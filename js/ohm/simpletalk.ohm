 SimpleTalk {
 	Script
		= ScriptPart+ end

	ScriptPart
		= MessageHandler
		| comment
		| lineTerminator

	// Function definition follows the HT convention
	// """
	// message messageName [parameterList]
	//     statementList
	// end messageName
	// """
	// Note: to distinguish from functions message handler parameters are not
	// parenthetical; moreover, message names are more restrictive
	MessageHandlerOpen
		= "on" messageName ParameterList? lineTerminator

	MessageHandlerClose
		= "end" messageName

	MessageHandler
		= MessageHandlerOpen StatementList? MessageHandlerClose

	// TODO should we insist that authered messages start with a lower case letter?
	Message
		= systemMessage ParameterList? --system
		// TODO do we need to prevent keyword/built in message overload?
		| messageName ParameterList? --authoredMessage

	// Any comma-separated string of tokens
	// that can be used either as arguments to
	// a called function, arguments in a function
	// definition, or args in a message handler
	// definition
	ParameterList (parameter list)
		// TODO do we need to prevent keyword overload?
		= NonemptyListOf<#(letter | digit)+, ", ">

	StatementList (a statement list, comments included)
		= StatementLine+

	StatementLine (a statement line)
		= Statement lineTerminator+

	// Note we explicitly exclude keywords, i.e. control
	Statement (a statement)
		= ~"end" Command

	Command (a command statement)
   		= "go to" ("next" | "previous") systemObject --goToDirection
   		| "go to" systemObject objectId --goToByReference
		| "answer" stringLiteral --answer
		| "delete" "this"? systemObject objectId? --deleteModel
		| "add" systemObject stringLiteral? "to"? ("this" | "current")? systemObject? objectId? --addModel
		| "set" stringLiteral "to" stringLiteral "in"? ("this" | "current")? systemObject? objectId? --setProperty
		| command_arbitrary

	command_arbitrary (an arbitrary command)
		= letter+

	systemObject (system object such as card, stack etc)
		= ("c" | "C") "ontainer" | ("b"| "B") "ackground" | ("b" | "B") "utton" | ("c" | "C") "ard" | ("f" | "F") "ield" | ("s" | "S") "tack" | ("w" | "W") "indow" | ("t"| "T") "oolbox"

	// TODO do we want to restrict message names (start with lowercase etc)?
	// Note: we prevent keyword overloading
	messageName (message name)
		= ~(keyword end) letter+

	systemMessage (system message)
		= "systemEvent" | "arrowKey"
		| "close" systemObject? --closeObject
		| "commandKeyDown"| "controlKey"
		| "delete" systemObject --deleteObject
		| "doMenu" | "enterInField" | "enterKey" | "exitField" | "functionKey"
		| "help" | "hide menubar" | "idle" | "keyDown"
		| "mouse" ("DoubleClick" | "DownInPicture" | "Down" | "Enter" | "Leave" | "StillDown" | "UpInPicture" | "Up" | "Within") --mouseEvent
		| "moveWindow"
		| "new" systemObject --newObject
		| "open" systemObject --openObject
		| "quit" | "resumeStack" | "resume" | "returnInField" | "returnKey" | "show menubar"
		| "sizeWindow" | "startUp" | "suspendStack" | "suspend" | "tabKey"

	// We need to prevent keyword overload since these are core control flow indicators
	keyword (a keyword)
		= "do" | "next" | "else" | "on" | "end" | "pass" | "exit" | "repeat" | "function" | "return" | "global" | "send" | "if" | "then"

	objectId (an identifier of an object, string, numeric or mixed)
		= ~systemObject (letter | digit)*


	// Helper utilities
	// Accounts for singular and plural word (i.e. with and without 's')
	singPlu<x> = x "s"?


	// TODO
	comment
		= "--"(letter | whitespace | digit)+


	// A string literal in SimpleTalk is any string
	// without line terminators wrapped in open and
	// closing quotes
	stringLiteral
		= quoteMark nonLineTerminator+ quoteMark

	quoteMark = "\""

	// Basic whitespace and line termination handling.
	// Note that we override the default Ohm definition
	// of `space` to only be spaces or tabs, and NOT
	// any of the newline characters
	space := whitespace
		whitespace = "\t"
		| "\x0B"    -- verticalTab
		| "\x0C"    -- formFeed
		| " "
		| "\u00A0"  -- noBreakSpace
		| "\uFEFF"  -- byteOrderMark
		| unicodeSpaceSeparator

	unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
	lineTerminator = "\n" | "\r" | "\u2028" | "\u2029" | "\r\n"
	nonLineTerminator = ~lineTerminator (alnum | whitespace)
}
