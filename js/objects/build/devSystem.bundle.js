/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/objects/System.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/objects/ExecutionStack.js":
/*!**************************************!*\
  !*** ./js/objects/ExecutionStack.js ***!
  \**************************************/
/*! exports provided: ExecutionStack, ActivationContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExecutionStack", function() { return ExecutionStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivationContext", function() { return ActivationContext; });
/**
 * ExecutionStack
 * ---------------------------------
 * I am an object that manages a stack of
 * ActivationContext objects.
 * I am designed to be used by System as the
 * global execution stack.
 *
 */

class ExecutionStack {
    constructor(){
        this._stack = [];
        this._globals = {};

        // Bound methods
        this.pop = this.pop.bind(this);
        this.push = this.push.bind(this);
        this.setGlobal = this.setGlobal.bind(this);
        this.getGlobal = this.getGlobal.bind(this);
    }

    pop(){
        if(!this._stack.length){
            return null;
        }
        return this._stack.pop();
    }

    push(anActivation){
        this._stack.push(anActivation);
    }

    setGlobal(varName, value){
        this._globals[varName] = value;
    }

    getGlobal(varName){
        return this._globals[varName];
    }

    get current(){
        if(!this._stack.length){
            return null;
        }
        return this._stack[this._stack.length - 1];
    }

    get previous(){
        if(!this._stack.length >= 2){
            return null;
        }
        return this._stack[this._stack.length - 2];
    }
};

class ActivationContext {
    constructor(messageName, part, incomingMessage, handlerFunction){
        this.part = part;
        this.messageName = messageName;
        this.message = incomingMessage;
        this.handlerFunction = handlerFunction;
        this._locals = {};

        // Bound methods
        this.get = this.get.bind(this);
        this.getLocal = this.getLocal.bind(this);
        this.setLocal = this.setLocal.bind(this);
    }

    get(varName){
        let localValue = this.getLocal(varName);
        if(localValue !== undefined){
            return localValue;
        };
        // otherwise try to return a global
        // variable
        return window.System.executionStack.getGlobal(varName);
    }

    getLocal(varName){
        return this._locals[varName];
    }

    setLocal(varName, value){
        this._locals[varName] = value;
    }
}




/***/ }),

/***/ "./js/objects/System.js":
/*!******************************!*\
  !*** ./js/objects/System.js ***!
  \******************************/
/*! exports provided: System, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return System; });
/* harmony import */ var _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parts/Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parts/Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parts/Button.js */ "./js/objects/parts/Button.js");
/* harmony import */ var _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parts/Field.js */ "./js/objects/parts/Field.js");
/* harmony import */ var _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parts/WorldStack.js */ "./js/objects/parts/WorldStack.js");
/* harmony import */ var _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parts/Window.js */ "./js/objects/parts/Window.js");
/* harmony import */ var _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parts/Drawing.js */ "./js/objects/parts/Drawing.js");
/* harmony import */ var _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parts/Audio.js */ "./js/objects/parts/Audio.js");
/* harmony import */ var _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parts/Browser.js */ "./js/objects/parts/Browser.js");
/* harmony import */ var _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parts/Resource.js */ "./js/objects/parts/Resource.js");
/* harmony import */ var _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parts/Image.js */ "./js/objects/parts/Image.js");
/* harmony import */ var _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parts/Area.js */ "./js/objects/parts/Area.js");
/* harmony import */ var _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./views/WorldView.js */ "./js/objects/views/WorldView.js");
/* harmony import */ var _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./views/StackView.js */ "./js/objects/views/StackView.js");
/* harmony import */ var _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./views/ButtonView.js */ "./js/objects/views/ButtonView.js");
/* harmony import */ var _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./views/CardView.js */ "./js/objects/views/CardView.js");
/* harmony import */ var _views_WindowView__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./views/WindowView */ "./js/objects/views/WindowView.js");
/* harmony import */ var _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./views/FieldView.js */ "./js/objects/views/FieldView.js");
/* harmony import */ var _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./views/drawing/DrawingView.js */ "./js/objects/views/drawing/DrawingView.js");
/* harmony import */ var _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./views/ImageView.js */ "./js/objects/views/ImageView.js");
/* harmony import */ var _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./views/AreaView.js */ "./js/objects/views/AreaView.js");
/* harmony import */ var _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./views/AudioView.js */ "./js/objects/views/AudioView.js");
/* harmony import */ var _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./views/BrowserView.js */ "./js/objects/views/BrowserView.js");
/* harmony import */ var _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./views/ResourceView.js */ "./js/objects/views/ResourceView.js");
/* harmony import */ var _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./views/Halo.js */ "./js/objects/views/Halo.js");
/* harmony import */ var _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./views/navigator/Navigator.js */ "./js/objects/views/navigator/Navigator.js");
/* harmony import */ var _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./views/editors/Editor.js */ "./js/objects/views/editors/Editor.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ohm-js */ "./node_modules/ohm-js/src/main.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(ohm_js__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./utils/clipboard.js */ "./js/objects/utils/clipboard.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./utils/handInterface.js */ "./js/objects/utils/handInterface.js");
/* harmony import */ var _utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./utils/merriamInterface.js */ "./js/objects/utils/merriamInterface.js");
/* harmony import */ var _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./utils/serialization.js */ "./js/objects/utils/serialization.js");
/* harmony import */ var _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../../plugins/plugins.js */ "./plugins/plugins.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * System Object
 * -------------------------------------
 * I am an object representing the "top" of the
 * sytem. I am the point of communication between
 * Models and Views.
 */
















































const DOMparser = new DOMParser();




const System = {
    name: "System",
    id: -1,
    isLoaded: false,
    partsById: {},
    _commandHandlers: {},
    _functionHandlers: {},
    _deserializer: null,

    // A dictionary mapping available ST resource (such as plugin) names
    availableResources: {},

    // A dictionary mapping part types like
    // 'button' to their classes (Button)
    availableParts: {},

    // A dictionary mapping part types like
    // 'button' to their view classes (ButtonView)
    availableViews: {},

    // A registry that keeps all system messages from
    // beginnign of time; TODO in the future we might want
    // to note keep all this in memory
    // each log consists of:
    // [aMessage, (sourceName, sourceId), (targetName, targetId)]
    messageLog: [],

    // Will be called when a page loads.
    // Checks for any view elements in the
    // page and attempts to find serialized
    // model state for each of them. If present,
    // deserializes the model and attaches it
    // to the view.
    initialLoad: function(){
        // load the available resources
        // these might be needed down the line
        this.loadResources();

        // If we have a serialization script tag
        // containing JSON of serialized information,
        // attempt to load from it
        let serializationEl = document.getElementById('serialization');
        if(serializationEl && serializationEl.text != ""){

            this.deserialize()
            // this.deserialize()
                .then(() => {
                    this.sendInitialOpenMessages();
                    System.navigator.setModel(
                        System.partsById['world']
                    );

                    // By default, we render the World in the
                    // Comprehensive Editor
                    this.editor.render(this.world);
                })
                .then(() => {
                    this.hideLoadingScreen();
                });
        } else {
            this.loadFromEmpty();
 
            // By default, we render the World in the
            // Comprehensive Editor
            this.editor.render(this.world);
            this.hideLoadingScreen();
        }

        // Attach a new clipboard instance
        this.clipboard = new _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__["default"](this);

        // By this point we should have a WorldView with
        // a model attached.
        this.isLoaded = true;
    },

    loadResources: function() {
        Object.keys(_plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"]).forEach((k) => {
            this.availableResources[k] = _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"][k];
        });
    },

    loadFromEmpty: function(){
        let worldModel = new this.availableParts['world']();
        this.partsById[worldModel.id] = worldModel;
        let worldView = document.createElement(
            this.tagNameForViewNamed('world')
        );
        worldView.setModel(worldModel);
        document.body.appendChild(worldView);

        // Create initial stack model
        let initStack = this.newModel('stack', worldModel.id);

        // Create initial card model for that stack
        let initCard = this.newModel('card', initStack.id);

        // Update current stack and card ids 
        worldModel.partProperties.setPropertyNamed(
            worldModel,
            'current',
            initStack.id
        );
        initStack.partProperties.setPropertyNamed(
            initStack,
            'current',
            initCard.id
        );
        // Update serialization
        this.serialize();

        this.sendInitialOpenMessages();
        System.navigator.setModel(
            System.partsById['world']
        );
    },

    sendInitialOpenMessages: function(){
        // Send the openWorld message to the WorldStack
        let world = this.partsById['world'];
        world.sendMessage({
            type: 'command',
            commandName: 'openWorld',
            args: [],
            shouldIgnore: true
        }, world);
        world.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, world.currentStack);
        world.currentStack.sendMessage({
            type: 'command',
            commandName: 'openCard',
            args: [],
            shouldIgnore: true
        }, world.currentStack.currentCard);
    },

    sendMessage: function(aMessage, source, target){
        if(!target || target == undefined){
            throw new Error('Messages must be sent with target receivers specified!');
        }

        // keep track of all sources which pass this message
        if (!("senders" in aMessage)) {
            aMessage["senders"] = [];
        }
        aMessage.senders.push({
            name: source.name,
            id: source.id,
        });

        return target.receiveMessage(aMessage);
    },

    receiveMessage: function(aMessage){
        switch(aMessage.type){
            case 'newView':
                return this.newView(
                    aMessage.viewType,
                    aMessage.modelId
                );
            case 'compile':
                return this.compile(aMessage);
            case 'command':
                return this.receiveCommand(aMessage);
            default:
                return this.doesNotUnderstand(aMessage);
        }
    },

    doesNotUnderstand: function(aMessage){
        // If the message has the shouldIgnore property
        // set to true, it means we should just swallow
        // this message if we don't understand it. This is
        // useful for messages like mouse events on buttons
        // which are not captured by default and would otherwise
        // end up arriving to this System object via the
        // message delegation chain.
        if(aMessage.shouldIgnore){
            return;
        }
        let originalSender = this.partsById[aMessage.senders[0].id];
        let msg = {
            type: "error",
            name: "MessageNotUnderstood",
            message: aMessage
        };
        originalSender.sendMessage(msg, originalSender);
    },

    compile: function(aMessage){
        let targetObject = this.partsById[aMessage.targetId];
        if(!targetObject || targetObject == undefined){
            throw new Error(`System could not compile target object ${aMessage.targetId}`);
        }


        // Attempt to parse the incoming SimpleTalk script string.
        // If there are grammatical errors, report them and bail.
        // Otherwise, create a new semantics on the targetPart, add
        // the required semantic operations, and interpret the top
        // level of the script, which will create the JS handler functions
        let parsedScript = languageGrammar.match(aMessage.codeString);
        if(parsedScript.failed()){
            // consider using the parse data from trace
            // example: let tracedScript = languageGrammar.trace(aMessage.codeString);
            // let tree = tracedScript.toString();
            let msg = {
                type: "error",
                name: "GrammarMatchError",
                parsedScript: parsedScript,
                partId: aMessage.targetId
            };
            targetObject.sendMessage(msg, targetObject);
        } else {
            // First, clear out any currently compiled handlers
            // since the incoming script might get rid of them
            targetObject._commandHandlers = {};

            // Create a semantics object whose partContext
            // attribute is set to be the target object.
            targetObject._semantics = languageGrammar.createSemantics();
            targetObject._semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(targetObject, this)
            );
            targetObject._semantics(parsedScript).interpret();
        }


        // Be sure to then update the
        // serialization for the target
        // part, thus adding the script to
        // its serialization
        if(aMessage.serialize){
            this.serialize();
        }
    },

    receiveCommand: function(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            let boundHandler = handler.bind(this);
            let activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            this.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            this.executionStack.pop();
            return result;
        } else {
            return this.doesNotUnderstand(aMessage);
        }
    },

    newModel: function(kind, ownerId, name, buildView=true){
        // Lookup the instance of the model that
        // matches the owner's id
        let ownerPart = this.partsById[ownerId];
        if(!ownerPart || ownerPart == undefined){
            throw new Error(`System could not locate owner part with id ${ownerId}`);
        }

        // Find the class constructor for the kind of
        // part requested as a new model. If not known,
        // throw an error
        let modelClass = this.availableParts[kind];
        if(!modelClass){
            throw new Error(`Cannot create unknown part type: ${kind}`);
        }
        let model = new modelClass(ownerPart);
        if(name){
            model.partProperties.setPropertyNamed(model, 'name', name);
        }
        this.partsById[model.id] = model;

        // Any created part might initialize its
        // own subparts. We need to let the System know
        // about those too
        model.subparts.forEach(subpart => {
            this.partsById[subpart.id] = subpart;
        });

        // If there is a valid owner part for
        // the newly created part model,
        // add the new model to the owner's
        // subparts list
        if(ownerPart){
            ownerPart.addPart(model);
        }

        // Add the System as a property subscriber to
        // the new model. This will send a message to
        // this System object whenever any of this model's
        // properties have changed
        model.addPropertySubscriber(this);

        if(buildView){
            // See if there is already a view for the model.
            // If not, create and attach it.
            let viewForModel = this.findViewById(model.id);
            if(!viewForModel){
                this.newView(model.type, model.id);
            }
        }

        // If the owner part is either a world or a stack
        // and has only one stack or card child, respectively, set
        // that child to be the current
        if(ownerPart.type == "world" || ownerPart.type == "stack"){
            let currentId = ownerPart.partProperties.getPropertyNamed(ownerPart, "current");
            if(!currentId){
                ownerPart.partProperties.setPropertyNamed(ownerPart, "current", model.id);
            }
        }

        // Finally send the model a message to announce that it is new
        // to the world, but don't 
        this.sendMessage({
            type: 'command',
            commandName: 'newModel',
            args: [],
            shouldNotDelegate: true,
            shouldIgnore: true
        }, this, model);

        return model;
    },

    newProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find newProperty target!`);
        }

        if(target.partProperties.findPropertyNamed(propName)){
            // TODO this should be a ST error
            throw new Error(`Part ${target.id} already has property "${propName}"`);
        }
        // we only add basic property and the default value is null
        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__["BasicProperty"](propName, null);
        customProp.add(newProp);
    },

    deleteProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find deleteProperty target!`);
        }

        // Note: this will only delete custom properties which is what we want
        let prop = target.partProperties.findPropertyNamed(propName);

        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        customProp.delete(prop);
    },

    setProperty(senders, propName, value, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find setProperty target!`);
        }

        target.partProperties.setPropertyNamed(
            target,
            propName,
            value
        );
    },

    // Remove the model with the given ID from
    // the System's registry, as well as from the subparts
    // array of any owners
    deleteModel: function(modelId){
        let foundModel = this.partsById[modelId];
        if(!foundModel){
            return false;
        }
        // When removing a card or a stack be sure it is not the only one
        // and if it is the current card or stack we should go to the next one
        // before removing it
        if(foundModel.type == "card" || foundModel.type == "stack"){
            let sameTypeSubparts = foundModel._owner.subparts.filter((p) => {return p.type == foundModel.type;});
            if(sameTypeSubparts.length == 1){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the only ${foundModel.type}`);
            } else if(modelId == this.getCurrentStackModel().id  || modelId == this.getCurrentCardModel().id){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the current ${foundModel.type}`);
            }
        }

        // Make sure to stop all stepping
        // on the Part, otherwise stepping
        // intervals will error infinitely
        foundModel.stopStepping();

        // make sure the editor is closed
        foundModel.closeEditorCmdHandler();

        let ownerModel = foundModel._owner;
        if(ownerModel){
            ownerModel.removePart(foundModel);
        }

        delete this.partsById[modelId];
        this.removeViews(modelId);

        // Serialize the state
        this.serialize();
        return true;
    },

    // Remove all views with the corresponding
    // model id from the DOM
    removeViews: function(modelId){
        let views = Array.from(this.findViewsById(modelId));
        views.forEach(view => {
            let parentEl = view.parentElement;
            view.parentElement.removeChild(view);
            // Dispatch a CustomEvent on the parentElement
            // indicating that this part has been removed, and
            // any view utilities that care can be notified.
            let event = new CustomEvent('st-view-removed', {
                detail: {
                    partType: view.model.type,
                    partId: modelId,
                    ownerId: null
                } 
            });
            parentEl.dispatchEvent(event);
        });
        let lenses = this.findLensViewsById(modelId);
        lenses.forEach(lensView => {
            lensView.parentElement.removeChild(lensView);
        });
    },

    newView: function(partName, modelId, parentId){
        let model = this.partsById[modelId];
        if(!model || model == undefined){
            throw new Error(`System does not know part ${partName}[${modelId}]`);
        }
        if(!partName){
            partName = model.type;
        }

        // Find the parent model id. This will
        // help us find the parent view element for
        // appending the new element.
        if (!parentId){
            parentId = model._owner.id;
        }
        let parentElement = this.findViewById(parentId);
        if(!parentElement){
            throw new Error(`Could not find parent element for ${partName}[${modelId}] (model owner id: ${model._owner.id})`);
        }

        // Create the new view instance,
        // append to parent, and set the model
        let newView = document.createElement(
            this.tagNameForViewNamed(partName)
        );
        newView.setModel(model);
        this.sendMessage({
            type: "viewChanged",
            changeName: "subpart-new",
            args: [newView]
        }, model._owner, parentElement);

        // Dispatch a CustomEvent on the parentElement
        // indicating that this part has been created, and
        // any view utilities that care can be notified.
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: model.type,
                partId: model.id,
                ownerId: model._owner.id || null
            } 
        });
        parentElement.dispatchEvent(event);

        // See if there are lens views and update
        // those as well
        let lensViews = this.findLensViewsById(parentId);
        lensViews.forEach(lensView => {
            let newLensView = document.createElement(
                this.tagNameForViewNamed(partName)
            );
            newLensView.setModel(model);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', modelId);
            newLensView.setAttribute('role', 'lens');
            lensView.appendChild(newLensView);
        });

        // TODO do we want to allow the possibiliy of a view on an
        // element but no subpart of that view on the element?

        // For all subparts of this model, call
        // the newView method recursively
        model.subparts.forEach(subpart => {
            this.newView(subpart.type, subpart.id);
        });

        return newView;
    },

    registerPart: function(name, cls){
        this.availableParts[name] = cls;
    },

    registerView: function(name, cls){
        this.availableViews[name] = cls;
    },

    tagNameForViewNamed: function(name){
        return `st-${name}`;
    },

    // Find the first matching view element
    // with the given id
    findViewById: function(id){
        return document.querySelector(`[part-id="${id}"]`);
    },

    findLensViewsById: function(id){
        return Array.from(document.querySelectorAll(`[lens-part-id="${id}"]`));
    },

    // Find all matching view elements with
    // the given part id
    findViewsById: function(id){
        return document.querySelectorAll(`[part-id="${id}"]`);
    },

    // return the model corresponding to the current stack
    getCurrentStackModel: function(){
        let world = this.getWorldStackModel();
        return world.currentStack;
    },

    // return the model corresponding to the current card
    getCurrentCardModel: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.currentCard;
    },

    // return the model corresponding to the world stack
    getWorldStackModel: function(){
        return this.partsById['world'];
    },

    // return the model corresponding script editor st-field
    // Note: we use the window.model.target to locate the corresponding window
    // but return its st-field subpart
    findScriptEditorByTargetId: function(id){
        let scriptEditorField;
        let windows = document.querySelectorAll("st-window");
        windows.forEach((w) => {
            let target = w.model.target;
            if(target && target.id === id){
                scriptEditorField = w.querySelector("st-field");
            }
        });
        return scriptEditorField;
    },

    serialize: function(){
        let world = this.partsById['world'];
        if(!world){
            throw new Error(`No world found!`);
        }
        let serializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STSerializer"](this);
        let serialString = serializer.serialize(this.partsById['world'], true);

        // If there is not a script tag in the
        // body for the serialization, create it
        let serializationScriptEl = document.getElementById('serialization');
        if(!serializationScriptEl){
            serializationScriptEl = document.createElement('script');
            serializationScriptEl.id = 'serialization';
            serializationScriptEl.type = 'application/json';
            document.body.append(serializationScriptEl);
        }
        serializationScriptEl.textContent = serialString;
    },

    deserialize: function(){
        let serializationEl = document.getElementById('serialization');
        if(!serializationEl){
            throw new Error(`No serialization found for this page`);
        }
        this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
        return this._deserializer.deserialize(serializationEl.textContent);
    },

    // Return a *complete* HTML
    // representation of the current application
    // that can later be saved to a file
    getFullHTMLString: function(){
        let clonedDocument = document.cloneNode(true);
        let world = clonedDocument.querySelector('st-world');
        let nav = clonedDocument.querySelector('st-navigator');
        if(world){
            world.remove();
        }
        if(nav){
            nav.remove();
        }

        return clonedDocument.documentElement.outerHTML;
    },


    /** Navigation of Current World **/
    goToNextStack: function(){
        let world = this.partsById['world'];
        return world.goToNextStack();
    },

    goToPrevStack: function(){
        let world = this.partsById['world'];
        return world.goToPrevStack();
    },

    goToStackById: function(stackId){
        let world = this.partsById['world'];
        return world.goToStackById(stackId);
    },

    /** Navigation of Current Stack **/
    goToNextCard: function(){
        let currentStack = this.getCurrentStackModel(); 
        return currentStack.goToNextCard();
    },

    goToPrevCard: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToPrevCard();
    },

    goToCardById: function(cardId){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToCardById(cardId);
    },

    openEditorForPart: function(partId){
        this.editor.render(
            this.partsById[partId]
        );
        this.editor.open();
    },

    closeEditorForPart: function(partId){
        this.editor.close();
    },

    showLoadingScreen: function(){
        return new Promise((resolve, reject) => {
               let container = document.createElement('div');
               container.innerHTML = `<img src="/images/simpletalk-calligraphy1.svg"/>
<h1>Loading...</h1>`;
               container.id = "loading-screen";
               container.style.display = 'flex';
               container.style.flexDirection = 'column';
               container.style.alignItems = 'center';
               container.style.justifyContent = 'space-around';
               container.children[0].style.width = "45vw";
               container.style.width = "100vw";
               container.style.height = "100vh";
               container.style.backgroundColor = "white";
               container.style.position = "absolute";
               document.body.append(container);
               return resolve();
        });
    },

    hideLoadingScreen: function(){
        let loadingDiv = document.getElementById('loading-screen');
        if(loadingDiv){
            loadingDiv.remove();
        }
    }
};

/** Add Default System Command Handlers **/
//System._commandHandlers['deleteModel'] = System.deleteModel;
System._commandHandlers['deleteModel'] = function(senders, ...rest){
    System.deleteModel(...rest);
};
//System._commandHandlers['newModel'] = System.newModel;
System._commandHandlers['newModel'] = function(senders, ...rest){
    System.newModel(...rest);
    this.serialize();
};
//System._commandHandlers['newView'] = System.newView;
System._commandHandlers['newView'] = function(senders, ...rest){
    System.newView(...rest);
};
System._commandHandlers['newProperty'] = System.newProperty;
System._commandHandlers['setProperty'] = System.setProperty;
System._commandHandlers['deleteProperty'] = System.deleteProperty;

System._commandHandlers['ask'] = function(senders, question){
    // Use the native JS prompt function to ask the question
    // and return its value.
    // By returning here, we expect the implicit variable
    // "it" to be set inside any calling script
    return prompt(question);
};

System._commandHandlers['putInto'] = function(senders, value, variableName, global){
    if(global){
        System.executionStack.setGlobal(variableName, value);
        return;
    }
    // Because we push all handlers onto the execution stack,
    // the putInto handler is currently at the top of the stack.
    // In order to modify the caller's variables, we need to
    // find the context that is one previous on the stack
    if(System.executionStack.previous){
        System.executionStack.previous.setLocal(variableName, value);
    } else {
        throw new Error(`ExecutionStack Error: #putInto on top of empty stack!`);
    }
};

System._commandHandlers['answer'] = function(senders, value){
    alert(value.toString());
};

System._commandHandlers['go to direction'] = function(senders, directive, objectName){
    switch(objectName) {
        case 'card':
            switch(directive){
                case 'next':
                    this.goToNextCard();
                    break;

                case 'previous':
                    this.goToPrevCard();
                    break;
            }
            break;

        case 'stack':
            switch(directive){
                case 'next':
                    this.goToNextStack();
                    break;

                case 'previous':
                    this.goToPrevStack();
                    break;
            }
            break;

        default:
            alert(`"go to" not implemented for ${objectName}`);

    }
};

System._commandHandlers['go to'] = function(senders, id){
    let model = this.partsById[id];
    if(!model){
        alert(`"go to" target not found`);
    }
    switch(model.type) {
    case 'card':
        this.goToCardById(id);
        break;

    case 'stack':
        this.goToStackById(id);
        break;

    default:
        alert(`"go to" not implemented for ${model.type}`);

    }
};

System._commandHandlers['go to website'] = function(senders, url){
    window.location.href = url;
};

//Import a world, i.e. its stacks from another source
System._commandHandlers['importWorld'] = function(sender, sourceUrl){
    if(!sourceUrl){
        sourceUrl = window.prompt("Choose World location");
    }
    fetch(sourceUrl)
        .then(response => {
            let contentType = response.headers.get('content-type');
            if(!contentType.startsWith('text/html')){
                throw new Error(`Invalid content type: ${contentType}`);
            }
            return response.blob().then(blob => {
                let reader = new FileReader();
                reader.readAsText(blob);
                reader.onloadend = () => {
                    let parsedDocument = DOMparser.parseFromString(reader.result, "text/html");
                    // there is no .getElementById() for a node HTML parsed document!
                    let serializationEl = parsedDocument.querySelector('#serialization');
                    if(!serializationEl){
                        console.log(`No serialization found for ${sourceUrl}`);
                        alert(`World "${sourceUrl}" not found`);
                        return;
                    }
                    this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
                    this._deserializer.targetId = 'world'; // We will insert the stacks into the world
                    return this._deserializer.importFromSerialization(
                        serializationEl.textContent,
                        (part) => {
                            // Return only Stacks that are direct subparts
                            // of the world.
                            let isStack = part.type == 'stack';
                            let isWorldSubpart = part._owner && part._owner.type == 'world';
                            return isStack && isWorldSubpart;
                        }
                    );
                };
            });
        })
        .then(() => {
            // Manually set the _src.
            // This ensures that we don't infinitely
            // call the load operation
            this._src = sourceUrl;
            /*
            // Stop and restart hand interface if it's running.
            if (handInterface.handDetectionRunning) {
                handInterface.stop();
                handInterface.start();
            }
            */
        })
        .catch(err => {
            alert("Could not load world");
            console.error(err);
        });
};

System._commandHandlers['openScriptEditor'] = function(senders, targetId){
    let target = this.partsById[targetId];
    let targetName = target.partProperties.getPropertyNamed(target, "name");
    if(targetName){
        targetName = `"${targetName}"`;
    }
    let name = `Script For ${target.name} ${targetName}`;

    // If there is already a dinwo opened with this name, then
    // we return without creating anything new.
    let found = Object.values(System.partsById).filter(part => {
        let partName;
        if(part.type == 'window'){
            partName = part.partProperties.getPropertyNamed(
                part,
                'title'
            );
        }
        return (part.type == 'window' && name == partName);
    });
    if(found.length){
        return;
    }

    let currentCard = this.getCurrentCardModel();
    let window = this.newModel('window', currentCard.id);
    let area = this.newModel('area', window.id);
    let scriptField = this.newModel('field', area.id);
    let saveButton = this.newModel('button', area.id);


    // setup the window and stack properties
    window.setTarget(target);
    window.partProperties.setPropertyNamed(window, "title", name);
    window.partProperties.setPropertyNamed(window, "height", 200);
    window.partProperties.setPropertyNamed(window, "width", 500);
    window.partProperties.setPropertyNamed(window, 'top', 100);
    window.partProperties.setPropertyNamed(window, 'left', 100);

    area.partProperties.setPropertyNamed(area, "layout", "list");
    area.partProperties.setPropertyNamed(area, "list-direction", "column");
    area.partProperties.setPropertyNamed(area, "width", "fill");
    area.partProperties.setPropertyNamed(area, "height", "fill");

    // script field
    let targetScript = target.partProperties.getPropertyNamed(target, "script"); 
    scriptField.partProperties.setPropertyNamed(scriptField, "text", targetScript);
    scriptField.partProperties.setPropertyNamed(scriptField, "height", "fill");
    scriptField.partProperties.setPropertyNamed(scriptField, "width", "fill");

    // Setup syntax highlight
    scriptField.sendMessage({
        type: "command",
        commandName: "highlightSyntax",
        args: []
    }, scriptField);


    // setup up the save button properties
    saveButton.partProperties.setPropertyNamed(saveButton, "name", "Save Script");
    saveButton.partProperties.setPropertyNamed(saveButton, "width", "fill");
    saveButton.partProperties.setPropertyNamed(saveButton, "text-size", 20);
    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);

    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);
    let saveScript = `on click\n\ttell target to set "script" to the "text" of first field\nend click`; 
    saveButton.partProperties.setPropertyNamed(saveButton, "script", saveScript);
};

System._commandHandlers['SimpleTalk'] = function(senders){
    return System.grammar.source.sourceString;
}

System._commandHandlers['openDebugger'] = function(senders, partId, type, name){
    let target = this.partsById[partId];
    // Create the Field model and attach to current card
    let currentCard = this.getCurrentCardModel();
    let windowModel = this.newModel('window', currentCard.id);
    let areaModel = this.newModel('area', windowModel.id);
    // name the window and setup basic layout
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'name',
        "debugger"
    );
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'title',
        `Message Not Understood : ${name}`
    );
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'width',
        400
    );
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'height',
        200
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'layout',
        "list"
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'list-direction',
        "column"
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'width',
        "fill"
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'height',
        "fill"
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'allow-scrolling',
        true
    );
    // fill in all the available commands for the given part
    Object.keys(target.commandHandlerRegistry).forEach((key) =>{
        let text = key;
        let isPrivate = target.commandHandlerRegistry[key].private;
        if(isPrivate){
            text += " (private)";
        }
        let fieldModel = this.newModel('field', areaModel.id);
        fieldModel.partProperties.setPropertyNamed(
            fieldModel,
            'text',
            text
        );
        fieldModel.partProperties.setPropertyNamed(
            fieldModel,
            'editable',
            false
        );
        fieldModel.partProperties.setPropertyNamed(
            fieldModel,
            'width',
            "fill"
        );
        fieldModel.partProperties.setPropertyNamed(
            fieldModel,
            'height',
            20
        );
    });
};

System._commandHandlers['openGrammar'] = function(senders, partId, ruleName){
    // first make sure that there are no grammar windows open already
    let windows = Object.values(window.System.partsById).filter((part) => {return part.name == "Window";});
    let grammarWindows = windows.filter((window) => {
        return window.partProperties.getPropertyNamed(window, "name") == "Simpletalk Grammar";
    });
    if(grammarWindows.length){
        return;
    }
    let target = this.partsById[partId];
    // Create the Field model and attach to current card
    let currentCard = this.getCurrentCardModel();
    let windowModel = this.newModel('window', currentCard.id);
    let areaModel = this.newModel('area', windowModel.id);
    // name the window and setup basic layout
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'name',
        "Simpletalk Grammar"
    );
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'title',
        "Simpletalk Grammar"
    );
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'width',
        400
    );
    windowModel.partProperties.setPropertyNamed(
        windowModel,
        'height',
        200
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'layout',
        "list"
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'list-direction',
        "column"
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'width',
        "fill"
    );
    areaModel.partProperties.setPropertyNamed(
        areaModel,
        'height',
        "fill"
    );
    // add the grammar text
    let text = System.grammar.source.sourceString;
    let fieldModel = this.newModel('field', areaModel.id);
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'text',
        text
    );
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'editable',
        false
    );
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'width',
        "fill"
    );
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'height',
        "fill"
    );
};

System._commandHandlers['saveHTML'] = function(senders){
    // Stop hand recognition if it's running.
    let handRecognitionOriginallyRunning = _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionRunning;
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
    this.serialize();

    let stamp = Date.now().toString();
    let serializedPage = this.getFullHTMLString();
    let typeInfo = "data:text/plain;charset=utf-8";
    let url = `${typeInfo},${encodeURIComponent(serializedPage)}`;

    let anchor = document.createElement('a');
    anchor.style.display = "none";
    document.body.append(anchor);
    anchor.href = url;
    anchor.download = `SimpleTalkSnapshot_${stamp}.html`;
    anchor.click();
    window.URL.revokeObjectURL(url);
    anchor.parentElement.removeChild(anchor);
    // Start hand recognition if it was running.
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    }
};

System._commandHandlers['tell'] = (senders, targetId, deferredMessage) => {
    let targetPart = System.partsById[targetId];
    if(!targetPart){
        throw new Error(`Attempted to tell part id ${targetId}: no such part!`);
    }
    targetPart.sendMessage(deferredMessage, targetPart);
};

System._commandHandlers['toggleHandDetection'] = () => {
    if (_utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionModel === null) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    } else {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
};

System._commandHandlers['merriam'] = (senders, docId) => {
    const sender = System.partsById[senders[0].id];
    Object(_utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__["default"])(sender, docId);
};

System._commandHandlers['globalInterrupt'] = () => {
    // cycle through all the parts and set the "stepping" property to false
    Object.values(System.partsById).forEach((part) => {
        if(part.isStepping){
            part.partProperties.setPropertyNamed(part, "stepping", false);
        }
    });
};


/** Register the initial set of parts in the system **/
System.registerPart('card', _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
System.registerPart('stack', _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('button', _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
System.registerPart('world', _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
System.registerPart('window', _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('drawing', _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
System.registerPart('image', _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
System.registerPart('area', _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
System.registerPart('audio', _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
System.registerPart('browser', _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
System.registerPart('resource', _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/** Register the initial set of views in the system **/
System.registerView('button', _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
System.registerView('stack', _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
System.registerView('world', _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
System.registerView('card', _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__["default"]);
System.registerView('window', _views_WindowView__WEBPACK_IMPORTED_MODULE_16__["default"]);
System.registerView('field', _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__["default"]);
System.registerView('drawing', _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__["default"]);
System.registerView('image', _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__["default"]);
System.registerView('area', _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__["default"]);
System.registerView('audio', _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__["default"]);
System.registerView('browser', _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__["default"]);
System.registerView('resource', _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__["default"]);


// Convenience method for adding all of the
// available custom elements to the window object's
// customElements registry
System.registerCustomElements = function(){
    Object.keys(System.availableViews).forEach(partName => {
        let viewClass = System.availableViews[partName];
        let elementName = System.tagNameForViewNamed(partName);
        window.customElements.define(elementName, viewClass);
    });
};

// iniitalize the compiler and add it to the system
// Instantiate the grammar.
let languageGrammar;
if (window.grammar){
    // for testing it is sometimes convenient to load the grammar and add to window
    // see ./tests/preload.js for example
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammar(window.grammar);
} else {
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammarFromScriptElement();
}

System.grammar = languageGrammar;

// Set the exection stack on the
// System
System.executionStack = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ExecutionStack"]();

// Add a dynamic getter for the World for convenience
Object.defineProperty(System, 'world', {
    get: function(){
        return this.partsById['world'];
    }
});

document.addEventListener('DOMContentLoaded', () => {
    // Add the System object to window so
    // that it is global on the page. We do this
    // for both debugging and testing.
    window.System = System;
    // Add the possible views as webcomponents
    // in the custom element registry
    System.registerCustomElements();

    // Add any other non-part view CustomElements,
    // like the halo
    window.customElements.define('st-halo', _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__["default"]);
    window.customElements.define('st-navigator', _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__["default"]);
    window.customElements.define('st-editor', _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__["default"]);

    // Add nav
    System.navigator = document.createElement('st-navigator');
    document.body.appendChild(System.navigator);

    // Add comprehensive editor pane
    // if one is not already present in the markup
    let existingEditors = Array.from(document.querySelectorAll('st-editor'));
    existingEditors.forEach(editorEl => {
        editorEl.remove();
    });
    System.editor = document.createElement('st-editor');
    document.body.appendChild(System.editor);

    // Perform the initial setup of
    // the system
    System.showLoadingScreen()
        .then(() => {
            setTimeout(() => {
                System.initialLoad();
            }, 100);
        });
});

// add a message listener on window
// these can include message from a browser part
// for now filter those not coming from the origin
window.addEventListener("message", (event) => {
    if (event.origin !== window.origin)
        return;
    console.log(`Message to browser`);
    // TODO: maybe we need to deal with quote escapes directly
    // in the grammar
    let script = event.data.replaceAll("'", '"');
    // only statements are accepted for now
    let parsedScript = languageGrammar.match(script, "Statement");
    if(parsedScript.failed()){
        // for now just log that it failed
        console.log("failed to parse script for browser");
    } else {
        let semantics = languageGrammar.createSemantics();
        let world = System.partsById["world"];
        semantics.addOperation(
            'interpret',
            Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(world, System)
        );
        let msg = semantics(parsedScript).interpret();
        System.sendMessage(msg, world, System);
    }
});

// global interrupt
document.addEventListener('keydown', (event) => {
    if(event.ctrlKey && event.key == 'c'){
        System.sendMessage({
            type: "command",
            commandName: "globalInterrupt",
            args: []
        }, System, System);
    }
});





/***/ }),

/***/ "./js/objects/parts/Area.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Area.js ***!
  \**********************************/
/*! exports provided: Area, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Area", function() { return Area; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Area; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Area
 * ----------------------------------
 * I am a Area Part.
 * I represent a 'grouping' of subparts within
 * my owner part.
 * I contain the Layout properties set, and therefore
 * can display my contained subparts according to 
 * different layout properties than my ancestor
 * Card.
 *
 */



const sides = ["top", "bottom", "left", "right"];

class Area extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(...args){
        super(...args);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
            "browser",
            "window"
        ];

        // Add style props
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addLayoutStyleProps"])(this);

        // Set default width and height
        // for an empty area
        this.partProperties.setPropertyNamed(
            this,
            'width',
            50
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            50
        );
        this.partProperties.newBasicProp(
            'clipping',
            false
        );
        this.partProperties.newBasicProp(
            'allow-scrolling',
            false
        );
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
    }


    get type(){
        return 'area';
    }
};




/***/ }),

/***/ "./js/objects/parts/Audio.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Audio.js ***!
  \***********************************/
/*! exports provided: Audio, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Audio; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Audio extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadAudioFromSource", this.loadAudioFromSource);
        this.setPrivateCommandHandler("play", () => {this.play(true);});
        this.setPrivateCommandHandler("pause", () => {this.play(false);});
        this.setPrivateCommandHandler("stop", this.stop);

        // Bind component methods
        this.loadAudioFromSource = this.loadAudioFromSource.bind(this);
        this.play = this.play.bind(this);
        this.stop = this.stop.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'audio';
    }

    loadAudioFromSource(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    play(value){
        this.partProperties.setPropertyNamed(this, "play", value);
        this.partProperties.setPropertyNamed(this, "stop", false);
    }

    stop(){
        this.partProperties.setPropertyNamed(this, "play", false);
        this.partProperties.setPropertyNamed(this, "stop", true);
    }
};




/***/ }),

/***/ "./js/objects/parts/Browser.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Browser.js ***!
  \*************************************/
/*! exports provided: Browser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Browser", function() { return Browser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Browser; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Browser extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;
        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("setURLTo", this.setURL);
        this.setPrivateCommandHandler("forward", this.sendMessageToBrowser);

        // Bind component methods
        this.setURL = this.setURL.bind(this);
        this.sendMessageToBrowser = this.sendMessageToBrowser.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                5
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );
    }

    get type(){
        return 'browser';
    }

    setURL(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    sendMessageToBrowser(senders, message){
        let views = window.System.findViewsById(this.id);
        views.forEach((v) => {
            let iframe = v._shadowRoot.querySelector("iframe");
            iframe.contentWindow.postMessage(message, window.origin);
        });
    }
};




/***/ }),

/***/ "./js/objects/parts/Button.js":
/*!************************************!*\
  !*** ./js/objects/parts/Button.js ***!
  \************************************/
/*! exports provided: Button, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Button; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Button
 * ----------------------------------
 * I am a Button Part.
 * My owner is always a Card.
 * I am a clickable point of interaction on a Card,
 * whose functionality can be customized by the author.
 */




class Button extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner){
        super(owner);

        this.isButton = true;

        // Add Button-specific part properties
        this.partProperties.newDynamicProp(
            'selectedText',
            null, // readOnly (for now)
            this.getSelectedText,
            true, // readOnly,
        );

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 234, 149)", // var(--palette-yellow)
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-top-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-bottom-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-left-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-right-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-left',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-top',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );

    }

    get type(){
        return 'button';
    }

    //TODO: implement this property
    // getter for real
    getSelectedText(propName, propVal){
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Card.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Card.js ***!
  \**********************************/
/*! exports provided: Card, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Card", function() { return Card; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Card; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Card
 * --------------------------
 * I am a Card Part.
 * I represent a collection of Parts that is
 * displayed on the screen. My owner is always
 * a Stack Part.
 * I can contain any kind of Part, including
 * buttons and fields.
 */





class Card extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, name){
        super(owner);
        this.stack = this._owner;
        this.acceptedSubpartTypes = [
            "window", "button",
            "field", "area", "drawing",
            "image", "audio", "browser", "resource"
        ];
        this.isCard = true;

        // Add Card-specific part
        // properties
        this.partProperties.newBasicProp(
            'marked',
            false
        );
        this.partProperties.newBasicProp(
            'cantDelete',
            false
        );
        this.partProperties.newBasicProp(
            'dontSearch',
            false
        );
        this.partProperties.newBasicProp(
            'showPict',
            false
        );

        // If we are initializing with a name
        // set the name property
        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addLayoutStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(0, 75, 103)" // palette-blue
        );
    }

    get type(){
        return 'card';
    }
};




/***/ }),

/***/ "./js/objects/parts/Drawing.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Drawing.js ***!
  \*************************************/
/*! exports provided: Drawing, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Drawing", function() { return Drawing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Drawing; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Basic User Drawing Part
 */



const sides = ["top", "bottom", "left", "right"];

class Drawing extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner){
        super(owner);

        // Set new properties for this
        // part type
        this.partProperties.newBasicProp(
            'image',
            null
        );
        this.partProperties.newBasicProp(
            'mode',
            'drawing'
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)", //grey
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            'width',
            300
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            200
        );

        // We are using a distinct show-border
        // property to deal with being able to see
        // a drawing that is empty
        this.partProperties.newBasicProp(
            'show-border',
            true
        );

        // When drawing from a script/commands,
        // we will use this as the open canvas
        // whose image bytes will be set to the
        // image property
        this.activeCanvas = null;

        // Set up the drawing commands
        this.setupDrawingCommands();


        // Bind component methods
        this.setupDrawingCommands = this.setupDrawingCommands.bind(this);
        this.stroke = this.stroke.bind(this);
        this.moveTo = this.moveTo.bind(this);
        this.lineTo = this.lineTo.bind(this);
        this.beginDraw = this.beginDraw.bind(this);
        this.endDraw = this.endDraw.bind(this);
        this.clear = this.clear.bind(this);
        this.coordsFromString = this.coordsFromString.bind(this);
    }

    get type(){
        return 'drawing';
    }

    setupDrawingCommands(){
        this.setPrivateCommandHandler('lineTo', (senders, ...args) => {
            this.lineTo(...args);
        });
        this.setPrivateCommandHandler('moveTo', (senders, ...args) => {
            this.moveTo(...args);
        });
        this.setPrivateCommandHandler('beginDraw', (senders, ...args) => {
            this.beginDraw(...args);
        });
        this.setPrivateCommandHandler('finishDraw', (senders, ...args) => {
            this.endDraw(...args);
        });
        this.setPrivateCommandHandler('stroke', (senders, ...args) => {
            this.stroke(...args);
        });
        this.setPrivateCommandHandler('clear', (senders, ...args) => {
            this.clear(...args);
        });
    }

    /* Scriptable Drawing Commands */
    stroke(){
        if(this.isDrawing){
            // Hard-coded. Get from props
            // and link to views
            this.activeContext.strokeWidth = 10;
            this.activeContext.stroke();
        }
    }
    moveTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.moveTo(
                x,
                y
            );
        }
    }

    lineTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.lineTo(
                x,
                y
            );
        }
    }

    beginDraw(){
        if(this.isDrawing){
            return;
        }
        this.isDrawing = true;
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');

        // If there is currently image data set to the
        // image part property, we need to draw that image
        // onto the canvas first.
        let currentImage = this.partProperties.getPropertyNamed(
            this,
            'image'
        );
        if(currentImage){
            let img = new Image();
            img.onload = () => {
                this.activeContext.drawImage(img, 0, 0);
            };
            img.src = currentImage;
        }

        // Begin a drawing path
        this.activeContext.beginPath();
    }

    endDraw(){
        if(this.isDrawing){
            this.activeContext.closePath();
            this.activeContext.stroke();

            // Update the image property to be the
            // serialized version of the current image.
            // This will update any subscribed views
            this.partProperties.setPropertyNamed(
                this,
                'image',
                this.activeCanvas.toDataURL()
            );
            this.activeCanvas = null;
            this.activeContext = null;
            this.isDrawing = false;
        }
    }

    clear(){
        if(this.isDrawing){
            return;
        }
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');
        this.partProperties.setPropertyNamed(
            this,
            'image',
            this.activeCanvas.toDataURL()
        );
        this.activeCanvas = null;
        this.activeContext = null;
    }

    /* Utility Methods for Scriptable Drawing */
    coordsFromString(coordString){
        let pair = coordString.split(",");
        let x = parseInt(pair[0]);
        let y = parseInt(pair[1]);
        return {x, y};
    }
};




/***/ }),

/***/ "./js/objects/parts/Field.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Field.js ***!
  \***********************************/
/*! exports provided: Field, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return Field; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Field
 * -----------------------------------------
 * I am a Field Part.
 * I am a container that holds text. I also allow
 * a user to edit my text.
 */





const sides = ["top", "bottom", "left", "right"];

class Field extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name){
        super(owner);

        this.acceptedSubpartTypes = ["field"];

        this.isField = true;

        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Set the Field-specific
        // Part Properties
        this.partProperties.newBasicProp(
            'mode',
            'editing' //TODO this should be either "bravo" or "simpletalk"
        );

        this.partProperties.newBasicProp(
            'innerHTML',
            ''
        );

        this.partProperties.newBasicProp(
            'targetRangeId',
            null
        );

        // 'text' is a DynamicProperty configured to also set the innerHTML
        // BasicProperty when changed. The basic idea is that 'text' will be
        // the property that ST will interface with and everytime it
        // is changed the 'innerHTML' property should follow.
        this.partProperties.newDynamicProp(
            'text',
            (owner, prop, value, notify) => {
                prop._value = value;
                if(notify){
                    /*
                    if(!value){
                        value = "<br>";
                    }
                    // replace all newline characters with <br>
                    value = value.replace(/\n/g, "<br>");
                    */
                    owner.partProperties.setPropertyNamed(owner, 'innerHTML', value, notify);
                }
            },
            (owner, prop) => {
                return prop._value;
            },
            false, // not read only
            ''     // default is empty string
        );

        this.partProperties.newBasicProp(
            'editable',
            true
        );


        // A number of the props deal with direct text editing,
        // and so they are like commands. Examples include "undo"
        // "redo" "clear" etc. Here we use dynami props which the
        // view can respond to accordingly, but having these props have
        // no actual 'state'
        /** TODO: these should be private commands
        this.partProperties.newDynamicProp(
            "undo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "redo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "remove-format",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        **/

        // Styling
        // setting width and height to null
        // effectively forces to the default size
        // of the button to fit the button name
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 248, 220)", // var(--palette-cornsik)
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "medium",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-style`,
                "solid",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "black",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "1",
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );

        // Private command handlers

        this.insertRange = this.insertRange.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.setPrivateCommandHandler("insertRange", this.insertRange);
        this.setPrivateCommandHandler("setSelection", this.setSelection);
        this.setPrivateCommandHandler("highlightSyntax", this.highlightSyntax);
        this.setPrivateCommandHandler("unhighlightSyntax", this.unhighlightSyntax);
    }

    insertRange(senders, rangeId, html, css){
        window.System.findViewsById(this.id).forEach((view) => {
            view.insertRange(rangeId, html, css);
        });
    }

    setSelection(senders, propertyName, propertyValue){
        // for now just allow properties of type "text-*" to be set
        if(propertyName.startsWith("text-")){
            window.System.findViewsById(this.id).forEach((view) => {
                view.setSelection(propertyName, propertyValue);
            });
        }
    }

    highlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.highlightSyntax();
        }
    }

    unhighlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.unhighlightSyntax();
        }
    }

    get type(){
        return 'field';
    }
};




/***/ }),

/***/ "./js/objects/parts/Image.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Image.js ***!
  \***********************************/
/*! exports provided: Image, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return Image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Image; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");




class Image extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newDynamicProp(
            "src",
            this.setSource,
            this.getSource
        );

        this._src = src;

        this.partProperties.newBasicProp(
            "mimeType",
            "unknown"
        );

        this.partProperties.newBasicProp(
            "imageData",
            null
        );

        this.partProperties.newBasicProp(
            'draggable',
            false
        );

        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "black"
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadImageFrom", this.loadImageFromSource);
        this.setPrivateCommandHandler("loadImageFromFile", this.loadImageFromFile);

        // Bind component methods
        this.loadImageFromSource = this.loadImageFromSource.bind(this);
        this.loadImageFromFile = this.loadImageFromFile.bind(this);
    }


    loadImageFromSource(senders, sourceUrl){
        fetch(sourceUrl)
            .then(response => {
                let contentType = response.headers.get('content-type');
                if(!contentType.startsWith('image')){
                    throw new Error(`Invalid image mimeType: ${contentType}`);
                }
                this.partProperties.setPropertyNamed(
                    this,
                    "mimeType",
                    contentType
                );
                if(contentType.startsWith("image/svg")){
                    return response.text().then(text => {
                        this.partProperties.setPropertyNamed(
                            this,
                            'imageData',
                            text
                        );
                    });
                } else {
                    return response.blob().then(blob => {
                        let reader = new FileReader();
                        reader.onloadend = () => {
                            this.partProperties.setPropertyNamed(
                                this,
                                'imageData',
                                reader.result // will be the base64 encoded data
                            );
                        };
                        reader.readAsDataURL(blob);
                    });
                }
            })
            .then(() => {
                // Manually set the _src.
                // This ensures that we don't infinitely
                // call the load operation
                this._src = sourceUrl;
            })
            .catch(err => {
                console.error(err);
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    null
                );
            });
    }

    loadImageFromFile(){
        let filePicker = document.createElement('input');
        filePicker.type = 'file';
        filePicker.setAttribute('accept', 'image/*');
        filePicker.style.display = 'none';
        filePicker.addEventListener('change', (event) => {
            // Handle the file here
            let reader = new FileReader();
            reader.onloadend = () => {
                this.partProperties.setPropertyNamed(
                    this,
                    'mimeType',
                    filePicker.files[0].type
                );
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    reader.result
                );
            };
            let imageFile = filePicker.files[0];
            if(imageFile.type.includes('svg')){
                reader.readAsText(imageFile);
            } else {
                reader.readAsDataURL(imageFile);
            }
            filePicker.remove();
        });
        document.body.append(filePicker);
        filePicker.click();
    }

    setSource(owner, property, value){
        owner._src = value;
        if(value){
            owner.loadImageFromSource([this], value);
        }
    }

    getSource(owner, property){
        return owner._src;
    }

    get type(){
        return 'image';
    }

    get isSvg(){
        let mimeType = this.partProperties.getPropertyNamed(
            this,
            "mimeType"
        );
        if(!mimeType){
            return false;
        }

        return mimeType.startsWith('image/svg');
    }
};




/***/ }),

/***/ "./js/objects/parts/Part.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Part.js ***!
  \**********************************/
/*! exports provided: Part, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Part", function() { return Part; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Part; });
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/errorHandler.js */ "./js/objects/utils/errorHandler.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/**
 * Part
 * -------------------------------
 * I represent the prototype object for all
 * SimpleTalk parts.
 */







class Part {
    constructor(anOwnerPart, name, deserializing=false){

        this.name = this.constructor.name;

        // An array of child parts
        this.subparts = [];
        // a list of all accepted subparts by type
        // By default this is null and each Part subclcass should
        // specify if otherwise
        this.acceptedSubpartTypes = [];

        this.partProperties = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["PartProperties"]();
        this._owner = anOwnerPart;
        this._commandHandlers = {};
        this._privateCommandHandlers = {};
        this._functionHandlers = {};
        this._scriptSemantics = {};
        this._propertySubscribers = new Set();
        this._viewSubscribers = new Set();
        this._stepIntervalId = null;

        this.isPart = true;

        // Bind methods
        this.setupProperties = this.setupProperties.bind(this);
        this.setupStyleProperties = this.setupStyleProperties.bind(this);

        this.addPart = this.addPart.bind(this);
        this.removePart = this.removePart.bind(this);
        this.acceptsSubpart = this.acceptsSubpart.bind(this);
        this.setPrivateCommandHandler = this.setPrivateCommandHandler.bind(this);
        this.removePrivateCommandHandler = this.removePrivateCommandHandler.bind(this);
        this.setFuncHandler = this.setFuncHandler.bind(this);
        this.receiveCmd = this.receiveCmd.bind(this);
        this.receiveFunc = this.receiveFunc.bind(this);
        this.receiveError = this.receiveError.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.delegateMessage = this.delegateMessage.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.addPropertySubscriber = this.addPropertySubscriber.bind(this);
        this.removePropertySubscriber = this.removePropertySubscriber.bind(this);
        this.addViewSubscriber = this.addViewSubscriber.bind(this);
        this.removeViewSubscriber = this.removeViewSubscriber.bind(this);
        this.serialize = this.serialize.bind(this);
        this.toJSON = this.toJSON.bind(this);
        this.setPropsFromDeserializer = this.setPropsFromDeserializer.bind(this);
        this.findAncestorOfType = this.findAncestorOfType.bind(this);
        this.openEditorCmdHandler = this.openEditorCmdHandler.bind(this);
        this.closeEditorCmdHandler = this.closeEditorCmdHandler.bind(this);
        this.copyCmdHandler = this.copyCmdHandler.bind(this);
        this.pasteCmdHandler = this.pasteCmdHandler.bind(this);
        this.isSubpartOfCurrentCard = this.isSubpartOfCurrentCard.bind(this);
        this.isSubpartOfCurrentStack = this.isSubpartOfCurrentStack.bind(this);
        this.getOwnerBranch = this.getOwnerBranch.bind(this);
        this.startStepping = this.startStepping.bind(this);
        this.stopStepping = this.stopStepping.bind(this);
        this.setTargetProp = this.setTargetProp.bind(this);
        this.move = this.move.bind(this);
        this.moveSubpartUp = this.moveSubpartUp.bind(this);
        this.moveSubpartDown = this.moveSubpartDown.bind(this);
        this.moveSubpartToFirst = this.moveSubpartToFirst.bind(this);
        this.moveSubpartToLast = this.moveSubpartToLast.bind(this);



        // Finally, we finish initialization
        this.setupProperties();

        // command handlers
        this.setPrivateCommandHandler("openEditor", this.openEditorCmdHandler);
        this.setPrivateCommandHandler("closeEditor", this.closeEditorCmdHandler);
        this.setPrivateCommandHandler("setTargetTo", this.setTargetProp);
        this.setPrivateCommandHandler("copy", this.copyCmdHandler);
        this.setPrivateCommandHandler("paste", this.pasteCmdHandler);
        this.setPrivateCommandHandler("move", this.move);
        this.setPrivateCommandHandler("moveUp", () => {this._owner.moveSubpartUp(this);});
        this.setPrivateCommandHandler("moveDown", () => {this._owner.moveSubpartDown(this);});
        this.setPrivateCommandHandler("moveToFirst", () => {this._owner.moveSubpartToFirst(this);});
        this.setPrivateCommandHandler("moveToLast", () => {this._owner.moveSubpartToLast(this);});
    }

    // Convenience getter to get the id
    // from the partProperties
    get id(){
        return this.partProperties.getPropertyNamed(this, 'id');
    }

    set id(val){
        return this.partProperties.setPropertyNamed(this, 'id', val);
    }


    // Return an array of names of all of my and my ancestors' handlers
    // for the moment this is just names, type, id and whether the handler overrides
    // an owner's, but could be richer info, such as arguments, documentation etc
    get commandHandlerRegistry(){
        let handlersInfo = {};
        let ownerBranch = this.getOwnerBranch();
        for(let i = 1; i <= ownerBranch.length; i++){
            let part = ownerBranch[ownerBranch.length - i];
            let partType = part.type;
            if(part.id === -1){
                partType = "System";
            } else {
                // System doesn't have private command handlers
                Object.keys(part._privateCommandHandlers).forEach((h) => {
                    let override = false;
                    if(handlersInfo[h]){
                        override = true;
                    }
                    handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: true};
                });
            }
            Object.keys(part._commandHandlers).forEach((h) => {
                let override = false;
                if(handlersInfo[h]){
                    override = true;
                }
                handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: false};
            });
        }
        return handlersInfo;
    }

    // returns the this.part -> System branch by part id
    getOwnerBranch(branch){
        if(!branch){
            branch = [this];
        }
        if(this.type === "world"){
            branch.push(window.System);
            return branch;
        } else {
            branch.push(this._owner);
        };
        return this._owner.getOwnerBranch(branch);
    }

    // Configures the specific properties that the
    // given part can expect, along with any default
    // values.
    // Descendant Parts should override this method
    // in their own constructor after calling super,
    // so that they get the parent's general properties
    // too.
    setupProperties(){
        // Here, we set up properties common
        // to ALL Parts in the system.
        let basicProps = [
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'target',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'contents',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'enabled',
                true
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'wants-move',
                false
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'id',
                _utils_id_js__WEBPACK_IMPORTED_MODULE_0__["idMaker"].new()
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'name',
                `New ${this.type}`
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'rectangle',
                "0, 0, 0, 0",
                true,
                ['rect']
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'script',
                null // For now
            ),

            // Styling
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssStyle',
                {},
                false,
            ),
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssTextStyle',
                {},
                false,
            )
        ];
        basicProps.forEach(prop => {
            this.partProperties.addProperty(prop);
        });

        // the index number of the part in part._owner.subpart
        // array. Note: this is 1-indexed
        this.partProperties.newDynamicProp(
            'number',
            null, // no setter
            function(propOwner, propObject){
                if(propOwner.type == "world"){
                    return 1;
                }
                return propOwner._owner.subparts.indexOf(propOwner) + 1;
            },
            true // readonly
        );

        this.partProperties.newDynamicProp(
            'target',
            function(propOwner, propObject, val){
                // check to see if the target is a non-ID
                let id = Object(_utils_id_js__WEBPACK_IMPORTED_MODULE_0__["isValidId"])(val);
                if(id){
                    // if it is an ID insert "part" since our
                    // grammar doesn't handle ID without system object
                    // prefixes
                    propObject._value = `part id ${val}`;
                } else {
                    propObject._value = val;
                }
            },
            function(propOwner, propObject){
                return propObject._value;
            },
            false,
            null,
        ),

        // Custom Properties store props defined within the
        // ST environment
        this.partProperties.newCustomProp(
        ),

        // Stepping related props

        this.partProperties.newDynamicProp(
            // The time in milliseconds between
            // sends of the step command if the
            // stepping property is set to true
            'stepTime',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(propOwner.isStepping){
                    // Interrupt the current interval
                    // and restart with new stepTime
                    propOwner.stopStepping();
                    this._value = value;
                    propOwner.startStepping();
                } else{
                    this._value = value;
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                return this._value;
            },
            false, // can read and write
            500 // Default to half a second
        );

        this.partProperties.newDynamicProp(
            'stepping',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(value === false && propOwner.isStepping){
                    propOwner.stopStepping();
                } else if(value === true && !propOwner.isStepping){
                    propOwner.startStepping();
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                // If the intervalId is set, then
                // the Part is currently stepping
                return propOwner.isStepping;
            },
        );

    }

    // To be called in each sub-class that has StyleProperties
    // called after the style props are configured
    setupStyleProperties(){
        this.partProperties._properties.forEach((prop) => {
            if(prop.constructor.name === "StyleProperty"){
                // setting the value on itself ensures that the cssStyle
                // BasicProperty is updated with the appropriate styler
                // conversion css key-val
                prop.setValue(this, prop._value);
            }
        });
    }

    /** Subpart Access **/
    /**
     * Each subclass will implement its own set of checks,
     * and throw an approprite error if the subpart type is invalid.
     */
    acceptsSubpart(aPartType){
        if (this.acceptedSubpartTypes[0] === "*"){
            return true;
        }
        return this.acceptedSubpartTypes.includes(aPartType.toLowerCase());
    }

    /**
     * Adds a part to this part's subparts
     * collection, if not already present.
     * It will also set the owner of the
     * added part to be this part.
     */
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            this.subparts.push(aPart);
            aPart._owner = this;
        }
    }

    /**
     * Removes the given part from this
     * part's list of subparts (if present).
     * It will also unset the owner of the
     * given part.
     */
    removePart(aPart){
        let partIndex = this.subparts.indexOf(aPart);
        if(partIndex >= 0){
            this.subparts.splice(partIndex, 1);
            aPart._owner = null;
        }
    }

    /** Checks whether the Part instance is a subpart of the current
     * Card.
     */
    isSubpartOfCurrentCard(){
    }

    /** Checks whether the Part instance is a subpart of the current
     * Stack.
     */
    isSubpartOfCurrentStack(){
    }

    /** Logging and Reporting **/
    shouldBeImplemented(functionName){
        let msg = `${this.constructor.name} should implement ${functionName}`;
        throw new Error(msg);
    }

    /** Message Handling and Delegation **/
    delegateMessage(aMessage){
        return this.sendMessage(
            aMessage,
            this._owner
        );
    }

    sendMessage(aMessage, target){
        return window.System.sendMessage(aMessage, this, target);
    }

    receiveMessage(aMessage){
        // By default, Parts will only handle
        // messages of type 'command' and 'function'
        switch(aMessage.type){
            case 'command':
                return this.receiveCmd(aMessage);
                //break;
            case 'function':
                return this.receiveFunc(aMessage);
                //break;
            case 'error':
                return this.receiveError(aMessage);
            default:
                return this.delegateMessage(aMessage);
        }
    }

    receiveError(aMessage){
        return _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].handle(aMessage);
    }

    receiveCmd(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = handler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        let privateHandler = this._privateCommandHandlers[aMessage.commandName];
        if(privateHandler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = privateHandler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        // Otherwise, we have no handler for
        // it. Unless the message indicates shouldNotDelegate
        // we delegate along the
        // message delegation chain. It is up
        // to Parts to properly implement delegation
        // for themselves!
        if(aMessage.shouldNotDelegate){
            return aMessage;
        }
        return this.delegateMessage(aMessage);
    }

    receiveFunc(aMessage){
        let handler = this._functionHandlers[aMessage.functionName];

        if(handler){
            let boundHandler = handler.bind(this);
            return boundHandler();
        } else {
            return this.delegateMessage(aMessage);
        }
    }

    setPrivateCommandHandler(commandName, handler){
        this._privateCommandHandlers[commandName] = handler;
    }

    removePrivateCommandHandler(commandName){
        delete this._privateCommandHandlers[commandName];
    }

    setFuncHandler(funcName, handler){
        this._functionHandlers[funcName] = handler;
    }

    /** Command Handlers
        ----------------
        Command handlers which are invoked at the Part level
        which are not immediately delegaed to the Part._owner
    **/

    openEditorCmdHandler(){
        let editor = document.querySelector('st-editor');
        editor.render(this);
        if(!editor.isOpen){
            editor.open();
        }
    }

    closeEditorCmdHandler(){
        let editor = document.querySelector('st-editor.open');
        if(editor){
            editor.close();
        }
    }

    setTargetProp(senders, ...args){
        let target = args.join(" ");
        this.partProperties.setPropertyNamed(this, "target", target);
    }

    copyCmdHandler(){
        window.System.clipboard.copyPart(this);
    }

    pasteCmdHandler(){
        if(!window.System.clipboard.isEmpty){
            let item = window.System.clipboard.contents[0];
            if(item.type == 'simpletalk/json' && this.acceptsSubpart(item.partType)){
                window.System.clipboard.pasteContentsInto(this);
            }
        }
    }

    move(senders, movementX, movementY){
        if(!this.partProperties.getPropertyNamed(this, "wants-move")){
            throw Error(`Part ${this.id} trying to move with 'wants-move' property false`);
        }
        let top = this.partProperties.getPropertyNamed(this, "top");
        top += movementY;
        this.partProperties.setPropertyNamed(this, "top", top);
        let left = this.partProperties.getPropertyNamed(this, "left");
        left += movementX;
        this.partProperties.setPropertyNamed(this, "left", left);
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex < this.subparts.length - 1){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex > 0){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    // Note: moveSubpartToFirst means move to first in the view
    // i.e. last as a subaprt
    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, 0);
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, this.subparts.length - 1);
    }

    /** Property Subscribers
        ------------------------
        Objects added as property subscribers
        will be 'notified' whenever one of this
        Part's properties changes
    **/
    addPropertySubscriber(anObject){
        this._propertySubscribers.add(anObject);
    }

    removePropertySubscriber(anObject){
        this._propertySubscribers.delete(anObject);
    }

    propertyChanged(propertyName, newValue){
        let message = {
            type: 'propertyChanged',
            propertyName: propertyName,
            value: newValue,
            partId: this.id
        };
        this._propertySubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    /** View Subscribers
        ------------------------
        Objects added as view subscribers
        will be 'notified' whenever this Part
        incurrs a view change (add, delete subparts, reorder etc)
    **/
    addViewSubscriber(anObject){
        this._viewSubscribers.add(anObject);
    }

    removeViewSubscriber(anObject){
        this._viewSubscribers.delete(anObject);
    }

    viewChanged(changeName, ...args){
        let message = {
            type: 'viewChanged',
            changeName: changeName,
            partId: this.id,
            args: args
        };
        this._viewSubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpart = this.subparts.splice(currentIndex, 1)[0];
        this.subparts.splice(newIndex, 0, subpart);
        this.viewChanged("subpart-order", id, currentIndex, newIndex);
    }

    startStepping(){
        if(this._stepIntervalId){
            this.stopStepping();
        }
        let stepTime = this.partProperties.getPropertyNamed(
            this,
            'stepTime'
        );
        if(stepTime > 0){
            this._stepIntervalId = setInterval(() => {
                this.sendMessage({
                    type: 'command',
                    commandName: 'step',
                    args: []
                }, this);
            }, stepTime);
        }
    }

    stopStepping(){
        clearInterval(this._stepIntervalId);
        this._stepIntervalId = null;
    }

    get isStepping(){
        // We know the Part is currently stepping
        // of the stored intervalId is set to
        // something besides null
        return this._stepIntervalId !== null;
    }

    /**
     * Serialize this Part's state as JSON.
     * By default, we do not serialize specific
     * PartCollection information (recursively),
     * and only include basics including the current
     * state of all properties.
     */
    serialize(){
        let ownerId = null;
        if(this._owner){
            ownerId = this._owner.id;
        }
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: ownerId
        };
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    /**
     * Set the properties and other
     * attributes of this Part model
     * from a deserialized JSON object.
     */
    setPropsFromDeserializer(incomingProps, deserializer){
        Object.keys(incomingProps).forEach(propName => {
            let property = this.partProperties.findPropertyNamed(propName);
            if(!property){
                // If some old or invalid property is
                // present in the deserialization, simply provide
                // a warning and then skip this one.
                console.warn(`Deserialized property "${propName}" is not a valid property name for ${this.type} (id ${this.id}) and will be ignored`);
            } else if(propName == "custom-properties"){
                // custom properties are serialized as an object like other props
                // and we need to create properties from these and set their respective
                // values. Then we need to set the value of "custom-properties" prop
                // itself to be the object containing all of these
                let customPropsData = incomingProps[propName];
                let newCustomPropsObject = {};
                Object.values(customPropsData).forEach((propData) => {
                    let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](propData.name, null);
                    newProp.setValue(this, propData._value, false); // no need to notify
                    newCustomPropsObject[propData.name] = newProp;
                });
                property.setValue(this, newCustomPropsObject, false); // no need to notify
            } else if(!property.readOnly){
                // Last arg is false, which tells the property
                // not to notify its owner's subscribers of
                // property changes. We don't need that when
                // deserializing
                property.setValue(this, incomingProps[propName], false);
            }
        });
    }

    toJSON(){
        return this.serialize();
    }

    findAncestorOfType(aPartType){
        let owner = this._owner;
        while(owner){
            if(owner.type == aPartType){
                return owner;
            }
            owner = owner._owner;
        }
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Resource.js":
/*!**************************************!*\
  !*** ./js/objects/parts/Resource.js ***!
  \**************************************/
/*! exports provided: Resource, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return Resource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Resource; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Resource extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);
        this.resource = null;

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "notReady"
        );

        this.partProperties.newBasicProp(
            "prerequisite",
            null
        );

        this.partProperties.newBasicProp(
            "resourceName",
            null
        );

        this.partProperties.newBasicProp(
            "response",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadResource", this.loadResource);
        this.setPrivateCommandHandler("setSourceTo", this.setSourceTo);
        this.setPrivateCommandHandler("get", this.get);

        // Bind component methods
        this.loadResource = this.loadResource.bind(this);
        this.get = this.get.bind(this);
        this.reset = this.reset.bind(this);

        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'resource';
    }

    loadResource(senders, resourceName){
        if(!window.System.availableResources || !window.System.availableResources[resourceName]){
            // TODO this should be a ST error
            throw Error(`resource ${resourceName} not found`);
        }
        this.resource = window.System.availableResources[resourceName];
        this.partProperties.setPropertyNamed(this, "resourceName", resourceName);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();
    }

    setSourceTo(senders, sourceUrl){
        if(!this.resource){
            // TODO this should be a ST error
            throw Error(`no resource loaded for resource part id ${this.id}`);
        }
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
        this.resource.load(sourceUrl);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();

    }

    get(senders, ...args){
        this.partProperties.setPropertyNamed(this, "readyState", "fetching");
        let prerequisite = this.partProperties.getPropertyNamed(this, "prerequisite");
        this.resource.get(prerequisite, ...args).then((response) => {
            this.partProperties.setPropertyNamed(this, "response", response);
            this.partProperties.setPropertyNamed(this, "readyState", "ready");
            this.sendMessage({
                type: "command",
                commandName: "responded",
                args: [this.id, this.resource.name],
                shouldIgnore: true
            }, this);
        }, (error) => {
            this.partProperties.setPropertyNamed(this, "readyState", "error");
            this.partProperties.setPropertyNamed(this, "response", null);
            this.sendMessage({
                type: "command",
                commandName: "errored",
                args: [this.id, this.resource.name, error.message],
                shouldIgnore: true
            }, this);
        });
    }

    reset(){
        this.partProperties.setPropertyNamed(this, "readyState", "notReady");
        this.partProperties.setPropertyNamed(this, "response", null);
    }
};




/***/ }),

/***/ "./js/objects/parts/Stack.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Stack.js ***!
  \***********************************/
/*! exports provided: Stack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Card_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/**
 * Stack
 * ----------------------------
 * I am the Stack Part.
 * I represent a collection of Card parts,
 * along with some extra configurability.
 */




class Stack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, deserializing=false){
        super(owner);
        this.acceptedSubpartTypes = [
            "card", "window", "button", "area", "field",
            "drawing", "image", "audio", "browser"
        ];

        // Set up Stack specific
        // PartProperties
        this.partProperties.newBasicProp(
            'cantPeek',
            false
        );
        this.partProperties.newBasicProp(
            'resizable',
            false
        );


        // Will hold the card-based index,
        // which here is zero-indexed, of the
        // card that is the current card for this
        // Stack.
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Bind general methods
        this.sendOpenCardTo = this.sendOpenCardTo.bind(this);
        this.sendCloseCardTo = this.sendCloseCardTo.bind(this);

        // Bind stack navigation methods
        this.goToNextCard = this.goToNextCard.bind(this);
        this.goToPrevCard = this.goToPrevCard.bind(this);
        this.goToCardById = this.goToCardById.bind(this);
        this.goToNthCard = this.goToNthCard.bind(this);
    }

    goToNextCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= cards.length){
            nextIdx = (nextIdx % cards.length);
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToCardById(anId){
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let cards = Object.values(window.System.partsById).filter((part) => {
            return part.type == "card";
        });
        let nextCard = cards.find(card => {
            return card.id == anId;
        });
        if(!nextCard){
            throw new Error(`The card id: ${anId} cant be found stack`);
        }
        // if the card is not on this stack we should go to the corresponding stack
        if(nextCard._owner != this){
            this._owner.goToStackById(nextCard._owner.id);
        }
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToPrevCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);

        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = cards.length + nextIdx;
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToNthCard(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(trueIndex < 0 || trueIndex > cards.length -1){
            console.warn(`Cannot navigate to card number ${anIndex} -- out of bounds`);
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let nextCard = cards[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
           nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    sendCloseCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    sendOpenCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    get type(){
        return 'stack';
    }

    get currentCardId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentCard(){
        return window.System.partsById[this.currentCardId];
    }

    // override the base class methods
    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a card then append after the last card
            if(aPart.type == "card"){
                let allCards = this.subparts.filter((part) => {
                    return part.type == "card";
                });
                this.subparts.splice(allCards.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }
};




/***/ }),

/***/ "./js/objects/parts/Window.js":
/*!************************************!*\
  !*** ./js/objects/parts/Window.js ***!
  \************************************/
/*! exports provided: Window, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Window", function() { return Window; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Window; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Window Part
 * ------------------------
 * A Window is a Part that wraps another
 * Part of type Card, Stack, or WorldStack
 * in a moveable window.
 * I can also optionally hold a reference
 * to a target Part that I do not own. I call
 * this JS property target and I store the
 * target part's id as a HyperTalk property
 * called targetId.
 * When my owner part is the current view, I
 * will be visible on top of everything else.
 */




class Window extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, target, deserializing=false){
        super(owner, name);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
        ];

        // If we pass in a target,
        // set it.
        if(target){
            this.setTarget(target);
        }

        // Set up Window specific
        // part ptoperties
        this.partProperties.newBasicProp(
            'targetId',
            null
        );

        this.partProperties.newBasicProp(
            'title',
            "New Window Title"
        );

        this.partProperties.newBasicProp(
            'isResizable',
            true
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );

        // Bind methods
        this.setTarget = this.setTarget.bind(this);
        this.onWindowClose = this.onWindowClose.bind(this);

        // Add private handlers
        this.setPrivateCommandHandler('windowClose', this.onWindowClose);
    }

    setTarget(aPart){
        this.target = aPart;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            this.target.id
        );
    }

    unsetTarget(){
        this.target = null;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            null
        );
    }

    /**
     * Override
     * Unlike other kinds of Parts, a window
     * has only one subpart, which should be
     * Card, Stack, or WorldStack.
     */
    addPart(aPart){
        let isValid = this.acceptsSubpart(aPart.type);
        if(!isValid){
            // Consider replacing this generic exception
            // with a message based approach that sends
            // these sorts of non-fatal errors to System
            // as a kind of message. This way we can display
            // errors in SimpltTalk objects.
            throw new Error(`Windows cannot wrap parts of type ${aPart.type}`);
        }
        this.subparts.forEach(subpart => {
            this.removePart(subpart);
        });
        this.subparts.push(aPart);
        aPart._owner = this;
    }

    onWindowClose(senders, ...args){
        // Default behavior is to delete
        // the window model from the System.
        // Scripts can override this handler
        this.sendMessage(
            {
                type: 'command',
                commandName: 'deleteModel',
                args: [ this.id ]
            },
            window.System
        );
    }

    get type(){
        return 'window';
    }
}




/***/ }),

/***/ "./js/objects/parts/WorldStack.js":
/*!****************************************!*\
  !*** ./js/objects/parts/WorldStack.js ***!
  \****************************************/
/*! exports provided: WorldStack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldStack", function() { return WorldStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldStack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/**
 * WorldStack
 * ---------------------------------------------------
 * I am a Stack part that represents the root of a
 * hierarchy of parts. I am the end of the ownership
 * chain for any given configuration of Parts.
 * I am also the final resolver of all unhandled
 * messages sent along the delegation chain for parts.
 * All parts can eventually resolve to me via the delegation
 * chain or ownership hierarchy.
 * There should only be one instance of me in any given
 * SimpleTalk environment.
 */



class WorldStack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super(null);

        this.acceptedSubpartTypes = ["stack", "image"];

        this.isWorld = true;

        // This property specifies the stack
        // id of the current stack
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Set the id property to always
        // be 'world'
        this.id = 'world';

        // Bind general methods
        this.sendOpenStackTo = this.sendOpenStackTo.bind(this);
        this.sendCloseStackTo = this.sendCloseStackTo.bind(this);

        // Bind navigation methods
        this.goToNextStack = this.goToNextStack.bind(this);
        this.goToPrevStack = this.goToPrevStack.bind(this);
        this.goToNthStack = this.goToNthStack.bind(this);
        this.goToStackById = this.goToStackById.bind(this);

        // remove command handlers which are not needed for world
        this.removePrivateCommandHandler("moveUp");
        this.removePrivateCommandHandler("moveDown");
        this.removePrivateCommandHandler("moveToFirst");
        this.removePrivateCommandHandler("moveToLast");
    }

    goToNextStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= stacks.length){
            nextIdx = (nextIdx % stacks.length);
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToStackById(anId){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        let nextStack = stacks.find(stack => {
            return stack.id == anId;
        });
        if(!nextStack){
            throw new Error(`The stack id: ${anId} cant be found on this stack`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToPrevStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = stacks.length + nextIdx;
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToNthStack(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(trueIndex < 0 || trueIndex > stacks.length -1){
            throw new Error(`Cannot navigate to stack number ${anIndex} -- out of bounds`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let nextStack = stacks[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    sendCloseStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'closeStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    sendOpenStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command', 
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    get type(){
        return 'world';
    }

    get loadedStacks(){
        return this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
    }

    // Override normal Part serialization.
    // Here we need to also include an array of ids of
    // loaded stacks and the id of the current stack
    serialize(){
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: null,
            loadedStacks: (this.loadedStacks.map(stack => {
                return stack.id;
            })),
        };

        // Serialize current part properties
        // values
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    // Override for delegation.
    // We send any messages that should be delegated
    // to the global System object, which has any
    // 'handlers of last resort'
    delegateMessage(aMessage){
        return this.sendMessage(aMessage, window.System);
    }

    get currentStackId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentStack(){
        return window.System.partsById[this.currentStackId];
    }

    // override the base class methods
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a stack then append after the last stack
            if(aPart.type == "stack"){
                let allStacks = this.subparts.filter((part) => {
                    return part.type == "stack";
                });
                this.subparts.splice(allStacks.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

};




/***/ }),

/***/ "./js/objects/properties/PartProperties.js":
/*!*************************************************!*\
  !*** ./js/objects/properties/PartProperties.js ***!
  \*************************************************/
/*! exports provided: PartProperties, BasicProperty, CustomProperty, DynamicProperty, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartProperties", function() { return PartProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicProperty", function() { return BasicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomProperty", function() { return CustomProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicProperty", function() { return DynamicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartProperties; });
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");


/**
 * PartProperties
 * ------------------------------------
 * I am an object representing the base
 * Part Properties for all Parts.
 * I also include some convenience methods
 * on my prototype that should be used by
 * other Parts when they inherit from me.
 * For now, we use Object.create() for inheritance.
 */

class BasicProperty {
    constructor(name, defaultValue, readOnly=false, aliases=[]){
        this.name = name;
        this._value = defaultValue;
        this.readOnly = readOnly;
        this.aliases = aliases;

        // Bound methods
        this.getValue = this.getValue.bind(this);
        this.setValue = this.setValue.bind(this);
        this.hasAlias = this.hasAlias.bind(this);
        this.matches = this.matches.bind(this);
        this.matchesNameOrAlias = this.matchesNameOrAlias.bind(this);
    }

    // For basic properties, we return
    // the set/stored value
    getValue(owner){
        return this._value;
    }

    // For the basic properties, we set
    // based on the incoming desired value
    // alone (nothing is computed)
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }

    // Returns true if this property
    // goes by the given alias
    hasAlias(anAlias){
        return this.aliases.includes(anAlias);
    }

    // Returns true if the given name is
    // either an alias or the exact name
    // for this property
    matchesNameOrAlias(aNameOrAlias){
        if(this.hasAlias(aNameOrAlias)){
            return true;
        } else if(aNameOrAlias == this.name){
            return true;
        }
        return false;
    }

    // Returns true if the incoming Property
    // has the same name and/or one of the same
    // aliases as this Property
    matches(aProperty){
        if(aProperty.name == this.name){
            return true;
        } else {
            for(let i = 0; i < this.aliases.length; i++){
                let myAlias = this.aliases[i];
                if(aProperty.hasAlias(myAlias)){
                    return true;
                }
            }
        }
        return false;
    }
};


/** Custom Properties are similar to dynamic props, except that
  * under the hood they store an object of properties
  * storing props defined within the ST environment. The find()
  * add() delete() methods find, add, or remove properties from the
  * this.customProperties object.
 **/
class CustomProperty extends BasicProperty {
    constructor(name="custom-properties", defaultValue={}, readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly=false, aliases);
    }

    find(name){
        let prop = this._value[name];
        if(prop){
            return prop;
        }
        return null;
    }

    add(aProperty){
        // NOTE: aliases are completed ignored for now
        if(!this.find(aProperty.name)){
            this._value[aProperty.name] = aProperty;
        }
    }

    delete(aProperty){
        delete this._value[aProperty.name];
    }



};

class DynamicProperty extends BasicProperty {
    constructor(name, setter, getter, readOnly=false, defaultValue=null, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.valueSetter = setter;
        this.valueGetter = getter;
    }

    // In this override, we use the getter
    // if available, to dynamically get the
    // incoming value.
    getValue(owner){
        return this.valueGetter(owner, this);
    }

    // In this override, we use the setter
    // if available, to dynamically set the
    // incoming value
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this.valueSetter(owner, this, val, notify);
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};


/** I am a special property which handles interfacing with the
  * the cssStyle basic property. Whenever I am updated I make
  * sure to update the cssStyle property via the styler utility
  * function. I can be used to create different and indepent
  * styling options.
  **/
class StyleProperty extends BasicProperty {
    constructor(name, defaultValue,  propName='cssStyle', styler=_utils_styler_js__WEBPACK_IMPORTED_MODULE_0__["default"], readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.propName = propName;
        this.styler = styler;
    }

    // In this override, we update the cssStyle property
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            let styleProperty = owner.partProperties.findPropertyNamed(this.propName);
            let style = styleProperty.getValue(owner);
            let newStyle = this.styler(style, this.name, val);
            styleProperty.setValue(owner, newStyle, notify);

            // set my value as well
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};

class PartProperties {
    constructor(){
        this._properties = [];

        // Bound methods
        this.hasProperty = this.hasProperty.bind(this);
        this.addProperty = this.addProperty.bind(this);
        this.removeProperty = this.removeProperty.bind(this);
        this.findPropertyNamed = this.findPropertyNamed.bind(this);
        this.setPropertyNamed = this.setPropertyNamed.bind(this);
        this.getPropertyNamed = this.getPropertyNamed.bind(this);
        this.newBasicProp = this.newBasicProp.bind(this);
        this.newStyleProp = this.newStyleProp.bind(this);
        this.newDynamicProp = this.newDynamicProp.bind(this);
        this._indexOfProperty = this._indexOfProperty.bind(this);
    }

    get all(){
        return this._properties;
    }

    // This collection 'has' a property if it contains
    // a Property object with matching name or alias
    // of the incoming property.
    hasProperty(aProperty){
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return true;
            }
        }
        return false;
    }

    // Find one of my Properties by
    // a name or alias. Returns null
    // if no match found. Perhaps we should
    // throw an error
    findPropertyNamed(aName){
        let found = null;
        let customPropertiesProp;
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(prop.matchesNameOrAlias(aName)){
                found = prop;
            }
            // grab the custom properties prop, as we might need it
            // for later
            if(prop.matchesNameOrAlias("custom-properties")){
                customPropertiesProp = prop;
            }
        }
        // see if the property is custom
        if(!found && customPropertiesProp){
            found = customPropertiesProp.find(aName);
        }
        return found;
    }

    // Attempts to get the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    getPropertyNamed(owner, aName){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.getValue(owner);
    }

    // Attempts to set the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    setPropertyNamed(owner, aName, aValue, notify=true){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.setValue(owner, aValue, notify);
    }

    // If you add a property with a name or alias
    // that is already present in the collection,
    // then we 'overwrite' it by removing the exising
    // property and replacing it with the incoming one.
    // Otherwise, we just add the property
    addProperty(aProperty){
        if(this.hasProperty(aProperty)){
            this.removeProperty(aProperty);
        }
        this._properties.push(aProperty);
    }

    // Removing a property here means removing
    // it from the stored array. If the property
    // is not in the array, we do NOT throw an error.
    // We just go on with our lives, because who cares?
    removeProperty(aProperty){
        let propIndex = this._indexOfProperty(aProperty);
        if(propIndex >= 0){
            this._properties.splice(propIndex, 1);
        }
    }

    // Convenience method for creating a new basic
    // property.
    newBasicProp(...args){
        let newProp = new BasicProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new custom
    // property.
    newCustomProp(...args){
        let newProp = new CustomProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new style
    // property.
    newStyleProp(...args){
        let newProp = new StyleProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new
    // dynamic prop
    newDynamicProp(...args){
        let newProp = new DynamicProperty(...args);
        this.addProperty(newProp);
    }

    // Private method. Finds the first occurring
    // index of the given Property in the array
    // of properties in this collection. Returns
    // -1 if not found, per JS implementation.
    _indexOfProperty(aProperty){
        for(let i = 0; this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return i;
            }
        }
        return -1;
    }
};




/***/ }),

/***/ "./js/objects/utils/AltSyntaxHighlighter.js":
/*!**************************************************!*\
  !*** ./js/objects/utils/AltSyntaxHighlighter.js ***!
  \**************************************************/
/*! exports provided: createHighlighter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHighlighter", function() { return createHighlighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createHighlighter; });
/** Second pass at syntax highlighter semantics **/
const syntaxSpan = (ruleName) => {
    let span = document.createElement('span');
    span.classList.add('st-syntax');
    span.setAttribute('data-st-rule', ruleName);
    return span;
}

const createHighlighter = (fieldElement) => {
    return {
        MessageHandlerOpen: function(literalOn, messageName, optionalParamList){
            let span = syntaxSpan("MessageHandlerOpen");
            let onSpan = syntaxSpan("keyword");
            onSpan.append("on ");
            span.append(onSpan);

            // Append sub-rules
            span.append(messageName.highlightSyntax());
            span.append(...optionalParamList.highlightSyntax());

            return span;
        },

        MessageHandlerClose(literalEnd, messageName){
            let span = syntaxSpan("MessageHandlerClose");
            let endSpan = syntaxSpan("keyword");
            endSpan.append("end ");
            span.append(endSpan);

            // Add the parts
            span.append(messageName.highlightSyntax());

            return span;
        },

        ParameterList: function(paramString){
            let outer = syntaxSpan("ParameterList");
            let innerItems = paramString.asIteration().children.map(paramName => {
                let span = syntaxSpan("ParameterList-item");
                span.append(paramName.sourceString);
                return span.outerHTML;
            });
            outer.innerHTML = innerItems.join(", ");
            return outer;
            
        },

        messageName: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'messageName');
            span.append(string.sourceString + " ");
            return span;
        },

        keyword: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'keyword');
            span.append(string.sourceString);
            return span;
        }
    };
};




/***/ }),

/***/ "./js/objects/utils/clipboard.js":
/*!***************************************!*\
  !*** ./js/objects/utils/clipboard.js ***!
  \***************************************/
/*! exports provided: STClipboard, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STClipboard", function() { return STClipboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STClipboard; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _serialization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serialization.js */ "./js/objects/utils/serialization.js");
/**
 * Utilities for Clipboard Functionality
 * ------------------------------------------
 * For the moment we use a very primitive stand-in
 * since the Clipboard API is not standardized across
 * browser implementations.
 **/



class STClipboard {
    constructor(aSystem){
        this.system = aSystem;
        this.contents = [];

        // Bound methods
        this.copyPart = this.copyPart.bind(this);
        this.pasteContentsInto = this.pasteContentsInto.bind(this);
        this._createLensedChildren = this._createLensedChildren.bind(this);
    }

    copyPart(aPart){
        let serializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STSerializer"](this.system);
        let rootSerialization = serializer.serialize(aPart, false);
        let item = new STClipboardItem(
            'simpletalk/json',
            rootSerialization,
            aPart.type
        );
        this.contents = [item];
    }

    pasteContentsInto(aTargetPart){
        let promises = this.contents.map(clipboardContent => {
            let serializedContent = clipboardContent.data;
            let deserializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STDeserializer"](this.system);
            deserializer.targetId = aTargetPart.id;
            return deserializer.deserialize(serializedContent)
                .then(() => {
                    // Reset the top and left values to that
                    // the pasted part doesn't run outside of the new
                    // relative bounds in which it has been pasted
                    let newPart = deserializer.rootParts[0];
                    let hasTop = newPart.partProperties.findPropertyNamed('top');
                    let hasLeft = newPart.partProperties.findPropertyNamed('left');
                    if(hasTop){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'top',
                            10
                        );
                    }
                    if(hasLeft){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'left',
                            10
                        );
                    }
                    
                    // Open Halo on the new view
                    deserializer.rootViews[0].openHalo();

                    // Dispatch the CustomEvent that notifies listeners
                    // that a new view was added (used by Nav etc)
                    let event = new CustomEvent('st-view-added', {
                        detail: {
                            partType: newPart.type,
                            partId: newPart.id,
                            ownerId: newPart._owner.id
                        }
                    });
                    deserializer.rootViews[0].dispatchEvent(event);

                    // Add any lensed views that might be needed
                    let rootLensViews = this.system.findLensViewsById(newPart._owner.id);
                    rootLensViews.forEach(lensView => {
                        let newLensView = document.createElement(
                            this.system.tagNameForViewNamed(newPart.type)
                        );
                        newLensView.setModel(newPart);
                        newLensView.removeAttribute('part-id');
                        newLensView.setAttribute('lens-part-id', newPart.id);
                        newLensView.setAttribute('role', 'lens');
                        lensView.appendChild(newLensView);
                        this._createLensedChildren(newLensView, newPart.subparts);
                    });
                    
                    return;
                })
                .catch(err => {
                    throw err;
                });
        });
        return Promise.all(promises);
    }

    _createLensedChildren(aLensView, subparts){
        subparts.forEach(subpart => {
            let newLensView = document.createElement(
                this.system.tagNameForViewNamed(subpart.type)
            );
            newLensView.setModel(subpart);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', subpart.id);
            newLensView.setAttribute('role', 'lens');
            aLensView.appendChild(newLensView);
            this._createLensedChildren(newLensView, subpart.subparts);
        });
    }
    
    get isEmpty(){
        return this.contents.length <= 0;
    }
}

class STClipboardItem {
    constructor(mimeType, data, partType){
        if(mimeType){
            this.type = mimeType;
        }
        if(partType){
            this._partType = partType;
        }
        if(data){
            this.data = data;
        }
    }

    get partType(){
        if(this.type == 'simpletalk/json'){
            return this._partType;
        }
        return null;
    }

    set partType(val){
        this._partType = val;
    }
};




/***/ }),

/***/ "./js/objects/utils/errorHandler.js":
/*!******************************************!*\
  !*** ./js/objects/utils/errorHandler.js ***!
  \******************************************/
/*! exports provided: errorHandler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorHandler", function() { return errorHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return errorHandler; });
/**
 * Error Handler
 * ------------------------------------
 * I am responsible for handler all
 * System-wide errors
 */

const errorHandler = {

    handle: function(aMessage){
        switch(aMessage.name){
            case 'GrammarMatchError':
                return this.handleGrammarMatchError(aMessage);
            case 'MessageNotUnderstood':
                return this.handleMessageNotUnderstood(aMessage);
            default:
                // if I don't know what to do with this message
                // I send it along to the System
                return window.System.receiveMessage(aMessage);
        }
    },

    handleGrammarMatchError: function(aMessage){
        // TODO is there a more structured way to get this out of ohm?
        let regex = /Line (?<line>\d), col (?<column>\d)/;
        let match = aMessage.parsedScript.message.match(regex);
        let errorLineNum = parseInt(match.groups["line"]) - 1; // ohm lines start with 1 
        // see if the grammar rule has been identified
        let ruleName;
        let rightMostFailures = aMessage.parsedScript.getRightmostFailures();
        if(rightMostFailures[1]){
            ruleName = rightMostFailures[1].pexpr.ruleName;
        }
        // get some more info about what the parser expected
        let expectedText = aMessage.parsedScript.getExpectedText();
        // get the original script
        let text = aMessage.parsedScript.input;
        let textLines = text.split("\n");
        // replace said text line with an error marker
        textLines[errorLineNum] += ` --<<<[Expected:${expectedText}; ruleName: "${ruleName}"]`;
        text = textLines.join("\n");
        // if the first message in the parsed script is "doIt" then the statementLines are
        // located in the corresponding field text, not the script, property and
        // we want the error to be marked up in the field textarea
        if(aMessage.parsedScript.input.startsWith("on doIt")){
            let originalSenderModel = window.System.partsById[aMessage.partId];
            // we need to get the original text so as not to completely replace it
            // then insert the markup in the appropriate line
            let fieldText = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, "text");
            let script = aMessage.parsedScript.input;
            script = this._cleanDoItSCript(script);
            // we don't want the "doIt" handler inserted back in, since it's just a hidden wrapper for the
            // statement lines
            text = this._cleanDoItSCript(text);
            fieldText = fieldText.replace(script, text);
            originalSenderModel.partProperties.setPropertyNamed(originalSenderModel, "text", fieldText);
        } else {
            // first locate the script editor in question
            let scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            if(!scriptEditor){
                this._openScriptEditor(aMessage.partId);
                scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            }
            scriptEditor.model.partProperties.setPropertyNamed(scriptEditor.model, "text", text);
        }
        // open the grammar if there is not one open already
        let currentCard = window.System.getCurrentCardModel();
        let grammar = currentCard.subparts.filter((part) => {
            return (part.type == "field") && (part.partProperties.getPropertyNamed(part, "name") == "SimpleTalk");
        });
        if(grammar.length == 0){
            this._openGrammar(aMessage.partId, ruleName);
        }
    },

    handleMessageNotUnderstood(aMessage){
        let offendingMessage = aMessage.message;
        let originalSender = offendingMessage.senders[0];
        // Are we ever going to have MNU errors on messages that
        // are not type: command?
        if(offendingMessage.type === "command"){
            let commandName = offendingMessage.commandName;
            let originalSenderModel = window.System.partsById[originalSender.id];
            let regex = new RegExp(`\\s*${commandName}(\s|\n|$)`, 'g');
            let text;
            let target;
            let executionStack = window.System.executionStack._stack;
            // if the first message in the execution stack is "doIt" then the statementLines are
            // located in the corresponding field text, not the script, property and
            // we want the error to be marked up in the field textarea
            if(executionStack[0] && executionStack[0].messageName == "doIt"){
                target = executionStack[0].part;
                text = target.partProperties.getPropertyNamed(originalSenderModel, 'text');
            } else {
                text = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, 'script');
                let scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                if(!scriptEditor){
                    this._openScriptEditor(originalSender.id);
                    scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                }
                if(scriptEditor){
                    target = scriptEditor.model;
                }
            }
            // TODO Sort this out
            if(target){
                let textLines = text.split("\n");
                // offending command text line with an error marker
                for(let i = 0; i < textLines.length; i++){
                    let line = textLines[i];
                    if(line.match(regex)){
                        textLines[i] = line += ` --<<<[MessageNotUnderstood: command; commandName: "${commandName}"]`;
                    }
                }
                text = textLines.join("\n");
                target.partProperties.setPropertyNamed(target, "text", text);

            }
            // finally open the debugger (or current version thereof)
            // NOTE: this is a bit dangerous, b/c if the System doesn't
            // handle the `openDebugger` command anywhere it will throw
            // a MNU error, which will then invoke this handler cuasing
            // an infinite loop!
            this._openDebugger(originalSender.id, offendingMessage.type, offendingMessage.commandName);
        }
    },

    _cleanDoItSCript(script){
        // clean up the DoIt script by removing the handler
        // newlines, tabs and spaces
        script = script.replace("on doIt", "");
        script = script.replace("end doIt", "");
        script = script.replace(/^[\n\t ]+/, "");
        script = script.replace(/[\n\t ]+$/, "");
        return script;
    },

    _openScriptEditor: function(partId){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openScriptEditor",
            args: [partId]
        };
        target.sendMessage(msg, target);
    },

    _openGrammar: function(partId, ruleName){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openGrammar",
            args: [partId, ruleName]
        };
        target.sendMessage(msg, target);
    },

    // At the moment this simply opens a st-window st-field with
    // information about the available commands for said parts
    _openDebugger: function(partId, type, name){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openDebugger",
            args: [partId, type, name]
        };
        target.sendMessage(msg, target);
    }
};




/***/ }),

/***/ "./js/objects/utils/handInterface.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/handInterface.js ***!
  \*******************************************/
/*! exports provided: Testables, handInterface, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Testables", function() { return Testables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handInterface", function() { return handInterface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return handInterface; });
const video = document.createElement('video');
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

const scaleDim = (dim) => {
    const scale = 0.7;
    const stride = 16;
    const evenRes = dim * scale - 1;
    return evenRes - (evenRes % stride) + 1;
};

const detectHands = async () => {
    if (!handInterface.handDetectionRunning) {
        return;
    }
    const scaledWidth = scaleDim(canvas.width);
    const scaledHeight = scaleDim(canvas.height);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const image = tf.tidy(() => {
        return tf.fromPixels(canvas).resizeBilinear([scaledHeight, scaledWidth]).expandDims(0);
    });
    const [scores, tboxes] = await handInterface.handDetectionModel.executeAsync(image);
    image.dispose();
    const handsDetected = tf.tidy(() => {
        const indices = tf.image.nonMaxSuppression(
            tboxes.reshape([tboxes.shape[1], tboxes.shape[3]]),
            scores.reshape([scores.shape[1]]),
            20,
            0.5,
            0.85).dataSync();
        var boxes = [];
        var idx;
        for (let i = 0; i < indices.length; i++) {
            idx = indices[i];
            var score = scores.get(0, idx, 0);
            // Original order is [minY, minX, maxY, maxX] so we reorder.
            var box = {
                upperLeft: [tboxes.get(0, idx, 0, 1), tboxes.get(0, idx, 0, 0)],
                lowerRight: [tboxes.get(0, idx, 0, 3), tboxes.get(0, idx, 0, 2)]
            };
            boxes.push({score: score, box: box});
        }
        return {boxes: boxes, timestamp: Date.now()};
    });
    scores.dispose();
    tboxes.dispose();
    if (handsDetected.boxes.length !== 1) {
        if (handInterface.handDetectionRunning) {
            window.requestAnimationFrame(detectHands);
        }
        return;
    }
    const box = handsDetected.boxes[0].box;
    const [x1, y1] = box.upperLeft;
    const [x2, y2] = box.lowerRight;
    const area = {area: (x2 - x1) * (y2 - y1), timestamp: Date.now()};
    handInterface.handDetectionAreas = [].concat(handInterface.handDetectionAreas.slice(-2), [area]);
    // Update hand location
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
    const p = [0.5 * (x1 + x2) * vw, 0.5 * (y1 + y2) * vh];
    handInterface.positions = [].concat(handInterface.positions.slice(-2), [p]);
    var target = handInterface.targetElement;
    if (target === null) {
        target = handInterface.leninHand;
    }
    // Compute average position
    const [p1, p2, p3] = handInterface.positions;
    const [ap1, ap2] = [(1/3)*(p1[0] + p2[0] + p3[0]), (1/3)*(p1[1] + p2[1] + p3[1])];
    target.partProperties.setPropertyNamed(target, "left", ap1);
    target.partProperties.setPropertyNamed(target, "top", ap2);
    // Extract area information without any timestamps
    var justAreas = [];
    for (var i = 0; i < handInterface.handDetectionAreas.length; ++i) {
        justAreas.push(handInterface.handDetectionAreas[i].area);
    }
    var justAreas = [].concat(Array(3 - justAreas.length).fill(0), justAreas);
    // Check if hand is pushing in
    const [a1, a2, a3] = justAreas;
    const aveArea = (1/3) * (a1 + a2 + a3);
    if (aveArea > 0.25) {
        if (!handInterface.handMasked) {
            handInterface.handMasked = true;
            setTimeout(() => { handInterface.handMasked = false; }, 3000);
            if (handInterface.targetElement === null) {
                let closestView = findClosestView([p1, p2]);
                if (closestView !== null) {
                    handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", true);
                    handInterface.targetElement = closestView.model;
                }
            } else {
                handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", false);
                handInterface.targetElement = null;
            }
        }
    }
    if (handInterface.handDetectionRunning) {
        window.requestAnimationFrame(detectHands);
    }
};

const findClosestView = (point) => {
    let views = [];
    window.System.getCurrentCardModel().subparts.forEach((part) => {
        let partViews = window.System.findViewsById(part.id);
        partViews.forEach((view) => {
            views.push(view);
        })
    });
    var [closestDist, closestView] = [Infinity, null];
    views.forEach((view) => {
        let viewDist = dist(point, getVertices(view));
        if (viewDist < closestDist) {
            closestDist = viewDist;
            closestView = view;
        }
    });
    return closestView;
}

// https://aaronsmith.online/easily-load-an-external-script-using-javascript/
const loadScript = src => {
    return new Promise((resolve, reject) => {
        if (typeof window.tf !== 'undefined') {
            console.log("tensorflowjs already loaded");
            resolve();
            return;
        }
        console.log("loading tensorflowjs");
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.onload = resolve;
        script.onerror = reject;
        script.src = src;
        document.head.append(script);
    });
};

const loadHandDetectionModel = () => {
    handInterface.handDetectionAreas = [];
    loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.5/dist/tf.js").then(() => {
        window.tf.loadFrozenModel(
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/tensorflowjs_model.pb",
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/weights_manifest.json"
        ).then(model => {
            console.log("hand detection model loaded");
            handInterface.handDetectionModel = model;
        }).then(() => {
            return navigator.mediaDevices.getUserMedia({ video: true });
        }).then(stream => {
            video.srcObject = stream;
            return video.play();
        }).then(() => {
            console.log("video started");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0); // Mirror incoming video
            handInterface.handDetectionRunning = true;
            handInterface.leninHand = window.System.newModel('image', window.System.getWorldStackModel().id, "/images/leninHand.png");
            handInterface.targetElement = null;
            window.requestAnimationFrame(detectHands);
        }).catch(err => {
            console.log("error loading hand detection model");
            console.log(err);
        });
    });
}

const unloadHandDetectionModel = () => {
    handInterface.handDetectionRunning = false;
    window.System.deleteModel(handInterface.leninHand.id)
    handInterface.leninHand = null;
    video.pause();
    const tracks = video.srcObject.getTracks();
    for (var i = 0; i < tracks.length; i++) {
        tracks[i].stop();
    }
    video.srcObject = null;
    console.log("video stopped");
    handInterface.handDetectionModel = null;
    console.log("unloading hand detection model");
}

const getVertices = (element) => {
    const rect = element.getBoundingClientRect();
    const upperLeft = [rect.x, rect.y];
    const upperRight = [rect.x + rect.width, rect.y];
    const lowerLeft = [rect.x, rect.y + rect.height];
    const lowerRight = [rect.x + rect.width, rect.y + rect.height];
    return {
        upperLeft: upperLeft,
        upperRight: upperRight,
        lowerLeft: lowerLeft,
        lowerRight: lowerRight
    };
}

const dist = (point, vertices) => {
    const [p1, p2] = point;
    const [ul1, ul2] = vertices.upperLeft;
    const [ll1, ll2] = vertices.lowerLeft;
    const [ur1, ur2] = vertices.upperRight;
    const [lr1, lr2] = vertices.lowerRight;
    // First check if the point is inside the rectangle
    // Next we compute the vector pointing from the point to the closest point
    // on the rectangle. There are 9 cases. The first is when the poinst is
    // inside the rectangle. The next four cases are if the point in one of
    // the four corners and the final four cases are when the point is on one
    // of the four sides.
    var [v1, v2] = [null, null];
    if ((ul1 <= p1) && (p1 <= lr1) && (ul2 <= p2) && (p2 <= lr2)) {
        // Case 0: inside the rectangle
        [v1, v2] = [0, 0];
    } else if ((p1 <= ul1) && (p2 <= ul2)) {
        // Case 1: upper left
        [v1, v2] = [ul1 - p1, ul2 - p2];
    } else if ((p1 >= ur1) && (p2 <= ur2)) {
        // Case 2: upper right
        [v1, v2] = [ur1 - p1, ur2 - p2];
    } else if ((p1 <= ll1) && (p2 >= ll2)) {
        // Case 3: lower left
        [v1, v2] = [ll1 - p1, ll2 - p2];
    } else if ((p1 >= lr1) && (p2 >= lr2)) {
        // Case 4: lower right
        [v1, v2] = [lr1 - p1, lr2 - p2];
    } else if (p1 <= ul1) {
        // Case 5: side left
        [v1, v2] = [ul1 - p1, 0];
    } else if (p1 >= lr1) {
        // Case 6: side right
        [v1, v2] = [lr1 - p1, 0];
    } else if (p2 <= ul2) {
        // Case 7: side top
        [v1, v2] = [0, ul2 - p2];
    } else if (p2 >= lr2) {
        // Case 8: side bottom
        [v1, v2] = [0, lr2 - p2];
    } else {
        // Case 9: inside
        [v1, v2] = [0, 0];
    }
    return Math.sqrt(v1*v1 + v2*v2);
}

class HandInterface {
    constructor() {
        this.handDetectionModel = null;
        this.handDetectionRunning = false;
        this.leninHand = null;
        this.handMasked = false;
        this.targetElement = null;
        this.handDetectionAreas = [];
        this.positions = [[0, 0], [0, 0], [0, 0]];
        // XXX - Only here to ignore the tensorflow warnings
        console.warn = () => {};
    }

    start() {
        loadHandDetectionModel();
    }

    stop() {
        unloadHandDetectionModel();
    }
}

const Testables = {
    dist: dist
}

const handInterface = new HandInterface();




/***/ }),

/***/ "./js/objects/utils/icons.js":
/*!***********************************!*\
  !*** ./js/objects/utils/icons.js ***!
  \***********************************/
/*! exports provided: partIcons, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partIcons", function() { return partIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return partIcons; });
let partIcons = {};

partIcons.world = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-world" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <line x1="3.6" y1="9" x2="20.4" y2="9" />
  <line x1="3.6" y1="15" x2="20.4" y2="15" />
  <path d="M11.5 3a17 17 0 0 0 0 18" />
  <path d="M12.5 3a17 17 0 0 1 0 18" />
</svg>
`;

partIcons.stack = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="12 4 4 8 12 12 20 8 12 4" />
  <polyline points="4 12 12 16 20 12" />
  <polyline points="4 16 12 20 20 16" />
</svg>
`;

partIcons.card = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>
`;

partIcons.button = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hand-finger" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M8 13v-8.5a1.5 1.5 0 0 1 3 0v7.5" />
  <path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0v2.5" />
  <path d="M14 10.5a1.5 1.5 0 0 1 3 0v1.5" />
  <path d="M17 11.5a1.5 1.5 0 0 1 3 0v4.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" />
</svg>
`;

partIcons.window = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-window" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3c-3.866 0 -7 3.272 -7 7v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1 -1v-10c0 -3.728 -3.134 -7 -7 -7z" />
  <line x1="5" y1="13" x2="19" y2="13" />
  <line x1="12" y1="3" x2="12" y2="21" />
</svg>
`;

partIcons.area = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-shape" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="5" cy="5" r="2" />
  <circle cx="19" cy="5" r="2" />
  <circle cx="5" cy="19" r="2" />
  <circle cx="19" cy="19" r="2" />
  <line x1="5" y1="7" x2="5" y2="17" />
  <line x1="7" y1="5" x2="17" y2="5" />
  <line x1="7" y1="19" x2="17" y2="19" />
  <line x1="19" y1="7" x2="19" y2="17" />
</svg>
`;

partIcons.field = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-forms" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3a3 3 0 0 0 -3 3v12a3 3 0 0 0 3 3" />
  <path d="M6 3a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3" />
  <path d="M13 7h7a1 1 0 0 1 1 1v8a1 1 0 0 1 -1 1h-7" />
  <path d="M5 7h-1a1 1 0 0 0 -1 1v8a1 1 0 0 0 1 1h1" />
  <path d="M17 12h.01" />
  <path d="M13 12h.01" />
</svg>
`;

partIcons.drawing = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-palette" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 21a9 9 0 1 1 0 -18a9 8 0 0 1 9 8a4.5 4 0 0 1 -4.5 4h-2.5a2 2 0 0 0 -1 3.75a1.3 1.3 0 0 1 -1 2.25" />
  <circle cx="7.5" cy="10.5" r=".5" fill="currentColor" />
  <circle cx="12" cy="7.5" r=".5" fill="currentColor" />
  <circle cx="16.5" cy="10.5" r=".5" fill="currentColor" />
</svg>
`;

partIcons.image = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="15" y1="8" x2="15.01" y2="8" />
  <rect x="4" y="4" width="16" height="16" rx="3" />
  <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5" />
  <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2" />
</svg>
`;

partIcons.generic = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-puzzle" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 7h3a1 1 0 0 0 1 -1v-1a2 2 0 0 1 4 0v1a1 1 0 0 0 1 1h3a1 1 0 0 1 1 1v3a1 1 0 0 0 1 1h1a2 2 0 0 1 0 4h-1a1 1 0 0 0 -1 1v3a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-1a2 2 0 0 0 -4 0v1a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1h1a2 2 0 0 0 0 -4h-1a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1" />
</svg>
`;




/***/ }),

/***/ "./js/objects/utils/id.js":
/*!********************************!*\
  !*** ./js/objects/utils/id.js ***!
  \********************************/
/*! exports provided: idMaker, isValidId, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idMaker", function() { return idMaker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidId", function() { return isValidId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return idMaker; });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_0__);
// ID related utilities



/**
 * ID Maker
 * ------------------------------------
 * I am responsible for creating globally
 * unique ID values for Parts in the SimpleTalk
 * world.
 * HC requires that all Parts have unique ids and
 * that these should not be repeated in any given
 * "application" instance.
 * We need to determine what an "application" is
 * in our context, but regardless we can use this
 * module as a drop in replacement, implementing
 * UUIDs or URLs or whatever we want.
 * For now we just increment an integer.
 */
const idMaker = {
    new: function(){
        let id = Object(uuid__WEBPACK_IMPORTED_MODULE_0__["v4"])();
        return id.replace(/-/g, '');
    }
};

/* ID checker
 * --------------------------------------
 * I am responsible for checking whether an id is
 * is valid and returning it if so
 */
const isValidId = function(id) {
    if(id === null || id === undefined || id === ""){
        return false;
    }
    if(id.length != 32 || id.match('[a-z0-9]*')[0].length != 32) {
        return false;
    }
    return id;
};




/***/ }),

/***/ "./js/objects/utils/merriamInterface.js":
/*!**********************************************!*\
  !*** ./js/objects/utils/merriamInterface.js ***!
  \**********************************************/
/*! exports provided: merriamSimScore, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriamSimScore", function() { return merriamSimScore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriamSimScore; });
const merriamSimScore = async (sender, docId) => {
    const url = "https://patents.merriamtech.com/_api/merriam/"
    const payload = {
        "fields": [
            "title",
            "date_publ"
        ],
        "weights": {
            "merriam":0.7,
            "date":0.3,
            "hierarchy":0.1
        },
        "doc_ids": [
            docId
        ],
        "limit": 5}
    const params = {
        "method": "POST",
        "headers": {
            "content-type": "application/json"
        },
        "body": JSON.stringify(payload)
    }
    fetch(url, params).then(data => {
        return data.json();
    }).then(json => {
        const msg = {
            type: 'command',
            commandName: 'merriamresult',
            args: [
                JSON.stringify(json)
            ]
        };
        sender.sendMessage(msg, sender);
    });
}




/***/ }),

/***/ "./js/objects/utils/serialization.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/serialization.js ***!
  \*******************************************/
/*! exports provided: STSerializer, STDeserializer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STSerializer", function() { return STSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STDeserializer", function() { return STDeserializer; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/**
 * Serialization and Deserialization Utility Classes
 */


const version = "0.0.2";

class STDeserializer {
    constructor(aSystem){
        this.system = aSystem;

        // These caches are used during the process
        // as optimizations
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];

        // The targetId is the id of
        // the Part that we wish to append any
        // deserialized subpart tree into.
        // By default we assume the whole system,
        // ie full deserialization.
        this.targetId = 'system';
        // the root id is the id of the root part instance
        // being attached
        this.rootId = null;

        // Bound methods
        this.deserialize = this.deserialize.bind(this);
        this.deserializeData = this.deserializeData.bind(this);
        this.deserializePart = this.deserializePart.bind(this);
        this.attachSubparts = this.attachSubparts.bind(this);
        this.setProperties = this.setProperties.bind(this);
        this.createView = this.createView.bind(this);
        this.attachView = this.attachView.bind(this);
        this.setViewModel = this.setViewModel.bind(this);
        this.compilePartScript = this.compilePartScript.bind(this);
        this.refreshWorld = this.refreshWorld.bind(this);
        this.appendWorld = this.appendWorld.bind(this);
        this.addPartsToSystem = this.addPartsToSystem.bind(this);
        this.compileScripts = this.compileScripts.bind(this);
        this.getFlattenedPartTree = this.getFlattenedPartTree.bind(this);
        this.getModelClass = this.getModelClass.bind(this);
        this.handleId = this.handleId.bind(this);
        this.throwError = this.throwError.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
        this.dispatchViewAdded = this.dispatchViewAdded.bind(this);
    }

    deserialize(aJSONString){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        return this.deserializeData()
            .then(() => {
                // Add all deserialized Parts to the System dict,
                // including the new World.
                this.addPartsToSystem(this._instanceCache);
            })
            .then(() => {
                // Compile the scripts on *all* deserialized
                // parts
                this.compileScripts(this._instanceCache);
            })
            .then(() => {
                // Insert the root Part into whatever
                // target it should go into.
                let rootPart = this.rootParts[0];
                let rootView = this.rootViews[0];
                if(this.targetId == 'system'){
                    this.refreshWorld();
                } else {
                    target.addPart(rootPart);
                }

                // Finally, append the PartView root node
                // where it should go in the view tree.
                if(this.targetId == 'system'){
                    this.appendWorld();
                } else {
                    let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
                    targetView.appendChild(rootView);
                    this.dispatchViewAdded(rootView);
                    rootPart.sendMessage({
                        type: 'command',
                        commandName: 'newModel',
                        args: [],
                        shouldNotDelegate: true,
                        shouldIgnore: true
                    }, rootPart);
                }
                return this;
            });
    }

    deserializeData(){
        return new Promise((resolve, reject) => {
            this.flushCaches();
            // First, we ensure that the target we
            // should be deserializing into actually exists
            let target = this.system.partsById[this.targetId];
            if(!target && this.targetId != 'system'){
                this.throwError(`Target id ${this.targetId} does not exist in System`);
            }

            // Second, we create instances of all models in the serialization
            // but we do not yet attach their subparts.
            Object.values(this.data.parts).forEach(partData => {
                this.deserializePart(Object.assign({}, partData));
            });

            // Translate targets
            for (let modelId in this._propsCache) {
                let props = this._propsCache[modelId];
                if (props.target !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        if (props.target === 'part id ' + oldId) {
                            props.target = 'part id ' + newId;
                            break;
                        }
                    }
                }
            }
            // Translate scripts
            for (let modelId in this._scriptCache) {
                let script = this._scriptCache[modelId];
                if (script !== null && script.match('part id') !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        let oldRe = 'part id ' + oldId;
                        let newRe = 'part id ' + newId;
                        if (this._scriptCache[modelId].match(oldRe) !== null) {
                            console.log(modelId);
                            let re = new RegExp(oldRe, "g");
                            this._scriptCache[modelId] = script.replace(re, newRe);
                        }
                    }
                }
            }

            // Third, we go through each created Part instance
            // and add any subparts to it. Note that this is not
            // recursive
            this._instanceCache.forEach(partInstance => {
                this.attachSubparts(partInstance);
            });

            // Forth and fifth. Create and attach views
            // Note this is recursive to preserve the subpart + view children order
            let root = this._instanceCache.filter((part) => {
                return part.partProperties.getPropertyNamed(part, "id") == this.rootId;
            })[0];
            this.createAndAttachViews(root);

            // Sixth, we set all properties on each created
            // Part model from the deserialized data.
            // We do this using a visitor method on the instances
            // themselves.
            // This gives the in-memory views the ability to
            // react to any initial changes to their models.
            this._instanceCache.forEach(partInstance => {
                this.setProperties(partInstance);
                // We need to translate new ids to old ones
                if (partInstance.name == "WorldStack") {
                    let world = partInstance;
                    world.partProperties.setPropertyNamed(
                        world,
                        "current",
                        this._idCache[world.currentStackId]
                    );
                }
                if (partInstance.name == "Stack") {
                    let stack = partInstance;
                    stack.partProperties.setPropertyNamed(
                        stack,
                        "current",
                        this._idCache[stack.currentCardId]
                    );
                }
                this.setViewModel(partInstance);
            });

            // We determine which of the instances is a "root",
            // meaning that it has, at this point, no owner in
            // the deserialized data. There can be multiple roots
            // (and therefore multiple trees) in a single deserialization
            this._rootsCache = this._instanceCache.filter(instance => {
                return instance._owner == null || instance._owner == undefined;
            });

            // Insertion should be handled by composed
            // promises elsewhere (see imports and deserialize()
            // for examples)

            return resolve(this);
        });
    }

    createAndAttachViews(partInstance){
        this.createView(partInstance);
        this.attachView(partInstance);
        if(partInstance.subparts.length){
            partInstance.subparts.forEach((subpartInstance) => {
                this.createAndAttachViews(subpartInstance);
            });
        }
    }

    importFromSerialization(aJSONString, filterFunction){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
        return this.deserializeData()
            .then(() => {
                // The caller will provide a filter function over
                // all deserialized part instances, returning only
                // those that should be inserted into the target.
                // For example, all Stacks in the WorldStack.
                return this._instanceCache.filter(filterFunction);
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.addPartsToSystem(allTreeParts);
                });
                return rootParts;

            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.compileScripts(allTreeParts);
                });
                return rootParts;
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let view = this._viewsCache[rootPart.id];
                    target.addPart(rootPart);
                    targetView.appendChild(view);
                    this.dispatchViewAdded(view);
                });
            });
    }

    deserializePart(partData){
        let partClass = this.getModelClass(partData.type);
        let instance = new partClass();

        // We create a new ID for this part, since we cannot
        // guarantee ID clashes with the existing System.
        // Exception is if the useOriginalids flag is set,
        // such as at load time
        let {newId, oldId} = this.handleId(instance, partData);
        instance.id = newId;
        // cache the new root ID if this is a root instance
        if(this.data.rootId == oldId){
            this.rootId = newId;
        }

        // Add to our caches and also to the System
        this._idCache[oldId] = newId;
        this._scriptCache[newId] = partData.properties.script;
        this._propsCache[newId] = partData.properties;
        this._modelCache[newId] = instance;
        this._subpartMapCache[newId] = partData.subparts;
        this._instanceCache.push(instance);
    }

    handleId(aPart, partData){
        let newId, oldId;
        oldId = partData.id;
        newId = aPart.id;
        if(aPart.type !== 'world'){
            newId = _id_js__WEBPACK_IMPORTED_MODULE_0__["default"].new();
        }
        return {
            newId,
            oldId
        };
    }

    addPartsToSystem(aListOfParts){
        aListOfParts.forEach(part => {
            this.system.partsById[part.id] = part;
        });
    }

    compileScripts(aListOfParts){
        aListOfParts.forEach(part => {
            this.compilePartScript(part);
        });
    }

    attachSubparts(aPart){
        // At this point, the _subpartMapCache should
        // have an entry mapping from this aPart's (new)
        // id to an array of ids of also-initialized
        // subpart models
        let subpartIds = this._subpartMapCache[aPart.id];
        subpartIds.forEach(subpartId => {
            let newId = this._idCache[subpartId];
            let subpartModel = this._modelCache[newId];
            if(!subpartModel){
                debugger;
            }
            aPart.addPart(subpartModel);
        });
    }

    setProperties(aPart){
        let props = this._propsCache[aPart.id];
        delete props['id'];
        aPart.setPropsFromDeserializer(props, this);
    }

    createView(aPart){
        let newView = document.createElement(
            this.system.tagNameForViewNamed(aPart.type)
        );
        // we need to set the part-id attribute since these
        // are used for queries needed for things like
        // current stack and card
        newView.setAttribute("part-id", aPart.id);
        this._viewsCache[aPart.id] = newView;
    }

    setViewModel(aPart){
        let view = this._viewsCache[aPart.id];
        view.setModel(aPart);
    }
    
    attachView(aPart){
        let owner = aPart._owner;
        if(owner){
            let ownerView = this._viewsCache[owner.id];
            let partView = this._viewsCache[aPart.id];
            owner.sendMessage({
                type: "viewChanged",
                changeName: "subpart-new",
                args: [partView]
            }, ownerView);
        }
    }

    compilePartScript(aPart){
        let scriptString = this._scriptCache[aPart.id];
        if(scriptString && scriptString != ""){
            this.system.compile({
                type: 'compile',
                targetId: aPart.id,
                codeString: scriptString,
                serialize: false
            });
        }
    }

    refreshWorld(){
        // We assume a single root part was deserialized and
        // attach it as the World accordingly
        let newWorld = this.rootParts[0];
        if(newWorld.type !== 'world'){
            this.throwError(`Found ${this.rootParts.length} roots, but no world!`);
        }
        this.system.partsById['world'] = this.rootParts[0];
    }

    appendWorld(){
        // We assume a single root view that is an st-world.
        let found = document.querySelector('st-world');
        if(found){
            document.body.replaceChild(this.rootViews[0], found);
        } else {
            document.body.prepend(this.rootViews[0]);
        }
        this.dispatchViewAdded(document.querySelector('st-world'));
    }

    getFlattenedPartTree(aPart, list=[]){
        list.push(aPart);
        aPart.subparts.forEach(subpart => {
            this.getFlattenedPartTree(subpart, list);
        });
        return list;
    }

    throwError(message){
        throw new Error(`Deserialization Error: ${message}`);
    }

    getModelClass(aPartTypeStr){
        let cls = this.system.availableParts[aPartTypeStr];
        if(!cls){
            this.throwError(`Part type "${aPartTypeStr}" does not exist in system`);
        }
        return cls;
    }

    flushCaches(){
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];
    }

    dispatchViewAdded(aView){
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: aView.model.type,
                partId: aView.model.id,
                //ownerId: aView.model._owner.id || null
            } 
        });
        aView.parentElement.dispatchEvent(event);
    }

    get rootParts(){
        return this._rootsCache;
    }

    get rootViews(){
        return this.rootParts.map(part => {
            return this._viewsCache[part.id];
        });
    }
}


class STSerializer {
    constructor(aSystem){
        this.system = aSystem;
        this._objectCache = {};

        // Bound methods
        this.serializePart = this.serializePart.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
    }

    serialize(aRootPart, pretty=true){
        this.flushCaches();
        let result = {
            version: version,
            rootId: aRootPart.id,
            type: aRootPart.type,
            id: aRootPart.id
        };

        // Recursively serialize Parts and
        // store in flat list
        this.serializePart(aRootPart);

        // We set the result objects parts
        // dict to be the same as the cache
        result.parts = this._objectCache;

        // Finally, we convert to a string and
        // return
        if(pretty){
            return JSON.stringify(result, null, 4);
        } else {
            return JSON.stringify(result);
        }
    }

    serializePart(aPart){
        // We use the serialize method available on
        // base Parts, passing in this serializer instance
        // as the sole arg
        this._objectCache[aPart.id] = aPart.serialize(this);
        aPart.subparts.forEach(subpart => {
            this.serializePart(subpart);
        });
    }

    flushCaches(){
        this._objectCache = {};
    }
}




/***/ }),

/***/ "./js/objects/utils/styleProperties.js":
/*!*********************************************!*\
  !*** ./js/objects/utils/styleProperties.js ***!
  \*********************************************/
/*! exports provided: addBasicStyleProps, addPositioningStyleProps, addTextStyleProps, addLayoutStyleProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addBasicStyleProps", function() { return addBasicStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPositioningStyleProps", function() { return addPositioningStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTextStyleProps", function() { return addTextStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLayoutStyleProps", function() { return addLayoutStyleProps; });
/**
 * Helpers for setting up various
 * style properties
 */


/**
 * Basic style properties are those
 * common to all (visual) Parts
 */
const sides = ["top", "bottom", "left", "right"];

const addBasicStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'background-transparency',
        1,
    );
    target.partProperties.newStyleProp(
        'background-color',
        "rgb(255, 255, 255)", // white 
    );
    target.partProperties.newStyleProp(
        'transparency',
        1.0,
    );
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-style`,
            'solid'
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-width`,
            0,
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-color`,
            "rgb(0, 0, 0)", // black
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-transparency`,
            1
        );
    });
    target.partProperties.newStyleProp(
        'shadow-left',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-top',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-blur',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-spread',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-color',
        "rgb(238, 238, 238)", // grey
    );
    target.partProperties.newStyleProp(
        'shadow-transparency',
        1
    );
    target.partProperties.newStyleProp(
        'corner-top-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-top-right-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-right-round',
        0
    );
};

/**
 * Style properties for Parts that can
 * be moved and that can have explicit
 * dimensions. Examples: buttons, fields.
 * Examples of those that can't: Cards, Stacks
 */
const addPositioningStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'hide',
        false,
    );
    // setting width and height to null
    // effectively forces to the default size
    // of the button to fit the button name
    target.partProperties.newStyleProp(
        'width',
        100,
    );
    target.partProperties.newStyleProp(
        'height',
        null,
    );
    target.partProperties.newStyleProp(
        'top',
        0,
    );
    target.partProperties.newStyleProp(
        'left',
        0,
    );
    target.partProperties.newStyleProp(
        'rotate',
        null,
    );

    // horizontal-resizing specifies a strategy
    // for how this Part should adjust its
    // horizontal axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // horizontal axis in the parent Part.
    target.partProperties.newStyleProp(
        'horizontal-resizing',
        'rigid'
    );

    // vertical-resizing specifies a strategy
    // for how this Part should adjust its
    // vertical axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // vertical axis in the parent Part.
    target.partProperties.newStyleProp(
        'vertical-resizing',
        'rigid'
    );

    // Margin specifies some space between the
    // target Part and any other Parts that might
    // be adjacent to it in a common Owner. It will
    // not be in effect when the owner is using a
    // strict layout.
    target.partProperties.newStyleProp(
        'top-margin',
        null
    );
    target.partProperties.newStyleProp(
        'right-margin',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-margin',
        null
    );
    target.partProperties.newStyleProp(
        'left-margin',
        null
    );

    // Pinning specifies whether or not
    // a given part should "stick" to a
    // particular side of its owner Part.
    // Pinning properties only have effect
    // inside of Parts with a strict layout
    target.partProperties.newDynamicProp(
        'pinning-top',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-left',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-bottom',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        'pinning-right',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        // Possible values for the compound
        // 'pinning' property are:
        // *"none" or null
        // *top
        // *top-right
        // *top-left
        // *bottom
        // *bottom-right
        // *bottom-left
        // *left
        // *right
        'pinning',
        // Setter
        function(propOwner, propObject, value){
            if(!value || value == "none"){
                ['top', 'left', 'right', 'bottom'].forEach(side => {
                    let pin = `pinning-${side}`;
                    propOwner.partProperties.setPropertyNamed(
                        propOwner,
                        pin,
                        false
                    );
                });
                return;
            }
            pinningAdjust(propOwner, value);
        },

        // Getter
        function(propOwner, propObject){
            let top = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-top'
            );
            let bottom = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-bottom'
            );
            let left = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-left'
            );
            let right = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-right'
            );
            let result = [];
            if(top){
                result.push('top');
            } else if(bottom){
                result.push('bottom');
            }
            if(left){
                result.push('left');
            } else if(right){
                result.push('right');
            }

            return result.join('-');
        }
    );
};

/**
 * Style properties for Parts that display
 * text
 */
const addTextStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'text-align',
        'left',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-font',
        'default',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-color',
        "rgb(0, 0, 0)", // black
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-transparency',
        1,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-style',
        'plain',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-bold',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-italic',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-size',
        15,
        'cssTextStyle'
    );
};

/**
 * Basic layout styles are those pertaining
 * to the positioning and resizing of subparts.
 * Examples include Cards and Area
 */
const addLayoutStyleProps = (target) => {
    // The 'layout' property is
    // one of two strings:
    // strict - Equivalent to the absolute
    // layout based strictly on coordinates
    // list - Will force items into either a row
    // or column list, based on the pairing with
    // the 'listDirection' property
    target.partProperties.newBasicProp(
        'layout',
        'strict'
    );

    // list-direction specifies row or column
    // and will only have an effect whent the
    // layout property is set to 'list'
    target.partProperties.newBasicProp(
        'list-direction',
        'row'
    );

    // Wrapping specifies whether a list should
    // wrap along its dominant dimension (row or column)
    target.partProperties.newBasicProp(
        'list-wrapping',
        false
    );

    // Padding specifies some space from the
    // border of the target Part to the beginning
    // of the layout of any subparts.
    target.partProperties.newStyleProp(
        'top-padding',
        null
    );
    target.partProperties.newStyleProp(
        'right-padding',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-padding',
        null
    );
    target.partProperties.newStyleProp(
        'left-padding',
        null
    );

    // List alignment describes how elements in
    // a list layout should align themselves along
    // the dominant dimension (row or column)
    // They are essentially proxies for align-items
    target.partProperties.newBasicProp(
        'list-alignment',
        null
    );

    // List distribution describes how elements
    // in a list layout should distribute themselves
    // across or along the dominant dimension
    // (row or column)
    // This is essentially a wrapper for justify-content
    target.partProperties.newBasicProp(
        'list-distribution',
        null
    );
};

/**
  * HELPERS
 **/

const pinningSetter = (propOwner, propObject, value) => {
    let side = propObject.name.split("-")[1];
    let topLeft;
    switch (side){
    case "right":
        topLeft = "left";
        break;
    case "bottom":
        topLeft = "top";
        break;
    default:
        topLeft = side;
    }
    // we'll need to fix and un-fix the corresponding top or left property depending
    // on whether value is true of false, respectively
    let prop = propOwner.partProperties.findPropertyNamed(
        topLeft 
    );
    let oppositeSide;
    switch (side){
    case "left":
        oppositeSide = "right";
        break;
    case "right":
        oppositeSide = "left";
        break;
    case "top":
        oppositeSide = "bottom";
        break;
    case "bottom":
        oppositeSide = "top";
        break;
    }
    if(value){
        // first make sure that pinning-bottom is false
        propOwner.partProperties.setPropertyNamed(
            propOwner,
            `pinning-${oppositeSide}`,
            false
        );
        prop.readOnly = true;
    } else {
        // reset the value back to trigger a notification
        prop.setValue(propOwner, prop._value);
        prop.readOnly = false;
    }
    propObject._value = value;
};

const pinningAdjust = (owner, value) => {
    let sides = ['top', 'left', 'right', 'bottom'];
    sides.forEach(side => {
        if(value.startsWith(side)){
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                true
            );
        } else {
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                false
            );
        }
    });

    if(value.includes("-")){
        if(value.endsWith('left')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                true
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                false
            );
        } else if(value.endsWith('right')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                false
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                true
            );
        }
    }
};




/***/ }),

/***/ "./js/objects/utils/styler.js":
/*!************************************!*\
  !*** ./js/objects/utils/styler.js ***!
  \************************************/
/*! exports provided: cssStyler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssStyler", function() { return cssStyler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cssStyler; });
/**
 * Styler
 * ------------------------------------
 * I am responsible for converting
 * SimpleTalk visual styling to a dict
 * Object of CSS JavaScript type key-value pairs
 */

/** I style the styleObj
 * styleObj: css JavaScript key:value pairs
 * propertyName: (SimpleTalk) styling property name
 * propertyValue: (SimpleTalk) styling property value
 */

const cssStyler = (styleObj, propertyName, propertyValue) => {
    switch(propertyName){

    case "background-color":
        _setOrNot(styleObj, "backgroundColor",  _colorToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "background-transparency":
        // here we set the Alpha value of the current styleObj["backgroundColor"] rgba
        _setOrNot(styleObj, "backgroundColor",  _colorTransparencyToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "border-top-style":
    case "border-bottom-style":
    case "border-left-style":
    case "border-right-style": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-style`,  propertyValue);
        break;
    }

    case "border-top-width":
    case "border-bottom-width":
    case "border-left-width":
    case "border-right-width": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-width`,  _intToPx(propertyValue));
        break;
    }

    case "border-top-color":
    case "border-bottom-color":
    case "border-top-color":
    case "border-right-color": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "border-top-transparency":
    case "border-bottom-transparency":
    case "border-left-transparency":
    case "border-right-transparency": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorTransparencyToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "corner-top-left-round":
    case "corner-top-right-round":
    case "corner-bottom-left-round":
    case "corner-bottom-right-round":{
        let c1 = propertyName.split("-")[1];
        let c2 = propertyName.split("-")[2];
        _setOrNot(styleObj, `border-${c1}-${c2}-radius`,  _intToPx(propertyValue));
        break;
    }

    case "shadow-left":
    case "shadow-top":
    case "shadow-blur":
    case "shadow-spread":
    case "shadow-color":
    case "shadow-transparency":
        let shadowProp = propertyName.split("-")[1];
        let [left, top, blur, spread, color] = _cssBoxShadow(styleObj["box-shadow"]);
        switch(shadowProp){
        case "color":
            color = _colorToRGBA(color, propertyValue);
            break;
        case "transparency":
            color = _colorTransparencyToRGBA(color, propertyValue);
            break;
        case "left":
            left = _intToPx(propertyValue);
            break;
        case "top":
            top = _intToPx(propertyValue);
            break;
        case "blur":
            blur = _intToPx(propertyValue);
            break;
        case "spread":
            spread = _intToPx(propertyValue);
            break;
        }
        _setOrNot(styleObj, "box-shadow", `${left} ${top} ${blur} ${spread} ${color}`);
        break;

    case "text-color":
        _setOrNot(styleObj, "color",  _colorToRGBA(styleObj["color"], propertyValue));
        break;

    case "text-font":
        _setOrNot(styleObj, "fontFamily",  propertyValue);
        break;

    case "text-size":
        _setOrNot(styleObj, "fontSize", propertyValue);
        break;

    case "text-align":
        _setOrNot(styleObj, "textAlign",  propertyValue);
        break;

    case "text-bold":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-weight",  "bold");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-weight",  "normal");
        }
        break;

    case "text-italic":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-style",  "italic");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-style",  "normal");
        }
        break;

    case "text-underline":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "underline");
        }
        break;

    case "text-strikethrough":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "line-through");
        }
        break;

    case "text-transparency":
        // here we set the Alpha value of the current styleObj["color"] rgba
        _setOrNot(styleObj, "color",  _colorTransparencyToRGBA(styleObj["color"], propertyValue));
        break;

    case "top":
        _setOrNot(styleObj, "top",  _intToPx(propertyValue));
        break;

    case "left":
        _setOrNot(styleObj, "left",  _intToPx(propertyValue));
        break;

    case "width":
        _setOrNot(styleObj, "width",  _intToPx(propertyValue));
        break;

    case "height":
        _setOrNot(styleObj, "height",  _intToPx(propertyValue));
        break;

    case "left-margin":
    case "right-margin":
    case "bottom-margin":
    case "top-margin":
        let marginSide = propertyName.split("-")[0];
        marginSide = `${marginSide[0].toUpperCase()}${marginSide.slice(1)}`;
        _setOrNot(styleObj, `margin${marginSide}`, _intToPx(propertyValue));
        break;

    case "left-padding":
    case "right-padding":
    case "bottom-padding":
    case "top-padding":
        let paddingSide = propertyName.split("-")[0];
        paddingSide = `${paddingSide[0].toUpperCase()}${paddingSide.slice(1)}`;
        _setOrNot(styleObj, `padding${paddingSide}`, _intToPx(propertyValue));
        break;

    case "text-style":
        _setOrNot(styleObj, "textStyle",  propertyValue);
        break;

    case "rotate":
        _setOrNot(styleObj, "transform",  _intToRotateDeg(propertyValue));
        break;

    case "transparency":
        _setOrNot(styleObj, "opacity",  propertyValue);
        break;

    case "hide":
        if(propertyValue === true){
            styleObj["display"] = "none";
        } else if(propertyValue === false){
            styleObj["display"] = null;
        }
        break;


    default:
        // for the default we simply allow ST style names to map 1-1
        // to CSS/JS style names. This is only somewhat safe, since the DOM
        // will simply ignore nonsense names without throwing an error. But it
        // does allow us to avoid writing a rule for every term (example: width,
        // height, top, left etc)
        _setOrNot(styleObj, propertyName,  propertyValue);
    }
    return styleObj;

};

// In order to avoid clashing with views interacting
// the style attribute directly we ignore everything that
// is either null or undefined
// TODO review this decision!
const _setOrNot = (styleObj, name, value) => {
    if(value !== null && value !== undefined){
        styleObj[name] = value;
    }
};

const _intToRotateDeg = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            n = n.split("deg")[0];
        }
        return `rotate(${n}deg)`;
    }
};


const _intToPx = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            if(n == "fill"){
                return "100%";
            } else if(["thin", "medium", "thick"].indexOf(n) > -1){
                return n;
            }
            n = n.split("px")[0];
        }
        return `${n}px`;
    }
};

// Convert colors to rgba
// change a css color RGB values, preserving the A(lpha) value
const _colorToRGBA = (cssColor, STColor) => {
    if(!STColor){
        return;
    }
    let r, g, b, a, _;
    // ST colors are RGB
    if(STColor.startsWith("rgb")){
        [r, g, b] = STColor.match(/\d+/g);
    } else {
        let colorInfo = basicCSSColors[STColor];
        if(colorInfo){
            r = colorInfo["r"];
            g = colorInfo["g"];
            b = colorInfo["b"];
        } else {
            return;
        }
    }
    if(cssColor){
        [_, _, _, a] = cssColor.match(/[\d\.]+/g);
        // if Alpha is not defined then we set it to 1
        // default for browsers
    }
    if(!a){
        a = 1;
    }
    return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// change the A(alpha) value, preserving the RGB values
const _colorTransparencyToRGBA = (cssColor, tValue) => {
    if(!cssColor){
        return;
    }

    let r, g, b;
    let mappedColor = basicCSSColors[cssColor];
    if(mappedColor){
        r = mappedColor.r;
        g = mappedColor.g;
        b = mappedColor.b;
    } else {
        [r, g, b] = cssColor.match(/\d+/g);
    }
    
    return `rgba(${r}, ${g}, ${b}, ${tValue})`;
}

// Add more colors as needed
const basicCSSColors = {
    black: {hex: "#000000", r: 0, g: 0, b: 0},
		silver: {hex: "#C0C0C0", r: 192, g: 192, b: 192},
		gray: {hex: "#808080", r: 128, g: 128, b: 128},
		white: {hex: "#FFFFFF", r: 255, g: 255, b: 255},
		maroon: {hex: "#800000", r: 128, g: 0, b: 0},
		red: {hex: "#FF0000", r: 255, g: 0, b: 0},
		purple: {hex: "#800080", r: 128, g: 0, b: 128},
		fuchsia: {hex: "#FF00FF", r: 255, g: 0, b: 255},
		green: {hex: "#008000", r: 0, g: 128, b: 0},
		lime: {hex: "#00FF00", r: 0, g: 255, b: 0},
		olive: {hex: "#808000", r: 128, g: 128, b: 0},
		yellow: {hex: "#FFFF00", r: 255, g: 255, b: 0},
		navy: {hex: "#000080", r: 0, g: 0, b: 128},
		blue: {hex: "#0000FF", r: 0, g: 0, b: 255},
		teal: {hex: "#008080", r: 0, g: 128, b: 128},
		aqua: {hex: "#00FFFF", r: 0, g: 255, b: 255},
};

// take the css box-shadow property and return its
// components (offset-y, offset-x, blur, spread and color)
// if the value is not defined return a default
const _cssBoxShadow = (cssPropValue) =>{
    if(!cssPropValue){
        return ["0px", "0px", "0px", "0px", "rgba(0, 0, 0, 1)"];
    }
    let [intValues, rgba] = cssPropValue.split(" rgba");
    let [left, top, blur, spread] = intValues.split(" ");
    return [left, top, blur, spread, `rgba${rgba}`];
}




/***/ }),

/***/ "./js/objects/views/AreaView.js":
/*!**************************************!*\
  !*** ./js/objects/views/AreaView.js ***!
  \**************************************/
/*! exports provided: AreaView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaView", function() { return AreaView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AreaView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * AreaView
 * -------------------------------
 * I am a webcomponent representation
 * of an Area, which is a grouping of
 * Parts that have some kind of layout
 * specified
 */


const templateString = `
                <style>
                #area-wrapper {
                    display: inherit;
                    flex-direction: inherit;
                    flex-wrap: inherit;
                    align-items: inherit;
                    align-content: inherit;
                    justify-content: inherit;
                    position: relative; 
                    width: 100%;
                    height: 100%;
                    border-radius: inherit;
                }
                .clip {
                    overflow: hidden;  
                }
                .allow-scroll {
                    overflow: auto;
                }
                </style>
                <div id="area-wrapper">
                <slot></slot>
                </div>
`;

class AreaView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.clippingChanged = this.clippingChanged.bind(this);
        this.allowScrollingChanged = this.allowScrollingChanged.bind(this);

        // Prop change handlers
        this.onPropChange('clipping', this.clippingChanged);
        this.onPropChange('allow-scrolling', this.allowScrollingChanged);
    }

    afterModelSet(){
        let clipping = this.model.partProperties.getPropertyNamed(
            this.model,
            "clipping"
        );
        let allowScrolling = this.model.partProperties.getPropertyNamed(
            this.model,
            "allow-scrolling"
        );
        this.clippingChanged(clipping, this.model.id);
        this.allowScrollingChanged(allowScrolling, this.model.id);
    }

    clippingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('allow-scroll');
            wrapper.classList.add('clip');
        } else {
            wrapper.classList.remove('clip');
        }
    }

    allowScrollingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('clip');
            wrapper.classList.add('allow-scroll');
            // this.classList.add('outer-allow-scroll');
        } else {
            // this.classList.remove('outer-allow-scroll');
            wrapper.classList.remove('allow-scroll');
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        let layout = this.model.partProperties.getPropertyNamed(
            this.model,
            'layout'
        );
        let direction = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-direction'
        );
        if(layout != 'list'){
            contextMenu.addListItem(
                "Set Layout to List",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'list'
                    );
                }
            );
        } else {
            contextMenu.addListItem(
                "Set Layout to Strict",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'strict'
                    );
                }
            );
            if(direction == 'row'){
                contextMenu.addListItem(
                    "Set List Direction to Column",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'column'
                        );
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Set List Direction to Row",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'row'
                        );
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/AudioView.js":
/*!***************************************!*\
  !*** ./js/objects/views/AudioView.js ***!
  \***************************************/
/*! exports provided: AudioView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioView", function() { return AudioView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AudioView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <audio></audio>
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-music" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="6" cy="17" r="3"></circle>
    <circle cx="16" cy="17" r="3"></circle>
    <polyline points="9 17 9 4 19 4 19 17"></polyline>
    <line x1="9" y1="8" x2="19" y2="8"></line>
    </svg>
</div>
`;

// HTMLMediaElementStates copied from
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
const mediaStates = {
    0: "HAVE_NOTHING",
    1: "HAVE_METADATA",
    2: "HAVE_CURRENT_DATA",
    3: "HAVE_FUTURE_DATA",
    4: "HAVE_ENOUGH_DATA"
};

class AudioView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateAudioLink = this.updateAudioLink.bind(this);
        this.play = this.play.bind(this);
        this.pause = this.pause.bind(this);
    }

    afterConnected(){
        let audio = this._shadowRoot.querySelector("audio");
        audio.addEventListener('loadeddata', () => {
            let stateCode = audio.readyState;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "readyState",
                mediaStates[stateCode]
            );
        });

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        this.model.partProperties.setPropertyNamed(
            this.model,
            "readyState",
           "HAVE_NOTHING"
        );
        let audio = this._shadowRoot.querySelector("audio");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            audio.src = src;
        }
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", (value) => {
            let borderColor = "red";
            if(value == "HAVE_FUTURE_DATA" || value == "HAVE_ENOUGH_DATA"){
                borderColor = "green";
            };
            ["right", "left", "top", "bottom"].forEach((side) => {
                this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
            });
        });
        this.onPropChange("play", (value) => {
            if(value === true){
                this.play();
            } else if (value === false){
                this.pause();
            }
        });
        this.onPropChange("stop", (value) => {
            if(value === true){
                audio.currentTime = 0;
            }
        });
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <audio> element
                audio.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "audio",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    play(){
        // first make sure that the resource is ready
        let audio = this._shadowRoot.querySelector("audio");
        let readyState = this.model.partProperties.getPropertyNamed(this.model, "readyState");
        if(readyState == "HAVE_FUTURE_DATA" || readyState == "HAVE_ENOUGH_DATA"){
            audio.play();
        } else {
            alert(`audio is not ready; current state: ${readyState}`);
        }
    }

    pause(){
        this._shadowRoot.querySelector("audio").pause();
    }

    // re-loads the media, setting it back to the beggning
    stop(){
        this._shadowRoot.querySelector("audio").load();
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-audio-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for audio source');
        this.haloButton.addEventListener('click', this.updateAudioLink);
    }

    updateAudioLink(event){
        // Tells the model to update its
        // src link for the audio
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for audio:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadAudioFromSource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/BrowserView.js":
/*!*****************************************!*\
  !*** ./js/objects/views/BrowserView.js ***!
  \*****************************************/
/*! exports provided: BrowserView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserView", function() { return BrowserView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BrowserView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}
iframe {
    width: 100%;
    height: 100%;
}
</style>
<iframe frameborder="0" allowfullscreen></iframe>
`;

class BrowserView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateBrowserLink = this.updateBrowserLink.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let iframe = this._shadowRoot.querySelector("iframe");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            iframe.src = src;
        }
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <browser> element
                iframe.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "browser",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-browser-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for browser source');
        this.haloButton.addEventListener('click', this.updateBrowserLink);
    }

    updateBrowserLink(event){
        // Tells the model to update its
        // src link for the browser
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for browser:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'setURLTo',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/ButtonView.js":
/*!****************************************!*\
  !*** ./js/objects/views/ButtonView.js ***!
  \****************************************/
/*! exports provided: ButtonView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonView", function() { return ButtonView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ButtonView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * ButtonView
 * ---------------------------------------------------
 * I am a webcomponent representing a Button.
 */


const templateString = `
                <style>
                 .st-button-label {
                     user-select: none;
                     pointer-events: none;
                     text-overflow: ellipsis;
                     overflow: hidden;
                     max-width: 95%;
                     white-space: nowrap;
                 }
                </style>
                <span class="st-button-label">
                    <slot></slot><!-- Text of the Name -->
                </span>
`;

class ButtonView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bound methods
        this.setupPropHandlers = this.setupPropHandlers.bind(this);

        // Setup prop change handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('name', (value, partId) => {
            this.innerText = value;
        });
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let buttonName = this.model.partProperties.getPropertyNamed(this, "name");
        if(buttonName){
            this.innerText = buttonName;
        };
    }

    // override the base class implementation
    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }
};




/***/ }),

/***/ "./js/objects/views/CardView.js":
/*!**************************************!*\
  !*** ./js/objects/views/CardView.js ***!
  \**************************************/
/*! exports provided: CardView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardView", function() { return CardView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * CardView
 * --------------------------------------------------
 * I am a webcomponent representation of a Card.
 */



const templateString = `
                <style>
                </style>
                <slot></slot>
`;

class CardView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Bind component methods
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    // override the default class method
    onClick(event){
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            event.stopPropagation();
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        // Toolbox toggle hide/unhide
        let currentStack = window.System.getCurrentStackModel();
        let toolbox = currentStack.subparts.filter((part) => {
            let name = part.partProperties.getPropertyNamed(part, "name");
            return name == "Toolbox";
        })[0];
        // if there is no toolbox at all, that's weird but don't do anything
        if(toolbox){
            let hidden = toolbox.partProperties.getPropertyNamed(toolbox, "hide");
            if(hidden){
                contextMenu.addListItem(
                    "Unhide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", false);
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Hide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", true);
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/FieldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/FieldView.js ***!
  \***************************************/
/*! exports provided: FieldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldView", function() { return FieldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FieldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");
/* harmony import */ var _drawing_ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing/ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * FieldView
 * ---------------------------------
 * I am the view of an Field part.
 * I am an "interim" view intended to display
 * and edit plain text on a Card.
 * I should be replaced with a more comprehensive
 * implementation of Field/FieldView in the future.
 */






const haloEditButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tools" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M3 21h4l13 -13a1.5 1.5 0 0 0 -4 -4l-13 13v4" />
  <line x1="14.5" y1="5.5" x2="18.5" y2="9.5" />
  <polyline points="12 8 7 3 3 7 8 12" />
  <line x1="7" y1="8" x2="5.5" y2="9.5" />
  <polyline points="16 12 21 17 17 21 12 16" />
  <line x1="16" y1="17" x2="14.5" y2="18.5" />
</svg>
`;

const haloLockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-4a4 4 0 0 1 8 0v4"></path>
</svg>
`;

const haloUnlockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock-open" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-5a4 4 0 0 1 8 0"></path>
</svg>
`;

const fieldTemplateString = `
      <style>
        .field {
            display: flex;
            align-items: center;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: auto;
        }

        .field color-wheel {
            position: absolute;
        }

        .field-textarea {
            width: calc(100% - 5px);
            height: 100%;
            width: 100%;
            white-space: pre-wrap;
            overflow-wrap: anywhere;
        }

        /* Syntax Highlighting
 *---------------------------------------------------*/
span[data-st-rule="messageName"]{
    text-decoration: underline;
}

span[data-st-rule="keyword"]{
    font-weight: bold;
}

span[data-st-rule="ParameterList-item"]{
    font-style: italic;
    color: grey;
}


    </style>
    <div class="field">
        <div class="field-textarea" spellcheck="false"></div>
    </div>`;


function formatDoc(sCmd, sValue) {
  document.execCommand(sCmd, false, sValue); oDoc.focus();
}

class FieldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // this.editorCompleter = this.simpleTalkCompleter;
        this.textStyler = _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__["default"];  // we might want to consider a more programmatic way to set this
        this.editorCompleter = null;
        this.contextMenuOpen = false;
        this.haloLockUnlockButton = null;
        this.selectionRanges = {};
        this.wantsContextMenu = false;

        // Presets for syntax highlighting.
        // When highlighting is enabled, we will check
        // each line of the text for the following
        // grammatical rules:
        this._syntaxRules = [
            "MessageHandlerOpen",
            "MessageHandlerClose"
        ];

        this.template = document.createElement('template');
        this.template.innerHTML = fieldTemplateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onInput = this.onInput.bind(this);
        this.onBeforeInput = this.onBeforeInput.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onKeydown = this.onKeydown.bind(this);
        this.onMousedown = this.onMousedown.bind(this);
        this.openContextMenu = this.openContextMenu.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);
        this.doIt = this.doIt.bind(this);
        this.handleSelection = this.handleSelection.bind(this);
        this.openField = this.openField.bind(this);
        this.textToHtml = this.textToHtml.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.simpleTalkCompleter = this.simpleTalkCompleter.bind(this);
        this.initCustomHaloButtons = this.initCustomHaloButtons.bind(this);
        this.insertRange = this.insertRange.bind(this);
        this.setRangeInTarget = this.setRangeInTarget.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.highlightSyntax = this.highlightSyntax.bind(this);
        this.unhighlightSyntax = this.unhighlightSyntax.bind(this);

        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('editable', (value, id) => {
            this.textarea.setAttribute('contenteditable', value);
            if(value === true){
                this.haloLockUnlockButton = this.haloLockButton;
                this.classList.add("editable");
            } else if (value === false){
                this.haloLockUnlockButton = this.haloUnlockButton;
                this.classList.remove("editable");
            }
        });
        // 'text' is a DynamicProp whose setter will set the corresponding
        // value for `innerHTML`. This way we can have programmatic content
        // setting and still allow to not loose markup.
        // 'innerHTML' is a BasicProp. See how these are set, without
        // notification in this.onInput()
        this.onPropChange('innerHTML', (value, id) => {
            this.textarea.innerHTML = value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "text",
                this.textarea.innerText,
                false // do not notify, to avoid an infinite loop
            );
        });
    }

    afterConnected(){
        // The events here are added via the .addEventListener() API which is
        // distinct from the this.eventRespond() which uses the DOM element
        // element.onEvent API. This allows us to distnguish between "core"
        // system-web events that we don't want meddled with at the moment, like
        // entering text in a field, and ones exposed in the environemnt for scripting
        this.textarea = this._shadowRoot.querySelector('.field-textarea');

        this.textarea.addEventListener('input', this.onInput);
        //this.textarea.addEventListener('beforeinput', this.onBeforeInput);
        this.textarea.addEventListener('keydown', this.onKeydown);
        this.textarea.addEventListener('mousedown', this.onMousedown);
        // No need to add a click listener as the base PartView class does that

        // in order to deal with range insertions (for styling text fragments within
        // the textarea), we need to have the default paragraph tag = </br>. Otherwise
        // the insert new line is of the form <div></br><div> which causes the appearance
        // of newlines when nodes are inserted into a range
        //document.execCommand("defaultParagraphSeparator", false, "st-line");
    }

    afterDisconnected(){
        this.textarea.removeEventListener('input', this.onInput);
        //this.textarea.removeEventListener('beforeinput', this.onBeforeInput);
        this.textarea.removeEventListener('keydown', this.onKeydown);
        this.textarea.removeEventListener('mousedown', this.onMousedown);
    }

    afterModelSet(){
        this.textarea = this._shadowRoot.querySelector('.field-textarea');
        // If we have a model, set the value of the textarea
        // to the current html of the field model
        let innerHTML = this.model.partProperties.getPropertyNamed(
            this.model,
            'innerHTML'
        );
        this.textarea.innerHTML = innerHTML;

        let isEditable = this.model.partProperties.getPropertyNamed(this.model, "editable");
        this.textarea.setAttribute('contenteditable', isEditable);

        // setup the lock/unlock halo button
        this.initCustomHaloButtons();
        let editable = this.model.partProperties.getPropertyNamed(
            this.model,
            'editable'
        );
        if(editable === true){
            this.haloLockUnlockButton = this.haloLockButton;
            this.classList.add("editable");
        } else if (editable === false){
            this.haloLockUnlockButton = this.haloUnlockButton;
            this.classList.remove("editable");
        }
    }

    simpleTalkCompleter(element){
        let textContent = this.htmlToText(element);
        let startOfHandlerRegex = /^on\s(\w+)(\s|\n)+$/;
        let match = textContent.match(startOfHandlerRegex);
        if(match){
            let messageName = match[1];
            // if input break is a new line then an extra
            // <div></br></div> has beed added into the elemen already
            let tabLine = "\t\n";
            if(match[2] === "\n"){
                tabLine= "";
            }
            textContent = `${tabLine}end ${messageName}`;
            let innerHTML = this.textToHtml(textContent);
            element.insertAdjacentHTML("beforeend", innerHTML);
        }
        return element.innerHTML;
    }

    /*
     * I override my base-class's implementation to handle target related functionality
     */
    styleTextCSS(){
        let textarea = this._shadowRoot.querySelector('.field-textarea');
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            textarea.style[key] = value;
        });
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, this.textarea.innerHTML, cssStyle);
        }
    }

    /*
     * set a text-* property on selection to style the selected text
     * Note: this is done for every current selection, i.e. everthing
     * in this.selectionRanges
     */
    setSelection(propName, value){
        Object.values(this.selectionRanges).forEach((range) => {
            let currentStyle = {};
            // // if the document fragment has one child node and it's a span
            // // we should style that directly. This avoids unncessary DOM elements
            // // being created to wrap the contents, such as when styling is continually
            // // applied ot the same selection
            // let span;
            // if(docFragment.childNodes.length == 1 && docFragment.childNodes[0].nodeName == "SPAN"){
            //     span = docFragment.childNodes[0];
            //     // Note the use of Obejct.values here for the DOM style attribute object
            //     // that's weird
            //     Object.values(span.style).forEach((key) => {
            //         currentStyle[key] = span.style[key];
            //     });
            // } else {
            //     // we need to create a span element to wrap the contents in style
            //     span = document.createElement('span');
            //     // While tempting to use range.surroundContents() avoid this
            //     // since it will fail with a non-informative error if the range
            //     // includes partial nodes (ex text across various nodes)
            //     while (docFragment.childNodes.length){
            //         span.appendChild(docFragment.childNodes[0]);
            //     }
            // }
            let span = document.createElement('span');
            let cssObject = this.textStyler(currentStyle, propName, value);
            Object.keys(cssObject).forEach((key) => {
                span.style[key] = cssObject[key];
            });

            span.append(range.extractContents());
            range.insertNode(span);
            
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
            // if there is a target and range set then send the target an update message
            let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
            if(target){
                this.setRangeInTarget(target, this.textarea.innerHTML);
            }
        });
    }

    onBeforeInput(event){
        let selection = document.getSelection();
        let selectedRange = selection.getRangeAt(0);
        let range = selectedRange.cloneRange();

        let innerHTML = event.target.innerHTML;
        if(!innerHTML.endsWith("<div><br></div>")){
            innerHTML += "<div><br></div>";
            event.target.innerHTML = innerHTML;
        }
        
        if(event.inputType == "insertParagraph"){
            //event.stopPropagation();
            event.preventDefault();

            let br = document.createElement('br');
            let br2 = document.createElement('br');
            range.insertNode(br);
            range.collapse(false);
            range.insertNode(br2);
            range.setStartAfter(br2);
            range.setEndAfter(br2);
        }
    }

    onInput(event){
        let innerHTML = event.target.innerHTML;
        /*
        if(!innerHTML.endsWith("<br>")){
            innerHTML += "<br>";
            event.target.innerHTML = innerHTML;
        }
        */

        if(this.editorCompleter){
            // TODO sort out how this would work
            let innerHTML = event.target.innerHTML;
            innerHTML = this.editorCompleter(event.target);
        }

        this.model.partProperties.setPropertyNamed(
            this.model,
            'text',
            event.target.innerText,
            false // do not notify, to preserve contenteditable context
        );
        this.model.partProperties.setPropertyNamed(
            this.model,
            'innerHTML',
            event.target.innerHTML,
            false // do not notify
        );
        // Since we update the 'text' property without notification, the part/model
        // is not sent the "propertyChanged" message so we do so manually
        this.model.propertyChanged("text", event.target.innerText);
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, event.target.innerHTML);
        }
    }

    onKeydown(event){
        // prevent the default tab key to leave focus on the field
        if(event.key==="Tab"){
            event.preventDefault();
            //document.execCommand('insertHTML', false, '&#x9');
            let sel = document.getSelection();
            let range = sel.getRangeAt(0);

            let tabNodeValue = '\t';
            let tabNode = document.createTextNode(tabNodeValue);

            range.insertNode(tabNode);

            range.setStartAfter(tabNode);
            range.setEndAfter(tabNode);
        };
    }

    onMousedown(event){
        // clear all selections
        this.selectionRanges = {};
    }
    onClick(event){
        event.preventDefault();
        event.stopPropagation();
        if(event.button == 0){
            // if the shift key is pressed we toggle the halo
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else{
                let text = window.getSelection().toString();
                // if no text is selected we do nothing
                if(text){
                    // if the altKey is pressed we open the context ("do it") menu
                    if(event.altKey){
                        if(!this.contextMenuOpen){
                            this.openContextMenu();
                        }
                    } else {
                        this.handleSelection(event.metaKey);
                    }
                } else {
                    // make sure no context menu is open
                    if(this.contextMenuOpen){
                        this.closeContextMenu();
                    }
                    // clear all the selections
                    this.selectionRanges = {};
                }
            }
        }
    }

    /* I handle selected text, creating a new field model/view
     * for every range in the selection, keeping track of every range
     * in this.selection Object/dict so that modification can be inserted
     * back into the corresponding ranges.
     */
    handleSelection(openNewField){
        let selection = window.getSelection();
        for(let i=0; i < selection.rangeCount; i++){
            // make sure this is not a continuing selection
            // and that the range is not already registered
            let range = selection.getRangeAt(i);
            let currentRanges = Object.values(this.selectionRanges);
            if(currentRanges.indexOf(range) >= 0){
                continue;
            }
            // we generate our own range ids, since we want this to correspond to
            // selection order which is not respected by the browser selection object
            // to ensure we don't hit on other views' ranges by accident we need unique id's
            let rangeId = Date.now(); //TODO we need a better random id
            this.selectionRanges[rangeId] = range;
            if(openNewField){
                // open a field for each new selection and populate it with the range html
                this.openField(range, rangeId);
            }
        }
    }

    openField(range, rangeId){
        // create an HTML document fragment from the range to avoid dealing wiht start/end
        // and offset calculations
        // fragments don't have the full html DOM element API so we need to create one
        let span = document.createElement('span');
        span.appendChild(range.cloneContents());

        // TODO these should all be messages and correspnding command handler definitions
        // should be part of the field's own script
        let fieldModel = window.System.newModel("field", this.model._owner.id, `selection ${rangeId}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "innerHTML", span.innerHTML);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "target", `field id ${this.model.id}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "targetRangeId", rangeId);
    }

    /**
      * Given a tagrget specifier and html
      * I first look up to make sure that the target has the corresponding
      * range (coming from the targetRangeId property), and then set it with my
      * innerHTML. Note, since the target property value is an object specifier I
      * create a semantics objects and interpret the value resulting in a valid
      * part id.
      */
    setRangeInTarget(targetSpecifier, html, css){
        let targetRangeId = this.model.partProperties.getPropertyNamed(this.model, 'targetRangeId');
        let match = window.System.grammar.match(targetSpecifier, "ObjectSpecifier");
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation('interpret', Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this.model, window.System));
        let targetId = semantics(match).interpret();

        this.model.sendMessage({
            type: "command",
            commandName: "insertRange",
            args: [targetRangeId, html, css]
        }, window.System.partsById[targetId]);
    }

    /*
     * I insert the html (string) into the specified range (by id)
     */
    insertRange(rangeId, html, cssObj){
        let range = this.selectionRanges[rangeId];
        if(range){
            let span = document.createElement('span');
            span.innerHTML = html;
            if(cssObj){
                Object.keys(cssObj).forEach((key) => {
                    let value = cssObj[key];
                    span.style[key] = value;
                });
            }
            range.deleteContents();
            range.insertNode(span);
            // update the text and innerHTML properties without notification
            // to prevent unnecessary setting of the text/html
            this.model.partProperties.setPropertyNamed(
                this.model,
                'text',
                this.textarea.innerText,
                false // do not notify, to preserve contenteditable context
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
        }
    }

    openContextMenu(){
        let text = document.getSelection().toString();
        let focusNode = document.getSelection().focusNode;
        let button = document.createElement("button");
        button.id = "doIt";
        button.style.marginLeft = "10px";
        button.style.backgroundColor = "var(--palette-green)";
        button.textContent = "Do it!";
        button.addEventListener("click", this.doIt);
        focusNode.after(button);
        this.contextMenuOpen = true;
    };

    closeContextMenu(){
        let button = this._shadowRoot.querySelector('#doIt');
        if(button){
            button.remove();
        }
        // clear the selection and set the context menu to closed
        document.getSelection().removeAllRanges();
        this.contextMenuOpen = false;
    }

    doIt(event){
        event.stopPropagation();
        let text = document.getSelection().toString();
        // clean up the text to make sure no newlines or spaces made it in
        text = text.replace(/^[\t\n ]+/, "");
        text = text.replace(/[\t\n ]+$/, "");
        this.closeContextMenu();
        // send message to compile the prepped script
        let script = `on doIt\n   ${text}\nend doIt`;
        // send these messages from the model (not the view)
        // since if there is an error the original sender will
        // have an id
        this.model.sendMessage(
            {
                type: "compile",
                codeString: script,
                targetId: this.model.id
            },
            this.model
        );
        this.model.sendMessage(
            {
                type: "command",
                commandName: "doIt",
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            },
            this.model
        );
    }

    initCustomHaloButtons(){
        this.haloLockButton = document.createElement('div');
        this.haloLockButton.id = "halo-field-lock-editor";
        this.haloLockButton.classList.add('halo-button');
        this.haloLockButton.innerHTML = haloLockButtonSVG;
        this.haloLockButton.style.marginRight = "6px";
        this.haloLockButton.setAttribute('slot', 'bottom-row');
        this.haloLockButton.setAttribute('title', 'Lock Editing');
        this.haloLockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", false],
            }, this.model);
            this.closeHalo();
            this.openHalo();
            // close/open the halo to update the editing state toggle button
        });
        this.haloUnlockButton = document.createElement('div');
        this.haloUnlockButton.id = "halo-field-unlock-editor";
        this.haloUnlockButton.classList.add('halo-button');
        this.haloUnlockButton.innerHTML = haloUnlockButtonSVG;
        this.haloUnlockButton.style.marginRight = "6px";
        this.haloUnlockButton.setAttribute('slot', 'bottom-row');
        this.haloUnlockButton.setAttribute('title', 'Unlock Editing');
        this.haloUnlockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", true],
            }, this.model);
            // close/open the halo to update the editing state toogle button
            this.closeHalo();
            this.openHalo();
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloLockUnlockButton);
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }


    /*
     * I convert raw text to html respecting the Firefox
     * contenteditable attribute guidelnes.
     * This means that single lins of text are left as is;
     * multiline text, i.e. text which includes "\n", is
     * wrapped in <div></div> for every line; and the last
     * line gets a <br> tag inserted before the </div> to reflect
     * the "on-enter-key" behavior.
     */
    textToHtml(text){
        if(text){
            let textLines = text.split("\n");
            if(textLines.length > 1){
                let html = "";
                textLines.forEach((line) => {
                    if(line){
                        html += `<div>${line}</div>`;
                    } else {
                        html += "<div><br></div>";
                    }
                });
                return  `<div>${html}<br></div>`;
            } else {
                return text;
            }
        } else {
            return "";
        }
    }

    htmlToText(element){
        // TODO this is very naive and ignores most possible structure
        if(element.innerHTML){
            // first replace all the "</div><div>" with line breaks
            let cleanHTML =  element.innerHTML.replace(/<\/div><div>/g, "\n");
            // then remove all html
            let tempElement = document.createElement("div");
            tempElement.innerHTML = cleanHTML;
            let cleanText = tempElement.textContent;
            tempElement.remove();
            return cleanText;
        } else {
            return "";
        }
    }

    highlightSyntax(){
        let current = this.getAttribute("syntax");
        if(current && current !== "false"){
            this.unhighlightSyntax();
        }
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation(
            "highlightSyntax",
            Object(_utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
        );
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let newHTML = text.split("\n").map(line => {
            // Loop through each rule and try to match
            for(let i = 0; i < this._syntaxRules.length; i++){
                let rule = this._syntaxRules[i];
                let match = window.System.grammar.match(line, rule);
                if(match.succeeded()){
                    return semantics(match).highlightSyntax().outerHTML;
                }
            }
            return line;
        }).join("\n");

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", true);
    }

    unhighlightSyntax(){
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let plainElements = text.split("\n").map(line => {
            let div = document.createElement("div");
            div.innerText = line;
            return div;
        });
        let finalLine = document.createElement("div");
        finalLine.append(document.createElement("br"));
        plainElements.push(finalLine);

        let newHTML = "";
        plainElements.forEach(element => {
            newHTML += element.outerHTML;
        });

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", false);
    }
};




/***/ }),

/***/ "./js/objects/views/Halo.js":
/*!**********************************!*\
  !*** ./js/objects/views/Halo.js ***!
  \**********************************/
/*! exports provided: Halo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Halo", function() { return Halo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Halo; });
/**
 * New Halo
 */

/** Note: Icons are from 
*** https://tablericons.com/
**/
const deleteIcon =`
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-trash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="4" y1="7" x2="20" y2="7" />
  <line x1="10" y1="11" x2="10" y2="17" />
  <line x1="14" y1="11" x2="14" y2="17" />
  <path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" />
  <path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" />
</svg>
`;
const editIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-edit" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 7h-3a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-3" />
  <path d="M9 15h3l8.5 -8.5a1.5 1.5 0 0 0 -3 -3l-8.5 8.5v3" />
  <line x1="16" y1="5" x2="19" y2="8" />
</svg>
`;
const growIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrows-diagonal-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="16 20 20 20 20 16" />
  <line x1="14" y1="14" x2="20" y2="20" />
  <polyline points="8 4 4 4 4 8" />
  <line x1="4" y1="4" x2="10" y2="10" />
</svg>
`;

const copyIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="8" y="8" width="12" height="12" rx="2"></rect>
   <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path>
</svg>
`;

const pasteIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2"></path>
   <rect x="9" y="3" width="6" height="4" rx="2"></rect>
   <path d="M9 14l2 2l4 -4"></path>
</svg>
`;

const targetIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-focus" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <circle cx="12" cy="12" r=".5" fill="currentColor"></circle>
   <circle cx="12" cy="12" r="9"></circle>
</svg>
`;

const settingsIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-settings" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z" />
  <circle cx="12" cy="12" r="3" />
</svg>
`;

const rotateIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rotate-clockwise" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M4.05 11a8 8 0 1 1 .5 4m-.5 5v-5h5"></path>
</svg>
`;

const templateString = `
<style>
 :host {
     --halo-button-height: 25px;
     --halo-button-width: 25px;
     --halo-rim-margin: 10px;
     --halo-button-width-padded: calc(var(--halo-button-width) + var(--halo-rim-margin));
     --halo-button-height-padded: calc(var(--halo-button-height) + var(--halo-rim-margin));
     position: absolute;
     box-sizing: border-box;
     top: calc(-1 * var(--halo-button-height-padded));
     left: calc(-1 * var(--halo-button-width-padded));
     width: calc(100% + (2 * var(--halo-button-width-padded)));
     height: calc(100% + (2 * var(--halo-button-height-padded)));
     color: initial;
     z-index: 10;
 }


 .halo-row,
 .halo-column {
     display: flex;
     position: absolute;
 }

 .halo-column {
     flex-direction: column;
 }

 #halo-top-row,
 #halo-bottom-row {
     width: calc(100% - var(--halo-button-width-padded));
     height: var(--halo-button-height-padded);
 }

 #halo-top-row {
     left: 0;
     top: 0;
 }

 #halo-bottom-row {
     right: 0;
     bottom: 0;
     flex-direction: row-reverse;
     align-items: flex-end;
 }

 #halo-right-column,
 #halo-left-column {
     height: calc(100% - var(--halo-button-height-padded));
     width: var(--halo-button-width-padded);
 }

 #halo-right-column {
     right: 0;
     top: 0;
     align-items: flex-end;
 }

 #halo-left-column {
     left: 0;
     top: var(--halo-button-height-padded);
 }

 .halo-button,
 ::slotted(*) {
     display: block;
     border: 1px solid rgba(100, 100, 100, 0.8);
     width: var(--halo-button-width);
     height: var(--halo-button-height);
     background-color: rgb(220, 220, 220);
 }

 .halo-button:hover
 ::slotted(*).halo-button:hover {
     cursor: pointer;
 }

 .halo-button:active
 ::slotted(*).halo-button:active {
     border: 1px solid black;
 }

 .halo-button.hidden
 ::slotted(*).halo-button.hidden {
     display: none;
 }

</style>

<div id="halo-top-row" class="halo-row">
    <div id="halo-delete" class="halo-button" title="Delete this part">
        ${deleteIcon}
    </div>
    <slot name="top-row"></slot>
</div>

<div id="halo-bottom-row" class="halo-row">
    <div id="halo-resize" class="halo-button" title="Resize this part">
        ${growIcon}
    </div>
    <div id="halo-script-edit" class="halo-button" title="Edit this part's script">
        ${editIcon}
    </div>
    <div id="halo-edit" class="halo-button" title="Edit this part">
        ${settingsIcon}
    </div>
    <slot name="bottom-row"></slot>
</div>

<div id="halo-left-column" class="halo-column">
    <div id="halo-copy" class="halo-button" title="Copy this Part">
        ${copyIcon}
    </div>
    <div id="halo-paste" class="halo-button" title="Paste the contents of clipboard into this Part">
        ${pasteIcon}
    </div>
    <div id="halo-target" class="halo-button" title="Select this Part's target">
        ${targetIcon}
    </div>
    <slot name="left-column"></slot>
</div>

<div id="halo-right-column" class="halo-column">
    <div id="halo-rotate" class="halo-button" title="Rotate this part">
        ${rotateIcon}
    </div>
    <slot name="right-column"></slot>
</div>

`;

class Halo extends HTMLElement {
    constructor(){
        super();

        // Configure the Shadow DOM and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind component methods


        // Bind event listeners
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onResizeMouseDown = this.onResizeMouseDown.bind(this);
        this.onResizeMouseUp = this.onResizeMouseUp.bind(this);
        this.onResizeMouseMove = this.onResizeMouseMove.bind(this);
        this.onRotateMouseDown = this.onRotateMouseDown.bind(this);
        this.onRotateMouseUp = this.onRotateMouseUp.bind(this);
        this.onRotateMouseMove = this.onRotateMouseMove.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.targetElement = this.getRootNode().host;
            this.targetElement.classList.add('editing');
            this.targetElement.hasOpenHalo = true;

            // Add event listeners
            this.addEventListener('mousedown', this.onMouseDown);

            // Resize button
            this.resizer = this.shadowRoot.getElementById('halo-resize');
            this.resizer.addEventListener('mousedown', this.onResizeMouseDown);
            if(!this.targetElement.wantsHaloResize){
                this.resizer.style.visibility = 'hidden';
            }

            // Rotate button
            this.rotater = this.shadowRoot.getElementById('halo-rotate');
            this.rotater.addEventListener('mousedown', this.onRotateMouseDown);
            if(!this.targetElement.wantsHaloRotate){
                this.rotater.style.visibility = 'hidden';
            }
            // Delete button
            this.deleter = this.shadowRoot.getElementById('halo-delete');
            this.deleter.addEventListener('click', this.targetElement.onHaloDelete);
            if(!this.targetElement.wantsHaloDelete){
                this.deleter.style.visibility = 'hidden';
            }

            // Edit button
            this.scriptEditor = this.shadowRoot.getElementById('halo-script-edit');
            this.scriptEditor.addEventListener('click', this.targetElement.onHaloOpenScriptEditor);
            if(!this.targetElement.wantsHaloScriptEdit){
                this.scriptEditor.style.visibility = 'hidden';
            }

            // Comprehensive editor button
            this.editor = this.shadowRoot.getElementById('halo-edit');
            this.editor.addEventListener('click', this.targetElement.onHaloOpenEditor);
            if(!this.targetElement.wantsHaloEdit){
                this.editor.style.visibility = 'hidden';
            }

            // Copy button
            this.copier = this.shadowRoot.getElementById('halo-copy');
            this.copier.addEventListener('click', this.targetElement.onHaloCopy);


            // Paste button
            this.paster = this.shadowRoot.getElementById('halo-paste');
            this.paster.addEventListener('click', this.targetElement.onHaloPaste);

            // Target button
            this.targeter = this.shadowRoot.getElementById('halo-target');
            this.targeter.addEventListener('click', this.targetElement.onHaloTarget);
            this.targeter.addEventListener('mouseenter', this.targetElement.onHaloTargetButtonMouseEnter);
            this.targeter.addEventListener('mouseleave', this.targetElement.onHaloTargetButtonMouseLeave);
        }
    }

    disconnectedCallback(){
        this.targetElement.classList.remove('editing');
        this.targetElement.hasOpenHalo = false;

        // Remove event listeners
        this.removeEventListener('mousedown', this.onMouseDown);
        this.resizer.removeEventListener('mousedown', this.onResizeMouseDown);
    }


    /* Event Handling */
    onMouseDown(event){
        if(event.button == 0 && this.targetElement.wantsHaloMove){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        let currentTop = parseInt(this.targetElement.style.top);
        let currentLeft = parseInt(this.targetElement.style.left);
        let newTop = event.movementY + currentTop;
        let newLeft = event.movementX + currentLeft;

        let model = this.targetElement.model;
        model.partProperties.setPropertyNamed(model, "top", newTop);
        model.partProperties.setPropertyNamed(model, "left", newLeft);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    onResizeMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onResizeMouseMove);
        document.addEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseUp(event){
        document.removeEventListener('mousemove', this.onResizeMouseMove);
        document.removeEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseMove(event){
        this.targetElement.onHaloResize(
            event.movementX,
            event.movementY
        );
    }

    onRotateMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onRotateMouseMove);
        document.addEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseUp(event){
        document.removeEventListener('mousemove', this.onRotateMouseMove);
        document.removeEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseMove(event){
        this.targetElement.onHaloRotate(
            event.movementX,
            event.movementY
        );
    }
};




/***/ }),

/***/ "./js/objects/views/ImageView.js":
/*!***************************************!*\
  !*** ./js/objects/views/ImageView.js ***!
  \***************************************/
/*! exports provided: ImageView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageView", function() { return ImageView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const pictureIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <line x1="15" y1="8" x2="15.01" y2="8"></line>
   <rect x="4" y="4" width="16" height="16" rx="3"></rect>
   <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5"></path>
   <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2"></path>
</svg>
`;

const templateString = `
<img id="wrapped-image" class="hidden" />
<svg class="hidden" id="wrapped-svg" xmlns="http://www.w3.org/2000/svg">
</svg>
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    user-select: none;
}

.hidden {
    display: none;
}
img {
    width: 100%;
    height: auto;
    display: block;
}

.currently-wrapped {
    width: 100%;
    height: 100%;
}
</style>
`;

class ImageView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.updateImageData = this.updateImageData.bind(this);
        this.updateSvgImage = this.updateSvgImage.bind(this);
        this.updateBinaryImage = this.updateBinaryImage.bind(this);
        this.setDefaultImage = this.setDefaultImage.bind(this);
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateImageLink = this.updateImageLink.bind(this);
        this.updateSizingForViewport = this.updateSizingForViewport.bind(this);
    }

    afterModelSet(){
        // prop changes
        this.onPropChange("imageData", (imageData) => {
            if(!imageData){
                this.setDefaultImage();
            }
            this.updateImageData(imageData);
        });

        // Make sure we have imageData. If not, try
        // to load from a src.
        let currentImageData = this.model.partProperties.getPropertyNamed(
            this.model,
            "imageData"
        );
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            "src"
        );
        if(!currentImageData){
            if(currentSrc){
                let msg = {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ currentSrc ]
                };
                this.model.sendMessage(msg, this.model);
            } else {
                this.setDefaultImage();
            }
        } else {
            this.updateImageData(currentImageData);
        }
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    setDefaultImage(){
        this.model.partProperties.setPropertyNamed(this.model, "imageData", pictureIcon);
        this.model.partProperties.setPropertyNamed(this.model, "mimeType", "image/svg");
        this.model.partProperties.setPropertyNamed(this.model, "src", "");
        this.updateImageData(pictureIcon);
    }

    updateImageData(imageData){
        if(this.model.isSvg){
            this.updateSvgImage(imageData);
        } else {
            this.updateBinaryImage(imageData);
        }
    }

    updateBinaryImage(imageData){
        // In this case, the imageData is
        // a base64 encoded data url describing
        // the bits of the image.
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let svgEl = this._shadowRoot.getElementById('wrapped-svg');
        svgEl.classList.add('hidden');
        svgEl.classList.remove('currently-wrapped');
        imgEl.classList.add('currently-wrapped');
        imgEl.src = imageData;
        imgEl.onload = () => {
            //this.updateSizingForViewport();
        };
        this.preserveAspectOnResize = true;
        imgEl.classList.remove('hidden');
    }

    updateSvgImage(imageData){
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let currentSvgEl = this._shadowRoot.getElementById('wrapped-svg');
        let parser = new DOMParser();
        let xmlDocument = parser.parseFromString(imageData, 'application/xml');
        let newSvgEl = xmlDocument.documentElement;

        // Ensure that the SVG has some width and height attributes
        // set so we have initial dimensions to display. If not present,
        // pull from viewbox.
        if(!newSvgEl.hasAttribute('width') || !newSvgEl.hasAttribute('height')){
            let viewBox = newSvgEl.getAttribute('viewBox');
            if(viewBox){
                viewBox = viewBox.split(" ");
                let viewBoxWidth = parseInt(viewBox[2]);
                let viewBoxHeight = parseInt(viewBox[3]);
                newSvgEl.setAttribute('height', viewBoxHeight);
                newSvgEl.setAttribute('width', viewBoxWidth);
            }
        } 
        newSvgEl.id = 'wrapped-svg';
        newSvgEl.classList.add('currently-wrapped');
        imgEl.classList.add('hidden');
        imgEl.classList.remove('currently-wrapped');
        currentSvgEl.remove();
        this._shadowRoot.appendChild(newSvgEl);
        this.updateSizingForViewport();
        this.preserveAspectOnResize = false;
    }

    updateImageLink(event){
        // Tells the model to update its
        // src link for the image
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for image:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ result ]
                },
                this.model
            );
        }
    }

    updateSizingForViewport(){
        // Ensure that this component does not display larger
        // than the current remaining subrectangle of its origin
        // and the corner of the viewport
        let padding = 40;
        // First, we need to find the absolute top corner
        // locations for the element
        let el = this._shadowRoot.querySelector('.currently-wrapped');
        let top = 0;
        let left = 0;
        while(el){
            top += el.offsetTop;
            left += el.offsetLeft;
            el = el.offsetParent;
        }

        let rect = this.getBoundingClientRect();
        let heightLimit = document.documentElement.clientHeight - padding;
        if((rect.height + top) > heightLimit){
            let ratio = (heightLimit - top) / rect.height;
            // this.style.height = `${rect.height * ratio}px`;
            // this.style.width = `${rect.width * ratio}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                (rect.width * ratio)
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                (rect.height * ratio)
            );
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    onHaloResize(movementX, movementY){
        // Override default behavior.
        // We resize the wrapped svg or img instead
        // and have the outer component simply react to
        // the change.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let wrappedImage = this._shadowRoot.querySelector('.currently-wrapped');
        let rect = wrappedImage.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let maxWidth = rect.width + movementX;
            let maxHeight = rect.height + movementY;
            let ratio = Math.min(maxWidth / rect.width, maxHeight / rect.height);
            newHeight = rect.height * ratio;
            newWidth = rect.width * ratio;
        } else {
            newWidth = rect.width + movementX;
            newHeight = rect.height + movementY;
        }

        if(newWidth && newHeight){
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight
            );
        }
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-image-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for image file');
        this.haloButton.addEventListener('click', this.updateImageLink);
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        contextMenu.addListItem(
            'Edit Image URL',
            this.updateImageLink
        );
    }
};




/***/ }),

/***/ "./js/objects/views/PartView.js":
/*!**************************************!*\
  !*** ./js/objects/views/PartView.js ***!
  \**************************************/
/*! exports provided: PartView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartView", function() { return PartView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartView; });
/* harmony import */ var _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contextmenu/ContextMenu.js */ "./js/objects/views/contextmenu/ContextMenu.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/**
 * PartView
 * ----------------------------------------
 * I am an *abstract* webcompoent CustomElement
 * that serves as the generic view for any Part
 * models.
 * I should not be instantiated directly, nor should
 * I be added to any web page's registry of CustomElements.
 * I am indended to be extended (subclassed) by the actual
 * views for each Part kind, and therefore I contain all
 * of the common behavior, including lifecycle methods,
 * for these.
 */



window.customElements.define('st-context-menu', _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

class PartView extends HTMLElement {
    constructor(){
        super();
        this.model = null;
        this.isPartView = true;
        this.isLensed = false;
        this.name = this.constructor.name;
        this.propChangeHandlers = {};
        this.setupBasePropHandlers();
        this.viewChangeHandlers = {};
        this.setupBaseViewChangeHandlers();

        // Halo settings. All are on by default
        this.wantsHaloResize = true;
        this.wantsHaloRotate = true;
        this.wantsHaloScriptEdit = true;
        this.wantsHaloEdit = true;
        this.wantsHaloDelete = true;
        this.wantsHalo = true;
        // Note: see getter for wantsHaloMove

        // Context menu settings
        this.wantsContextMenu = true;

        // Bind component methods
        this.setModel = this.setModel.bind(this);
        this.unsetModel = this.unsetModel.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.setupBasePropHandlers = this.setupBasePropHandlers.bind(this);
        this.setupBaseViewChangeHandlers = this.setupBaseViewChangeHandlers.bind(this);
        this.initLayout = this.initLayout.bind(this);

        // Bind initial property method
        this.styleCSS = this.styleCSS.bind(this);
        this.styleTextCSS = this.styleTextCSS.bind(this);

        // Bind property change reaction methods
        this.primHandlePropChange = this.primHandlePropChange.bind(this);
        this.onPropChange = this.onPropChange.bind(this);
        this.primHandleViewChange = this.primHandleViewChange.bind(this);
        this.onViewChange = this.onViewChange.bind(this);
        this.scriptChanged = this.scriptChanged.bind(this);
        this.layoutChanged = this.layoutChanged.bind(this);
        this.listDirectionChanged = this.listDirectionChanged.bind(this);
        this.listWrappingChanged = this.listWrappingChanged.bind(this);
        this.vResizingChanged = this.vResizingChanged.bind(this);
        this.hResizingChanged = this.hResizingChanged.bind(this);
        this.pinningLeftChanged = this.pinningLeftChanged.bind(this);
        this.pinningTopChanged = this.pinningTopChanged.bind(this);
        this.pinningBottomChanged = this.pinningBottomChanged.bind(this);
        this.pinningRightChanged = this.pinningRightChanged.bind(this);
        this.listAlignmentChanged = this.listAlignmentChanged.bind(this);
        this.listDistributionChanged = this.listDistributionChanged.bind(this);

        // Bind view change reaction methods
        this.subpartOrderChanged = this.subpartOrderChanged.bind(this);
        this.newSubpartView = this.newSubpartView.bind(this);

        // Bind Halo related methods
        this.openHalo = this.openHalo.bind(this);
        this.closeHalo = this.closeHalo.bind(this);
        this.onHaloDelete = this.onHaloDelete.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onHaloOpenScriptEditor = this.onHaloOpenScriptEditor.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.onHaloRotate = this.onHaloRotate.bind(this);
        this.onHaloPaste = this.onHaloPaste.bind(this);
        this.onHaloCopy = this.onHaloCopy.bind(this);
        this.onHaloTarget = this.onHaloTarget.bind(this);
        this.endHaloTarget = this.endHaloTarget.bind(this);
        this.onHaloTargetButtonMouseEnter = this.onHaloTargetButtonMouseEnter.bind(this);
        this.onHaloTargetButtonMouseLeave = this.onHaloTargetButtonMouseLeave.bind(this);
        this.onHaloActivationClick = this.onHaloActivationClick.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onAuxClick = this.onAuxClick.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onContextMenuClick = this.onContextMenuClick.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.handleTargetKey = this.handleTargetKey.bind(this);
        this.handleTargetMouseClick = this.handleTargetMouseClick.bind(this);
        this.handleTargetMouseOver = this.handleTargetMouseOver.bind(this);
        this.handleTargetMouseOut = this.handleTargetMouseLeave.bind(this);
        this.addContextMenuItems = this.addContextMenuItems.bind(this);
        this.getCurrentTargetViews = this.getCurrentTargetViews.bind(this);

        // Bind editor related methods
        this.openEditor = this.openEditor.bind(this);
        this.closeEditor = this.closeEditor.bind(this);

        // Context menu
        this.openContextMenuAt = this.openContextMenuAt.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);

        // misc
        this.highlight = this.highlight.bind(this);
        this.unhighlight = this.unhighlight.bind(this);

        // Bind lifecycle methods
        this.afterModelSet = this.afterModelSet.bind(this);
        this.afterModelUnset = this.afterModelUnset.bind(this);
        this.afterConnected = this.afterConnected.bind(this);
        this.afterDisconnected = this.afterDisconnected.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Do some universal PartView configuration
            // when attached to a parent element, like
            // registering event listeners etc

            // Register middle mouse button click
            // to toggle the halo
            this.addEventListener('auxclick', this.onAuxClick);

            // Register default event handlers manually]
            this.addEventListener('click', this.onClick);
            this.addEventListener('contextmenu', this.onContextMenuClick);

            // Call the lifecycle method when done
            // with the above
            this.afterConnected();
        }
    }

    disconnectedCallback(){
        this.removeEventListener('auxclick', this.onAuxClick);
        this.removeEventListener('click', this.onClick);
        this.removeEventListener('contextmenu', this.onContextMenuClick);
        this.afterDisconnected();
    }

    setModel(aModel){
        this.unsetModel();
        this.model = aModel;
        aModel.addPropertySubscriber(this);
        aModel.addViewSubscriber(this);
        if(this.isLensed){
            this.removeAttribute('part-id');
            this.setAttribute('lens-part-id', aModel.id);
        } else {
            this.removeAttribute('lens-part-id');
            this.setAttribute('part-id', aModel.id);
        }
        // deal with 'special' props
        let wantsMove = this.model.partProperties.getPropertyNamed(
            this.model,
            "wants-move"
        );
        if(wantsMove){
            this.addEventListener('mousedown', this.onMouseDown);
        }

        // load all the initial styling
        this.styleCSS();
        this.styleTextCSS();
        this.initLayout();
        this.afterModelSet();
    }

    unsetModel(){
        if(this.model){
            let removedModel = this.model;
            this.model.removePropertySubscriber(this);
            this.model = null;
            this.setAttribute('part-id', "");
            this.afterModelUnset(removedModel);
        }
    }

    setupBasePropHandlers(){
        // This is where we should setup any
        // prop change handlers that are universal
        // to all PartViews. We would do this via
        // the #onPropChange method, which registers
        // a handler function.
        // Do not override this method
        // TODO: Implement the universals
        this.onPropChange('script', this.scriptChanged);
        this.onPropChange('number', this.numberChanged);
        this.onPropChange('cssStyle', this.styleCSS);
        this.onPropChange('cssTextStyle', this.styleTextCSS);
        this.onPropChange('layout', this.layoutChanged);
        this.onPropChange('list-direction', this.listDirectionChanged);
        this.onPropChange('list-wrapping', this.listWrappingChanged);
        this.onPropChange('list-alignment', this.listAlignmentChanged);
        this.onPropChange('list-distribution', this.listDistributionChanged);
        this.onPropChange('horizontal-resizing', this.hResizingChanged);
        this.onPropChange('vertical-resizing', this.vResizingChanged);
        this.onPropChange('pinning-top', this.pinningTopChanged);
        this.onPropChange('pinning-right', this.pinningRightChanged);
        this.onPropChange('pinning-left', this.pinningLeftChanged);
        this.onPropChange('pinning-bottom', this.pinningBottomChanged);
        this.onPropChange('wants-move', (value) => {
            if(value){
                this.addEventListener('mousedown', this.onMouseDown);
            } else {
                this.removeEventListener('mousedown', this.onMouseDown);
            }
        });
    }

    setupBaseViewChangeHandlers(){
        // This is where we should setup any
        // view change handlers that are universal
        // to all PartViews. We would do this via
        // the #onViewChange method, which registers
        // a handler function.
        // Do not override this method
        this.onViewChange('subpart-order', this.subpartOrderChanged);
        this.onViewChange('subpart-new', this.newSubpartView);
    }

    initLayout(){
        // Not all Part/PartView pairs have the layout
        // properties. Ensure they exist first
        let hasLayout = this.model.partProperties.findPropertyNamed('layout');
        let hasBoxResizing = this.model.partProperties.findPropertyNamed('vertical-resizing');
        let hasPinning = this.model.partProperties.findPropertyNamed('pinning');
        if(hasLayout){
            let initialLayout = this.model.partProperties.getPropertyNamed(
                this.model,
                'layout'
            );
            let initialListDirection = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-direction'
            );
            let initialListWrapping = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-wrapping'
            );
            this.layoutChanged(initialLayout);
            this.listDirectionChanged(initialListDirection);
            this.listWrappingChanged(initialListWrapping);
            this.listAlignmentChanged();
            this.listDistributionChanged();
        }

        if(hasBoxResizing){
            let initialVResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'vertical-resizing'
            );
            let initialHResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'horizontal-resizing'
            );
            this.vResizingChanged(initialVResizing);
            this.hResizingChanged(initialHResizing);
        }

        if(hasPinning){
            this.pinningTopChanged();
            this.pinningBottomChanged();
            this.pinningLeftChanged();
            this.pinningRightChanged();
        }
    }

    styleCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    styleTextCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    sendMessage(aMessage, target){
        if(!this.isLensed){
            // Lensed views should not send messages
            window.System.sendMessage(aMessage, this, target);
        }
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            this.primHandlePropChange(
                aMessage.propertyName,
                aMessage.value,
                aMessage.partId
            );
            break;
        case 'viewChanged':
            this.primHandleViewChange(
                aMessage.changeName,
                ...aMessage.args
            );
            break;
        }
    }

    primHandlePropChange(name, value, partId){
        // We notify the model that the property change so that
        // on propertyChanged command handlers could be invoked
        // but we make sure that this stops at the said model and
        // does not go up the delegation chain
        let commandMessage = {
            type: 'command',
            commandName: 'propertyChanged',
            args: [name, value],
            shouldNotDelegate:true, // do not send this up the delegation chain
            shouldIgnore: true
        };
        this.sendMessage(commandMessage, this.model);
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.propChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(value, partId);
    }


    onPropChange(name, func){
        this.propChangeHandlers[name] = func;
    }

    primHandleViewChange(name, ...args){
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.viewChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(...args);
    }

    onViewChange(name, func){
        this.viewChangeHandlers[name] = func;
    }

    scriptChanged(value, partId){
        // make sure that we are only sending the compile
        // message when dealing with a 'core' st-part views (not
        // with navigator or related views)
        if(this.tagName.split("-")[0] != "ST" || this.slot == "wrapped-view"){
            return;
        }
        this.model.sendMessage({
            type: 'compile',
            codeString: value,
            targetId: partId
        }, window.System);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        // there is no need to do anything for the wrapped views
        // CardRow and StackRow will handle the updates
        if(this.name == "WrappedView"){
            return;
        }
        let subpartNode = this.childNodes[currentIndex];
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
    }

    newSubpartView(newView){
        this.appendChild(newView);
    }

    layoutChanged(value, partId){
        if(value == 'list'){
            this.classList.add('list-layout');
        } else {
            this.classList.remove('list-layout');
        }
    }

    listDirectionChanged(value, partId){
        // Row is the default configuration
        // for a list layout, so only one extra
        // CSS class needs to be toggled
        if(value == 'row'){
            this.classList.remove('list-column');
        } else if(value == 'column'){
            this.classList.add('list-column');
        }
    }

    listWrappingChanged(value, partId){
        if(value == true){
            this.classList.add('wrap-list');
        } else {
            this.classList.remove('wrap-list');
        }
    }

    hResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('h-space-fill');
            this.classList.remove(
                'h-rigid',
                'h-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('h-shrink-wrap');
            this.classList.remove(
                'h-rigid',
                'h-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('h-rigid');
            this.classList.remove(
                'h-space-fill',
                'h-shrink-wrap'
            );
        }
    }

    vResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('v-space-fill');
            this.classList.remove(
                'v-rigid',
                'v-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('v-shrink-wrap');
            this.classList.remove(
                'v-rigid',
                'v-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('v-rigid');
            this.classList.remove(
                'v-space-fill',
                'v-shrink-wrap'
            );
        }
    }

    pinningTopChanged(){
        let top = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-top'
        );
        if(top){
            this.classList.add('pin-top');
        } else {
            this.classList.remove('pin-top');
        }
    }

    pinningLeftChanged(){
        let left = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-left'
        );
        if(left){
            this.classList.add('pin-left');
        } else {
            this.classList.remove('pin-left');
        }
    }

    pinningRightChanged(){
        let right = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-right'
        );
        if(right){
            this.classList.add('pin-right');
        } else {
            this.classList.remove('pin-right');
        }
    }

    pinningBottomChanged(){
        let bottom = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-bottom'
        );
        if(bottom){
            this.classList.add('pin-bottom');
        } else {
            this.classList.remove('pin-bottom');
        }
    }

    listAlignmentChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-alignment'
        );
        let valid = [
            'top',
            'bottom',
            'left',
            'right',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-align-${side}`);
            });
            this.classList.add(`list-align-${value}`);
        }
    }

    listDistributionChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-distribution'
        );
        let valid = [
            'start',
            'end',
            'space-between',
            'space-around',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-distribution-${side}`);
            });
            this.classList.add(`list-distribution-${value}`);
        }
    }

    /* Lifecycle Method Defaults */
    afterModelSet(){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterModelUnset(removedModel){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterConnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    afterDisconnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    /* Halo Related Methods */

    openHalo(){
        // Check to see if there's a halo in
        // the component's shadow root already
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            let newHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(newHalo);
        }
    }

    closeHalo(){
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(foundHalo){
            foundHalo.remove();
        }
    }

    toggleAntsBorder(){
        if(this.classList.contains('marching-ants')){
            this.classList.remove('marching-ants');
        } else {
            this.classList.add('marching-ants');
        }
    }

    onHaloDelete(){
        // What to do when the user clicks the
        // delete button on a halo for this partview.
        // The default implementation is to send a message
        // to the System to delete the corresponding
        // model and *all* views referencing that
        // model.
        this.sendMessage({
            type: 'command',
            commandName: 'deleteModel',
            args: [this.model.id]
        }, this.model);
    }

    onHaloOpenScriptEditor(){
        // Send the message to open a script editor
        // with this view's model as the target
        this.model.sendMessage({
            type: 'command',
            commandName: 'openScriptEditor',
            args: [this.model.id]
        }, this.model);
    }

    onHaloOpenEditor(){
        window.System.editor.render(this.model);
        window.System.editor.open();
    }

    onHaloResize(movementX, movementY){
        // Default implementation on what to do during
        // halo button resize opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // width and height style properties directly.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let rect = this.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let ratio = rect.width / rect.height;
            let hyp = Math.sqrt((movementX**2) + (movementY**2));
            if(movementX < 0 || movementY < 0){
                hyp = hyp * -1;
            }
            newHeight = rect.height + hyp;
            newWidth = rect.width + hyp;
        } else {
            newWidth = movementX + rect.width;
            newHeight = movementY + rect.height;
        }
        this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
        this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    onHaloRotate(movementX, movementY){
        // Default implementation on what to do during
        // halo button rotate opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // rotate style property directly.
        if(movementX || movementY){
            let currentAngle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
            let rect = this.getBoundingClientRect();
            if(!currentAngle){
                currentAngle = 0;
            }
            let theta1 = Math.atan((rect.height/2)/(rect.width/2));
            let theta2 = Math.atan((rect.height/2 + movementY)/(rect.width/2 + movementX));
            let changeAngle = Math.abs((theta2 - theta1)*180/Math.PI);
            let newAngle = (currentAngle + changeAngle) % 360;
            if(newAngle < 0){
                newAngle = 360 + newAngle;
            }
            if(newAngle){
                this.model.partProperties.setPropertyNamed(this.model, "rotate", newAngle);
            }
        }
    }

    onHaloCopy(){
        window.System.clipboard.copyPart(this.model);
    }

    onHaloPaste(){
        window.System.clipboard.pasteContentsInto(this.model);
        this.closeHalo();
    }

    onHaloTarget(event){
        // Add targeting receive listeners to all PartViews
        // on the current card.
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.addEventListener('keydown', this.handleTargetKey);
            partView.addEventListener('mouseover', this.handleTargetMouseOver);
            partView.addEventListener('mouseout', this.handleTargetMouseOut);
            partView.addEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.add('targeting-mode');
        event.stopPropagation();
    }

    onHaloTargetButtonMouseEnter(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); //green
        });
    }

    onHaloTargetButtonMouseLeave(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.unhighlight();
        });
    }

    highlight(color){
        if(this.name != "StackView" && this.name != "WorldView"){
            this._tempBackgroundColor = this.model.partProperties.getPropertyNamed(this.model, "background-color");
            this.model.partProperties.setPropertyNamed(this.model, "background-color", color);
            this._tempBackgroundTransparency = this.model.partProperties.getPropertyNamed(this.model, "background-transparency");
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", 1);
        }

    }

    unhighlight(){
        if(this.name != "StackView" && this.name != "WorldView"){
            this.model.partProperties.setPropertyNamed(this.model, "background-color", this._tempBackgroundColor);
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", this._tempBackgroundTransparency);
        }
    }

    endHaloTarget(){
        // Remove all targeting related event listeners
        // that were added during the onHaloTarget
        // handler
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('mouseover', this.handleTargetMouseOver);
            partView.removeEventListener('mouseout', this.handleTargetMouseOut);
            partView.removeEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.remove('targeting-mode');
    }

    handleTargetKey(event){
        if(event.key == 'Escape'){
            this.endHaloTarget();
        }
    }

    handleTargetMouseOver(event){
        if(!event.target.classList.contains('targeting')){
            event.target.classList.add('targeting');
            event.target.highlight("rgb(234, 55, 55)");
            event.target.removeEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseLeave(event){
        if(event.target.classList.contains('targeting')){
            event.target.classList.remove('targeting');
            event.target.unhighlight();
            event.target.addEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseClick(event){
        event.preventDefault();
        if(event.button == 0 && event.shiftKey){
            this.onHaloActivationClick(event);
            return;
        }
        event.target.classList.remove('targeting');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'target',
            event.target.model.id
        );
        this.endHaloTarget();
        event.stopImmediatePropagation();
        event.target.unhighlight();
        event.target.addEventListener('click', event.target.onClick);
    }

    getCurrentTargetViews(){
        // clean up the current target
        let currentTarget = this.model.partProperties.getPropertyNamed(this.model, "target");
        if(currentTarget){
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this.model, window.System)
            );
            let m = window.System.grammar.match(currentTarget, "ObjectSpecifier");
            let targetId = semantics(m).interpret();
            return window.System.findViewsById(targetId);
        }
        return [];
    }

    onContextMenuClick(event){
        if(this.wantsContextMenu){
            event.preventDefault();
            event.stopPropagation();
            if(this.contextMenuIsOpen){
                this.closeContextMenu();
            } else {
                this.openContextMenuAt(
                    event.clientX,
                    event.clientY
                );
            }
        } else {
            event.stopPropagation();
        }
    }

    onAuxClick(event){
        // Should only open halo when middle
        // mouse button is clicked
        if(event.button == 1){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onClick(event){
        if(this.contextMenuIsOpen){
            this.closeContextMenu();
        }
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onHaloActivationClick(event){
        if(this.wantsHalo){
            if(this.hasOpenHalo){
                this.closeHalo();
            } else {
                event.stopPropagation();
                // Find any other open Halos
                // and automatically close them
                let exSelector = `.editing:not([part-id="${this.model.id}"])`;
                Array.from(document.querySelectorAll(exSelector)).forEach(openHaloEl => {
                    openHaloEl.closeHalo();
                });

                // Finally, open on this view
                this.openHalo();
            }
        }
    }

    onMouseDown(event){
        if(event.button == 0 && !event.shiftKey){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        this.sendMessage({
            type: 'command',
            commandName: 'move',
            args: [event.movementX, event.movementY]
        }, this.model);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    openContextMenuAt(x, y){
        let menuEl = document.createElement('st-context-menu');
        menuEl.render(this.model);
        menuEl.style.left = `${x}px`;
        menuEl.style.top = `${y}px`;
        document.body.append(menuEl);

        // Ensure that the menu is completely
        // within the current view. If not (meaning
        // it is clipped), then adjust so it is
        // completely in the view.
        menuEl.adjustToClientView();
    }

    closeContextMenu(){
        let found = document.querySelector('st-context-menu');
        if(found){
            found.remove();
        }
    }

    addContextMenuItems(contextMenu){
        // The default implementation is to
        // do nothins.
        // Subclasses should override and use the
        // passed-in contextMenu object to construct
        // list items that are specific to their needs
        return;
    }

    get wantsHaloMove(){
        if(!this.parentElement || !this.isConnected){
            return false;
        }
        let parentModel = this.parentElement.model;
        if(!parentModel){
            return true;
        }

        let hasLayout = parentModel.partProperties.findPropertyNamed(
            parentModel,
            'layout'
        );

        if(!hasLayout){
            return true;
        }

        let parentLayout = parentModel.partProperties.getPropertyNamed(
            parentModel,
            'layout'
        );
        if(parentLayout === 'strict' | !parentLayout || parentLayout == ""){
            return true;
        }

        return false;
    }

    get contextMenuIsOpen(){
        let found = document.querySelector('st-context-menu');
        if(found){
            return true;
        }
        return false;
    }

    /* Editor related methods */
    openEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    closeEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }
};




/***/ }),

/***/ "./js/objects/views/ResourceView.js":
/*!******************************************!*\
  !*** ./js/objects/views/ResourceView.js ***!
  \******************************************/
/*! exports provided: ResourceView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceView", function() { return ResourceView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResourceView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-building-bridge-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <path d="M6 7h12a2 2 0 0 1 2 2v9a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-2a4 4 0 0 0 -8 0v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-9a2 2 0 0 1 2 -2"></path>
    </svg>
</div>
`;

class ResourceView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateResourceLink = this.updateResourceLink.bind(this);
        this.indicateReadyState = this.indicateReadyState.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        // if the resourceName property is set then make sure it is loaded
        // TODO: i don't like this view asking the model to load!
        let resourceName = this.model.partProperties.getPropertyNamed(this.model, "resourceName");
        if(resourceName){
            this.model.loadResource([this], resourceName);
        }
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            this.model.setSourceTo([this], src);
        }
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        let state = this.model.partProperties.getPropertyNamed(
            this.model,
            "readyState",
        );
        this.indicateReadyState(state);
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", this.indicateReadyState);
        this.onPropChange("src", (url) => {
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    indicateReadyState(value){
        let borderColor = "red";
        if(value == "fetching"){
            borderColor = "yellow";
        } else if(value == "ready"){
            borderColor = "green";
        };
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-resource-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for resource');
        this.haloButton.addEventListener('click', this.updateResourceLink);
    }

    updateResourceLink(event){
        // Tells the model to update its
        // src link for the resource
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for resource:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadResource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/StackView.js":
/*!***************************************!*\
  !*** ./js/objects/views/StackView.js ***!
  \***************************************/
/*! exports provided: StackView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackView", function() { return StackView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Stack.js */ "./js/objects/parts/Stack.js");
/**
 * StackView
 * ----------------------------------------------
 * I am a Webcomponent (custom element) representing
 * the view of a Stack.
 * I take up the full width of the current viewport
 * when I am being displayed.
 * My child elements are BackgroundView and CardView
 */




// by default, stacks are hidden unless they're
// the current stack, or else they have the class
// window-stack (suggesting there's window part
// who wishes to display it)
const templateString = `<slot></slot>`;

class StackView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup templating and shadow dom
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Handle current-ness prop change
        this.onPropChange('current', this.handleCurrentChange);

        // Bind methods
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
    }

    afterModelSet(){
        // Do an initial setting of the
        // current card
        this.handleCurrentChange();
    }

    handleCurrentChange(){
        // The value of the current prop is the card ID
        // of the child Card that should be the
        // current one. We remove the current-card class from
        // the previous current card and add it to the new one.
        let currentCard = this.querySelector('.current-card');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let shouldNotify = false;
        let selector = `:scope > st-card[part-id="${nextCurrentId}"]`;
        if(this.isLensed){
            selector = `:scope > st-card[lens-part-id="${nextCurrentId}"]`;
            shouldNotify = true;
        }
        let nextCurrentCard = this.querySelector(selector);
        // if there is no currentCard and no next currentCard we set it to be the first
        // card child (this can happen when new ids are created on deserialization and so
        // the current property stored id is no longer relevant)
        if(!nextCurrentCard && !currentCard){
            nextCurrentCard = this.querySelector(`:scope > st-card`);
            // if there are no cards at all, this must be a brand new stack
            if(!nextCurrentCard){
                return;
            }
            this.model.partProperties.setPropertyNamed(
                this.model,
                "current",
                nextCurrentCard.id,
                shouldNotify
            );
        }
        if(nextCurrentCard){
            nextCurrentCard.classList.add('current-card');
        } else {
            return;
        }
        if(currentCard && currentCard != nextCurrentCard){
            currentCard.classList.remove('current-card');
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "CardView"){
            let lastCardNode;
            this.childNodes.forEach((child) => {
                if(child.name == "CardView"){
                    lastCardNode = child;
                }
            });
            if(lastCardNode){
                // insert after the last card
                lastCardNode.after(newView);
            } else {
                // since there are no cards
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/WindowView.js":
/*!****************************************!*\
  !*** ./js/objects/views/WindowView.js ***!
  \****************************************/
/*! exports provided: WindowView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindowView", function() { return WindowView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WindowView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WindowView
 * -------------------------------
 * I am the view of a Window Part.
 * Windows are wrappers for Stacks/StackViews that
 * appear as the subparts of other Stacks or Cards.
 * They are examples of how we can use stack and card
 * composition to create more complex UIs.
 */


const template = document.createElement('template');
template.innerHTML = `
<style>
 * {
     box-sizing: border-box;
 }

 .st-window-bar {
     display: flex;
     flex-direction: row;
     width: 100%;
     min-height: 25px;
     background-color: rgb(218, 218, 218);
     padding-left: 8px;
     padding-right: 8px;
     align-items: center;
 }
 .st-window-button {
     display: block;
     width: 12px;
     height: 12px;
     border-radius: 100%;
     background-color: rgba(255, 150, 150);
     margin-right: 4px;
 }
 .close-button {
     background-color: rgba(255, 50, 50, 0.4);
 }
 .shade-button {
     background-color: rgba(255, 255, 0. 0.4);
 }
 .expand-button {
     background-color: rgba(150, 255, 0, 0.8);
 }
 .st-window-pane {
     display: block;
     position: relative;
     min-height: 50px;
     flex: 1;
 }
 .st-window-pane.shaded {
     display: none;
 }
 .st-window-gripper {
     display: block;
     position: absolute;
     top: calc(100% - 15px);
     width: 30px;
     height: 30px;
 }
 .st-window-title {
     user-select: none;
     text-overflow: ellipsis;
     overflow: hidden;
     white-space: nowrap;
     max-width: 70%;
 }
 .right-gripper {
     left: calc(100% - 15px);
 }
 .right-gripper:hover {
     cursor: nwse-resize;
 }
 .left-gripper {
     right: calc(100% - 15px);
 }
 .left-gripper:hover {
     cursor: nesw-resize;
 }
</style>
<div class="st-window-bar">
    <div class="st-window-button close-button"></div>
    <div class="st-window-button shade-button"></div>
    <div class="st-window-button expand-button"></div>
    <div class="st-window-title">
        <span></span>
    </div>
</div>
<div class="st-window-pane">
    <slot></slot>
</div>
<div class="st-window-gripper right-gripper" data-grip-end="right"></div>
`;

class WindowView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        var templateContent = template.content.cloneNode(true);
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(templateContent);

        this.mouseDownInBar = false;
        this.isShaded = false;
        this.isExpanded = false;
        this.expandCache = {};

        // Whether or not we are gripping the
        // bottom right corner for a resize
        this.isGripping = false;

        // Bound methods
        this.setupClickAndDrag = this.setupClickAndDrag.bind(this);
        this.setupBarButtons = this.setupBarButtons.bind(this);
        this.setupExpanderAreas = this.setupExpanderAreas.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.onMouseMoveInBar = this.onMouseMoveInBar.bind(this);
        this.onMouseDownInBar = this.onMouseDownInBar.bind(this);
        this.onMouseUpAfterDrag = this.onMouseUpAfterDrag.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onShade = this.onShade.bind(this);
        this.onExpand = this.onExpand.bind(this);
        this.onGripDown = this.onGripDown.bind(this);
        this.onGripUp = this.onGripUp.bind(this);
        this.onGripMove = this.onGripMove.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('title', this.setTitle);
    }

    afterConnected(){
        this.setupClickAndDrag();
        this.setupBarButtons();
        this.setupExpanderAreas();
    }

    afterModelSet(){
        this.setTitle(
            this.model.partProperties.getPropertyNamed(
                this.model,
                'title'
            )
        );
    }

    setupClickAndDrag(){
        let bar = this._shadowRoot.querySelector('.st-window-bar');
        bar.addEventListener('mousedown', this.onMouseDownInBar);
    }

    setupBarButtons(){
        let closeButton = this._shadowRoot.querySelector('.close-button');
        let shadeButton = this._shadowRoot.querySelector('.shade-button');
        let expandButton = this._shadowRoot.querySelector('.expand-button');

        closeButton.addEventListener('click', this.onClose);
        shadeButton.addEventListener('click', this.onShade);
        expandButton.addEventListener('click', this.onExpand);
    }

    setupExpanderAreas(){
        let lowerRight = this._shadowRoot.querySelector('.right-gripper');
        lowerRight.addEventListener('mousedown', this.onGripDown);
    }

    onExpand(event){
        if(this.isExpanded){
            this.style.width = this.expandCache.width;
            this.style.height = this.expandCache.height;
            this.style.top = this.expandCache.top;
            this.style.left = this.expandCache.left;
            this.isExpanded = false;
        } else {
            this.expandCache = {
                width: this.style.width,
                height: this.style.height,
                top: this.style.top,
                left: this.style.left
            };
            // Set new values based on window size
            this.style.top = "0px";
            this.style.left = "0px";
            this.style.width = "100vw";
            this.style.height = "100vh";
            this.isExpanded = true;
        }
    }

    onShade(event){
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        if(this.isShaded){
            pane.classList.remove('shaded');
            this.isShaded = false;
        } else {
            pane.classList.add('shaded');
            this.isShaded = true;
        }
    }

    onClose(event){
        let msg = {
            type: 'command',
            commandName: 'windowClose',
            args: []
        };
        this.model.sendMessage(msg, this.model);
    }

    onMouseDownInBar(event){
        this.mouseDownInBar = true;
        let bar = event.target;
        document.addEventListener('mousemove', this.onMouseMoveInBar);
        document.addEventListener('mouseup', this.onMouseUpAfterDrag);
    }

    onMouseUpAfterDrag(event){
        this.mouseDownInBar = false;
        let bar = event.target;
        document.removeEventListener('mouseup', this.onMouseUpAfterDrag);
        document.removeEventListener('mousemove', this.onMouseMoveInBar);
    }

    onMouseMoveInBar(event){
        let currentTop = parseInt(this.style.top);
        let currentLeft = parseInt(this.style.left);
        // let newTop = `${currentTop + event.movementY}px`;
        // let newLeft = `${currentLeft + event.movementX}px`;
        let newTop = currentTop + event.movementY;
        let newLeft = currentLeft + event.movementX;
        this.model.partProperties.setPropertyNamed(this.model, "top", newTop);
        this.model.partProperties.setPropertyNamed(this.model, "left", newLeft);
    }

    onGripUp(event){
        this.isGripping = false;
        document.removeEventListener('mousemove', this.onGripMove);
        document.removeEventListener('mouseup', this.onGripUp);
    }

    onGripDown(event){
        this.isGripping = true;
        document.addEventListener('mousemove', this.onGripMove);
        document.addEventListener('mouseup', this.onGripUp);
    }

    onGripMove(event){
        if(this.isGripping){
            // Figure out the current width and height.
            // and set the property to the new one
            let box = this.getBoundingClientRect();
            let newWidth = Math.floor(box.width) + event.movementX;
            if(newWidth){
                this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
            }
            let newHeight = Math.floor(box.height) + event.movementY;
            if(newHeight){
                this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
            }
        }
    }

    setTitle(aString){
        let titleArea = this._shadowRoot.querySelector(
            '.st-window-title > span'
        );
        titleArea.innerText = aString;
    }

    // override subclass methods
    newSubpartView(newView){
        // slot the new view into the window pane
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        pane.append(newView);
        this.appendChild(newView);
    }


};




/***/ }),

/***/ "./js/objects/views/WorldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/WorldView.js ***!
  \***************************************/
/*! exports provided: WorldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldView", function() { return WorldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WorldView
 * ---------------------------------------------
 * I am a Webcomponent (custom element) that represents
 * a view of a WorldStack model.
 * My element children should contain a single StackView representing
 * the current displayed stack (this comes from the model).
 * I am the root-level element for the SimpleTalk system in a web
 * page. There should only be one of me on any given HTML page.
 */


const templateString = `<slot></slot>`;

const NODES_TO_IGNORE_WHEN_ARROW_KEY = [
    'TEXTAREA',
    'INPUT',
    'ST-FIELD'
];

class WorldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Set up templating and shadow dom
        // TODO: Put the template definition in this
        // module as formatted text
        const template = document.createElement('template');
        template.innerHTML = templateString;
        
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // The world never wants a halo
        this.wantsHalo = false;

        // Bound methods
        this.updateCurrentStack = this.updateCurrentStack.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('current', this.updateCurrentStack);
    }

    afterConnected(){
        document.addEventListener('keydown', this.handleKeyDown);
    }

    afterDisconnected(){
        document.removeEventListener('keydown', this.handleKeyDown);
    }

    afterModelSet(){
        // Do an initial update to display
        // the model's current stack
        this.updateCurrentStack();
    }

    updateCurrentStack(){
        // The value of the current prop is the stack ID
        // of the child Stack that should be the
        // current one. We remove the current-stack class from
        // the previous current stack and add it to the new one.
        let currentStack = this.querySelector('.current-stack');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let nextCurrentStack = this.querySelector(`:scope > st-stack[part-id="${nextCurrentId}"]`);
        if(nextCurrentStack){
            nextCurrentStack.classList.add('current-stack');
        } else {
            return;
        }
        // To prevent the setting of the same id as the current stack make sure
        // next and current are not the same
        if(currentStack && currentStack != nextCurrentStack){
            currentStack.classList.remove('current-stack');
        }
    }

    handleKeyDown(event){
        if(event.altKey && event.ctrlKey && event.code == "Space"){
            let navigator = document.querySelector('st-navigator');
            navigator.toggle();
        } else {
            // Bind arrow key events if and only if
            // the focus is not in any kind of text input.
            // We send the arrowKey command to the current card
            if(event.code.startsWith('Arrow')){
                if(!NODES_TO_IGNORE_WHEN_ARROW_KEY.includes(document.activeElement.nodeName)){
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'arrowKey',
                        args: [
                            // First arg is the direction
                            event.code.split('Arrow')[1].toLowerCase(),
                            event.ctrlKey,
                            event.altKey,
                            event.shiftKey
                        ],
                        shouldIgnore: true
                    }, this.model.currentStack.currentCard);
                }
            }
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "StackView"){
            let lastStackNode;
            this.childNodes.forEach((child) => {
                if(child.name == "StackView"){
                    lastStackNode = child;
                }
            });
            if(lastStackNode){
                // insert after the last stack
                lastStackNode.after(newView);
            } else {
                // since there are no stacks
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenu.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenu.js ***!
  \*****************************************************/
/*! exports provided: ContextMenu, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenu", function() { return ContextMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenu; });
/* harmony import */ var _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContextMenuItem.js */ "./js/objects/views/contextmenu/ContextMenuItem.js");
// PREAMBLE


window.customElements.define('st-context-menu-item', _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        border: 1px solid black;
        background-color: white;
        box-shadow: 1px 2px 10px rgba(50, 50, 50, 0.7);
        z-index: 10000;
        padding-bottom: 8px;
        min-width: 200px;
        font-family: 'Helvetica', sans-serif;
    }

    :host-context(li) {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host-context(li):hover {
        display: flex;
    }

    header {
        position: relative;
        display: flex;
        border-bottom: 1px solid rgba(150, 150, 150, 0.5);
        padding-right: 16px;
        padding-left: 16px;
        padding-top: 8px;
        padding-bottom: 8px;
    }

    header > h4 {
        padding: 0;
        margin:0;
    }

    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        font-size: 0.8rem;
    }

</style>
<header>
    <h4></h4>
</header>
<ul id="list-items">
    <slot></slot>
</ul>
`;

class ContextMenu extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.addHaloToggleItem = this.addHaloToggleItem.bind(this);
        this.addNavigatorToggleItem = this.addNavigatorToggleItem.bind(this);
        this.addCopyAndPasteItems = this.addCopyAndPasteItems.bind(this);
        this.addOpenEditorItem = this.addOpenEditorItem.bind(this);
        this.addScriptEditItem = this.addScriptEditItem.bind(this);
        this.addMovementItems = this.addMovementItems.bind(this);
        this.addPartSubmenu = this.addPartSubmenu.bind(this);
        this.addListItem = this.addListItem.bind(this);
        this.addSpacer = this.addSpacer.bind(this);
        this.hideHeader = this.hideHeader.bind(this);
        this.adjustToClientView = this.adjustToClientView.bind(this);
    }

    render(aModel){
        this.innerHTML = "";
        this.model = aModel;
        let headerEl = this._shadowRoot.querySelector('header > h4');
        let headerText = `${this.model.type[0].toUpperCase()}${this.model.type.slice(1)}`;
        headerText = `a ${headerText}`;
        headerEl.textContent = headerText;

        // Render the default menu items
        this.addHaloToggleItem();
        this.addCopyAndPasteItems();
        this.addOpenEditorItem();
        this.addPartSubmenu();
        this.addScriptEditItem();
        this.addMovementItems();
        this.addNavigatorToggleItem();

        // Add View-specific items
        let view = document.querySelector(`[part-id="${this.model.id}"]`);
        view.addContextMenuItems(this);
    }

    addListItem(label, callback, submenu=null){
        let itemEl = document.createElement('st-context-menu-item');
        itemEl.textContent = label;
        itemEl.classList.add('context-menu-item');
        itemEl.addEventListener('click', callback);
        itemEl.addEventListener('click', () => {
            this.remove();
        });
        if(submenu){
            submenu.classList.add('context-submenu', 'submenu-hidden');
            submenu.setAttribute('slot', 'submenu');
            itemEl.append(submenu);
            itemEl.showCaret();
        }
        this.append(itemEl);
    }

    addHaloToggleItem(){
        let target = window.System.findViewById(this.model.id);
        // don't add halo option to cards, since you can't see those
        if(target.name != "CardView"){
            if(target.classList.contains('editing')){
                this.addListItem(
                    'Close Halo',
                    (event) => {
                        target.closeHalo();
                    }
                );
            } else {
                this.addListItem(
                    'Open Halo',
                    (event) => {
                        target.openHalo();
                    }
                );
            }
        }
    }

    addNavigatorToggleItem(){
        let nav = document.querySelector('st-navigator');
        if(nav.classList.contains('open')){
            nav.classList.toggle('open');
            this.addListItem(
                'Close Navigator',
                (event) => {
                    nav.close();
                }
            );
        } else {
            this.addListItem(
                'Open Navigator',
                (event) => {
                    nav.open();
                    nav.classList.toggle('open');
                }
            );
        }
    }

    addCopyAndPasteItems(){
        // Add copy item
        this.addListItem(
            'Copy',
            (event) => {
                window.System.clipboard.copyPart(this.model);
            }
        );

        // Add paste but only if:
        // 1. There is clipboard contents;
        // 2. The part type in the clipboard is
        //    one that is accepted by this model's part
        if(window.System.clipboard.contents.length){
            let partType = window.System.clipboard.contents[0].partType;
            if(this.model.acceptsSubpart(partType)){
                let label = `Paste (a ${partType[0].toUpperCase()}${partType.slice(1)})`;
                this.addListItem(label, (event) => {
                    window.System.clipboard.pasteContentsInto(this.model);
                });
            }
        }
    }

    addOpenEditorItem(){
        this.addListItem(
            'Open Editor',
            (event) => {
                window.System.openEditorForPart(this.model.id);
            }
        );
    }

    addScriptEditItem(){
        this.addListItem(
            'Edit Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: [this.model.id]
                }, this.model);
            }
        );

        this.addListItem(
            'Edit World Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: ['world']
                }, this.model);
            }
        );

        let windowAncestor = this.model.findAncestorOfType('window');
        if(this.model.type != 'window' && windowAncestor !== null){
            this.addListItem(
                'Edit Owning Window Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [windowAncestor.id]
                    }, this.model);
                }
            );
        }
        
        let cardAncestor = this.model.findAncestorOfType('card');
        if(this.model.type != 'card' && cardAncestor){
            this.addListItem(
                'Edit Owning Card Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [cardAncestor.id]
                    }, this.model);
                }
            );
        }

        let stackAncestor = this.model.findAncestorOfType('stack');
        if(this.model.type != 'stack' && stackAncestor){
            this.addListItem(
                'Edit Owning Stack Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [stackAncestor.id]
                    }, this.model);
                }
            );
        }
    }

    addPartSubmenu(){
        // First, we need to get a list of names
        // of subparts that this model accepts
        let subpartNames;
        if(this.model.acceptedSubpartTypes[0] == "*"){
            // This model accepts all subpart types.
            // We need to get the names for these subparts,
            // which are registered at the System level.
            subpartNames = Object.keys(window.System.availableViews);
        } else {
            subpartNames = this.model.acceptedSubpartTypes;
        }

        // If there are no subpart names (meaning
        // the given part, like a button, doesn't
        // accept any subparts), then we do nothing.
        if(subpartNames.length == 0){
            return;
        }

        // Now we construct the submenu for adding parts
        // of the given type
        let submenu = document.createElement('st-context-menu');
        submenu.hideHeader();
        subpartNames.forEach(subpartName => {
            submenu.addListItem(
                subpartName[0].toUpperCase() + subpartName.slice(1),
                () => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'newModel',
                        args: [
                            subpartName,
                            this.model.id
                        ]
                    }, this.model);
                }
            );
        });

        // Now add the list item that will "reveal"
        // the submenu
        this.addListItem(
            'Add a new part',
            null,
            submenu
        );
        
    }

    addMovementItems(){
        let index = this.model._owner.subparts.indexOf(this.model);
        let ownerLength = this.model._owner.subparts.length;
        if(ownerLength && index < ownerLength - 1){
            // Create the moveDown option
            this.addListItem(
                'Move Down',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveDown',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to Last',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToLast',
                        args: []
                    }, this.model);
                }
            );
        }
        if(index > 0){
            // Create the moveUp option
            this.addListItem(
                'Move Up',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveUp',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to First',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToFirst',
                        args: []
                    }, this.model);
                }
            );
        }
    }

    addSpacer(){
        let item = document.createElement('li');
        item.classList.add('context-menu-spacer');
        this.append(item);
    }

    hideHeader(){
        let headerEl = this._shadowRoot.querySelector('header');
        headerEl.style.display = "none";
    }

    adjustToClientView(){
        let rect = this.getBoundingClientRect();
        let padding = 10;
        let viewportWidth = document.documentElement.clientWidth;
        let viewportHeight = document.documentElement.clientHeight;
        let bottomDiff = (rect.bottom + padding) - viewportHeight;
        let rightDiff = (rect.right + padding) - viewportWidth;
        if(bottomDiff > 0){
            this.style.top = `${(rect.top - bottomDiff)}px`;

            // Reposition any hidden submenus, so they open
            // above
            Array.from(this.children).filter(childEl => {
                return childEl.children.length > 0;
            }).forEach(itemWithSubmenu => {
                let container = itemWithSubmenu._shadowRoot.querySelector('.submenu-area');
                container.style.top = `${(-1 * itemWithSubmenu.getBoundingClientRect().height)}px`;
            });
        }
        if(rightDiff > 0){
            this.style.left = `${rect.left - rightDiff}px`;

            // Reposition any hidden submenus, so they open
            // to the left (instead of right)
            Array.from(this.children).filter(childEl => {
                return childEl.children.length > 0;
            }).forEach(itemWithSubmenu => {
                let container = itemWithSubmenu._shadowRoot.querySelector('.submenu-area');
                container.style.left = `${(-1 * itemWithSubmenu.getBoundingClientRect().width)}px`;
            });
        }
    }
};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenuItem.js":
/*!*********************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenuItem.js ***!
  \*********************************************************/
/*! exports provided: ContextMenuItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenuItem", function() { return ContextMenuItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenuItem; });
const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
    }
    .submenu-area {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host(:hover) .submenu-area {
        display: flex;
    }

    .label-area {
        display: flex;
        align-items: center;
    }

    .caret.hidden {
        display: none;
    }
    .caret {
        display: block;
        margin-left: auto;
        font-size: 1.1em;
    }
</style>
<div class="label-area">
    <span class="label"><slot></slot></span>
    <div class="caret hidden"></div>
</div>
<div class="submenu-area">
    <slot name="submenu"></slot>
</div>
`;

class ContextMenuItem extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.append(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.showCaret = this.showCaret.bind(this);
    }

    showCaret(){
        let caretEl = this._shadowRoot.querySelector('.caret');
        caretEl.classList.remove('hidden');    
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/ColorPickerTool.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/drawing/ColorPickerTool.js ***!
  \*****************************************************/
/*! exports provided: ColorPickerTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPickerTool", function() { return ColorPickerTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorPickerTool; });
/* harmony import */ var _ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/**
 * ColorPickerTool
 * I provide a color choorser capability
 * for the shadow canvas of my parent element.
 * Brushes on my parent Drawing canvas will use
 * whatever color I have currently selected.
 * I am explicitly designed for use with
 * DrawingView*/

const colorPickerSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-color-swatch" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 3h-4a2 2 0 0 0 -2 2v12a4 4 0 0 0 8 0v-12a2 2 0 0 0 -2 -2" />
  <path d="M13 7.35l-2 -2a2 2 0 0 0 -2.828 0l-2.828 2.828a2 2 0 0 0 0 2.828l9 9" />
  <path d="M7.3 13h-2.3a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h12" />
  <line x1="17" y1="17" x2="17" y2="17.01" />
</svg>
`;

const colorPickerTemplateString = `
<style>
    :host {
        display: block;
        position: relative;
        margin-bottom: 6px;
    }

    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        position: relative;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
        width: 24px;
        height: 24px;
    }

    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    color-wheel {
        display: none;
        position: absolute;
    }

    :host([active="true"]) > color-wheel {
        display: flex;
    }
</style>
<div id="tool-button">
${colorPickerSVG}
</div>
<color-wheel></color-wheel>
`;


class ColorPickerTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can be
        // toggled within its parent DrawingView.
        this.template = document.createElement('template');
        this.template.innerHTML = colorPickerTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool
        // is connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.onColorSelected = this.onColorSelected.bind(this);
        this.onTransparencyChanged = this.onTransparencyChanged.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('current-color')){
                this.setAttribute('current-color', 'rgba(0, 0, 0, 0)');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.colorWheel = this.shadowRoot.querySelector('color-wheel');
            this.colorWheel.addEventListener('color-selected', this.onColorSelected);
            this.colorWheel.addEventListener('transparency-changed', this.onTransparencyChanged);
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.colorWheel.removeEventListener('color-selected', this.onColorSelected);
        this.colorWheel.removeEventListener('transparency-changed', this.onTransparencyChanged);
    }

    start(x, y){
        // Does nothing in this tool
    }

    end(x, y){
        // Does nothing in this tool
    }

    onMove(x, y){
        // Does nothing in this tool
    }

    setContextFromAttributes(){
        // Does nothing in this tool
    }

    onColorSelected(event){
        let colorInfo = event.detail;
        let colorStr = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
        this.ctx.strokeStyle = colorStr;
        this.ctx.fillStyle = colorStr;
    }

    onTransparencyChanged(event){
        this.parentElement.model.sendMessage({
            type: "command",
            commandName: "setProperty",
            args: ["transparency", event.detail]
        }, this.parentElement.model);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};



window.customElements.define('color-picker-tool', ColorPickerTool);




/***/ }),

/***/ "./js/objects/views/drawing/ColorWheelWidget.js":
/*!******************************************************!*\
  !*** ./js/objects/views/drawing/ColorWheelWidget.js ***!
  \******************************************************/
/*! exports provided: ColorWheelWidget, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorWheelWidget", function() { return ColorWheelWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorWheelWidget; });
/**
 * ColorWheelWidget
 * I am a *generic use* webcomponent representing
 * a ColorWheel selection widget.
 * I operate as a floating modal window with a
 * circular color wheel as well as a list of
 * recently selected colors.
 * I am designed to be used by any parent element.
 * I will trigger an event called 'color-change' whenever
 * a new color has been selected from within me
 */

const colorWheelTemplate = `
<style>
  :host {
    display: initial !important;
    visibility: visible !important;
    position: relative;
    flex-direction: column;
    align-items: center;
    box-sizing: border-box;
    background-color: white;
    border: 1px solid black;
  }

  #palette-bar {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    height: 20px;
    background-color: rgba(200, 200, 200);
    width: 100%;
    box-sizing: border-box;
  }

  #palette-title {
    width: 100%;
    text-align: center;
  }

  #close-button {
    display: block;
    width: 12px;
    height: 12px;
    margin-left: 8px;
    background-color: white;
    border: 1px solid black;
    text-align: center;
    font-size: 12px;
  }

  #palette-content {
    flex: 1;
    display: block;
    position: relative;
  }
  #hover-color {
    display: block;
    width: 100%;
    height: 25px;
  }
  #options {
    display: flex;
    width: 100%;
    height: 25px;
    margin-top: 5px;
    justify-content: center;
  }

  #options > label{
    font-size: .8rem;
    display: flex;
    align-items: center;
  }

  #recent-colors {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    padding-left: 15px;
    padding-right: 15px;
    box-sizing: border-box;
    list-style: none;
  }
  .recent-color-item {
    display: block;
    width: 26px;
    height: 26px;
    box-sizing: border-box;
    border: 1px solid rgba(200, 200, 200, 0.8);
  }

  .recent-color-item.selected {
    border: 2px solid black;
  }

</style>
<div id="palette-wrapper">
  <div id="palette-bar"><div id="close-button">x</div><span id="palette-title"></span></div>
  <div id="palette-content">
    <div id="options">
      <input type="range" id="transparency" name="transparency" min="0" max="1" step="0.1" value="1">
      <!-- <label for="transparency">Transparency</label>-->
    </div>
    <ul id="recent-colors">
      <li class="recent-color-item selected"></li>
      <li class="recent-color-item"></li>
      <li class="recent-color-item"></li>
    </ul>
    <canvas id="color-wheel" width="150" height="150"></canvas>
    <div id="hover-color"></div>
  </div>
</div>
`;

class ColorWheelWidget extends HTMLElement {
    constructor(name){
        super();

        this.name = name;

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = colorWheelTemplate;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind local methods
        this.onWheelMouseEnter = this.onWheelMouseEnter.bind(this);
        this.onWheelMouseLeave = this.onWheelMouseLeave.bind(this);
        this.onWheelMouseMove = this.onWheelMouseMove.bind(this);
        this.onWheelClick = this.onWheelClick.bind(this);
        this.onItemClick = this.onItemClick.bind(this);
        this.onBarMouseDown = this.onBarMouseDown.bind(this);
        this.onBarMouseUp = this.onBarMouseUp.bind(this);
        this.onBarMouseMove = this.onBarMouseMove.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onTransparencyChange = this.onTransparencyChange.bind(this);
        this._drawWheel = this._drawWheel.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.canvas = this.shadowRoot.querySelector('canvas');
            this.bar = this.shadowRoot.getElementById('palette-bar');
            // give the widget a title if provided
            if(this.name){
                this.shadowRoot.getElementById('palette-title').innerText = this.name;
            }

            // Set events
            this.canvas.addEventListener('click', this.onWheelClick);
            this.canvas.addEventListener('mouseenter', this.onWheelMouseEnter);
            this.bar.addEventListener('mousedown', this.onBarMouseDown);
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item')).forEach(el => {
                el.addEventListener('click', this.onItemClick);
            });
            this.transparencySlider = this.shadowRoot.getElementById('transparency');
            this.transparencySlider.addEventListener("input", this.onTransparencyChange);

            // Draw the color wheel to the canvas
            this._drawWheel();
        }
    }

    disconnectedCallback(){
        this.canvas.removeEventListener('click', this.onWheelClick);
        this.canvas.removeEventListener('mouseenter', this.onWheelMouseEnter);
        this.bar.removeEventListener('mousedown', this.onBarMouseDown);
        Array.from(this.shadowRoot.querySelector('.recent-color-item')).forEach(el => {
            el.removeEventListener('click', this.onItemClick);
        });
        this.transparencySlider.removeEventListener("change", this.onTransparencyChange);
    }


    onWheelMouseEnter(event){
        // Cache the image data for the whole canvas
        let ctx = this.canvas.getContext('2d');
        this._cachedImageData = ctx.getImageData(
            0,
            0,
            this.canvas.width,
            this.canvas.height
        );
        // Bind subsequent events
        this.canvas.addEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.addEventListener('mouseleave', this.onWheelMouseLeave);
    }

    onWheelMouseLeave(event){
        this.canvas.removeEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.removeEventListener('mouseleave', this.onWheelMouseLeave);
        this._cachedImageData = null;
    }

    onWheelMouseMove(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let hoverColorArea = this.shadowRoot.getElementById('hover-color');
        let newStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;
        hoverColorArea.style.backgroundColor = newStyle;
    }

    onWheelClick(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let colorInfo = {
            r: rgb[0],
            g: rgb[1],
            b: rgb[2],
            alpha: rgb[3]
        };
        let newEvent = new CustomEvent('color-selected', {
            detail: colorInfo
        });
        this.selectedColor = colorInfo;
        this.dispatchEvent(newEvent);

        // Update the recent color swatches
        let currentSwatchSelection = this.shadowRoot.querySelector('.recent-color-item.selected');
        if(currentSwatchSelection){
            currentSwatchSelection.style.backgroundColor = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
            currentSwatchSelection.selectedColor = colorInfo;
        }
    }

    onTransparencyChange(event){
        let command = this.getAttribute("selector-command");
        // update the corresponding transparency - text or background
        // depending on what this color wheel is setup to update
        let propName = "background-transparency";
        if(command === "text-color"){
            propName = "text-transparency";
        }
        let eventDetail = {propName: propName, value: event.target.value};
        let newEvent = new CustomEvent('transparency-changed', {
            detail: eventDetail,
        });
        this.dispatchEvent(newEvent);
    }

    onItemClick(event){
        // If this element is not the currently
        // selected recent item, find the one that is
        // and toggle the selection class, then toggle
        // this item's selection class.
        if(!event.target.classList.contains('selected')){
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item.selected')).forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        if(event.target.selectedColor){
            let newEvent = new CustomEvent('color-selected', {
                detail: event.target.selectedColor
            });
            this.dispatchEvent(newEvent);
        }
    }

    onBarMouseDown(event){
        document.addEventListener('mousemove', this.onBarMouseMove);
        document.addEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseUp(event){
        document.removeEventListener('mousemove', this.onBarMouseMove);
        document.removeEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseMove(event){
        let newTop = this.offsetTop + event.movementY;
        let newLeft = this.offsetLeft + event.movementX;
        this.style.top = `${newTop}px`;
        this.style.left = `${newLeft}px`;
    }

    onClose(event){
        this.remove();
    }

    _drawWheel(){
        let ctx = this.canvas.getContext('2d');
        drawCircle(ctx, this.canvas.width / 2);
    }
};

window.customElements.define('color-wheel', ColorWheelWidget);

/** Utility Functions **/

// This function is adapted from
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const drawCircle = (ctx, radius) => {
    let image = ctx.createImageData(2*radius, 2*radius);
    let data = image.data;

    for (let x = -radius; x < radius; x++) {
        for (let y = -radius; y < radius; y++) {

            let [r, phi] = xy2polar(x, y);

            if (r > radius) {
                // skip all (x,y) coordinates that are outside of the circle
                continue;
            }

            let deg = rad2deg(phi);

            // Figure out the starting index of this pixel in the image data array.
            let rowLength = 2*radius;
            let adjustedX = x + radius; // convert x from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let adjustedY = y + radius; // convert y from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let pixelWidth = 4; // each pixel requires 4 slots in the data array
            let index = (adjustedX + (adjustedY * rowLength)) * pixelWidth;

            let hue = deg;
            let saturation = r / radius;
            let value = 1.0;

            let [red, green, blue] = hsv2rgb(hue, saturation, value);
            let alpha = 255;

            data[index] = red;
            data[index+1] = green;
            data[index+2] = blue;
            data[index+3] = alpha;
        }
    }

    ctx.putImageData(image, 0, 0);
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const xy2polar = (x, y) => {
    let r = Math.sqrt(x*x + y*y);
    let phi = Math.atan2(y, x);
    return [r, phi];
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43s
const rad2deg = (rad) => {
    return ((rad + Math.PI) / (2 * Math.PI)) * 360;
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const hsv2rgb = (hue, saturation, value) => {
    let chroma = value * saturation;
    let hue1 = hue / 60;
    let x = chroma * (1- Math.abs((hue1 % 2) - 1));
    let r1, g1, b1;
    if (hue1 >= 0 && hue1 <= 1) {
        ([r1, g1, b1] = [chroma, x, 0]);
    } else if (hue1 >= 1 && hue1 <= 2) {
        ([r1, g1, b1] = [x, chroma, 0]);
    } else if (hue1 >= 2 && hue1 <= 3) {
        ([r1, g1, b1] = [0, chroma, x]);
    } else if (hue1 >= 3 && hue1 <= 4) {
        ([r1, g1, b1] = [0, x, chroma]);
    } else if (hue1 >= 4 && hue1 <= 5) {
        ([r1, g1, b1] = [x, 0, chroma]);
    } else if (hue1 >= 5 && hue1 <= 6) {
        ([r1, g1, b1] = [chroma, 0, x]);
    }

    let m = value - chroma;
    let [r,g,b] = [r1+m, g1+m, b1+m];

    // Change r,g,b values from [0,1] to [0,255]
    return [255*r,255*g,255*b];
};

const getPositionFromEvent = (event) => {
    let target = event.target;
    let offsetX = target.offsetLeft;
    let offsetY = target.offsetTop;
    let check = target.offsetParent;
    while(check){
        offsetX += check.offsetLeft;
        offsetY += check.offsetTop;
        check = check.offsetParent;
    }
    let result = {
        x: event.clientX - offsetX,
        y: event.clientY - offsetY
    };
    return result;
};

const getRGBFromImageData = (x, y, width, data) => {
    let index = (y * width + x) * 4;
    return [
        data[index], // r
        data[index + 1], // g
        data[index + 2], // b
        data[index + 3] // alpha
    ];
};




/***/ }),

/***/ "./js/objects/views/drawing/DrawingView.js":
/*!*************************************************!*\
  !*** ./js/objects/views/drawing/DrawingView.js ***!
  \*************************************************/
/*! exports provided: DrawingView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawingView", function() { return DrawingView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DrawingView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _PencilTool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PencilTool.js */ "./js/objects/views/drawing/PencilTool.js");
/* harmony import */ var _EraserTool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EraserTool.js */ "./js/objects/views/drawing/EraserTool.js");
/* harmony import */ var _ColorPickerTool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ColorPickerTool.js */ "./js/objects/views/drawing/ColorPickerTool.js");
/**
 * DrawingView
 * Experimental.
 * This is still a pure webcomponent and is not
 * linked at all to SimpleTalk yet.
 *
 */





const haloButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tool" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 10h3v-3l-3.5 -3.5a6 6 0 0 1 8 8l6 6a2 2 0 0 1 -3 3l-6-6a6 6 0 0 1 -8 -8l3.5 3.5" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: inline-block;
        position: relative;
        box-sizing: border-box;
    }
    #tool-buttons {
        position: absolute;
        left: calc(100% + 5px);
        top: 0px;
        display: flex;
        flex-direction: column;
    }
    :host(.show-border){
        border: 1px solid black;
    }
    :host(:not([mode="drawing"])) > #tool-buttons {
        display: none;
    }
</style>
<canvas></canvas >
<div id="tool-buttons">
<slot></slot>
</div>
`;

class DrawingView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["PartView"] {
    constructor(){
        super();

        // Setup shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        this.colorPickerTool = null;

        this.isCurrentlyDrawing = false;

        // Bind component methods
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.toggleMode = this.toggleMode.bind(this);
        this.afterDrawAction = this.afterDrawAction.bind(this);
        this.restoreImageFromModel = this.restoreImageFromModel.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.modeChanged = this.modeChanged.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('mode', this.modeChanged);
        this.onPropChange('image', () => {
            let imageBits = this.model.partProperties.getPropertyNamed(
                this.model,
                'image'
            );
            this.restoreImageFromModel(imageBits);
        });
        this.onPropChange('show-border', (val) => {
            if(val){
                this.classList.add('show-border');
            } else {
                this.classList.remove('show-border');
            }
        });
        this.onPropChange('width', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("width", cssStyle.width);
        });
        this.onPropChange('height', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("height", cssStyle.height);
        });
    }

    modeChanged(value){
        this.setAttribute('mode', value);
    }

    afterConnected(){
        this.canvas = this.shadow.querySelector('canvas');
        this.canvas.addEventListener('mouseup', this.onMouseUp);
        this.canvas.addEventListener('mousedown', this.onMouseDown);

        // Set and store the drawing context
        this.drawingContext = this.canvas.getContext('2d');

        // If I don't have the default tools, add
        // them as real dom children now
        let pencilChild = this.querySelector('pencil-tool');
        if(!pencilChild){
            let newPencil = document.createElement('pencil-tool');
            this.append(newPencil);
        }
        let eraserChild = this.querySelector('eraser-tool');
        if(!eraserChild){
            let newEraser = document.createElement('eraser-tool');
            this.append(newEraser);
        }

        let colorPickerChild = this.querySelector('color-picker-tool');
        if(!colorPickerChild){
            let newColorPicker = document.createElement('color-picker-tool');
            // TODO this is a total hack since drawing does not work well with styles at the moment
            this.append(newColorPicker);
            newColorPicker.colorWheel.shadowRoot.querySelector('div#options').style.display = "none";
            this.colorPickerTool = newColorPicker;
        }

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
        this.canvas.removeEventListener('mouseup', this.onMouseUp);
        this.canvas.removeEventListener('mousedown', this.onMouseDown);
    }

    afterModelSet(){
        // setup the canvas height and width
        // Note: what we want is the calculated CSS, not the ST part property value
        let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
        let canvas = this.shadow.querySelector('canvas');
        canvas.setAttribute("height", cssStyle.height);
        canvas.setAttribute("width", cssStyle.width);
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        if(currentImage){
            this.restoreImageFromModel(currentImage);
        }

        let initialShowBorder = this.model.partProperties.getPropertyNamed(
            this.model,
            'show-border'
        );
        if(initialShowBorder){
            this.classList.add('show-border');
        }
    }

    onMouseDown(event){
        if(event.shiftKey){
            return;
        } else if(!this.inDrawingMode) {
            // Send the mouseUp command message to self
            this.model.sendMessage({
                type: 'command',
                commandName: 'mouseUp',
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            }, this.model);
        }
        this.activeTool = this.querySelector('[role="tool"][active="true"]');
        if(!this.activeTool){
            return;
        }
        this.isCurrentlyDrawing = true;
        let canvas = this.shadow.querySelector('canvas');
        canvas.addEventListener('mousemove', this.onMouseMove);
        canvas.addEventListener('mouseleave', this.onMouseLeave);
        this.activeTool.start(event.offsetX, event.offsetY);
    }

    onMouseMove(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode){
            this.activeTool.onMove(
                event.offsetX,
                event.offsetY
            );
        } else if(this.model.partProperties.getPropertyNamed(this.model, "wants-move")){
            this.sendMessage({
                type: 'command',
                commandName: 'move',
                args: [event.movementX, event.movementY]
            }, this.model);
        }
    }

    onMouseUp(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode && this.isCurrentlyDrawing){
            this.activeTool.end(event.offsetX, event.offsetY);
            this.afterDrawAction();
        }
        this.isCurrentlyDrawing = false;
        let canvas = this.shadow.querySelector('canvas');
        canvas.removeEventListener('mousemove', this.onMouseMove);
        canvas.removeEventListener('mouseleave', this.onMouseLeave);
    }


    onMouseLeave(event){
        // If this is triggered, we left the area
        // while drawing. So call the activeTool's
        // end method
        this.activeTool.end(
            event.offsetX,
            event.offsetY
        );
        this.isCurrentlyDrawing = false;
        this.afterDrawAction();
        this.canvas.removeEventListener('mouseleave', this.onMouseLeave);
        this.canvas.removeEventListener('mousemove', this.onMouseMove);
    }

    onHaloResize(movementX, movementY){
        let canvas = this.shadowRoot.querySelector('canvas');
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        // canvas.width = canvas.width + movementX;
        // canvas.height = canvas.height + movementY;
        let newWidth = canvas.width + movementX;
        let newHeight = canvas.height + movementY;
        if(newWidth && newHeight){
            // this.style.width = `${newWidth}px`;
            // this.style.height = `${newHeight}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth,
                true
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight,
                true
            );
        }
        this.restoreImageFromModel(currentImage);
    }

    afterDrawAction(){
        // Encode canvas contents as base64 png
        // and set to model's image property
        let canvas = this.shadowRoot.querySelector('canvas');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'image',
            canvas.toDataURL()
        );
        //this.setAttribute("mode", "");
    }

    restoreImageFromModel(base64ImageData){
        // Clear and draw the image to restore to
        // the canvas
        if(base64ImageData){
            let canvas = this.shadowRoot.querySelector('canvas');
            let context = canvas.getContext('2d');
            let img = new Image();
            img.onload = function(){
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(img, 0, 0);
            };
            img.src = base64ImageData;

            // Set the border to hide
            this.model.partProperties.setPropertyNamed(
                this.model,
                'show-border',
                false
            );
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = "halo-drawing-toggle-mode";
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = haloButtonSVG;
        this.haloButton.style.marginRight = "6px";
        this.haloButton.setAttribute('slot', 'bottom-row');
        this.haloButton.setAttribute('title', 'Toggle drawing tools');
        this.haloButton.addEventListener('click', this.toggleMode);
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    toggleMode(){
        let currentMode = this.getAttribute('mode');
        let nextMode = 'viewing'; // By default, set to viewing
        let isEmpty = (!currentMode || currentMode == undefined || currentMode == "");
        if(currentMode == 'viewing' || isEmpty){
            nextMode = 'drawing';
        }
        this.model.partProperties.setPropertyNamed(
            this.model,
            'mode',
            nextMode
        );
    }

    get inDrawingMode(){
        if(!this.model){
            return false;
        }
        let mode = this.getAttribute('mode');
        if(mode == 'drawing'){
            return true;
        }
        return false;
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/EraserTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/EraserTool.js ***!
  \************************************************/
/*! exports provided: EraserTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EraserTool", function() { return EraserTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EraserTool; });
/**
 * EraserTool
 * -----------------------------------
 * I provide eraser-like functionality on
 * my parent element's shadow canvas.
 * I am specifically designed for use as a
 * child of DrawingView
 */
const eraserSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-eraser" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 19h-11l-4 -4a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9 9" />
  <line x1="18" y1="12.3" x2="11.7" y2="6" />
</svg>
`;

const eraserToolTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${eraserSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class EraserTool extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = eraserToolTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool is
        // connected to a parent element that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
                this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.cachedStrokeStyle = this.ctx.strokeStyle;
        this.ctx.strokeStyle = 'red';
        this.ctx.globalCompositeOperation = 'destination-out';
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.strokeStyle = this.cachedStrokeStyle;
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};
window.customElements.define('eraser-tool', EraserTool);




/***/ }),

/***/ "./js/objects/views/drawing/PencilTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/PencilTool.js ***!
  \************************************************/
/*! exports provided: PencilTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PencilTool", function() { return PencilTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PencilTool; });
/**
 * PencilTool
 * --------------------------
 * I provide pencil-like drawing capability
 * on the shadow canvas of my parent element.
 * I am explicitly designed for use with
 * DrawingView
 */
const pencilSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
  <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
</svg>
`;

const pencilTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${pencilSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class PencilTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = pencilTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context
        // is null. This will be set
        // if and when this tool is
        // connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
            this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};

window.customElements.define('pencil-tool', PencilTool);




/***/ }),

/***/ "./js/objects/views/editors/Editor.js":
/*!********************************************!*\
  !*** ./js/objects/views/editors/Editor.js ***!
  \********************************************/
/*! exports provided: Editor, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Editor; });
/* harmony import */ var _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorTab.js */ "./js/objects/views/editors/EditorTab.js");
/* harmony import */ var _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditorPropList.js */ "./js/objects/views/editors/EditorPropList.js");
/* harmony import */ var _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditorMessenger.js */ "./js/objects/views/editors/EditorMessenger.js");
/* harmony import */ var _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditorCustomList.js */ "./js/objects/views/editors/EditorCustomList.js");
/* harmony import */ var _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditorSubpartsPane.js */ "./js/objects/views/editors/EditorSubpartsPane.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");






// PREAMBLE

// Add editor tab element
window.customElements.define('editor-tab', _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
window.customElements.define('editor-props-list', _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
window.customElements.define('editor-custom-list', _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('editor-messenger', _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('editor-subparts', _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

const closeButton = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
</svg>
`;

const scriptIcon = `
<svg id='script' xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-file-code" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M14 3v4a1 1 0 0 0 1 1h4" />
    <path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" />
    <path d="M10 13l-1 2l1 2" />
    <path d="M14 13l1 2l-1 2" />
</svg>`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        transform: translateX(-105%);
        transition: transform 150ms linear;
        width: 400px;
        height: 100%;
        background-color: white;
        padding: 8px;
        border-right: 1px solid rgba(0, 0, 0, 0.5);
        box-shadow: 0px 1px 10px 2px rgba(0, 0, 0, 0.3);
    }
    
    :host(.open){
        transform: translateX(0%);
        transition: transform 150ms linear;
        z-index: 100;
    }

    :host(::after) {
        content: " ";
        height: 100%;
        width: 5px;
        background-color: black;
        display: block;
        position: absolute;
        top: 0;
        right: -10;
        box-shadow: 0px 0px 3px 10px rgba(100, 100, 100, 0.6);
    }

    ::slotted(editor-props-list:not(.show-pane)),
    ::slotted(editor-messenger:not(.show-pane)),
    ::slotted(editor-custom-list:not(.show-pane)),
    ::slotted(editor-subparts:not(.show-pane)){
        display: none;
    }

    #tab-area {
        display: inline-flex;
        align-items: center;
        justify-content: space-around;
        width: 100%;
    }
    
    #pane-area {
        display: block;
        flex: 1;
        margin-top: 20px;
        overflow: hidden;
    }

    #header-area {
        display: flex;
        font-family: 'Helvetica', sans-serif;
        margin-bottom: 20px;
    }

    .header-side {
        flex: 1;
        margin-top: 20px;
    }

    #display-area {
        display: flex;
        align-items: center;
        margin-bottom: 30px;
    }

    #header-area h3 {
        display: inline-block;
        margin: 0;
        margin-right: 8px;
        margin-left: 5px;
        font-size: 1.7rem;
    }

    #header-left > input {
        display: inline-block;
        padding: 4px;
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.8);
        font-size: 1.1rem;
    }

    #header-right > button {
        width: 100%;
        background-color: transparent;
        border: 1px solid transparent;
        outline: none;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        font-size: 0.85em;
    }

    #header-right > button:hover {
        cursor: pointer;
        border: 1px solid rgba(150, 150, 150, 0.3);
    }

    #header-right > button:active {
        border: 1px solid rgba(150, 150, 150, 0.8);
        background-color: rgba(220, 220, 220);
    }

    #header-right > button > svg {
        height: 1.3em;
        width: auto;
        margin-right: 8px;
    }

    #header-left {
        max-width: 80%;
    }

    #header-left span {
        font-family: monospace;
        font-size: 1.1rem;
        color: rgba(0, 0, 0, 0.5);
        text-overflow: ellipsis;
        overflow: hidden;
    }

    #icon-display-area {
        width: 1.7rem;
        height: 1.7rem;
        margin-bottom: 5px;
    }
    #icon-display-area > svg {
        width: 100%;
        height: 100%;
    }

    #close-button {
        display: block;
        position: absolute;
        top: 5;
        right: 5;
    }
    #close-button:hover {
        cursor: pointer;
    }
</style>
<div id="close-button">${closeButton}</div>
<div id="header-area">
    <div id="header-left" class="header-side">
        <div id="display-area">
            <div id="icon-display-area"></div>
            <h3></h3><span></span>
        </div>
        <input type="text" id="part-name-input"/>
    </div>
    <div id="header-right" class="header-side">
        <button id="edit-script-button">
            ${scriptIcon}
            <span>Edit Script</span>
        </button>
    </div>
</div>
<div id="tab-area">
    <editor-tab active="true" name="properties">Properties</editor-tab>
    <editor-tab name="custom">Custom</editor-tab>
    <editor-tab name="messenger">Messenger</editor-tab>
    <editor-tab name="subparts">Subparts</editor-tab>
</div>
<div id="pane-area">
    <slot></slot>
</div>
`;

class Editor extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.render = this.render.bind(this);
        this.centerOnElement = this.centerOnElement.bind(this);
        this.undoCenterOnElement = this.undoCenterOnElement.bind(this);
        this.updateHeader = this.updateHeader.bind(this);
        this.checkForNavigation = this.checkForNavigation.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.onTabActivated = this.onTabActivated.bind(this);
        this.onNameInputChange = this.onNameInputChange.bind(this);
        this.onEditScriptClick = this.onEditScriptClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this._shadowRoot.addEventListener('tab-activated', this.onTabActivated);
            this._shadowRoot.getElementById('close-button').addEventListener(
                'click',
                this.close
            );

            // Events
            let nameInput = this._shadowRoot.getElementById('part-name-input');
            nameInput.addEventListener('change', this.onNameInputChange);

            let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
            editScriptButton.addEventListener('click', this.onEditScriptClick);
        }
    }

    disconnectedCallback(){
        this._shadowRoot.removeEventListener('tab-activated', this.onTabActivated);
        this._shadowRoot.getElementById('close-button').removeEventListener(
            'click',
            this.close
        );
        
        // Events
        let nameInput = this._shadowRoot.getElementById('part-name-input');
        nameInput.removeEventListener('change', this.onNameInputChange);

        let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
        editScriptButton.removeEventListener('click', this.onEditScriptClick);
    }

    toggle(){
        if(this.isOpen){
            this.close();
        } else {
            this.open();
        }
    }

    open(){
        this.classList.add('open');
        this.centerOnElement();
    }

    close(){
        this.classList.remove('open');
        this.undoCenterOnElement();
    }

    render(aModel){
        if(this.model){
            this.model.removePropertySubscriber(this);
        }
        this.model = aModel;
        this.model.addPropertySubscriber(this);

        // If the incoming model is a Card or
        // Stack that is not the current one,
        // we navigate to it
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.checkForNavigation();
        }

        // Close any open Halos.
        // If the new model wants a Halo,
        // open it on the View for that Model.
        Array.from(document.querySelectorAll(`.editing`)).forEach(el => {
            el.closeHalo();
        });
        let targetView = document.querySelector(`[part-id="${this.model.id}"]`);
        if(targetView && targetView.wantsHalo){
            targetView.openHalo();
        }
        
        this.updateHeader();

        // Clear slotted inner DOM
        this.innerHTML = "";

        // Add panes
        let propsPane = document.createElement('editor-props-list');
        propsPane.setAttribute('tab-name', 'properties');
        this.appendChild(propsPane);
        propsPane.render(this.model);

        let messengerPane = document.createElement('editor-messenger');
        messengerPane.setAttribute('tab-name', 'messenger');
        this.appendChild(messengerPane);
        messengerPane.render(this.model);

        let customPane = document.createElement('editor-custom-list');
        customPane.setAttribute('tab-name', 'custom');
        this.appendChild(customPane);
        customPane.render(this.model);

        let subpartsPane = document.createElement('editor-subparts');
        subpartsPane.setAttribute('tab-name', 'subparts');
        this.appendChild(subpartsPane);
        subpartsPane.render(this.model);

        // Find the active tab and show its corresponding pane
        let activeTab = this._shadowRoot.querySelector(`editor-tab[active="true"]`);
        if(activeTab){
            let activeName = activeTab.getAttribute('name');
            Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
                let name = pane.getAttribute('tab-name');
                if(name == activeName){
                    pane.classList.add('show-pane');
                } else {
                    pane.classList.remove('show-pane');
                }
            });
        }

        // If this pane is already open, then center
        // on the primary view element for the model
        if(this.isOpen){
            this.centerOnElement();
        }
    }

    centerOnElement(){
        // Use CSS transforms of the whole World to center on
        // the primary view element of the Part being edited,
        // if set. If not set, do nothing.
        if(this.model){
            // If we are editing a Card, Stack, or World, then
            // we uncenter and return
            let isCardStackOrWorld = ['card', 'stack', 'world'].includes(this.model.type);
            if(isCardStackOrWorld){
                return this.undoCenterOnElement();
            }
            
            let partView = window.System.findViewById(this.model.id);
            let worldView = window.System.findViewById('world');
            let current = worldView.getAttribute('centered-on');
            if(current == this.model.id.toString()){
                return;
            }

            let menuRect = this.getBoundingClientRect();
            let partRect = partView.getBoundingClientRect();

            // Get the actual viewable width, plus the editor menu
            let viewWidth = window.innerWidth + menuRect.width;
            let viewHeight = window.innerWidth - menuRect.height;

            // Calculate X translation
            let targetX = (viewWidth - partRect.width) / 2;
            let newX;
            if(targetX < partRect.left){
                newX = (partRect.left - targetX) * -1;
            } else {
                newX = targetX - partRect.left;
            }

            // Calculate Y translation
            let targetY = (viewHeight - partRect.height) / 2;
            let newY;
            if(targetY < partRect.top){
                newY = (partRect.top - targetY) * -1;
            } else {
                newY = targetY - partRect.top;
            }

            worldView.setAttribute('centered-on', this.model.id);
            
            // Set transform and transition
            worldView.style.transition = "transform 0.3s ease-out";
            worldView.style.transform = `translate(${newX}px, ${newY}px)`;
        }
    }

    undoCenterOnElement(){
        let worldView = window.System.findViewById('world');
        worldView.removeAttribute('centered-on');
        worldView.style.removeProperty('transform');
    }

    updateHeader(){
        let nameInput = this._shadowRoot.querySelector('#header-left > input');
        let typeDisplay = this._shadowRoot.querySelector('#display-area > h3');
        let idDisplay = this._shadowRoot.querySelector('#display-area > span');
        let iconDisplay = this._shadowRoot.getElementById('icon-display-area');

        let partName = this.model.partProperties.getPropertyNamed(
            this.model,
            'name'
        );

        if(partName && partName !== ""){
            nameInput.value = partName;
        } else {
            nameInput.value = "(Unnamed)";
        }

        typeDisplay.textContent = this.model.type.charAt(0).toUpperCase() + this.model.type.slice(1);
        idDisplay.textContent = `id=${this.model.id}`;
        idDisplay.title = this.model.id;

        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"]).includes(this.model.type)){
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"][this.model.type];
        } else {
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"].generic;
        }
    }

    checkForNavigation(){
        // If the model is a Card or Stack that
        // is not the current (ie, not being displayed
        // in the main window), then we should navigate
        // to it
        let currentStack = window.System.world.currentStack;
        let currentCard = currentStack.currentCard;
        if(this.model.type == 'card' && this.model.id != currentCard.id){
            currentStack.goToCardById(this.model.id);
        } else if(this.model.type == 'stack' && this.model.id != currentStack.id){
            window.System.world.goToStackById(this.model.id);
        }
        
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            // Find any nested editor-prop-item elements
            // and re-render, so they display the correct
            // values in the editor
            let queryString = `editor-prop-item[name="${aMessage.propertyName}"][owner-id="${aMessage.partId}"]`;
            Array.from(this.querySelectorAll(queryString)).forEach(el => {
                if(el.property.value !== aMessage.value){
                    el.render();
                }
            });
            break;
        }
    }

    onTabActivated(event){
        Array.from(this._shadowRoot.querySelectorAll('editor-tab'))
            .filter(tabEl => {
                return tabEl !== event.target;
            }).forEach(tabEl => {
                tabEl.removeAttribute('active');
            });

        // Get the name of the activated tab
        let targetName = event.target.getAttribute('name');
        Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
            let name = pane.getAttribute('tab-name');
            if(name == targetName){
                pane.classList.add('show-pane');
            } else {
                pane.classList.remove('show-pane');
            }
        });
    }

    onNameInputChange(event){
        if(this.model){
            let newName = event.target.value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'name',
                newName
            );
        }
    }

    onEditScriptClick(event){
        if(this.model){
            this.model.sendMessage({
                type: 'command',
                commandName: 'openScriptEditor',
                args: [
                    this.model.id
                ]
            }, this.model);
            this.close();
        }
    }

    get isOpen(){
        return this.classList.contains('open');
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorCustomList.js":
/*!******************************************************!*\
  !*** ./js/objects/views/editors/EditorCustomList.js ***!
  \******************************************************/
/*! exports provided: EditorCustomList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorCustomList", function() { return EditorCustomList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorCustomList; });


// PREAMBLE

const caretDownIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(180 12 12)" />
</svg>
`;

const caretRightIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(90 12 12)" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
    
    #new-prop-area {
        display: flex;
        flex-direction: column;
        width: 100%;
    }

    #new-prop-area.open > #new-prop-form {
        display:flex;
    }

    #new-prop-form {
        display: none;
        flex-direction: column;
        width: 100%;
    }

    .row {
        display: flex;
        flex-direction: row;
        width: 100%;
        align-items: center;
        margin-bottom: 1em;
    }

    h3 {
        padding: 0px;
        margin-bottom: 1em;
    }

    #new-prop-form > .row > * {
        margin-right: 16px;
        padding-left: 8px;
        padding-right: 8px;
    }
    #new-prop-form input {
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.7);
        font-family: monospace;
        padding: 6px;
    }

    #new-prop-name:invalid {
        border-bottom: 1px solid red;
    }
    
    select {
        font-size: 1em;
    }
    #add-prop-dropdown-control {
        align-items: center;
        user-select: none;
    }

    #add-prop-dropdown-control:hover,
    #add-prop-dropdown-control label {
        cursor: pointer;
    }

    #caret-button {
        position: relative;
        width: 1.5em;
        height: 1.5em;
        transform: rotate(0deg);
        transition: transform 0.1s linear;
    }

    #caret-button > svg {
        width: 100%;
        height: 100%;
    }
    #new-prop-area.open #caret-button {
        transform: rotate(90deg);
        transition: transform 0.1s linear;
    }

</style>
<div id="new-prop-area">
    <div class="row" id="add-prop-dropdown-control">
        <h3><label for="caret-button">Add New Property</label></h3>
        <div id="caret-button">${caretRightIcon}</div>
    </div>
    <div id="new-prop-form">
        <div class="row">
            <label for="new-prop-name">Property Name </label>
            <input type="text" id="new-prop-name" placeholder="property-name" pattern="[a-z\\-]{3,64}"/>
        </div>
        <div class="row">
            <label for="default-val-select">Default value type</label>
            <select id="default-val-select">
                <option value="" selected>None</option>
                <option value="string">Text</option>
                <option value="number">Number</option>
                <option value="boolean">True or False</option>
            </select>
        </div>
        <div class="row">
            <label for="default-value">Default value </label>
            <input type="text" id="default-value" placeholder="Default value" disabled/>
        </div>
        <div class="row" id="submit-control">
            <button id="submit-prop">Create</button>
        </div>
    </div>
</div>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

class EditorCustomList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.resetForm = this.resetForm.bind(this);
        this.onDefaultNewTypeChange = this.onDefaultNewTypeChange.bind(this);
        this.onCaretClick = this.onCaretClick.bind(this);
        this.onCreateSubmit = this.onCreateSubmit.bind(this);
        this.onFilterInput = this.onFilterInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.newPropTypeSelect = this._shadowRoot.getElementById('default-val-select');
            this.newPropNameInput = this._shadowRoot.getElementById('new-prop-name');
            this.newPropDefaultValue = this._shadowRoot.getElementById('default-value');
            this.addPropControl = this._shadowRoot.getElementById('add-prop-dropdown-control');
            this.newPropForm = this._shadowRoot.getElementById('new-prop-form');
            this.createButton = this._shadowRoot.getElementById('submit-prop');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.filterInput = this._shadowRoot.getElementById('filter-input');
            
            // Add listeners
            this.addPropControl.addEventListener('click', this.onCaretClick);
            this.createButton.addEventListener('click', this.onCreateSubmit);
            this.filterInput.addEventListener('input', this.onFilterInput);
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any main dom children
        this.innerHTML = "";

        // Create a sorted copy of the property
        // objects
        let customProps = this.model.partProperties.getPropertyNamed(
            this.model,
            'custom-properties'
        );

        // Create a sorted list of the custom properties
        // available
        this.propList = Object.values(customProps)
            .sort((first, second) => {
                return first.name.localeCompare(second.name);
            });

        // Render the property items and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });

        // Set up event listeners
        this.newPropTypeSelect.removeEventListener('change', this.onDefaultNewTypeChange);
        this.newPropTypeSelect.addEventListener('change', this.onDefaultNewTypeChange);
    }

    onDefaultNewTypeChange(event){
        let option = event.target.selectedOptions[0];
        switch(option.value){
        case 'string':
            this.newPropDefaultValue.setAttribute('type', 'text');
            this.newPropDefaultValue.setAttribute('value', "");
            break;
        case 'number':
            this.newPropDefaultValue.setAttribute('type', 'number');
            this.newPropDefaultValue.setAttribute('value', 0);
            break;
        case 'boolean':
            this.newPropDefaultValue.setAttribute('type', 'checkbox');
            break;
        default:
            this.newPropDefaultValue.setAttribute('type', 'text');
        }

        if(option.value == ""){
            this.newPropDefaultValue.setAttribute('disabled', true);
        } else {
            this.newPropDefaultValue.removeAttribute('disabled');
        }
    }

    onCaretClick(event){
        let newPropArea = this._shadowRoot.getElementById('new-prop-area');
        newPropArea.classList.toggle('open');
    }

    onCreateSubmit(event){
        if(this.model){
            let propName = this.newPropNameInput.value;
            let defaultValue = this.newPropDefaultValue.value;
            if(this.newPropDefaultValue.type == 'checkbox'){
                defaultValue = this.newPropDefaultValue.checked;
            } else if(this.newPropDefaultValue.type == 'number'){
                defaultValue = parseFloat(this.newPropDefaultValue.value);
            }

            // Send the property create message
            this.model.sendMessage({
                type: 'command',
                commandName: 'newProperty',
                args: [
                    propName,
                    this.model.id
                ]
            }, this.model);

            // Set the created prop to the default
            // value
            this.model.partProperties.setPropertyNamed(
                this.model,
                propName,
                defaultValue
            );

            // Re-render this pane
            this.resetForm();
            this.render(this.model);
        }
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onFilterInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInput.value = "";
        this.filterBy("");
    }

    resetForm(){
        this.newPropNameInput.value = null;
        this.newPropDefaultValue.value = null;
        if(this.newPropDefaultValue.type == 'checked'){
            this.newPropDefaultValue.checked = false;
        }
        this.newPropDefaultValue.type = 'text';
        this.newPropDefaultValue.setAttribute('disabled', true);
        this.newPropTypeSelect.selectedIndex = 0;
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorLocationInfo.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorLocationInfo.js ***!
  \********************************************************/
/*! exports provided: EditorLocationInfo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorLocationInfo", function() { return EditorLocationInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorLocationInfo; });
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");



// PREAMBLE
const arrowLeftIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrow-narrow-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12" />
  <line x1="5" y1="12" x2="9" y2="16" />
  <line x1="5" y1="12" x2="9" y2="8" />
</svg>
`;

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host(.hidden){
        display: none;
    }
    .button-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .button-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .button-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .button-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
</style>
<p class="part-info">
    My <button id="owner-link" class="button-link" title=""><span></span>${arrowLeftIcon}</button> is named <span class="part-name"></span> and is located at <button id="location-link" class="button-link" title="Copy location"><span></span>${clipboardIcon}</button> <button id="id-link" class="button-link" title="Copy id"><span>Copy id</span>${clipboardIcon}</button>
</p>
`;

class EditorLocationInfo extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Accepted values for the kind attribute
        this.allowedKinds = ['stack', 'card', 'owner'];

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.handleStackKind = this.handleStackKind.bind(this);
        this.handleCardKind = this.handleCardKind.bind(this);
        this.updateInfo = this.updateInfo.bind(this);
        this.getAncestorOfTypeFor = this.getAncestorOfTypeFor.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
        this.onLinkClick = this.onLinkClick.bind(this);
        this.onMouseEnter = this.onMouseEnter.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
    }

    connectedCallback(){
        // Events
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        ownerLinkButton.addEventListener('click', this.onLinkClick);
        locationLinkButton.addEventListener('click', this.onLocationClick);
        idLinkButton.addEventListener('click', this.onLocationClick);
        locationLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.addEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.addEventListener('mouseleave', this.onMouseLeave);
    }

    disconnectedCallback(){
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        locationLinkButton.removeEventListener('click', this.onLocationClick);
        idLinkButton.removeEventListener('click', this.onLocationClick);
        ownerLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
    }

    render(aModel){
        this.model = aModel;
        let kind = this.getAttribute('kind');
        if(!kind || !this.allowedKinds.includes(kind)){
            this.classList.add('hidden');
            return;
        }
        if(this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }

        this.classList.remove('hidden');

        // Update element references
        this.ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        this.ownerLinkTypeSpan = this.ownerLinkButton.querySelector('span');
        this.locationLinkButton = this._shadowRoot.getElementById('location-link');
        this.locationLinkSpan = this.locationLinkButton.querySelector('span');
        this.idLinkButton = this._shadowRoot.getElementById('id-link');
        this.idLinkSpan = this.idLinkButton.querySelector('span');
        this.nameSpan = this._shadowRoot.querySelector('p .part-name');

        if(kind == 'stack'){
            this.handleStackKind();
        } else if(kind =='card'){
            this.handleCardKind();
        } else {
            this.updateInfo();
        }
    }

    updateInfo(){
        let kind = this.getAttribute('kind');
        let ancestor = this.model._owner;
        if(kind == 'stack' || kind == 'card'){
            ancestor = this.getAncestorOfTypeFor(this.model, kind);
        }

        // If we cannot find an ancestor of the given
        // kind, then we hide this field
        if(!ancestor){
            this.classList.add('hidden');
            return;
        }

        // Update name span
        let ancestorName = ancestor.partProperties.getPropertyNamed(
            ancestor,
            'name'
        );
        if(!ancestorName){
            ancestorName = '(unnamed)';
        } else {
            ancestorName = `"${ancestorName}"`;
        }
        this.nameSpan.textContent = ancestorName;

        // Update kind span
        let kindLabel = kind[0].toUpperCase() + kind.slice(1);
        this.ownerLinkTypeSpan.textContent = kindLabel;

        // Update location link span
        this.locationLinkSpan.textContent = this.getLocationStringFor(ancestor);

        // Update button titles
        let editTitle = `Edit owning ${kindLabel}`;
        if(kind == 'owner'){
            editTitle = 'Edit Owner';
        }
        this.ownerLinkButton.setAttribute(
            'title',
            editTitle
        );

        // Add the ref-id attribute
        this.setAttribute('ref-id', ancestor.id);
    }

    handleStackKind(){
        if(this.model.type == 'stack' || this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    handleCardKind(){
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    getAncestorOfTypeFor(aPart, aType){
        let result;
        let currentOwner = aPart._owner;
        while(currentOwner){
            if(currentOwner.type == aType){
                result = currentOwner;
                break;
            }
            currentOwner = currentOwner._owner;
        }
        return result;
    }

    onLinkClick(event){
        let id = this.getAttribute('ref-id');
        if(id && this.model){
            // Re-render the editor on the Part
            // referenced by the found id
            let target = window.System.partsById[id];
            window.System.editor.render(target);
        }
    }

    onMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    getLocationViews(event){
        let targetId;
        let span = event.currentTarget.querySelector('span');
        if(span.parentElement.id == 'id-link'){
            targetId = this.getAttribute('ref-id');
        } else {
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.System.partsById['world'], window.System)
            );
            let m = window.System.grammar.match(span.textContent, "ObjectSpecifier");
            try{
                targetId = semantics(m).interpret();
            } catch(e){
                console.log(`cannot locate ${span.textContent}`);
            }
        }
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorMessenger.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/editors/EditorMessenger.js ***!
  \*****************************************************/
/*! exports provided: EditorMessenger, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorMessenger", function() { return EditorMessenger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorMessenger; });


// PREAMBLE
const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }
   
    textarea {
        resize: none;
        flex: 0.25;
    }
</style>
<h3>Send this <span></span> a Message:</h3>
<textarea placeholder="Type your Simpletalk message here..."></textarea>
<button>Send</button>
`;

class EditorMessenger extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onMessageFieldInput = this.onMessageFieldInput.bind(this);
        this.sendMessageFromText = this.sendMessageFromText.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.sendButton = this._shadowRoot.querySelector('button');
            this.sendButton.addEventListener('click', this.sendMessageFromText);
        
            this.messageField = this._shadowRoot.querySelector('textarea');
            this.messageField.addEventListener('input', this.onMessageFieldInput);
        }
    }

    disconnectedCallback(){
        this.messageField.removeEventListener('input', this.onMessageFieldInput);
        this.sendButton.removeEventListener('click', this.sendMessageFromText);
    }

    render(aModel){
        this.model = aModel;
        
        let partTypeLabel = this._shadowRoot.querySelector('h3 > span');
        partTypeLabel.textContent = this.model.type;
    }

    onMessageFieldInput(event){

    }

    sendMessageFromText(){
        let text = this.messageField.value;
        let script = `on doIt\n\t${text}\nend doIt`;
        this.model.sendMessage({
            type: 'compile',
            codeString: script,
            targetId: this.model.id
        }, this.model);
        this.model.sendMessage({
            type: 'command',
            commandName: 'doIt',
            args: [],
            shouldIgnore: true
        }, this.model);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropItem.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropItem.js ***!
  \****************************************************/
/*! exports provided: EditorPropItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropItem", function() { return EditorPropItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropItem; });
// PREAMBLE

const checkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>
`;

const cancelIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#ff2825" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M10 10l4 4m0 -4l-4 4" />
</svg>
`;

const templateString = `
<style>
    li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px;
        padding-left: 8px;
        padding-right: 8px;
        margin-top: 6px;
    }
   
    li > label {
        flex: 1;
    }

    :host {
        width: 100%;
    }

    :host(.item-hidden) {
        display:none;
    }

    button {
        outline: none;
        border: 1px solid transparent;
        background-color: transparent;
        opacity: 1.0;
        transition: opacity 0.1s linear;
    }

    button:disabled {
        opacity: 0.05;
        transition: opacity: 0.1s linear;
    }

    button:hover {
        cursor: pointer;
    }

    button.button-hidden {
        display: none;
    }

    label {
        font-family: monospace;
    }

    input {
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.5);
        outline: none;
    }
    
    input:focus {
        border: 1px solid rgba(100, 100, 100, 0.8);
    }
</style>
<li>
    <label for="prop-value"></label>
    <input id="prop-value" name="prop-value"/>
    <button id="accept" disabled>${checkIcon}</button>
    <button id="cancel" disabled>${cancelIcon}</button>
</li>
`;

class EditorPropItem extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // By default, there is no property
        this.property = null;
        this.owner = null;

        // Bound methods
        this.render = this.render.bind(this);
        this.onInputChange = this.onInputChange.bind(this);
        this.onInputInput = this.onInputInput.bind(this);
        this.onAcceptClick = this.onAcceptClick.bind(this);
        this.onCancelClick = this.onCancelClick.bind(this);
        this.onEnterKey = this.onEnterKey.bind(this);
        this.setupNumericInput = this.setupNumericInput.bind(this);
        this.enableButtons = this.enableButtons.bind(this);
        this.disableButtons = this.disableButtons.bind(this);
    }

    setProperty(aProperty, anOwner){
        // Remove any existing event handlers
        // TODO
        this.property = aProperty;
        this.owner = anOwner;

        // Update the element attributes
        this.setAttribute('name', this.property.name);
        this.setAttribute('owner-id', this.owner.id);

        // Add new event handlers

        // Render
        this.render();
        
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('keypress', this.onEnterKey);
        }
    }

    disconnectedCallback(){
        this.removeEventListener('keypress', this.onEnterKey);
    }

    render(){
        this.labelElement = this._shadowRoot.querySelector('label');
        this.inputElement = this._shadowRoot.querySelector('input');
        this.acceptButton = this._shadowRoot.getElementById('accept');
        this.cancelButton = this._shadowRoot.getElementById('cancel');

        // Remove any hide classes
        this.acceptButton.classList.remove('button-hidden');
        this.cancelButton.classList.remove('button-hidden');
        
        // Remove any bound events
        this.inputElement.removeEventListener('input', this.onInputInput);
        this.inputElement.removeEventListener('change', this.onInputChange);
        this.acceptButton.removeEventListener('click', this.onAcceptClick);
        this.cancelButton.removeEventListener('click', this.onCancelClick);

        // Add new events
        this.inputElement.addEventListener('input', this.onInputInput);
        this.inputElement.addEventListener('change', this.onInputChange);
        this.acceptButton.addEventListener('click', this.onAcceptClick);
        this.cancelButton.addEventListener('click', this.onCancelClick);
        
        this.labelElement.textContent = `${this.property.name}:`;
        let currentVal = this.property.getValue(this.owner);
        if(currentVal == null || currentVal == undefined){
            // Do something different here
        } else if(typeof(currentVal) == 'number'){
            this.setupNumericInput();
        } else if(typeof(currentVal) == 'boolean'){
            this.inputElement.setAttribute('type', 'checkbox');
            this.inputElement.checked = currentVal;
            this.acceptButton.classList.add('button-hidden');
            this.cancelButton.classList.add('button-hidden');
        } else {
            this.inputElement.setAttribute('type', 'text');
        }

        this.inputElement.setAttribute('placeholder', currentVal);
        this.inputElement.value = currentVal;
    }

    setupNumericInput(){
        if(this.property.name.endsWith('-transparency')){
            this.inputElement.setAttribute('type', 'range');
            this.inputElement.setAttribute('step', '0.05');
            this.inputElement.setAttribute('min', '0.0');
            this.inputElement.setAttribute('max', '1.0');
        } else {
            this.inputElement.setAttribute('type', 'number');
        }
    }

    onInputChange(event){
        if(event.target.type == "checkbox"){
            this.owner.partProperties.setPropertyNamed(
                this.owner,
                this.property.name,
                event.target.checked
            );
        }
    }

    onInputInput(event){
        let inputType = event.target.getAttribute('type');
        if(inputType == 'range'){
            return this.onAcceptClick();
        }
        if(event.target.value !== this.property.getValue(this.owner)){
            this.enableButtons();
        } else {
            this.disableButtons();
        }
    }

    onEnterKey(event){
        if(event.key == 'Enter'){
            this.onAcceptClick();
        }
    }

    enableButtons(){
        this.acceptButton.removeAttribute('disabled');
        this.cancelButton.removeAttribute('disabled');
    }

    disableButtons(){
        this.acceptButton.setAttribute('disabled', true);
        this.cancelButton.setAttribute('disabled', true);
    }

    onAcceptClick(event){
        let value = this.inputElement.value;
        if(this.inputElement.type == 'number'){
            value = parseFloat(value);
            if(isNaN(value)){
                // if we can't parse the value just let it go through
                // as it might be a prop style keyword such as "fill"
                // TODO: we might want to limit this to a set of prop keywords
                value = this.inputElement.value;
            }
        } else if(this.inputElement.type == 'range'){
            value = parseFloat(value);
        } else if(this.inputElement.type == 'checkbox'){
            value = this.inputElement.checked;
        }
        this.owner.partProperties.setPropertyNamed(
            this.owner,
            this.property.name,
            value
        );
        this.disableButtons();
    }

    onCancelClick(event){
        this.inputElement.value = this.owner.partProperties.getPropertyNamed(
            this.owner,
            this.property.name
        );
        this.disableButtons();
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropList.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropList.js ***!
  \****************************************************/
/*! exports provided: EditorPropList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropList", function() { return EditorPropList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropList; });
/* harmony import */ var _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorPropItem.js */ "./js/objects/views/editors/EditorPropItem.js");


// PREAMBLE
window.customElements.define('editor-prop-item', _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
</style>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

const specialProps = [
    'cssStyle',
    'cssTextStyle',
    'id',
    'name',
    'target',
    'events',
    'current',
    'script',
    'custom-properties'
];

class EditorPropList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onInput = this.onInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.filterInputElement = this._shadowRoot.getElementById('filter-input');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any existing main DOM children
        this.innerHTML = "";
        let inputEl = this._shadowRoot.getElementById('filter-input');
        inputEl.removeEventListener('input', this.onInput);
        inputEl.addEventListener('input', this.onInput);

        // Create a sorted copy of the property objects
        this.propList = this.model.partProperties.all.slice().filter(prop => {
                return !specialProps.includes(prop.name);
            });
        this.propList
            .sort((first, second) => {
            return first.name.localeCompare(second.name);
        });

        // Render the list item elements and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInputElement.value = "";
        this.filterBy("");
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorSubpartsPane.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorSubpartsPane.js ***!
  \********************************************************/
/*! exports provided: EditorSubpartsPane, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorSubpartsPane", function() { return EditorSubpartsPane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorSubpartsPane; });
/* harmony import */ var _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorLocationInfo.js */ "./js/objects/views/editors/EditorLocationInfo.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");
// PREAMBLE




window.customElements.define('editor-location-info', _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    :host() > li {
        background-color: red;
    }

    .id-link,
    .location-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .id-link:hover,
    .location-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .id-link > svg,
    .location-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .id-link:hover > svg,
    .location-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    section {
        display: flex;
        flex-direction: column;
        margin: 6px;
    }

    #button-area {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;'
    }

    #subparts-list-wrapper {
        flex: 1;
        overflow-y: hidden;
    }

    .hidden {
        display: none;
    }

    #subparts-area {
        flex: 1;
        list-style: none;
        font-family: 'Helvetica', sans-serif;
        padding: 0;
        margin: 0;
        margin-left: 32px;
        overflow-y: auto;
    }
</style>
<section id="button-area">
    <slot name="button"></slot>
</section>
<section id="location-area">
    <h3>Part Location and Owners</h3>
    <p class="part-info">
        I am located at <button class="location-link"><span></span>${clipboardIcon}</button>
        and my id is <button class="id-link"><span></span>${clipboardIcon}</button>
    </p>
    <slot name="ancestor-info"></slot>
</section>
<section id="subparts-list-wrapper">
    <h3>Subparts</h3>
    <ol id="subparts-area">
        <slot></slot>
    </ol>
</section>
`;

class EditorSubpartsPane extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.onAddSubpart = this.onAddSubpart.bind(this);
        this.onSubpartItemClick = this.onSubpartItemClick.bind(this);
        this.onSubpartItemMouseEnter = this.onSubpartItemMouseEnter.bind(this);
        this.onSubpartItemMouseLeave = this.onSubpartItemMouseLeave.bind(this);
        this.createAddPartButton = this.createAddPartButton.bind(this);
        this.createSubpartComponent = this.createSubpartComponent.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.headerEl = this._shadowRoot.getElementById('location-area');
            this.myLocationArea = this.headerEl.querySelector('p');
            this.myLocationButton = this.myLocationArea.querySelector('.location-link');
            this.myIdButton = this.myLocationArea.querySelector('.id-link');

            // Add event listener to buttons
            this.myLocationButton.addEventListener('click', this.onLocationLinkClick);
            this.myIdButton.addEventListener('click', this.onLocationLinkClick);
        }
    }

    disconnectedCallback(){
        this.myLocationButton.removeEventListener('click', this.onLocationLinkClick);
        this.myIdButton.removeEventListener('click', this.onLocationLinkClick);
    }

    render(aModel){
        this.model = aModel;
        this.headerEl = this._shadowRoot.getElementById('location-area');

        // Clear any DOM children
        this.innerHTML = "";


        // Create location link elements
        // and also the self-location element
        let myLocationText = this.getLocationStringFor(this.model);
        this.myLocationButton.querySelector('span').textContent = myLocationText;
        this.myIdButton.querySelector('span').textContent = this.model.id.toString();
        if(this.model.type == 'world'){
            this.headerEl.classList.add('hidden');
        } else {
            this.headerEl.classList.remove('hidden');

            // Create the info elements
            ['stack', 'card', 'owner'].forEach(kind => {
                let infoEl = document.createElement('editor-location-info');
                infoEl.setAttribute('slot', 'ancestor-info');
                infoEl.setAttribute('kind', kind);
                infoEl.render(this.model);
                this.appendChild(infoEl);
            });
        }

        // Create the "add subpart" buttons for parts that are accepted by the
        // current Model part.
        this.model.acceptedSubpartTypes.forEach(partType => {
            let element = this.createAddPartButton(partType);
            this.appendChild(element);
        });

        let labelHeader = this._shadowRoot.querySelector('#subparts-list-wrapper > h3');
        if(this.model.subparts.length){
            labelHeader.textContent = "Current Subparts";
        } else {
            labelHeader.textContent = "There are no subparts";
        }

        this.model.subparts.forEach(subpart => {
            let element = this.createSubpartComponent(subpart);
            this.appendChild(element);
        });
    }

    createSubpartComponent(aPart){
        let wrapper = document.createElement('li');
        wrapper.classList.add('subpart-item');
        wrapper.setAttribute('ref-id', aPart.id);
        wrapper.addEventListener('click', this.onSubpartItemClick);
        wrapper.addEventListener('mouseenter', this.onSubpartItemMouseEnter);
        wrapper.addEventListener('mouseleave', this.onSubpartItemMouseLeave);

        // Add icon area an SVG for Part
        let iconArea = document.createElement('div');
        iconArea.classList.add('icon-display-area');
        let iconImage;
        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"]).includes(aPart.type)){
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPart.type];
        } else {
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        iconArea.innerHTML = iconImage;
        wrapper.append(iconArea);

        // Add label, name, and id info
        let labelArea = document.createElement('h3');
        labelArea.textContent = `a ${aPart.type[0].toUpperCase()}${aPart.type.slice(1)}`;
        wrapper.append(labelArea);
        let name = aPart.partProperties.getPropertyNamed(
            aPart,
            'name'
        );
        if(name && name != ""){
            let nameArea = document.createElement('span');
            nameArea.classList.add('name-span');
            nameArea.textContent = `"${name}"`;
            wrapper.append(nameArea);
        }

        let idArea = document.createElement('span');
        idArea.classList.add('id-span');
        idArea.textContent = `(${aPart.id})`;
        wrapper.append(idArea);

        return wrapper;
    }

    createAddPartButton(aPartName){
        let button = document.createElement('button');
        let icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPartName];
        if(!icon){
            icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        button.setAttribute('slot', 'button');
        button.setAttribute('data-type', aPartName);
        button.setAttribute('title', `Add a ${aPartName} to this ${this.model.type}`);
        button.classList.add('add-part-button');
        button.addEventListener('click', this.onAddSubpart);
        button.innerHTML = icon;
        return button;
    }

    onSubpartItemClick(event){
        let id = event.currentTarget.getAttribute('ref-id');
        let targetPart = window.System.partsById[id];
        if(targetPart){
            window.System.editor.render(targetPart);
        }
    }

    onSubpartItemMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onSubpartItemMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    onAddSubpart(event){
        let type = event.currentTarget.getAttribute('data-type');
        if(type){
            this.model.sendMessage({
                type: 'command',
                commandName: 'newModel',
                args: [
                    type,
                    this.model.id
                ]
            }, this.model);
        }
        this.render(this.model);
    }

    getLocationViews(event){
        let targetId = event.currentTarget.getAttribute('ref-id');
        let span = event.currentTarget.querySelector('span');
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorTab.js":
/*!***********************************************!*\
  !*** ./js/objects/views/editors/EditorTab.js ***!
  \***********************************************/
/*! exports provided: EditorTab, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorTab", function() { return EditorTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorTab; });
// PREAMBLE

const templateString = `
<style>
    :host {
        display: flex;
        flex: 1;
        align-items: center;
        justify-content: center;
        padding: 6px;
        opacity: 0.5;
        border-bottom: 2px solid rgba(100, 100, 100, 0.7);
        transition: border 0.2s linear, opacity 0.2s linear;
        user-select: none;
    }

    :host([active="true"]){
        border-bottom: 2px solid rgba(200, 0, 0, 0.9);
        opacity: 1.0;
        transition: border 0.2s linear, opacity 0.2s linear;
    }

    :host(:hover){
        cursor: pointer;
    }
</style>
<span id="label">
    <slot></slot>
</span>
`;

class EditorTab extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.onClick = this.onClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('click', this.onClick);

            // If the tab is currently activated, emit
            // the tab-activaed message
            if(this.getAttribute('active') == "true"){
                let event = new CustomEvent("tab-activated", {
                    bubbles: true
                });
                this.dispatchEvent(event);
            }
        }
    }

    disconnectedCallback(){
        this.removeEventListener('click', this.onClick);
    }

    onClick(event){
        let isActive = (this.getAttribute('active') == "true");
        if(!isActive){
            this.setAttribute('active', 'true');
            let event = new CustomEvent("tab-activated", {
                bubbles: true
            });
            this.dispatchEvent(event);
        }
    }
};




/***/ }),

/***/ "./js/objects/views/editors/utils/subparts.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/utils/subparts.js ***!
  \****************************************************/
/*! exports provided: getLocationStringFor, onLocationLinkClick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocationStringFor", function() { return getLocationStringFor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onLocationLinkClick", function() { return onLocationLinkClick; });
 const getLocationStringFor = (aPart) => {
        let result = "";
        let currentPart = aPart;
        let currentOwner = aPart._owner;
        while(currentOwner){
            let indexInParent = currentOwner.subparts.filter((subpart) => {
                return subpart.type == currentPart.type;
            }).indexOf(currentPart) + 1;
            result += `${currentPart.type} ${indexInParent} of `;
            currentPart = currentPart._owner;
            currentOwner = currentOwner._owner;
        }
        result += 'this world';
        return result;
}


const onLocationLinkClick = (event) => {
        let text = event.currentTarget.querySelector('span').textContent;
        let input = document.createElement('input');
        input.style.position = 'absolute';
        input.style.opacity = 0;
        document.body.append(input);
        let currentFocus = document.activeElement;
        input.focus();
        input.value = text;
        console.log(input.value);
        input.select();
        document.execCommand('copy');
        input.remove();
        currentFocus.focus();
}




/***/ }),

/***/ "./js/objects/views/navigator/CardRow.js":
/*!***********************************************!*\
  !*** ./js/objects/views/navigator/CardRow.js ***!
  \***********************************************/
/*! exports provided: CardRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardRow", function() { return CardRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Card Row
 * --------------------------------------------
 * I am a view on a given Stack that shows each
 * subpart card item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="cards"></slot>
`;

class CardRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedCard = this.addWrappedCard.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('card-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the Stack Model's main view element.
        // We add the st-view-added/removed CustomEvent listeners
        // here so we can react only to direct stack additions
        // to the Stack (and not, say, to Windows or other nested kinds)
        let stackView = window.System.findViewById(this.model.id);
        stackView.addEventListener('st-view-added', this.handlePartAdded);
        stackView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(removedModel){
        let stackView = window.System.findViewById(removedModel.id);
        stackView.removeEventListener('st-view-added', this.handlePartAdded);
        stackView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        if(!this.model.currentCard){
            return;
        }
        let wrappers = Array.from(this.querySelectorAll('wrapped-view'));
        wrappers.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentCard.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'card'){
            let cardPart = window.System.partsById[event.detail.partId];
            this.addWrappedCard(cardPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'card'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update number display of all wrapped views in the row
            Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToCardById(event.target.getAttribute('wrapped-id'));
        }
    }

    initView(){
        // First, we clear out any existing children
        this.innerHTML = "";

        // We iterate over each card of the stack and:
        // * Create a clone of the card view element;
        // * Attach the correct model;
        // * Set it to be a lensed view;
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'card';
        }).forEach(cardPart => {
            this.addWrappedCard(cardPart);
        });

        // Update setting the current
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedCard(aCard){
        // Insert the lensed CardView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute('slot', 'cards');
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aCard);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a card and hence not
            // displayed in the CardRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

};




/***/ }),

/***/ "./js/objects/views/navigator/Navigator.js":
/*!*************************************************!*\
  !*** ./js/objects/views/navigator/Navigator.js ***!
  \*************************************************/
/*! exports provided: STNavigator, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STNavigator", function() { return STNavigator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STNavigator; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WrappedView.js */ "./js/objects/views/navigator/WrappedView.js");
/* harmony import */ var _StackRow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StackRow.js */ "./js/objects/views/navigator/StackRow.js");
/* harmony import */ var _CardRow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CardRow.js */ "./js/objects/views/navigator/CardRow.js");
/**
 * SimpleTalk Navigator Webcomponent
 * ------------------------------------------
 * This is a standalone component that allows
 * authors to navigate the WorldStack and individual
 * Stacks therein using a convenient pop-out tray from
 * the bottom of the screen.
 **/





// Add any needed customElements
window.customElements.define('nav-stack-row', _StackRow_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('nav-card-row', _CardRow_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('wrapped-view', _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

const stackIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="50" height="50" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <polyline points="12 4 4 8 12 12 20 8 12 4"></polyline>
   <polyline points="4 12 12 16 20 12"></polyline>
   <polyline points="4 16 12 20 20 16"></polyline>
</svg>
`;

const cardIcon = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   class="icon icon-tabler icon-tabler-stack"
   width="50"
   height="20.833309"
   viewBox="0 0 24 9.9999884"
   stroke-width="2"
   stroke="currentColor"
   fill="none"
   stroke-linecap="round"
   stroke-linejoin="round"
   version="1.1"
   id="svg893">
  <metadata
     id="metadata899">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs897" />
  <path
     stroke="none"
     d="M -2.7669151,-1.2564948 H 21.233085 V 22.743505 H -2.7669151 Z"
     fill="none"
     id="path885" />
  <polyline
     points="12 4 4 8 12 12 20 8 12 4"
     id="polyline887"
     transform="translate(0,-3)" />
</svg>
`;

const templateString = `
<style>
    :host {
        box-sizing: border-box;
        position: absolute;
        width: 100%;
        bottom: 0;
        min-height: 271px;
        background-color: white;
        backdrop-filter: blur(4px);
        transition: transform 0.2s ease-out;
        padding: 20px;
        transform: translateY(100%);
        border-top: 1px solid rgba(50, 50, 50, 0.4);
        overflow-y: hidden;
        overflow-x: auto;
        z-index: 1000;
    }

    .nav-display-row {
        box-sizing: border-box;
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        margin-bottom: 15px;
    }
    .nav-icon {
        color: gray;
        margin-right: 30px;
    }
</style>
<div id="stacks-display" class="nav-display-row">
    <div id="stack-icon" class="nav-icon">${stackIcon}</div>
    <slot name="stack-row"></slot>
</div>
<div id="cards-display" class="nav-display-row">
    <div id="card-icon" class="nav-icon">${cardIcon}</div>
    <slot name="card-row"></slot>
</div>
`;

class STNavigator extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.initialized = false;
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.createCardRowFor = this.createCardRowFor.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterDisconnected(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelSet(){
        this.removeAttribute('part-id');

        // Respond to the System part-added CustomEvent
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);

        // Add a StackRow view.
        this.stackRowEl = this.querySelector(':scope > nav-stack-row');
        if(!this.stackRowEl){
            this.stackRowEl = document.createElement('nav-stack-row');
            this.stackRowEl.setAttribute('slot', 'stack-row');
            this.appendChild(this.stackRowEl);
        }
        this.stackRowEl.setModel(this.model);

        // Create any needed CardRow views for all stacks
        // currently in the world
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.createCardRowFor(stackPart);
        });

        // Init the StackRow
        this.stackRowEl.initView();
        
        // Update the current card/stack values
        this.handleCurrentChange();

        // Respond to eventual current-ness prop
        // changes from the WorldStack.
        this.onPropChange('current', this.handleCurrentChange);
    }

    handleCurrentChange(){
        // If we get here, this means that the current *stack* has changed.
        // So we need to find the correct CardRow for it and set it
        // to be the slotted one in the shadow DOM
        let currentStackId = this.model.currentStack.id.toString();
        Array.from(this.querySelectorAll('nav-card-row')).forEach(cardRow => {
            let rowId = cardRow.getAttribute('stack-id');
            cardRow.removeAttribute('slot');
            if(currentStackId == rowId){
                cardRow.setAttribute('slot', 'card-row');
                Array.from(cardRow.querySelectorAll('wrapped-view')).forEach(wrapper => {
                    wrapper.updateScaling();
                });
            }
        });
    }

    handlePartAdded(event){
        // If a new stack is added, we need to create
        // a new CardRow for it.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.createCardRowFor(stackPart);
        }
    }

    handlePartRemoved(event){
        // If a stack has been removed, we need to
        // remove the corresponding CardRow
        if(event.detail.partType == 'stack'){
            let cardRow = this.querySelector(`[stack-id="${event.detail.partId}"]`);
            if(cardRow){
                cardRow.remove();
            }
        }
    }

    createCardRowFor(aStack){
        let cardRow = document.createElement('nav-card-row');
        cardRow.setAttribute('stack-id', aStack.id);
        cardRow.setModel(aStack);
        this.appendChild(cardRow);
        cardRow.initView();
    }

    toggle(){
        this.classList.toggle('open');
        if(this.classList.contains('open')){
            this.open();
        } else {
            this.close();
        }
    }

    open(){
        this.style.transform = "translateY(0)";
    }

    close(){
        this.style.transform = "translateY(100%)";
    }

    
};




/***/ }),

/***/ "./js/objects/views/navigator/StackRow.js":
/*!************************************************!*\
  !*** ./js/objects/views/navigator/StackRow.js ***!
  \************************************************/
/*! exports provided: StackRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackRow", function() { return StackRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Stack Row
 * --------------------------------------------
 * I am a view on the WorldStack that shows each
 * subpart stack item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="stacks"></slot>
`;

class StackRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedStack = this.addWrappedStack.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }


    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('stack-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the World Model's main view element.
        // We add the st-view-added CustomEvent listener
        // here so we can react only to direct stack additions
        // to the WorldStack (and not, say, to Windows or other nested kinds)
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        let currentId = this.model.currentStack.id;
        let wrappedViews = Array.from(
            this.querySelectorAll('wrapped-view')
        );
        wrappedViews.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentStack.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.addWrappedStack(stackPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'stack'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update numbers of remaining wrapped views in this StackRow
            Array.from(this.querySelectorAll('wrapped-view')).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToStackById(
                event.target.getAttribute('wrapped-id')
            );
        }
    }

    initView(){
        // Remove any existing wrapped views
        this.innerHTML = "";

        // We iterate over each corresponding Stack and:
        // * Create a clone of its view node;
        // * Attach the correct model;
        // * Set it to be a lensed view
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.addWrappedStack(stackPart);
        });

        // Setup the initial current-ness display
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedStack(aStack){  
        // Insert the lensed StackView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute("slot", "stacks");
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aStack);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a stack and hence not
            // displayed in the StackRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }
};




/***/ }),

/***/ "./js/objects/views/navigator/WrappedView.js":
/*!***************************************************!*\
  !*** ./js/objects/views/navigator/WrappedView.js ***!
  \***************************************************/
/*! exports provided: WrappedView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrappedView", function() { return WrappedView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WrappedView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * WrappedView Component
 * ---------------------------------------
 * I am a plain Webcomponent whose purpose is to
 * wrap a visual copy of an actual SimpleTalk View
 * element and display it in a scaled down format.
 * I make a cloned copy of the underlying view and
 * attach it to the same model as the original.
 **/


const templateString = `
<style>
    #number-display {
        opacity: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 100%;
        transition: opacity 0.2s ease-in;
        font-size: 2.2rem;
    }

    #number-display > span {
        transform: translateY(-10px);
        transition: transform 0.2s linear;
        pointer-events: none;
    }

    :host(:not(.current)) > #number-display {
        opacity: 0.8;
        background-color: rgba(200, 200, 200, 0.5);
        transition: opacity 0.2s ease-out;
        z-index: 1000;
    }

    :host(:not(.current)) > #number-display > span {
        transform: translateY(0px);
        transition: transform 0.2s linear;
    }
</style>
<div id="number-display">
    <span></span>
</div>
<slot name="wrapped-view"></slot>
`;


class WrappedView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template and shadowDom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onChildSlotted = this.onChildSlotted.bind(this);
        this.updateScaling = this.updateScaling.bind(this);
        this.handleNumberChange = this.handleNumberChange.bind(this);
        this.addWrappedView = this.addWrappedView.bind(this);
        this._recursivelyUpdateLensViews = this._recursivelyUpdateLensViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Bind a listener for the slot change.
            // This will be triggered whenever any
            // underlying element is slotted, so we
            // know to recompute the appropriate sizing
            // and styling
            let slotEl = this._shadowRoot.querySelector('slot');
            slotEl.addEventListener('slotchange', this.onChildSlotted);

            // we don't want the context menu to open in the nav since
            // it doens't make sense atm and will error
            this.removeEventListener('contextmenu', this.onContextMenuClick);
        }
    }

    disconnectedCallback(){
        let slotEl = this._shadowRoot.querySelector('slot');
        slotEl.removeEventListener('slotchange', this.onChildSlotted);
    }

    onChildSlotted(event){
        //this.updateScaling();
        //this.updateNumberDisplay();
    }

    afterModelSet(){
        this.onPropChange('number', this.handleNumberChange);
        this.removeAttribute('part-id');
        this.addWrappedView(this.model);
        this.updateNumberDisplay();
    }

    updateScaling(){
        let firstChild = this.children[0];
        // We need to find the element corresponding to the
        // actual view for the lens-ed part, in order to get
        // its current dimensions.
        let partId = firstChild.getAttribute('lens-part-id');
        let refElement = document.querySelector(`st-world`);
        let wrapBox = this.getBoundingClientRect();
        let innerBox = document.querySelector(`st-world`).getBoundingClientRect();
        let scalingX = (wrapBox.width / innerBox.width);
        let refElementBox = refElement.getBoundingClientRect();
        firstChild.style.width = `${refElementBox.width}px`;
        firstChild.style.height = `${refElementBox.height}px`;
        firstChild.style.transform = `scale(${scalingX})`;
        firstChild.style.transformOrigin = "0px 0px";
    }

    updateNumberDisplay(){
        let firstChild = this.children[0];
        let model = firstChild.model;
        // we only want to look at subparts of the same type (stack or card)
        let subparts = model._owner.subparts.filter((part) => {
            return model.type == part.type;
        });
        let numDisplay = this._shadowRoot.querySelector('#number-display > span');
        numDisplay.innerText = subparts.indexOf(model) + 1;
    }

    handleNumberChange(){
        // Update number display of all wrapped views in the row
        Array.from(this.parentNode.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

    addWrappedView(aPartModel){
        // First, clear out any existing
        // child elements
        this.innerHTML = "";

        // Create a lensed copy of the given
        // view and update key attributes on it
        let originalView = document.querySelector(`[part-id="${aPartModel.id}"]`);
        let lensedView = originalView.cloneNode(true);
        lensedView.setAttribute('lens-part-id', aPartModel.id);
        lensedView.setAttribute('slot', 'wrapped-view');
        lensedView.style.pointerEvents = "none";
        lensedView.wantsHalo = false;

        // Inline the initial scaling style properties.
        // We begin with an extremely small amount which will
        // be adjusted later during updateScaling();
        lensedView.style.transform = `scale(${0.001})`;
        lensedView.style.transformOrigin = "0px 0px";
        
        // Recursively create lens views of all subpart children
        // and append them in the correct places
        lensedView.isLensed = true;
        lensedView.setModel(aPartModel);
        lensedView.removeAttribute('part-id');
        if(lensedView.handleCurrentChange){
            lensedView.handleCurrentChange();
        }
        this._recursivelyUpdateLensViews(lensedView, aPartModel.id);

        // Insert the root lensed view into the wrapper
        this.setAttribute('wrapped-id', aPartModel.id);
        this.appendChild(lensedView);
        this.updateScaling();
    }

    _recursivelyUpdateLensViews(lensedView, anId){
        let subViews = Array.from(lensedView.children).filter(child => {
            return child.isPartView;
        });
        subViews.forEach(subView => {
            subView.isLensed = true;
            subView.wantsHalo = false;
            let subId = subView.getAttribute('part-id');
            subView.setAttribute('lens-part-id', subId);
            let model = window.System.partsById[subId];
            subView.setModel(model);
            subView.removeAttribute('part-id');
            this._recursivelyUpdateLensViews(subView, subId);
        });
    }

    /** PartView Overrides **/
    styleCSS(){
        // Do nothing
    }

    styleTextCSS(){
        // Do nothing
    }

    layoutChanged(){
        // Do nothing
    }
};




/***/ }),

/***/ "./js/ohm/interpreter-semantics.js":
/*!*****************************************!*\
  !*** ./js/ohm/interpreter-semantics.js ***!
  \*****************************************/
/*! exports provided: createInterpreterSemantics, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createInterpreterSemantics", function() { return createInterpreterSemantics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createInterpreterSemantics; });
/* harmony import */ var _objects_ExecutionStack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/ExecutionStack.js */ "./js/objects/ExecutionStack.js");


// Helpers
function findNearestParentOfKind(aPart, aPartType){
    let owner = aPart._owner;
    while(owner){
        if(owner.type == aPartType){
            return owner;
        }
        owner = owner._owner;
    }
    throw new Error(`'this' is a ${aPart.type}, not a ${aPartType} or does not have a parent of a ${aPartType}!`);
}

// check for possibleAncestor.acceptsSubpart(aPart.type)
// and if not go to owner and check again
function findFirstPossibleAncestor(aPart, aPartType){
    if(_subpartCheck(aPart, aPartType)){
        return aPart;
    } else {
        let owner = aPart._owner;
        while(owner){
            if(_subpartCheck(owner, aPartType)){
                return owner;
            }
            owner = owner._owner;
        }
    }
    throw new Error(`a ${aPart.type}, does not accept nor has any ancestors which accept part type ${aPartType}`);
}

function _subpartCheck(aPart, aPartType){
    if(aPartType == 'part'){
        return aPart.acceptedSubpartTypes.length > 0;
    }
    return aPart.acceptsSubpart(aPartType);
}

class STVariableReferenceError extends Error {
    constructor(...args){
        super(...args);
    }
};
Object.defineProperty(
    STVariableReferenceError.prototype,
    'name',
    {
        value: 'STVariableReferenceError'
    }
);

const createInterpreterSemantics = (partContext, systemContext) => {
    return {
        Script: function(scriptParts, _){
            return scriptParts.interpret();
        },
        MessageHandler: function(handlerOpen, lineTerm, optionalStatementList, handlerClose){
            let {messageName, parameters} = handlerOpen.interpret();
            let handlerFunction = function(senders, ...args){

                // In the grammar, the StatementList is
                // an optional rule, meaning the result of the rule
                // is an empty array (no statementlist) or a single
                // item array (the statementlist)
                if(optionalStatementList.children.length == 0){
                    return;
                }
                let statementList = optionalStatementList.children[0];

                // Next, we initialize a new ActivationContext
                // that will hold all variable information for
                // the execution of this handler.
                // We push it to the top of the current execution stack
                // and set the argument variables to locals
                args.forEach((argValue, index) => {
                    let argName = parameters[index];
                    systemContext.executionStack.current.setLocal(
                        argName,
                        argValue
                    );
                });

                // Because StatementList is both optional *and* made up
                // of iterable StatementLine rules (ie, 'StatementLine+' in grammar),
                // we need to "unwrap" these nodes without calling interpret() on them.
                // This ensures that expressions within the statements, like variable lookups,
                // are not called before any preceding statements have been interpreted and
                // the corresponding messages have already been sent. For example, statement 1 might
                // set a variable that statement 2 needs to lookup and use, so we want the lookup to
                // occur after statement 1 has been interpreted and the message for it has
                // been sent.
                statementList.children.forEach(statementLines => {
                    statementLines.children.forEach(statementLine => {
                        let message = statementLine.interpret();
                    });
                });
            };

            partContext._commandHandlers[messageName] = handlerFunction;
        },

        MessageHandlerOpen: function(literalOn, messageName, optionalParameterList){
            // Because the ParameterList here is optional, if
            // it is set it will be in the form of a size 1 array.
            // This single array item will itself be an array of the
            // parameter variable names.
            // Otherwise, an empty array indicates no params
            // are passed in for this handler
            let params = optionalParameterList.interpret();
            if(params.length > 0){
                params = params[0];
            }
            return {
                messageName: messageName.sourceString,
                parameters: params
            };
        },

        ParameterList: function(parameterString){
            return parameterString.asIteration().children.map(child => {
                return child.sourceString;
            });
        },


        InClause: function(inLiteral, objectSpecifier){
            return objectSpecifier.interpret();
        },

        Command_answer: function(answer, expression){
            let msg = {
                type: "command",
                commandName: "answer",
                args: [
                    expression.interpret()
                ]
            };
            return msg;
        },

        Command_goToDirection: function(goToLiteral, nextPrevious, systemObject){
            let args = [];
            args.push(nextPrevious.sourceString);
            if (systemObject.sourceString){
                args.push(systemObject.sourceString);
            }

            let msg = {
                type: "command",
                commandName: "go to direction",
                args: args
            };
            return msg;
        },

        Command_goToByObjectSpecifier: function(goToLiteral, objectSpecifier){
            let args = [
                objectSpecifier.interpret() // id of the object
            ];

            let msg = {
                type: "command",
                commandName: "go to",
                args: args
            };
            return msg;
        },

        Command_goToWebsite: function(goToLiteral, websiteLiteral, url){
            let args = [
                url.interpret()
            ];

            let msg = {
                type: "command",
                commandName: "go to website",
                args: args
            };
            return msg;
        },

        Command_addProperty: function(addLiteral, propertyLiteral, propNameAsLiteral, toLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "newProperty",
                args: args
            };
            return msg;
        },

        Command_addModel: function(addLiteral, newPartType, optionalPartName){
            // here no owner has been provided so we assume it is the first possible one
            let parent = findFirstPossibleAncestor(partContext, newPartType.sourceString);
            let args = [
                newPartType.sourceString,
                parent.id
            ];
            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_addModelTo: function(addLiteral, newPartType, optionalPartName, toLiteral, objectSpecifier){
            let args = [
                newPartType.sourceString, // The kind of part to add
                objectSpecifier.interpret() // id of the parent model part
            ];

            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_putVariable: function(putLiteral, value, intoLiteral, globalLiteral, destination){
            let global = false;
            if(globalLiteral.sourceString){
                global = true;
            };
            let args = [
                value.interpret(),
                destination.sourceString,
                global
            ];
            let msg = {
                type: "command",
                commandName: 'putInto',
                args
            };
            return msg;
        },

        Command_deleteProperty: function(deleteLiteral, propertyLiteral, propNameAsLiteral, fromLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "deleteProperty",
                args: args
            };
            return msg;
        },

        Command_deleteModel: function(deleteLiteral, objectSpecifier){
            let args = [
                objectSpecifier.interpret() // id of the object
            ];

            let msg = {
                type: "command",
                commandName: "deleteModel",
                args: args
            };
            return msg;
        },

        Command_setProperty: function(setLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setProperty",
                args: args
            };
            return msg;
        },

        Command_setSelection: function(setLiteral, selectionLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setSelection",
                args: args
            };
            return msg;
        },

        Command_ask: function(askLiteral, question){
            return {
                type: "command",
                commandName: "ask",
                args: [ question.interpret() ]
            };
        },

        Command_tellCommand: function(tellLiteral, objectSpecifier, toLiteral, command){
            return {
                type: 'command',
                commandName: 'tell',
                args: [
                    objectSpecifier.interpret(),
                    command.interpret()
                ]
            };
        },

        Command_arbitraryCommand: function(commandName, optionalArgumentList){
            // Because the argument list is optional here, it will
            // be either an empty array (no arguments) or a size 1
            // array (which itself will contain an array of the arguments)
            let optionalArguments = optionalArgumentList.interpret();
            if(optionalArguments.length > 0){
                optionalArguments = optionalArguments[0];
            }

            return {
                type: "command",
                commandName: commandName.sourceString,
                args: optionalArguments
            };
        },

        CommandArgumentList: function(list){
            return list.asIteration().interpret();
        },

        StatementLine: function(statement, newline){
            let message = statement.interpret();

            // Some statements, like if-then controls
            // and repeat controls, do not result in
            // messages but return null.
            // We ignore these.
            if(message && typeof(message) !== 'string'){
                let commandResult = partContext.sendMessage(message, partContext);
                systemContext.executionStack.current.setLocal('it', commandResult);
                return null;
            } else {
                return message;
            }
        },

        Statement: function(actualStatement, optionalComment){
            return actualStatement.interpret();
        },

        Expression_addExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first + second;
        },

        Expression_minusExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first - second;
        },

        Expression_divideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first / second;
        },

        Expression_moduloDivideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first % second;
        },

        Expression_timesExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first * second;
        },

        Expression_stringConcatExpr: function(firstExpression, operation, secondExpression){
            // When we encounter the "&" operator, we coerce both expressions into
            // a string
            let first = firstExpression.interpret().toString();
            let second = secondExpression.interpret().toString();
            return `${first}${second}`;
        },

        Factor_parenFactor: function(leftParen, expression, rightParen){
            return expression.interpret();
        },

        Factor_notFactor: function(notLiteral, expression){
            return !expression.interpret();
        },

        EqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first === second;
        },

        NonEqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first !== second;
        },

        Conditional_gtComparison: function(expr1, gtLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first > second;
        },

        Conditional_ltComparison: function(expr1, ltLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first < second;
        },

        Conditional_gteComparison: function(expr1, gteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first >= second;
        },

        Conditional_lteComparison: function(expr1, lteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first <= second;
        },

        ThereIsAnObjectConditional: function(thereLiteral, isLiteral, aOrAnLiteral, objectSpecifier){
            try{
                objectSpecifier.interpret();
                return true;
            } catch(e){
                return false;
            };
        },

        ThereIsNotAnObjectConditional: function(thereLiteral, isLiteral, notLiteral, aOrAnLiteral, inClause){
            try{
                objectSpecifier.interpret();
                return false;
            } catch(e){
                return true;
            };
        },

        ThereIsAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsNotAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        ThereIsNotAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        IfThenInline: function(ifLiteral, conditional, thenLiteral, statement, optionalComment){
            let shouldEvaluate = conditional.interpret();
            if(shouldEvaluate){
                return statement.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withoutElse: function(ifLine, lineTerm1, thenLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withElse: function(ifLine, lineTerm1, thenLine, lineTerm2, elseLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return elseLine.interpret();
            }
        },

        IfThenMultiline_withElse: function(ifLine, lineTerm, multiThen, multiElse, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            } else {
                return multiElse.interpret();
            }
        },

        IfThenMultiline_withoutElse: function(ifLine, lineTerm, multiThen, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            }
            return null;
        },

        IfLine: function(ifLiteral, conditional, optionalComment){
            return conditional.interpret();
        },

        ThenLine: function(thenLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ElseLine: function(elseLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ControlStatementLine: function(statementLine){
            return statementLine.interpret();
        },

        MultiThen: function(thenLiteral, optionalComment, lintTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        MultiElse: function(elseLiteral, optionalComment, lineTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        KindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return false;
        },

        NotKindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return true;
        },

        RepeatControlForm_forNumTimes: function(repeatLit, optionalForLit, intOrVar, timesLit){
            return {
                repeatType: 'forNumTimes',
                numTimes: intOrVar.interpret()
            };
        },

        RepeatControlForm_untilCondition: function(repeatLit, untilLit, conditional){
            return {
                repeatType: 'untilCondition',
                condition: conditional
            };
        },

        RepeatControlForm_whileCondition: function(repeatLit, whileLit, conditional){
            return {
                repeatType: 'whileCondition',
                condition: conditional
            };
        },

        RepeatControlForm_withStartFinish: function(repeatLit, withLit, varName, eqLit, firstVal, toLit, secondVal){
            return {
                repeatType: 'withStartFinish',
                varName: varName.sourceString,
                start: firstVal.interpret(),
                finish: secondVal.interpret()
            };
        },

        RepeatAdjust_exit: function(_){
            return 'exit repeat';
        },

        RepeatAdjust_next: function(_){
            return 'next repeat';
        },

        RepeatBlock: function(repeatControl, lineTerm, statementLineOrRepAdjustPlus, endLiteral){
            let repeatInfo = repeatControl.interpret();
            let statementLines = statementLineOrRepAdjustPlus.children;
            switch(repeatInfo.repeatType){
            case 'forNumTimes':
                for(let i = 1; i <= repeatInfo.numTimes; i++){
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == 'next repeat'){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the main for loop
                    }
                }
                break; // Break out of the switch
            case 'untilCondition':
                let untilTestCondition = repeatInfo.condition.interpret();
                while(!untilTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result){
                            if(result == 'exit repeat'){
                                shouldBreak = true;
                                break;
                            } else if(result == 'next repeat'){
                                break;
                            }
                        }
                    }
                    if(shouldBreak){
                        break; // break out of the outer while loop
                    }
                    untilTestCondition = repeatInfo.condition.interpret();
                }
                break; // Break out of the switch case
            case 'whileCondition':
                let whileTestCondition = repeatInfo.condition.interpret();
                while(whileTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldBreak){
                        break; // break out of outer while loop (end repeat)
                    }
                    whileTestCondition = repeatInfo.condition.interpret();
                }
                break; // break out of switch case
            case 'withStartFinish':
                // For now, we assume that start is less than
                // finish. We should probably throw an error if
                // otherwise
                if(repeatInfo.start > repeatInfo.finish){
                    throw new Error(`Repeat error: start greater than finish`);
                }

                for(let i = repeatInfo.start; i <= repeatInfo.finish; i++){
                    systemContext.executionStack.current.setLocal(repeatInfo.varName, i);
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == "exit repeat"){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the outer (repeat) loop
                    }
                }
            }
            return null;
        },

        PropertyValue_withSpecifier: function(theLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            return target.partProperties.getPropertyNamed(
                target,
                propName.interpret()
            );
        },

        PropertyValue_withoutSpecifier: function(theLiteral, propName){
            return partContext.partProperties.getPropertyNamed(
                partContext,
                propName.interpret()
            );
        },

        /** Object Specifiers **/


        /**
         * The partByTarget Partial Specifier
         * refers to partials that specify a part
         * specified in the "target" PartProperty
         * of the context part. The value of the
         * target property is any valid ObjectSpecifier
         * string.
         */
        PartialSpecifier_partByTarget(targetLiteral){
            return (context) => {
                let targetPropValue = context.partProperties.getPropertyNamed(context, "target");
                // use the partContext since the context object might not have any semantics set on it
                // For example, a context object/part which does not have a script which has been
                // compiled will not have had context._semantics set.
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return systemContext.partsById[targetId];
            };
        },

        /**
         * The currentCard Partial Specifier
         * refers to partials that specify the current card
         * depending on the stack context.
         */
        PartialSpecifier_currentCard: function(currentLiteral, cardLiteral){
            return function(contextPart){
                return contextPart.currentCard;
            };
        },

        /**
         * The partByIndex Partial Specifier
         * refers to partials that specify a part
         * type and an integer literal, for ex:
         *     field 3
         * The above example refers to the third
         * field part in its owner/parent part.
         */
        PartialSpecifier_partByIndex: function(objectType, integerLiteral){
            let index = integerLiteral.interpret();
            if(index < 1){
                throw new Error(`Part indices must be 1 or greater`);
            }
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    return contextPart.subparts[index-1];
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    return partsOfType[index-1];
                }
            };
        },

        /**
         * The partByNumericalIndex Partial Specifier
         * refers to partial that specify a part
         * type preceded by the English word for the
         * number. For the moment we accept first - tenth
         * Example:
         *     sixth button
         */
        PartialSpecifier_partByNumericalIndex: function(numericalKeyword, objectType){
            let index = numericalKeyword.interpret();
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return contextPart.subparts[contextPart.subparts.length - 1];
                    } else {
                        return contextPart.subparts[index-1];
                    }
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return partsOfType[partsOfType.length - 1];
                    } else {
                        return partsOfType[index-1];
                    }
                }
            };
        },

        /**
         * The partByName Partial Specifier
         * refers to a partial that specifies a part
         * by its name property. Example:
         *     card "My Custom Card"
         */
        PartialSpecifier_partByName: function(objectType, stringLiteral){
            let name = stringLiteral.interpret();
            if(objectType.sourceString == 'part'){
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return name == foundName;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part named "${name}"`);
                };
            } else {
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    }).filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return foundName == name;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} named "${name}"`);
                };
            }
        },

        /**
         * The 'this' specifier is a terminal (final)
         * specifier that refers to one of three things:
         * 1. the type of the current part executing the script,
         *    example: this button
         * 2. Card, which refers to the card that owns the
         *    part that is currently executing the script, ex:
         *    this card
         * 3. Stack, which refers to the stack that owns the
         *    part that is currently executing the script, ex:
         *    this stack
         */
        TerminalSpecifier_thisSystemObject: function(thisLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == partContext.type){
                    return partContext;
                } else {
                    return findNearestParentOfKind(partContext, targetType);
                }
            };
        },

        /**
         * The 'current' specifier is a terminal (final)
         * specifier that refers to either the current card or stack
         * being displayed to the user.
         * There are only two possible valid options:
         *     `current card`
         *     `current stack`
         */
        TerminalSpecifier_currentSystemObject: function(currentLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == 'stack'){
                    return systemContext.getCurrentStackModel();
                } else if(targetType == 'card'){
                    return systemContext.getCurrentCardModel();
                } else {
                    throw new Error(`${targetType} cannot be a 'current' system object`);
                }
            };
        },

        /**
         * The partById specifier is a terminal (final)
         * specifier that refers to a given part type
         * by its unique system id. For any kind of part,
         * we use `part id <objectId>`
         * Examples: `card id 266` `part id 5`
         */
        TerminalSpecifier_partById: function(objectType, idLiteral, objectId){
            let id = objectId.sourceString;
            let found = systemContext.partsById[id];
            if(!found){
                throw new Error(`Cannot find ${objectType.sourceString} with id ${objectId}`);
            }
            return function(context){
                return found;
            };
        },

        /**
         * A "prefixed" queried specifier is just
         * a PartialSpecifier with "of" in front of it, indicating
         * that a different partial will precede it be queried inside of it.
         * Example `of button "My Button"`
         */
        QueriedSpecifier_prefixed: function(partialSpecifier, ofLiteral){
            return partialSpecifier.interpret();
        },

        /**
         * A nested queried specifier is one that has two
         * or more prefixed specifiers. The simplest would be
         * something like:
         *     `of card "My Card" of stack "Another named stack"`
         */
        QueriedSpecifier_nested: function(firstQuery, secondQuery){
            return function(contextPart){
                let inner = secondQuery.interpret()(contextPart);
                let outer = firstQuery.interpret()(inner);
                return outer;
            };
        },

        /**
         * An ObjectSpecifier without an annotated
         * rule means it was interpreted as just
         * a TerminalSpecifier of some sort.
         * However, we need to extract the id
         * and return that result, since that is what is
         * expected of all interpreted ObjectSpecifiers
         */
        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let found = terminalSpecifier.interpret()();
            return found.id;
        },

        /**
         * A Compound with terminal specifier is a QueriedSpecifier
         * that finishes with a Terminal specifier.
         * Example: `of button 3 of card "Some named card" of current stack`
         */
        ObjectSpecifier_compoundQueryWithTerminal: function(queriedSpecifier, terminalSpecifier){
            // The terminal here is the ultimate part context
            let finalPart = terminalSpecifier.interpret()();
            let result = queriedSpecifier.interpret()(finalPart);
            return result.id;
        },

        /**
         * A Compound without terminal specifier is a QueriedSpecifier
         * that finishes with a Partial specifier.
         * Example: `of button 3 of first card` (which can continue `..of current stack` etc)
         * `first button of first area of stack 3`
         * `first button of area two of stack 3`
         */
        ObjectSpecifier_compoundQueryWithoutTerminal: function(queriedSpecifier, partialSpecifier){
            // if the partialSpecfier refers to either area, card or stack
            // then go to its owner for the context
            // if it refers to the current card then find the owner for the context
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                systemObjectString = "card";
            } else {
                children.forEach((child) => {
                    if(child.ctorName == "systemObject"){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let finalPartial = partialSpecifier.interpret()(finalPart);
            let result = queriedSpecifier.interpret()(finalPartial);
            return result.id;
        },

        /**
         * A single non-terminal ObjectSpecifier is just a Partial
         * specifier by itself. When present outside of a QueriedSpecifier,
         * it will be interpreted in the current context and treated
         * as terminal/final. For example:
         *     button 4
         * by itself as a whole specifier will be interpreted as
         * `button 4 of this card`
         */
        ObjectSpecifier_singleNonTerminal: function(partialSpecifier){
            // A single non-terminal object specifier is one
            // whose terminal object is implicitly assumed to
            // be the card or the stack in which the current context part
            // exists.
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                return systemContext.getCurrentCardModel().id;
            } else {
                children.forEach((child) => {
                    if(child.sourceString == "part" || child.sourceString == "target" || child.ctorName == 'systemObject'){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            // the systemObject is the target (defined in it's "target" part property), then we need to
            // first get the target property value (string) and interpret that
            if(systemObjectString == "target"){
                let targetPropValue = partContext.partProperties.getPropertyNamed(partContext, "target");
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return targetId;
            } else if(systemObjectString == "current card"){
                systemObjectString = "card";
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let result = partialSpecifier.interpret()(finalPart);
            return result.id;
        },

        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let result = terminalSpecifier.interpret()(partContext);
            return result.id;
        },

        anyLiteral: function(theLiteral){
            return theLiteral.interpret();
        },

        stringLiteral: function(openQuote, text, closeQuote){
            return text.sourceString;
        },

        booleanLiteral: function(text){
            if(text.sourceString == 'true'){
                return true;
            }
            if(text.sourceString == 'false'){
                return false;
            }
            throw new Error(`Invalid boolean literal: ${text}`);
        },

        integerLiteral: function(negativeSign, integer){
            let int = parseInt(integer.sourceString);
            let hasNegative = (negativeSign.sourceString == "-");
            if(hasNegative){
                return -1 * int;
            }
            return int; 
        },

        floatLiteral: function(negativeSign, onesPlace, decimal, restPlace){
            let floatString = `${onesPlace.sourceString}.${restPlace.sourceString}`;
            let hasNegative = (negativeSign.sourceString == "-");
            let result = parseFloat(floatString);
            if(hasNegative){
                return -1 * result;
            }
            return result;
        },

        numericalKeyword: function(numeralName){
            switch(numeralName.sourceString){
            case 'first':
                return 1;
            case 'second':
                return 2;
            case 'third':
                return 3;
            case 'fourth':
                return 4;
            case 'fifth':
                return 5;
            case 'sixth':
                return 6;
            case 'seventh':
                return 7;
            case 'eighth':
                return 8;
            case 'ninth':
                return 9;
            case 'tenth':
                return 10;
            }

            return -1;
        },

        variableName: function(letterPlus, optionalDigits){
            // Lookup the variable in the part's
            // current execution context
            // If the variable is not a key on the object,
            // we throw an error: this means the variable has not yet
            // been defined but is being looked up.
            let value = systemContext.executionStack.current.get(this.sourceString);
            if(value == undefined){
                throw new STVariableReferenceError(
                    `Variable ${this.sourceString} has not been defined`);
            }
            return value;
        },

        comment: function(dashesLiteral, nonLineTerminatorChars){
            // Interpret doesn't do anything
            // with comments.
            return null;
        },

        _terminal(){

        }
    };
};





/***/ }),

/***/ "./node_modules/ohm-js/dist/built-in-rules.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/dist/built-in-rules.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = \"0\"..\"9\"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | \"a\"..\"f\"\n    | \"A\"..\"F\"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n}"},"BuiltInRules",null,null,{"alnum":["define",{"sourceInterval":[18,78]},"an alpha-numeric character",[],["alt",{"sourceInterval":[60,78]},["app",{"sourceInterval":[60,66]},"letter",[]],["app",{"sourceInterval":[73,78]},"digit",[]]]],"letter":["define",{"sourceInterval":[82,142]},"a letter",[],["alt",{"sourceInterval":[107,142]},["app",{"sourceInterval":[107,112]},"lower",[]],["app",{"sourceInterval":[119,124]},"upper",[]],["app",{"sourceInterval":[131,142]},"unicodeLtmo",[]]]],"digit":["define",{"sourceInterval":[146,177]},"a digit",[],["range",{"sourceInterval":[169,177]},"0","9"]],"hexDigit":["define",{"sourceInterval":[181,254]},"a hexadecimal digit",[],["alt",{"sourceInterval":[219,254]},["app",{"sourceInterval":[219,224]},"digit",[]],["range",{"sourceInterval":[231,239]},"a","f"],["range",{"sourceInterval":[246,254]},"A","F"]]],"ListOf":["define",{"sourceInterval":[258,336]},null,["elem","sep"],["alt",{"sourceInterval":[282,336]},["app",{"sourceInterval":[282,307]},"NonemptyListOf",[["param",{"sourceInterval":[297,301]},0],["param",{"sourceInterval":[303,306]},1]]],["app",{"sourceInterval":[314,336]},"EmptyListOf",[["param",{"sourceInterval":[326,330]},0],["param",{"sourceInterval":[332,335]},1]]]]],"NonemptyListOf":["define",{"sourceInterval":[340,388]},null,["elem","sep"],["seq",{"sourceInterval":[372,388]},["param",{"sourceInterval":[372,376]},0],["star",{"sourceInterval":[377,388]},["seq",{"sourceInterval":[378,386]},["param",{"sourceInterval":[378,381]},1],["param",{"sourceInterval":[382,386]},0]]]]],"EmptyListOf":["define",{"sourceInterval":[392,434]},null,["elem","sep"],["seq",{"sourceInterval":[438,438]}]],"listOf":["define",{"sourceInterval":[438,516]},null,["elem","sep"],["alt",{"sourceInterval":[462,516]},["app",{"sourceInterval":[462,487]},"nonemptyListOf",[["param",{"sourceInterval":[477,481]},0],["param",{"sourceInterval":[483,486]},1]]],["app",{"sourceInterval":[494,516]},"emptyListOf",[["param",{"sourceInterval":[506,510]},0],["param",{"sourceInterval":[512,515]},1]]]]],"nonemptyListOf":["define",{"sourceInterval":[520,568]},null,["elem","sep"],["seq",{"sourceInterval":[552,568]},["param",{"sourceInterval":[552,556]},0],["star",{"sourceInterval":[557,568]},["seq",{"sourceInterval":[558,566]},["param",{"sourceInterval":[558,561]},1],["param",{"sourceInterval":[562,566]},0]]]]],"emptyListOf":["define",{"sourceInterval":[572,614]},null,["elem","sep"],["seq",{"sourceInterval":[616,616]}]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/ohm-grammar.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/dist/ohm-grammar.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"Ohm {\n\n  Grammars\n    = Grammar*\n\n  Grammar\n    = ident SuperGrammar? \"{\" Rule* \"}\"\n\n  SuperGrammar\n    = \"<:\" ident\n\n  Rule\n    = ident Formals? ruleDescr? \"=\"  RuleBody  -- define\n    | ident Formals?            \":=\" OverrideRuleBody  -- override\n    | ident Formals?            \"+=\" RuleBody  -- extend\n\n  RuleBody\n    = \"|\"? NonemptyListOf<TopLevelTerm, \"|\">\n\n  TopLevelTerm\n    = Seq caseName  -- inline\n    | Seq\n\n  OverrideRuleBody\n    = \"|\"? NonemptyListOf<OverrideTopLevelTerm, \"|\">\n\n  OverrideTopLevelTerm\n    = \"...\"  -- superSplice\n    | TopLevelTerm\n\n  Formals\n    = \"<\" ListOf<ident, \",\"> \">\"\n\n  Params\n    = \"<\" ListOf<Seq, \",\"> \">\"\n\n  Alt\n    = NonemptyListOf<Seq, \"|\">\n\n  Seq\n    = Iter*\n\n  Iter\n    = Pred \"*\"  -- star\n    | Pred \"+\"  -- plus\n    | Pred \"?\"  -- opt\n    | Pred\n\n  Pred\n    = \"~\" Lex  -- not\n    | \"&\" Lex  -- lookahead\n    | Lex\n\n  Lex\n    = \"#\" Base  -- lex\n    | Base\n\n  Base\n    = ident Params? ~(ruleDescr? \"=\" | \":=\" | \"+=\")  -- application\n    | oneCharTerminal \"..\" oneCharTerminal           -- range\n    | terminal                                       -- terminal\n    | \"(\" Alt \")\"                                    -- paren\n\n  ruleDescr  (a rule description)\n    = \"(\" ruleDescrText \")\"\n\n  ruleDescrText\n    = (~\")\" any)*\n\n  caseName\n    = \"--\" (~\"\\n\" space)* name (~\"\\n\" space)* (\"\\n\" | &\"}\")\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n  ident  (an identifier)\n    = name\n\n  terminal\n    = \"\\\"\" terminalChar* \"\\\"\"\n\n  oneCharTerminal\n    = \"\\\"\" terminalChar \"\\\"\"\n\n  terminalChar\n    = escapeChar\n    | ~\"\\\\\" ~\"\\\"\" ~\"\\n\" any\n\n  escapeChar  (an escape sequence)\n    = \"\\\\\\\\\"                                     -- backslash\n    | \"\\\\\\\"\"                                     -- doubleQuote\n    | \"\\\\\\'\"                                     -- singleQuote\n    | \"\\\\b\"                                      -- backspace\n    | \"\\\\n\"                                      -- lineFeed\n    | \"\\\\r\"                                      -- carriageReturn\n    | \"\\\\t\"                                      -- tab\n    | \"\\\\u\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\n    | \"\\\\x\" hexDigit hexDigit                    -- hexEscape\n\n  space\n   += comment\n\n  comment\n    = \"//\" (~\"\\n\" any)* &(\"\\n\" | end)  -- singleLine\n    | \"/*\" (~\"*/\" any)* \"*/\"  -- multiLine\n\n  tokens = token*\n\n  token = caseName | comment | ident | operator | punctuation | terminal | any\n\n  operator = \"<:\" | \"=\" | \":=\" | \"+=\" | \"*\" | \"+\" | \"?\" | \"~\" | \"&\"\n\n  punctuation = \"<\" | \">\" | \",\" | \"--\"\n}"},"Ohm",null,"Grammars",{"Grammars":["define",{"sourceInterval":[9,32]},null,[],["star",{"sourceInterval":[24,32]},["app",{"sourceInterval":[24,31]},"Grammar",[]]]],"Grammar":["define",{"sourceInterval":[36,83]},null,[],["seq",{"sourceInterval":[50,83]},["app",{"sourceInterval":[50,55]},"ident",[]],["opt",{"sourceInterval":[56,69]},["app",{"sourceInterval":[56,68]},"SuperGrammar",[]]],["terminal",{"sourceInterval":[70,73]},"{"],["star",{"sourceInterval":[74,79]},["app",{"sourceInterval":[74,78]},"Rule",[]]],["terminal",{"sourceInterval":[80,83]},"}"]]],"SuperGrammar":["define",{"sourceInterval":[87,116]},null,[],["seq",{"sourceInterval":[106,116]},["terminal",{"sourceInterval":[106,110]},"<:"],["app",{"sourceInterval":[111,116]},"ident",[]]]],"Rule_define":["define",{"sourceInterval":[131,181]},null,[],["seq",{"sourceInterval":[131,170]},["app",{"sourceInterval":[131,136]},"ident",[]],["opt",{"sourceInterval":[137,145]},["app",{"sourceInterval":[137,144]},"Formals",[]]],["opt",{"sourceInterval":[146,156]},["app",{"sourceInterval":[146,155]},"ruleDescr",[]]],["terminal",{"sourceInterval":[157,160]},"="],["app",{"sourceInterval":[162,170]},"RuleBody",[]]]],"Rule_override":["define",{"sourceInterval":[188,248]},null,[],["seq",{"sourceInterval":[188,235]},["app",{"sourceInterval":[188,193]},"ident",[]],["opt",{"sourceInterval":[194,202]},["app",{"sourceInterval":[194,201]},"Formals",[]]],["terminal",{"sourceInterval":[214,218]},":="],["app",{"sourceInterval":[219,235]},"OverrideRuleBody",[]]]],"Rule_extend":["define",{"sourceInterval":[255,305]},null,[],["seq",{"sourceInterval":[255,294]},["app",{"sourceInterval":[255,260]},"ident",[]],["opt",{"sourceInterval":[261,269]},["app",{"sourceInterval":[261,268]},"Formals",[]]],["terminal",{"sourceInterval":[281,285]},"+="],["app",{"sourceInterval":[286,294]},"RuleBody",[]]]],"Rule":["define",{"sourceInterval":[120,305]},null,[],["alt",{"sourceInterval":[131,305]},["app",{"sourceInterval":[131,170]},"Rule_define",[]],["app",{"sourceInterval":[188,235]},"Rule_override",[]],["app",{"sourceInterval":[255,294]},"Rule_extend",[]]]],"RuleBody":["define",{"sourceInterval":[309,362]},null,[],["seq",{"sourceInterval":[324,362]},["opt",{"sourceInterval":[324,328]},["terminal",{"sourceInterval":[324,327]},"|"]],["app",{"sourceInterval":[329,362]},"NonemptyListOf",[["app",{"sourceInterval":[344,356]},"TopLevelTerm",[]],["terminal",{"sourceInterval":[358,361]},"|"]]]]],"TopLevelTerm_inline":["define",{"sourceInterval":[385,408]},null,[],["seq",{"sourceInterval":[385,397]},["app",{"sourceInterval":[385,388]},"Seq",[]],["app",{"sourceInterval":[389,397]},"caseName",[]]]],"TopLevelTerm":["define",{"sourceInterval":[366,418]},null,[],["alt",{"sourceInterval":[385,418]},["app",{"sourceInterval":[385,397]},"TopLevelTerm_inline",[]],["app",{"sourceInterval":[415,418]},"Seq",[]]]],"OverrideRuleBody":["define",{"sourceInterval":[422,491]},null,[],["seq",{"sourceInterval":[445,491]},["opt",{"sourceInterval":[445,449]},["terminal",{"sourceInterval":[445,448]},"|"]],["app",{"sourceInterval":[450,491]},"NonemptyListOf",[["app",{"sourceInterval":[465,485]},"OverrideTopLevelTerm",[]],["terminal",{"sourceInterval":[487,490]},"|"]]]]],"OverrideTopLevelTerm_superSplice":["define",{"sourceInterval":[522,543]},null,[],["terminal",{"sourceInterval":[522,527]},"..."]],"OverrideTopLevelTerm":["define",{"sourceInterval":[495,562]},null,[],["alt",{"sourceInterval":[522,562]},["app",{"sourceInterval":[522,527]},"OverrideTopLevelTerm_superSplice",[]],["app",{"sourceInterval":[550,562]},"TopLevelTerm",[]]]],"Formals":["define",{"sourceInterval":[566,606]},null,[],["seq",{"sourceInterval":[580,606]},["terminal",{"sourceInterval":[580,583]},"<"],["app",{"sourceInterval":[584,602]},"ListOf",[["app",{"sourceInterval":[591,596]},"ident",[]],["terminal",{"sourceInterval":[598,601]},","]]],["terminal",{"sourceInterval":[603,606]},">"]]],"Params":["define",{"sourceInterval":[610,647]},null,[],["seq",{"sourceInterval":[623,647]},["terminal",{"sourceInterval":[623,626]},"<"],["app",{"sourceInterval":[627,643]},"ListOf",[["app",{"sourceInterval":[634,637]},"Seq",[]],["terminal",{"sourceInterval":[639,642]},","]]],["terminal",{"sourceInterval":[644,647]},">"]]],"Alt":["define",{"sourceInterval":[651,685]},null,[],["app",{"sourceInterval":[661,685]},"NonemptyListOf",[["app",{"sourceInterval":[676,679]},"Seq",[]],["terminal",{"sourceInterval":[681,684]},"|"]]]],"Seq":["define",{"sourceInterval":[689,704]},null,[],["star",{"sourceInterval":[699,704]},["app",{"sourceInterval":[699,703]},"Iter",[]]]],"Iter_star":["define",{"sourceInterval":[719,736]},null,[],["seq",{"sourceInterval":[719,727]},["app",{"sourceInterval":[719,723]},"Pred",[]],["terminal",{"sourceInterval":[724,727]},"*"]]],"Iter_plus":["define",{"sourceInterval":[743,760]},null,[],["seq",{"sourceInterval":[743,751]},["app",{"sourceInterval":[743,747]},"Pred",[]],["terminal",{"sourceInterval":[748,751]},"+"]]],"Iter_opt":["define",{"sourceInterval":[767,783]},null,[],["seq",{"sourceInterval":[767,775]},["app",{"sourceInterval":[767,771]},"Pred",[]],["terminal",{"sourceInterval":[772,775]},"?"]]],"Iter":["define",{"sourceInterval":[708,794]},null,[],["alt",{"sourceInterval":[719,794]},["app",{"sourceInterval":[719,727]},"Iter_star",[]],["app",{"sourceInterval":[743,751]},"Iter_plus",[]],["app",{"sourceInterval":[767,775]},"Iter_opt",[]],["app",{"sourceInterval":[790,794]},"Pred",[]]]],"Pred_not":["define",{"sourceInterval":[809,824]},null,[],["seq",{"sourceInterval":[809,816]},["terminal",{"sourceInterval":[809,812]},"~"],["app",{"sourceInterval":[813,816]},"Lex",[]]]],"Pred_lookahead":["define",{"sourceInterval":[831,852]},null,[],["seq",{"sourceInterval":[831,838]},["terminal",{"sourceInterval":[831,834]},"&"],["app",{"sourceInterval":[835,838]},"Lex",[]]]],"Pred":["define",{"sourceInterval":[798,862]},null,[],["alt",{"sourceInterval":[809,862]},["app",{"sourceInterval":[809,816]},"Pred_not",[]],["app",{"sourceInterval":[831,838]},"Pred_lookahead",[]],["app",{"sourceInterval":[859,862]},"Lex",[]]]],"Lex_lex":["define",{"sourceInterval":[876,892]},null,[],["seq",{"sourceInterval":[876,884]},["terminal",{"sourceInterval":[876,879]},"#"],["app",{"sourceInterval":[880,884]},"Base",[]]]],"Lex":["define",{"sourceInterval":[866,903]},null,[],["alt",{"sourceInterval":[876,903]},["app",{"sourceInterval":[876,884]},"Lex_lex",[]],["app",{"sourceInterval":[899,903]},"Base",[]]]],"Base_application":["define",{"sourceInterval":[918,979]},null,[],["seq",{"sourceInterval":[918,963]},["app",{"sourceInterval":[918,923]},"ident",[]],["opt",{"sourceInterval":[924,931]},["app",{"sourceInterval":[924,930]},"Params",[]]],["not",{"sourceInterval":[932,963]},["alt",{"sourceInterval":[934,962]},["seq",{"sourceInterval":[934,948]},["opt",{"sourceInterval":[934,944]},["app",{"sourceInterval":[934,943]},"ruleDescr",[]]],["terminal",{"sourceInterval":[945,948]},"="]],["terminal",{"sourceInterval":[951,955]},":="],["terminal",{"sourceInterval":[958,962]},"+="]]]]],"Base_range":["define",{"sourceInterval":[986,1041]},null,[],["seq",{"sourceInterval":[986,1022]},["app",{"sourceInterval":[986,1001]},"oneCharTerminal",[]],["terminal",{"sourceInterval":[1002,1006]},".."],["app",{"sourceInterval":[1007,1022]},"oneCharTerminal",[]]]],"Base_terminal":["define",{"sourceInterval":[1048,1106]},null,[],["app",{"sourceInterval":[1048,1056]},"terminal",[]]],"Base_paren":["define",{"sourceInterval":[1113,1168]},null,[],["seq",{"sourceInterval":[1113,1124]},["terminal",{"sourceInterval":[1113,1116]},"("],["app",{"sourceInterval":[1117,1120]},"Alt",[]],["terminal",{"sourceInterval":[1121,1124]},")"]]],"Base":["define",{"sourceInterval":[907,1168]},null,[],["alt",{"sourceInterval":[918,1168]},["app",{"sourceInterval":[918,963]},"Base_application",[]],["app",{"sourceInterval":[986,1022]},"Base_range",[]],["app",{"sourceInterval":[1048,1056]},"Base_terminal",[]],["app",{"sourceInterval":[1113,1124]},"Base_paren",[]]]],"ruleDescr":["define",{"sourceInterval":[1172,1231]},"a rule description",[],["seq",{"sourceInterval":[1210,1231]},["terminal",{"sourceInterval":[1210,1213]},"("],["app",{"sourceInterval":[1214,1227]},"ruleDescrText",[]],["terminal",{"sourceInterval":[1228,1231]},")"]]],"ruleDescrText":["define",{"sourceInterval":[1235,1266]},null,[],["star",{"sourceInterval":[1255,1266]},["seq",{"sourceInterval":[1256,1264]},["not",{"sourceInterval":[1256,1260]},["terminal",{"sourceInterval":[1257,1260]},")"]],["app",{"sourceInterval":[1261,1264]},"any",[]]]]],"caseName":["define",{"sourceInterval":[1270,1338]},null,[],["seq",{"sourceInterval":[1285,1338]},["terminal",{"sourceInterval":[1285,1289]},"--"],["star",{"sourceInterval":[1290,1304]},["seq",{"sourceInterval":[1291,1302]},["not",{"sourceInterval":[1291,1296]},["terminal",{"sourceInterval":[1292,1296]},"\n"]],["app",{"sourceInterval":[1297,1302]},"space",[]]]],["app",{"sourceInterval":[1305,1309]},"name",[]],["star",{"sourceInterval":[1310,1324]},["seq",{"sourceInterval":[1311,1322]},["not",{"sourceInterval":[1311,1316]},["terminal",{"sourceInterval":[1312,1316]},"\n"]],["app",{"sourceInterval":[1317,1322]},"space",[]]]],["alt",{"sourceInterval":[1326,1337]},["terminal",{"sourceInterval":[1326,1330]},"\n"],["lookahead",{"sourceInterval":[1333,1337]},["terminal",{"sourceInterval":[1334,1337]},"}"]]]]],"name":["define",{"sourceInterval":[1342,1382]},"a name",[],["seq",{"sourceInterval":[1363,1382]},["app",{"sourceInterval":[1363,1372]},"nameFirst",[]],["star",{"sourceInterval":[1373,1382]},["app",{"sourceInterval":[1373,1381]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[1386,1418]},null,[],["alt",{"sourceInterval":[1402,1418]},["terminal",{"sourceInterval":[1402,1405]},"_"],["app",{"sourceInterval":[1412,1418]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[1422,1452]},null,[],["alt",{"sourceInterval":[1437,1452]},["terminal",{"sourceInterval":[1437,1440]},"_"],["app",{"sourceInterval":[1447,1452]},"alnum",[]]]],"ident":["define",{"sourceInterval":[1456,1489]},"an identifier",[],["app",{"sourceInterval":[1485,1489]},"name",[]]],"terminal":["define",{"sourceInterval":[1493,1531]},null,[],["seq",{"sourceInterval":[1508,1531]},["terminal",{"sourceInterval":[1508,1512]},"\""],["star",{"sourceInterval":[1513,1526]},["app",{"sourceInterval":[1513,1525]},"terminalChar",[]]],["terminal",{"sourceInterval":[1527,1531]},"\""]]],"oneCharTerminal":["define",{"sourceInterval":[1535,1579]},null,[],["seq",{"sourceInterval":[1557,1579]},["terminal",{"sourceInterval":[1557,1561]},"\""],["app",{"sourceInterval":[1562,1574]},"terminalChar",[]],["terminal",{"sourceInterval":[1575,1579]},"\""]]],"terminalChar":["define",{"sourceInterval":[1583,1640]},null,[],["alt",{"sourceInterval":[1602,1640]},["app",{"sourceInterval":[1602,1612]},"escapeChar",[]],["seq",{"sourceInterval":[1619,1640]},["not",{"sourceInterval":[1619,1624]},["terminal",{"sourceInterval":[1620,1624]},"\\"]],["not",{"sourceInterval":[1625,1630]},["terminal",{"sourceInterval":[1626,1630]},"\""]],["not",{"sourceInterval":[1631,1636]},["terminal",{"sourceInterval":[1632,1636]},"\n"]],["app",{"sourceInterval":[1637,1640]},"any",[]]]]],"escapeChar_backslash":["define",{"sourceInterval":[1683,1738]},null,[],["terminal",{"sourceInterval":[1683,1689]},"\\\\"]],"escapeChar_doubleQuote":["define",{"sourceInterval":[1745,1802]},null,[],["terminal",{"sourceInterval":[1745,1751]},"\\\""]],"escapeChar_singleQuote":["define",{"sourceInterval":[1809,1866]},null,[],["terminal",{"sourceInterval":[1809,1815]},"\\'"]],"escapeChar_backspace":["define",{"sourceInterval":[1873,1928]},null,[],["terminal",{"sourceInterval":[1873,1878]},"\\b"]],"escapeChar_lineFeed":["define",{"sourceInterval":[1935,1989]},null,[],["terminal",{"sourceInterval":[1935,1940]},"\\n"]],"escapeChar_carriageReturn":["define",{"sourceInterval":[1996,2056]},null,[],["terminal",{"sourceInterval":[1996,2001]},"\\r"]],"escapeChar_tab":["define",{"sourceInterval":[2063,2112]},null,[],["terminal",{"sourceInterval":[2063,2068]},"\\t"]],"escapeChar_unicodeEscape":["define",{"sourceInterval":[2119,2178]},null,[],["seq",{"sourceInterval":[2119,2160]},["terminal",{"sourceInterval":[2119,2124]},"\\u"],["app",{"sourceInterval":[2125,2133]},"hexDigit",[]],["app",{"sourceInterval":[2134,2142]},"hexDigit",[]],["app",{"sourceInterval":[2143,2151]},"hexDigit",[]],["app",{"sourceInterval":[2152,2160]},"hexDigit",[]]]],"escapeChar_hexEscape":["define",{"sourceInterval":[2185,2240]},null,[],["seq",{"sourceInterval":[2185,2208]},["terminal",{"sourceInterval":[2185,2190]},"\\x"],["app",{"sourceInterval":[2191,2199]},"hexDigit",[]],["app",{"sourceInterval":[2200,2208]},"hexDigit",[]]]],"escapeChar":["define",{"sourceInterval":[1644,2240]},"an escape sequence",[],["alt",{"sourceInterval":[1683,2240]},["app",{"sourceInterval":[1683,1689]},"escapeChar_backslash",[]],["app",{"sourceInterval":[1745,1751]},"escapeChar_doubleQuote",[]],["app",{"sourceInterval":[1809,1815]},"escapeChar_singleQuote",[]],["app",{"sourceInterval":[1873,1878]},"escapeChar_backspace",[]],["app",{"sourceInterval":[1935,1940]},"escapeChar_lineFeed",[]],["app",{"sourceInterval":[1996,2001]},"escapeChar_carriageReturn",[]],["app",{"sourceInterval":[2063,2068]},"escapeChar_tab",[]],["app",{"sourceInterval":[2119,2160]},"escapeChar_unicodeEscape",[]],["app",{"sourceInterval":[2185,2208]},"escapeChar_hexEscape",[]]]],"space":["extend",{"sourceInterval":[2244,2263]},null,[],["app",{"sourceInterval":[2256,2263]},"comment",[]]],"comment_singleLine":["define",{"sourceInterval":[2281,2327]},null,[],["seq",{"sourceInterval":[2281,2312]},["terminal",{"sourceInterval":[2281,2285]},"//"],["star",{"sourceInterval":[2286,2298]},["seq",{"sourceInterval":[2287,2296]},["not",{"sourceInterval":[2287,2292]},["terminal",{"sourceInterval":[2288,2292]},"\n"]],["app",{"sourceInterval":[2293,2296]},"any",[]]]],["lookahead",{"sourceInterval":[2299,2312]},["alt",{"sourceInterval":[2301,2311]},["terminal",{"sourceInterval":[2301,2305]},"\n"],["app",{"sourceInterval":[2308,2311]},"end",[]]]]]],"comment_multiLine":["define",{"sourceInterval":[2334,2370]},null,[],["seq",{"sourceInterval":[2334,2356]},["terminal",{"sourceInterval":[2334,2338]},"/*"],["star",{"sourceInterval":[2339,2351]},["seq",{"sourceInterval":[2340,2349]},["not",{"sourceInterval":[2340,2345]},["terminal",{"sourceInterval":[2341,2345]},"*/"]],["app",{"sourceInterval":[2346,2349]},"any",[]]]],["terminal",{"sourceInterval":[2352,2356]},"*/"]]],"comment":["define",{"sourceInterval":[2267,2370]},null,[],["alt",{"sourceInterval":[2281,2370]},["app",{"sourceInterval":[2281,2312]},"comment_singleLine",[]],["app",{"sourceInterval":[2334,2356]},"comment_multiLine",[]]]],"tokens":["define",{"sourceInterval":[2374,2389]},null,[],["star",{"sourceInterval":[2383,2389]},["app",{"sourceInterval":[2383,2388]},"token",[]]]],"token":["define",{"sourceInterval":[2393,2469]},null,[],["alt",{"sourceInterval":[2401,2469]},["app",{"sourceInterval":[2401,2409]},"caseName",[]],["app",{"sourceInterval":[2412,2419]},"comment",[]],["app",{"sourceInterval":[2422,2427]},"ident",[]],["app",{"sourceInterval":[2430,2438]},"operator",[]],["app",{"sourceInterval":[2441,2452]},"punctuation",[]],["app",{"sourceInterval":[2455,2463]},"terminal",[]],["app",{"sourceInterval":[2466,2469]},"any",[]]]],"operator":["define",{"sourceInterval":[2473,2538]},null,[],["alt",{"sourceInterval":[2484,2538]},["terminal",{"sourceInterval":[2484,2488]},"<:"],["terminal",{"sourceInterval":[2491,2494]},"="],["terminal",{"sourceInterval":[2497,2501]},":="],["terminal",{"sourceInterval":[2504,2508]},"+="],["terminal",{"sourceInterval":[2511,2514]},"*"],["terminal",{"sourceInterval":[2517,2520]},"+"],["terminal",{"sourceInterval":[2523,2526]},"?"],["terminal",{"sourceInterval":[2529,2532]},"~"],["terminal",{"sourceInterval":[2535,2538]},"&"]]],"punctuation":["define",{"sourceInterval":[2542,2578]},null,[],["alt",{"sourceInterval":[2556,2578]},["terminal",{"sourceInterval":[2556,2559]},"<"],["terminal",{"sourceInterval":[2562,2565]},">"],["terminal",{"sourceInterval":[2568,2571]},","],["terminal",{"sourceInterval":[2574,2578]},"--"]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/operations-and-attributes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ohm-js/dist/operations-and-attributes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = \"(\" ListOf<name, \",\"> \")\"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n}"},"OperationsAndAttributes",null,"AttributeSignature",{"AttributeSignature":["define",{"sourceInterval":[29,58]},null,[],["app",{"sourceInterval":[54,58]},"name",[]]],"OperationSignature":["define",{"sourceInterval":[62,100]},null,[],["seq",{"sourceInterval":[87,100]},["app",{"sourceInterval":[87,91]},"name",[]],["opt",{"sourceInterval":[92,100]},["app",{"sourceInterval":[92,99]},"Formals",[]]]]],"Formals":["define",{"sourceInterval":[104,143]},null,[],["seq",{"sourceInterval":[118,143]},["terminal",{"sourceInterval":[118,121]},"("],["app",{"sourceInterval":[122,139]},"ListOf",[["app",{"sourceInterval":[129,133]},"name",[]],["terminal",{"sourceInterval":[135,138]},","]]],["terminal",{"sourceInterval":[140,143]},")"]]],"name":["define",{"sourceInterval":[147,187]},"a name",[],["seq",{"sourceInterval":[168,187]},["app",{"sourceInterval":[168,177]},"nameFirst",[]],["star",{"sourceInterval":[178,187]},["app",{"sourceInterval":[178,186]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[191,223]},null,[],["alt",{"sourceInterval":[207,223]},["terminal",{"sourceInterval":[207,210]},"_"],["app",{"sourceInterval":[217,223]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[227,257]},null,[],["alt",{"sourceInterval":[242,257]},["terminal",{"sourceInterval":[242,245]},"_"],["app",{"sourceInterval":[252,257]},"alnum",[]]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/extras/VisitorFamily.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/extras/VisitorFamily.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ../src/common */ "./node_modules/ohm-js/src/common.js").assert;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Helpers

function getProp(name, thing, fn) {
  return fn(thing[name]);
}

function mapProp(name, thing, fn) {
  return thing[name].map(fn);
}

// Returns a function that will walk a single property of a node.
// `descriptor` is a string indicating the property name, optionally ending
// with '[]' (e.g., 'children[]').
function getPropWalkFn(descriptor) {
  const parts = descriptor.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor);
}

function getProps(walkFns, thing, fn) {
  return walkFns.map(walkFn => walkFn(thing, fn));
}

function getWalkFn(shape) {
  if (typeof shape === 'string') {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === 'function', 'Expected a string, Array, or function');
    assert(shape.length === 2, 'Expected a function of arity 2, got ' + shape.length);
    return shape;
  }
}

function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}

function trim(s) {
  return s.trim();
}

function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === '') {
    const name = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(',').map(trim);
    }
    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {
      return {name, formals: params};
    }
  }
  throw new Error('Invalid operation signature: ' + sig);
}

/*
  A VisitorFamily contains a set of recursive operations that are defined over some kind of
  tree structure. The `config` parameter specifies how to walk the tree:
  - 'getTag' is function which, given a node in the tree, returns the node's 'tag' (type)
  - 'shapes' an object that maps from a tag to a value that describes how to recursively
    evaluate the operation for nodes of that type. The value can be:
    * a string indicating the property name that holds that node's only child
    * an Array of property names (or an empty array indicating a leaf type), or
    * a function taking two arguments (node, fn), and returning an Array which is the result
      of apply `fn` to each of the node's children.
 */
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;

  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error('heeey!');
  };
  this.operations = {};

  this._arities = Object.create(null);
  this._getChildren = Object.create(null);

  const self = this;
  Object.keys(this._shapes).forEach(k => {
    const shape = self._shapes[k];
    self._getChildren[k] = getWalkFn(shape);

    // A function means the arity isn't fixed, so don't put an entry in the arity map.
    if (typeof shape !== 'function') {
      self._arities[k] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = function(thing) { return new self.Adapter(thing, self); };
}

VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};

VisitorFamily.prototype._checkActionDict = function(dict) {
  const self = this;
  Object.keys(dict).forEach(k => {
    assert(k in self._getChildren, "Unrecognized action name '" + k + "'");
    const action = dict[k];
    assert(typeof action === 'function', "Key '" + k + "': expected function, got " + action);
    if (k in self._arities) {
      const expected = self._arities[k];
      const actual = dict[k].length;
      assert(actual === expected,
          "Action '" + k + "' has the wrong arity: expected " + expected + ', got ' + actual);
    }
  });
};

VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const name = sig.name;
  this._checkActionDict(actions);
  this.operations[name] = {
    name,
    formals: sig.formals,
    actions
  };

  const family = this;
  this.Adapter.prototype[name] = function() {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name + "'");

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let i = 0; i < arguments.length; i++) {
      args[sig.formals[i]] = arguments[i];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = actions[tag].apply(this, family._getChildren[tag](this._adaptee, family._wrap));
    this.args = oldArgs;
    return ans;
  };
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = VisitorFamily;


/***/ }),

/***/ "./node_modules/ohm-js/extras/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/extras/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  VisitorFamily: __webpack_require__(/*! ./VisitorFamily */ "./node_modules/ohm-js/extras/VisitorFamily.js"),
  semanticsForToAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").semantics,
  toAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").helper
};


/***/ }),

/***/ "./node_modules/ohm-js/extras/semantics-toAST.js":
/*!*******************************************************!*\
  !*** ./node_modules/ohm-js/extras/semantics-toAST.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ../src/pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const MatchResult = __webpack_require__(/*! ../src/MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const Grammar = __webpack_require__(/*! ../src/Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

const defaultOperation = {
  _terminal() {
    return this.primitiveValue;
  },

  _nonterminal(children) {
    const ctorName = this._node.ctorName;
    const mapping = this.args.mapping;

    // without customization
    if (!mapping.hasOwnProperty(ctorName)) {
      // intermediate node
      if (this._node instanceof pexprs.Alt || this._node instanceof pexprs.Apply) {
        return children[0].toAST(mapping);
      }

      // lexical rule
      if (this.isLexical()) {
        return this.sourceString;
      }

      // singular node (e.g. only surrounded by literals or lookaheads)
      const realChildren = children.filter(child => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }

      // rest: terms with multiple children
    }

    // direct forward
    if (typeof mapping[ctorName] === 'number') {
      return children[mapping[ctorName]].toAST(mapping);
    }

    // named/mapped children or unnamed children ('0', '1', '2', ...)
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === 'number') {
        // direct forward
        node[prop] = children[mappedProp].toAST(mapping);
      } else if ((typeof mappedProp === 'string') || (typeof mappedProp === 'boolean') ||
          (mappedProp === null)) {
        // primitive value
        node[prop] = mappedProp;
      } else if ((typeof mappedProp === 'object') && (mappedProp instanceof Number)) {
        // primitive number (must be unboxed)
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === 'function') {
        // computed value
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === undefined) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          // delete predefined 'type' properties, like 'type', if explicitely removed
          delete node[prop];
        }
      }
    }
    return node;
  },

  _iter(children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }

    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },

  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },

  EmptyListOf() {
    return [];
  }
};

// Returns a plain JavaScript object that includes an abstract syntax tree (AST)
// for the given match result `res` containg a concrete syntax tree (CST) and grammar.
// The optional `mapping` parameter can be used to customize how the nodes of the CST
// are mapped to the AST (see /doc/extras.md#toastmatchresult-mapping).
function toAST(res, mapping) {
  if (!(res instanceof MatchResult) || res.failed()) {
    throw new Error('toAST() expects a succesfull MatchResult as first parameter');
  }

  mapping = extend({}, mapping);
  const operation = extend({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === 'function') {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g = res._cst.grammar;
  const s = g.createSemantics().addOperation('toAST(mapping)', operation);
  return s(res).toAST(mapping);
}

// Returns a semantics containg the toAST(mapping) operation for the given grammar g.
function semanticsForToAST(g) {
  if (!(g instanceof Grammar)) {
    throw new Error('semanticsToAST() expects a Grammar as parameter');
  }

  return g.createSemantics().addOperation('toAST(mapping)', defaultOperation);
}

module.exports = {
  helper: toAST,
  semantics: semanticsForToAST
};


/***/ }),

/***/ "./node_modules/ohm-js/node_modules/is-buffer/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ohm-js/node_modules/is-buffer/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "./node_modules/ohm-js/package.json":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/package.json ***!
  \******************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bin, bugs, contributors, dependencies, description, devDependencies, engines, homepage, keywords, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_args\":[[\"ohm-js@15.4.1\",\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\"]],\"_from\":\"ohm-js@15.4.1\",\"_id\":\"ohm-js@15.4.1\",\"_inBundle\":false,\"_integrity\":\"sha512-ob5b6hnlg6tR73Zxd8ON/MQND36SgEDbKQYrzdDVVyTNa3d3aJ/YyobB7mItJ8YXNTZGgZ/eUiLtfo2CU0uREA==\",\"_location\":\"/ohm-js\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"ohm-js@15.4.1\",\"name\":\"ohm-js\",\"escapedName\":\"ohm-js\",\"rawSpec\":\"15.4.1\",\"saveSpec\":null,\"fetchSpec\":\"15.4.1\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/ohm-js/-/ohm-js-15.4.1.tgz\",\"_spec\":\"15.4.1\",\"_where\":\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\",\"author\":{\"name\":\"Alex Warth\",\"email\":\"alexwarth@gmail.com\",\"url\":\"http://tinlizzie.org/~awarth\"},\"bin\":{\"ohm-js\":\"src/ohm-cmd.js\"},\"bugs\":{\"url\":\"https://github.com/harc/ohm/issues\"},\"contributors\":[{\"name\":\"Patrick Dubroy\",\"email\":\"pdubroy@gmail.com\"},{\"name\":\"Meixian Li\",\"email\":\"lmeixian@gmail.com\"},{\"name\":\"Marko Rder\",\"email\":\"m.roeder@photon-software.de\"},{\"name\":\"Tony Garnock-Jones\",\"email\":\"tonygarnockjones@gmail.com\"},{\"name\":\"Saketh Kasibatla\",\"email\":\"sake.kasi@gmail.com\"},{\"name\":\"Lionel Landwerlin\",\"email\":\"llandwerlin@gmail.com\"},{\"name\":\"Jason Merrill\",\"email\":\"jwmerrill@gmail.com\"},{\"name\":\"Ray Toal\",\"email\":\"rtoal@lmu.edu\"},{\"name\":\"Yoshiki Ohshima\",\"email\":\"Yoshiki.Ohshima@acm.org\"},{\"name\":\"stagas\",\"email\":\"gstagas@gmail.com\"},{\"name\":\"Jonathan Edwards\",\"email\":\"JonathanMEdwards@gmail.com\"},{\"name\":\"Neil Jewers\",\"email\":\"njjewers@uwaterloo.ca\"},{\"name\":\"Mike Niebling\",\"email\":\"(none)\",\"url\":\"none\"},{\"name\":\"Arthur Carabott\",\"email\":\"arthurc@gmail.com\"},{\"name\":\"AngryPowman\",\"email\":\"angrypowman@qq.com\"},{\"name\":\"Luca Guzzon\",\"email\":\"luca.guzzon@gmail.com\"},{\"name\":\"Leslie Ying\",\"email\":\"acetophore@users.noreply.github.com\"},{\"name\":\"Stan Rozenraukh\",\"email\":\"stan@stanistan.com\"},{\"name\":\"Stephan Seidt\",\"email\":\"stephan.seidt@gmail.com\"},{\"name\":\"Thomas Nyberg\",\"email\":\"tomnyberg@gmail.com\"},{\"name\":\"Justin Chase\",\"email\":\"justin.m.chase@gmail.com\"},{\"name\":\"Vse Mozhet Byt\",\"email\":\"vsemozhetbyt@gmail.com\"},{\"name\":\"Wil Chung\",\"email\":\"10446+iamwilhelm@users.noreply.github.com\"},{\"name\":\"Daniel Tomlinson\",\"email\":\"DanielTomlinson@me.com\"},{\"name\":\"abego\",\"email\":\"ub@abego-software.de\"},{\"name\":\"acslk\",\"email\":\"d_vd415@hotmail.com\"},{\"name\":\"codeZeilen\",\"email\":\"codeZeilen@users.noreply.github.com\"},{\"name\":\"owch\",\"email\":\"bowenrainyday@gmail.com\"},{\"name\":\"sfinnie\",\"email\":\"scott.finnie@gmail.com\"},{\"name\":\"Milan Lajto\",\"email\":\"milan.lajtos@me.com\"}],\"dependencies\":{\"is-buffer\":\"^2.0.4\",\"util-extend\":\"^1.0.3\"},\"description\":\"An object-oriented language for parsing and pattern matching\",\"devDependencies\":{\"@types/tape\":\"^4.13.0\",\"eslint\":\"^7.9.0\",\"eslint-config-google\":\"^0.14.0\",\"eslint-plugin-camelcase-ohm\":\"^0.2.1\",\"eslint-plugin-no-extension-in-require\":\"^0.2.0\",\"eslint-plugin-tape\":\"^1.1.0\",\"husky\":\"^4.2.5\",\"jsdom\":\"^9.9.1\",\"json\":\"^9.0.6\",\"markscript\":\"^0.5.0\",\"node-static\":\"^0.7.11\",\"nodemon\":\"^2.0.4\",\"ohm-grammar-ecmascript\":\"^0.5.0\",\"tap-spec\":\"^5.0.0\",\"tape\":\"^5.0.1\",\"tape-catch\":\"^1.0.6\",\"ts-loader\":\"^8.0.4\",\"ts-node\":\"^9.0.0\",\"typescript\":\"^4.0.3\",\"walk-sync\":\"^2.2.0\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^3.3.12\"},\"engines\":{\"node\":\">=0.12.1\"},\"homepage\":\"https://ohmlang.github.io/\",\"keywords\":[\"parser\",\"compiler\",\"pattern matching\",\"pattern-matching\",\"ometa\",\"ometa/js\",\"ometa-js\",\"ometajs\",\"rapid\",\"prototyping\"],\"license\":\"MIT\",\"main\":\"src/main.js\",\"name\":\"ohm-js\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/harc/ohm.git\"},\"scripts\":{\"bootstrap\":\"bash bin/bootstrap --test || (echo 'Bootstrap failed.' && mv -v dist/ohm-grammar.js.old dist/ohm-grammar.js && mv -v dist/built-in-rules.js.old dist/built-in-rules.js && mv -v dist/operations-and-attributes.js.old dist/operations-and-attributes.js)\",\"build\":\"yarn build-debug && webpack --mode=production\",\"build-debug\":\"webpack --mode=development\",\"clean\":\"rm -f dist/ohm.js dist/ohm.min.js\",\"lint\":\"eslint . --ignore-path ../.eslintignore\",\"postinstall\":\"node bin/dev-setup.js\",\"postpublish\":\"rm README.md\",\"pre-commit\":\"yarn run lint && yarn run build && yarn run test\",\"prebootstrap\":\"bash bin/prebootstrap\",\"prebuild-debug\":\"bash ../bin/update-env.sh\",\"prepublishOnly\":\"cp ../README.md .\",\"pretest\":\"bash ../bin/update-env.sh\",\"test\":\"(tape 'test/**/*.js' | tap-spec) && ts-node test/test-typings.ts\",\"test-watch\":\"bash bin/test-watch\",\"unsafe-bootstrap\":\"bash bin/bootstrap\",\"version-package\":\"bash bin/version\",\"watch\":\"webpack --mode=development --watch\"},\"types\":\"index.d.ts\",\"version\":\"15.4.1\"}");

/***/ }),

/***/ "./node_modules/ohm-js/src/Builder.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Builder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const GrammarDecl = __webpack_require__(/*! ./GrammarDecl */ "./node_modules/ohm-js/src/GrammarDecl.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Builder() {}

Builder.prototype = {
  currentDecl: null,
  currentRuleName: null,

  newGrammar(name) {
    return new GrammarDecl(name);
  },

  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name);
    if (superGrammar) {
      gDecl.withSuperGrammar(this.fromRecipe(superGrammar));
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }

    this.currentDecl = gDecl;
    Object.keys(rules).forEach(ruleName => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];

      const action = ruleRecipe[0]; // define/extend/override
      const metaInfo = ruleRecipe[1];
      const description = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);

      let source;
      if (gDecl.source && metaInfo && metaInfo.sourceInterval) {
        source = gDecl.source.subInterval(
            metaInfo.sourceInterval[0],
            metaInfo.sourceInterval[1] - metaInfo.sourceInterval[0]);
      }
      gDecl[action](ruleName, formals, body, description, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },

  terminal(x) {
    return new pexprs.Terminal(x);
  },

  range(from, to) {
    return new pexprs.Range(from, to);
  },

  param(index) {
    return new pexprs.Param(index);
  },

  alt(/* term1, term2, ... */) {
    let terms = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs.Alt(terms);
  },

  seq(/* factor1, factor2, ... */) {
    let factors = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs.Seq(factors);
  },

  star(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Star(expr);
  },

  plus(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Plus(expr);
  },

  opt(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Opt(expr);
  },

  not(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Not(expr);
  },

  la(expr) {
    // TODO: temporary to still be able to read old recipes
    return this.lookahead(expr);
  },

  lookahead(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lookahead(expr);
  },

  lex(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lex(expr);
  },

  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs.PExpr ? param :
          this.fromRecipe(param);
      }, this);
    }
    return new pexprs.Apply(ruleName, optParams);
  },

  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs.Splice(
        this.currentDecl.superGrammar,
        this.currentRuleName,
        beforeTerms.map(term => this.fromRecipe(term)),
        afterTerms.map(term => this.fromRecipe(term)));
  },

  fromRecipe(recipe) {
    // the meta-info of 'grammar' is processed in Builder.grammar
    const result = this[recipe[0]].apply(this,
      recipe[0] === 'grammar' ? recipe.slice(1) : recipe.slice(2));

    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(
            this.currentDecl.sourceInterval.apply(this.currentDecl, metaInfo.sourceInterval)
        );
      }
    }
    return result;
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Builder;


/***/ }),

/***/ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/CaseInsensitiveTerminal.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const TerminalNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").TerminalNode;
const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const {PExpr, Terminal} = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

class CaseInsensitiveTerminal extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }

  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert(terminal instanceof Terminal, 'expected a Terminal expression');
    return terminal.obj;
  }

  // Implementation of the PExpr API

  allowsSkippingPrecedingSpace() {
    return true;
  }

  eval(state) {
    const inputStream = state.inputStream;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(state.grammar, matchStr), origPos);
      return true;
    }
  }

  generateExample(grammar, examples, inSyntacticContext, actuals) {
    // Start with a example generated from the Terminal...
    const str = this.obj.generateExample(grammar, examples, inSyntacticContext, actuals).value;

    // ...and randomly switch characters to uppercase/lowercase.
    let value = '';
    for (let i = 0; i < str.length; ++i) {
      value += Math.random() < 0.5 ? str[i].toLocaleLowerCase() : str[i].toLocaleUpperCase();
    }
    return {value};
  }

  getArity() {
    return 1;
  }

  substituteParams(actuals) {
    return new CaseInsensitiveTerminal(this.obj.substituteParams(actuals));
  }

  toDisplayString() {
    return this.obj.toDisplayString() + ' (case-insensitive)';
  }

  toFailure(grammar) {
    return new Failure(this, this.obj.toFailure(grammar) + ' (case-insensitive)', 'description');
  }

  _isNullable(grammar, memo) {
    return this.obj._isNullable(grammar, memo);
  }
}

module.exports = CaseInsensitiveTerminal;


/***/ }),

/***/ "./node_modules/ohm-js/src/Failure.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Failure.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

/*
  `Failure`s represent expressions that weren't matched while parsing. They are used to generate
  error messages automatically. The interface of `Failure`s includes the collowing methods:

  - getText() : String
  - getType() : String  (one of {"description", "string", "code"})
  - isDescription() : bool
  - isStringTerminal() : bool
  - isCode() : bool
  - isFluffy() : bool
  - makeFluffy() : void
  - subsumes(Failure) : bool
*/

function isValidType(type) {
  return type === 'description' || type === 'string' || type === 'code';
}

function Failure(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error('invalid Failure type: ' + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}

Failure.prototype.getPExpr = function() {
  return this.pexpr;
};

Failure.prototype.getText = function() {
  return this.text;
};

Failure.prototype.getType = function() {
  return this.type;
};

Failure.prototype.isDescription = function() {
  return this.type === 'description';
};

Failure.prototype.isStringTerminal = function() {
  return this.type === 'string';
};

Failure.prototype.isCode = function() {
  return this.type === 'code';
};

Failure.prototype.isFluffy = function() {
  return this.fluffy;
};

Failure.prototype.makeFluffy = function() {
  this.fluffy = true;
};

Failure.prototype.clearFluffy = function() {
  this.fluffy = false;
};

Failure.prototype.subsumes = function(that) {
  return this.getText() === that.getText() &&
      this.type === that.type &&
      (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};

Failure.prototype.toString = function() {
  return this.type === 'string' ?
    JSON.stringify(this.getText()) :
    this.getText();
};

Failure.prototype.clone = function() {
  const failure = new Failure(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};

Failure.prototype.toKey = function() {
  return this.toString() + '#' + this.type;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Failure;


/***/ }),

/***/ "./node_modules/ohm-js/src/Grammar.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Grammar.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const CaseInsensitiveTerminal = __webpack_require__(/*! ./CaseInsensitiveTerminal */ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js");
const Matcher = __webpack_require__(/*! ./Matcher */ "./node_modules/ohm-js/src/Matcher.js");
const Semantics = __webpack_require__(/*! ./Semantics */ "./node_modules/ohm-js/src/Semantics.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getSortedRuleValues(grammar) {
  return Object.keys(grammar.rules).sort().map(name => grammar.rules[name]);
}

function Grammar(
    name,
    superGrammar,
    rules,
    optDefaultStartRule) {
  this.name = name;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error("Invalid start rule: '" + optDefaultStartRule +
                      "' is not a rule in grammar '" + name + "'");
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}

let ohmGrammar;
let buildGrammar;

// This method is called from main.js once Ohm has loaded.
Grammar.initApplicationParser = function(grammar, builderFn) {
  ohmGrammar = grammar;
  buildGrammar = builderFn;
};

Grammar.prototype = {
  matcher() {
    return new Matcher(this);
  },

  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;
  },

  equals(g) {
    if (this === g) {
      return true;
    }
    // Do the cheapest comparisons first.
    if (g == null ||
        this.name !== g.name ||
        this.defaultStartRule !== g.defaultStartRule ||
        !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description &&
             rule.formals.join(',') === otherRules[i].formals.join(',') &&
             rule.body.toString() === otherRules[i].body.toString();
    });
  },

  match(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.match(optStartApplication);
  },

  trace(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.trace(optStartApplication);
  },

  semantics() {
    // TODO: Remove this eventually! Deprecated in v0.12.
    throw new Error('semantics() is deprecated -- use createSemantics() instead.');
  },

  createSemantics() {
    return Semantics.createSemantics(this);
  },

  extendSemantics(superSemantics) {
    return Semantics.createSemantics(this, superSemantics._getSemantics());
  },

  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name, actionDict) {
    function isSpecialAction(a) {
      return a === '_iter' || a === '_terminal' || a === '_nonterminal' || a === '_default';
    }

    const problems = [];
    for (const k in actionDict) {
      const v = actionDict[k];
      if (!isSpecialAction(k) && !(k in this.rules)) {
        problems.push("'" + k + "' is not a valid semantic action for '" + this.name + "'");
      } else if (typeof v !== 'function') {
        problems.push(
            "'" + k + "' must be a function in an action dictionary for '" + this.name + "'");
      } else {
        const actual = v.length;
        const expected = this._topDownActionArity(k);
        if (actual !== expected) {
          problems.push(
              "Semantic action '" + k + "' has the wrong arity: " +
              'expected ' + expected + ', got ' + actual);
        }
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map(problem => '- ' + problem);
      const error = new Error(
          "Found errors in the action dictionary of the '" + name + "' " + what + ':\n' +
          prettyProblems.join('\n'));
      error.problems = problems;
      throw error;
    }
  },

  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    if (actionName === '_iter' || actionName === '_nonterminal' || actionName === '_default') {
      return 1;
    } else if (actionName === '_terminal') {
      return 0;
    }
    return this.rules[actionName].body.getArity();
  },

  _inheritsFrom(grammar) {
    let g = this.superGrammar;
    while (g) {
      if (g.equals(grammar, true)) {
        return true;
      }
      g = g.superGrammar;
    }
    return false;
  },

  toRecipe(optVarName) {
    const metaInfo = {};
    // Include the grammar source if it is available.
    if (this.source) {
      metaInfo.source = this.source.contents;
    }

    let superGrammar = null;
    if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammar = JSON.parse(this.superGrammar.toRecipe());
    }

    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }

    const rules = {};
    const self = this;
    Object.keys(this.rules).forEach(ruleName => {
      const ruleInfo = self.rules[ruleName];
      const body = ruleInfo.body;
      const isDefinition = !self.superGrammar || !self.superGrammar.rules[ruleName];

      let operation;
      if (isDefinition) {
        operation = 'define';
      } else {
        operation = body instanceof pexprs.Extend ? 'extend' : 'override';
      }

      const metaInfo = {};
      if (ruleInfo.source && self.source) {
        const adjusted = ruleInfo.source.relativeTo(self.source);
        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }

      const description = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, self.source);

      rules[ruleName] = [
        operation, // "define"/"extend"/"override"
        metaInfo,
        description,
        ruleInfo.formals,
        bodyRecipe
      ];
    });

    return JSON.stringify([
      'grammar',
      metaInfo,
      this.name,
      superGrammar,
      startRule,
      rules
    ]);
  },

  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },

  _toOperationOrAttributeActionDictionaryTemplate() {
    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus
    // should appear next to other cases of AddExpr.

    const sb = new common.StringBuffer();
    sb.append('{');

    let first = true;
    for (const ruleName in this.rules) {
      const body = this.rules[ruleName].body;
      if (first) {
        first = false;
      } else {
        sb.append(',');
      }
      sb.append('\n');
      sb.append('  ');
      this.addSemanticActionTemplate(ruleName, body, sb);
    }

    sb.append('\n}');
    return sb.contents();
  },

  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(': function(');
    const arity = this._topDownActionArity(ruleName);
    sb.append(common.repeat('_', arity).join(', '));
    sb.append(') {\n');
    sb.append('  }');
  },

  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf('<') === -1) {
      // simple application
      app = new pexprs.Apply(str);
    } else {
      // parameterized application
      const cst = ohmGrammar.match(str, 'Base_application');
      app = buildGrammar(cst, {});
    }

    // Ensure that the application is valid.
    if (!(app.ruleName in this.rules)) {
      throw errors.undeclaredRule(app.ruleName, this.name);
    }
    const formals = this.rules[app.ruleName].formals;
    if (formals.length !== app.args.length) {
      const source = this.rules[app.ruleName].source;
      throw errors.wrongNumberOfParameters(app.ruleName, formals.length, app.args.length, source);
    }
    return app;
  }
};

// The following grammar contains a few rules that couldn't be written  in "userland".
// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called
// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and
// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar
// isn't specified.
Grammar.ProtoBuiltInRules = new Grammar(
    'ProtoBuiltInRules', // name
    undefined, // supergrammar
    {
      any: {
        body: pexprs.any,
        formals: [],
        description: 'any character',
        primitive: true
      },
      end: {
        body: pexprs.end,
        formals: [],
        description: 'end of input',
        primitive: true
      },

      caseInsensitive: {
        body: new CaseInsensitiveTerminal(new pexprs.Param(0)),
        formals: ['str'],
        primitive: true
      },
      lower: {
        body: new pexprs.UnicodeChar('Ll'),
        formals: [],
        description: 'a lowercase letter',
        primitive: true
      },
      upper: {
        body: new pexprs.UnicodeChar('Lu'),
        formals: [],
        description: 'an uppercase letter',
        primitive: true
      },
      // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
      unicodeLtmo: {
        body: new pexprs.UnicodeChar('Ltmo'),
        formals: [],
        description: 'a Unicode character in Lt, Lm, or Lo',
        primitive: true
      },

      // These rules are not truly primitive (they could be written in userland) but are defined
      // here for bootstrapping purposes.
      spaces: {
        body: new pexprs.Star(new pexprs.Apply('space')),
        formals: []
      },
      space: {
        body: new pexprs.Range('\x00', ' '),
        formals: [],
        description: 'a space'
      }
    }
);

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Grammar;


/***/ }),

/***/ "./node_modules/ohm-js/src/GrammarDecl.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/GrammarDecl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Constructors

function GrammarDecl(name) {
  this.name = name;
}

// Helpers

GrammarDecl.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};

GrammarDecl.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
        // TODO: The conditional expression below is an ugly hack. It's kind of ok because
        // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
        // we should try to find a better way to do this.
        this.name === 'BuiltInRules' ?
            Grammar.ProtoBuiltInRules :
            Grammar.BuiltInRules);
  }
  return this.superGrammar;
};

GrammarDecl.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
  }
  return ruleInfo;
};

GrammarDecl.prototype.installOverriddenOrExtendedRule = function(name, formals, body, source) {
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
  }
  return this.install(name, formals, body, ruleInfo.description, source);
};

GrammarDecl.prototype.install = function(name, formals, body, description, source) {
  this.rules[name] = {
    body: body.introduceParams(formals),
    formals,
    description,
    source
  };
  return this;
};

// Stuff that you should only do once

GrammarDecl.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error('the super grammar of a GrammarDecl cannot be set more than once');
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);

  // Grammars with an explicit supergrammar inherit a default start rule.
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};

GrammarDecl.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};

GrammarDecl.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};

// Creates a Grammar instance, and if it passes the sanity checks, returns it.
GrammarDecl.prototype.build = function() {
  const grammar = new Grammar(
      this.name,
      this.ensureSuperGrammar(),
      this.rules,
      this.defaultStartRule);

  // TODO: change the pexpr.prototype.assert... methods to make them add
  // exceptions to an array that's provided as an arg. Then we'll be able to
  // show more than one error of the same type at a time.
  // TODO: include the offending pexpr in the errors, that way we can show
  // the part of the source that caused it.
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar.rules).forEach(ruleName => {
    const body = grammar.rules[ruleName].body;
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    // The following check can only be done if the grammar has no invalid applications.
    Object.keys(grammar.rules).forEach(ruleName => {
      const body = grammar.rules[ruleName].body;
      try {
        body.assertIteratedExprsAreNotNullable(grammar, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar.source = this.source;
  }

  return grammar;
};

// Rule declarations

GrammarDecl.prototype.define = function(name, formals, body, description, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
  } else if (this.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.name, source);
  }
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  return this.install(name, formals, body, description, source);
};

GrammarDecl.prototype.override = function(name, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name, source);
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

GrammarDecl.prototype.extend = function(name, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
  }
  const body = new pexprs.Extend(this.superGrammar, name, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = GrammarDecl;


/***/ }),

/***/ "./node_modules/ohm-js/src/InputStream.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/InputStream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function InputStream(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}

InputStream.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },

  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },

  matchString(s, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      /*
        Case-insensitive comparison is a tricky business. Some notable gotchas include the
        "Turkish I" problem (http://www.i18nguy.com/unicode/turkish-i18n.html) and the fact
        that the German Esszet () turns into "SS" in upper case.

        This is intended to be a locale-invariant comparison, which means it may not obey
        locale-specific expectations (e.g. "i" => "").
       */
      for (idx = 0; idx < s.length; idx++) {
        const actual = this.next();
        const expected = s[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    // Default is case-sensitive comparison.
    for (idx = 0; idx < s.length; idx++) {
      if (this.next() !== s[idx]) { return false; }
    }
    return true;
  },

  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },

  interval(startIdx, optEndIdx) {
    return new Interval(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = InputStream;


/***/ }),

/***/ "./node_modules/ohm-js/src/Interval.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/src/Interval.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Interval(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}

Interval.coverage = function(/* interval1, interval2, ... */) {
  const sourceString = arguments[0].sourceString;
  let startIdx = arguments[0].startIdx;
  let endIdx = arguments[0].endIdx;
  for (let idx = 1; idx < arguments.length; idx++) {
    const interval = arguments[idx];
    if (interval.sourceString !== sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, arguments[idx].startIdx);
      endIdx = Math.max(endIdx, arguments[idx].endIdx);
    }
  }
  return new Interval(sourceString, startIdx, endIdx);
};

Interval.prototype = {
  coverageWith(/* interval1, interval2, ... */) {
    const intervals = Array.prototype.slice.call(arguments);
    intervals.push(this);
    return Interval.coverage.apply(undefined, intervals);
  },

  collapsedLeft() {
    return new Interval(this.sourceString, this.startIdx, this.startIdx);
  },

  collapsedRight() {
    return new Interval(this.sourceString, this.endIdx, this.endIdx);
  },

  getLineAndColumn() {
    return util.getLineAndColumn(this.sourceString, this.startIdx);
  },

  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },

  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      // `this` and `that` are the same interval!
      return [
      ];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      // `that` splits `this` into two intervals
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx),
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      // `that` contains a prefix of `this`
      return [
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      // `that` contains a suffix of `this`
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx)
      ];
    } else {
      // `that` and `this` do not overlap
      return [
        this
      ];
    }
  },

  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    }
    assert(this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
        'other interval does not cover this one');
    return new Interval(this.sourceString,
        this.startIdx - that.startIdx,
        this.endIdx - that.startIdx);
  },

  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends. (This only makes sense when
  // the input stream is a string.)
  trimmed() {
    const contents = this.contents;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval(this.sourceString, startIdx, endIdx);
  },

  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval(this.sourceString, newStartIdx, newStartIdx + len);
  }
};

Object.defineProperties(Interval.prototype, {
  contents: {
    get() {
      if (this._contents === undefined) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() { return this.endIdx - this.startIdx; },
    enumerable: true
  }
});

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Interval;



/***/ }),

/***/ "./node_modules/ohm-js/src/MatchResult.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/MatchResult.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function MatchResult(
    matcher,
    input,
    startExpr,
    cst,
    cstOffset,
    rightmostFailurePosition,
    optRecordedFailures) {

  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;

  if (this.failed()) {
    common.defineLazyProperty(this, 'message', function() {
      const detail = 'Expected ' + this.getExpectedText();
      return util.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common.defineLazyProperty(this, 'shortMessage', function() {
      const detail = 'expected ' + this.getExpectedText();
      const errorInfo = util.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;
    });
  }
}

MatchResult.prototype.succeeded = function() {
  return !!this._cst;
};

MatchResult.prototype.failed = function() {
  return !this.succeeded();
};

MatchResult.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};

MatchResult.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures =
        this.matcher._match(this.startExpr, false, this.getRightmostFailurePosition());
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};

MatchResult.prototype.toString = function() {
  return this.succeeded() ?
      '[match succeeded]' :
      '[match failed at position ' + this.getRightmostFailurePosition() + ']';
};

// Return a string summarizing the expected contents of the input stream when
// the match failure occurred.
MatchResult.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error('cannot get expected text of a successful MatchResult');
  }

  const sb = new common.StringBuffer();
  let failures = this.getRightmostFailures();

  // Filter out the fluffy failures to make the default error messages more useful
  failures = failures.filter(failure => !failure.isFluffy());

  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ', or ' : ' or ');
      } else {
        sb.append(', ');
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};

MatchResult.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchResult;


/***/ }),

/***/ "./node_modules/ohm-js/src/MatchState.js":
/*!***********************************************!*\
  !*** ./node_modules/ohm-js/src/MatchState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const PosInfo = __webpack_require__(/*! ./PosInfo */ "./node_modules/ohm-js/src/PosInfo.js");
const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const applySpaces = new pexprs.Apply('spaces');

function MatchState(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;

  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream(matcher.input);
  this.memoTable = matcher.memoTable;

  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];

  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];

  if (optPositionToRecordFailures !== undefined) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = Object.create(null);
  }
}

MatchState.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },

  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },

  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();

    this.rightmostFailurePosition = Math.max(
        this.rightmostFailurePosition,
        this._rightmostFailurePositionStack.pop());

    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },

  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },

  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },

  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },

  inSyntacticContext() {
    if (typeof this.inputStream.source !== 'string') {
      return false;
    }
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      // The top-level context is syntactic if the start application is.
      return this.startExpr.factors[0].isSyntactic();
    }
  },

  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },

  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },

  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ?
        this.skipSpaces() :
        this.inputStream.pos;
  },

  maybeSkipSpacesBefore(expr) {
    if (expr instanceof pexprs.Apply && expr.isSyntactic()) {
      return this.skipSpaces();
    } else if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },

  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },

  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },

  numBindings() {
    return this._bindings.length;
  },

  truncateBindings(newLength) {
    // Yes, this is this really faster than setting the `length` property (tested with
    // bin/es5bench on Node v6.1.0).
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },

  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },

  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },

  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);

    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        // Substitute parameters with the actual pexprs that were passed to
        // the current rule.
        expr = expr.substituteParams(app.args);
      } else {
        // This branch is only reached for the "end-check" that is
        // performed after the top-level application. In that case,
        // expr === pexprs.end so there is no need to substitute
        // parameters.
      }

      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },

  recordFailure(failure, shouldCloneIfNew) {
    const key = failure.toKey();
    if (!this.recordedFailures[key]) {
      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key].clearFluffy();
    }
  },

  recordFailures(failures, shouldCloneIfNew) {
    const self = this;
    Object.keys(failures).forEach(key => {
      self.recordFailure(failures[key], shouldCloneIfNew);
    });
  },

  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return undefined;
    }

    const ans = Object.create(null);
    const self = this;
    Object.keys(this.recordedFailures).forEach(key => {
      ans[key] = self.recordedFailures[key].clone();
    });
    return ans;
  },

  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },

  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ?
        this.posToOffset(this.rightmostFailurePosition) :
        -1;
  },

  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr.ruleName) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },

  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) ||
           new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },

  isTracing() {
    return !!this.trace;
  },

  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }

    if (this.recordedFailures &&
        this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }

    return true;
  },


  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }

    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition =
        Math.max(this.rightmostFailurePosition, memoRecRightmostFailurePosition);
    if (this.recordedFailures &&
        this.positionToRecordFailures === memoRecRightmostFailurePosition &&
        memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }

    this.inputStream.examinedLength =
        Math.max(this.inputStream.examinedLength, memoRec.examinedLength + origPos);

    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },

  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const inputStream = this.inputStream;
    const origNumBindings = this._bindings.length;

    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = Object.create(null);
    }

    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);

    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }

    // Do the actual evaluation.
    const ans = expr.eval(this);

    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }

    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        const self = this;
        Object.keys(this.recordedFailures).forEach(key => {
          self.recordedFailures[key].makeFluffy();
        });
      }
    } else {
      // Reset the position and the bindings.
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }

    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }

    return ans;
  },

  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      const self = this;
      rightmostFailures = Object.keys(this.recordedFailures).map(key => self.recordedFailures[key]);
    }
    return new MatchResult(
        this.matcher,
        this.input,
        this.startExpr,
        this._bindings[0],
        this._bindingOffsets[0],
        this.rightmostFailurePosition,
        rightmostFailures);
  },

  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();

    // The trace node for the start rule is always the last entry. If it is a syntactic rule,
    // the first entry is for an application of 'spaces'.
    // TODO(pdubroy): Clean this up by introducing a special `Match<startAppl>` rule, which will
    // ensure that there is always a single root trace node.
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },

  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },

  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchState;


/***/ }),

/***/ "./node_modules/ohm-js/src/Matcher.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Matcher.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const MatchState = __webpack_require__(/*! ./MatchState */ "./node_modules/ohm-js/src/MatchState.js");

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Matcher(grammar) {
  this.grammar = grammar;
  this.memoTable = [];
  this.input = '';
}

Matcher.prototype.getInput = function() {
  return this.input;
};

Matcher.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};

Matcher.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length ||
      endIdx < 0 || endIdx > currentInput.length ||
      startIdx > endIdx) {
    throw new Error('Invalid indices: ' + startIdx + ' and ' + endIdx);
  }

  // update input
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);

  // update memo table (similar to the above)
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(undefined);
  }
  restOfMemoTable.forEach(
      function(posInfo) { this.memoTable.push(posInfo); },
      this);

  // Invalidate memoRecs
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }

  return this;
};

Matcher.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};

Matcher.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};

Matcher.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};

/*
  Returns the starting expression for this Matcher's associated grammar. If `optStartApplicationStr`
  is specified, it is a string expressing a rule application in the grammar. If not specified, the
  grammar's default start rule will be used.
*/
Matcher.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error('Missing start rule argument -- the grammar has no default start rule.');
  }

  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs.Seq([startApp, pexprs.end]);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Matcher;


/***/ }),

/***/ "./node_modules/ohm-js/src/Namespace.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Namespace.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Namespace() {
}
Namespace.prototype = Object.create(null);

Namespace.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace) {
    return objOrNamespace;
  }
  return Namespace.createNamespace(objOrNamespace);
};

// Create a new namespace. If `optProps` is specified, all of its properties
// will be copied to the new namespace.
Namespace.createNamespace = function(optProps) {
  return Namespace.extend(Namespace.prototype, optProps);
};

// Create a new namespace which extends another namespace. If `optProps` is
// specified, all of its properties will be copied to the new namespace.
Namespace.extend = function(namespace, optProps) {
  if (namespace !== Namespace.prototype && !(namespace instanceof Namespace)) {
    throw new TypeError('not a Namespace object: ' + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return extend(ns, optProps);
};

// TODO: Should this be a regular method?
Namespace.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Namespace;


/***/ }),

/***/ "./node_modules/ohm-js/src/PosInfo.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/PosInfo.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function PosInfo() {
  this.applicationMemoKeyStack = []; // active applications at this position
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = undefined;
}

PosInfo.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },

  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },

  exit() {
    this.applicationMemoKeyStack.pop();
  },

  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;

    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    const indexOfFirstInvolvedRule =
        applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(indexOfFirstInvolvedRule);

    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };

    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },

  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },

  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },

  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset =
        Math.max(this.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
    return memoRec;
  },

  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      // Optimization: none of the rule applications that were memoized here examined the
      // interval of the input that changed, so nothing has to be invalidated.
      return;
    }

    const memo = this.memo;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    const self = this;
    Object.keys(memo).forEach(k => {
      const memoRec = memo[k];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k];
      } else {
        self.maxExaminedLength = Math.max(self.maxExaminedLength, memoRec.examinedLength);
        self.maxRightmostFailureOffset =
            Math.max(self.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
      }
    });
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = PosInfo;


/***/ }),

/***/ "./node_modules/ohm-js/src/Semantics.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Semantics.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const IterationNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").IterationNode;
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const globalActionStack = [];
let prototypeGrammar;
let prototypeGrammarSemantics;

// JSON is not a valid subset of JavaScript because there are two possible line terminators,
// U+2028 (line separator) and U+2029 (paragraph separator) that are allowed in JSON strings
// but not in JavaScript strings.
// jsonToJS() properly encodes those two characters in JSON so that it can seamlessly be
// inserted into JavaScript code (plus the encoded version is still valid JSON)
function jsonToJS(str) {
  const output = str.replace(/[\u2028\u2029]/g, (char, pos, str) => {
    const hex = char.codePointAt(0).toString(16);
    return '\\u' + '0000'.slice(hex.length) + hex;
  });
  return output;
}

// ----------------- Wrappers -----------------

// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)
// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A
// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and
// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is
// used to cache the wrapper instances that are created for its child nodes. Setting these instance
// variables is the responsibility of the constructor of each Semantics-specific subclass of
// `Wrapper`.
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;

    // The interval that the childOffsets of `node` are relative to. It should be the source
    // of the closest Nonterminal node.
    this._baseInterval = baseInterval;

    if (node.isNonterminal()) {
      common.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }

  toString() {
    return '[semantics wrapper for ' + this._node.grammar.name + ']';
  };

  // This is used by ohm editor to display a node wrapper appropriately.
  toJSON() {
    return this.toString();
  }

  _forgetMemoizedResultFor(attributeName) {
    // Remove the memoized attribute from the cstNode and all its children.
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach(child => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }

  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      // TODO: Consider throwing an exception here.
      return undefined;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];

      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
    }
    return childWrapper;
  }

  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    // Force the creation of all child wrappers
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }

  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }

  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }

  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }

  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];

    const childNodes = childWrappers.map(c => c._node);
    const iter = new IterationNode(this._node.grammar, childNodes, [], -1, false);

    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }

  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }

  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }

  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error('The `interval` property is deprecated -- use `source` instead');
  }

  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }

  // Returns the primitive value of this CST node, if it's a terminal node. Otherwise,
  // throws an exception.
  get primitiveValue() {
    if (this.isTerminal()) {
      return this._node.primitiveValue;
    }
    throw new TypeError(
        "tried to access the 'primitiveValue' attribute of a non-terminal CST node");
  }

  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}

// ----------------- Semantics -----------------

// A Semantics is a container for a family of Operations and Attributes for a given grammar.
// Semantics enable modularity (different clients of a grammar can create their set of operations
// and attributes in isolation) and extensibility even when operations and attributes are mutually-
// recursive. This constructor should not be called directly except from
// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are
// `g.createSemantics()` and `g.extendSemantics(parentSemantics)`.
function Semantics(grammar, superSemantics) {
  const self = this;
  this.grammar = grammar;
  this.checkedActionDicts = false;

  // Constructor for wrapper instances, which are passed as the arguments to the semantic actions
  // of an operation or attribute. Operations and attributes require double dispatch: the semantic
  // action is chosen based on both the node's type and the semantics. Wrappers ensure that
  // the `execute` method is called with the correct (most specific) semantics object as an
  // argument.
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self.checkActionDictsIfHaventAlready();
      this._semantics = self;
    }
  };

  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) {
      throw new Error(
          "Cannot extend a semantics for grammar '" + this.super.grammar.name +
          "' for use with grammar '" + grammar.name + "' (not a sub-grammar)");
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = Object.create(null);

    // Assign unique symbols for each of the attributes inherited from the super-semantics so that
    // they are memoized independently.
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = Object.create(null);
    this.attributes = Object.create(null);
    this.attributeKeys = Object.create(null);
  }
}

Semantics.prototype.toString = function() {
  return '[semantics for ' + this.grammar.name + ']';
};

Semantics.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};

// Checks that the action dictionaries for all operations and attributes in this semantics,
// including the ones that were inherited from the super-semantics, agree with the grammar.
// Throws an exception if one or more of them doesn't.
Semantics.prototype.checkActionDicts = function() {
  let name;
  for (name in this.operations) {
    this.operations[name].checkActionDict(this.grammar);
  }
  for (name in this.attributes) {
    this.attributes[name].checkActionDict(this.grammar);
  }
};

Semantics.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s) {
    return s.super !== Semantics.BuiltInSemantics._getSemantics();
  }

  let str = '(function(g) {\n';
  if (hasSuperSemantics(this)) {
    str += '  var semantics = ' + this.super.toRecipe(true) + '(g';

    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += '.superGrammar';
      relatedGrammar = relatedGrammar.superGrammar;
    }

    str += ');\n';
    str += '  return g.extendSemantics(semantics)';
  } else {
    str += '  return g.createSemantics()';
  }
  ['Operation', 'Attribute'].forEach(type => {
    const semanticOperations = this[type.toLowerCase() + 's'];
    Object.keys(semanticOperations).forEach(name => {
      const {actionDict, formals, builtInDefault} = semanticOperations[name];

      let signature = name;
      if (formals.length > 0) {
        signature += '(' + formals.join(', ') + ')';
      }

      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + 's'][name]) {
        method = 'extend' + type;
      } else {
        method = 'add' + type;
      }
      str += '\n    .' + method + '(' + JSON.stringify(signature) + ', {';

      const srcArray = [];
      Object.keys(actionDict).forEach(actionName => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();

          // Convert method shorthand to plain old function syntax.
          // https://github.com/harc/ohm/issues/263
          source = source.replace(/^.*\(/, 'function(');

          srcArray.push('\n      ' + JSON.stringify(actionName) + ': ' + source);
        }
      });
      str += srcArray.join(',') + '\n    })';
    });
  });
  str += ';\n  })';

  if (!semanticsOnly) {
    str =
      '(function() {\n' +
      '  var grammar = this.fromRecipe(' + jsonToJS(this.grammar.toRecipe()) + ');\n' +
      '  var semantics = ' + str + '(grammar);\n' +
      '  return semantics;\n' +
      '});\n';
  }

  return str;
};

function parseSignature(signature, type) {
  if (!prototypeGrammar) {
    // The Operations and Attributes grammar won't be available while Ohm is loading,
    // but we can get away the following simplification b/c none of the operations
    // that are used while loading take arguments.
    common.assert(signature.indexOf('(') === -1);
    return {
      name: signature,
      formals: []
    };
  }

  const r = prototypeGrammar.match(
      signature,
      type === 'operation' ? 'OperationSignature' : 'AttributeSignature');
  if (r.failed()) {
    throw new Error(r.message);
  }

  return prototypeGrammarSemantics(r).parse();
}

function newDefaultAction(type, name, doIt) {
  return function(children) {
    const self = this;
    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
    const args = thisThing.formals.map(formal => self.args[formal]);

    if (this.isIteration()) {
      // This CST node corresponds to an iteration expression in the grammar (*, +, or ?). The
      // default behavior is to map this operation or attribute over all of its child nodes.
      return children.map(child => doIt.apply(child, args));
    }

    // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that
    // we got here means that this action dictionary doesn't have an action for this particular
    // non-terminal or a generic `_nonterminal` action.
    if (children.length === 1) {
      // As a convenience, if this node only has one child, we just return the result of
      // applying this operation / attribute to the child node.
      return doIt.apply(children[0], args);
    } else {
      // Otherwise, we throw an exception to let the programmer know that we don't know what
      // to do with this node.
      throw errors.missingSemanticAction(this.ctorName, name, type, globalActionStack);
    }
  };
}

Semantics.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + 's';

  const parsedNameAndFormalArgs = parseSignature(signature, type);
  const name = parsedNameAndFormalArgs.name;
  const formals = parsedNameAndFormalArgs.formals;

  // TODO: check that there are no duplicate formal arguments

  this.assertNewName(name, type);

  // Create the action dictionary for this operation / attribute that contains a `_default` action
  // which defines the default behavior of iteration, terminal, and non-terminal nodes...
  const builtInDefault = newDefaultAction(type, name, doIt);
  const realActionDict = {_default: builtInDefault};
  // ... and add in the actions supplied by the programmer, which may override some or all of the
  // default ones.
  Object.keys(actionDict).forEach(name => {
    realActionDict[name] = actionDict[name];
  });

  const entry = type === 'operation' ?
      new Operation(name, formals, realActionDict, builtInDefault) :
      new Attribute(name, realActionDict, builtInDefault);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  entry.checkActionDict(this.grammar);

  this[typePlural][name] = entry;

  function doIt() {
    // Dispatch to most specific version of this operation / attribute -- it may have been
    // overridden by a sub-semantics.
    const thisThing = this._semantics[typePlural][name];

    // Check that the caller passed the correct number of arguments.
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
          'Invalid number of arguments passed to ' + name + ' ' + type + ' (expected ' +
          thisThing.formals.length + ', got ' + arguments.length + ')');
    }

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let idx = 0; idx < arguments.length; idx++) {
      const formal = thisThing.formals[idx];
      args[formal] = arguments[idx];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }

  if (type === 'operation') {
    this.Wrapper.prototype[name] = doIt;
    this.Wrapper.prototype[name].toString = function() {
      return '[' + name + ' operation]';
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name, {
      get: doIt,
      configurable: true // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name, {
      value: util.uniqueId(name)
    });
  }
};

Semantics.prototype.extendOperationOrAttribute = function(type, name, actionDict) {
  const typePlural = type + 's';

  // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.
  parseSignature(name, 'attribute');

  if (!(this.super && name in this.super[typePlural])) {
    throw new Error('Cannot extend ' + type + " '" + name +
        "': did not inherit an " + type + ' with that name');
  }
  if (Object.prototype.hasOwnProperty.call(this[typePlural], name)) {
    throw new Error('Cannot extend ' + type + " '" + name + "' again");
  }

  // Create a new operation / attribute whose actionDict delegates to the super operation /
  // attribute's actionDict, and which has all the keys from `inheritedActionDict`.
  const inheritedFormals = this[typePlural][name].formals;
  const inheritedActionDict = this[typePlural][name].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach(name => {
    newActionDict[name] = actionDict[name];
  });

  this[typePlural][name] = type === 'operation' ?
      new Operation(name, inheritedFormals, newActionDict) :
      new Attribute(name, newActionDict);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  this[typePlural][name].checkActionDict(this.grammar);
};

Semantics.prototype.assertNewName = function(name, type) {
  if (Wrapper.prototype.hasOwnProperty(name)) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': that's a reserved name");
  }
  if (name in this.operations) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an operation with that name already exists");
  }
  if (name in this.attributes) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an attribute with that name already exists");
  }
};

// Returns a wrapper for the given CST `node` in this semantics.
// If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?
Semantics.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};

// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from
// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new
// Semantics instance. When that function is invoked with a CST node as an argument, it returns
// a wrapper for that node which gives access to the operations and attributes provided by this
// semantics.
Semantics.createSemantics = function(grammar, optSuperSemantics) {
  const s = new Semantics(
      grammar,
      optSuperSemantics !== undefined ?
          optSuperSemantics :
          Semantics.BuiltInSemantics._getSemantics());

  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy
  // for `s`, which is the real `Semantics` instance.
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
          'Semantics expected a MatchResult, but got ' + common.unexpectedObjToString(matchResult));
    }
    if (matchResult.failed()) {
      throw new TypeError('cannot apply Semantics to ' + matchResult.toString());
    }

    const cst = matchResult._cst;
    if (cst.grammar !== grammar) {
      throw new Error(
          "Cannot use a MatchResult from grammar '" + cst.grammar.name +
          "' with a semantics for '" + grammar.name + "'");
    }
    const inputStream = new InputStream(matchResult.input);
    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };

  // Forward public methods from the proxy to the semantics instance.
  proxy.addOperation = function(signature, actionDict) {
    s.addOperationOrAttribute('operation', signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name, actionDict) {
    s.extendOperationOrAttribute('operation', name, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name, actionDict) {
    s.addOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name, actionDict) {
    s.extendOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error('"' + operationOrAttributeName + '" is not a valid operation or attribute ' +
        'name in this semantics for "' + grammar.name + '"');
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s.operations) {
      semantic = s.operations[operationOrAttributeName];
      delete s.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s.attributes) {
      semantic = s.attributes[operationOrAttributeName];
      delete s.attributes[operationOrAttributeName];
    }
    delete s.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s.attributes);
  };
  proxy.getGrammar = function() {
    return s.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s.toRecipe(semanticsOnly);
  };

  // Make the proxy's toString() work.
  proxy.toString = s.toString.bind(s);

  // Returns the semantics for the proxy.
  proxy._getSemantics = function() {
    return s;
  };

  return proxy;
};

// ----------------- Operation -----------------

// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very
// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by
// recursively walking the CST, and at each node, invoking the matching semantic action from
// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic
// action is found.
class Operation {
  constructor(name, formals, actionDict, builtInDefault) {
    this.name = name;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }

  checkActionDict(grammar) {
    grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }

  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      // Look for a semantic action whose name matches the node's constructor name, which is either
      // the name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an
      // iteration node). In the latter case, the action function receives a single argument, which
      // is an array containing all of the children of the CST node.
      const ctorName = nodeWrapper._node.ctorName;
      let actionFn = this.actionDict[ctorName];
      let ans;
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        ans = this.doAction(semantics, nodeWrapper, actionFn, nodeWrapper.isIteration());
        return ans;
      }

      // The action dictionary does not contain a semantic action for this specific type of node.
      // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic
      // action, we invoke it:
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, '_nonterminal', ctorName]);
          ans = this.doAction(semantics, nodeWrapper, actionFn, true);
          return ans;
        }
      }

      // Otherwise, we invoke the '_default' semantic action.
      globalActionStack.push([this, 'default action', ctorName]);
      ans = this.doAction(semantics, nodeWrapper, this.actionDict._default, true);
      return ans;
    } finally {
      globalActionStack.pop();
    }
  }

  // Invoke `actionFn` on the CST node that corresponds to `nodeWrapper`, in the context of
  // `semantics`. If `optPassChildrenAsArray` is truthy, `actionFn` will be called with a single
  // argument, which is an array of wrappers. Otherwise, the number of arguments to `actionFn` will
  // be equal to the number of children in the CST node.
  doAction(semantics, nodeWrapper, actionFn, optPassChildrenAsArray) {
    return optPassChildrenAsArray ?
        actionFn.call(nodeWrapper, nodeWrapper._children()) :
        actionFn.apply(nodeWrapper, nodeWrapper._children());
  }
}

Operation.prototype.typeName = 'operation';

// ----------------- Attribute -----------------

// Attributes are Operations whose results are memoized. This means that, for any given semantics,
// the semantic action for a CST node will be invoked no more than once.
class Attribute extends Operation {
  constructor(name, actionDict, builtInDefault) {
    super(name, [], actionDict, builtInDefault);
  }

  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key = semantics.attributeKeys[this.name];
    if (!node.hasOwnProperty(key)) {
      // The following is a super-send -- isn't JS beautiful? :/
      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key];
  }
}

Attribute.prototype.typeName = 'attribute';


// ----------------- Deferred initialization -----------------

util.awaitBuiltInRules(builtInRules => {
  const operationsAndAttributesGrammar = __webpack_require__(/*! ../dist/operations-and-attributes */ "./node_modules/ohm-js/dist/operations-and-attributes.js");
  initBuiltInSemantics(builtInRules);
  initPrototypeParser(operationsAndAttributesGrammar); // requires BuiltInSemantics
});

function initBuiltInSemantics(builtInRules) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };

  Semantics.BuiltInSemantics = Semantics
      .createSemantics(builtInRules, null)
      .addOperation('asIteration', {
        emptyListOf: actions.empty,
        nonemptyListOf: actions.nonEmpty,
        EmptyListOf: actions.empty,
        NonemptyListOf: actions.nonEmpty
      });
}

function initPrototypeParser(grammar) {
  prototypeGrammarSemantics = grammar.createSemantics().addOperation('parse', {
    AttributeSignature(name) {
      return {
        name: name.parse(),
        formals: []
      };
    },
    OperationSignature(name, optFormals) {
      return {
        name: name.parse(),
        formals: optFormals.parse()[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().parse();
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  prototypeGrammar = grammar;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Semantics;


/***/ }),

/***/ "./node_modules/ohm-js/src/Trace.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/Trace.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Unicode characters that are used in the `toString` output.
const BALLOT_X = '\u2717';
const CHECK_MARK = '\u2713';
const DOT_OPERATOR = '\u22C5';
const RIGHTWARDS_DOUBLE_ARROW = '\u21D2';
const SYMBOL_FOR_HORIZONTAL_TABULATION = '\u2409';
const SYMBOL_FOR_LINE_FEED = '\u240A';
const SYMBOL_FOR_CARRIAGE_RETURN = '\u240D';

const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};

function spaces(n) {
  return common.repeat(' ', n).join('');
}

// Return a string representation of a portion of `input` at offset `pos`.
// The result will contain exactly `len` characters.
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));

  // Pad the output if necessary.
  if (excerpt.length < len) {
    return excerpt + common.repeat(' ', len - excerpt.length).join('');
  }
  return excerpt;
}

function asEscapedString(obj) {
  if (typeof obj === 'string') {
    // Replace non-printable characters with visible symbols.
    return obj
        .replace(/ /g, DOT_OPERATOR)
        .replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)
        .replace(/\n/g, SYMBOL_FOR_LINE_FEED)
        .replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}

// ----------------- Trace -----------------

function Trace(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;

  this._flags = succeeded ? Flags.succeeded : 0;
}

// A value that can be returned from visitor functions to indicate that a
// node should not be recursed into.
Trace.prototype.SKIP = {};

Object.defineProperty(Trace.prototype, 'displayString', {
  get() { return this.expr.toDisplayString(); }
});

// For convenience, create a getter and setter for the boolean flags in `Flags`.
Object.keys(Flags).forEach(name => {
  const mask = Flags[name];
  Object.defineProperty(Trace.prototype, name, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});

Trace.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};

Trace.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace(
      this.input, this.pos, this.pos2, expr, this.succeeded, this.bindings, this.children);

  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};

// Record the trace information for the terminating condition of the LR loop.
Trace.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry =
      new Trace(this.input, this.pos, this.pos2, this.expr, false, [value], [ruleBodyTrace]);
  this.terminatingLREntry.terminatesLR = true;
};

// Recursively traverse this trace node and all its descendents, calling a visitor function
// for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property
// is a function to call before visiting the children of a node, and its 'exit' property is
// a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'
// function.
//
// The functions are called with three arguments: the Trace node, its parent Trace, and a number
// representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if
// specified, is the value to use for `this` when executing the visitor functions.
Trace.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === 'function') {
    visitor = {enter: visitor};
  }

  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach(child => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    // Don't visit the root node itself, only its children.
    this.children.forEach(c => { _walk(c, null, 0); });
  } else {
    _walk(this, null, 0);
  }
};

// Return a string representation of the trace.
// Sample:
//     12+2*3  exp   "12"
//     12+2*3    addExp (LR)   "12"
//     12+2*3        addExp_plus
Trace.prototype.toString = function() {
  const sb = new common.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    // Don't print anything for Alt nodes.
    if (ctorName === 'Alt') {
      return; // eslint-disable-line consistent-return
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(' (LR)');
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');
      sb.append(typeof contents === 'string' ? '"' + contents + '"' : contents);
    }
    sb.append('\n');
  });
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Trace;


/***/ }),

/***/ "./node_modules/ohm-js/src/common.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/common.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Helpers

const escapeStringFor = {};
for (let c = 0; c < 128; c++) {
  escapeStringFor[c] = String.fromCharCode(c);
}
escapeStringFor["'".charCodeAt(0)] = "\\'";
escapeStringFor['"'.charCodeAt(0)] = '\\"';
escapeStringFor['\\'.charCodeAt(0)] = '\\\\';
escapeStringFor['\b'.charCodeAt(0)] = '\\b';
escapeStringFor['\f'.charCodeAt(0)] = '\\f';
escapeStringFor['\n'.charCodeAt(0)] = '\\n';
escapeStringFor['\r'.charCodeAt(0)] = '\\r';
escapeStringFor['\t'.charCodeAt(0)] = '\\t';
escapeStringFor['\u000b'.charCodeAt(0)] = '\\v';

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.abstract = function(optMethodName) {
  const methodName = optMethodName || '';
  return function() {
    throw new Error(
        'this method ' + methodName + ' is abstract! ' +
      '(it has no implementation in class ' + this.constructor.name + ')');
  };
};

exports.assert = function(cond, message) {
  if (!cond) {
    throw new Error(message);
  }
};

// Define a lazily-computed, non-enumerable property named `propName`
// on the object `obj`. `getterFn` will be called to compute the value the
// first time the property is accessed.
exports.defineLazyProperty = function(obj, propName, getterFn) {
  let memo;
  Object.defineProperty(obj, propName, {
    get() {
      if (!memo) {
        memo = getterFn.call(this);
      }
      return memo;
    }
  });
};

exports.clone = function(obj) {
  if (obj) {
    return extend({}, obj);
  }
  return obj;
};

exports.extend = extend;

exports.repeatFn = function(fn, n) {
  const arr = [];
  while (n-- > 0) {
    arr.push(fn());
  }
  return arr;
};

exports.repeatStr = function(str, n) {
  return new Array(n + 1).join(str);
};

exports.repeat = function(x, n) {
  return exports.repeatFn(() => x, n);
};

exports.getDuplicates = function(array) {
  const duplicates = [];
  for (let idx = 0; idx < array.length; idx++) {
    const x = array[idx];
    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {
      duplicates.push(x);
    }
  }
  return duplicates;
};

exports.copyWithoutDuplicates = function(array) {
  const noDuplicates = [];
  array.forEach(entry => {
    if (noDuplicates.indexOf(entry) < 0) {
      noDuplicates.push(entry);
    }
  });
  return noDuplicates;
};

exports.isSyntactic = function(ruleName) {
  const firstChar = ruleName[0];
  return firstChar === firstChar.toUpperCase();
};

exports.isLexical = function(ruleName) {
  return !exports.isSyntactic(ruleName);
};

exports.padLeft = function(str, len, optChar) {
  const ch = optChar || ' ';
  if (str.length < len) {
    return exports.repeatStr(ch, len - str.length) + str;
  }
  return str;
};

// StringBuffer

exports.StringBuffer = function() {
  this.strings = [];
};

exports.StringBuffer.prototype.append = function(str) {
  this.strings.push(str);
};

exports.StringBuffer.prototype.contents = function() {
  return this.strings.join('');
};

// Character escaping and unescaping

exports.escapeChar = function(c, optDelim) {
  const charCode = c.charCodeAt(0);
  if ((c === '"' || c === "'") && optDelim && c !== optDelim) {
    return c;
  } else if (charCode < 128) {
    return escapeStringFor[charCode];
  } else if (128 <= charCode && charCode < 256) {
    return '\\x' + exports.padLeft(charCode.toString(16), 2, '0');
  } else {
    return '\\u' + exports.padLeft(charCode.toString(16), 4, '0');
  }
};

exports.unescapeChar = function(s) {
  if (s.charAt(0) === '\\') {
    switch (s.charAt(1)) {
      case 'b': return '\b';
      case 'f': return '\f';
      case 'n': return '\n';
      case 'r': return '\r';
      case 't': return '\t';
      case 'v': return '\v';
      case 'x': return String.fromCharCode(parseInt(s.substring(2, 4), 16));
      case 'u': return String.fromCharCode(parseInt(s.substring(2, 6), 16));
      default: return s.charAt(1);
    }
  } else {
    return s;
  }
};

// Helper for producing a description of an unknown object in a safe way.
// Especially useful for error messages where an unexpected type of object was encountered.
exports.unexpectedObjToString = function(obj) {
  if (obj == null) {
    return String(obj);
  }
  const baseToString = Object.prototype.toString.call(obj);
  try {
    let typeName;
    if (obj.constructor && obj.constructor.name) {
      typeName = obj.constructor.name;
    } else if (baseToString.indexOf('[object ') === 0) {
      typeName = baseToString.slice(8, -1); // Extract e.g. "Array" from "[object Array]".
    } else {
      typeName = typeof obj;
    }
    return typeName + ': ' + JSON.stringify(String(obj));
  } catch (e) {
    return baseToString;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/errors.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/errors.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}

// ----------------- errors about intervals -----------------

function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}

// ----------------- errors about grammars -----------------

// Grammar syntax error

function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, 'message', {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, 'shortMessage', {
    enumerable: true,
    get() {
      return 'Expected ' + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}

// Undeclared grammar

function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ?
      'Grammar ' + grammarName + ' is not declared in namespace ' + Namespace.toString(namespace) :
      'Undeclared grammar ' + grammarName;
  return createError(message, interval);
}

// Duplicate grammar declaration

function duplicateGrammarDeclaration(grammar, namespace) {
  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');
}

// ----------------- rules -----------------

// Undeclared rule

function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,
      optInterval);
}

// Cannot override undeclared rule

function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Cannot extend undeclared rule

function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Duplicate rule declaration

function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName +
      "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}

// Wrong number of parameters

function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
      'Wrong number of parameters for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      source);
}

// Wrong number of arguments

function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
      'Wrong number of arguments for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// Duplicate parameter names

function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(', '),
      source);
}

// Invalid parameter expression

function invalidParameter(ruleName, expr) {
  return createError(
      'Invalid parameter to rule ' + ruleName + ': ' + expr + ' has arity ' + expr.getArity() +
         ', but parameter expressions must have arity 1',
      expr.source);
}

// Application of syntactic rule from lexical rule

function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',
      applyExpr.source);
}

// Incorrect argument type

function incorrectArgumentType(expectedType, expr) {
  return createError('Incorrect argument type: expected ' + expectedType, expr.source);
}

// Multiple instances of the super-splice operator (`...`) in the rule body.

function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}

// ----------------- Kleene operators -----------------

function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ?
    applicationStack[applicationStack.length - 1].args :
    [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message =
    'Nullable expression ' + expr + " is not allowed inside '" +
    kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack
        .map(app => new pexprs.Apply(app.ruleName, app.args))
        .join('\n');
    message += '\nApplication stack (most recent application last):\n' + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}

// ----------------- arity -----------------

function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
      'Rule ' + ruleName + ' involves an alternation which has inconsistent arity ' +
          '(expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// ----------------- properties -----------------

function duplicatePropertyNames(duplicates) {
  return createError('Object pattern has duplicate property names: ' + duplicates.join(', '));
}

// ----------------- constructors -----------------

function invalidConstructorCall(grammar, ctorName, children) {
  return createError(
      'Attempt to invoke constructor ' + ctorName + ' with invalid or unexpected arguments');
}

// ----------------- convenience -----------------

function multipleErrors(errors) {
  const messages = errors.map(e => e.message);
  return createError(
      ['Errors:'].concat(messages).join('\n- '),
      errors[0].interval);
}

// ----------------- semantic -----------------

function missingSemanticAction(ctorName, name, type, stack) {
  let stackTrace = stack.slice(0, -1).map(info => {
    const ans = '  ' + info[0].name + ' > ' + info[1];
    return info.length === 3
        ? ans + " for '" + info[2] + "'"
        : ans;
  }).join('\n');
  stackTrace += '\n  ' + name + ' > ' + ctorName;

  const where = type + " '" + name + "'";
  const message = "Missing semantic action for '" + ctorName + "' in " + where + '\n' +
                'Action stack (most recent call last):\n' + stackTrace;

  const e = createError(message);
  e.name = 'missingSemanticAction';
  return e;
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  applicationOfSyntacticRuleFromLexicalContext,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  wrongNumberOfArguments,
  wrongNumberOfParameters,

  throwErrors(errors) {
    if (errors.length === 1) {
      throw errors[0];
    }
    if (errors.length > 1) {
      throw multipleErrors(errors);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/main.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/main.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global document, XMLHttpRequest */



// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Builder = __webpack_require__(/*! ./Builder */ "./node_modules/ohm-js/src/Builder.js");
const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const version = __webpack_require__(/*! ./version */ "./node_modules/ohm-js/src/version.js");

const isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/ohm-js/node_modules/is-buffer/index.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// The metagrammar, i.e. the grammar for Ohm grammars. Initialized at the
// bottom of this file because loading the grammar requires Ohm itself.
let ohmGrammar;

// An object which makes it possible to stub out the document API for testing.
let documentInterface = {
  querySelector(sel) { return document.querySelector(sel); },
  querySelectorAll(sel) { return document.querySelectorAll(sel); }
};

const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);

// Check if `obj` is a DOM element.
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

function isUndefined(obj) {
  return obj === void 0; // eslint-disable-line no-void
}

const MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

function isArrayLike(obj) {
  if (obj == null) {
    return false;
  }
  const length = obj.length;
  return typeof length === 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
}

// TODO: just use the jQuery thing
function load(url) {
  const req = new XMLHttpRequest();
  req.open('GET', url, false);
  try {
    req.send();
    if (req.status === 0 || req.status === 200) {
      return req.responseText;
    }
  } catch (e) {}
  throw new Error('unable to load url ' + url);
}

// Returns a Grammar instance (i.e., an object with a `match` method) for
// `tree`, which is the concrete syntax tree of a user-written grammar.
// The grammar will be assigned into `namespace` under the name of the grammar
// as specified in the source.
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;

  // A visitor that produces a Grammar instance from the CST.
  const helpers = metaGrammar.createSemantics().addOperation('visit', {
    Grammar(n, s, open, rs, close) {
      const grammarName = n.visit();
      decl = builder.newGrammar(grammarName, namespace);
      s.visit();
      rs.visit();
      const g = decl.build();
      g.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors.duplicateGrammarDeclaration(g, namespace);
      }
      namespace[grammarName] = g;
      return g;
    },

    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === 'null') {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },

    Rule_define(n, fs, d, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      // If there is no default start rule yet, set it now. This must be done before visiting
      // the body, because it might contain an inline rule definition.
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b.visit();
      const description = d.visit()[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description, source);
    },
    Rule_override(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];

      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);

      overriding = true;
      const body = b.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      const body = b.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      const args = terms.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();

      // Check if the super-splice operator (`...`) appears in the terms.
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);

        // Ensure it appears no more than once.
        afterTerms.forEach(t => {
          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);
        });

        return new pexprs.Splice(
            decl.superGrammar, currentRuleName, beforeTerms, afterTerms).withSource(this.source);
      } else {
        return builder.alt.apply(builder, args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },

    Params(opointy, ps, cpointy) {
      return ps.visit();
    },

    Alt(seqs) {
      const args = seqs.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },

    TopLevelTerm_inline(b, n) {
      const inlineRuleName = currentRuleName + '_' + n.visit();
      const body = b.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration =
          !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map(formal => builder.app(formal));
      return builder.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },

    Seq(expr) {
      return builder.seq.apply(builder, expr.visit()).withSource(this.source);
    },

    Iter_star(x, _) {
      return builder.star(x.visit()).withSource(this.source);
    },
    Iter_plus(x, _) {
      return builder.plus(x.visit()).withSource(this.source);
    },
    Iter_opt(x, _) {
      return builder.opt(x.visit()).withSource(this.source);
    },

    Pred_not(_, x) {
      return builder.not(x.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x) {
      return builder.lookahead(x.visit()).withSource(this.source);
    },

    Lex_lex(_, x) {
      return builder.lex(x.visit()).withSource(this.source);
    },

    Base_application(rule, ps) {
      return builder.app(rule.visit(), ps.visit()[0] || []).withSource(this.source);
    },
    Base_range(from, _, to) {
      return builder.range(from.visit(), to.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x, close) {
      return x.visit();
    },

    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },

    caseName(_, space1, n, space2, end) {
      return n.visit();
    },

    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {},
    nameRest(expr) {},

    terminal(open, cs, close) {
      return cs.visit().join('');
    },

    oneCharTerminal(open, c, close) {
      return c.visit();
    },

    terminalChar(_) {
      return common.unescapeChar(this.sourceString);
    },

    escapeChar(_) {
      return this.sourceString;
    },

    NonemptyListOf(x, _, xs) {
      return [x.visit()].concat(xs.visit());
    },
    EmptyListOf() {
      return [];
    },

    _terminal() {
      return this.primitiveValue;
    }
  });
  return helpers(match).visit();
}

function compileAndLoad(source, namespace) {
  const m = ohmGrammar.match(source, 'Grammars');
  if (m.failed()) {
    throw errors.grammarSyntaxError(m);
  }
  return buildGrammar(m, namespace);
}

// Return the contents of a script element, fetching it via XHR if necessary.
function getScriptElementContents(el) {
  if (!isElement(el)) {
    throw new TypeError('Expected a DOM Node, got ' + common.unexpectedObjToString(el));
  }
  if (el.type !== 'text/ohm-js') {
    throw new Error('Expected a script tag with type="text/ohm-js", got ' + el);
  }
  return el.getAttribute('src') ? load(el.getAttribute('src')) : el.innerHTML;
}

function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);

  // Ensure that the source contained no more than one grammar definition.
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error('Missing grammar definition');
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
        util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) +
        'Found more than one grammar definition -- use ohm.grammars() instead.');
  }
  return ns[grammarNames[0]]; // Return the one and only grammar.
}

function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== 'string') {
    // For convenience, detect Node.js Buffer objects and automatically call toString().
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
          'Expected string as first argument, got ' + common.unexpectedObjToString(source));
    }
  }
  compileAndLoad(source, ns);
  return ns;
}

function grammarFromScriptElement(optNode) {
  let node = optNode;
  if (isUndefined(node)) {
    const nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
    if (nodeList.length !== 1) {
      throw new Error(
          'Expected exactly one script tag with type="text/ohm-js", found ' + nodeList.length);
    }
    node = nodeList[0];
  }
  return grammar(getScriptElementContents(node));
}

function grammarsFromScriptElements(optNodeOrNodeList) {
  // Simple case: the argument is a DOM node.
  if (isElement(optNodeOrNodeList)) {
    return grammars(optNodeOrNodeList);
  }
  // Otherwise, it must be either undefined or a NodeList.
  let nodeList = optNodeOrNodeList;
  if (isUndefined(nodeList)) {
    // Find all script elements with type="text/ohm-js".
    nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
  } else if (typeof nodeList === 'string' || (!isElement(nodeList) && !isArrayLike(nodeList))) {
    throw new TypeError('Expected a Node, NodeList, or Array, but got ' + nodeList);
  }
  const ns = Namespace.createNamespace();
  for (let i = 0; i < nodeList.length; ++i) {
    // Copy the new grammars into `ns` to keep the namespace flat.
    common.extend(ns, grammars(getScriptElementContents(nodeList[i]), ns));
  }
  return ns;
}

function makeRecipe(recipe) {
  if (typeof recipe === 'function') {
    return recipe.call(new Builder());
  } else {
    if (typeof recipe === 'string') {
      // stringified JSON recipe
      recipe = JSON.parse(recipe);
    }
    return (new Builder()).fromRecipe(recipe);
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

// Stuff that users should know about
module.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null, // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util,
  extras: __webpack_require__(/*! ../extras */ "./node_modules/ohm-js/extras/index.js"),
  version
};

// Stuff for testing, etc.
module.exports._buildGrammar = buildGrammar;
module.exports._setDocumentInterfaceForTesting = function(doc) { documentInterface = doc; };

// Late initialization for stuff that is bootstrapped.

Grammar.BuiltInRules = __webpack_require__(/*! ../dist/built-in-rules */ "./node_modules/ohm-js/dist/built-in-rules.js");
util.announceBuiltInRules(Grammar.BuiltInRules);

module.exports.ohmGrammar = ohmGrammar = __webpack_require__(/*! ../dist/ohm-grammar */ "./node_modules/ohm-js/dist/ohm-grammar.js");
Grammar.initApplicationParser(ohmGrammar, buildGrammar);


/***/ }),

/***/ "./node_modules/ohm-js/src/nodes.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/nodes.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

class Node {
  constructor(grammar, ctorName, matchLength) {
    this.grammar = grammar;
    this.ctorName = ctorName;
    this.matchLength = matchLength;
  }

  numChildren() {
    return this.children ? this.children.length : 0;
  }

  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }

  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }

  hasChildren() {
    return this.numChildren() > 1;
  }

  hasNoChildren() {
    return !this.hasChildren();
  }

  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
          'cannot get only child of a node of type ' + this.ctorName +
          ' (it has ' + this.numChildren() + ' children)');
    } else {
      return this.firstChild();
    }
  }

  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get first child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(0);
    }
  }

  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get last child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }

  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childBefore() called w/ an argument that is not a child');
    } else if (childIdx === 0) {
      throw new Error('cannot get child before first child');
    } else {
      return this.childAt(childIdx - 1);
    }
  }

  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childAfter() called w/ an argument that is not a child');
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error('cannot get child after last child');
    } else {
      return this.childAt(childIdx + 1);
    }
  }

  isTerminal() {
    return false;
  }

  isNonterminal() {
    return false;
  }

  isIteration() {
    return false;
  }

  isOptional() {
    return false;
  }

  toJSON() {
    return {[this.ctorName]: this.children};
  }
}

// Terminals

class TerminalNode extends Node {
  constructor(grammar, value) {
    const matchLength = value ? value.length : 0;
    super(grammar, '_terminal', matchLength);
    this.primitiveValue = value;
  }

  isTerminal() {
    return true;
  }

  toJSON() {
    return {[this.ctorName]: this.primitiveValue};
  }
}

// Nonterminals

class NonterminalNode extends Node {
  constructor(grammar, ruleName, children, childOffsets, matchLength) {
    super(grammar, ruleName, matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
  }

  isNonterminal() {
    return true;
  }

  isLexical() {
    return common.isLexical(this.ctorName);
  }

  isSyntactic() {
    return common.isSyntactic(this.ctorName);
  }
}

// Iterations

class IterationNode extends Node {
  constructor(grammar, children, childOffsets, matchLength, isOptional) {
    super(grammar, '_iter', matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }

  isIteration() {
    return true;
  }

  isOptional() {
    return this.optional;
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  Node,
  TerminalNode,
  NonterminalNode,
  IterationNode
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js":
/*!************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Return true if we should skip spaces preceding this expression in a syntactic context.
*/
pexprs.PExpr.prototype.allowsSkippingPrecedingSpace = common.abstract(
    'allowsSkippingPrecedingSpace'
);

/*
  Generally, these are all first-order expressions and (with the exception of Apply)
  directly read from the input stream.
*/
pexprs.any.allowsSkippingPrecedingSpace =
pexprs.end.allowsSkippingPrecedingSpace =
pexprs.Apply.prototype.allowsSkippingPrecedingSpace =
pexprs.Terminal.prototype.allowsSkippingPrecedingSpace =
pexprs.Range.prototype.allowsSkippingPrecedingSpace =
pexprs.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};

/*
  Higher-order expressions that don't directly consume input.
*/
pexprs.Alt.prototype.allowsSkippingPrecedingSpace =
pexprs.Iter.prototype.allowsSkippingPrecedingSpace =
pexprs.Lex.prototype.allowsSkippingPrecedingSpace =
pexprs.Lookahead.prototype.allowsSkippingPrecedingSpace =
pexprs.Not.prototype.allowsSkippingPrecedingSpace =
pexprs.Param.prototype.allowsSkippingPrecedingSpace =
pexprs.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

let BuiltInRules;

util.awaitBuiltInRules(g => { BuiltInRules = g; });

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

let lexifyCount;

pexprs.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.PExpr.prototype._assertAllApplicationsAreValid = common.abstract(
    '_assertAllApplicationsAreValid'
);

pexprs.any._assertAllApplicationsAreValid =
pexprs.end._assertAllApplicationsAreValid =
pexprs.Terminal.prototype._assertAllApplicationsAreValid =
pexprs.Range.prototype._assertAllApplicationsAreValid =
pexprs.Param.prototype._assertAllApplicationsAreValid =
pexprs.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  // no-op
};

pexprs.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
  lexifyCount--;
};

pexprs.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Iter.prototype._assertAllApplicationsAreValid =
pexprs.Not.prototype._assertAllApplicationsAreValid =
pexprs.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  const ruleInfo = grammar.rules[this.ruleName];

  // Make sure that the rule exists...
  if (!ruleInfo) {
    throw errors.undeclaredRule(this.ruleName, grammar.name, this.source);
  }

  // ...and that this application is allowed
  if (common.isSyntactic(this.ruleName) && (!common.isSyntactic(ruleName) || lexifyCount > 0)) {
    throw errors.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }

  // ...and that this application has the correct number of arguments
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }

  // ...and that all of the argument expressions only have valid applications and have arity 1.
  const self = this;
  this.args.forEach(arg => {
    arg._assertAllApplicationsAreValid(ruleName, grammar);
    if (arg.getArity() !== 1) {
      throw errors.invalidParameter(self.ruleName, arg);
    }
  });

  // Extra checks for "special" applications

  // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.
  if (BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive) {
    if (!(this.args[0] instanceof pexprs.Terminal)) {
      throw errors.incorrectArgumentType('a Terminal (e.g. \"abc\")', this.args[0]);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertChoicesHaveUniformArity = common.abstract(
    'assertChoicesHaveUniformArity'
);

pexprs.any.assertChoicesHaveUniformArity =
pexprs.end.assertChoicesHaveUniformArity =
pexprs.Terminal.prototype.assertChoicesHaveUniformArity =
pexprs.Range.prototype.assertChoicesHaveUniformArity =
pexprs.Param.prototype.assertChoicesHaveUniformArity =
pexprs.Lex.prototype.assertChoicesHaveUniformArity =
pexprs.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op
};

pexprs.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};

pexprs.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // Extend is a special case of Alt that's guaranteed to have exactly two
  // cases: [extensions, origBody].
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};

pexprs.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};

pexprs.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op (not required b/c the nested expr doesn't show up in the CST)
};

pexprs.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // The arities of the parameter expressions is required to be 1 by
  // `assertAllApplicationsAreValid()`.
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertIteratedExprsAreNotNullable = common.abstract(
    'assertIteratedExprsAreNotNullable'
);

pexprs.any.assertIteratedExprsAreNotNullable =
pexprs.end.assertIteratedExprsAreNotNullable =
pexprs.Terminal.prototype.assertIteratedExprsAreNotNullable =
pexprs.Range.prototype.assertIteratedExprsAreNotNullable =
pexprs.Param.prototype.assertIteratedExprsAreNotNullable =
pexprs.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // no-op
};

pexprs.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // Note: this is the implementation of this method for `Star` and `Plus` expressions.
  // It is overridden for `Opt` below.
  this.expr.assertIteratedExprsAreNotNullable(grammar);
  if (this.expr.isNullable(grammar)) {
    throw errors.kleeneExprHasNullableOperand(this, []);
  }
};

pexprs.Opt.prototype.assertIteratedExprsAreNotNullable =
pexprs.Not.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lookahead.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.expr.assertIteratedExprsAreNotNullable(grammar);
};

pexprs.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.args.forEach(arg => {
    arg.assertIteratedExprsAreNotNullable(grammar);
  });
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-check.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-check.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.check = common.abstract('check');

pexprs.any.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.end.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === undefined;
};

pexprs.Terminal.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === this.obj;
};

pexprs.Range.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === typeof this.from;
};

pexprs.Param.prototype.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.Alt.prototype.check = function(grammar, vals) {
  for (let i = 0; i < this.terms.length; i++) {
    const term = this.terms[i];
    if (term.check(grammar, vals)) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.check = function(grammar, vals) {
  let pos = 0;
  for (let i = 0; i < this.factors.length; i++) {
    const factor = this.factors[i];
    if (factor.check(grammar, vals.slice(pos))) {
      pos += factor.getArity();
    } else {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.check = function(grammar, vals) {
  const arity = this.getArity();
  const columns = vals.slice(0, arity);
  if (columns.length !== arity) {
    return false;
  }
  const rowCount = columns[0].length;
  let i;
  for (i = 1; i < arity; i++) {
    if (columns[i].length !== rowCount) {
      return false;
    }
  }

  for (i = 0; i < rowCount; i++) {
    const row = [];
    for (let j = 0; j < arity; j++) {
      row.push(columns[j][i]);
    }
    if (!this.expr.check(grammar, row)) {
      return false;
    }
  }

  return true;
};

pexprs.Not.prototype.check = function(grammar, vals) {
  return true;
};

pexprs.Lookahead.prototype.check =
pexprs.Lex.prototype.check = function(grammar, vals) {
  return this.expr.check(grammar, vals);
};

pexprs.Apply.prototype.check = function(grammar, vals) {
  if (!(vals[0] instanceof nodes.Node &&
        vals[0].grammar === grammar &&
        vals[0].ctorName === this.ruleName)) {
    return false;
  }

  // TODO: think about *not* doing the following checks, i.e., trusting that the rule
  // was correctly constructed.
  const ruleNode = vals[0];
  const body = grammar.rules[this.ruleName].body;
  return body.check(grammar, ruleNode.children) && ruleNode.numChildren() === body.getArity();
};

pexprs.UnicodeChar.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === 'string';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-eval.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-eval.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const TerminalNode = nodes.TerminalNode;
const NonterminalNode = nodes.NonterminalNode;
const IterationNode = nodes.IterationNode;

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should
  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures
  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific
  data structures to be "secrets" of that class, which is good for modularity.)

  The contract of this method is as follows:
  * When the return value is `true`,
    - the state object will have `expr.getArity()` more bindings than it did before the call.
  * When the return value is `false`,
    - the state object may have more bindings than it did before the call, and
    - its input stream's position may be anywhere.

  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state
  object's bindings nor its input stream's position will change if the expression fails to match.
*/
pexprs.PExpr.prototype.eval = common.abstract('eval'); // function(state) { ... }

pexprs.any.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.end.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode(state.grammar, undefined), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Terminal.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode(state.grammar, this.obj), origPos);
    return true;
  }
};

pexprs.Range.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.from <= ch && ch <= this.to) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};

pexprs.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};

pexprs.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }

  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];

    const endOffset =
        lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
        new IterationNode(state.grammar, cols[idx], colOffsets[idx], matchLength, isOptional));
    state._bindingOffsets.push(offset);
  }
  return true;
};

pexprs.Not.prototype.eval = function(state) {
  /*
    TODO:
    - Right now we're just throwing away all of the failures that happen inside a `not`, and
      recording `this` as a failed expression.
    - Double negation should be equivalent to lookahead, but that's not the case right now wrt
      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce
      a failure for 'foo' instead.
  */

  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();

  const ans = state.eval(this.expr);

  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }

  inputStream.pos = origPos;
  return true;
};

pexprs.Lookahead.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};

pexprs.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);

  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    // This rule is already active at this position, i.e., it is left-recursive.
    return app.handleCycle(state);
  }

  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];

  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};

pexprs.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const currentLeftRecursion = posInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];

  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    // We already know about this left recursion, but it's possible there are "involved
    // applications" that we don't already know about, so...
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    // New left recursion detected! Memoize a failure to try to get a seed parse.
    memoRec = posInfo.memoize(
        memoKey,
        {matchLength: 0, examinedLength: 0, value: false, rightmostFailureOffset: -1});
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};

pexprs.Apply.prototype.reallyEval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const body = ruleInfo.body;
  const description = ruleInfo.description;

  state.enterApplication(origPosInfo, this);

  if (description) {
    state.pushFailuresInfo();
  }

  // Reset the input stream's examinedLength property so that we can track
  // the examined length of this particular application.
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;

  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;

  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec); // updates origPosInfo's maxExaminedLength
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    // This application is not involved in left recursion, so it's ok to memoize it.
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;

  if (description) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }

  // Record trace information in the memo table, so that it is available if the memoized result
  // is used later.
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }

  // Fix the input stream's examinedLength -- it should be the maximum examined length
  // across all applications, not just this one.
  inputStream.examinedLength = Math.max(inputStream.examinedLength, origInputStreamExaminedLength);

  state.exitApplication(origPosInfo, value);

  return succeeded;
};

pexprs.Apply.prototype.evalOnce = function(expr, state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;

  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    return new NonterminalNode(
        state.grammar, this.ruleName, bindings, offsets, inputStream.pos - origPos);
  } else {
    return false;
  }
};

pexprs.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }

  const inputStream = state.inputStream;

  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();

    if (state.isTracing()) {
      // Before evaluating the body again, add a trace node for this application to the memo entry.
      // Its only child is a copy of the trace node from `newValue`, which will always be the last
      // element in `state.trace`.
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace(
          state.input, origPos, inputStream.pos, this, true, [newValue], [seedTrace.clone()]);
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1); // Drop the trace for the old seed.
    }
  }
  if (state.isTracing()) {
    // The last entry is for an unused result -- pop it and save it in the "real" entry.
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};

pexprs.UnicodeChar.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-generateExample.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-generateExample.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Helpers
// --------------------------------------------------------------------

function flatten(listOfLists) {
  return Array.prototype.concat.apply([], listOfLists);
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.generateExample = common.abstract('generateExample');

function categorizeExamples(examples) {
  // A list of rules that the system needs examples of, in order to generate an example
  //   for the current rule
  let examplesNeeded = examples.filter(example => example.hasOwnProperty('examplesNeeded'))
      .map(example => example.examplesNeeded);

  examplesNeeded = flatten(examplesNeeded);

  const uniqueExamplesNeeded = {};
  for (let i = 0; i < examplesNeeded.length; i++) {
    const currentExampleNeeded = examplesNeeded[i];
    uniqueExamplesNeeded[currentExampleNeeded] = true;
  }
  examplesNeeded = Object.keys(uniqueExamplesNeeded);

  // A list of successfully generated examples
  const successfulExamples = examples.filter(example => example.hasOwnProperty('value'))
      .map(item => item.value);

  // This flag returns true if the system cannot generate the rule it is currently
  //   attempting to generate, regardless of whether or not it has the examples it needs.
  //   Currently, this is only used in overriding generators to prevent the system from
  //   generating examples for certain rules (e.g. 'ident').
  const needHelp = examples.some(item => item.needHelp);

  return {
    examplesNeeded,
    successfulExamples,
    needHelp
  };
}

pexprs.any.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return {value: String.fromCharCode(Math.floor(Math.random() * 255))};
};

// Assumes that terminal's object is always a string
pexprs.Terminal.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: this.obj};
};

pexprs.Range.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  const rangeSize = this.to.charCodeAt(0) - this.from.charCodeAt(0);
  return {value: String.fromCharCode(
      this.from.charCodeAt(0) + Math.floor(rangeSize * Math.random())
  )};
};

pexprs.Param.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return actuals[this.index].generateExample(grammar, examples, inSyntacticContext, actuals);
};

pexprs.Alt.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  // items -> termExamples
  const termExamples = this.terms.map(term => {
    return term.generateExample(grammar, examples, inSyntacticContext, actuals);
  });

  const categorizedExamples = categorizeExamples(termExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // Alt can contain both an example and a request for examples
  if (successfulExamples.length > 0) {
    const i = Math.floor(Math.random() * successfulExamples.length);
    ans.value = successfulExamples[i];
  }
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }
  ans.needHelp = needHelp;

  return ans;
};

pexprs.Seq.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const factorExamples = this.factors.map(factor => {
    return factor.generateExample(grammar, examples, inSyntacticContext, actuals);
  });
  const categorizedExamples = categorizeExamples(factorExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // In a Seq, all pieces must succeed in order to have a successful example.
  if (examplesNeeded.length > 0 || needHelp) {
    ans.examplesNeeded = examplesNeeded;
    ans.needHelp = needHelp;
  } else {
    ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  }

  return ans;
};

pexprs.Iter.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const rangeTimes = Math.min(this.maxNumMatches - this.minNumMatches, 3);
  const numTimes = Math.floor(Math.random() * (rangeTimes + 1) + this.minNumMatches);
  const items = [];

  for (let i = 0; i < numTimes; i++) {
    items.push(this.expr.generateExample(grammar, examples, inSyntacticContext, actuals));
  }

  const categorizedExamples = categorizeExamples(items);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;

  const ans = {};

  // It's always either one or the other.
  // TODO: instead of ' ', call 'spaces.generateExample()'
  ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }

  return ans;
};

// Right now, 'Not' and 'Lookahead' generate nothing and assume that whatever follows will
//   work according to the encoded constraints.
pexprs.Not.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lookahead.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lex.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return this.expr.generateExample(grammar, examples, false, actuals);
};

pexprs.Apply.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const ans = {};

  const ruleName = this.substituteParams(actuals).toString();

  if (!examples.hasOwnProperty(ruleName)) {
    ans.examplesNeeded = [ruleName];
  } else {
    const relevantExamples = examples[ruleName];
    const i = Math.floor(Math.random() * relevantExamples.length);
    ans.value = relevantExamples[i];
  }

  return ans;
};

pexprs.UnicodeChar.prototype.generateExample = function(
    grammar, examples, inSyntacticContext, actuals) {
  let char;
  switch (this.category) {
    case 'Lu': char = ''; break;
    case 'Ll': char = ''; break;
    case 'Lt': char = ''; break;
    case 'Lm': char = ''; break;
    case 'Lo': char = ''; break;

    case 'Nl': char = ''; break;
    case 'Nd': char = ''; break;

    case 'Mn': char = '\u0487'; break;
    case 'Mc': char = ''; break;

    case 'Pc': char = ''; break;

    case 'Zs': char = '\u2001'; break;

    case 'L': char = ''; break;
    case 'Ltmo': char = ''; break;
  }
  return {value: char}; // 
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-getArity.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-getArity.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.getArity = common.abstract('getArity');

pexprs.any.getArity =
pexprs.end.getArity =
pexprs.Terminal.prototype.getArity =
pexprs.Range.prototype.getArity =
pexprs.Param.prototype.getArity =
pexprs.Apply.prototype.getArity =
pexprs.UnicodeChar.prototype.getArity = function() {
  return 1;
};

pexprs.Alt.prototype.getArity = function() {
  // This is ok b/c all terms must have the same arity -- this property is
  // checked by the Grammar constructor.
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};

pexprs.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};

pexprs.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};

pexprs.Not.prototype.getArity = function() {
  return 0;
};

pexprs.Lookahead.prototype.getArity =
pexprs.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-introduceParams.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-introduceParams.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Called at grammar creation time to rewrite a rule body, replacing each reference to a formal
  parameter with a `Param` node. Returns a PExpr -- either a new one, or the original one if
  it was modified in place.
*/
pexprs.PExpr.prototype.introduceParams = common.abstract('introduceParams');

pexprs.any.introduceParams =
pexprs.end.introduceParams =
pexprs.Terminal.prototype.introduceParams =
pexprs.Range.prototype.introduceParams =
pexprs.Param.prototype.introduceParams =
pexprs.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};

pexprs.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};

pexprs.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};

pexprs.Iter.prototype.introduceParams =
pexprs.Not.prototype.introduceParams =
pexprs.Lookahead.prototype.introduceParams =
pexprs.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};

pexprs.Apply.prototype.introduceParams = function(formals) {
  const index = formals.indexOf(this.ruleName);
  if (index >= 0) {
    if (this.args.length > 0) {
      // TODO: Should this be supported? See issue #64.
      throw new Error('Parameterized rules cannot be passed as arguments to another rule.');
    }
    return new pexprs.Param(index).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-isNullable.js":
/*!******************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-isNullable.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns `true` if this parsing expression may accept without consuming any input.
pexprs.PExpr.prototype.isNullable = function(grammar) {
  return this._isNullable(grammar, Object.create(null));
};

pexprs.PExpr.prototype._isNullable = common.abstract('_isNullable');

pexprs.any._isNullable =
pexprs.Range.prototype._isNullable =
pexprs.Param.prototype._isNullable =
pexprs.Plus.prototype._isNullable =
pexprs.UnicodeChar.prototype._isNullable = function(grammar, memo) {
  return false;
};

pexprs.end._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Terminal.prototype._isNullable = function(grammar, memo) {
  if (typeof this.obj === 'string') {
    // This is an over-simplification: it's only correct if the input is a string. If it's an array
    // or an object, then the empty string parsing expression is not nullable.
    return this.obj === '';
  } else {
    return false;
  }
};

pexprs.Alt.prototype._isNullable = function(grammar, memo) {
  return this.terms.length === 0 ||
      this.terms.some(term => term._isNullable(grammar, memo));
};

pexprs.Seq.prototype._isNullable = function(grammar, memo) {
  return this.factors.every(factor => factor._isNullable(grammar, memo));
};

pexprs.Star.prototype._isNullable =
pexprs.Opt.prototype._isNullable =
pexprs.Not.prototype._isNullable =
pexprs.Lookahead.prototype._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Lex.prototype._isNullable = function(grammar, memo) {
  return this.expr._isNullable(grammar, memo);
};

pexprs.Apply.prototype._isNullable = function(grammar, memo) {
  const key = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key)) {
    const body = grammar.rules[this.ruleName].body;
    const inlined = body.substituteParams(this.args);
    memo[key] = false; // Prevent infinite recursion for recursive rules.
    memo[key] = inlined._isNullable(grammar, memo);
  }
  return memo[key];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-outputRecipe.js":
/*!********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-outputRecipe.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.outputRecipe = common.abstract('outputRecipe');

pexprs.any.outputRecipe = function(formals, grammarInterval) {
  return ['any', getMetaInfo(this, grammarInterval)];
};

pexprs.end.outputRecipe = function(formals, grammarInterval) {
  return ['end', getMetaInfo(this, grammarInterval)];
};

pexprs.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'terminal',
    getMetaInfo(this, grammarInterval),
    this.obj
  ];
};

pexprs.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'range',
    getMetaInfo(this, grammarInterval),
    this.from,
    this.to
  ];
};

pexprs.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'param',
    getMetaInfo(this, grammarInterval),
    this.index
  ];
};

pexprs.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'alt',
    getMetaInfo(this, grammarInterval)
  ].concat(this.terms.map(term => term.outputRecipe(formals, grammarInterval)));
};

pexprs.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0]; // [extension, original]
  return extension.outputRecipe(formals, grammarInterval);
};

pexprs.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    'splice',
    getMetaInfo(this, grammarInterval),
    beforeTerms.map(term => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map(term => term.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'seq',
    getMetaInfo(this, grammarInterval)
  ].concat(this.factors.map(factor => factor.outputRecipe(formals, grammarInterval)));
};

pexprs.Star.prototype.outputRecipe =
pexprs.Plus.prototype.outputRecipe =
pexprs.Opt.prototype.outputRecipe =
pexprs.Not.prototype.outputRecipe =
pexprs.Lookahead.prototype.outputRecipe =
pexprs.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};

pexprs.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'app',
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map(arg => arg.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'unicodeChar',
    getMetaInfo(this, grammarInterval),
    this.category
  ];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-substituteParams.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-substituteParams.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a PExpr that results from recursively replacing every formal parameter (i.e., instance
  of `Param`) inside this PExpr with its actual value from `actuals` (an Array).

  The receiver must not be modified; a new PExpr must be returned if any replacement is necessary.
*/
// function(actuals) { ... }
pexprs.PExpr.prototype.substituteParams = common.abstract('substituteParams');

pexprs.any.substituteParams =
pexprs.end.substituteParams =
pexprs.Terminal.prototype.substituteParams =
pexprs.Range.prototype.substituteParams =
pexprs.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};

pexprs.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};

pexprs.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs.Alt(
      this.terms.map(term => term.substituteParams(actuals)));
};

pexprs.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs.Seq(
      this.factors.map(factor => factor.substituteParams(actuals)));
};

pexprs.Iter.prototype.substituteParams =
pexprs.Not.prototype.substituteParams =
pexprs.Lookahead.prototype.substituteParams =
pexprs.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};

pexprs.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    // Avoid making a copy of this application, as an optimization
    return this;
  } else {
    const args = this.args.map(arg => arg.substituteParams(actuals));
    return new pexprs.Apply(this.ruleName, args);
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toArgumentNameList.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const {copyWithoutDuplicates} = common;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}

function resolveDuplicatedNames(argumentNameList) {
  // `count` is used to record the number of times each argument name occurs in the list,
  // this is useful for checking duplicated argument name. It maps argument names to ints.
  const count = Object.create(null);
  argumentNameList.forEach(argName => {
    count[argName] = (count[argName] || 0) + 1;
  });

  // Append subscripts ('_1', '_2', ...) to duplicate argument names.
  Object.keys(count).forEach(dupArgName => {
    if (count[dupArgName] <= 1) {
      return;
    }

    // This name shows up more than once, so add subscripts.
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + '_' + subscript++;
      }
    });
  });
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a list of strings that will be used as the default argument names for its receiver
  (a pexpr) in a semantic action. This is used exclusively by the Semantics Editor.

  `firstArgIndex` is the 1-based index of the first argument name that will be generated for this
  pexpr. It enables us to name arguments positionally, e.g., if the second argument is a
  non-alphanumeric terminal like "+", it will be named '$2'.

  `noDupCheck` is true if the caller of `toArgumentNameList` is not a top level caller. It enables
  us to avoid nested duplication subscripts appending, e.g., '_1_1', '_1_2', by only checking
  duplicates at the top level.

  Here is a more elaborate example that illustrates how this method works:
  `(a "+" b).toArgumentNameList(1)` evaluates to `['a', '$2', 'b']` with the following recursive
  calls:

    (a).toArgumentNameList(1) -> ['a'],
    ("+").toArgumentNameList(2) -> ['$2'],
    (b).toArgumentNameList(3) -> ['b']

  Notes:
  * This method must only be called on well-formed expressions, e.g., the receiver must
    not have any Alt sub-expressions with inconsistent arities.
  * e.getArity() === e.toArgumentNameList(1).length
*/
// function(firstArgIndex, noDupCheck) { ... }
pexprs.PExpr.prototype.toArgumentNameList = common.abstract('toArgumentNameList');

pexprs.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['any'];
};

pexprs.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['end'];
};

pexprs.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === 'string' && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    // If this terminal is a valid suffix for a JS identifier, just prepend it with '_'
    return ['_' + this.obj];
  } else {
    // Otherwise, name it positionally.
    return ['$' + firstArgIndex];
  }
};

pexprs.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + '_to_' + this.to;
  // If the `argName` is not valid then try to prepend a `_`.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '_' + argName;
  }
  // If the `argName` still not valid after prepending a `_`, then name it positionally.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '$' + firstArgIndex;
  }
  return [argName];
};

pexprs.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // `termArgNameLists` is an array of arrays where each row is the
  // argument name list that corresponds to a term in this alternation.
  const termArgNameLists = this.terms.map(term => term.toArgumentNameList(firstArgIndex, true));

  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join('_or_'));
  }

  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // Generate the argument name list, without worrying about duplicates.
  let argumentNameList = [];
  this.factors.forEach(factor => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);

    // Shift the firstArgIndex to take this factor's argument names into account.
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck)
      .map(exprArgumentString => exprArgumentString[exprArgumentString.length - 1] === 's' ?
          exprArgumentString + 'es' :
          exprArgumentString + 's');
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(argName => {
    return 'opt' + argName[0].toUpperCase() + argName.slice(1);
  });
};

pexprs.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};

pexprs.Lookahead.prototype.toArgumentNameList =
pexprs.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};

pexprs.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};

pexprs.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['$' + firstArgIndex];
};

pexprs.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['param' + this.index];
};

// "Value pexprs" (Value, Str, Arr, Obj) are going away soon, so we don't worry about them here.


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toDisplayString.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toDisplayString.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns a string representing the PExpr, for use as a UI label, etc.
pexprs.PExpr.prototype.toDisplayString = common.abstract('toDisplayString');

pexprs.Alt.prototype.toDisplayString =
pexprs.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return '[' + this.constructor.name + ']';
};

pexprs.any.toDisplayString =
pexprs.end.toDisplayString =
pexprs.Iter.prototype.toDisplayString =
pexprs.Not.prototype.toDisplayString =
pexprs.Lookahead.prototype.toDisplayString =
pexprs.Lex.prototype.toDisplayString =
pexprs.Terminal.prototype.toDisplayString =
pexprs.Range.prototype.toDisplayString =
pexprs.Param.prototype.toDisplayString = function() {
  return this.toString();
};

pexprs.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toDisplayString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toDisplayString = function() {
  return 'Unicode [' + this.category + '] character';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toFailure.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toFailure.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.toFailure = common.abstract('toFailure');

pexprs.any.toFailure = function(grammar) {
  return new Failure(this, 'any object', 'description');
};

pexprs.end.toFailure = function(grammar) {
  return new Failure(this, 'end of input', 'description');
};

pexprs.Terminal.prototype.toFailure = function(grammar) {
  return new Failure(this, this.obj, 'string');
};

pexprs.Range.prototype.toFailure = function(grammar) {
  // TODO: come up with something better
  return new Failure(this, JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');
};

pexprs.Not.prototype.toFailure = function(grammar) {
  const description = this.expr === pexprs.any ?
      'nothing' :
      'not ' + this.expr.toFailure(grammar);
  return new Failure(this, description, 'description');
};

pexprs.Lookahead.prototype.toFailure = function(grammar) {
  return this.expr.toFailure(grammar);
};

pexprs.Apply.prototype.toFailure = function(grammar) {
  let description = grammar.rules[this.ruleName].description;
  if (!description) {
    const article = (/^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a');
    description = article + ' ' + this.ruleName;
  }
  return new Failure(this, description, 'description');
};

pexprs.UnicodeChar.prototype.toFailure = function(grammar) {
  return new Failure(this, 'a Unicode [' + this.category + '] character', 'description');
};

pexprs.Alt.prototype.toFailure = function(grammar) {
  const fs = this.terms.map(t => t.toFailure(grammar));
  const description = '(' + fs.join(' or ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Seq.prototype.toFailure = function(grammar) {
  const fs = this.factors.map(f => f.toFailure(grammar));
  const description = '(' + fs.join(' ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Iter.prototype.toFailure = function(grammar) {
  const description = '(' + this.expr.toFailure(grammar) + this.operator + ')';
  return new Failure(this, description, 'description');
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toString.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toString.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.
  Note that this is not an iff (<==>): e.g.,
  (~"b" "a").toString() !== ("a").toString(), even though
  ~"b" "a" and "a" are interchangeable in any grammar,
  both in terms of the languages they accept and their arities.
*/
pexprs.PExpr.prototype.toString = common.abstract('toString');

pexprs.any.toString = function() {
  return 'any';
};

pexprs.end.toString = function() {
  return 'end';
};

pexprs.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};

pexprs.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);
};

pexprs.Param.prototype.toString = function() {
  return '$' + this.index;
};

pexprs.Lex.prototype.toString = function() {
  return '#(' + this.expr.toString() + ')';
};

pexprs.Alt.prototype.toString = function() {
  return this.terms.length === 1 ?
    this.terms[0].toString() :
    '(' + this.terms.map(term => term.toString()).join(' | ') + ')';
};

pexprs.Seq.prototype.toString = function() {
  return this.factors.length === 1 ?
    this.factors[0].toString() :
    '(' + this.factors.map(factor => factor.toString()).join(' ') + ')';
};

pexprs.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};

pexprs.Not.prototype.toString = function() {
  return '~' + this.expr;
};

pexprs.Lookahead.prototype.toString = function() {
  return '&' + this.expr;
};

pexprs.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toString = function() {
  return '\\p{' + this.category + '}';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const UnicodeCategories = __webpack_require__(/*! ../third_party/UnicodeCategories */ "./node_modules/ohm-js/third_party/UnicodeCategories.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// General stuff

class PExpr {
  constructor() {
    if (this.constructor === PExpr) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }

  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}

// Any

const any = Object.create(PExpr.prototype);

// End

const end = Object.create(PExpr.prototype);

// Terminals

class Terminal extends PExpr {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}

// Ranges

class Range extends PExpr {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
  }
}

// Parameters

class Param extends PExpr {
  constructor(index) {
    super();
    this.index = index;
  }
}

// Alternation

class Alt extends PExpr {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}

// Extend is an implementation detail of rule extension

class Extend extends Alt {
  constructor(superGrammar, name, body) {
    const origBody = superGrammar.rules[name].body;
    super([body, origBody]);

    this.superGrammar = superGrammar;
    this.name = name;
    this.body = body;
  }
}

// Splice is an implementation detail of rule overriding with the `...` operator.
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);

    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}

// Sequences

class Seq extends PExpr {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}

// Iterators and optionals

class Iter extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Star extends Iter {}
class Plus extends Iter {}
class Opt extends Iter {}

Star.prototype.operator = '*';
Plus.prototype.operator = '+';
Opt.prototype.operator = '?';

Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;

Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;

// Predicates

class Not extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Lookahead extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// "Lexification"

class Lex extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// Rule application

class Apply extends PExpr {
  constructor(ruleName, args=[]) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }

  isSyntactic() {
    return common.isSyntactic(this.ruleName);
  }

  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, '_memoKey', {value: this.toString()});
    }
    return this._memoKey;
  }
}

// Unicode character

class UnicodeChar extends PExpr {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.PExpr = PExpr;
exports.any = any;
exports.end = end;
exports.Terminal = Terminal;
exports.Range = Range;
exports.Param = Param;
exports.Alt = Alt;
exports.Extend = Extend;
exports.Splice = Splice;
exports.Seq = Seq;
exports.Iter = Iter;
exports.Star = Star;
exports.Plus = Plus;
exports.Opt = Opt;
exports.Not = Not;
exports.Lookahead = Lookahead;
exports.Lex = Lex;
exports.Apply = Apply;
exports.UnicodeChar = UnicodeChar;

// --------------------------------------------------------------------
// Extensions
// --------------------------------------------------------------------

__webpack_require__(/*! ./pexprs-allowsSkippingPrecedingSpace */ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js");
__webpack_require__(/*! ./pexprs-assertAllApplicationsAreValid */ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js");
__webpack_require__(/*! ./pexprs-assertChoicesHaveUniformArity */ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js");
__webpack_require__(/*! ./pexprs-assertIteratedExprsAreNotNullable */ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js");
__webpack_require__(/*! ./pexprs-check */ "./node_modules/ohm-js/src/pexprs-check.js");
__webpack_require__(/*! ./pexprs-eval */ "./node_modules/ohm-js/src/pexprs-eval.js");
__webpack_require__(/*! ./pexprs-getArity */ "./node_modules/ohm-js/src/pexprs-getArity.js");
__webpack_require__(/*! ./pexprs-generateExample */ "./node_modules/ohm-js/src/pexprs-generateExample.js");
__webpack_require__(/*! ./pexprs-outputRecipe */ "./node_modules/ohm-js/src/pexprs-outputRecipe.js");
__webpack_require__(/*! ./pexprs-introduceParams */ "./node_modules/ohm-js/src/pexprs-introduceParams.js");
__webpack_require__(/*! ./pexprs-isNullable */ "./node_modules/ohm-js/src/pexprs-isNullable.js");
__webpack_require__(/*! ./pexprs-substituteParams */ "./node_modules/ohm-js/src/pexprs-substituteParams.js");
__webpack_require__(/*! ./pexprs-toDisplayString */ "./node_modules/ohm-js/src/pexprs-toDisplayString.js");
__webpack_require__(/*! ./pexprs-toArgumentNameList */ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js");
__webpack_require__(/*! ./pexprs-toFailure */ "./node_modules/ohm-js/src/pexprs-toFailure.js");
__webpack_require__(/*! ./pexprs-toString */ "./node_modules/ohm-js/src/pexprs-toString.js");


/***/ }),

/***/ "./node_modules/ohm-js/src/util.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/util.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Given an array of numbers `arr`, return an array of the numbers as strings,
// right-justified and padded to the same length.
function padNumbersToEqualLength(arr) {
  let maxLen = 0;
  const strings = arr.map(n => {
    const str = n.toString();
    maxLen = Math.max(maxLen, str.length);
    return str;
  });
  return strings.map(s => common.padLeft(s, maxLen));
}

// Produce a new string that would be the result of copying the contents
// of the string `src` onto `dest` at offset `offest`.
function strcpy(dest, src, offset) {
  const origDestLen = dest.length;
  const start = dest.slice(0, offset);
  const end = dest.slice(offset + src.length);
  return (start + src + end).substr(0, origDestLen);
}

// Casts the underlying lineAndCol object to a formatted message string,
// highlighting `ranges`.
function lineAndColumnToMessage(...ranges) {
  const lineAndCol = this;
  const offset = lineAndCol.offset;
  const repeatStr = common.repeatStr;

  const sb = new common.StringBuffer();
  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\n');

  // An array of the previous, current, and next line numbers as strings of equal length.
  const lineNumbers = padNumbersToEqualLength([
    lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
    lineAndCol.lineNum,
    lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
  ]);

  // Helper for appending formatting input lines to the buffer.
  const appendLine = (num, content, prefix) => {
    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\n');
  };

  // Include the previous line for context if possible.
  if (lineAndCol.prevLine != null) {
    appendLine(0, lineAndCol.prevLine, '  ');
  }
  // Line that the error occurred on.
  appendLine(1, lineAndCol.line, '> ');

  // Build up the line that points to the offset and possible indicates one or more ranges.
  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.
  const lineLen = lineAndCol.line.length;
  let indicationLine = repeatStr(' ', lineLen + 1);
  for (let i = 0; i < ranges.length; ++i) {
    let startIdx = ranges[i][0];
    let endIdx = ranges[i][1];
    common.assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');

    const lineStartOffset = offset - lineAndCol.colNum + 1;
    startIdx = Math.max(0, startIdx - lineStartOffset);
    endIdx = Math.min(endIdx - lineStartOffset, lineLen);

    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);
  }
  const gutterWidth = 2 + lineNumbers[1].length + 3;
  sb.append(repeatStr(' ', gutterWidth));
  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);
  sb.append(indicationLine.replace(/ +$/, '') + '\n');

  // Include the next line for context if possible.
  if (lineAndCol.nextLine != null) {
    appendLine(2, lineAndCol.nextLine, '  ');
  }
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

let builtInRulesCallbacks = [];

// Since Grammar.BuiltInRules is bootstrapped, most of Ohm can't directly depend it.
// This function allows modules that do depend on the built-in rules to register a callback
// that will be called later in the initialization process.
exports.awaitBuiltInRules = cb => {
  builtInRulesCallbacks.push(cb);
};

exports.announceBuiltInRules = grammar => {
  builtInRulesCallbacks.forEach(cb => {
    cb(grammar);
  });
  builtInRulesCallbacks = null;
};

// Return an object with the line and column information for the given
// offset in `str`.
exports.getLineAndColumn = (str, offset) => {
  let lineNum = 1;
  let colNum = 1;

  let currOffset = 0;
  let lineStartOffset = 0;

  let nextLine = null;
  let prevLine = null;
  let prevLineStartOffset = -1;

  while (currOffset < offset) {
    const c = str.charAt(currOffset++);
    if (c === '\n') {
      lineNum++;
      colNum = 1;
      prevLineStartOffset = lineStartOffset;
      lineStartOffset = currOffset;
    } else if (c !== '\r') {
      colNum++;
    }
  }

  // Find the end of the target line.
  let lineEndOffset = str.indexOf('\n', lineStartOffset);
  if (lineEndOffset === -1) {
    lineEndOffset = str.length;
  } else {
    // Get the next line.
    const nextLineEndOffset = str.indexOf('\n', lineEndOffset + 1);
    nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset)
                                        : str.slice(lineEndOffset, nextLineEndOffset);
    // Strip leading and trailing EOL char(s).
    nextLine = nextLine.replace(/^\r?\n/, '').replace(/\r$/, '');
  }

  // Get the previous line.
  if (prevLineStartOffset >= 0) {
    prevLine = str.slice(prevLineStartOffset, lineStartOffset)
        .replace(/\r?\n$/, ''); // Strip trailing EOL char(s).
  }

  // Get the target line, stripping a trailing carriage return if necessary.
  const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, '');

  return {
    offset,
    lineNum,
    colNum,
    line,
    prevLine,
    nextLine,
    toString: lineAndColumnToMessage
  };
};

// Return a nicely-formatted string describing the line and column for the
// given offset in `str` highlighting `ranges`.
exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
  return exports.getLineAndColumn(str, offset).toString(...ranges);
};

exports.uniqueId = (() => {
  let idCounter = 0;
  return prefix => '' + prefix + idCounter++;
})();


/***/ }),

/***/ "./node_modules/ohm-js/src/version.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/version.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global __GLOBAL_OHM_VERSION__ */



// When running under Node, read the version from package.json. For the browser,
// use a special global variable defined in the build process (see webpack.config.js).
module.exports = typeof __GLOBAL_OHM_VERSION__ === 'string'
    ? __GLOBAL_OHM_VERSION__
    : __webpack_require__(/*! ../package.json */ "./node_modules/ohm-js/package.json").version;


/***/ }),

/***/ "./node_modules/ohm-js/third_party/UnicodeCategories.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/third_party/UnicodeCategories.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Based on https://github.com/mathiasbynens/unicode-9.0.0.
// These are just categories that are used in ES5/ES2015.
// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.
module.exports = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,

  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,

  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,

  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,

  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,

  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};


/***/ }),

/***/ "./node_modules/util-extend/extend.js":
/*!********************************************!*\
  !*** ./node_modules/util-extend/extend.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = extend;
function extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || typeof add !== 'object') return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}


/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./plugins/merriam.js":
/*!****************************!*\
  !*** ./plugins/merriam.js ***!
  \****************************/
/*! exports provided: merriam, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriam", function() { return merriam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriam; });
const merriam = {
    name: "MerriamAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    cache: null,
    cacheNextItem: null,
    currentResponseItemIndex: -1,
    src: null,
    get: async function(prerequisite, arg){
        if(arg){
            if(!this.cache){
                throw Error("No result has been fetched");
            }
            if(arg == "next"){
                let results = this.cache.results;
                this.currentResponseItemIndex += 1;
                if(this.currentResponseItemIndex >= results.length){
                    this.currentResponseItemIndex = 0;
                }
                this.response = this.cache.results[this.currentResponseItemIndex];
                // put the result in the next item cache
                this.cacheNextItem = this.cache.results[this.currentResponseItemIndex];
                return JSON.stringify(this.response, null, '\t');
            }
            // here we assume that the arg is a key in the next item cache
            this.response = this.cacheNextItem[arg];
            return this.response;
        }
        const payload = parsePrerequisite(prerequisite);
        const params = {
            "method": "POST",
            "headers": {
                "content-type": "application/json"
            },
            "body": JSON.stringify(payload)
        };
        let response = await fetch(this.src, params);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            this.cache = json;
            return JSON.stringify(this.response, null, '\t');
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    }
}


let parsePrerequisite = (p) => {
    let pList = p.split(";");
    let payload = {};
    pList.forEach((item) => {
        let key = item.split(":")[0];
        let value = item.replace(`${key}:`, "");
        switch(key){
        case "fields":
            payload["fields"] = value.split(',');
            break;
        case "weights":
            let weights = {};
            value.split(",").forEach((w) => {
                let [w_name, w_value] = w.split(":");
                weights[w_name] = Number(w_value);
            });
            payload["weights"] = weights;
            break;
        case "doc_ids":
            payload["doc_ids"] = value.split(",");
            break;
        case "limit":
            payload["limit"] = Number(value);
            break;
        }
    });
    return payload;
}





/***/ }),

/***/ "./plugins/plugins.js":
/*!****************************!*\
  !*** ./plugins/plugins.js ***!
  \****************************/
/*! exports provided: plugins, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugins", function() { return plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return plugins; });
/* harmony import */ var _testAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./testAPI.js */ "./plugins/testAPI.js");
/* harmony import */ var _merriam_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./merriam.js */ "./plugins/merriam.js");



const plugins = {
    "MerriamAPI": _merriam_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    "TestAPI": _testAPI_js__WEBPACK_IMPORTED_MODULE_0__["default"]
}




/***/ }),

/***/ "./plugins/testAPI.js":
/*!****************************!*\
  !*** ./plugins/testAPI.js ***!
  \****************************/
/*! exports provided: test, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test", function() { return test; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return test; });
const test = {
    name: "TestAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    src: null,
    get: async function(prerequisite, key){
        if(key){
            if(!this.response){
                throw Error("No result has been fetched");
            }
            return this.response[key];
        }
        let src = this.src;
        if(prerequisite){
            src = src + "/" + prerequisite;
        }
        let response = await fetch(src);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            return JSON.stringify(json);
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    },
};




/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9FeGVjdXRpb25TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9BdWRpby5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9DYXJkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvRHJhd2luZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0ZpZWxkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9QYXJ0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dvcmxkU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9jbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9lcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9oYW5kSW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3V0aWxzL21lcnJpYW1JbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9zZXJpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVyLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvQXJlYVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9BdWRpb1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Ccm93c2VyVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0J1dHRvblZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9DYXJkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0ZpZWxkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0hhbG8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9JbWFnZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9QYXJ0Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1Jlc291cmNlVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1N0YWNrVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1dpbmRvd1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Xb3JsZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9jb250ZXh0bWVudS9Db250ZXh0TWVudS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2NvbnRleHRtZW51L0NvbnRleHRNZW51SXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvQ29sb3JQaWNrZXJUb29sLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9Db2xvcldoZWVsV2lkZ2V0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9EcmF3aW5nVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvRXJhc2VyVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvUGVuY2lsVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JDdXN0b21MaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JMb2NhdGlvbkluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvck1lc3Nlbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yUHJvcEl0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclByb3BMaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JTdWJwYXJ0c1BhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclRhYi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvdXRpbHMvc3VicGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvQ2FyZFJvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL25hdmlnYXRvci9OYXZpZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvU3RhY2tSb3cuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvV3JhcHBlZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL2Rpc3QvYnVpbHQtaW4tcnVsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9kaXN0L29obS1ncmFtbWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZGlzdC9vcGVyYXRpb25zLWFuZC1hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZXh0cmFzL1Zpc2l0b3JGYW1pbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvc2VtYW50aWNzLXRvQVNULmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0Nhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0ZhaWx1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9HcmFtbWFyRGVjbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnB1dFN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL01hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvTmFtZXNwYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1Bvc0luZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvU2VtYW50aWNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1RyYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9ub2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWNoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1ldmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1nZW5lcmF0ZUV4YW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWdldEFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1pbnRyb2R1Y2VQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWlzTnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLW91dHB1dFJlY2lwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtc3Vic3RpdHV0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9Bcmd1bWVudE5hbWVMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy10b0Rpc3BsYXlTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLXRvRmFpbHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3RoaXJkX3BhcnR5L1VuaWNvZGVDYXRlZ29yaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsLWV4dGVuZC9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL21lcnJpYW0uanMiLCJ3ZWJwYWNrOi8vLy4vcGx1Z2lucy9wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL3BsdWdpbnMvdGVzdEFQSS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5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Q3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVFQUFjO0FBQy9DO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsV0FBVzs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLFdBQVc7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQSw2Q0FBNkMsdUVBQWM7QUFDM0QsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBLDZCQUE2QixZQUFZLEdBQUcsV0FBVzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsVUFBVTs7QUFFMUYsZ0ZBQWdGLFVBQVU7QUFDMUYsdUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLDhCQUE4QjtBQUN6RztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0VBQWE7QUFDeEQ7QUFDQSxRQUFRLGdFQUFhO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxpQkFBaUIsU0FBUyxHQUFHLG1DQUFtQzs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBYTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0VBQWE7QUFDckIsUUFBUSxnRUFBYTtBQUNyQixLQUFLO0FBQ0wsUUFBUSxnRUFBYTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDJFQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSw0QkFBNEIsc0RBQUk7QUFDaEMsNkJBQTZCLHVEQUFLO0FBQ2xDLDZCQUE2Qix1REFBSztBQUNsQyw4QkFBOEIsd0RBQU07QUFDcEMsNkJBQTZCLDREQUFVO0FBQ3ZDLDhCQUE4Qix3REFBTTtBQUNwQyw2QkFBNkIsdURBQUs7QUFDbEMsK0JBQStCLHlEQUFPO0FBQ3RDLDZCQUE2Qix3REFBSztBQUNsQyw0QkFBNEIsdURBQUk7QUFDaEMsNkJBQTZCLHVEQUFLO0FBQ2xDLCtCQUErQix5REFBTztBQUN0QyxnQ0FBZ0MsMERBQVE7O0FBRXhDO0FBQ0EsOEJBQThCLDZEQUFVO0FBQ3hDLDZCQUE2Qiw0REFBUztBQUN0Qyw2QkFBNkIsNERBQVM7QUFDdEMsNEJBQTRCLDJEQUFRO0FBQ3BDLDhCQUE4QiwwREFBVTtBQUN4Qyw2QkFBNkIsNERBQVM7QUFDdEMsK0JBQStCLHNFQUFXO0FBQzFDLDZCQUE2Qiw0REFBUztBQUN0Qyw0QkFBNEIsMkRBQVE7QUFDcEMsNkJBQTZCLDREQUFTO0FBQ3RDLCtCQUErQiw4REFBVztBQUMxQyxnQ0FBZ0MsK0RBQVk7OztBQUc1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBRztBQUN6QixDQUFDO0FBQ0Qsc0JBQXNCLDhDQUFHO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qyx1REFBSTtBQUNoRCxpREFBaUQsc0VBQVc7QUFDNUQsOENBQThDLGlFQUFNOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhFQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOzs7QUFNQzs7Ozs7Ozs7Ozs7OztBQzkyQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQjtBQUtNOztBQUVyQzs7QUFFQSxtQkFBbUIsNkNBQUk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxvRkFBa0I7QUFDMUIsUUFBUSwwRkFBd0I7QUFDaEMsUUFBUSxxRkFBbUI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JHRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStCO0FBS007O0FBRXJDLG9CQUFvQiw2Q0FBSTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEUsc0RBQXNELGtCQUFrQjtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0ZBQWtCO0FBQzFCLFFBQVEsMEZBQXdCO0FBQ2hDLFFBQVEsbUZBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDM0ZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7QUFLTTs7QUFFckMsc0JBQXNCLDZDQUFJO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9GQUFrQjtBQUMxQixRQUFRLDBGQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3pGRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZCO0FBSVk7QUFLSjs7QUFFckMscUJBQXFCLGdEQUFJO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLG9GQUFrQjtBQUMxQixRQUFRLDBGQUF3QjtBQUNoQyxRQUFRLG1GQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDekhGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytCO0FBR1U7O0FBS0o7O0FBRXJDLG1CQUFtQiw2Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsb0ZBQWtCO0FBQzFCLFFBQVEscUZBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNoRkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUMrQjtBQUlNOztBQUVyQzs7QUFFQSxzQkFBc0IsNkNBQUk7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRkFBa0I7QUFDMUIsUUFBUSwwRkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFLRTs7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QSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixVQUFVLG9DQUFvQyxXQUFXO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN0UkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QjtBQUNFO0FBS007O0FBRXJDLHFCQUFxQixnREFBSTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRkFBa0I7QUFDMUIsUUFBUSwwRkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQzs7Ozs7Ozs7Ozs7OztBQzVJRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZCOzs7QUFHN0IseUJBQXlCLGdEQUFJO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsb0NBQW9DLFdBQVc7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JVRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx3REFBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2hKRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWMsY0FBYyxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBLHFGQUFxRixpQkFBaUIsWUFBWTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUM3S0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBNkM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQyxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0RBQXdELGNBQWM7QUFDdEUsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBTUU7Ozs7Ozs7Ozs7Ozs7QUNwUkY7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3hHRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQU07QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTUU7Ozs7Ozs7Ozs7Ozs7QUM3Q0Y7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN4Q0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7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QTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUMzZUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9FOzs7Ozs7Ozs7Ozs7O0FDOWZGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QzVDLFNBQVMscUNBQXFDO0FBQzlDLFNBQVMscUNBQXFDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDbFZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9EQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsTUFBTSxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRGQUE0RixRQUFRO0FBQ3BHO0FBQ0EscUZBQXFGLGNBQWM7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkVBQW9CO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQyxLQUFLO0FBQ3JDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4RUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDenZCRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDaFhGO0FBQUE7QUFBQTtBQUFBO0FBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0RBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNwVEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ2U7O0FBRXRFLGdEQUFnRCxtRUFBVzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RCxhQUFhO0FBQ2IsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEUsYUFBYTtBQUNiLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9DQUFvQztBQUN2RyxrRUFBa0UsZ0RBQWdEO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9DQUFvQztBQUN2RyxrRUFBa0UsZ0RBQWdEO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakMsOEJBQThCLEVBQUU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDMzlCRjtBQUFBO0FBQUE7QUFBQTtBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixvREFBUTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxLQUFLO0FBQ2xGLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQy9LRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixvREFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3RIRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixvREFBUTtBQUNqQztBQUNBOztBQUVBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hELDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUMvUkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0RBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsY0FBYztBQUM5RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDL0lGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDbUQ7O0FBRW5ELHFEQUFxRCwyREFBZTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQyxFQUFFLHlCQUF5QjtBQUN4RiwwQkFBMEIsV0FBVztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQixFQUFFLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5Q0FBeUMsc0RBQXNEO0FBQy9GLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQ0FBMEMscURBQXFEO0FBQy9GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNsYUY7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQztBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNqRUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxJQUFJLFlBQVksSUFBSSxZQUFZLElBQUksZ0JBQWdCO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDeExGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksT0FBTztBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFlBQVksSUFBSSxZQUFZLElBQUksWUFBWSxJQUFJLGdCQUFnQjtBQUNuSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsNkJBQTZCLFFBQVE7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsWUFBWTtBQUNyQyw2QkFBNkIsWUFBWTs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDcGFGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7QUFDRztBQUNBO0FBQ1U7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixxREFBUTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QyxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN6V0Y7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3ZQRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JQRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7QUFDVTtBQUNFO0FBQ0U7QUFDSTtBQUNaO0FBQzdDOztBQUVBO0FBQ0EsMkNBQTJDLHFEQUFTO0FBQ3BELGtEQUFrRCwwREFBYztBQUNoRSxtREFBbUQsNERBQWdCO0FBQ25FLGlEQUFpRCwyREFBZTtBQUNoRSxnREFBZ0QsOERBQWtCOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSyxNQUFNLEtBQUs7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7O0FBRUEsdUJBQXVCLHVEQUFTO0FBQ2hDLG9DQUFvQyx1REFBUztBQUM3QyxTQUFTO0FBQ1Qsb0NBQW9DLHVEQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHNCQUFzQixlQUFlLGdCQUFnQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzZ0JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLEtBQUs7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUMzVkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF5RTtBQUNLOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDelFGO0FBQUE7QUFBQTtBQUFBO0FBQWlEOztBQUVqRDtBQUNBLGlEQUFpRCwwREFBYzs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDakpGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ3lEO0FBQ1o7QUFDaUM7O0FBRTlFLHFEQUFxRCw4REFBa0I7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsY0FBYztBQUNuRiw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHVFQUFvQjtBQUN4RCxtQ0FBbUMsc0VBQW1COztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBUztBQUNoQyx3QkFBd0IsdURBQVM7QUFDakMsU0FBUztBQUNULHdCQUF3Qix1REFBUztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEIsRUFBRSxvQkFBb0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix1REFBUztBQUM1QjtBQUNBLG1CQUFtQix1REFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVSxXQUFXLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDelRGO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDakZGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlCQUF5QixpQkFBaUIsR0FBRyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDcENGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isb0RBQVE7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkUsb0JBQW9CO0FBQ2pHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNwTEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ0s7QUFDTjtBQUNGOztBQUVuQztBQUNBLDhDQUE4QyxvREFBUTtBQUN0RCw2Q0FBNkMsbURBQU87QUFDcEQsNkNBQTZDLHVEQUFXOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixvREFBUTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU0sRUFBRSxPQUFPO0FBQ3JDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUyxJQUFJLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUyxJQUFJLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDaFdhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQywrREFBZTtBQUMzQyxlQUFlLG1CQUFPLENBQUMscURBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTs7QUFFakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzFMYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMseURBQVk7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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LGNBQWMsbUJBQU8sQ0FBQyxtREFBUztBQUMvQixlQUFlLG1CQUFPLENBQUMscURBQVU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDO0FBQzFDLEtBQUs7QUFDTCxHQUFHO0FBQ0gsV0FBVyxLQUFLOztBQUVoQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGtGQUFrRjtBQUNsRiw4Q0FBOEM7QUFDOUMsMEJBQTBCO0FBQzFCLFFBQVEsRUFBRTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0I7QUFDdEIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyx3REFBVztBQUM3QjtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBTUU7Ozs7Ozs7Ozs7Ozs7QUN2RkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFnQztBQUNHOztBQUVuQztBQUNBLGtCQUFrQixtREFBTztBQUN6QixlQUFlLG1EQUFJO0FBQ25COztBQUtDOzs7Ozs7Ozs7Ozs7O0FDWEQ7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFLRSIsImZpbGUiOiJkZXZTeXN0ZW0uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9qcy9vYmplY3RzL1N5c3RlbS5qc1wiKTtcbiIsIi8qKlxuICogRXhlY3V0aW9uU3RhY2tcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhbiBvYmplY3QgdGhhdCBtYW5hZ2VzIGEgc3RhY2sgb2ZcbiAqIEFjdGl2YXRpb25Db250ZXh0IG9iamVjdHMuXG4gKiBJIGFtIGRlc2lnbmVkIHRvIGJlIHVzZWQgYnkgU3lzdGVtIGFzIHRoZVxuICogZ2xvYmFsIGV4ZWN1dGlvbiBzdGFjay5cbiAqXG4gKi9cblxuY2xhc3MgRXhlY3V0aW9uU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX3N0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2dsb2JhbHMgPSB7fTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMucG9wID0gdGhpcy5wb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wdXNoID0gdGhpcy5wdXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0R2xvYmFsID0gdGhpcy5zZXRHbG9iYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRHbG9iYWwgPSB0aGlzLmdldEdsb2JhbC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHBvcCgpe1xuICAgICAgICBpZighdGhpcy5fc3RhY2subGVuZ3RoKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFjay5wb3AoKTtcbiAgICB9XG5cbiAgICBwdXNoKGFuQWN0aXZhdGlvbil7XG4gICAgICAgIHRoaXMuX3N0YWNrLnB1c2goYW5BY3RpdmF0aW9uKTtcbiAgICB9XG5cbiAgICBzZXRHbG9iYWwodmFyTmFtZSwgdmFsdWUpe1xuICAgICAgICB0aGlzLl9nbG9iYWxzW3Zhck5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0R2xvYmFsKHZhck5hbWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2xvYmFsc1t2YXJOYW1lXTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudCgpe1xuICAgICAgICBpZighdGhpcy5fc3RhY2subGVuZ3RoKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBnZXQgcHJldmlvdXMoKXtcbiAgICAgICAgaWYoIXRoaXMuX3N0YWNrLmxlbmd0aCA+PSAyKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAyXTtcbiAgICB9XG59O1xuXG5jbGFzcyBBY3RpdmF0aW9uQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZU5hbWUsIHBhcnQsIGluY29taW5nTWVzc2FnZSwgaGFuZGxlckZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICAgICAgdGhpcy5tZXNzYWdlTmFtZSA9IG1lc3NhZ2VOYW1lO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBpbmNvbWluZ01lc3NhZ2U7XG4gICAgICAgIHRoaXMuaGFuZGxlckZ1bmN0aW9uID0gaGFuZGxlckZ1bmN0aW9uO1xuICAgICAgICB0aGlzLl9sb2NhbHMgPSB7fTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuZ2V0ID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRMb2NhbCA9IHRoaXMuZ2V0TG9jYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRMb2NhbCA9IHRoaXMuc2V0TG9jYWwuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQodmFyTmFtZSl7XG4gICAgICAgIGxldCBsb2NhbFZhbHVlID0gdGhpcy5nZXRMb2NhbCh2YXJOYW1lKTtcbiAgICAgICAgaWYobG9jYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBvdGhlcndpc2UgdHJ5IHRvIHJldHVybiBhIGdsb2JhbFxuICAgICAgICAvLyB2YXJpYWJsZVxuICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5nZXRHbG9iYWwodmFyTmFtZSk7XG4gICAgfVxuXG4gICAgZ2V0TG9jYWwodmFyTmFtZSl7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbHNbdmFyTmFtZV07XG4gICAgfVxuXG4gICAgc2V0TG9jYWwodmFyTmFtZSwgdmFsdWUpe1xuICAgICAgICB0aGlzLl9sb2NhbHNbdmFyTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7XG4gICAgRXhlY3V0aW9uU3RhY2ssXG4gICAgQWN0aXZhdGlvbkNvbnRleHRcbn07XG4iLCIvKipcbiAqIFN5c3RlbSBPYmplY3RcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgXCJ0b3BcIiBvZiB0aGVcbiAqIHN5dGVtLiBJIGFtIHRoZSBwb2ludCBvZiBjb21tdW5pY2F0aW9uIGJldHdlZW5cbiAqIE1vZGVscyBhbmQgVmlld3MuXG4gKi9cbmltcG9ydCBDYXJkIGZyb20gJy4vcGFydHMvQ2FyZC5qcyc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi9wYXJ0cy9TdGFjay5qcyc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vcGFydHMvQnV0dG9uLmpzJztcbmltcG9ydCBGaWVsZCBmcm9tICcuL3BhcnRzL0ZpZWxkLmpzJztcbmltcG9ydCBXb3JsZFN0YWNrIGZyb20gJy4vcGFydHMvV29ybGRTdGFjay5qcyc7XG5pbXBvcnQgV2luZG93IGZyb20gJy4vcGFydHMvV2luZG93LmpzJztcbmltcG9ydCBEcmF3aW5nIGZyb20gJy4vcGFydHMvRHJhd2luZy5qcyc7XG5pbXBvcnQgQXVkaW8gZnJvbSAnLi9wYXJ0cy9BdWRpby5qcyc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuL3BhcnRzL0Jyb3dzZXIuanMnO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vcGFydHMvUmVzb3VyY2UuanMnO1xuaW1wb3J0IEltYWdlIGZyb20gJy4vcGFydHMvSW1hZ2UuanMnO1xuaW1wb3J0IEFyZWEgZnJvbSAnLi9wYXJ0cy9BcmVhLmpzJztcblxuaW1wb3J0IFdvcmxkVmlldyBmcm9tICcuL3ZpZXdzL1dvcmxkVmlldy5qcyc7XG5pbXBvcnQgU3RhY2tWaWV3IGZyb20gJy4vdmlld3MvU3RhY2tWaWV3LmpzJztcbmltcG9ydCBCdXR0b25WaWV3IGZyb20gJy4vdmlld3MvQnV0dG9uVmlldy5qcyc7XG5cbmltcG9ydCBDYXJkVmlldyBmcm9tICcuL3ZpZXdzL0NhcmRWaWV3LmpzJztcbmltcG9ydCBXaW5kb3dWaWV3IGZyb20gJy4vdmlld3MvV2luZG93Vmlldyc7XG5pbXBvcnQgRmllbGRWaWV3IGZyb20gJy4vdmlld3MvRmllbGRWaWV3LmpzJztcbmltcG9ydCBEcmF3aW5nVmlldyBmcm9tICcuL3ZpZXdzL2RyYXdpbmcvRHJhd2luZ1ZpZXcuanMnO1xuaW1wb3J0IEltYWdlVmlldyBmcm9tICcuL3ZpZXdzL0ltYWdlVmlldy5qcyc7XG5pbXBvcnQgQXJlYVZpZXcgZnJvbSAnLi92aWV3cy9BcmVhVmlldy5qcyc7XG5pbXBvcnQgQXVkaW9WaWV3IGZyb20gJy4vdmlld3MvQXVkaW9WaWV3LmpzJztcbmltcG9ydCBCcm93c2VyVmlldyBmcm9tICcuL3ZpZXdzL0Jyb3dzZXJWaWV3LmpzJztcbmltcG9ydCBSZXNvdXJjZVZpZXcgZnJvbSAnLi92aWV3cy9SZXNvdXJjZVZpZXcuanMnO1xuXG5cbmltcG9ydCBIYWxvIGZyb20gJy4vdmlld3MvSGFsby5qcyc7XG5pbXBvcnQgU1ROYXZpZ2F0b3IgZnJvbSAnLi92aWV3cy9uYXZpZ2F0b3IvTmF2aWdhdG9yLmpzJztcbmltcG9ydCBFZGl0b3IgZnJvbSAnLi92aWV3cy9lZGl0b3JzL0VkaXRvci5qcyc7XG5cbmltcG9ydCBvaG0gZnJvbSAnb2htLWpzJztcbmltcG9ydCBpbnRlcnByZXRlclNlbWFudGljcyBmcm9tICcuLi9vaG0vaW50ZXJwcmV0ZXItc2VtYW50aWNzLmpzJztcbmltcG9ydCB7RXhlY3V0aW9uU3RhY2ssIEFjdGl2YXRpb25Db250ZXh0fSBmcm9tICcuL0V4ZWN1dGlvblN0YWNrLmpzJztcblxuaW1wb3J0IGlkTWFrZXIgZnJvbSAnLi91dGlscy9pZC5qcyc7XG5pbXBvcnQgU1RDbGlwYm9hcmQgZnJvbSAnLi91dGlscy9jbGlwYm9hcmQuanMnO1xuXG5pbXBvcnQge0Jhc2ljUHJvcGVydHl9IGZyb20gJy4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmltcG9ydCBoYW5kSW50ZXJmYWNlIGZyb20gJy4vdXRpbHMvaGFuZEludGVyZmFjZS5qcyc7XG5pbXBvcnQgbWVycmlhbVNpbVNjb3JlIGZyb20gJy4vdXRpbHMvbWVycmlhbUludGVyZmFjZS5qcyc7XG5cbmltcG9ydCB7U1REZXNlcmlhbGl6ZXIsIFNUU2VyaWFsaXplcn0gZnJvbSAnLi91dGlscy9zZXJpYWxpemF0aW9uLmpzJztcblxuaW1wb3J0IHBsdWdpbnMgZnJvbSAnLi4vLi4vcGx1Z2lucy9wbHVnaW5zLmpzJztcblxuY29uc3QgRE9NcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXG5pbXBvcnQgY3JlYXRlSGlnaGxpZ2h0ZXIgZnJvbSAnLi91dGlscy9BbHRTeW50YXhIaWdobGlnaHRlci5qcyc7XG5cblxuY29uc3QgU3lzdGVtID0ge1xuICAgIG5hbWU6IFwiU3lzdGVtXCIsXG4gICAgaWQ6IC0xLFxuICAgIGlzTG9hZGVkOiBmYWxzZSxcbiAgICBwYXJ0c0J5SWQ6IHt9LFxuICAgIF9jb21tYW5kSGFuZGxlcnM6IHt9LFxuICAgIF9mdW5jdGlvbkhhbmRsZXJzOiB7fSxcbiAgICBfZGVzZXJpYWxpemVyOiBudWxsLFxuXG4gICAgLy8gQSBkaWN0aW9uYXJ5IG1hcHBpbmcgYXZhaWxhYmxlIFNUIHJlc291cmNlIChzdWNoIGFzIHBsdWdpbikgbmFtZXNcbiAgICBhdmFpbGFibGVSZXNvdXJjZXM6IHt9LFxuXG4gICAgLy8gQSBkaWN0aW9uYXJ5IG1hcHBpbmcgcGFydCB0eXBlcyBsaWtlXG4gICAgLy8gJ2J1dHRvbicgdG8gdGhlaXIgY2xhc3NlcyAoQnV0dG9uKVxuICAgIGF2YWlsYWJsZVBhcnRzOiB7fSxcblxuICAgIC8vIEEgZGljdGlvbmFyeSBtYXBwaW5nIHBhcnQgdHlwZXMgbGlrZVxuICAgIC8vICdidXR0b24nIHRvIHRoZWlyIHZpZXcgY2xhc3NlcyAoQnV0dG9uVmlldylcbiAgICBhdmFpbGFibGVWaWV3czoge30sXG5cbiAgICAvLyBBIHJlZ2lzdHJ5IHRoYXQga2VlcHMgYWxsIHN5c3RlbSBtZXNzYWdlcyBmcm9tXG4gICAgLy8gYmVnaW5uaWduIG9mIHRpbWU7IFRPRE8gaW4gdGhlIGZ1dHVyZSB3ZSBtaWdodCB3YW50XG4gICAgLy8gdG8gbm90ZSBrZWVwIGFsbCB0aGlzIGluIG1lbW9yeVxuICAgIC8vIGVhY2ggbG9nIGNvbnNpc3RzIG9mOlxuICAgIC8vIFthTWVzc2FnZSwgKHNvdXJjZU5hbWUsIHNvdXJjZUlkKSwgKHRhcmdldE5hbWUsIHRhcmdldElkKV1cbiAgICBtZXNzYWdlTG9nOiBbXSxcblxuICAgIC8vIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBwYWdlIGxvYWRzLlxuICAgIC8vIENoZWNrcyBmb3IgYW55IHZpZXcgZWxlbWVudHMgaW4gdGhlXG4gICAgLy8gcGFnZSBhbmQgYXR0ZW1wdHMgdG8gZmluZCBzZXJpYWxpemVkXG4gICAgLy8gbW9kZWwgc3RhdGUgZm9yIGVhY2ggb2YgdGhlbS4gSWYgcHJlc2VudCxcbiAgICAvLyBkZXNlcmlhbGl6ZXMgdGhlIG1vZGVsIGFuZCBhdHRhY2hlcyBpdFxuICAgIC8vIHRvIHRoZSB2aWV3LlxuICAgIGluaXRpYWxMb2FkOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBsb2FkIHRoZSBhdmFpbGFibGUgcmVzb3VyY2VzXG4gICAgICAgIC8vIHRoZXNlIG1pZ2h0IGJlIG5lZWRlZCBkb3duIHRoZSBsaW5lXG4gICAgICAgIHRoaXMubG9hZFJlc291cmNlcygpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBzZXJpYWxpemF0aW9uIHNjcmlwdCB0YWdcbiAgICAgICAgLy8gY29udGFpbmluZyBKU09OIG9mIHNlcmlhbGl6ZWQgaW5mb3JtYXRpb24sXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gbG9hZCBmcm9tIGl0XG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VyaWFsaXphdGlvbicpO1xuICAgICAgICBpZihzZXJpYWxpemF0aW9uRWwgJiYgc2VyaWFsaXphdGlvbkVsLnRleHQgIT0gXCJcIil7XG5cbiAgICAgICAgICAgIHRoaXMuZGVzZXJpYWxpemUoKVxuICAgICAgICAgICAgLy8gdGhpcy5kZXNlcmlhbGl6ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRJbml0aWFsT3Blbk1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5uYXZpZ2F0b3Iuc2V0TW9kZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2UgcmVuZGVyIHRoZSBXb3JsZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJlaGVuc2l2ZSBFZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyKHRoaXMud29ybGQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRGcm9tRW1wdHkoKTtcbiBcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHJlbmRlciB0aGUgV29ybGQgaW4gdGhlXG4gICAgICAgICAgICAvLyBDb21wcmVoZW5zaXZlIEVkaXRvclxuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyKHRoaXMud29ybGQpO1xuICAgICAgICAgICAgdGhpcy5oaWRlTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0YWNoIGEgbmV3IGNsaXBib2FyZCBpbnN0YW5jZVxuICAgICAgICB0aGlzLmNsaXBib2FyZCA9IG5ldyBTVENsaXBib2FyZCh0aGlzKTtcblxuICAgICAgICAvLyBCeSB0aGlzIHBvaW50IHdlIHNob3VsZCBoYXZlIGEgV29ybGRWaWV3IHdpdGhcbiAgICAgICAgLy8gYSBtb2RlbCBhdHRhY2hlZC5cbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIGxvYWRSZXNvdXJjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW5zKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF2YWlsYWJsZVJlc291cmNlc1trXSA9IHBsdWdpbnNba107XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBsb2FkRnJvbUVtcHR5OiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgd29ybGRNb2RlbCA9IG5ldyB0aGlzLmF2YWlsYWJsZVBhcnRzWyd3b3JsZCddKCk7XG4gICAgICAgIHRoaXMucGFydHNCeUlkW3dvcmxkTW9kZWwuaWRdID0gd29ybGRNb2RlbDtcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICB0aGlzLnRhZ05hbWVGb3JWaWV3TmFtZWQoJ3dvcmxkJylcbiAgICAgICAgKTtcbiAgICAgICAgd29ybGRWaWV3LnNldE1vZGVsKHdvcmxkTW9kZWwpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdvcmxkVmlldyk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgc3RhY2sgbW9kZWxcbiAgICAgICAgbGV0IGluaXRTdGFjayA9IHRoaXMubmV3TW9kZWwoJ3N0YWNrJywgd29ybGRNb2RlbC5pZCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgY2FyZCBtb2RlbCBmb3IgdGhhdCBzdGFja1xuICAgICAgICBsZXQgaW5pdENhcmQgPSB0aGlzLm5ld01vZGVsKCdjYXJkJywgaW5pdFN0YWNrLmlkKTtcblxuICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBzdGFjayBhbmQgY2FyZCBpZHMgXG4gICAgICAgIHdvcmxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHdvcmxkTW9kZWwsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBpbml0U3RhY2suaWRcbiAgICAgICAgKTtcbiAgICAgICAgaW5pdFN0YWNrLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBpbml0U3RhY2ssXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBpbml0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICAvLyBVcGRhdGUgc2VyaWFsaXphdGlvblxuICAgICAgICB0aGlzLnNlcmlhbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMuc2VuZEluaXRpYWxPcGVuTWVzc2FnZXMoKTtcbiAgICAgICAgU3lzdGVtLm5hdmlnYXRvci5zZXRNb2RlbChcbiAgICAgICAgICAgIFN5c3RlbS5wYXJ0c0J5SWRbJ3dvcmxkJ11cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2VuZEluaXRpYWxPcGVuTWVzc2FnZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFNlbmQgdGhlIG9wZW5Xb3JsZCBtZXNzYWdlIHRvIHRoZSBXb3JsZFN0YWNrXG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICB3b3JsZC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5Xb3JsZCcsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB3b3JsZCk7XG4gICAgICAgIHdvcmxkLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIHdvcmxkLmN1cnJlbnRTdGFjayk7XG4gICAgICAgIHdvcmxkLmN1cnJlbnRTdGFjay5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5DYXJkJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIHdvcmxkLmN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZCk7XG4gICAgfSxcblxuICAgIHNlbmRNZXNzYWdlOiBmdW5jdGlvbihhTWVzc2FnZSwgc291cmNlLCB0YXJnZXQpe1xuICAgICAgICBpZighdGFyZ2V0IHx8IHRhcmdldCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlcyBtdXN0IGJlIHNlbnQgd2l0aCB0YXJnZXQgcmVjZWl2ZXJzIHNwZWNpZmllZCEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgYWxsIHNvdXJjZXMgd2hpY2ggcGFzcyB0aGlzIG1lc3NhZ2VcbiAgICAgICAgaWYgKCEoXCJzZW5kZXJzXCIgaW4gYU1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBhTWVzc2FnZVtcInNlbmRlcnNcIl0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhTWVzc2FnZS5zZW5kZXJzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc291cmNlLm5hbWUsXG4gICAgICAgICAgICBpZDogc291cmNlLmlkLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0LnJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKTtcbiAgICB9LFxuXG4gICAgcmVjZWl2ZU1lc3NhZ2U6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAnbmV3Vmlldyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3VmlldyhcbiAgICAgICAgICAgICAgICAgICAgYU1lc3NhZ2Uudmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGFNZXNzYWdlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSAnY29tcGlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZShhTWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlQ29tbWFuZChhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvZXNOb3RVbmRlcnN0YW5kKGFNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkb2VzTm90VW5kZXJzdGFuZDogZnVuY3Rpb24oYU1lc3NhZ2Upe1xuICAgICAgICAvLyBJZiB0aGUgbWVzc2FnZSBoYXMgdGhlIHNob3VsZElnbm9yZSBwcm9wZXJ0eVxuICAgICAgICAvLyBzZXQgdG8gdHJ1ZSwgaXQgbWVhbnMgd2Ugc2hvdWxkIGp1c3Qgc3dhbGxvd1xuICAgICAgICAvLyB0aGlzIG1lc3NhZ2UgaWYgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpdC4gVGhpcyBpc1xuICAgICAgICAvLyB1c2VmdWwgZm9yIG1lc3NhZ2VzIGxpa2UgbW91c2UgZXZlbnRzIG9uIGJ1dHRvbnNcbiAgICAgICAgLy8gd2hpY2ggYXJlIG5vdCBjYXB0dXJlZCBieSBkZWZhdWx0IGFuZCB3b3VsZCBvdGhlcndpc2VcbiAgICAgICAgLy8gZW5kIHVwIGFycml2aW5nIHRvIHRoaXMgU3lzdGVtIG9iamVjdCB2aWEgdGhlXG4gICAgICAgIC8vIG1lc3NhZ2UgZGVsZWdhdGlvbiBjaGFpbi5cbiAgICAgICAgaWYoYU1lc3NhZ2Uuc2hvdWxkSWdub3JlKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JpZ2luYWxTZW5kZXIgPSB0aGlzLnBhcnRzQnlJZFthTWVzc2FnZS5zZW5kZXJzWzBdLmlkXTtcbiAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG5hbWU6IFwiTWVzc2FnZU5vdFVuZGVyc3Rvb2RcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGFNZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIG9yaWdpbmFsU2VuZGVyLnNlbmRNZXNzYWdlKG1zZywgb3JpZ2luYWxTZW5kZXIpO1xuICAgIH0sXG5cbiAgICBjb21waWxlOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIGxldCB0YXJnZXRPYmplY3QgPSB0aGlzLnBhcnRzQnlJZFthTWVzc2FnZS50YXJnZXRJZF07XG4gICAgICAgIGlmKCF0YXJnZXRPYmplY3QgfHwgdGFyZ2V0T2JqZWN0ID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5c3RlbSBjb3VsZCBub3QgY29tcGlsZSB0YXJnZXQgb2JqZWN0ICR7YU1lc3NhZ2UudGFyZ2V0SWR9YCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGluY29taW5nIFNpbXBsZVRhbGsgc2NyaXB0IHN0cmluZy5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGdyYW1tYXRpY2FsIGVycm9ycywgcmVwb3J0IHRoZW0gYW5kIGJhaWwuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IHNlbWFudGljcyBvbiB0aGUgdGFyZ2V0UGFydCwgYWRkXG4gICAgICAgIC8vIHRoZSByZXF1aXJlZCBzZW1hbnRpYyBvcGVyYXRpb25zLCBhbmQgaW50ZXJwcmV0IHRoZSB0b3BcbiAgICAgICAgLy8gbGV2ZWwgb2YgdGhlIHNjcmlwdCwgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIEpTIGhhbmRsZXIgZnVuY3Rpb25zXG4gICAgICAgIGxldCBwYXJzZWRTY3JpcHQgPSBsYW5ndWFnZUdyYW1tYXIubWF0Y2goYU1lc3NhZ2UuY29kZVN0cmluZyk7XG4gICAgICAgIGlmKHBhcnNlZFNjcmlwdC5mYWlsZWQoKSl7XG4gICAgICAgICAgICAvLyBjb25zaWRlciB1c2luZyB0aGUgcGFyc2UgZGF0YSBmcm9tIHRyYWNlXG4gICAgICAgICAgICAvLyBleGFtcGxlOiBsZXQgdHJhY2VkU2NyaXB0ID0gbGFuZ3VhZ2VHcmFtbWFyLnRyYWNlKGFNZXNzYWdlLmNvZGVTdHJpbmcpO1xuICAgICAgICAgICAgLy8gbGV0IHRyZWUgPSB0cmFjZWRTY3JpcHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiR3JhbW1hck1hdGNoRXJyb3JcIixcbiAgICAgICAgICAgICAgICBwYXJzZWRTY3JpcHQ6IHBhcnNlZFNjcmlwdCxcbiAgICAgICAgICAgICAgICBwYXJ0SWQ6IGFNZXNzYWdlLnRhcmdldElkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0LnNlbmRNZXNzYWdlKG1zZywgdGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBjbGVhciBvdXQgYW55IGN1cnJlbnRseSBjb21waWxlZCBoYW5kbGVyc1xuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGluY29taW5nIHNjcmlwdCBtaWdodCBnZXQgcmlkIG9mIHRoZW1cbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5fY29tbWFuZEhhbmRsZXJzID0ge307XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNlbWFudGljcyBvYmplY3Qgd2hvc2UgcGFydENvbnRleHRcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYmUgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAgICB0YXJnZXRPYmplY3QuX3NlbWFudGljcyA9IGxhbmd1YWdlR3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5fc2VtYW50aWNzLmFkZE9wZXJhdGlvbihcbiAgICAgICAgICAgICAgICAnaW50ZXJwcmV0JyxcbiAgICAgICAgICAgICAgICBpbnRlcnByZXRlclNlbWFudGljcyh0YXJnZXRPYmplY3QsIHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0Ll9zZW1hbnRpY3MocGFyc2VkU2NyaXB0KS5pbnRlcnByZXQoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gQmUgc3VyZSB0byB0aGVuIHVwZGF0ZSB0aGVcbiAgICAgICAgLy8gc2VyaWFsaXphdGlvbiBmb3IgdGhlIHRhcmdldFxuICAgICAgICAvLyBwYXJ0LCB0aHVzIGFkZGluZyB0aGUgc2NyaXB0IHRvXG4gICAgICAgIC8vIGl0cyBzZXJpYWxpemF0aW9uXG4gICAgICAgIGlmKGFNZXNzYWdlLnNlcmlhbGl6ZSl7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlY2VpdmVDb21tYW5kOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fY29tbWFuZEhhbmRsZXJzW2FNZXNzYWdlLmNvbW1hbmROYW1lXTtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgICBsZXQgYm91bmRIYW5kbGVyID0gaGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgbGV0IGFjdGl2YXRpb24gPSBuZXcgQWN0aXZhdGlvbkNvbnRleHQoXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UuY29tbWFuZE5hbWUsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBib3VuZEhhbmRsZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGlvblN0YWNrLnB1c2goYWN0aXZhdGlvbik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYm91bmRIYW5kbGVyKGFNZXNzYWdlLnNlbmRlcnMsIC4uLmFNZXNzYWdlLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2VzTm90VW5kZXJzdGFuZChhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV3TW9kZWw6IGZ1bmN0aW9uKGtpbmQsIG93bmVySWQsIG5hbWUsIGJ1aWxkVmlldz10cnVlKXtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBpbnN0YW5jZSBvZiB0aGUgbW9kZWwgdGhhdFxuICAgICAgICAvLyBtYXRjaGVzIHRoZSBvd25lcidzIGlkXG4gICAgICAgIGxldCBvd25lclBhcnQgPSB0aGlzLnBhcnRzQnlJZFtvd25lcklkXTtcbiAgICAgICAgaWYoIW93bmVyUGFydCB8fCBvd25lclBhcnQgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3lzdGVtIGNvdWxkIG5vdCBsb2NhdGUgb3duZXIgcGFydCB3aXRoIGlkICR7b3duZXJJZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGNsYXNzIGNvbnN0cnVjdG9yIGZvciB0aGUga2luZCBvZlxuICAgICAgICAvLyBwYXJ0IHJlcXVlc3RlZCBhcyBhIG5ldyBtb2RlbC4gSWYgbm90IGtub3duLFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICBsZXQgbW9kZWxDbGFzcyA9IHRoaXMuYXZhaWxhYmxlUGFydHNba2luZF07XG4gICAgICAgIGlmKCFtb2RlbENsYXNzKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSB1bmtub3duIHBhcnQgdHlwZTogJHtraW5kfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb2RlbCA9IG5ldyBtb2RlbENsYXNzKG93bmVyUGFydCk7XG4gICAgICAgIGlmKG5hbWUpe1xuICAgICAgICAgICAgbW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChtb2RlbCwgJ25hbWUnLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRzQnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcblxuICAgICAgICAvLyBBbnkgY3JlYXRlZCBwYXJ0IG1pZ2h0IGluaXRpYWxpemUgaXRzXG4gICAgICAgIC8vIG93biBzdWJwYXJ0cy4gV2UgbmVlZCB0byBsZXQgdGhlIFN5c3RlbSBrbm93XG4gICAgICAgIC8vIGFib3V0IHRob3NlIHRvb1xuICAgICAgICBtb2RlbC5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0c0J5SWRbc3VicGFydC5pZF0gPSBzdWJwYXJ0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHZhbGlkIG93bmVyIHBhcnQgZm9yXG4gICAgICAgIC8vIHRoZSBuZXdseSBjcmVhdGVkIHBhcnQgbW9kZWwsXG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IG1vZGVsIHRvIHRoZSBvd25lcidzXG4gICAgICAgIC8vIHN1YnBhcnRzIGxpc3RcbiAgICAgICAgaWYob3duZXJQYXJ0KXtcbiAgICAgICAgICAgIG93bmVyUGFydC5hZGRQYXJ0KG1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgU3lzdGVtIGFzIGEgcHJvcGVydHkgc3Vic2NyaWJlciB0b1xuICAgICAgICAvLyB0aGUgbmV3IG1vZGVsLiBUaGlzIHdpbGwgc2VuZCBhIG1lc3NhZ2UgdG9cbiAgICAgICAgLy8gdGhpcyBTeXN0ZW0gb2JqZWN0IHdoZW5ldmVyIGFueSBvZiB0aGlzIG1vZGVsJ3NcbiAgICAgICAgLy8gcHJvcGVydGllcyBoYXZlIGNoYW5nZWRcbiAgICAgICAgbW9kZWwuYWRkUHJvcGVydHlTdWJzY3JpYmVyKHRoaXMpO1xuXG4gICAgICAgIGlmKGJ1aWxkVmlldyl7XG4gICAgICAgICAgICAvLyBTZWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHZpZXcgZm9yIHRoZSBtb2RlbC5cbiAgICAgICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIGFuZCBhdHRhY2ggaXQuXG4gICAgICAgICAgICBsZXQgdmlld0Zvck1vZGVsID0gdGhpcy5maW5kVmlld0J5SWQobW9kZWwuaWQpO1xuICAgICAgICAgICAgaWYoIXZpZXdGb3JNb2RlbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWaWV3KG1vZGVsLnR5cGUsIG1vZGVsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBvd25lciBwYXJ0IGlzIGVpdGhlciBhIHdvcmxkIG9yIGEgc3RhY2tcbiAgICAgICAgLy8gYW5kIGhhcyBvbmx5IG9uZSBzdGFjayBvciBjYXJkIGNoaWxkLCByZXNwZWN0aXZlbHksIHNldFxuICAgICAgICAvLyB0aGF0IGNoaWxkIHRvIGJlIHRoZSBjdXJyZW50XG4gICAgICAgIGlmKG93bmVyUGFydC50eXBlID09IFwid29ybGRcIiB8fCBvd25lclBhcnQudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJZCA9IG93bmVyUGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKG93bmVyUGFydCwgXCJjdXJyZW50XCIpO1xuICAgICAgICAgICAgaWYoIWN1cnJlbnRJZCl7XG4gICAgICAgICAgICAgICAgb3duZXJQYXJ0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQob3duZXJQYXJ0LCBcImN1cnJlbnRcIiwgbW9kZWwuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWxseSBzZW5kIHRoZSBtb2RlbCBhIG1lc3NhZ2UgdG8gYW5ub3VuY2UgdGhhdCBpdCBpcyBuZXdcbiAgICAgICAgLy8gdG8gdGhlIHdvcmxkLCBidXQgZG9uJ3QgXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICduZXdNb2RlbCcsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZE5vdERlbGVnYXRlOiB0cnVlLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIHRoaXMsIG1vZGVsKTtcblxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIG5ld1Byb3BlcnR5KHNlbmRlcnMsIHByb3BOYW1lLCBvYmplY3RJZCl7XG4gICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgIGxldCBvcmlnaW5hbFNlbmRlciA9IHNlbmRlcnNbMF0uaWQ7XG5cbiAgICAgICAgaWYob2JqZWN0SWQpe1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhbiBvYmplY3RJZCwgd2UgYXJlXG4gICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvZiBhIHNwZWNpZmljIHBhcnQgYnlcbiAgICAgICAgICAgIC8vIGlkXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvYmplY3RJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHNldHRpbmcgdGhlIHByb3BlcnR5IG9uIHRoZSBwYXJ0XG4gICAgICAgICAgICAvLyB0aGF0IG9yaWdpbmFsbHkgc2VudCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb3JpZ2luYWxTZW5kZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG5ld1Byb3BlcnR5IHRhcmdldCFgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZSkpe1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnQgJHt0YXJnZXQuaWR9IGFscmVhZHkgaGFzIHByb3BlcnR5IFwiJHtwcm9wTmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG9ubHkgYWRkIGJhc2ljIHByb3BlcnR5IGFuZCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsXG4gICAgICAgIGxldCBjdXN0b21Qcm9wID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKFwiY3VzdG9tLXByb3BlcnRpZXNcIik7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IEJhc2ljUHJvcGVydHkocHJvcE5hbWUsIG51bGwpO1xuICAgICAgICBjdXN0b21Qcm9wLmFkZChuZXdQcm9wKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlUHJvcGVydHkoc2VuZGVycywgcHJvcE5hbWUsIG9iamVjdElkKXtcbiAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gc2VuZGVyc1swXS5pZDtcblxuICAgICAgICBpZihvYmplY3RJZCl7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIGFuIG9iamVjdElkLCB3ZSBhcmVcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHByb3BlcnR5IG9mIGEgc3BlY2lmaWMgcGFydCBieVxuICAgICAgICAgICAgLy8gaWRcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29iamVjdElkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBhcmUgc2V0dGluZyB0aGUgcHJvcGVydHkgb24gdGhlIHBhcnRcbiAgICAgICAgICAgIC8vIHRoYXQgb3JpZ2luYWxseSBzZW50IHRoZSBtZXNzYWdlXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvcmlnaW5hbFNlbmRlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgZGVsZXRlUHJvcGVydHkgdGFyZ2V0IWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsIG9ubHkgZGVsZXRlIGN1c3RvbSBwcm9wZXJ0aWVzIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxuICAgICAgICBsZXQgcHJvcCA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZSk7XG5cbiAgICAgICAgbGV0IGN1c3RvbVByb3AgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoXCJjdXN0b20tcHJvcGVydGllc1wiKTtcbiAgICAgICAgY3VzdG9tUHJvcC5kZWxldGUocHJvcCk7XG4gICAgfSxcblxuICAgIHNldFByb3BlcnR5KHNlbmRlcnMsIHByb3BOYW1lLCB2YWx1ZSwgb2JqZWN0SWQpe1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBsZXQgb3JpZ2luYWxTZW5kZXIgPSBzZW5kZXJzWzBdLmlkO1xuXG4gICAgICAgIGlmKG9iamVjdElkKXtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgYW4gb2JqZWN0SWQsIHdlIGFyZVxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgcHJvcGVydHkgb2YgYSBzcGVjaWZpYyBwYXJ0IGJ5XG4gICAgICAgICAgICAvLyBpZFxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb2JqZWN0SWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvbiB0aGUgcGFydFxuICAgICAgICAgICAgLy8gdGhhdCBvcmlnaW5hbGx5IHNlbnQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29yaWdpbmFsU2VuZGVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBzZXRQcm9wZXJ0eSB0YXJnZXQhYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBJRCBmcm9tXG4gICAgLy8gdGhlIFN5c3RlbSdzIHJlZ2lzdHJ5LCBhcyB3ZWxsIGFzIGZyb20gdGhlIHN1YnBhcnRzXG4gICAgLy8gYXJyYXkgb2YgYW55IG93bmVyc1xuICAgIGRlbGV0ZU1vZGVsOiBmdW5jdGlvbihtb2RlbElkKXtcbiAgICAgICAgbGV0IGZvdW5kTW9kZWwgPSB0aGlzLnBhcnRzQnlJZFttb2RlbElkXTtcbiAgICAgICAgaWYoIWZvdW5kTW9kZWwpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gcmVtb3ZpbmcgYSBjYXJkIG9yIGEgc3RhY2sgYmUgc3VyZSBpdCBpcyBub3QgdGhlIG9ubHkgb25lXG4gICAgICAgIC8vIGFuZCBpZiBpdCBpcyB0aGUgY3VycmVudCBjYXJkIG9yIHN0YWNrIHdlIHNob3VsZCBnbyB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgLy8gYmVmb3JlIHJlbW92aW5nIGl0XG4gICAgICAgIGlmKGZvdW5kTW9kZWwudHlwZSA9PSBcImNhcmRcIiB8fCBmb3VuZE1vZGVsLnR5cGUgPT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBzYW1lVHlwZVN1YnBhcnRzID0gZm91bmRNb2RlbC5fb3duZXIuc3VicGFydHMuZmlsdGVyKChwKSA9PiB7cmV0dXJuIHAudHlwZSA9PSBmb3VuZE1vZGVsLnR5cGU7fSk7XG4gICAgICAgICAgICBpZihzYW1lVHlwZVN1YnBhcnRzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGJlIGEgU1QgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgdGhlIG9ubHkgJHtmb3VuZE1vZGVsLnR5cGV9YCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYobW9kZWxJZCA9PSB0aGlzLmdldEN1cnJlbnRTdGFja01vZGVsKCkuaWQgIHx8IG1vZGVsSWQgPT0gdGhpcy5nZXRDdXJyZW50Q2FyZE1vZGVsKCkuaWQpe1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgYSBTVCBlcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSB0aGUgY3VycmVudCAke2ZvdW5kTW9kZWwudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0byBzdG9wIGFsbCBzdGVwcGluZ1xuICAgICAgICAvLyBvbiB0aGUgUGFydCwgb3RoZXJ3aXNlIHN0ZXBwaW5nXG4gICAgICAgIC8vIGludGVydmFscyB3aWxsIGVycm9yIGluZmluaXRlbHlcbiAgICAgICAgZm91bmRNb2RlbC5zdG9wU3RlcHBpbmcoKTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGVkaXRvciBpcyBjbG9zZWRcbiAgICAgICAgZm91bmRNb2RlbC5jbG9zZUVkaXRvckNtZEhhbmRsZXIoKTtcblxuICAgICAgICBsZXQgb3duZXJNb2RlbCA9IGZvdW5kTW9kZWwuX293bmVyO1xuICAgICAgICBpZihvd25lck1vZGVsKXtcbiAgICAgICAgICAgIG93bmVyTW9kZWwucmVtb3ZlUGFydChmb3VuZE1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcnRzQnlJZFttb2RlbElkXTtcbiAgICAgICAgdGhpcy5yZW1vdmVWaWV3cyhtb2RlbElkKTtcblxuICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgICAgIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYWxsIHZpZXdzIHdpdGggdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAvLyBtb2RlbCBpZCBmcm9tIHRoZSBET01cbiAgICByZW1vdmVWaWV3czogZnVuY3Rpb24obW9kZWxJZCl7XG4gICAgICAgIGxldCB2aWV3cyA9IEFycmF5LmZyb20odGhpcy5maW5kVmlld3NCeUlkKG1vZGVsSWQpKTtcbiAgICAgICAgdmlld3MuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFbCA9IHZpZXcucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZpZXcucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh2aWV3KTtcbiAgICAgICAgICAgIC8vIERpc3BhdGNoIGEgQ3VzdG9tRXZlbnQgb24gdGhlIHBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgIC8vIGluZGljYXRpbmcgdGhhdCB0aGlzIHBhcnQgaGFzIGJlZW4gcmVtb3ZlZCwgYW5kXG4gICAgICAgICAgICAvLyBhbnkgdmlldyB1dGlsaXRpZXMgdGhhdCBjYXJlIGNhbiBiZSBub3RpZmllZC5cbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc3Qtdmlldy1yZW1vdmVkJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0VHlwZTogdmlldy5tb2RlbC50eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IG1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIG93bmVySWQ6IG51bGxcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRFbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsZW5zZXMgPSB0aGlzLmZpbmRMZW5zVmlld3NCeUlkKG1vZGVsSWQpO1xuICAgICAgICBsZW5zZXMuZm9yRWFjaChsZW5zVmlldyA9PiB7XG4gICAgICAgICAgICBsZW5zVmlldy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGxlbnNWaWV3KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG5ld1ZpZXc6IGZ1bmN0aW9uKHBhcnROYW1lLCBtb2RlbElkLCBwYXJlbnRJZCl7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMucGFydHNCeUlkW21vZGVsSWRdO1xuICAgICAgICBpZighbW9kZWwgfHwgbW9kZWwgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3lzdGVtIGRvZXMgbm90IGtub3cgcGFydCAke3BhcnROYW1lfVske21vZGVsSWR9XWApO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFwYXJ0TmFtZSl7XG4gICAgICAgICAgICBwYXJ0TmFtZSA9IG1vZGVsLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgaWQuIFRoaXMgd2lsbFxuICAgICAgICAvLyBoZWxwIHVzIGZpbmQgdGhlIHBhcmVudCB2aWV3IGVsZW1lbnQgZm9yXG4gICAgICAgIC8vIGFwcGVuZGluZyB0aGUgbmV3IGVsZW1lbnQuXG4gICAgICAgIGlmICghcGFyZW50SWQpe1xuICAgICAgICAgICAgcGFyZW50SWQgPSBtb2RlbC5fb3duZXIuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSB0aGlzLmZpbmRWaWV3QnlJZChwYXJlbnRJZCk7XG4gICAgICAgIGlmKCFwYXJlbnRFbGVtZW50KXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcGFyZW50IGVsZW1lbnQgZm9yICR7cGFydE5hbWV9WyR7bW9kZWxJZH1dIChtb2RlbCBvd25lciBpZDogJHttb2RlbC5fb3duZXIuaWR9KWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgdmlldyBpbnN0YW5jZSxcbiAgICAgICAgLy8gYXBwZW5kIHRvIHBhcmVudCwgYW5kIHNldCB0aGUgbW9kZWxcbiAgICAgICAgbGV0IG5ld1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgdGhpcy50YWdOYW1lRm9yVmlld05hbWVkKHBhcnROYW1lKVxuICAgICAgICApO1xuICAgICAgICBuZXdWaWV3LnNldE1vZGVsKG1vZGVsKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcInZpZXdDaGFuZ2VkXCIsXG4gICAgICAgICAgICBjaGFuZ2VOYW1lOiBcInN1YnBhcnQtbmV3XCIsXG4gICAgICAgICAgICBhcmdzOiBbbmV3Vmlld11cbiAgICAgICAgfSwgbW9kZWwuX293bmVyLCBwYXJlbnRFbGVtZW50KTtcblxuICAgICAgICAvLyBEaXNwYXRjaCBhIEN1c3RvbUV2ZW50IG9uIHRoZSBwYXJlbnRFbGVtZW50XG4gICAgICAgIC8vIGluZGljYXRpbmcgdGhhdCB0aGlzIHBhcnQgaGFzIGJlZW4gY3JlYXRlZCwgYW5kXG4gICAgICAgIC8vIGFueSB2aWV3IHV0aWxpdGllcyB0aGF0IGNhcmUgY2FuIGJlIG5vdGlmaWVkLlxuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3N0LXZpZXctYWRkZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBwYXJ0VHlwZTogbW9kZWwudHlwZSxcbiAgICAgICAgICAgICAgICBwYXJ0SWQ6IG1vZGVsLmlkLFxuICAgICAgICAgICAgICAgIG93bmVySWQ6IG1vZGVsLl9vd25lci5pZCB8fCBudWxsXG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgICAgICAvLyBTZWUgaWYgdGhlcmUgYXJlIGxlbnMgdmlld3MgYW5kIHVwZGF0ZVxuICAgICAgICAvLyB0aG9zZSBhcyB3ZWxsXG4gICAgICAgIGxldCBsZW5zVmlld3MgPSB0aGlzLmZpbmRMZW5zVmlld3NCeUlkKHBhcmVudElkKTtcbiAgICAgICAgbGVuc1ZpZXdzLmZvckVhY2gobGVuc1ZpZXcgPT4ge1xuICAgICAgICAgICAgbGV0IG5ld0xlbnNWaWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWVGb3JWaWV3TmFtZWQocGFydE5hbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIG1vZGVsSWQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgIGxlbnNWaWV3LmFwcGVuZENoaWxkKG5ld0xlbnNWaWV3KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETyBkbyB3ZSB3YW50IHRvIGFsbG93IHRoZSBwb3NzaWJpbGl5IG9mIGEgdmlldyBvbiBhblxuICAgICAgICAvLyBlbGVtZW50IGJ1dCBubyBzdWJwYXJ0IG9mIHRoYXQgdmlldyBvbiB0aGUgZWxlbWVudD9cblxuICAgICAgICAvLyBGb3IgYWxsIHN1YnBhcnRzIG9mIHRoaXMgbW9kZWwsIGNhbGxcbiAgICAgICAgLy8gdGhlIG5ld1ZpZXcgbWV0aG9kIHJlY3Vyc2l2ZWx5XG4gICAgICAgIG1vZGVsLnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLm5ld1ZpZXcoc3VicGFydC50eXBlLCBzdWJwYXJ0LmlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1ZpZXc7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyUGFydDogZnVuY3Rpb24obmFtZSwgY2xzKXtcbiAgICAgICAgdGhpcy5hdmFpbGFibGVQYXJ0c1tuYW1lXSA9IGNscztcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJWaWV3OiBmdW5jdGlvbihuYW1lLCBjbHMpe1xuICAgICAgICB0aGlzLmF2YWlsYWJsZVZpZXdzW25hbWVdID0gY2xzO1xuICAgIH0sXG5cbiAgICB0YWdOYW1lRm9yVmlld05hbWVkOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgcmV0dXJuIGBzdC0ke25hbWV9YDtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgdmlldyBlbGVtZW50XG4gICAgLy8gd2l0aCB0aGUgZ2l2ZW4gaWRcbiAgICBmaW5kVmlld0J5SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHtpZH1cIl1gKTtcbiAgICB9LFxuXG4gICAgZmluZExlbnNWaWV3c0J5SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2xlbnMtcGFydC1pZD1cIiR7aWR9XCJdYCkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCBtYXRjaGluZyB2aWV3IGVsZW1lbnRzIHdpdGhcbiAgICAvLyB0aGUgZ2l2ZW4gcGFydCBpZFxuICAgIGZpbmRWaWV3c0J5SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtwYXJ0LWlkPVwiJHtpZH1cIl1gKTtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRoZSBtb2RlbCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgZ2V0Q3VycmVudFN0YWNrTW9kZWw6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMuZ2V0V29ybGRTdGFja01vZGVsKCk7XG4gICAgICAgIHJldHVybiB3b3JsZC5jdXJyZW50U3RhY2s7XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgbW9kZWwgY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBjYXJkXG4gICAgZ2V0Q3VycmVudENhcmRNb2RlbDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZDtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRoZSBtb2RlbCBjb3JyZXNwb25kaW5nIHRvIHRoZSB3b3JsZCBzdGFja1xuICAgIGdldFdvcmxkU3RhY2tNb2RlbDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdGhlIG1vZGVsIGNvcnJlc3BvbmRpbmcgc2NyaXB0IGVkaXRvciBzdC1maWVsZFxuICAgIC8vIE5vdGU6IHdlIHVzZSB0aGUgd2luZG93Lm1vZGVsLnRhcmdldCB0byBsb2NhdGUgdGhlIGNvcnJlc3BvbmRpbmcgd2luZG93XG4gICAgLy8gYnV0IHJldHVybiBpdHMgc3QtZmllbGQgc3VicGFydFxuICAgIGZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkOiBmdW5jdGlvbihpZCl7XG4gICAgICAgIGxldCBzY3JpcHRFZGl0b3JGaWVsZDtcbiAgICAgICAgbGV0IHdpbmRvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3Qtd2luZG93XCIpO1xuICAgICAgICB3aW5kb3dzLmZvckVhY2goKHcpID0+IHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB3Lm1vZGVsLnRhcmdldDtcbiAgICAgICAgICAgIGlmKHRhcmdldCAmJiB0YXJnZXQuaWQgPT09IGlkKXtcbiAgICAgICAgICAgICAgICBzY3JpcHRFZGl0b3JGaWVsZCA9IHcucXVlcnlTZWxlY3RvcihcInN0LWZpZWxkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdEVkaXRvckZpZWxkO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICBpZighd29ybGQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB3b3JsZCBmb3VuZCFgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VyaWFsaXplciA9IG5ldyBTVFNlcmlhbGl6ZXIodGhpcyk7XG4gICAgICAgIGxldCBzZXJpYWxTdHJpbmcgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLnBhcnRzQnlJZFsnd29ybGQnXSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgc2NyaXB0IHRhZyBpbiB0aGVcbiAgICAgICAgLy8gYm9keSBmb3IgdGhlIHNlcmlhbGl6YXRpb24sIGNyZWF0ZSBpdFxuICAgICAgICBsZXQgc2VyaWFsaXphdGlvblNjcmlwdEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgaWYoIXNlcmlhbGl6YXRpb25TY3JpcHRFbCl7XG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uU2NyaXB0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25TY3JpcHRFbC5pZCA9ICdzZXJpYWxpemF0aW9uJztcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25TY3JpcHRFbC50eXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoc2VyaWFsaXphdGlvblNjcmlwdEVsKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemF0aW9uU2NyaXB0RWwudGV4dENvbnRlbnQgPSBzZXJpYWxTdHJpbmc7XG4gICAgfSxcblxuICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgc2VyaWFsaXphdGlvbkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgaWYoIXNlcmlhbGl6YXRpb25FbCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlcmlhbGl6YXRpb24gZm91bmQgZm9yIHRoaXMgcGFnZWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rlc2VyaWFsaXplciA9IG5ldyBTVERlc2VyaWFsaXplcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uRWwudGV4dENvbnRlbnQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYSAqY29tcGxldGUqIEhUTUxcbiAgICAvLyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBhcHBsaWNhdGlvblxuICAgIC8vIHRoYXQgY2FuIGxhdGVyIGJlIHNhdmVkIHRvIGEgZmlsZVxuICAgIGdldEZ1bGxIVE1MU3RyaW5nOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgY2xvbmVkRG9jdW1lbnQgPSBkb2N1bWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGxldCB3b3JsZCA9IGNsb25lZERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIGxldCBuYXYgPSBjbG9uZWREb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1uYXZpZ2F0b3InKTtcbiAgICAgICAgaWYod29ybGQpe1xuICAgICAgICAgICAgd29ybGQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYobmF2KXtcbiAgICAgICAgICAgIG5hdi5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZWREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgIH0sXG5cblxuICAgIC8qKiBOYXZpZ2F0aW9uIG9mIEN1cnJlbnQgV29ybGQgKiovXG4gICAgZ29Ub05leHRTdGFjazogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgICAgIHJldHVybiB3b3JsZC5nb1RvTmV4dFN0YWNrKCk7XG4gICAgfSxcblxuICAgIGdvVG9QcmV2U3RhY2s6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICByZXR1cm4gd29ybGQuZ29Ub1ByZXZTdGFjaygpO1xuICAgIH0sXG5cbiAgICBnb1RvU3RhY2tCeUlkOiBmdW5jdGlvbihzdGFja0lkKXtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgICAgIHJldHVybiB3b3JsZC5nb1RvU3RhY2tCeUlkKHN0YWNrSWQpO1xuICAgIH0sXG5cbiAgICAvKiogTmF2aWdhdGlvbiBvZiBDdXJyZW50IFN0YWNrICoqL1xuICAgIGdvVG9OZXh0Q2FyZDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTsgXG4gICAgICAgIHJldHVybiBjdXJyZW50U3RhY2suZ29Ub05leHRDYXJkKCk7XG4gICAgfSxcblxuICAgIGdvVG9QcmV2Q2FyZDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGFjay5nb1RvUHJldkNhcmQoKTtcbiAgICB9LFxuXG4gICAgZ29Ub0NhcmRCeUlkOiBmdW5jdGlvbihjYXJkSWQpe1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5nZXRDdXJyZW50U3RhY2tNb2RlbCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFN0YWNrLmdvVG9DYXJkQnlJZChjYXJkSWQpO1xuICAgIH0sXG5cbiAgICBvcGVuRWRpdG9yRm9yUGFydDogZnVuY3Rpb24ocGFydElkKXtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyKFxuICAgICAgICAgICAgdGhpcy5wYXJ0c0J5SWRbcGFydElkXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVkaXRvci5vcGVuKCk7XG4gICAgfSxcblxuICAgIGNsb3NlRWRpdG9yRm9yUGFydDogZnVuY3Rpb24ocGFydElkKXtcbiAgICAgICAgdGhpcy5lZGl0b3IuY2xvc2UoKTtcbiAgICB9LFxuXG4gICAgc2hvd0xvYWRpbmdTY3JlZW46IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gYDxpbWcgc3JjPVwiL2ltYWdlcy9zaW1wbGV0YWxrLWNhbGxpZ3JhcGh5MS5zdmdcIi8+XG48aDE+TG9hZGluZy4uLjwvaDE+YDtcbiAgICAgICAgICAgICAgIGNvbnRhaW5lci5pZCA9IFwibG9hZGluZy1zY3JlZW5cIjtcbiAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcbiAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnc3BhY2UtYXJvdW5kJztcbiAgICAgICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlblswXS5zdHlsZS53aWR0aCA9IFwiNDV2d1wiO1xuICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gXCIxMDB2d1wiO1xuICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IFwiMTAwdmhcIjtcbiAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGhpZGVMb2FkaW5nU2NyZWVuOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgbG9hZGluZ0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nLXNjcmVlbicpO1xuICAgICAgICBpZihsb2FkaW5nRGl2KXtcbiAgICAgICAgICAgIGxvYWRpbmdEaXYucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiogQWRkIERlZmF1bHQgU3lzdGVtIENvbW1hbmQgSGFuZGxlcnMgKiovXG4vL1N5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydkZWxldGVNb2RlbCddID0gU3lzdGVtLmRlbGV0ZU1vZGVsO1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2RlbGV0ZU1vZGVsJ10gPSBmdW5jdGlvbihzZW5kZXJzLCAuLi5yZXN0KXtcbiAgICBTeXN0ZW0uZGVsZXRlTW9kZWwoLi4ucmVzdCk7XG59O1xuLy9TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3TW9kZWwnXSA9IFN5c3RlbS5uZXdNb2RlbDtcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyduZXdNb2RlbCddID0gZnVuY3Rpb24oc2VuZGVycywgLi4ucmVzdCl7XG4gICAgU3lzdGVtLm5ld01vZGVsKC4uLnJlc3QpO1xuICAgIHRoaXMuc2VyaWFsaXplKCk7XG59O1xuLy9TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3VmlldyddID0gU3lzdGVtLm5ld1ZpZXc7XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3VmlldyddID0gZnVuY3Rpb24oc2VuZGVycywgLi4ucmVzdCl7XG4gICAgU3lzdGVtLm5ld1ZpZXcoLi4ucmVzdCk7XG59O1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ25ld1Byb3BlcnR5J10gPSBTeXN0ZW0ubmV3UHJvcGVydHk7XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snc2V0UHJvcGVydHknXSA9IFN5c3RlbS5zZXRQcm9wZXJ0eTtcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydkZWxldGVQcm9wZXJ0eSddID0gU3lzdGVtLmRlbGV0ZVByb3BlcnR5O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snYXNrJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBxdWVzdGlvbil7XG4gICAgLy8gVXNlIHRoZSBuYXRpdmUgSlMgcHJvbXB0IGZ1bmN0aW9uIHRvIGFzayB0aGUgcXVlc3Rpb25cbiAgICAvLyBhbmQgcmV0dXJuIGl0cyB2YWx1ZS5cbiAgICAvLyBCeSByZXR1cm5pbmcgaGVyZSwgd2UgZXhwZWN0IHRoZSBpbXBsaWNpdCB2YXJpYWJsZVxuICAgIC8vIFwiaXRcIiB0byBiZSBzZXQgaW5zaWRlIGFueSBjYWxsaW5nIHNjcmlwdFxuICAgIHJldHVybiBwcm9tcHQocXVlc3Rpb24pO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ3B1dEludG8nXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHZhbHVlLCB2YXJpYWJsZU5hbWUsIGdsb2JhbCl7XG4gICAgaWYoZ2xvYmFsKXtcbiAgICAgICAgU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnNldEdsb2JhbCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIHdlIHB1c2ggYWxsIGhhbmRsZXJzIG9udG8gdGhlIGV4ZWN1dGlvbiBzdGFjayxcbiAgICAvLyB0aGUgcHV0SW50byBoYW5kbGVyIGlzIGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjay5cbiAgICAvLyBJbiBvcmRlciB0byBtb2RpZnkgdGhlIGNhbGxlcidzIHZhcmlhYmxlcywgd2UgbmVlZCB0b1xuICAgIC8vIGZpbmQgdGhlIGNvbnRleHQgdGhhdCBpcyBvbmUgcHJldmlvdXMgb24gdGhlIHN0YWNrXG4gICAgaWYoU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnByZXZpb3VzKXtcbiAgICAgICAgU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnByZXZpb3VzLnNldExvY2FsKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhlY3V0aW9uU3RhY2sgRXJyb3I6ICNwdXRJbnRvIG9uIHRvcCBvZiBlbXB0eSBzdGFjayFgKTtcbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snYW5zd2VyJ10gPSBmdW5jdGlvbihzZW5kZXJzLCB2YWx1ZSl7XG4gICAgYWxlcnQodmFsdWUudG9TdHJpbmcoKSk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZ28gdG8gZGlyZWN0aW9uJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBkaXJlY3RpdmUsIG9iamVjdE5hbWUpe1xuICAgIHN3aXRjaChvYmplY3ROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2NhcmQnOlxuICAgICAgICAgICAgc3dpdGNoKGRpcmVjdGl2ZSl7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub05leHRDYXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9QcmV2Q2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YWNrJzpcbiAgICAgICAgICAgIHN3aXRjaChkaXJlY3RpdmUpe1xuICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9OZXh0U3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub1ByZXZTdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhbGVydChgXCJnbyB0b1wiIG5vdCBpbXBsZW1lbnRlZCBmb3IgJHtvYmplY3ROYW1lfWApO1xuXG4gICAgfVxufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2dvIHRvJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBpZCl7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5wYXJ0c0J5SWRbaWRdO1xuICAgIGlmKCFtb2RlbCl7XG4gICAgICAgIGFsZXJ0KGBcImdvIHRvXCIgdGFyZ2V0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBzd2l0Y2gobW9kZWwudHlwZSkge1xuICAgIGNhc2UgJ2NhcmQnOlxuICAgICAgICB0aGlzLmdvVG9DYXJkQnlJZChpZCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3RhY2snOlxuICAgICAgICB0aGlzLmdvVG9TdGFja0J5SWQoaWQpO1xuICAgICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAgIGFsZXJ0KGBcImdvIHRvXCIgbm90IGltcGxlbWVudGVkIGZvciAke21vZGVsLnR5cGV9YCk7XG5cbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZ28gdG8gd2Vic2l0ZSddID0gZnVuY3Rpb24oc2VuZGVycywgdXJsKXtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn07XG5cbi8vSW1wb3J0IGEgd29ybGQsIGkuZS4gaXRzIHN0YWNrcyBmcm9tIGFub3RoZXIgc291cmNlXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snaW1wb3J0V29ybGQnXSA9IGZ1bmN0aW9uKHNlbmRlciwgc291cmNlVXJsKXtcbiAgICBpZighc291cmNlVXJsKXtcbiAgICAgICAgc291cmNlVXJsID0gd2luZG93LnByb21wdChcIkNob29zZSBXb3JsZCBsb2NhdGlvblwiKTtcbiAgICB9XG4gICAgZmV0Y2goc291cmNlVXJsKVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICBpZighY29udGVudFR5cGUuc3RhcnRzV2l0aCgndGV4dC9odG1sJykpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZW50IHR5cGU6ICR7Y29udGVudFR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpLnRoZW4oYmxvYiA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZERvY3VtZW50ID0gRE9NcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhyZWFkZXIucmVzdWx0LCBcInRleHQvaHRtbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gLmdldEVsZW1lbnRCeUlkKCkgZm9yIGEgbm9kZSBIVE1MIHBhcnNlZCBkb2N1bWVudCFcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb25FbCA9IHBhcnNlZERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZXJpYWxpemF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFzZXJpYWxpemF0aW9uRWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE5vIHNlcmlhbGl6YXRpb24gZm91bmQgZm9yICR7c291cmNlVXJsfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoYFdvcmxkIFwiJHtzb3VyY2VVcmx9XCIgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemVyID0gbmV3IFNURGVzZXJpYWxpemVyKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZXIudGFyZ2V0SWQgPSAnd29ybGQnOyAvLyBXZSB3aWxsIGluc2VydCB0aGUgc3RhY2tzIGludG8gdGhlIHdvcmxkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZXIuaW1wb3J0RnJvbVNlcmlhbGl6YXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uRWwudGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBvbmx5IFN0YWNrcyB0aGF0IGFyZSBkaXJlY3Qgc3VicGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgd29ybGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzU3RhY2sgPSBwYXJ0LnR5cGUgPT0gJ3N0YWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNXb3JsZFN1YnBhcnQgPSBwYXJ0Ll9vd25lciAmJiBwYXJ0Ll9vd25lci50eXBlID09ICd3b3JsZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RhY2sgJiYgaXNXb3JsZFN1YnBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzZXQgdGhlIF9zcmMuXG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBpbmZpbml0ZWx5XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBsb2FkIG9wZXJhdGlvblxuICAgICAgICAgICAgdGhpcy5fc3JjID0gc291cmNlVXJsO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vIFN0b3AgYW5kIHJlc3RhcnQgaGFuZCBpbnRlcmZhY2UgaWYgaXQncyBydW5uaW5nLlxuICAgICAgICAgICAgaWYgKGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGFsZXJ0KFwiQ291bGQgbm90IGxvYWQgd29ybGRcIik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH0pO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ29wZW5TY3JpcHRFZGl0b3InXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHRhcmdldElkKXtcbiAgICBsZXQgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgIGxldCB0YXJnZXROYW1lID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcIm5hbWVcIik7XG4gICAgaWYodGFyZ2V0TmFtZSl7XG4gICAgICAgIHRhcmdldE5hbWUgPSBgXCIke3RhcmdldE5hbWV9XCJgO1xuICAgIH1cbiAgICBsZXQgbmFtZSA9IGBTY3JpcHQgRm9yICR7dGFyZ2V0Lm5hbWV9ICR7dGFyZ2V0TmFtZX1gO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGRpbndvIG9wZW5lZCB3aXRoIHRoaXMgbmFtZSwgdGhlblxuICAgIC8vIHdlIHJldHVybiB3aXRob3V0IGNyZWF0aW5nIGFueXRoaW5nIG5ldy5cbiAgICBsZXQgZm91bmQgPSBPYmplY3QudmFsdWVzKFN5c3RlbS5wYXJ0c0J5SWQpLmZpbHRlcihwYXJ0ID0+IHtcbiAgICAgICAgbGV0IHBhcnROYW1lO1xuICAgICAgICBpZihwYXJ0LnR5cGUgPT0gJ3dpbmRvdycpe1xuICAgICAgICAgICAgcGFydE5hbWUgPSBwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAndGl0bGUnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocGFydC50eXBlID09ICd3aW5kb3cnICYmIG5hbWUgPT0gcGFydE5hbWUpO1xuICAgIH0pO1xuICAgIGlmKGZvdW5kLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudENhcmQgPSB0aGlzLmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICBsZXQgd2luZG93ID0gdGhpcy5uZXdNb2RlbCgnd2luZG93JywgY3VycmVudENhcmQuaWQpO1xuICAgIGxldCBhcmVhID0gdGhpcy5uZXdNb2RlbCgnYXJlYScsIHdpbmRvdy5pZCk7XG4gICAgbGV0IHNjcmlwdEZpZWxkID0gdGhpcy5uZXdNb2RlbCgnZmllbGQnLCBhcmVhLmlkKTtcbiAgICBsZXQgc2F2ZUJ1dHRvbiA9IHRoaXMubmV3TW9kZWwoJ2J1dHRvbicsIGFyZWEuaWQpO1xuXG5cbiAgICAvLyBzZXR1cCB0aGUgd2luZG93IGFuZCBzdGFjayBwcm9wZXJ0aWVzXG4gICAgd2luZG93LnNldFRhcmdldCh0YXJnZXQpO1xuICAgIHdpbmRvdy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHdpbmRvdywgXCJ0aXRsZVwiLCBuYW1lKTtcbiAgICB3aW5kb3cucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh3aW5kb3csIFwiaGVpZ2h0XCIsIDIwMCk7XG4gICAgd2luZG93LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQod2luZG93LCBcIndpZHRoXCIsIDUwMCk7XG4gICAgd2luZG93LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQod2luZG93LCAndG9wJywgMTAwKTtcbiAgICB3aW5kb3cucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh3aW5kb3csICdsZWZ0JywgMTAwKTtcblxuICAgIGFyZWEucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChhcmVhLCBcImxheW91dFwiLCBcImxpc3RcIik7XG4gICAgYXJlYS5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGFyZWEsIFwibGlzdC1kaXJlY3Rpb25cIiwgXCJjb2x1bW5cIik7XG4gICAgYXJlYS5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGFyZWEsIFwid2lkdGhcIiwgXCJmaWxsXCIpO1xuICAgIGFyZWEucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChhcmVhLCBcImhlaWdodFwiLCBcImZpbGxcIik7XG5cbiAgICAvLyBzY3JpcHQgZmllbGRcbiAgICBsZXQgdGFyZ2V0U2NyaXB0ID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcInNjcmlwdFwiKTsgXG4gICAgc2NyaXB0RmllbGQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzY3JpcHRGaWVsZCwgXCJ0ZXh0XCIsIHRhcmdldFNjcmlwdCk7XG4gICAgc2NyaXB0RmllbGQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzY3JpcHRGaWVsZCwgXCJoZWlnaHRcIiwgXCJmaWxsXCIpO1xuICAgIHNjcmlwdEZpZWxkLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2NyaXB0RmllbGQsIFwid2lkdGhcIiwgXCJmaWxsXCIpO1xuXG4gICAgLy8gU2V0dXAgc3ludGF4IGhpZ2hsaWdodFxuICAgIHNjcmlwdEZpZWxkLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgIGNvbW1hbmROYW1lOiBcImhpZ2hsaWdodFN5bnRheFwiLFxuICAgICAgICBhcmdzOiBbXVxuICAgIH0sIHNjcmlwdEZpZWxkKTtcblxuXG4gICAgLy8gc2V0dXAgdXAgdGhlIHNhdmUgYnV0dG9uIHByb3BlcnRpZXNcbiAgICBzYXZlQnV0dG9uLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2F2ZUJ1dHRvbiwgXCJuYW1lXCIsIFwiU2F2ZSBTY3JpcHRcIik7XG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwid2lkdGhcIiwgXCJmaWxsXCIpO1xuICAgIHNhdmVCdXR0b24ucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzYXZlQnV0dG9uLCBcInRleHQtc2l6ZVwiLCAyMCk7XG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwidGFyZ2V0XCIsIGBwYXJ0IGlkICR7dGFyZ2V0LmlkfWApO1xuXG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwidGFyZ2V0XCIsIGBwYXJ0IGlkICR7dGFyZ2V0LmlkfWApO1xuICAgIGxldCBzYXZlU2NyaXB0ID0gYG9uIGNsaWNrXFxuXFx0dGVsbCB0YXJnZXQgdG8gc2V0IFwic2NyaXB0XCIgdG8gdGhlIFwidGV4dFwiIG9mIGZpcnN0IGZpZWxkXFxuZW5kIGNsaWNrYDsgXG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwic2NyaXB0XCIsIHNhdmVTY3JpcHQpO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ1NpbXBsZVRhbGsnXSA9IGZ1bmN0aW9uKHNlbmRlcnMpe1xuICAgIHJldHVybiBTeXN0ZW0uZ3JhbW1hci5zb3VyY2Uuc291cmNlU3RyaW5nO1xufVxuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snb3BlbkRlYnVnZ2VyJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBwYXJ0SWQsIHR5cGUsIG5hbWUpe1xuICAgIGxldCB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtwYXJ0SWRdO1xuICAgIC8vIENyZWF0ZSB0aGUgRmllbGQgbW9kZWwgYW5kIGF0dGFjaCB0byBjdXJyZW50IGNhcmRcbiAgICBsZXQgY3VycmVudENhcmQgPSB0aGlzLmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICBsZXQgd2luZG93TW9kZWwgPSB0aGlzLm5ld01vZGVsKCd3aW5kb3cnLCBjdXJyZW50Q2FyZC5pZCk7XG4gICAgbGV0IGFyZWFNb2RlbCA9IHRoaXMubmV3TW9kZWwoJ2FyZWEnLCB3aW5kb3dNb2RlbC5pZCk7XG4gICAgLy8gbmFtZSB0aGUgd2luZG93IGFuZCBzZXR1cCBiYXNpYyBsYXlvdXRcbiAgICB3aW5kb3dNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICB3aW5kb3dNb2RlbCxcbiAgICAgICAgJ25hbWUnLFxuICAgICAgICBcImRlYnVnZ2VyXCJcbiAgICApO1xuICAgIHdpbmRvd01vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIHdpbmRvd01vZGVsLFxuICAgICAgICAndGl0bGUnLFxuICAgICAgICBgTWVzc2FnZSBOb3QgVW5kZXJzdG9vZCA6ICR7bmFtZX1gXG4gICAgKTtcbiAgICB3aW5kb3dNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICB3aW5kb3dNb2RlbCxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgNDAwXG4gICAgKTtcbiAgICB3aW5kb3dNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICB3aW5kb3dNb2RlbCxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIDIwMFxuICAgICk7XG4gICAgYXJlYU1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIGFyZWFNb2RlbCxcbiAgICAgICAgJ2xheW91dCcsXG4gICAgICAgIFwibGlzdFwiXG4gICAgKTtcbiAgICBhcmVhTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgYXJlYU1vZGVsLFxuICAgICAgICAnbGlzdC1kaXJlY3Rpb24nLFxuICAgICAgICBcImNvbHVtblwiXG4gICAgKTtcbiAgICBhcmVhTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgYXJlYU1vZGVsLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICBcImZpbGxcIlxuICAgICk7XG4gICAgYXJlYU1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIGFyZWFNb2RlbCxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIFwiZmlsbFwiXG4gICAgKTtcbiAgICBhcmVhTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgYXJlYU1vZGVsLFxuICAgICAgICAnYWxsb3ctc2Nyb2xsaW5nJyxcbiAgICAgICAgdHJ1ZVxuICAgICk7XG4gICAgLy8gZmlsbCBpbiBhbGwgdGhlIGF2YWlsYWJsZSBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIHBhcnRcbiAgICBPYmplY3Qua2V5cyh0YXJnZXQuY29tbWFuZEhhbmRsZXJSZWdpc3RyeSkuZm9yRWFjaCgoa2V5KSA9PntcbiAgICAgICAgbGV0IHRleHQgPSBrZXk7XG4gICAgICAgIGxldCBpc1ByaXZhdGUgPSB0YXJnZXQuY29tbWFuZEhhbmRsZXJSZWdpc3RyeVtrZXldLnByaXZhdGU7XG4gICAgICAgIGlmKGlzUHJpdmF0ZSl7XG4gICAgICAgICAgICB0ZXh0ICs9IFwiIChwcml2YXRlKVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZE1vZGVsID0gdGhpcy5uZXdNb2RlbCgnZmllbGQnLCBhcmVhTW9kZWwuaWQpO1xuICAgICAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBmaWVsZE1vZGVsLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgdGV4dFxuICAgICAgICApO1xuICAgICAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBmaWVsZE1vZGVsLFxuICAgICAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIGZpZWxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIGZpZWxkTW9kZWwsXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgXCJmaWxsXCJcbiAgICAgICAgKTtcbiAgICAgICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgZmllbGRNb2RlbCxcbiAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgMjBcbiAgICAgICAgKTtcbiAgICB9KTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydvcGVuR3JhbW1hciddID0gZnVuY3Rpb24oc2VuZGVycywgcGFydElkLCBydWxlTmFtZSl7XG4gICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vIGdyYW1tYXIgd2luZG93cyBvcGVuIGFscmVhZHlcbiAgICBsZXQgd2luZG93cyA9IE9iamVjdC52YWx1ZXMod2luZG93LlN5c3RlbS5wYXJ0c0J5SWQpLmZpbHRlcigocGFydCkgPT4ge3JldHVybiBwYXJ0Lm5hbWUgPT0gXCJXaW5kb3dcIjt9KTtcbiAgICBsZXQgZ3JhbW1hcldpbmRvd3MgPSB3aW5kb3dzLmZpbHRlcigod2luZG93KSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh3aW5kb3csIFwibmFtZVwiKSA9PSBcIlNpbXBsZXRhbGsgR3JhbW1hclwiO1xuICAgIH0pO1xuICAgIGlmKGdyYW1tYXJXaW5kb3dzLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRhcmdldCA9IHRoaXMucGFydHNCeUlkW3BhcnRJZF07XG4gICAgLy8gQ3JlYXRlIHRoZSBGaWVsZCBtb2RlbCBhbmQgYXR0YWNoIHRvIGN1cnJlbnQgY2FyZFxuICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuZ2V0Q3VycmVudENhcmRNb2RlbCgpO1xuICAgIGxldCB3aW5kb3dNb2RlbCA9IHRoaXMubmV3TW9kZWwoJ3dpbmRvdycsIGN1cnJlbnRDYXJkLmlkKTtcbiAgICBsZXQgYXJlYU1vZGVsID0gdGhpcy5uZXdNb2RlbCgnYXJlYScsIHdpbmRvd01vZGVsLmlkKTtcbiAgICAvLyBuYW1lIHRoZSB3aW5kb3cgYW5kIHNldHVwIGJhc2ljIGxheW91dFxuICAgIHdpbmRvd01vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIHdpbmRvd01vZGVsLFxuICAgICAgICAnbmFtZScsXG4gICAgICAgIFwiU2ltcGxldGFsayBHcmFtbWFyXCJcbiAgICApO1xuICAgIHdpbmRvd01vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIHdpbmRvd01vZGVsLFxuICAgICAgICAndGl0bGUnLFxuICAgICAgICBcIlNpbXBsZXRhbGsgR3JhbW1hclwiXG4gICAgKTtcbiAgICB3aW5kb3dNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICB3aW5kb3dNb2RlbCxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgNDAwXG4gICAgKTtcbiAgICB3aW5kb3dNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICB3aW5kb3dNb2RlbCxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIDIwMFxuICAgICk7XG4gICAgYXJlYU1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIGFyZWFNb2RlbCxcbiAgICAgICAgJ2xheW91dCcsXG4gICAgICAgIFwibGlzdFwiXG4gICAgKTtcbiAgICBhcmVhTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgYXJlYU1vZGVsLFxuICAgICAgICAnbGlzdC1kaXJlY3Rpb24nLFxuICAgICAgICBcImNvbHVtblwiXG4gICAgKTtcbiAgICBhcmVhTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgYXJlYU1vZGVsLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICBcImZpbGxcIlxuICAgICk7XG4gICAgYXJlYU1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIGFyZWFNb2RlbCxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIFwiZmlsbFwiXG4gICAgKTtcbiAgICAvLyBhZGQgdGhlIGdyYW1tYXIgdGV4dFxuICAgIGxldCB0ZXh0ID0gU3lzdGVtLmdyYW1tYXIuc291cmNlLnNvdXJjZVN0cmluZztcbiAgICBsZXQgZmllbGRNb2RlbCA9IHRoaXMubmV3TW9kZWwoJ2ZpZWxkJywgYXJlYU1vZGVsLmlkKTtcbiAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIGZpZWxkTW9kZWwsXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgdGV4dFxuICAgICk7XG4gICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICBmaWVsZE1vZGVsLFxuICAgICAgICAnZWRpdGFibGUnLFxuICAgICAgICBmYWxzZVxuICAgICk7XG4gICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICBmaWVsZE1vZGVsLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICBcImZpbGxcIlxuICAgICk7XG4gICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICBmaWVsZE1vZGVsLFxuICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgXCJmaWxsXCJcbiAgICApO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ3NhdmVIVE1MJ10gPSBmdW5jdGlvbihzZW5kZXJzKXtcbiAgICAvLyBTdG9wIGhhbmQgcmVjb2duaXRpb24gaWYgaXQncyBydW5uaW5nLlxuICAgIGxldCBoYW5kUmVjb2duaXRpb25PcmlnaW5hbGx5UnVubmluZyA9IGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmc7XG4gICAgaWYgKGhhbmRSZWNvZ25pdGlvbk9yaWdpbmFsbHlSdW5uaW5nKSB7XG4gICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RvcCgpO1xuICAgIH1cbiAgICB0aGlzLnNlcmlhbGl6ZSgpO1xuXG4gICAgbGV0IHN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xuICAgIGxldCBzZXJpYWxpemVkUGFnZSA9IHRoaXMuZ2V0RnVsbEhUTUxTdHJpbmcoKTtcbiAgICBsZXQgdHlwZUluZm8gPSBcImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04XCI7XG4gICAgbGV0IHVybCA9IGAke3R5cGVJbmZvfSwke2VuY29kZVVSSUNvbXBvbmVudChzZXJpYWxpemVkUGFnZSl9YDtcblxuICAgIGxldCBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYW5jaG9yLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChhbmNob3IpO1xuICAgIGFuY2hvci5ocmVmID0gdXJsO1xuICAgIGFuY2hvci5kb3dubG9hZCA9IGBTaW1wbGVUYWxrU25hcHNob3RfJHtzdGFtcH0uaHRtbGA7XG4gICAgYW5jaG9yLmNsaWNrKCk7XG4gICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICBhbmNob3IucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChhbmNob3IpO1xuICAgIC8vIFN0YXJ0IGhhbmQgcmVjb2duaXRpb24gaWYgaXQgd2FzIHJ1bm5pbmcuXG4gICAgaWYgKGhhbmRSZWNvZ25pdGlvbk9yaWdpbmFsbHlSdW5uaW5nKSB7XG4gICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RhcnQoKTtcbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1sndGVsbCddID0gKHNlbmRlcnMsIHRhcmdldElkLCBkZWZlcnJlZE1lc3NhZ2UpID0+IHtcbiAgICBsZXQgdGFyZ2V0UGFydCA9IFN5c3RlbS5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgIGlmKCF0YXJnZXRQYXJ0KXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gdGVsbCBwYXJ0IGlkICR7dGFyZ2V0SWR9OiBubyBzdWNoIHBhcnQhYCk7XG4gICAgfVxuICAgIHRhcmdldFBhcnQuc2VuZE1lc3NhZ2UoZGVmZXJyZWRNZXNzYWdlLCB0YXJnZXRQYXJ0KTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyd0b2dnbGVIYW5kRGV0ZWN0aW9uJ10gPSAoKSA9PiB7XG4gICAgaWYgKGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbk1vZGVsID09PSBudWxsKSB7XG4gICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RhcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kSW50ZXJmYWNlLnN0b3AoKTtcbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbWVycmlhbSddID0gKHNlbmRlcnMsIGRvY0lkKSA9PiB7XG4gICAgY29uc3Qgc2VuZGVyID0gU3lzdGVtLnBhcnRzQnlJZFtzZW5kZXJzWzBdLmlkXTtcbiAgICBtZXJyaWFtU2ltU2NvcmUoc2VuZGVyLCBkb2NJZCk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZ2xvYmFsSW50ZXJydXB0J10gPSAoKSA9PiB7XG4gICAgLy8gY3ljbGUgdGhyb3VnaCBhbGwgdGhlIHBhcnRzIGFuZCBzZXQgdGhlIFwic3RlcHBpbmdcIiBwcm9wZXJ0eSB0byBmYWxzZVxuICAgIE9iamVjdC52YWx1ZXMoU3lzdGVtLnBhcnRzQnlJZCkuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICBpZihwYXJ0LmlzU3RlcHBpbmcpe1xuICAgICAgICAgICAgcGFydC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHBhcnQsIFwic3RlcHBpbmdcIiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKiBSZWdpc3RlciB0aGUgaW5pdGlhbCBzZXQgb2YgcGFydHMgaW4gdGhlIHN5c3RlbSAqKi9cblN5c3RlbS5yZWdpc3RlclBhcnQoJ2NhcmQnLCBDYXJkKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ3N0YWNrJywgU3RhY2spO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnZmllbGQnLCBGaWVsZCk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdidXR0b24nLCBCdXR0b24pO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnd29ybGQnLCBXb3JsZFN0YWNrKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ3dpbmRvdycsIFdpbmRvdyk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdmaWVsZCcsIEZpZWxkKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2RyYXdpbmcnLCBEcmF3aW5nKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2ltYWdlJywgSW1hZ2UpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnYXJlYScsIEFyZWEpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnYXVkaW8nLCBBdWRpbyk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdicm93c2VyJywgQnJvd3Nlcik7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdyZXNvdXJjZScsIFJlc291cmNlKTtcblxuLyoqIFJlZ2lzdGVyIHRoZSBpbml0aWFsIHNldCBvZiB2aWV3cyBpbiB0aGUgc3lzdGVtICoqL1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnYnV0dG9uJywgQnV0dG9uVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdzdGFjaycsIFN0YWNrVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCd3b3JsZCcsIFdvcmxkVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdjYXJkJywgQ2FyZFZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnd2luZG93JywgV2luZG93Vmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdmaWVsZCcsIEZpZWxkVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdkcmF3aW5nJywgRHJhd2luZ1ZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnaW1hZ2UnLCBJbWFnZVZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnYXJlYScsIEFyZWFWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2F1ZGlvJywgQXVkaW9WaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2Jyb3dzZXInLCBCcm93c2VyVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdyZXNvdXJjZScsIFJlc291cmNlVmlldyk7XG5cblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBhZGRpbmcgYWxsIG9mIHRoZVxuLy8gYXZhaWxhYmxlIGN1c3RvbSBlbGVtZW50cyB0byB0aGUgd2luZG93IG9iamVjdCdzXG4vLyBjdXN0b21FbGVtZW50cyByZWdpc3RyeVxuU3lzdGVtLnJlZ2lzdGVyQ3VzdG9tRWxlbWVudHMgPSBmdW5jdGlvbigpe1xuICAgIE9iamVjdC5rZXlzKFN5c3RlbS5hdmFpbGFibGVWaWV3cykuZm9yRWFjaChwYXJ0TmFtZSA9PiB7XG4gICAgICAgIGxldCB2aWV3Q2xhc3MgPSBTeXN0ZW0uYXZhaWxhYmxlVmlld3NbcGFydE5hbWVdO1xuICAgICAgICBsZXQgZWxlbWVudE5hbWUgPSBTeXN0ZW0udGFnTmFtZUZvclZpZXdOYW1lZChwYXJ0TmFtZSk7XG4gICAgICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoZWxlbWVudE5hbWUsIHZpZXdDbGFzcyk7XG4gICAgfSk7XG59O1xuXG4vLyBpbmlpdGFsaXplIHRoZSBjb21waWxlciBhbmQgYWRkIGl0IHRvIHRoZSBzeXN0ZW1cbi8vIEluc3RhbnRpYXRlIHRoZSBncmFtbWFyLlxubGV0IGxhbmd1YWdlR3JhbW1hcjtcbmlmICh3aW5kb3cuZ3JhbW1hcil7XG4gICAgLy8gZm9yIHRlc3RpbmcgaXQgaXMgc29tZXRpbWVzIGNvbnZlbmllbnQgdG8gbG9hZCB0aGUgZ3JhbW1hciBhbmQgYWRkIHRvIHdpbmRvd1xuICAgIC8vIHNlZSAuL3Rlc3RzL3ByZWxvYWQuanMgZm9yIGV4YW1wbGVcbiAgICBsYW5ndWFnZUdyYW1tYXIgPSBvaG0uZ3JhbW1hcih3aW5kb3cuZ3JhbW1hcik7XG59IGVsc2Uge1xuICAgIGxhbmd1YWdlR3JhbW1hciA9IG9obS5ncmFtbWFyRnJvbVNjcmlwdEVsZW1lbnQoKTtcbn1cblxuU3lzdGVtLmdyYW1tYXIgPSBsYW5ndWFnZUdyYW1tYXI7XG5cbi8vIFNldCB0aGUgZXhlY3Rpb24gc3RhY2sgb24gdGhlXG4vLyBTeXN0ZW1cblN5c3RlbS5leGVjdXRpb25TdGFjayA9IG5ldyBFeGVjdXRpb25TdGFjaygpO1xuXG4vLyBBZGQgYSBkeW5hbWljIGdldHRlciBmb3IgdGhlIFdvcmxkIGZvciBjb252ZW5pZW5jZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5c3RlbSwgJ3dvcmxkJywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgIH1cbn0pO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIC8vIEFkZCB0aGUgU3lzdGVtIG9iamVjdCB0byB3aW5kb3cgc29cbiAgICAvLyB0aGF0IGl0IGlzIGdsb2JhbCBvbiB0aGUgcGFnZS4gV2UgZG8gdGhpc1xuICAgIC8vIGZvciBib3RoIGRlYnVnZ2luZyBhbmQgdGVzdGluZy5cbiAgICB3aW5kb3cuU3lzdGVtID0gU3lzdGVtO1xuICAgIC8vIEFkZCB0aGUgcG9zc2libGUgdmlld3MgYXMgd2ViY29tcG9uZW50c1xuICAgIC8vIGluIHRoZSBjdXN0b20gZWxlbWVudCByZWdpc3RyeVxuICAgIFN5c3RlbS5yZWdpc3RlckN1c3RvbUVsZW1lbnRzKCk7XG5cbiAgICAvLyBBZGQgYW55IG90aGVyIG5vbi1wYXJ0IHZpZXcgQ3VzdG9tRWxlbWVudHMsXG4gICAgLy8gbGlrZSB0aGUgaGFsb1xuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0LWhhbG8nLCBIYWxvKTtcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdC1uYXZpZ2F0b3InLCBTVE5hdmlnYXRvcik7XG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3QtZWRpdG9yJywgRWRpdG9yKTtcblxuICAgIC8vIEFkZCBuYXZcbiAgICBTeXN0ZW0ubmF2aWdhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtbmF2aWdhdG9yJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChTeXN0ZW0ubmF2aWdhdG9yKTtcblxuICAgIC8vIEFkZCBjb21wcmVoZW5zaXZlIGVkaXRvciBwYW5lXG4gICAgLy8gaWYgb25lIGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIG1hcmt1cFxuICAgIGxldCBleGlzdGluZ0VkaXRvcnMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0LWVkaXRvcicpKTtcbiAgICBleGlzdGluZ0VkaXRvcnMuZm9yRWFjaChlZGl0b3JFbCA9PiB7XG4gICAgICAgIGVkaXRvckVsLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIFN5c3RlbS5lZGl0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1lZGl0b3InKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFN5c3RlbS5lZGl0b3IpO1xuXG4gICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBzZXR1cCBvZlxuICAgIC8vIHRoZSBzeXN0ZW1cbiAgICBTeXN0ZW0uc2hvd0xvYWRpbmdTY3JlZW4oKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uaW5pdGlhbExvYWQoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0pO1xufSk7XG5cbi8vIGFkZCBhIG1lc3NhZ2UgbGlzdGVuZXIgb24gd2luZG93XG4vLyB0aGVzZSBjYW4gaW5jbHVkZSBtZXNzYWdlIGZyb20gYSBicm93c2VyIHBhcnRcbi8vIGZvciBub3cgZmlsdGVyIHRob3NlIG5vdCBjb21pbmcgZnJvbSB0aGUgb3JpZ2luXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gd2luZG93Lm9yaWdpbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKGBNZXNzYWdlIHRvIGJyb3dzZXJgKTtcbiAgICAvLyBUT0RPOiBtYXliZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBxdW90ZSBlc2NhcGVzIGRpcmVjdGx5XG4gICAgLy8gaW4gdGhlIGdyYW1tYXJcbiAgICBsZXQgc2NyaXB0ID0gZXZlbnQuZGF0YS5yZXBsYWNlQWxsKFwiJ1wiLCAnXCInKTtcbiAgICAvLyBvbmx5IHN0YXRlbWVudHMgYXJlIGFjY2VwdGVkIGZvciBub3dcbiAgICBsZXQgcGFyc2VkU2NyaXB0ID0gbGFuZ3VhZ2VHcmFtbWFyLm1hdGNoKHNjcmlwdCwgXCJTdGF0ZW1lbnRcIik7XG4gICAgaWYocGFyc2VkU2NyaXB0LmZhaWxlZCgpKXtcbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IGxvZyB0aGF0IGl0IGZhaWxlZFxuICAgICAgICBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBzY3JpcHQgZm9yIGJyb3dzZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNlbWFudGljcyA9IGxhbmd1YWdlR3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgbGV0IHdvcmxkID0gU3lzdGVtLnBhcnRzQnlJZFtcIndvcmxkXCJdO1xuICAgICAgICBzZW1hbnRpY3MuYWRkT3BlcmF0aW9uKFxuICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICBpbnRlcnByZXRlclNlbWFudGljcyh3b3JsZCwgU3lzdGVtKVxuICAgICAgICApO1xuICAgICAgICBsZXQgbXNnID0gc2VtYW50aWNzKHBhcnNlZFNjcmlwdCkuaW50ZXJwcmV0KCk7XG4gICAgICAgIFN5c3RlbS5zZW5kTWVzc2FnZShtc2csIHdvcmxkLCBTeXN0ZW0pO1xuICAgIH1cbn0pO1xuXG4vLyBnbG9iYWwgaW50ZXJydXB0XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgaWYoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkgPT0gJ2MnKXtcbiAgICAgICAgU3lzdGVtLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZ2xvYmFsSW50ZXJydXB0XCIsXG4gICAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICB9LCBTeXN0ZW0sIFN5c3RlbSk7XG4gICAgfVxufSk7XG5cblxuZXhwb3J0IHtcbiAgICBTeXN0ZW0sXG4gICAgU3lzdGVtIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEFyZWFcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBBcmVhIFBhcnQuXG4gKiBJIHJlcHJlc2VudCBhICdncm91cGluZycgb2Ygc3VicGFydHMgd2l0aGluXG4gKiBteSBvd25lciBwYXJ0LlxuICogSSBjb250YWluIHRoZSBMYXlvdXQgcHJvcGVydGllcyBzZXQsIGFuZCB0aGVyZWZvcmVcbiAqIGNhbiBkaXNwbGF5IG15IGNvbnRhaW5lZCBzdWJwYXJ0cyBhY2NvcmRpbmcgdG8gXG4gKiBkaWZmZXJlbnQgbGF5b3V0IHByb3BlcnRpZXMgdGhhbiBteSBhbmNlc3RvclxuICogQ2FyZC5cbiAqXG4gKi9cbmltcG9ydCB7UGFydH0gZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRMYXlvdXRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jbGFzcyBBcmVhIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImFyZWFcIixcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBcImZpZWxkXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgICAgICBcInJlc291cmNlXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdcIixcbiAgICAgICAgICAgIFwiYnJvd3NlclwiLFxuICAgICAgICAgICAgXCJ3aW5kb3dcIlxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEFkZCBzdHlsZSBwcm9wc1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkTGF5b3V0U3R5bGVQcm9wcyh0aGlzKTtcblxuICAgICAgICAvLyBTZXQgZGVmYXVsdCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIC8vIGZvciBhbiBlbXB0eSBhcmVhXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgNTBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgNTBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnY2xpcHBpbmcnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnYWxsb3ctc2Nyb2xsaW5nJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwicmdiKDIzOCwgMjM4LCAyMzgpXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LXRyYW5zcGFyZW5jeWAsXG4gICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2FyZWEnO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQXJlYSxcbiAgICBBcmVhIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkVGV4dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQXVkaW8gZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgc3JjKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNyYyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVhZHlTdGF0ZScsXG4gICAgICAgICAgICBcIkhBVkVfTk9USElOR1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInBsYXlcIixcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInN0b3BcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJsb2FkQXVkaW9Gcm9tU291cmNlXCIsIHRoaXMubG9hZEF1ZGlvRnJvbVNvdXJjZSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwicGxheVwiLCAoKSA9PiB7dGhpcy5wbGF5KHRydWUpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInBhdXNlXCIsICgpID0+IHt0aGlzLnBsYXkoZmFsc2UpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInN0b3BcIiwgdGhpcy5zdG9wKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMubG9hZEF1ZGlvRnJvbVNvdXJjZSA9IHRoaXMubG9hZEF1ZGlvRnJvbVNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBsYXkgPSB0aGlzLnBsYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdG9wID0gdGhpcy5zdG9wLmJpbmQodGhpcyk7XG5cblxuICAgICAgICAvLyBsb2FkIHRoZSBzcmMgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYoc3JjKXtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInNyY1wiLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFRleHRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC10cmFuc3BhcmVuY3knLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl0uZm9yRWFjaCgoc2lkZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3NpZGV9LXdpZHRoYCxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2F1ZGlvJztcbiAgICB9XG5cbiAgICBsb2FkQXVkaW9Gcm9tU291cmNlKHNlbmRlcnMsIHNvdXJjZVVybCl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInNyY1wiLCBzb3VyY2VVcmwpO1xuICAgIH1cblxuICAgIHBsYXkodmFsdWUpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJwbGF5XCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3RvcFwiLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgc3RvcCgpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJwbGF5XCIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3RvcFwiLCB0cnVlKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEF1ZGlvLFxuICAgIEF1ZGlvIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkVGV4dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQnJvd3NlciBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBzcmMpIHtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuXG4gICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3JjID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVhZHlTdGF0ZScsXG4gICAgICAgICAgICBcIkhBVkVfTk9USElOR1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInBsYXlcIixcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInN0b3BcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzZXRVUkxUb1wiLCB0aGlzLnNldFVSTCk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiZm9yd2FyZFwiLCB0aGlzLnNlbmRNZXNzYWdlVG9Ccm93c2VyKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0VVJMID0gdGhpcy5zZXRVUkwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQnJvd3NlciA9IHRoaXMuc2VuZE1lc3NhZ2VUb0Jyb3dzZXIuYmluZCh0aGlzKTtcblxuXG4gICAgICAgIC8vIGxvYWQgdGhlIHNyYyBpZiBwcm92aWRlZFxuICAgICAgICBpZihzcmMpe1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3R5bGUgcHJvcGVydGllc1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzaWRlfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICAgICA0MDAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdicm93c2VyJztcbiAgICB9XG5cbiAgICBzZXRVUkwoc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHNvdXJjZVVybCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2VUb0Jyb3dzZXIoc2VuZGVycywgbWVzc2FnZSl7XG4gICAgICAgIGxldCB2aWV3cyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0aGlzLmlkKTtcbiAgICAgICAgdmlld3MuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgbGV0IGlmcmFtZSA9IHYuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKTtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHdpbmRvdy5vcmlnaW4pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEJyb3dzZXIsXG4gICAgQnJvd3NlciBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBCdXR0b25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBCdXR0b24gUGFydC5cbiAqIE15IG93bmVyIGlzIGFsd2F5cyBhIENhcmQuXG4gKiBJIGFtIGEgY2xpY2thYmxlIHBvaW50IG9mIGludGVyYWN0aW9uIG9uIGEgQ2FyZCxcbiAqIHdob3NlIGZ1bmN0aW9uYWxpdHkgY2FuIGJlIGN1c3RvbWl6ZWQgYnkgdGhlIGF1dGhvci5cbiAqL1xuaW1wb3J0IFBhcnQgZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgQmFzaWNQcm9wZXJ0eSxcbiAgICBEeW5hbWljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkVGV4dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQnV0dG9uIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpe1xuICAgICAgICBzdXBlcihvd25lcik7XG5cbiAgICAgICAgdGhpcy5pc0J1dHRvbiA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIEJ1dHRvbi1zcGVjaWZpYyBwYXJ0IHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICdzZWxlY3RlZFRleHQnLFxuICAgICAgICAgICAgbnVsbCwgLy8gcmVhZE9ubHkgKGZvciBub3cpXG4gICAgICAgICAgICB0aGlzLmdldFNlbGVjdGVkVGV4dCxcbiAgICAgICAgICAgIHRydWUsIC8vIHJlYWRPbmx5LFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0eWxpbmdcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFRleHRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcInJnYigyNTUsIDIzNCwgMTQ5KVwiLCAvLyB2YXIoLS1wYWxldHRlLXllbGxvdylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjb3JuZXItdG9wLWxlZnQtcm91bmQnLFxuICAgICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2Nvcm5lci10b3AtcmlnaHQtcm91bmQnLFxuICAgICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2Nvcm5lci1ib3R0b20tbGVmdC1yb3VuZCcsXG4gICAgICAgICAgICAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY29ybmVyLWJvdHRvbS1yaWdodC1yb3VuZCcsXG4gICAgICAgICAgICAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYm9yZGVyLXRvcC13aWR0aCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYm9yZGVyLWJvdHRvbS13aWR0aCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYm9yZGVyLWxlZnQtd2lkdGgnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JvcmRlci1yaWdodC13aWR0aCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnc2hhZG93LWxlZnQnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3NoYWRvdy10b3AnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3NoYWRvdy1ibHVyJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdzaGFkb3ctYmx1cicsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG5cbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2J1dHRvbic7XG4gICAgfVxuXG4gICAgLy9UT0RPOiBpbXBsZW1lbnQgdGhpcyBwcm9wZXJ0eVxuICAgIC8vIGdldHRlciBmb3IgcmVhbFxuICAgIGdldFNlbGVjdGVkVGV4dChwcm9wTmFtZSwgcHJvcFZhbCl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQnV0dG9uLFxuICAgIEJ1dHRvbiBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBDYXJkXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIENhcmQgUGFydC5cbiAqIEkgcmVwcmVzZW50IGEgY29sbGVjdGlvbiBvZiBQYXJ0cyB0aGF0IGlzXG4gKiBkaXNwbGF5ZWQgb24gdGhlIHNjcmVlbi4gTXkgb3duZXIgaXMgYWx3YXlzXG4gKiBhIFN0YWNrIFBhcnQuXG4gKiBJIGNhbiBjb250YWluIGFueSBraW5kIG9mIFBhcnQsIGluY2x1ZGluZ1xuICogYnV0dG9ucyBhbmQgZmllbGRzLlxuICovXG5pbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIEJhc2ljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZExheW91dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQ2FyZCBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBuYW1lKXtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5fb3duZXI7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcIndpbmRvd1wiLCBcImJ1dHRvblwiLFxuICAgICAgICAgICAgXCJmaWVsZFwiLCBcImFyZWFcIiwgXCJkcmF3aW5nXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsIFwiYXVkaW9cIiwgXCJicm93c2VyXCIsIFwicmVzb3VyY2VcIlxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmlzQ2FyZCA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIENhcmQtc3BlY2lmaWMgcGFydFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ21hcmtlZCcsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdjYW50RGVsZXRlJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2RvbnRTZWFyY2gnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnc2hvd1BpY3QnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgaW5pdGlhbGl6aW5nIHdpdGggYSBuYW1lXG4gICAgICAgIC8vIHNldCB0aGUgbmFtZSBwcm9wZXJ0eVxuICAgICAgICBpZihuYW1lKXtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZExheW91dFN0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgIFwicmdiKDAsIDc1LCAxMDMpXCIgLy8gcGFsZXR0ZS1ibHVlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdjYXJkJztcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIENhcmQsXG4gICAgQ2FyZCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBCYXNpYyBVc2VyIERyYXdpbmcgUGFydFxuICovXG5pbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY29uc3Qgc2lkZXMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5cbmNsYXNzIERyYXdpbmcgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcil7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBTZXQgbmV3IHByb3BlcnRpZXMgZm9yIHRoaXNcbiAgICAgICAgLy8gcGFydCB0eXBlXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICAnZHJhd2luZydcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU3R5bGVcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwicmdiKDIzOCwgMjM4LCAyMzgpXCIsIC8vZ3JleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS10cmFuc3BhcmVuY3lgLFxuICAgICAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgIDMwMFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAyMDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBXZSBhcmUgdXNpbmcgYSBkaXN0aW5jdCBzaG93LWJvcmRlclxuICAgICAgICAvLyBwcm9wZXJ0eSB0byBkZWFsIHdpdGggYmVpbmcgYWJsZSB0byBzZWVcbiAgICAgICAgLy8gYSBkcmF3aW5nIHRoYXQgaXMgZW1wdHlcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnc2hvdy1ib3JkZXInLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFdoZW4gZHJhd2luZyBmcm9tIGEgc2NyaXB0L2NvbW1hbmRzLFxuICAgICAgICAvLyB3ZSB3aWxsIHVzZSB0aGlzIGFzIHRoZSBvcGVuIGNhbnZhc1xuICAgICAgICAvLyB3aG9zZSBpbWFnZSBieXRlcyB3aWxsIGJlIHNldCB0byB0aGVcbiAgICAgICAgLy8gaW1hZ2UgcHJvcGVydHlcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBudWxsO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgZHJhd2luZyBjb21tYW5kc1xuICAgICAgICB0aGlzLnNldHVwRHJhd2luZ0NvbW1hbmRzKCk7XG5cblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0dXBEcmF3aW5nQ29tbWFuZHMgPSB0aGlzLnNldHVwRHJhd2luZ0NvbW1hbmRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gdGhpcy5zdHJva2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlVG8gPSB0aGlzLm1vdmVUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxpbmVUbyA9IHRoaXMubGluZVRvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVnaW5EcmF3ID0gdGhpcy5iZWdpbkRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmREcmF3ID0gdGhpcy5lbmREcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXIgPSB0aGlzLmNsZWFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29vcmRzRnJvbVN0cmluZyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnZHJhd2luZyc7XG4gICAgfVxuXG4gICAgc2V0dXBEcmF3aW5nQ29tbWFuZHMoKXtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ2xpbmVUbycsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdtb3ZlVG8nLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignYmVnaW5EcmF3JywgKHNlbmRlcnMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5EcmF3KC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ2ZpbmlzaERyYXcnLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmREcmF3KC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ3N0cm9rZScsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdjbGVhcicsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBTY3JpcHRhYmxlIERyYXdpbmcgQ29tbWFuZHMgKi9cbiAgICBzdHJva2UoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgLy8gSGFyZC1jb2RlZC4gR2V0IGZyb20gcHJvcHNcbiAgICAgICAgICAgIC8vIGFuZCBsaW5rIHRvIHZpZXdzXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQuc3Ryb2tlV2lkdGggPSAxMDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlVG8oeCwgeSl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIC8vbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZyhjb29yZFBhaXIpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0Lm1vdmVUbyhcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5lVG8oeCwgeSl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIC8vbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZyhjb29yZFBhaXIpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWdpbkRyYXcoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEcmF3aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMud2lkdGggPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3dpZHRoJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcy5oZWlnaHQgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2hlaWdodCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0ID0gdGhpcy5hY3RpdmVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBjdXJyZW50bHkgaW1hZ2UgZGF0YSBzZXQgdG8gdGhlXG4gICAgICAgIC8vIGltYWdlIHBhcnQgcHJvcGVydHksIHdlIG5lZWQgdG8gZHJhdyB0aGF0IGltYWdlXG4gICAgICAgIC8vIG9udG8gdGhlIGNhbnZhcyBmaXJzdC5cbiAgICAgICAgbGV0IGN1cnJlbnRJbWFnZSA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaW1hZ2UnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRJbWFnZSl7XG4gICAgICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gY3VycmVudEltYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVnaW4gYSBkcmF3aW5nIHBhdGhcbiAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGVuZERyYXcoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGltYWdlIHByb3BlcnR5IHRvIGJlIHRoZVxuICAgICAgICAgICAgLy8gc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHVwZGF0ZSBhbnkgc3Vic2NyaWJlZCB2aWV3c1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcy50b0RhdGFVUkwoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzRHJhd2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzLndpZHRoID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICd3aWR0aCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMuaGVpZ2h0ID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dCA9IHRoaXMuYWN0aXZlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMudG9EYXRhVVJMKClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qIFV0aWxpdHkgTWV0aG9kcyBmb3IgU2NyaXB0YWJsZSBEcmF3aW5nICovXG4gICAgY29vcmRzRnJvbVN0cmluZyhjb29yZFN0cmluZyl7XG4gICAgICAgIGxldCBwYWlyID0gY29vcmRTdHJpbmcuc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgeCA9IHBhcnNlSW50KHBhaXJbMF0pO1xuICAgICAgICBsZXQgeSA9IHBhcnNlSW50KHBhaXJbMV0pO1xuICAgICAgICByZXR1cm4ge3gsIHl9O1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRHJhd2luZyxcbiAgICBEcmF3aW5nIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEZpZWxkXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIEZpZWxkIFBhcnQuXG4gKiBJIGFtIGEgY29udGFpbmVyIHRoYXQgaG9sZHMgdGV4dC4gSSBhbHNvIGFsbG93XG4gKiBhIHVzZXIgdG8gZWRpdCBteSB0ZXh0LlxuICovXG5pbXBvcnQgUGFydCBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcblxuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jbGFzcyBGaWVsZCBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBuYW1lKXtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXCJmaWVsZFwiXTtcblxuICAgICAgICB0aGlzLmlzRmllbGQgPSB0cnVlO1xuXG4gICAgICAgIGlmKG5hbWUpe1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIEZpZWxkLXNwZWNpZmljXG4gICAgICAgIC8vIFBhcnQgUHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdtb2RlJyxcbiAgICAgICAgICAgICdlZGl0aW5nJyAvL1RPRE8gdGhpcyBzaG91bGQgYmUgZWl0aGVyIFwiYnJhdm9cIiBvciBcInNpbXBsZXRhbGtcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAgICAgICAnJ1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3RhcmdldFJhbmdlSWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vICd0ZXh0JyBpcyBhIER5bmFtaWNQcm9wZXJ0eSBjb25maWd1cmVkIHRvIGFsc28gc2V0IHRoZSBpbm5lckhUTUxcbiAgICAgICAgLy8gQmFzaWNQcm9wZXJ0eSB3aGVuIGNoYW5nZWQuIFRoZSBiYXNpYyBpZGVhIGlzIHRoYXQgJ3RleHQnIHdpbGwgYmVcbiAgICAgICAgLy8gdGhlIHByb3BlcnR5IHRoYXQgU1Qgd2lsbCBpbnRlcmZhY2Ugd2l0aCBhbmQgZXZlcnl0aW1lIGl0XG4gICAgICAgIC8vIGlzIGNoYW5nZWQgdGhlICdpbm5lckhUTUwnIHByb3BlcnR5IHNob3VsZCBmb2xsb3cuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAob3duZXIsIHByb3AsIHZhbHVlLCBub3RpZnkpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9wLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmKG5vdGlmeSl7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgYWxsIG5ld2xpbmUgY2hhcmFjdGVycyB3aXRoIDxicj5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpO1xuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG93bmVyLCAnaW5uZXJIVE1MJywgdmFsdWUsIG5vdGlmeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChvd25lciwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wLl92YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICAgICAgJycgICAgIC8vIGRlZmF1bHQgaXMgZW1wdHkgc3RyaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnZWRpdGFibGUnLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG5cbiAgICAgICAgLy8gQSBudW1iZXIgb2YgdGhlIHByb3BzIGRlYWwgd2l0aCBkaXJlY3QgdGV4dCBlZGl0aW5nLFxuICAgICAgICAvLyBhbmQgc28gdGhleSBhcmUgbGlrZSBjb21tYW5kcy4gRXhhbXBsZXMgaW5jbHVkZSBcInVuZG9cIlxuICAgICAgICAvLyBcInJlZG9cIiBcImNsZWFyXCIgZXRjLiBIZXJlIHdlIHVzZSBkeW5hbWkgcHJvcHMgd2hpY2ggdGhlXG4gICAgICAgIC8vIHZpZXcgY2FuIHJlc3BvbmQgdG8gYWNjb3JkaW5nbHksIGJ1dCBoYXZpbmcgdGhlc2UgcHJvcHMgaGF2ZVxuICAgICAgICAvLyBubyBhY3R1YWwgJ3N0YXRlJ1xuICAgICAgICAvKiogVE9ETzogdGhlc2Ugc2hvdWxkIGJlIHByaXZhdGUgY29tbWFuZHNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgIFwidW5kb1wiLFxuICAgICAgICAgICAgKCkgPT4ge30sIC8vIGFsbCB3ZSBpcyBhIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgKCkgPT4ge30gLy8gbm8gZ2V0dGVyXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICBcInJlZG9cIixcbiAgICAgICAgICAgICgpID0+IHt9LCAvLyBhbGwgd2UgaXMgYSBub3RpZmljYXRpb25cbiAgICAgICAgICAgICgpID0+IHt9IC8vIG5vIGdldHRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgXCJyZW1vdmUtZm9ybWF0XCIsXG4gICAgICAgICAgICAoKSA9PiB7fSwgLy8gYWxsIHdlIGlzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAoKSA9PiB7fSAvLyBubyBnZXR0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgKiovXG5cbiAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICAvLyBzZXR0aW5nIHdpZHRoIGFuZCBoZWlnaHQgdG8gbnVsbFxuICAgICAgICAvLyBlZmZlY3RpdmVseSBmb3JjZXMgdG8gdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAgICAvLyBvZiB0aGUgYnV0dG9uIHRvIGZpdCB0aGUgYnV0dG9uIG5hbWVcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFRleHRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcInJnYigyNTUsIDI0OCwgMjIwKVwiLCAvLyB2YXIoLS1wYWxldHRlLWNvcm5zaWspXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgXCJtZWRpdW1cIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tc3R5bGVgLFxuICAgICAgICAgICAgICAgIFwic29saWRcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwiYmxhY2tcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgICAgIFwiMVwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICAgICA0MDAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG5cbiAgICAgICAgdGhpcy5pbnNlcnRSYW5nZSA9IHRoaXMuaW5zZXJ0UmFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24gPSB0aGlzLnNldFNlbGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImluc2VydFJhbmdlXCIsIHRoaXMuaW5zZXJ0UmFuZ2UpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInNldFNlbGVjdGlvblwiLCB0aGlzLnNldFNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiaGlnaGxpZ2h0U3ludGF4XCIsIHRoaXMuaGlnaGxpZ2h0U3ludGF4KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJ1bmhpZ2hsaWdodFN5bnRheFwiLCB0aGlzLnVuaGlnaGxpZ2h0U3ludGF4KTtcbiAgICB9XG5cbiAgICBpbnNlcnRSYW5nZShzZW5kZXJzLCByYW5nZUlkLCBodG1sLCBjc3Mpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGhpcy5pZCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy5pbnNlcnRSYW5nZShyYW5nZUlkLCBodG1sLCBjc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb24oc2VuZGVycywgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKXtcbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IGFsbG93IHByb3BlcnRpZXMgb2YgdHlwZSBcInRleHQtKlwiIHRvIGJlIHNldFxuICAgICAgICBpZihwcm9wZXJ0eU5hbWUuc3RhcnRzV2l0aChcInRleHQtXCIpKXtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0aGlzLmlkKS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRTZWxlY3Rpb24ocHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCB2aWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5pZCk7XG4gICAgICAgIGlmKHZpZXcpe1xuICAgICAgICAgICAgdmlldy5oaWdobGlnaHRTeW50YXgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCB2aWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5pZCk7XG4gICAgICAgIGlmKHZpZXcpe1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodFN5bnRheCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdmaWVsZCc7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBGaWVsZCxcbiAgICBGaWVsZCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuXG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgSW1hZ2UgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgc3JjKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgdGhpcy5zZXRTb3VyY2UsXG4gICAgICAgICAgICB0aGlzLmdldFNvdXJjZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3NyYyA9IHNyYztcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwibWltZVR5cGVcIixcbiAgICAgICAgICAgIFwidW5rbm93blwiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcImltYWdlRGF0YVwiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2RyYWdnYWJsZScsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcImJsYWNrXCJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJsb2FkSW1hZ2VGcm9tXCIsIHRoaXMubG9hZEltYWdlRnJvbVNvdXJjZSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZEltYWdlRnJvbUZpbGVcIiwgdGhpcy5sb2FkSW1hZ2VGcm9tRmlsZSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLmxvYWRJbWFnZUZyb21Tb3VyY2UgPSB0aGlzLmxvYWRJbWFnZUZyb21Tb3VyY2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2VGcm9tRmlsZSA9IHRoaXMubG9hZEltYWdlRnJvbUZpbGUuYmluZCh0aGlzKTtcbiAgICB9XG5cblxuICAgIGxvYWRJbWFnZUZyb21Tb3VyY2Uoc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgZmV0Y2goc291cmNlVXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICBpZighY29udGVudFR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UnKSl7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbWFnZSBtaW1lVHlwZTogJHtjb250ZW50VHlwZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbWVUeXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZihjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiaW1hZ2Uvc3ZnXCIpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKHRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKS50aGVuKGJsb2IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXN1bHQgLy8gd2lsbCBiZSB0aGUgYmFzZTY0IGVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBfc3JjLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGluZmluaXRlbHlcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBsb2FkIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuX3NyYyA9IHNvdXJjZVVybDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAnaW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2FkSW1hZ2VGcm9tRmlsZSgpe1xuICAgICAgICBsZXQgZmlsZVBpY2tlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGZpbGVQaWNrZXIudHlwZSA9ICdmaWxlJztcbiAgICAgICAgZmlsZVBpY2tlci5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsICdpbWFnZS8qJyk7XG4gICAgICAgIGZpbGVQaWNrZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZmlsZVBpY2tlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZmlsZSBoZXJlXG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAnbWltZVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICBmaWxlUGlja2VyLmZpbGVzWzBdLnR5cGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXN1bHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBpbWFnZUZpbGUgPSBmaWxlUGlja2VyLmZpbGVzWzBdO1xuICAgICAgICAgICAgaWYoaW1hZ2VGaWxlLnR5cGUuaW5jbHVkZXMoJ3N2ZycpKXtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChpbWFnZUZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZUZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVBpY2tlci5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGZpbGVQaWNrZXIpO1xuICAgICAgICBmaWxlUGlja2VyLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlKG93bmVyLCBwcm9wZXJ0eSwgdmFsdWUpe1xuICAgICAgICBvd25lci5fc3JjID0gdmFsdWU7XG4gICAgICAgIGlmKHZhbHVlKXtcbiAgICAgICAgICAgIG93bmVyLmxvYWRJbWFnZUZyb21Tb3VyY2UoW3RoaXNdLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTb3VyY2Uob3duZXIsIHByb3BlcnR5KXtcbiAgICAgICAgcmV0dXJuIG93bmVyLl9zcmM7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgfVxuXG4gICAgZ2V0IGlzU3ZnKCl7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIm1pbWVUeXBlXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYoIW1pbWVUeXBlKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW1lVHlwZS5zdGFydHNXaXRoKCdpbWFnZS9zdmcnKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEltYWdlLFxuICAgIEltYWdlIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFBhcnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgcmVwcmVzZW50IHRoZSBwcm90b3R5cGUgb2JqZWN0IGZvciBhbGxcbiAqIFNpbXBsZVRhbGsgcGFydHMuXG4gKi9cbmltcG9ydCB7XG4gICAgaWRNYWtlcixcbiAgICBpc1ZhbGlkSWRcbn0gZnJvbSAnLi4vdXRpbHMvaWQuanMnO1xuaW1wb3J0IGVycm9ySGFuZGxlciBmcm9tICcuLi91dGlscy9lcnJvckhhbmRsZXIuanMnO1xuaW1wb3J0IHtcbiAgICBQYXJ0UHJvcGVydGllcyxcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcblxuaW1wb3J0IHtBY3RpdmF0aW9uQ29udGV4dH0gZnJvbSAnLi4vRXhlY3V0aW9uU3RhY2suanMnO1xuXG5cbmNsYXNzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGFuT3duZXJQYXJ0LCBuYW1lLCBkZXNlcmlhbGl6aW5nPWZhbHNlKXtcblxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgLy8gQW4gYXJyYXkgb2YgY2hpbGQgcGFydHNcbiAgICAgICAgdGhpcy5zdWJwYXJ0cyA9IFtdO1xuICAgICAgICAvLyBhIGxpc3Qgb2YgYWxsIGFjY2VwdGVkIHN1YnBhcnRzIGJ5IHR5cGVcbiAgICAgICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIG51bGwgYW5kIGVhY2ggUGFydCBzdWJjbGNhc3Mgc2hvdWxkXG4gICAgICAgIC8vIHNwZWNpZnkgaWYgb3RoZXJ3aXNlXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzID0gbmV3IFBhcnRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuX293bmVyID0gYW5Pd25lclBhcnQ7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9wcml2YXRlQ29tbWFuZEhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0U2VtYW50aWNzID0ge307XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5U3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3ZpZXdTdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaXNQYXJ0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BlcnRpZXMgPSB0aGlzLnNldHVwUHJvcGVydGllcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzID0gdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuYWRkUGFydCA9IHRoaXMuYWRkUGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVBhcnQgPSB0aGlzLnJlbW92ZVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hY2NlcHRzU3VicGFydCA9IHRoaXMuYWNjZXB0c1N1YnBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIgPSB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlciA9IHRoaXMucmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0RnVuY0hhbmRsZXIgPSB0aGlzLnNldEZ1bmNIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUNtZCA9IHRoaXMucmVjZWl2ZUNtZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVGdW5jID0gdGhpcy5yZWNlaXZlRnVuYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVFcnJvciA9IHRoaXMucmVjZWl2ZUVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZU1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVNZXNzYWdlID0gdGhpcy5kZWxlZ2F0ZU1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IHRoaXMuc2VuZE1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eVN1YnNjcmliZXIgPSB0aGlzLmFkZFByb3BlcnR5U3Vic2NyaWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5U3Vic2NyaWJlciA9IHRoaXMucmVtb3ZlUHJvcGVydHlTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkVmlld1N1YnNjcmliZXIgPSB0aGlzLmFkZFZpZXdTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlVmlld1N1YnNjcmliZXIgPSB0aGlzLnJlbW92ZVZpZXdTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gdGhpcy5zZXJpYWxpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b0pTT04gPSB0aGlzLnRvSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByb3BzRnJvbURlc2VyaWFsaXplciA9IHRoaXMuc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmluZEFuY2VzdG9yT2ZUeXBlID0gdGhpcy5maW5kQW5jZXN0b3JPZlR5cGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuRWRpdG9yQ21kSGFuZGxlciA9IHRoaXMub3BlbkVkaXRvckNtZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvckNtZEhhbmRsZXIgPSB0aGlzLmNsb3NlRWRpdG9yQ21kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvcHlDbWRIYW5kbGVyID0gdGhpcy5jb3B5Q21kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhc3RlQ21kSGFuZGxlciA9IHRoaXMucGFzdGVDbWRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNTdWJwYXJ0T2ZDdXJyZW50Q2FyZCA9IHRoaXMuaXNTdWJwYXJ0T2ZDdXJyZW50Q2FyZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzU3VicGFydE9mQ3VycmVudFN0YWNrID0gdGhpcy5pc1N1YnBhcnRPZkN1cnJlbnRTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE93bmVyQnJhbmNoID0gdGhpcy5nZXRPd25lckJyYW5jaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0U3RlcHBpbmcgPSB0aGlzLnN0YXJ0U3RlcHBpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdG9wU3RlcHBpbmcgPSB0aGlzLnN0b3BTdGVwcGluZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRhcmdldFByb3AgPSB0aGlzLnNldFRhcmdldFByb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVN1YnBhcnRVcCA9IHRoaXMubW92ZVN1YnBhcnRVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vdmVTdWJwYXJ0RG93biA9IHRoaXMubW92ZVN1YnBhcnREb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVN1YnBhcnRUb0ZpcnN0ID0gdGhpcy5tb3ZlU3VicGFydFRvRmlyc3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlU3VicGFydFRvTGFzdCA9IHRoaXMubW92ZVN1YnBhcnRUb0xhc3QuYmluZCh0aGlzKTtcblxuXG5cbiAgICAgICAgLy8gRmluYWxseSwgd2UgZmluaXNoIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgLy8gY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm9wZW5FZGl0b3JcIiwgdGhpcy5vcGVuRWRpdG9yQ21kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiY2xvc2VFZGl0b3JcIiwgdGhpcy5jbG9zZUVkaXRvckNtZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInNldFRhcmdldFRvXCIsIHRoaXMuc2V0VGFyZ2V0UHJvcCk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiY29weVwiLCB0aGlzLmNvcHlDbWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlQ21kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVVcFwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnRVcCh0aGlzKTt9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlRG93blwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnREb3duKHRoaXMpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0ZpcnN0XCIsICgpID0+IHt0aGlzLl9vd25lci5tb3ZlU3VicGFydFRvRmlyc3QodGhpcyk7fSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVRvTGFzdFwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnRUb0xhc3QodGhpcyk7fSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZ2V0dGVyIHRvIGdldCB0aGUgaWRcbiAgICAvLyBmcm9tIHRoZSBwYXJ0UHJvcGVydGllc1xuICAgIGdldCBpZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsICdpZCcpO1xuICAgIH1cblxuICAgIHNldCBpZCh2YWwpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsICdpZCcsIHZhbCk7XG4gICAgfVxuXG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgbmFtZXMgb2YgYWxsIG9mIG15IGFuZCBteSBhbmNlc3RvcnMnIGhhbmRsZXJzXG4gICAgLy8gZm9yIHRoZSBtb21lbnQgdGhpcyBpcyBqdXN0IG5hbWVzLCB0eXBlLCBpZCBhbmQgd2hldGhlciB0aGUgaGFuZGxlciBvdmVycmlkZXNcbiAgICAvLyBhbiBvd25lcidzLCBidXQgY291bGQgYmUgcmljaGVyIGluZm8sIHN1Y2ggYXMgYXJndW1lbnRzLCBkb2N1bWVudGF0aW9uIGV0Y1xuICAgIGdldCBjb21tYW5kSGFuZGxlclJlZ2lzdHJ5KCl7XG4gICAgICAgIGxldCBoYW5kbGVyc0luZm8gPSB7fTtcbiAgICAgICAgbGV0IG93bmVyQnJhbmNoID0gdGhpcy5nZXRPd25lckJyYW5jaCgpO1xuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDw9IG93bmVyQnJhbmNoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gb3duZXJCcmFuY2hbb3duZXJCcmFuY2gubGVuZ3RoIC0gaV07XG4gICAgICAgICAgICBsZXQgcGFydFR5cGUgPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgICBpZihwYXJ0LmlkID09PSAtMSl7XG4gICAgICAgICAgICAgICAgcGFydFR5cGUgPSBcIlN5c3RlbVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTeXN0ZW0gZG9lc24ndCBoYXZlIHByaXZhdGUgY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcnQuX3ByaXZhdGVDb21tYW5kSGFuZGxlcnMpLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhhbmRsZXJzSW5mb1toXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNJbmZvW2hdID0ge3BhcnRJZDogcGFydC5pZCwgcGFydFR5cGU6IHBhcnRUeXBlLCBvdmVycmlkZTogb3ZlcnJpZGUsIHByaXZhdGU6IHRydWV9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFydC5fY29tbWFuZEhhbmRsZXJzKS5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoaGFuZGxlcnNJbmZvW2hdKXtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVyc0luZm9baF0gPSB7cGFydElkOiBwYXJ0LmlkLCBwYXJ0VHlwZTogcGFydFR5cGUsIG92ZXJyaWRlOiBvdmVycmlkZSwgcHJpdmF0ZTogZmFsc2V9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzSW5mbztcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIHRoZSB0aGlzLnBhcnQgLT4gU3lzdGVtIGJyYW5jaCBieSBwYXJ0IGlkXG4gICAgZ2V0T3duZXJCcmFuY2goYnJhbmNoKXtcbiAgICAgICAgaWYoIWJyYW5jaCl7XG4gICAgICAgICAgICBicmFuY2ggPSBbdGhpc107XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy50eXBlID09PSBcIndvcmxkXCIpe1xuICAgICAgICAgICAgYnJhbmNoLnB1c2god2luZG93LlN5c3RlbSk7XG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJhbmNoLnB1c2godGhpcy5fb3duZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fb3duZXIuZ2V0T3duZXJCcmFuY2goYnJhbmNoKTtcbiAgICB9XG5cbiAgICAvLyBDb25maWd1cmVzIHRoZSBzcGVjaWZpYyBwcm9wZXJ0aWVzIHRoYXQgdGhlXG4gICAgLy8gZ2l2ZW4gcGFydCBjYW4gZXhwZWN0LCBhbG9uZyB3aXRoIGFueSBkZWZhdWx0XG4gICAgLy8gdmFsdWVzLlxuICAgIC8vIERlc2NlbmRhbnQgUGFydHMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kXG4gICAgLy8gaW4gdGhlaXIgb3duIGNvbnN0cnVjdG9yIGFmdGVyIGNhbGxpbmcgc3VwZXIsXG4gICAgLy8gc28gdGhhdCB0aGV5IGdldCB0aGUgcGFyZW50J3MgZ2VuZXJhbCBwcm9wZXJ0aWVzXG4gICAgLy8gdG9vLlxuICAgIHNldHVwUHJvcGVydGllcygpe1xuICAgICAgICAvLyBIZXJlLCB3ZSBzZXQgdXAgcHJvcGVydGllcyBjb21tb25cbiAgICAgICAgLy8gdG8gQUxMIFBhcnRzIGluIHRoZSBzeXN0ZW0uXG4gICAgICAgIGxldCBiYXNpY1Byb3BzID0gW1xuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ3RhcmdldCcsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnY29udGVudHMnLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnd2FudHMtbW92ZScsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgICAgIGlkTWFrZXIubmV3KClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgYE5ldyAke3RoaXMudHlwZX1gXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ3JlY3RhbmdsZScsXG4gICAgICAgICAgICAgICAgXCIwLCAwLCAwLCAwXCIsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBbJ3JlY3QnXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIG51bGwgLy8gRm9yIG5vd1xuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICAgICAgLy8gY3NzIChyZWFsbHkgSlMgc3R5bGUpIGtleS12YWx1ZXNcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdjc3NTdHlsZScsXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gY3NzIChyZWFsbHkgSlMgc3R5bGUpIGtleS12YWx1ZXNcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdjc3NUZXh0U3R5bGUnLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgICBiYXNpY1Byb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLmFkZFByb3BlcnR5KHByb3ApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGUgaW5kZXggbnVtYmVyIG9mIHRoZSBwYXJ0IGluIHBhcnQuX293bmVyLnN1YnBhcnRcbiAgICAgICAgLy8gYXJyYXkuIE5vdGU6IHRoaXMgaXMgMS1pbmRleGVkXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgIG51bGwsIC8vIG5vIHNldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICBpZihwcm9wT3duZXIudHlwZSA9PSBcIndvcmxkXCIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BPd25lci5fb3duZXIuc3VicGFydHMuaW5kZXhPZihwcm9wT3duZXIpICsgMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlIC8vIHJlYWRvbmx5XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICd0YXJnZXQnLFxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWwpe1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgdGFyZ2V0IGlzIGEgbm9uLUlEXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gaXNWYWxpZElkKHZhbCk7XG4gICAgICAgICAgICAgICAgaWYoaWQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhbiBJRCBpbnNlcnQgXCJwYXJ0XCIgc2luY2Ugb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdyYW1tYXIgZG9lc24ndCBoYW5kbGUgSUQgd2l0aG91dCBzeXN0ZW0gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZWZpeGVzXG4gICAgICAgICAgICAgICAgICAgIHByb3BPYmplY3QuX3ZhbHVlID0gYHBhcnQgaWQgJHt2YWx9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wT2JqZWN0Ll92YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICApLFxuXG4gICAgICAgIC8vIEN1c3RvbSBQcm9wZXJ0aWVzIHN0b3JlIHByb3BzIGRlZmluZWQgd2l0aGluIHRoZVxuICAgICAgICAvLyBTVCBlbnZpcm9ubWVudFxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0N1c3RvbVByb3AoXG4gICAgICAgICksXG5cbiAgICAgICAgLy8gU3RlcHBpbmcgcmVsYXRlZCBwcm9wc1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAvLyBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlblxuICAgICAgICAgICAgLy8gc2VuZHMgb2YgdGhlIHN0ZXAgY29tbWFuZCBpZiB0aGVcbiAgICAgICAgICAgIC8vIHN0ZXBwaW5nIHByb3BlcnR5IGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAnc3RlcFRpbWUnLFxuICAgICAgICAgICAgLy8gRHluYW1pYyBzZXR0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsdWUpe1xuICAgICAgICAgICAgICAgIGlmKHByb3BPd25lci5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJydXB0IHRoZSBjdXJyZW50IGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXN0YXJ0IHdpdGggbmV3IHN0ZXBUaW1lXG4gICAgICAgICAgICAgICAgICAgIHByb3BPd25lci5zdG9wU3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnN0YXJ0U3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIER5bmFtaWMgZ2V0dGVyXG4gICAgICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZSwgLy8gY2FuIHJlYWQgYW5kIHdyaXRlXG4gICAgICAgICAgICA1MDAgLy8gRGVmYXVsdCB0byBoYWxmIGEgc2Vjb25kXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICdzdGVwcGluZycsXG4gICAgICAgICAgICAvLyBEeW5hbWljIHNldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWx1ZSl7XG4gICAgICAgICAgICAgICAgaWYodmFsdWUgPT09IGZhbHNlICYmIHByb3BPd25lci5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnN0b3BTdGVwcGluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PT0gdHJ1ZSAmJiAhcHJvcE93bmVyLmlzU3RlcHBpbmcpe1xuICAgICAgICAgICAgICAgICAgICBwcm9wT3duZXIuc3RhcnRTdGVwcGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBEeW5hbWljIGdldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW50ZXJ2YWxJZCBpcyBzZXQsIHRoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgUGFydCBpcyBjdXJyZW50bHkgc3RlcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE93bmVyLmlzU3RlcHBpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgfVxuXG4gICAgLy8gVG8gYmUgY2FsbGVkIGluIGVhY2ggc3ViLWNsYXNzIHRoYXQgaGFzIFN0eWxlUHJvcGVydGllc1xuICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgc3R5bGUgcHJvcHMgYXJlIGNvbmZpZ3VyZWRcbiAgICBzZXR1cFN0eWxlUHJvcGVydGllcygpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLl9wcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmKHByb3AuY29uc3RydWN0b3IubmFtZSA9PT0gXCJTdHlsZVByb3BlcnR5XCIpe1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHZhbHVlIG9uIGl0c2VsZiBlbnN1cmVzIHRoYXQgdGhlIGNzc1N0eWxlXG4gICAgICAgICAgICAgICAgLy8gQmFzaWNQcm9wZXJ0eSBpcyB1cGRhdGVkIHdpdGggdGhlIGFwcHJvcHJpYXRlIHN0eWxlclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnNpb24gY3NzIGtleS12YWxcbiAgICAgICAgICAgICAgICBwcm9wLnNldFZhbHVlKHRoaXMsIHByb3AuX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFN1YnBhcnQgQWNjZXNzICoqL1xuICAgIC8qKlxuICAgICAqIEVhY2ggc3ViY2xhc3Mgd2lsbCBpbXBsZW1lbnQgaXRzIG93biBzZXQgb2YgY2hlY2tzLFxuICAgICAqIGFuZCB0aHJvdyBhbiBhcHByb3ByaXRlIGVycm9yIGlmIHRoZSBzdWJwYXJ0IHR5cGUgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBhY2NlcHRzU3VicGFydChhUGFydFR5cGUpe1xuICAgICAgICBpZiAodGhpcy5hY2NlcHRlZFN1YnBhcnRUeXBlc1swXSA9PT0gXCIqXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMuaW5jbHVkZXMoYVBhcnRUeXBlLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwYXJ0IHRvIHRoaXMgcGFydCdzIHN1YnBhcnRzXG4gICAgICogY29sbGVjdGlvbiwgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICAgKiBJdCB3aWxsIGFsc28gc2V0IHRoZSBvd25lciBvZiB0aGVcbiAgICAgKiBhZGRlZCBwYXJ0IHRvIGJlIHRoaXMgcGFydC5cbiAgICAgKi9cbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgaWYoIXRoaXMuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gZG9lcyBub3QgYWNjZXB0IHN1YnBhcnRzIG9mIHR5cGUgJHthUGFydC50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYoZm91bmQgPCAwKXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydHMucHVzaChhUGFydCk7XG4gICAgICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcGFydCBmcm9tIHRoaXNcbiAgICAgKiBwYXJ0J3MgbGlzdCBvZiBzdWJwYXJ0cyAoaWYgcHJlc2VudCkuXG4gICAgICogSXQgd2lsbCBhbHNvIHVuc2V0IHRoZSBvd25lciBvZiB0aGVcbiAgICAgKiBnaXZlbiBwYXJ0LlxuICAgICAqL1xuICAgIHJlbW92ZVBhcnQoYVBhcnQpe1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYocGFydEluZGV4ID49IDApe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UocGFydEluZGV4LCAxKTtcbiAgICAgICAgICAgIGFQYXJ0Ll9vd25lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgdGhlIFBhcnQgaW5zdGFuY2UgaXMgYSBzdWJwYXJ0IG9mIHRoZSBjdXJyZW50XG4gICAgICogQ2FyZC5cbiAgICAgKi9cbiAgICBpc1N1YnBhcnRPZkN1cnJlbnRDYXJkKCl7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBQYXJ0IGluc3RhbmNlIGlzIGEgc3VicGFydCBvZiB0aGUgY3VycmVudFxuICAgICAqIFN0YWNrLlxuICAgICAqL1xuICAgIGlzU3VicGFydE9mQ3VycmVudFN0YWNrKCl7XG4gICAgfVxuXG4gICAgLyoqIExvZ2dpbmcgYW5kIFJlcG9ydGluZyAqKi9cbiAgICBzaG91bGRCZUltcGxlbWVudGVkKGZ1bmN0aW9uTmFtZSl7XG4gICAgICAgIGxldCBtc2cgPSBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHNob3VsZCBpbXBsZW1lbnQgJHtmdW5jdGlvbk5hbWV9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgLyoqIE1lc3NhZ2UgSGFuZGxpbmcgYW5kIERlbGVnYXRpb24gKiovXG4gICAgZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICBhTWVzc2FnZSxcbiAgICAgICAgICAgIHRoaXMuX293bmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHRhcmdldCl7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLnNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0aGlzLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIHJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgUGFydHMgd2lsbCBvbmx5IGhhbmRsZVxuICAgICAgICAvLyBtZXNzYWdlcyBvZiB0eXBlICdjb21tYW5kJyBhbmQgJ2Z1bmN0aW9uJ1xuICAgICAgICBzd2l0Y2goYU1lc3NhZ2UudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlQ21kKGFNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVGdW5jKGFNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVFcnJvcihhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNlaXZlRXJyb3IoYU1lc3NhZ2Upe1xuICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyLmhhbmRsZShhTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmVjZWl2ZUNtZChhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fY29tbWFuZEhhbmRsZXJzW2FNZXNzYWdlLmNvbW1hbmROYW1lXTtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIFBhcnQgaGFzIGEgaGFuZGxlciBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBnaXZlbiBjb21tYW5kLCB3ZSBydW4gaXQuXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGxhdGUtYmluZCB0aGUgY3VycmVudCBwYXJ0XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSBhcyB0aGUgJ3RoaXMnIGNvbnRleHQgZm9yXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlclxuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByaXZhdGVIYW5kbGVyID0gdGhpcy5fcHJpdmF0ZUNvbW1hbmRIYW5kbGVyc1thTWVzc2FnZS5jb21tYW5kTmFtZV07XG4gICAgICAgIGlmKHByaXZhdGVIYW5kbGVyKXtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgUGFydCBoYXMgYSBoYW5kbGVyIGZvclxuICAgICAgICAgICAgLy8gdGhlIGdpdmVuIGNvbW1hbmQsIHdlIHJ1biBpdC5cbiAgICAgICAgICAgIC8vIFdlIGFsc28gbGF0ZS1iaW5kIHRoZSBjdXJyZW50IHBhcnRcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIGFzIHRoZSAndGhpcycgY29udGV4dCBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICBsZXQgYm91bmRIYW5kbGVyID0gcHJpdmF0ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBoYXZlIG5vIGhhbmRsZXIgZm9yXG4gICAgICAgIC8vIGl0LiBVbmxlc3MgdGhlIG1lc3NhZ2UgaW5kaWNhdGVzIHNob3VsZE5vdERlbGVnYXRlXG4gICAgICAgIC8vIHdlIGRlbGVnYXRlIGFsb25nIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGRlbGVnYXRpb24gY2hhaW4uIEl0IGlzIHVwXG4gICAgICAgIC8vIHRvIFBhcnRzIHRvIHByb3Blcmx5IGltcGxlbWVudCBkZWxlZ2F0aW9uXG4gICAgICAgIC8vIGZvciB0aGVtc2VsdmVzIVxuICAgICAgICBpZihhTWVzc2FnZS5zaG91bGROb3REZWxlZ2F0ZSl7XG4gICAgICAgICAgICByZXR1cm4gYU1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZWNlaXZlRnVuYyhhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fZnVuY3Rpb25IYW5kbGVyc1thTWVzc2FnZS5mdW5jdGlvbk5hbWVdO1xuXG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZEhhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoY29tbWFuZE5hbWUsIGhhbmRsZXIpe1xuICAgICAgICB0aGlzLl9wcml2YXRlQ29tbWFuZEhhbmRsZXJzW2NvbW1hbmROYW1lXSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgcmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyKGNvbW1hbmROYW1lKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ByaXZhdGVDb21tYW5kSGFuZGxlcnNbY29tbWFuZE5hbWVdO1xuICAgIH1cblxuICAgIHNldEZ1bmNIYW5kbGVyKGZ1bmNOYW1lLCBoYW5kbGVyKXtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25IYW5kbGVyc1tmdW5jTmFtZV0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIC8qKiBDb21tYW5kIEhhbmRsZXJzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ29tbWFuZCBoYW5kbGVycyB3aGljaCBhcmUgaW52b2tlZCBhdCB0aGUgUGFydCBsZXZlbFxuICAgICAgICB3aGljaCBhcmUgbm90IGltbWVkaWF0ZWx5IGRlbGVnYWVkIHRvIHRoZSBQYXJ0Ll9vd25lclxuICAgICoqL1xuXG4gICAgb3BlbkVkaXRvckNtZEhhbmRsZXIoKXtcbiAgICAgICAgbGV0IGVkaXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LWVkaXRvcicpO1xuICAgICAgICBlZGl0b3IucmVuZGVyKHRoaXMpO1xuICAgICAgICBpZighZWRpdG9yLmlzT3Blbil7XG4gICAgICAgICAgICBlZGl0b3Iub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VFZGl0b3JDbWRIYW5kbGVyKCl7XG4gICAgICAgIGxldCBlZGl0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1lZGl0b3Iub3BlbicpO1xuICAgICAgICBpZihlZGl0b3Ipe1xuICAgICAgICAgICAgZWRpdG9yLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUYXJnZXRQcm9wKHNlbmRlcnMsIC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYXJncy5qb2luKFwiIFwiKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgY29weUNtZEhhbmRsZXIoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29weVBhcnQodGhpcyk7XG4gICAgfVxuXG4gICAgcGFzdGVDbWRIYW5kbGVyKCl7XG4gICAgICAgIGlmKCF3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5pc0VtcHR5KXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29udGVudHNbMF07XG4gICAgICAgICAgICBpZihpdGVtLnR5cGUgPT0gJ3NpbXBsZXRhbGsvanNvbicgJiYgdGhpcy5hY2NlcHRzU3VicGFydChpdGVtLnBhcnRUeXBlKSl7XG4gICAgICAgICAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQucGFzdGVDb250ZW50c0ludG8odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlKHNlbmRlcnMsIG1vdmVtZW50WCwgbW92ZW1lbnRZKXtcbiAgICAgICAgaWYoIXRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcIndhbnRzLW1vdmVcIikpe1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBhcnQgJHt0aGlzLmlkfSB0cnlpbmcgdG8gbW92ZSB3aXRoICd3YW50cy1tb3ZlJyBwcm9wZXJ0eSBmYWxzZWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJ0b3BcIik7XG4gICAgICAgIHRvcCArPSBtb3ZlbWVudFk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInRvcFwiLCB0b3ApO1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcImxlZnRcIik7XG4gICAgICAgIGxlZnQgKz0gbW92ZW1lbnRYO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJsZWZ0XCIsIGxlZnQpO1xuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgdGhpcy5zdWJwYXJ0cy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRVcChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gMCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdGU6IG1vdmVTdWJwYXJ0VG9GaXJzdCBtZWFucyBtb3ZlIHRvIGZpcnN0IGluIHRoZSB2aWV3XG4gICAgLy8gaS5lLiBsYXN0IGFzIGEgc3ViYXBydFxuICAgIG1vdmVTdWJwYXJ0VG9GaXJzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0xhc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgLyoqIFByb3BlcnR5IFN1YnNjcmliZXJzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBPYmplY3RzIGFkZGVkIGFzIHByb3BlcnR5IHN1YnNjcmliZXJzXG4gICAgICAgIHdpbGwgYmUgJ25vdGlmaWVkJyB3aGVuZXZlciBvbmUgb2YgdGhpc1xuICAgICAgICBQYXJ0J3MgcHJvcGVydGllcyBjaGFuZ2VzXG4gICAgKiovXG4gICAgYWRkUHJvcGVydHlTdWJzY3JpYmVyKGFuT2JqZWN0KXtcbiAgICAgICAgdGhpcy5fcHJvcGVydHlTdWJzY3JpYmVycy5hZGQoYW5PYmplY3QpO1xuICAgIH1cblxuICAgIHJlbW92ZVByb3BlcnR5U3Vic2NyaWJlcihhbk9iamVjdCl7XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5U3Vic2NyaWJlcnMuZGVsZXRlKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eUNoYW5nZWQocHJvcGVydHlOYW1lLCBuZXdWYWx1ZSl7XG4gICAgICAgIGxldCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3Byb3BlcnR5Q2hhbmdlZCcsXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIHBhcnRJZDogdGhpcy5pZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eVN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2UsIHN1YnNjcmliZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogVmlldyBTdWJzY3JpYmVyc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgT2JqZWN0cyBhZGRlZCBhcyB2aWV3IHN1YnNjcmliZXJzXG4gICAgICAgIHdpbGwgYmUgJ25vdGlmaWVkJyB3aGVuZXZlciB0aGlzIFBhcnRcbiAgICAgICAgaW5jdXJycyBhIHZpZXcgY2hhbmdlIChhZGQsIGRlbGV0ZSBzdWJwYXJ0cywgcmVvcmRlciBldGMpXG4gICAgKiovXG4gICAgYWRkVmlld1N1YnNjcmliZXIoYW5PYmplY3Qpe1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMuYWRkKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICByZW1vdmVWaWV3U3Vic2NyaWJlcihhbk9iamVjdCl7XG4gICAgICAgIHRoaXMuX3ZpZXdTdWJzY3JpYmVycy5kZWxldGUoYW5PYmplY3QpO1xuICAgIH1cblxuICAgIHZpZXdDaGFuZ2VkKGNoYW5nZU5hbWUsIC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWV3Q2hhbmdlZCcsXG4gICAgICAgICAgICBjaGFuZ2VOYW1lOiBjaGFuZ2VOYW1lLFxuICAgICAgICAgICAgcGFydElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobWVzc2FnZSwgc3Vic2NyaWJlcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN1YnBhcnRPcmRlckNoYW5nZWQoaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpe1xuICAgICAgICBsZXQgc3VicGFydCA9IHRoaXMuc3VicGFydHMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSlbMF07XG4gICAgICAgIHRoaXMuc3VicGFydHMuc3BsaWNlKG5ld0luZGV4LCAwLCBzdWJwYXJ0KTtcbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlZChcInN1YnBhcnQtb3JkZXJcIiwgaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpO1xuICAgIH1cblxuICAgIHN0YXJ0U3RlcHBpbmcoKXtcbiAgICAgICAgaWYodGhpcy5fc3RlcEludGVydmFsSWQpe1xuICAgICAgICAgICAgdGhpcy5zdG9wU3RlcHBpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RlcFRpbWUgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3N0ZXBUaW1lJ1xuICAgICAgICApO1xuICAgICAgICBpZihzdGVwVGltZSA+IDApe1xuICAgICAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdzdGVwJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHN0ZXBUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BTdGVwcGluZygpe1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3N0ZXBJbnRlcnZhbElkKTtcbiAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBpc1N0ZXBwaW5nKCl7XG4gICAgICAgIC8vIFdlIGtub3cgdGhlIFBhcnQgaXMgY3VycmVudGx5IHN0ZXBwaW5nXG4gICAgICAgIC8vIG9mIHRoZSBzdG9yZWQgaW50ZXJ2YWxJZCBpcyBzZXQgdG9cbiAgICAgICAgLy8gc29tZXRoaW5nIGJlc2lkZXMgbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcEludGVydmFsSWQgIT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgUGFydCdzIHN0YXRlIGFzIEpTT04uXG4gICAgICogQnkgZGVmYXVsdCwgd2UgZG8gbm90IHNlcmlhbGl6ZSBzcGVjaWZpY1xuICAgICAqIFBhcnRDb2xsZWN0aW9uIGluZm9ybWF0aW9uIChyZWN1cnNpdmVseSksXG4gICAgICogYW5kIG9ubHkgaW5jbHVkZSBiYXNpY3MgaW5jbHVkaW5nIHRoZSBjdXJyZW50XG4gICAgICogc3RhdGUgb2YgYWxsIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCl7XG4gICAgICAgIGxldCBvd25lcklkID0gbnVsbDtcbiAgICAgICAgaWYodGhpcy5fb3duZXIpe1xuICAgICAgICAgICAgb3duZXJJZCA9IHRoaXMuX293bmVyLmlkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgc3VicGFydHM6IHRoaXMuc3VicGFydHMubWFwKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LmlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvd25lcklkOiBvd25lcklkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuX3Byb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcC5nZXRWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcHJvcGVydGllcyBhbmQgb3RoZXJcbiAgICAgKiBhdHRyaWJ1dGVzIG9mIHRoaXMgUGFydCBtb2RlbFxuICAgICAqIGZyb20gYSBkZXNlcmlhbGl6ZWQgSlNPTiBvYmplY3QuXG4gICAgICovXG4gICAgc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyKGluY29taW5nUHJvcHMsIGRlc2VyaWFsaXplcil7XG4gICAgICAgIE9iamVjdC5rZXlzKGluY29taW5nUHJvcHMpLmZvckVhY2gocHJvcE5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gdGhpcy5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZighcHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWUgb2xkIG9yIGludmFsaWQgcHJvcGVydHkgaXNcbiAgICAgICAgICAgICAgICAvLyBwcmVzZW50IGluIHRoZSBkZXNlcmlhbGl6YXRpb24sIHNpbXBseSBwcm92aWRlXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nIGFuZCB0aGVuIHNraXAgdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXNlcmlhbGl6ZWQgcHJvcGVydHkgXCIke3Byb3BOYW1lfVwiIGlzIG5vdCBhIHZhbGlkIHByb3BlcnR5IG5hbWUgZm9yICR7dGhpcy50eXBlfSAoaWQgJHt0aGlzLmlkfSkgYW5kIHdpbGwgYmUgaWdub3JlZGApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHByb3BOYW1lID09IFwiY3VzdG9tLXByb3BlcnRpZXNcIil7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIHByb3BlcnRpZXMgYXJlIHNlcmlhbGl6ZWQgYXMgYW4gb2JqZWN0IGxpa2Ugb3RoZXIgcHJvcHNcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byBjcmVhdGUgcHJvcGVydGllcyBmcm9tIHRoZXNlIGFuZCBzZXQgdGhlaXIgcmVzcGVjdGl2ZVxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcy4gVGhlbiB3ZSBuZWVkIHRvIHNldCB0aGUgdmFsdWUgb2YgXCJjdXN0b20tcHJvcGVydGllc1wiIHByb3BcbiAgICAgICAgICAgICAgICAvLyBpdHNlbGYgdG8gYmUgdGhlIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGVzZVxuICAgICAgICAgICAgICAgIGxldCBjdXN0b21Qcm9wc0RhdGEgPSBpbmNvbWluZ1Byb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q3VzdG9tUHJvcHNPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKGN1c3RvbVByb3BzRGF0YSkuZm9yRWFjaCgocHJvcERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgQmFzaWNQcm9wZXJ0eShwcm9wRGF0YS5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcC5zZXRWYWx1ZSh0aGlzLCBwcm9wRGF0YS5fdmFsdWUsIGZhbHNlKTsgLy8gbm8gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3VzdG9tUHJvcHNPYmplY3RbcHJvcERhdGEubmFtZV0gPSBuZXdQcm9wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFZhbHVlKHRoaXMsIG5ld0N1c3RvbVByb3BzT2JqZWN0LCBmYWxzZSk7IC8vIG5vIG5lZWQgdG8gbm90aWZ5XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXByb3BlcnR5LnJlYWRPbmx5KXtcbiAgICAgICAgICAgICAgICAvLyBMYXN0IGFyZyBpcyBmYWxzZSwgd2hpY2ggdGVsbHMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbm90IHRvIG5vdGlmeSBpdHMgb3duZXIncyBzdWJzY3JpYmVycyBvZlxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IGNoYW5nZXMuIFdlIGRvbid0IG5lZWQgdGhhdCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gZGVzZXJpYWxpemluZ1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFZhbHVlKHRoaXMsIGluY29taW5nUHJvcHNbcHJvcE5hbWVdLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvSlNPTigpe1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9XG5cbiAgICBmaW5kQW5jZXN0b3JPZlR5cGUoYVBhcnRUeXBlKXtcbiAgICAgICAgbGV0IG93bmVyID0gdGhpcy5fb3duZXI7XG4gICAgICAgIHdoaWxlKG93bmVyKXtcbiAgICAgICAgICAgIGlmKG93bmVyLnR5cGUgPT0gYVBhcnRUeXBlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvd25lciA9IG93bmVyLl9vd25lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnQsXG4gICAgUGFydCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIFJlc291cmNlIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIHNyYykge1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3JjID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdyZWFkeVN0YXRlJyxcbiAgICAgICAgICAgIFwibm90UmVhZHlcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJwcmVyZXF1aXNpdGVcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwicmVzb3VyY2VOYW1lXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZFJlc291cmNlXCIsIHRoaXMubG9hZFJlc291cmNlKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzZXRTb3VyY2VUb1wiLCB0aGlzLnNldFNvdXJjZVRvKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJnZXRcIiwgdGhpcy5nZXQpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5sb2FkUmVzb3VyY2UgPSB0aGlzLmxvYWRSZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgc3JjIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRUZXh0U3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzaWRlfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdyZXNvdXJjZSc7XG4gICAgfVxuXG4gICAgbG9hZFJlc291cmNlKHNlbmRlcnMsIHJlc291cmNlTmFtZSl7XG4gICAgICAgIGlmKCF3aW5kb3cuU3lzdGVtLmF2YWlsYWJsZVJlc291cmNlcyB8fCAhd2luZG93LlN5c3RlbS5hdmFpbGFibGVSZXNvdXJjZXNbcmVzb3VyY2VOYW1lXSl7XG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGJlIGEgU1QgZXJyb3JcbiAgICAgICAgICAgIHRocm93IEVycm9yKGByZXNvdXJjZSAke3Jlc291cmNlTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHdpbmRvdy5TeXN0ZW0uYXZhaWxhYmxlUmVzb3VyY2VzW3Jlc291cmNlTmFtZV07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlc291cmNlTmFtZVwiLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICAvLyB3ZSBjYW4ndCBndWFyYW50ZWUgdGhlIHN0YXRlIG9mIGEgcmVzb3VyY2UgYW5kIHNvIGl0IHNob3VsZCBiZSByZS1zZXQgZXZlcnkgdGltZVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlVG8oc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgaWYoIXRoaXMucmVzb3VyY2Upe1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgbm8gcmVzb3VyY2UgbG9hZGVkIGZvciByZXNvdXJjZSBwYXJ0IGlkICR7dGhpcy5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgc291cmNlVXJsKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZS5sb2FkKHNvdXJjZVVybCk7XG4gICAgICAgIC8vIHdlIGNhbid0IGd1YXJhbnRlZSB0aGUgc3RhdGUgb2YgYSByZXNvdXJjZSBhbmQgc28gaXQgc2hvdWxkIGJlIHJlLXNldCBldmVyeSB0aW1lXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgIH1cblxuICAgIGdldChzZW5kZXJzLCAuLi5hcmdzKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVhZHlTdGF0ZVwiLCBcImZldGNoaW5nXCIpO1xuICAgICAgICBsZXQgcHJlcmVxdWlzaXRlID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicHJlcmVxdWlzaXRlXCIpO1xuICAgICAgICB0aGlzLnJlc291cmNlLmdldChwcmVyZXF1aXNpdGUsIC4uLmFyZ3MpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZWFkeVN0YXRlXCIsIFwicmVhZHlcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJyZXNwb25kZWRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5pZCwgdGhpcy5yZXNvdXJjZS5uYW1lXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlYWR5U3RhdGVcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlc3BvbnNlXCIsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZXJyb3JlZFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmlkLCB0aGlzLnJlc291cmNlLm5hbWUsIGVycm9yLm1lc3NhZ2VdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0KCl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlYWR5U3RhdGVcIiwgXCJub3RSZWFkeVwiKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVzcG9uc2VcIiwgbnVsbCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBSZXNvdXJjZSxcbiAgICBSZXNvdXJjZSBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTdGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSB0aGUgU3RhY2sgUGFydC5cbiAqIEkgcmVwcmVzZW50IGEgY29sbGVjdGlvbiBvZiBDYXJkIHBhcnRzLFxuICogYWxvbmcgd2l0aCBzb21lIGV4dHJhIGNvbmZpZ3VyYWJpbGl0eS5cbiAqL1xuaW1wb3J0IFBhcnQgZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZC5qcyc7XG5pbXBvcnQge1xuICAgIEJhc2ljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIFN0YWNrIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIG5hbWUsIGRlc2VyaWFsaXppbmc9ZmFsc2Upe1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImNhcmRcIiwgXCJ3aW5kb3dcIiwgXCJidXR0b25cIiwgXCJhcmVhXCIsIFwiZmllbGRcIixcbiAgICAgICAgICAgIFwiZHJhd2luZ1wiLCBcImltYWdlXCIsIFwiYXVkaW9cIiwgXCJicm93c2VyXCJcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBTZXQgdXAgU3RhY2sgc3BlY2lmaWNcbiAgICAgICAgLy8gUGFydFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnY2FudFBlZWsnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVzaXphYmxlJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cblxuICAgICAgICAvLyBXaWxsIGhvbGQgdGhlIGNhcmQtYmFzZWQgaW5kZXgsXG4gICAgICAgIC8vIHdoaWNoIGhlcmUgaXMgemVyby1pbmRleGVkLCBvZiB0aGVcbiAgICAgICAgLy8gY2FyZCB0aGF0IGlzIHRoZSBjdXJyZW50IGNhcmQgZm9yIHRoaXNcbiAgICAgICAgLy8gU3RhY2suXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgZ2VuZXJhbCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8gPSB0aGlzLnNlbmRPcGVuQ2FyZFRvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvID0gdGhpcy5zZW5kQ2xvc2VDYXJkVG8uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIHN0YWNrIG5hdmlnYXRpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLmdvVG9OZXh0Q2FyZCA9IHRoaXMuZ29Ub05leHRDYXJkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub1ByZXZDYXJkID0gdGhpcy5nb1RvUHJldkNhcmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvQ2FyZEJ5SWQgPSB0aGlzLmdvVG9DYXJkQnlJZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdvVG9OdGhDYXJkID0gdGhpcy5nb1RvTnRoQ2FyZC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdvVG9OZXh0Q2FyZCgpe1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoY2FyZHMubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBjdXJyZW50SWR4ID0gY2FyZHMuaW5kZXhPZihjdXJyZW50Q2FyZCk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCArIDE7XG4gICAgICAgIGlmKG5leHRJZHggPj0gY2FyZHMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHRJZHggPSAobmV4dElkeCAlIGNhcmRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHNbbmV4dElkeF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBuZXh0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50Q2FyZElkICE9IG5leHRDYXJkLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvKGN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8obmV4dENhcmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub0NhcmRCeUlkKGFuSWQpe1xuICAgICAgICBsZXQgY3VycmVudENhcmRJZCA9IHRoaXMuY3VycmVudENhcmRJZDtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkID0gdGhpcy5jdXJyZW50Q2FyZDtcbiAgICAgICAgbGV0IGNhcmRzID0gT2JqZWN0LnZhbHVlcyh3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZCkuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwiY2FyZFwiO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHMuZmluZChjYXJkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXJkLmlkID09IGFuSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZighbmV4dENhcmQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FyZCBpZDogJHthbklkfSBjYW50IGJlIGZvdW5kIHN0YWNrYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGNhcmQgaXMgbm90IG9uIHRoaXMgc3RhY2sgd2Ugc2hvdWxkIGdvIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0YWNrXG4gICAgICAgIGlmKG5leHRDYXJkLl9vd25lciAhPSB0aGlzKXtcbiAgICAgICAgICAgIHRoaXMuX293bmVyLmdvVG9TdGFja0J5SWQobmV4dENhcmQuX293bmVyLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dENhcmQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYoY3VycmVudENhcmRJZCAhPSBuZXh0Q2FyZC5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZUNhcmRUbyhjdXJyZW50Q2FyZCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuQ2FyZFRvKG5leHRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9QcmV2Q2FyZCgpe1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoY2FyZHMubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBjdXJyZW50SWR4ID0gY2FyZHMuaW5kZXhPZihjdXJyZW50Q2FyZCk7XG5cbiAgICAgICAgbGV0IG5leHRJZHggPSBjdXJyZW50SWR4IC0gMTtcbiAgICAgICAgaWYobmV4dElkeCA8IDApe1xuICAgICAgICAgICAgbmV4dElkeCA9IGNhcmRzLmxlbmd0aCArIG5leHRJZHg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHNbbmV4dElkeF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBuZXh0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50Q2FyZElkICE9IG5leHRDYXJkLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvKGN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8obmV4dENhcmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub050aENhcmQoYW5JbmRleCl7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSB1c2luZyAxLWluZGV4ZWQgdmFsdWVzXG4gICAgICAgIC8vIHBlciB0aGUgU2ltcGxlVGFsayBzeXN0ZW1cbiAgICAgICAgbGV0IHRydWVJbmRleCA9IGFuSW5kZXggLSAxO1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYodHJ1ZUluZGV4IDwgMCB8fCB0cnVlSW5kZXggPiBjYXJkcy5sZW5ndGggLTEpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgbmF2aWdhdGUgdG8gY2FyZCBudW1iZXIgJHthbkluZGV4fSAtLSBvdXQgb2YgYm91bmRzYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBuZXh0Q2FyZCA9IGNhcmRzW3RydWVJbmRleF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgIG5leHRDYXJkLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRDYXJkSWQgIT0gbmV4dENhcmQuaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VDYXJkVG8oY3VycmVudENhcmQpO1xuICAgICAgICAgICAgdGhpcy5zZW5kT3BlbkNhcmRUbyhuZXh0Q2FyZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kQ2xvc2VDYXJkVG8oYUNhcmQpe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2Nsb3NlQ2FyZCcsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYUNhcmRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZW5kT3BlbkNhcmRUbyhhQ2FyZCl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlbkNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFDYXJkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdzdGFjayc7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRDYXJkSWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudENhcmQoKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RoaXMuY3VycmVudENhcmRJZF07XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGJhc2UgY2xhc3MgbWV0aG9kc1xuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsQ2FyZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPCBsYXN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlU3VicGFydFRvTGFzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsQ2FyZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPCBsYXN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgbGFzdFZhbGlkUGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VXAocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBmaXJzdFZhbGlkUGFydEluZGV4ID0gMDtcbiAgICAgICAgaWYocGFydC50eXBlICE9IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlyc3RWYWxpZFBhcnRJbmRleCA9IGFsbENhcmRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPiBmaXJzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0ZpcnN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgZmlyc3RWYWxpZFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmKHBhcnQudHlwZSAhPSBcImNhcmRcIil7XG4gICAgICAgICAgICBsZXQgYWxsQ2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0VmFsaWRQYXJ0SW5kZXggPSBhbGxDYXJkcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gZmlyc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBmaXJzdFZhbGlkUGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFBhcnQoYVBhcnQpe1xuICAgICAgICBpZighdGhpcy5hY2NlcHRzU3VicGFydChhUGFydC50eXBlKSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy50eXBlfSBkb2VzIG5vdCBhY2NlcHQgc3VicGFydHMgb2YgdHlwZSAke2FQYXJ0LnR5cGV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YoYVBhcnQpO1xuICAgICAgICBpZihmb3VuZCA8IDApe1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcnQgaXMgYSBjYXJkIHRoZW4gYXBwZW5kIGFmdGVyIHRoZSBsYXN0IGNhcmRcbiAgICAgICAgICAgIGlmKGFQYXJ0LnR5cGUgPT0gXCJjYXJkXCIpe1xuICAgICAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UoYWxsQ2FyZHMubGVuZ3RoLCAwLCBhUGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VicGFydHMucHVzaChhUGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTdGFjayxcbiAgICBTdGFjayBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBXaW5kb3cgUGFydFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBIFdpbmRvdyBpcyBhIFBhcnQgdGhhdCB3cmFwcyBhbm90aGVyXG4gKiBQYXJ0IG9mIHR5cGUgQ2FyZCwgU3RhY2ssIG9yIFdvcmxkU3RhY2tcbiAqIGluIGEgbW92ZWFibGUgd2luZG93LlxuICogSSBjYW4gYWxzbyBvcHRpb25hbGx5IGhvbGQgYSByZWZlcmVuY2VcbiAqIHRvIGEgdGFyZ2V0IFBhcnQgdGhhdCBJIGRvIG5vdCBvd24uIEkgY2FsbFxuICogdGhpcyBKUyBwcm9wZXJ0eSB0YXJnZXQgYW5kIEkgc3RvcmUgdGhlXG4gKiB0YXJnZXQgcGFydCdzIGlkIGFzIGEgSHlwZXJUYWxrIHByb3BlcnR5XG4gKiBjYWxsZWQgdGFyZ2V0SWQuXG4gKiBXaGVuIG15IG93bmVyIHBhcnQgaXMgdGhlIGN1cnJlbnQgdmlldywgSVxuICogd2lsbCBiZSB2aXNpYmxlIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2UuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi9TdGFjay5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkTGF5b3V0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBXaW5kb3cgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgbmFtZSwgdGFyZ2V0LCBkZXNlcmlhbGl6aW5nPWZhbHNlKXtcbiAgICAgICAgc3VwZXIob3duZXIsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImFyZWFcIixcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBcImZpZWxkXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgICAgICBcInJlc291cmNlXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdcIixcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBJZiB3ZSBwYXNzIGluIGEgdGFyZ2V0LFxuICAgICAgICAvLyBzZXQgaXQuXG4gICAgICAgIGlmKHRhcmdldCl7XG4gICAgICAgICAgICB0aGlzLnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHVwIFdpbmRvdyBzcGVjaWZpY1xuICAgICAgICAvLyBwYXJ0IHB0b3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgICAgIFwiTmV3IFdpbmRvdyBUaXRsZVwiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnaXNSZXNpemFibGUnLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICAvLyBTdHlsZVxuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICAvLyBwYXJ0IHNwZWNpZmljIGRlZmF1bHQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXRUYXJnZXQgPSB0aGlzLnNldFRhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV2luZG93Q2xvc2UgPSB0aGlzLm9uV2luZG93Q2xvc2UuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBBZGQgcHJpdmF0ZSBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignd2luZG93Q2xvc2UnLCB0aGlzLm9uV2luZG93Q2xvc2UpO1xuICAgIH1cblxuICAgIHNldFRhcmdldChhUGFydCl7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYVBhcnQ7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgdGhpcy50YXJnZXQuaWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1bnNldFRhcmdldCgpe1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlXG4gICAgICogVW5saWtlIG90aGVyIGtpbmRzIG9mIFBhcnRzLCBhIHdpbmRvd1xuICAgICAqIGhhcyBvbmx5IG9uZSBzdWJwYXJ0LCB3aGljaCBzaG91bGQgYmVcbiAgICAgKiBDYXJkLCBTdGFjaywgb3IgV29ybGRTdGFjay5cbiAgICAgKi9cbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0aGlzLmFjY2VwdHNTdWJwYXJ0KGFQYXJ0LnR5cGUpO1xuICAgICAgICBpZighaXNWYWxpZCl7XG4gICAgICAgICAgICAvLyBDb25zaWRlciByZXBsYWNpbmcgdGhpcyBnZW5lcmljIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCBhIG1lc3NhZ2UgYmFzZWQgYXBwcm9hY2ggdGhhdCBzZW5kc1xuICAgICAgICAgICAgLy8gdGhlc2Ugc29ydHMgb2Ygbm9uLWZhdGFsIGVycm9ycyB0byBTeXN0ZW1cbiAgICAgICAgICAgIC8vIGFzIGEga2luZCBvZiBtZXNzYWdlLiBUaGlzIHdheSB3ZSBjYW4gZGlzcGxheVxuICAgICAgICAgICAgLy8gZXJyb3JzIGluIFNpbXBsdFRhbGsgb2JqZWN0cy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2luZG93cyBjYW5ub3Qgd3JhcCBwYXJ0cyBvZiB0eXBlICR7YVBhcnQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhcnQoc3VicGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIG9uV2luZG93Q2xvc2Uoc2VuZGVycywgLi4uYXJncyl7XG4gICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gZGVsZXRlXG4gICAgICAgIC8vIHRoZSB3aW5kb3cgbW9kZWwgZnJvbSB0aGUgU3lzdGVtLlxuICAgICAgICAvLyBTY3JpcHRzIGNhbiBvdmVycmlkZSB0aGlzIGhhbmRsZXJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdkZWxldGVNb2RlbCcsXG4gICAgICAgICAgICAgICAgYXJnczogWyB0aGlzLmlkIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICd3aW5kb3cnO1xuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBXaW5kb3csXG4gICAgV2luZG93IGFzIGRlZmF1bHRcbn1cbiIsIi8qKlxuICogV29ybGRTdGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgU3RhY2sgcGFydCB0aGF0IHJlcHJlc2VudHMgdGhlIHJvb3Qgb2YgYVxuICogaGllcmFyY2h5IG9mIHBhcnRzLiBJIGFtIHRoZSBlbmQgb2YgdGhlIG93bmVyc2hpcFxuICogY2hhaW4gZm9yIGFueSBnaXZlbiBjb25maWd1cmF0aW9uIG9mIFBhcnRzLlxuICogSSBhbSBhbHNvIHRoZSBmaW5hbCByZXNvbHZlciBvZiBhbGwgdW5oYW5kbGVkXG4gKiBtZXNzYWdlcyBzZW50IGFsb25nIHRoZSBkZWxlZ2F0aW9uIGNoYWluIGZvciBwYXJ0cy5cbiAqIEFsbCBwYXJ0cyBjYW4gZXZlbnR1YWxseSByZXNvbHZlIHRvIG1lIHZpYSB0aGUgZGVsZWdhdGlvblxuICogY2hhaW4gb3Igb3duZXJzaGlwIGhpZXJhcmNoeS5cbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBpbnN0YW5jZSBvZiBtZSBpbiBhbnkgZ2l2ZW5cbiAqIFNpbXBsZVRhbGsgZW52aXJvbm1lbnQuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5cblxuY2xhc3MgV29ybGRTdGFjayBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKG51bGwpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXCJzdGFja1wiLCBcImltYWdlXCJdO1xuXG4gICAgICAgIHRoaXMuaXNXb3JsZCA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIHN0YWNrXG4gICAgICAgIC8vIGlkIG9mIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFNldCB0aGUgaWQgcHJvcGVydHkgdG8gYWx3YXlzXG4gICAgICAgIC8vIGJlICd3b3JsZCdcbiAgICAgICAgdGhpcy5pZCA9ICd3b3JsZCc7XG5cbiAgICAgICAgLy8gQmluZCBnZW5lcmFsIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZW5kT3BlblN0YWNrVG8gPSB0aGlzLnNlbmRPcGVuU3RhY2tUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8gPSB0aGlzLnNlbmRDbG9zZVN0YWNrVG8uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIG5hdmlnYXRpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLmdvVG9OZXh0U3RhY2sgPSB0aGlzLmdvVG9OZXh0U3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvUHJldlN0YWNrID0gdGhpcy5nb1RvUHJldlN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub050aFN0YWNrID0gdGhpcy5nb1RvTnRoU3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvU3RhY2tCeUlkID0gdGhpcy5nb1RvU3RhY2tCeUlkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvbW1hbmQgaGFuZGxlcnMgd2hpY2ggYXJlIG5vdCBuZWVkZWQgZm9yIHdvcmxkXG4gICAgICAgIHRoaXMucmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVVwXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVEb3duXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0ZpcnN0XCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0xhc3RcIik7XG4gICAgfVxuXG4gICAgZ29Ub05leHRTdGFjaygpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihzdGFja3MubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrSWQgPSB0aGlzLmN1cnJlbnRTdGFja0lkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IHN0YWNrcy5pbmRleE9mKGN1cnJlbnRTdGFjayk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCArIDE7XG4gICAgICAgIGlmKG5leHRJZHggPj0gc3RhY2tzLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0SWR4ID0gKG5leHRJZHggJSBzdGFja3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvU3RhY2tCeUlkKGFuSWQpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzLmZpbmQoc3RhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmlkID09IGFuSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZighbmV4dFN0YWNrKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIGlkOiAke2FuSWR9IGNhbnQgYmUgZm91bmQgb24gdGhpcyBzdGFja2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG5leHRTdGFjay5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50U3RhY2tJZCAhPSBuZXh0U3RhY2suaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VTdGFja1RvKGN1cnJlbnRTdGFjayk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuU3RhY2tUbyhuZXh0U3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZTdGFjaygpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihzdGFja3MubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrSWQgPSB0aGlzLmN1cnJlbnRTdGFja0lkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IHN0YWNrcy5pbmRleE9mKGN1cnJlbnRTdGFjayk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCAtIDE7XG4gICAgICAgIGlmKG5leHRJZHggPCAwKXtcbiAgICAgICAgICAgIG5leHRJZHggPSBzdGFja3MubGVuZ3RoICsgbmV4dElkeDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvTnRoU3RhY2soYW5JbmRleCl7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSB1c2luZyAxLWluZGV4ZWQgdmFsdWVzXG4gICAgICAgIC8vIHBlciB0aGUgU2ltcGxlVGFsayBzeXN0ZW1cbiAgICAgICAgbGV0IHRydWVJbmRleCA9IGFuSW5kZXggLSAxO1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZih0cnVlSW5kZXggPCAwIHx8IHRydWVJbmRleCA+IHN0YWNrcy5sZW5ndGggLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbmF2aWdhdGUgdG8gc3RhY2sgbnVtYmVyICR7YW5JbmRleH0gLS0gb3V0IG9mIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgbGV0IG5leHRTdGFjayA9IHN0YWNrc1t0cnVlSW5kZXhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kQ2xvc2VTdGFja1RvKGFTdGFjayl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbG9zZVN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIGFTdGFjayk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IGFTdGFjay5jdXJyZW50Q2FyZDtcbiAgICAgICAgaWYoY3VycmVudENhcmQpe1xuICAgICAgICAgICAgYVN0YWNrLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbG9zZUNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgYVN0YWNrLmN1cnJlbnRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbmRPcGVuU3RhY2tUbyhhU3RhY2spe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIGFTdGFjayk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IGFTdGFjay5jdXJyZW50Q2FyZDtcbiAgICAgICAgaWYoY3VycmVudENhcmQpe1xuICAgICAgICAgICAgYVN0YWNrLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsIFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlbkNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgYVN0YWNrLmN1cnJlbnRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnd29ybGQnO1xuICAgIH1cblxuICAgIGdldCBsb2FkZWRTdGFja3MoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBub3JtYWwgUGFydCBzZXJpYWxpemF0aW9uLlxuICAgIC8vIEhlcmUgd2UgbmVlZCB0byBhbHNvIGluY2x1ZGUgYW4gYXJyYXkgb2YgaWRzIG9mXG4gICAgLy8gbG9hZGVkIHN0YWNrcyBhbmQgdGhlIGlkIG9mIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgc2VyaWFsaXplKCl7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgc3VicGFydHM6IHRoaXMuc3VicGFydHMubWFwKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LmlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvd25lcklkOiBudWxsLFxuICAgICAgICAgICAgbG9hZGVkU3RhY2tzOiAodGhpcy5sb2FkZWRTdGFja3MubWFwKHN0YWNrID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2suaWQ7XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGN1cnJlbnQgcGFydCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHZhbHVlc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLl9wcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AuZ2V0VmFsdWUodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBmb3IgZGVsZWdhdGlvbi5cbiAgICAvLyBXZSBzZW5kIGFueSBtZXNzYWdlcyB0aGF0IHNob3VsZCBiZSBkZWxlZ2F0ZWRcbiAgICAvLyB0byB0aGUgZ2xvYmFsIFN5c3RlbSBvYmplY3QsIHdoaWNoIGhhcyBhbnlcbiAgICAvLyAnaGFuZGxlcnMgb2YgbGFzdCByZXNvcnQnXG4gICAgZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHdpbmRvdy5TeXN0ZW0pO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50U3RhY2tJZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50J1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50U3RhY2soKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RoaXMuY3VycmVudFN0YWNrSWRdO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHRoZSBiYXNlIGNsYXNzIG1ldGhvZHNcbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgaWYoIXRoaXMuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gZG9lcyBub3QgYWNjZXB0IHN1YnBhcnRzIG9mIHR5cGUgJHthUGFydC50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYoZm91bmQgPCAwKXtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJ0IGlzIGEgc3RhY2sgdGhlbiBhcHBlbmQgYWZ0ZXIgdGhlIGxhc3Qgc3RhY2tcbiAgICAgICAgICAgIGlmKGFQYXJ0LnR5cGUgPT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgICAgICBsZXQgYWxsU3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UoYWxsU3RhY2tzLmxlbmd0aCwgMCwgYVBhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVBhcnQuX293bmVyID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwic3RhY2tcIil7XG4gICAgICAgICAgICBsZXQgYWxsU3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwic3RhY2tcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsU3RhY2tzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbGFzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0xhc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBsYXN0VmFsaWRQYXJ0SW5kZXggPSB0aGlzLnN1YnBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKHBhcnQudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RWYWxpZFBhcnRJbmRleCA9IGFsbFN0YWNrcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IGxhc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBsYXN0VmFsaWRQYXJ0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRVcChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGZpcnN0VmFsaWRQYXJ0SW5kZXggPSAwO1xuICAgICAgICBpZihwYXJ0LnR5cGUgIT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBhbGxTdGFja3MgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJzdGFja1wiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaXJzdFZhbGlkUGFydEluZGV4ID0gYWxsU3RhY2tzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPiBmaXJzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0ZpcnN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgZmlyc3RWYWxpZFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmKHBhcnQudHlwZSAhPSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0VmFsaWRQYXJ0SW5kZXggPSBhbGxTdGFja3MubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA+IGZpcnN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgZmlyc3RWYWxpZFBhcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmV4cG9ydCB7XG4gICAgV29ybGRTdGFjayxcbiAgICBXb3JsZFN0YWNrIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgY3NzU3R5bGVyIGZyb20gJy4uL3V0aWxzLy9zdHlsZXIuanMnO1xuXG4vKipcbiAqIFBhcnRQcm9wZXJ0aWVzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmFzZVxuICogUGFydCBQcm9wZXJ0aWVzIGZvciBhbGwgUGFydHMuXG4gKiBJIGFsc28gaW5jbHVkZSBzb21lIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIG9uIG15IHByb3RvdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5XG4gKiBvdGhlciBQYXJ0cyB3aGVuIHRoZXkgaW5oZXJpdCBmcm9tIG1lLlxuICogRm9yIG5vdywgd2UgdXNlIE9iamVjdC5jcmVhdGUoKSBmb3IgaW5oZXJpdGFuY2UuXG4gKi9cblxuY2xhc3MgQmFzaWNQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seT1mYWxzZSwgYWxpYXNlcz1bXSl7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgIHRoaXMuYWxpYXNlcyA9IGFsaWFzZXM7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5nZXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhc0FsaWFzID0gdGhpcy5oYXNBbGlhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSB0aGlzLm1hdGNoZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzTmFtZU9yQWxpYXMgPSB0aGlzLm1hdGNoZXNOYW1lT3JBbGlhcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBiYXNpYyBwcm9wZXJ0aWVzLCB3ZSByZXR1cm5cbiAgICAvLyB0aGUgc2V0L3N0b3JlZCB2YWx1ZVxuICAgIGdldFZhbHVlKG93bmVyKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8vIEZvciB0aGUgYmFzaWMgcHJvcGVydGllcywgd2Ugc2V0XG4gICAgLy8gYmFzZWQgb24gdGhlIGluY29taW5nIGRlc2lyZWQgdmFsdWVcbiAgICAvLyBhbG9uZSAobm90aGluZyBpcyBjb21wdXRlZClcbiAgICBzZXRWYWx1ZShvd25lciwgdmFsLCBub3RpZnk9dHJ1ZSl7XG4gICAgICAgIGlmKCF0aGlzLnJlYWRPbmx5KXtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICAgICAgaWYobm90aWZ5KXtcbiAgICAgICAgICAgICAgICBvd25lci5wcm9wZXJ0eUNoYW5nZWQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHByb3BlcnR5XG4gICAgLy8gZ29lcyBieSB0aGUgZ2l2ZW4gYWxpYXNcbiAgICBoYXNBbGlhcyhhbkFsaWFzKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpYXNlcy5pbmNsdWRlcyhhbkFsaWFzKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG5hbWUgaXNcbiAgICAvLyBlaXRoZXIgYW4gYWxpYXMgb3IgdGhlIGV4YWN0IG5hbWVcbiAgICAvLyBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgIG1hdGNoZXNOYW1lT3JBbGlhcyhhTmFtZU9yQWxpYXMpe1xuICAgICAgICBpZih0aGlzLmhhc0FsaWFzKGFOYW1lT3JBbGlhcykpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZihhTmFtZU9yQWxpYXMgPT0gdGhpcy5uYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGluY29taW5nIFByb3BlcnR5XG4gICAgLy8gaGFzIHRoZSBzYW1lIG5hbWUgYW5kL29yIG9uZSBvZiB0aGUgc2FtZVxuICAgIC8vIGFsaWFzZXMgYXMgdGhpcyBQcm9wZXJ0eVxuICAgIG1hdGNoZXMoYVByb3BlcnR5KXtcbiAgICAgICAgaWYoYVByb3BlcnR5Lm5hbWUgPT0gdGhpcy5uYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYWxpYXNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgbGV0IG15QWxpYXMgPSB0aGlzLmFsaWFzZXNbaV07XG4gICAgICAgICAgICAgICAgaWYoYVByb3BlcnR5Lmhhc0FsaWFzKG15QWxpYXMpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5cbi8qKiBDdXN0b20gUHJvcGVydGllcyBhcmUgc2ltaWxhciB0byBkeW5hbWljIHByb3BzLCBleGNlcHQgdGhhdFxuICAqIHVuZGVyIHRoZSBob29kIHRoZXkgc3RvcmUgYW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgKiBzdG9yaW5nIHByb3BzIGRlZmluZWQgd2l0aGluIHRoZSBTVCBlbnZpcm9ubWVudC4gVGhlIGZpbmQoKVxuICAqIGFkZCgpIGRlbGV0ZSgpIG1ldGhvZHMgZmluZCwgYWRkLCBvciByZW1vdmUgcHJvcGVydGllcyBmcm9tIHRoZVxuICAqIHRoaXMuY3VzdG9tUHJvcGVydGllcyBvYmplY3QuXG4gKiovXG5jbGFzcyBDdXN0b21Qcm9wZXJ0eSBleHRlbmRzIEJhc2ljUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWU9XCJjdXN0b20tcHJvcGVydGllc1wiLCBkZWZhdWx0VmFsdWU9e30sIHJlYWRPbmx5PWZhbHNlLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seT1mYWxzZSwgYWxpYXNlcyk7XG4gICAgfVxuXG4gICAgZmluZChuYW1lKXtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl92YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYocHJvcCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhZGQoYVByb3BlcnR5KXtcbiAgICAgICAgLy8gTk9URTogYWxpYXNlcyBhcmUgY29tcGxldGVkIGlnbm9yZWQgZm9yIG5vd1xuICAgICAgICBpZighdGhpcy5maW5kKGFQcm9wZXJ0eS5uYW1lKSl7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZVthUHJvcGVydHkubmFtZV0gPSBhUHJvcGVydHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUoYVByb3BlcnR5KXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ZhbHVlW2FQcm9wZXJ0eS5uYW1lXTtcbiAgICB9XG5cblxuXG59O1xuXG5jbGFzcyBEeW5hbWljUHJvcGVydHkgZXh0ZW5kcyBCYXNpY1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzZXR0ZXIsIGdldHRlciwgcmVhZE9ubHk9ZmFsc2UsIGRlZmF1bHRWYWx1ZT1udWxsLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seSwgYWxpYXNlcyk7XG4gICAgICAgIHRoaXMudmFsdWVTZXR0ZXIgPSBzZXR0ZXI7XG4gICAgICAgIHRoaXMudmFsdWVHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhpcyBvdmVycmlkZSwgd2UgdXNlIHRoZSBnZXR0ZXJcbiAgICAvLyBpZiBhdmFpbGFibGUsIHRvIGR5bmFtaWNhbGx5IGdldCB0aGVcbiAgICAvLyBpbmNvbWluZyB2YWx1ZS5cbiAgICBnZXRWYWx1ZShvd25lcil7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlR2V0dGVyKG93bmVyLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBJbiB0aGlzIG92ZXJyaWRlLCB3ZSB1c2UgdGhlIHNldHRlclxuICAgIC8vIGlmIGF2YWlsYWJsZSwgdG8gZHluYW1pY2FsbHkgc2V0IHRoZVxuICAgIC8vIGluY29taW5nIHZhbHVlXG4gICAgc2V0VmFsdWUob3duZXIsIHZhbCwgbm90aWZ5PXRydWUpe1xuICAgICAgICBpZighdGhpcy5yZWFkT25seSl7XG4gICAgICAgICAgICB0aGlzLnZhbHVlU2V0dGVyKG93bmVyLCB0aGlzLCB2YWwsIG5vdGlmeSk7XG4gICAgICAgICAgICBpZihub3RpZnkpe1xuICAgICAgICAgICAgICAgIG93bmVyLnByb3BlcnR5Q2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKiogSSBhbSBhIHNwZWNpYWwgcHJvcGVydHkgd2hpY2ggaGFuZGxlcyBpbnRlcmZhY2luZyB3aXRoIHRoZVxuICAqIHRoZSBjc3NTdHlsZSBiYXNpYyBwcm9wZXJ0eS4gV2hlbmV2ZXIgSSBhbSB1cGRhdGVkIEkgbWFrZVxuICAqIHN1cmUgdG8gdXBkYXRlIHRoZSBjc3NTdHlsZSBwcm9wZXJ0eSB2aWEgdGhlIHN0eWxlciB1dGlsaXR5XG4gICogZnVuY3Rpb24uIEkgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGRpZmZlcmVudCBhbmQgaW5kZXBlbnRcbiAgKiBzdHlsaW5nIG9wdGlvbnMuXG4gICoqL1xuY2xhc3MgU3R5bGVQcm9wZXJ0eSBleHRlbmRzIEJhc2ljUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlZmF1bHRWYWx1ZSwgIHByb3BOYW1lPSdjc3NTdHlsZScsIHN0eWxlcj1jc3NTdHlsZXIsIHJlYWRPbmx5PWZhbHNlLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seSwgYWxpYXNlcyk7XG4gICAgICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICAgICAgdGhpcy5zdHlsZXIgPSBzdHlsZXI7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhpcyBvdmVycmlkZSwgd2UgdXBkYXRlIHRoZSBjc3NTdHlsZSBwcm9wZXJ0eVxuICAgIHNldFZhbHVlKG93bmVyLCB2YWwsIG5vdGlmeT10cnVlKXtcbiAgICAgICAgaWYoIXRoaXMucmVhZE9ubHkpe1xuICAgICAgICAgICAgbGV0IHN0eWxlUHJvcGVydHkgPSBvd25lci5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCh0aGlzLnByb3BOYW1lKTtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHN0eWxlUHJvcGVydHkuZ2V0VmFsdWUob3duZXIpO1xuICAgICAgICAgICAgbGV0IG5ld1N0eWxlID0gdGhpcy5zdHlsZXIoc3R5bGUsIHRoaXMubmFtZSwgdmFsKTtcbiAgICAgICAgICAgIHN0eWxlUHJvcGVydHkuc2V0VmFsdWUob3duZXIsIG5ld1N0eWxlLCBub3RpZnkpO1xuXG4gICAgICAgICAgICAvLyBzZXQgbXkgdmFsdWUgYXMgd2VsbFxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICBpZihub3RpZnkpe1xuICAgICAgICAgICAgICAgIG93bmVyLnByb3BlcnR5Q2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY2xhc3MgUGFydFByb3BlcnRpZXMge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuaGFzUHJvcGVydHkgPSB0aGlzLmhhc1Byb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkgPSB0aGlzLmFkZFByb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlUHJvcGVydHkgPSB0aGlzLnJlbW92ZVByb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmluZFByb3BlcnR5TmFtZWQgPSB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHlOYW1lZCA9IHRoaXMuc2V0UHJvcGVydHlOYW1lZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFByb3BlcnR5TmFtZWQgPSB0aGlzLmdldFByb3BlcnR5TmFtZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXdCYXNpY1Byb3AgPSB0aGlzLm5ld0Jhc2ljUHJvcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5ld1N0eWxlUHJvcCA9IHRoaXMubmV3U3R5bGVQcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubmV3RHluYW1pY1Byb3AgPSB0aGlzLm5ld0R5bmFtaWNQcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2luZGV4T2ZQcm9wZXJ0eSA9IHRoaXMuX2luZGV4T2ZQcm9wZXJ0eS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCBhbGwoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjb2xsZWN0aW9uICdoYXMnIGEgcHJvcGVydHkgaWYgaXQgY29udGFpbnNcbiAgICAvLyBhIFByb3BlcnR5IG9iamVjdCB3aXRoIG1hdGNoaW5nIG5hbWUgb3IgYWxpYXNcbiAgICAvLyBvZiB0aGUgaW5jb21pbmcgcHJvcGVydHkuXG4gICAgaGFzUHJvcGVydHkoYVByb3BlcnR5KXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYoYVByb3BlcnR5Lm1hdGNoZXMocHJvcCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIG9uZSBvZiBteSBQcm9wZXJ0aWVzIGJ5XG4gICAgLy8gYSBuYW1lIG9yIGFsaWFzLiBSZXR1cm5zIG51bGxcbiAgICAvLyBpZiBubyBtYXRjaCBmb3VuZC4gUGVyaGFwcyB3ZSBzaG91bGRcbiAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgIGZpbmRQcm9wZXJ0eU5hbWVkKGFOYW1lKXtcbiAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgbGV0IGN1c3RvbVByb3BlcnRpZXNQcm9wO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fcHJvcGVydGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuX3Byb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBpZihwcm9wLm1hdGNoZXNOYW1lT3JBbGlhcyhhTmFtZSkpe1xuICAgICAgICAgICAgICAgIGZvdW5kID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIGN1c3RvbSBwcm9wZXJ0aWVzIHByb3AsIGFzIHdlIG1pZ2h0IG5lZWQgaXRcbiAgICAgICAgICAgIC8vIGZvciBsYXRlclxuICAgICAgICAgICAgaWYocHJvcC5tYXRjaGVzTmFtZU9yQWxpYXMoXCJjdXN0b20tcHJvcGVydGllc1wiKSl7XG4gICAgICAgICAgICAgICAgY3VzdG9tUHJvcGVydGllc1Byb3AgPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiB0aGUgcHJvcGVydHkgaXMgY3VzdG9tXG4gICAgICAgIGlmKCFmb3VuZCAmJiBjdXN0b21Qcm9wZXJ0aWVzUHJvcCl7XG4gICAgICAgICAgICBmb3VuZCA9IGN1c3RvbVByb3BlcnRpZXNQcm9wLmZpbmQoYU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0cyB0byBnZXQgdGhlICp2YWx1ZSogb2YgdGhlIHByb3BlcnR5XG4gICAgLy8gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciBhbGlhcy5cbiAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB3ZSB0aHJvdyBhblxuICAgIC8vIGVycm9yXG4gICAgZ2V0UHJvcGVydHlOYW1lZChvd25lciwgYU5hbWUpe1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkKGFOYW1lKTtcbiAgICAgICAgaWYoIWZvdW5kKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvd25lcn0gZG9lcyBub3QgaGF2ZSBwcm9wZXJ0eSBcIiR7YU5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQuZ2V0VmFsdWUob3duZXIpO1xuICAgIH1cblxuICAgIC8vIEF0dGVtcHRzIHRvIHNldCB0aGUgKnZhbHVlKiBvZiB0aGUgcHJvcGVydHlcbiAgICAvLyB3aXRoIHRoZSBnaXZlbiBuYW1lIG9yIGFsaWFzLlxuICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHdlIHRocm93IGFuXG4gICAgLy8gZXJyb3JcbiAgICBzZXRQcm9wZXJ0eU5hbWVkKG93bmVyLCBhTmFtZSwgYVZhbHVlLCBub3RpZnk9dHJ1ZSl7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZmluZFByb3BlcnR5TmFtZWQoYU5hbWUpO1xuICAgICAgICBpZighZm91bmQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke293bmVyfSBkb2VzIG5vdCBoYXZlIHByb3BlcnR5IFwiJHthTmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZC5zZXRWYWx1ZShvd25lciwgYVZhbHVlLCBub3RpZnkpO1xuICAgIH1cblxuICAgIC8vIElmIHlvdSBhZGQgYSBwcm9wZXJ0eSB3aXRoIGEgbmFtZSBvciBhbGlhc1xuICAgIC8vIHRoYXQgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBjb2xsZWN0aW9uLFxuICAgIC8vIHRoZW4gd2UgJ292ZXJ3cml0ZScgaXQgYnkgcmVtb3ZpbmcgdGhlIGV4aXNpbmdcbiAgICAvLyBwcm9wZXJ0eSBhbmQgcmVwbGFjaW5nIGl0IHdpdGggdGhlIGluY29taW5nIG9uZS5cbiAgICAvLyBPdGhlcndpc2UsIHdlIGp1c3QgYWRkIHRoZSBwcm9wZXJ0eVxuICAgIGFkZFByb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGlmKHRoaXMuaGFzUHJvcGVydHkoYVByb3BlcnR5KSl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5KGFQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvcGVydGllcy5wdXNoKGFQcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZpbmcgYSBwcm9wZXJ0eSBoZXJlIG1lYW5zIHJlbW92aW5nXG4gICAgLy8gaXQgZnJvbSB0aGUgc3RvcmVkIGFycmF5LiBJZiB0aGUgcHJvcGVydHlcbiAgICAvLyBpcyBub3QgaW4gdGhlIGFycmF5LCB3ZSBkbyBOT1QgdGhyb3cgYW4gZXJyb3IuXG4gICAgLy8gV2UganVzdCBnbyBvbiB3aXRoIG91ciBsaXZlcywgYmVjYXVzZSB3aG8gY2FyZXM/XG4gICAgcmVtb3ZlUHJvcGVydHkoYVByb3BlcnR5KXtcbiAgICAgICAgbGV0IHByb3BJbmRleCA9IHRoaXMuX2luZGV4T2ZQcm9wZXJ0eShhUHJvcGVydHkpO1xuICAgICAgICBpZihwcm9wSW5kZXggPj0gMCl7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnNwbGljZShwcm9wSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBiYXNpY1xuICAgIC8vIHByb3BlcnR5LlxuICAgIG5ld0Jhc2ljUHJvcCguLi5hcmdzKXtcbiAgICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgQmFzaWNQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShuZXdQcm9wKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IGN1c3RvbVxuICAgIC8vIHByb3BlcnR5LlxuICAgIG5ld0N1c3RvbVByb3AoLi4uYXJncyl7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IEN1c3RvbVByb3BlcnR5KC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KG5ld1Byb3ApO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXcgc3R5bGVcbiAgICAvLyBwcm9wZXJ0eS5cbiAgICBuZXdTdHlsZVByb3AoLi4uYXJncyl7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IFN0eWxlUHJvcGVydHkoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ld1xuICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgIG5ld0R5bmFtaWNQcm9wKC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbmV3UHJvcCA9IG5ldyBEeW5hbWljUHJvcGVydHkoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QuIEZpbmRzIHRoZSBmaXJzdCBvY2N1cnJpbmdcbiAgICAvLyBpbmRleCBvZiB0aGUgZ2l2ZW4gUHJvcGVydHkgaW4gdGhlIGFycmF5XG4gICAgLy8gb2YgcHJvcGVydGllcyBpbiB0aGlzIGNvbGxlY3Rpb24uIFJldHVybnNcbiAgICAvLyAtMSBpZiBub3QgZm91bmQsIHBlciBKUyBpbXBsZW1lbnRhdGlvbi5cbiAgICBfaW5kZXhPZlByb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYoYVByb3BlcnR5Lm1hdGNoZXMocHJvcCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnRQcm9wZXJ0aWVzLFxuICAgIEJhc2ljUHJvcGVydHksXG4gICAgQ3VzdG9tUHJvcGVydHksXG4gICAgRHluYW1pY1Byb3BlcnR5LFxuICAgIFBhcnRQcm9wZXJ0aWVzIGFzIGRlZmF1bHRcbn07XG4iLCIvKiogU2Vjb25kIHBhc3MgYXQgc3ludGF4IGhpZ2hsaWdodGVyIHNlbWFudGljcyAqKi9cbmNvbnN0IHN5bnRheFNwYW4gPSAocnVsZU5hbWUpID0+IHtcbiAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3N0LXN5bnRheCcpO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKCdkYXRhLXN0LXJ1bGUnLCBydWxlTmFtZSk7XG4gICAgcmV0dXJuIHNwYW47XG59XG5cbmNvbnN0IGNyZWF0ZUhpZ2hsaWdodGVyID0gKGZpZWxkRWxlbWVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIE1lc3NhZ2VIYW5kbGVyT3BlbjogZnVuY3Rpb24obGl0ZXJhbE9uLCBtZXNzYWdlTmFtZSwgb3B0aW9uYWxQYXJhbUxpc3Qpe1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBzeW50YXhTcGFuKFwiTWVzc2FnZUhhbmRsZXJPcGVuXCIpO1xuICAgICAgICAgICAgbGV0IG9uU3BhbiA9IHN5bnRheFNwYW4oXCJrZXl3b3JkXCIpO1xuICAgICAgICAgICAgb25TcGFuLmFwcGVuZChcIm9uIFwiKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKG9uU3Bhbik7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCBzdWItcnVsZXNcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKG1lc3NhZ2VOYW1lLmhpZ2hsaWdodFN5bnRheCgpKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKC4uLm9wdGlvbmFsUGFyYW1MaXN0LmhpZ2hsaWdodFN5bnRheCgpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWVzc2FnZUhhbmRsZXJDbG9zZShsaXRlcmFsRW5kLCBtZXNzYWdlTmFtZSl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IHN5bnRheFNwYW4oXCJNZXNzYWdlSGFuZGxlckNsb3NlXCIpO1xuICAgICAgICAgICAgbGV0IGVuZFNwYW4gPSBzeW50YXhTcGFuKFwia2V5d29yZFwiKTtcbiAgICAgICAgICAgIGVuZFNwYW4uYXBwZW5kKFwiZW5kIFwiKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKGVuZFNwYW4pO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBhcnRzXG4gICAgICAgICAgICBzcGFuLmFwcGVuZChtZXNzYWdlTmFtZS5oaWdobGlnaHRTeW50YXgoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9LFxuXG4gICAgICAgIFBhcmFtZXRlckxpc3Q6IGZ1bmN0aW9uKHBhcmFtU3RyaW5nKXtcbiAgICAgICAgICAgIGxldCBvdXRlciA9IHN5bnRheFNwYW4oXCJQYXJhbWV0ZXJMaXN0XCIpO1xuICAgICAgICAgICAgbGV0IGlubmVySXRlbXMgPSBwYXJhbVN0cmluZy5hc0l0ZXJhdGlvbigpLmNoaWxkcmVuLm1hcChwYXJhbU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzcGFuID0gc3ludGF4U3BhbihcIlBhcmFtZXRlckxpc3QtaXRlbVwiKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZChwYXJhbU5hbWUuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Bhbi5vdXRlckhUTUw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dGVyLmlubmVySFRNTCA9IGlubmVySXRlbXMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG91dGVyO1xuICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZU5hbWU6IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZCgnc3Qtc3ludGF4Jyk7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnZGF0YS1zdC1ydWxlJywgJ21lc3NhZ2VOYW1lJyk7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZChzdHJpbmcuc291cmNlU3RyaW5nICsgXCIgXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5d29yZDogZnVuY3Rpb24oc3RyaW5nKXtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdzdC1zeW50YXgnKTtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKCdkYXRhLXN0LXJ1bGUnLCAna2V5d29yZCcpO1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmQoc3RyaW5nLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnQge1xuICAgIGNyZWF0ZUhpZ2hsaWdodGVyLFxuICAgIGNyZWF0ZUhpZ2hsaWdodGVyIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFV0aWxpdGllcyBmb3IgQ2xpcGJvYXJkIEZ1bmN0aW9uYWxpdHlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRm9yIHRoZSBtb21lbnQgd2UgdXNlIGEgdmVyeSBwcmltaXRpdmUgc3RhbmQtaW5cbiAqIHNpbmNlIHRoZSBDbGlwYm9hcmQgQVBJIGlzIG5vdCBzdGFuZGFyZGl6ZWQgYWNyb3NzXG4gKiBicm93c2VyIGltcGxlbWVudGF0aW9ucy5cbiAqKi9cbmltcG9ydCBpZE1ha2VyIGZyb20gJy4vaWQuanMnO1xuaW1wb3J0IHtTVERlc2VyaWFsaXplciwgU1RTZXJpYWxpemVyfSBmcm9tICcuL3NlcmlhbGl6YXRpb24uanMnO1xuXG5jbGFzcyBTVENsaXBib2FyZCB7XG4gICAgY29uc3RydWN0b3IoYVN5c3RlbSl7XG4gICAgICAgIHRoaXMuc3lzdGVtID0gYVN5c3RlbTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IFtdO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5jb3B5UGFydCA9IHRoaXMuY29weVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXN0ZUNvbnRlbnRzSW50byA9IHRoaXMucGFzdGVDb250ZW50c0ludG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlTGVuc2VkQ2hpbGRyZW4gPSB0aGlzLl9jcmVhdGVMZW5zZWRDaGlsZHJlbi5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvcHlQYXJ0KGFQYXJ0KXtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZXIgPSBuZXcgU1RTZXJpYWxpemVyKHRoaXMuc3lzdGVtKTtcbiAgICAgICAgbGV0IHJvb3RTZXJpYWxpemF0aW9uID0gc2VyaWFsaXplci5zZXJpYWxpemUoYVBhcnQsIGZhbHNlKTtcbiAgICAgICAgbGV0IGl0ZW0gPSBuZXcgU1RDbGlwYm9hcmRJdGVtKFxuICAgICAgICAgICAgJ3NpbXBsZXRhbGsvanNvbicsXG4gICAgICAgICAgICByb290U2VyaWFsaXphdGlvbixcbiAgICAgICAgICAgIGFQYXJ0LnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IFtpdGVtXTtcbiAgICB9XG5cbiAgICBwYXN0ZUNvbnRlbnRzSW50byhhVGFyZ2V0UGFydCl7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IHRoaXMuY29udGVudHMubWFwKGNsaXBib2FyZENvbnRlbnQgPT4ge1xuICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudC5kYXRhO1xuICAgICAgICAgICAgbGV0IGRlc2VyaWFsaXplciA9IG5ldyBTVERlc2VyaWFsaXplcih0aGlzLnN5c3RlbSk7XG4gICAgICAgICAgICBkZXNlcmlhbGl6ZXIudGFyZ2V0SWQgPSBhVGFyZ2V0UGFydC5pZDtcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENvbnRlbnQpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdG9wIGFuZCBsZWZ0IHZhbHVlcyB0byB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXN0ZWQgcGFydCBkb2Vzbid0IHJ1biBvdXRzaWRlIG9mIHRoZSBuZXdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRpdmUgYm91bmRzIGluIHdoaWNoIGl0IGhhcyBiZWVuIHBhc3RlZFxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGFydCA9IGRlc2VyaWFsaXplci5yb290UGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNUb3AgPSBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCd0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0xlZnQgPSBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1RvcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihoYXNMZWZ0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcnQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiBIYWxvIG9uIHRoZSBuZXcgdmlld1xuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZXIucm9vdFZpZXdzWzBdLm9wZW5IYWxvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIEN1c3RvbUV2ZW50IHRoYXQgbm90aWZpZXMgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYSBuZXcgdmlldyB3YXMgYWRkZWQgKHVzZWQgYnkgTmF2IGV0YylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzdC12aWV3LWFkZGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydFR5cGU6IG5ld1BhcnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IG5ld1BhcnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJZDogbmV3UGFydC5fb3duZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplci5yb290Vmlld3NbMF0uZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFueSBsZW5zZWQgdmlld3MgdGhhdCBtaWdodCBiZSBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvb3RMZW5zVmlld3MgPSB0aGlzLnN5c3RlbS5maW5kTGVuc1ZpZXdzQnlJZChuZXdQYXJ0Ll9vd25lci5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RMZW5zVmlld3MuZm9yRWFjaChsZW5zVmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TGVuc1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQobmV3UGFydC50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldE1vZGVsKG5ld1BhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIG5ld1BhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbnNWaWV3LmFwcGVuZENoaWxkKG5ld0xlbnNWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxlbnNlZENoaWxkcmVuKG5ld0xlbnNWaWV3LCBuZXdQYXJ0LnN1YnBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlTGVuc2VkQ2hpbGRyZW4oYUxlbnNWaWV3LCBzdWJwYXJ0cyl7XG4gICAgICAgIHN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3TGVuc1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIHRoaXMuc3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQoc3VicGFydC50eXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldE1vZGVsKHN1YnBhcnQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIHN1YnBhcnQuaWQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgIGFMZW5zVmlldy5hcHBlbmRDaGlsZChuZXdMZW5zVmlldyk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVMZW5zZWRDaGlsZHJlbihuZXdMZW5zVmlldywgc3VicGFydC5zdWJwYXJ0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBnZXQgaXNFbXB0eSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGggPD0gMDtcbiAgICB9XG59XG5cbmNsYXNzIFNUQ2xpcGJvYXJkSXRlbSB7XG4gICAgY29uc3RydWN0b3IobWltZVR5cGUsIGRhdGEsIHBhcnRUeXBlKXtcbiAgICAgICAgaWYobWltZVR5cGUpe1xuICAgICAgICAgICAgdGhpcy50eXBlID0gbWltZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFydFR5cGUpe1xuICAgICAgICAgICAgdGhpcy5fcGFydFR5cGUgPSBwYXJ0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGFydFR5cGUoKXtcbiAgICAgICAgaWYodGhpcy50eXBlID09ICdzaW1wbGV0YWxrL2pzb24nKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXQgcGFydFR5cGUodmFsKXtcbiAgICAgICAgdGhpcy5fcGFydFR5cGUgPSB2YWw7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTVENsaXBib2FyZCxcbiAgICBTVENsaXBib2FyZCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBFcnJvciBIYW5kbGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gcmVzcG9uc2libGUgZm9yIGhhbmRsZXIgYWxsXG4gKiBTeXN0ZW0td2lkZSBlcnJvcnNcbiAqL1xuXG5jb25zdCBlcnJvckhhbmRsZXIgPSB7XG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLm5hbWUpe1xuICAgICAgICAgICAgY2FzZSAnR3JhbW1hck1hdGNoRXJyb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUdyYW1tYXJNYXRjaEVycm9yKGFNZXNzYWdlKTtcbiAgICAgICAgICAgIGNhc2UgJ01lc3NhZ2VOb3RVbmRlcnN0b29kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNZXNzYWdlTm90VW5kZXJzdG9vZChhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlmIEkgZG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggdGhpcyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgLy8gSSBzZW5kIGl0IGFsb25nIHRvIHRoZSBTeXN0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5yZWNlaXZlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlR3JhbW1hck1hdGNoRXJyb3I6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gVE9ETyBpcyB0aGVyZSBhIG1vcmUgc3RydWN0dXJlZCB3YXkgdG8gZ2V0IHRoaXMgb3V0IG9mIG9obT9cbiAgICAgICAgbGV0IHJlZ2V4ID0gL0xpbmUgKD88bGluZT5cXGQpLCBjb2wgKD88Y29sdW1uPlxcZCkvO1xuICAgICAgICBsZXQgbWF0Y2ggPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQubWVzc2FnZS5tYXRjaChyZWdleCk7XG4gICAgICAgIGxldCBlcnJvckxpbmVOdW0gPSBwYXJzZUludChtYXRjaC5ncm91cHNbXCJsaW5lXCJdKSAtIDE7IC8vIG9obSBsaW5lcyBzdGFydCB3aXRoIDEgXG4gICAgICAgIC8vIHNlZSBpZiB0aGUgZ3JhbW1hciBydWxlIGhhcyBiZWVuIGlkZW50aWZpZWRcbiAgICAgICAgbGV0IHJ1bGVOYW1lO1xuICAgICAgICBsZXQgcmlnaHRNb3N0RmFpbHVyZXMgPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQuZ2V0UmlnaHRtb3N0RmFpbHVyZXMoKTtcbiAgICAgICAgaWYocmlnaHRNb3N0RmFpbHVyZXNbMV0pe1xuICAgICAgICAgICAgcnVsZU5hbWUgPSByaWdodE1vc3RGYWlsdXJlc1sxXS5wZXhwci5ydWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgc29tZSBtb3JlIGluZm8gYWJvdXQgd2hhdCB0aGUgcGFyc2VyIGV4cGVjdGVkXG4gICAgICAgIGxldCBleHBlY3RlZFRleHQgPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQuZ2V0RXhwZWN0ZWRUZXh0KCk7XG4gICAgICAgIC8vIGdldCB0aGUgb3JpZ2luYWwgc2NyaXB0XG4gICAgICAgIGxldCB0ZXh0ID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmlucHV0O1xuICAgICAgICBsZXQgdGV4dExpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgLy8gcmVwbGFjZSBzYWlkIHRleHQgbGluZSB3aXRoIGFuIGVycm9yIG1hcmtlclxuICAgICAgICB0ZXh0TGluZXNbZXJyb3JMaW5lTnVtXSArPSBgIC0tPDw8W0V4cGVjdGVkOiR7ZXhwZWN0ZWRUZXh0fTsgcnVsZU5hbWU6IFwiJHtydWxlTmFtZX1cIl1gO1xuICAgICAgICB0ZXh0ID0gdGV4dExpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBwYXJzZWQgc2NyaXB0IGlzIFwiZG9JdFwiIHRoZW4gdGhlIHN0YXRlbWVudExpbmVzIGFyZVxuICAgICAgICAvLyBsb2NhdGVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHRleHQsIG5vdCB0aGUgc2NyaXB0LCBwcm9wZXJ0eSBhbmRcbiAgICAgICAgLy8gd2Ugd2FudCB0aGUgZXJyb3IgdG8gYmUgbWFya2VkIHVwIGluIHRoZSBmaWVsZCB0ZXh0YXJlYVxuICAgICAgICBpZihhTWVzc2FnZS5wYXJzZWRTY3JpcHQuaW5wdXQuc3RhcnRzV2l0aChcIm9uIGRvSXRcIikpe1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyTW9kZWwgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFthTWVzc2FnZS5wYXJ0SWRdO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBnZXQgdGhlIG9yaWdpbmFsIHRleHQgc28gYXMgbm90IHRvIGNvbXBsZXRlbHkgcmVwbGFjZSBpdFxuICAgICAgICAgICAgLy8gdGhlbiBpbnNlcnQgdGhlIG1hcmt1cCBpbiB0aGUgYXBwcm9wcmlhdGUgbGluZVxuICAgICAgICAgICAgbGV0IGZpZWxkVGV4dCA9IG9yaWdpbmFsU2VuZGVyTW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvcmlnaW5hbFNlbmRlck1vZGVsLCBcInRleHRcIik7XG4gICAgICAgICAgICBsZXQgc2NyaXB0ID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmlucHV0O1xuICAgICAgICAgICAgc2NyaXB0ID0gdGhpcy5fY2xlYW5Eb0l0U0NyaXB0KHNjcmlwdCk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBcImRvSXRcIiBoYW5kbGVyIGluc2VydGVkIGJhY2sgaW4sIHNpbmNlIGl0J3MganVzdCBhIGhpZGRlbiB3cmFwcGVyIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHN0YXRlbWVudCBsaW5lc1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuX2NsZWFuRG9JdFNDcmlwdCh0ZXh0KTtcbiAgICAgICAgICAgIGZpZWxkVGV4dCA9IGZpZWxkVGV4dC5yZXBsYWNlKHNjcmlwdCwgdGV4dCk7XG4gICAgICAgICAgICBvcmlnaW5hbFNlbmRlck1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQob3JpZ2luYWxTZW5kZXJNb2RlbCwgXCJ0ZXh0XCIsIGZpZWxkVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBsb2NhdGUgdGhlIHNjcmlwdCBlZGl0b3IgaW4gcXVlc3Rpb25cbiAgICAgICAgICAgIGxldCBzY3JpcHRFZGl0b3IgPSB3aW5kb3cuU3lzdGVtLmZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkKGFNZXNzYWdlLnBhcnRJZCk7XG4gICAgICAgICAgICBpZighc2NyaXB0RWRpdG9yKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGVuU2NyaXB0RWRpdG9yKGFNZXNzYWdlLnBhcnRJZCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChhTWVzc2FnZS5wYXJ0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyaXB0RWRpdG9yLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2NyaXB0RWRpdG9yLm1vZGVsLCBcInRleHRcIiwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3BlbiB0aGUgZ3JhbW1hciBpZiB0aGVyZSBpcyBub3Qgb25lIG9wZW4gYWxyZWFkeVxuICAgICAgICBsZXQgY3VycmVudENhcmQgPSB3aW5kb3cuU3lzdGVtLmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICAgICAgbGV0IGdyYW1tYXIgPSBjdXJyZW50Q2FyZC5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocGFydC50eXBlID09IFwiZmllbGRcIikgJiYgKHBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChwYXJ0LCBcIm5hbWVcIikgPT0gXCJTaW1wbGVUYWxrXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoZ3JhbW1hci5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICB0aGlzLl9vcGVuR3JhbW1hcihhTWVzc2FnZS5wYXJ0SWQsIHJ1bGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVNZXNzYWdlTm90VW5kZXJzdG9vZChhTWVzc2FnZSl7XG4gICAgICAgIGxldCBvZmZlbmRpbmdNZXNzYWdlID0gYU1lc3NhZ2UubWVzc2FnZTtcbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gb2ZmZW5kaW5nTWVzc2FnZS5zZW5kZXJzWzBdO1xuICAgICAgICAvLyBBcmUgd2UgZXZlciBnb2luZyB0byBoYXZlIE1OVSBlcnJvcnMgb24gbWVzc2FnZXMgdGhhdFxuICAgICAgICAvLyBhcmUgbm90IHR5cGU6IGNvbW1hbmQ/XG4gICAgICAgIGlmKG9mZmVuZGluZ01lc3NhZ2UudHlwZSA9PT0gXCJjb21tYW5kXCIpe1xuICAgICAgICAgICAgbGV0IGNvbW1hbmROYW1lID0gb2ZmZW5kaW5nTWVzc2FnZS5jb21tYW5kTmFtZTtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFNlbmRlck1vZGVsID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbb3JpZ2luYWxTZW5kZXIuaWRdO1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXHMqJHtjb21tYW5kTmFtZX0oXFxzfFxcbnwkKWAsICdnJyk7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgICAgICBsZXQgZXhlY3V0aW9uU3RhY2sgPSB3aW5kb3cuU3lzdGVtLmV4ZWN1dGlvblN0YWNrLl9zdGFjaztcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBleGVjdXRpb24gc3RhY2sgaXMgXCJkb0l0XCIgdGhlbiB0aGUgc3RhdGVtZW50TGluZXMgYXJlXG4gICAgICAgICAgICAvLyBsb2NhdGVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHRleHQsIG5vdCB0aGUgc2NyaXB0LCBwcm9wZXJ0eSBhbmRcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdGhlIGVycm9yIHRvIGJlIG1hcmtlZCB1cCBpbiB0aGUgZmllbGQgdGV4dGFyZWFcbiAgICAgICAgICAgIGlmKGV4ZWN1dGlvblN0YWNrWzBdICYmIGV4ZWN1dGlvblN0YWNrWzBdLm1lc3NhZ2VOYW1lID09IFwiZG9JdFwiKXtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBleGVjdXRpb25TdGFja1swXS5wYXJ0O1xuICAgICAgICAgICAgICAgIHRleHQgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvcmlnaW5hbFNlbmRlck1vZGVsLCAndGV4dCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb3JpZ2luYWxTZW5kZXJNb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKG9yaWdpbmFsU2VuZGVyTW9kZWwsICdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICBsZXQgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChvcmlnaW5hbFNlbmRlci5pZCk7XG4gICAgICAgICAgICAgICAgaWYoIXNjcmlwdEVkaXRvcil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5TY3JpcHRFZGl0b3Iob3JpZ2luYWxTZW5kZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRFZGl0b3IgPSB3aW5kb3cuU3lzdGVtLmZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkKG9yaWdpbmFsU2VuZGVyLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoc2NyaXB0RWRpdG9yKXtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2NyaXB0RWRpdG9yLm1vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gU29ydCB0aGlzIG91dFxuICAgICAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dExpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBvZmZlbmRpbmcgY29tbWFuZCB0ZXh0IGxpbmUgd2l0aCBhbiBlcnJvciBtYXJrZXJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0TGluZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmKGxpbmUubWF0Y2gocmVnZXgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IGxpbmUgKz0gYCAtLTw8PFtNZXNzYWdlTm90VW5kZXJzdG9vZDogY29tbWFuZDsgY29tbWFuZE5hbWU6IFwiJHtjb21tYW5kTmFtZX1cIl1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0TGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwidGV4dFwiLCB0ZXh0KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmluYWxseSBvcGVuIHRoZSBkZWJ1Z2dlciAob3IgY3VycmVudCB2ZXJzaW9uIHRoZXJlb2YpXG4gICAgICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIGEgYml0IGRhbmdlcm91cywgYi9jIGlmIHRoZSBTeXN0ZW0gZG9lc24ndFxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBgb3BlbkRlYnVnZ2VyYCBjb21tYW5kIGFueXdoZXJlIGl0IHdpbGwgdGhyb3dcbiAgICAgICAgICAgIC8vIGEgTU5VIGVycm9yLCB3aGljaCB3aWxsIHRoZW4gaW52b2tlIHRoaXMgaGFuZGxlciBjdWFzaW5nXG4gICAgICAgICAgICAvLyBhbiBpbmZpbml0ZSBsb29wIVxuICAgICAgICAgICAgdGhpcy5fb3BlbkRlYnVnZ2VyKG9yaWdpbmFsU2VuZGVyLmlkLCBvZmZlbmRpbmdNZXNzYWdlLnR5cGUsIG9mZmVuZGluZ01lc3NhZ2UuY29tbWFuZE5hbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jbGVhbkRvSXRTQ3JpcHQoc2NyaXB0KXtcbiAgICAgICAgLy8gY2xlYW4gdXAgdGhlIERvSXQgc2NyaXB0IGJ5IHJlbW92aW5nIHRoZSBoYW5kbGVyXG4gICAgICAgIC8vIG5ld2xpbmVzLCB0YWJzIGFuZCBzcGFjZXNcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoXCJvbiBkb0l0XCIsIFwiXCIpO1xuICAgICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShcImVuZCBkb0l0XCIsIFwiXCIpO1xuICAgICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZSgvXltcXG5cXHQgXSsvLCBcIlwiKTtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoL1tcXG5cXHQgXSskLywgXCJcIik7XG4gICAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgfSxcblxuICAgIF9vcGVuU2NyaXB0RWRpdG9yOiBmdW5jdGlvbihwYXJ0SWQpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbcGFydElkXTtcbiAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgXCJjb21tYW5kTmFtZVwiOiBcIm9wZW5TY3JpcHRFZGl0b3JcIixcbiAgICAgICAgICAgIGFyZ3M6IFtwYXJ0SWRdXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5zZW5kTWVzc2FnZShtc2csIHRhcmdldCk7XG4gICAgfSxcblxuICAgIF9vcGVuR3JhbW1hcjogZnVuY3Rpb24ocGFydElkLCBydWxlTmFtZSl7XG4gICAgICAgIGxldCB0YXJnZXQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtwYXJ0SWRdO1xuICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBcImNvbW1hbmROYW1lXCI6IFwib3BlbkdyYW1tYXJcIixcbiAgICAgICAgICAgIGFyZ3M6IFtwYXJ0SWQsIHJ1bGVOYW1lXVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UobXNnLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvLyBBdCB0aGUgbW9tZW50IHRoaXMgc2ltcGx5IG9wZW5zIGEgc3Qtd2luZG93IHN0LWZpZWxkIHdpdGhcbiAgICAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXZhaWxhYmxlIGNvbW1hbmRzIGZvciBzYWlkIHBhcnRzXG4gICAgX29wZW5EZWJ1Z2dlcjogZnVuY3Rpb24ocGFydElkLCB0eXBlLCBuYW1lKXtcbiAgICAgICAgbGV0IHRhcmdldCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3BhcnRJZF07XG4gICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgIFwiY29tbWFuZE5hbWVcIjogXCJvcGVuRGVidWdnZXJcIixcbiAgICAgICAgICAgIGFyZ3M6IFtwYXJ0SWQsIHR5cGUsIG5hbWVdXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5zZW5kTWVzc2FnZShtc2csIHRhcmdldCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBlcnJvckhhbmRsZXIsXG4gICAgZXJyb3JIYW5kbGVyIGFzIGRlZmF1bHRcbn07XG4iLCJjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbmNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG5jb25zdCBzY2FsZURpbSA9IChkaW0pID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IDAuNztcbiAgICBjb25zdCBzdHJpZGUgPSAxNjtcbiAgICBjb25zdCBldmVuUmVzID0gZGltICogc2NhbGUgLSAxO1xuICAgIHJldHVybiBldmVuUmVzIC0gKGV2ZW5SZXMgJSBzdHJpZGUpICsgMTtcbn07XG5cbmNvbnN0IGRldGVjdEhhbmRzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gc2NhbGVEaW0oY2FudmFzLndpZHRoKTtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBzY2FsZURpbShjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZHJhd0ltYWdlKHZpZGVvLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGltYWdlID0gdGYudGlkeSgoKSA9PiB7XG4gICAgICAgIHJldHVybiB0Zi5mcm9tUGl4ZWxzKGNhbnZhcykucmVzaXplQmlsaW5lYXIoW3NjYWxlZEhlaWdodCwgc2NhbGVkV2lkdGhdKS5leHBhbmREaW1zKDApO1xuICAgIH0pO1xuICAgIGNvbnN0IFtzY29yZXMsIHRib3hlc10gPSBhd2FpdCBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25Nb2RlbC5leGVjdXRlQXN5bmMoaW1hZ2UpO1xuICAgIGltYWdlLmRpc3Bvc2UoKTtcbiAgICBjb25zdCBoYW5kc0RldGVjdGVkID0gdGYudGlkeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSB0Zi5pbWFnZS5ub25NYXhTdXBwcmVzc2lvbihcbiAgICAgICAgICAgIHRib3hlcy5yZXNoYXBlKFt0Ym94ZXMuc2hhcGVbMV0sIHRib3hlcy5zaGFwZVszXV0pLFxuICAgICAgICAgICAgc2NvcmVzLnJlc2hhcGUoW3Njb3Jlcy5zaGFwZVsxXV0pLFxuICAgICAgICAgICAgMjAsXG4gICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICAwLjg1KS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYm94ZXMgPSBbXTtcbiAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZHggPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIHNjb3JlID0gc2NvcmVzLmdldCgwLCBpZHgsIDApO1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgb3JkZXIgaXMgW21pblksIG1pblgsIG1heFksIG1heFhdIHNvIHdlIHJlb3JkZXIuXG4gICAgICAgICAgICB2YXIgYm94ID0ge1xuICAgICAgICAgICAgICAgIHVwcGVyTGVmdDogW3Rib3hlcy5nZXQoMCwgaWR4LCAwLCAxKSwgdGJveGVzLmdldCgwLCBpZHgsIDAsIDApXSxcbiAgICAgICAgICAgICAgICBsb3dlclJpZ2h0OiBbdGJveGVzLmdldCgwLCBpZHgsIDAsIDMpLCB0Ym94ZXMuZ2V0KDAsIGlkeCwgMCwgMildXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYm94ZXMucHVzaCh7c2NvcmU6IHNjb3JlLCBib3g6IGJveH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7Ym94ZXM6IGJveGVzLCB0aW1lc3RhbXA6IERhdGUubm93KCl9O1xuICAgIH0pO1xuICAgIHNjb3Jlcy5kaXNwb3NlKCk7XG4gICAgdGJveGVzLmRpc3Bvc2UoKTtcbiAgICBpZiAoaGFuZHNEZXRlY3RlZC5ib3hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgaWYgKGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGV0ZWN0SGFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYm94ID0gaGFuZHNEZXRlY3RlZC5ib3hlc1swXS5ib3g7XG4gICAgY29uc3QgW3gxLCB5MV0gPSBib3gudXBwZXJMZWZ0O1xuICAgIGNvbnN0IFt4MiwgeTJdID0gYm94Lmxvd2VyUmlnaHQ7XG4gICAgY29uc3QgYXJlYSA9IHthcmVhOiAoeDIgLSB4MSkgKiAoeTIgLSB5MSksIHRpbWVzdGFtcDogRGF0ZS5ub3coKX07XG4gICAgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uQXJlYXMgPSBbXS5jb25jYXQoaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uQXJlYXMuc2xpY2UoLTIpLCBbYXJlYV0pO1xuICAgIC8vIFVwZGF0ZSBoYW5kIGxvY2F0aW9uXG4gICAgY29uc3QgdncgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCwgd2luZG93LmlubmVyV2lkdGggfHwgMClcbiAgICBjb25zdCB2aCA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApXG4gICAgY29uc3QgcCA9IFswLjUgKiAoeDEgKyB4MikgKiB2dywgMC41ICogKHkxICsgeTIpICogdmhdO1xuICAgIGhhbmRJbnRlcmZhY2UucG9zaXRpb25zID0gW10uY29uY2F0KGhhbmRJbnRlcmZhY2UucG9zaXRpb25zLnNsaWNlKC0yKSwgW3BdKTtcbiAgICB2YXIgdGFyZ2V0ID0gaGFuZEludGVyZmFjZS50YXJnZXRFbGVtZW50O1xuICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0ID0gaGFuZEludGVyZmFjZS5sZW5pbkhhbmQ7XG4gICAgfVxuICAgIC8vIENvbXB1dGUgYXZlcmFnZSBwb3NpdGlvblxuICAgIGNvbnN0IFtwMSwgcDIsIHAzXSA9IGhhbmRJbnRlcmZhY2UucG9zaXRpb25zO1xuICAgIGNvbnN0IFthcDEsIGFwMl0gPSBbKDEvMykqKHAxWzBdICsgcDJbMF0gKyBwM1swXSksICgxLzMpKihwMVsxXSArIHAyWzFdICsgcDNbMV0pXTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwibGVmdFwiLCBhcDEpO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRhcmdldCwgXCJ0b3BcIiwgYXAyKTtcbiAgICAvLyBFeHRyYWN0IGFyZWEgaW5mb3JtYXRpb24gd2l0aG91dCBhbnkgdGltZXN0YW1wc1xuICAgIHZhciBqdXN0QXJlYXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGp1c3RBcmVhcy5wdXNoKGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzW2ldLmFyZWEpO1xuICAgIH1cbiAgICB2YXIganVzdEFyZWFzID0gW10uY29uY2F0KEFycmF5KDMgLSBqdXN0QXJlYXMubGVuZ3RoKS5maWxsKDApLCBqdXN0QXJlYXMpO1xuICAgIC8vIENoZWNrIGlmIGhhbmQgaXMgcHVzaGluZyBpblxuICAgIGNvbnN0IFthMSwgYTIsIGEzXSA9IGp1c3RBcmVhcztcbiAgICBjb25zdCBhdmVBcmVhID0gKDEvMykgKiAoYTEgKyBhMiArIGEzKTtcbiAgICBpZiAoYXZlQXJlYSA+IDAuMjUpIHtcbiAgICAgICAgaWYgKCFoYW5kSW50ZXJmYWNlLmhhbmRNYXNrZWQpIHtcbiAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UuaGFuZE1hc2tlZCA9IHRydWU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaGFuZEludGVyZmFjZS5oYW5kTWFza2VkID0gZmFsc2U7IH0sIDMwMDApO1xuICAgICAgICAgICAgaWYgKGhhbmRJbnRlcmZhY2UudGFyZ2V0RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBjbG9zZXN0VmlldyA9IGZpbmRDbG9zZXN0VmlldyhbcDEsIHAyXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RWaWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoaGFuZEludGVyZmFjZS5sZW5pbkhhbmQsIFwiaGlkZVwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZEludGVyZmFjZS50YXJnZXRFbGVtZW50ID0gY2xvc2VzdFZpZXcubW9kZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmxlbmluSGFuZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kLCBcImhpZGVcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UudGFyZ2V0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkZXRlY3RIYW5kcyk7XG4gICAgfVxufTtcblxuY29uc3QgZmluZENsb3Nlc3RWaWV3ID0gKHBvaW50KSA9PiB7XG4gICAgbGV0IHZpZXdzID0gW107XG4gICAgd2luZG93LlN5c3RlbS5nZXRDdXJyZW50Q2FyZE1vZGVsKCkuc3VicGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICBsZXQgcGFydFZpZXdzID0gd2luZG93LlN5c3RlbS5maW5kVmlld3NCeUlkKHBhcnQuaWQpO1xuICAgICAgICBwYXJ0Vmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICB2YXIgW2Nsb3Nlc3REaXN0LCBjbG9zZXN0Vmlld10gPSBbSW5maW5pdHksIG51bGxdO1xuICAgIHZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IHZpZXdEaXN0ID0gZGlzdChwb2ludCwgZ2V0VmVydGljZXModmlldykpO1xuICAgICAgICBpZiAodmlld0Rpc3QgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgICAgICAgY2xvc2VzdERpc3QgPSB2aWV3RGlzdDtcbiAgICAgICAgICAgIGNsb3Nlc3RWaWV3ID0gdmlldztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbG9zZXN0Vmlldztcbn1cblxuLy8gaHR0cHM6Ly9hYXJvbnNtaXRoLm9ubGluZS9lYXNpbHktbG9hZC1hbi1leHRlcm5hbC1zY3JpcHQtdXNpbmctamF2YXNjcmlwdC9cbmNvbnN0IGxvYWRTY3JpcHQgPSBzcmMgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LnRmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW5zb3JmbG93anMgYWxyZWFkeSBsb2FkZWRcIik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJsb2FkaW5nIHRlbnNvcmZsb3dqc1wiKTtcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0KTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGxvYWRIYW5kRGV0ZWN0aW9uTW9kZWwgPSAoKSA9PiB7XG4gICAgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uQXJlYXMgPSBbXTtcbiAgICBsb2FkU2NyaXB0KFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdGVuc29yZmxvdy90ZmpzQDAuMTMuNS9kaXN0L3RmLmpzXCIpLnRoZW4oKCkgPT4ge1xuICAgICAgICB3aW5kb3cudGYubG9hZEZyb3plbk1vZGVsKFxuICAgICAgICAgICAgXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2hhbmR0cmFja2pzL21vZGVscy93ZWIvc3NkbGl0ZW1vYmlsZW5ldHYyL3RlbnNvcmZsb3dqc19tb2RlbC5wYlwiLFxuICAgICAgICAgICAgXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2hhbmR0cmFja2pzL21vZGVscy93ZWIvc3NkbGl0ZW1vYmlsZW5ldHYyL3dlaWdodHNfbWFuaWZlc3QuanNvblwiXG4gICAgICAgICkudGhlbihtb2RlbCA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImhhbmQgZGV0ZWN0aW9uIG1vZGVsIGxvYWRlZFwiKTtcbiAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbk1vZGVsID0gbW9kZWw7XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IHRydWUgfSk7XG4gICAgICAgIH0pLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgIHJldHVybiB2aWRlby5wbGF5KCk7XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ2aWRlbyBzdGFydGVkXCIpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLTEsIDAsIDAsIDEsIGNhbnZhcy53aWR0aCwgMCk7IC8vIE1pcnJvciBpbmNvbWluZyB2aWRlb1xuICAgICAgICAgICAgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmxlbmluSGFuZCA9IHdpbmRvdy5TeXN0ZW0ubmV3TW9kZWwoJ2ltYWdlJywgd2luZG93LlN5c3RlbS5nZXRXb3JsZFN0YWNrTW9kZWwoKS5pZCwgXCIvaW1hZ2VzL2xlbmluSGFuZC5wbmdcIik7XG4gICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkZXRlY3RIYW5kcyk7XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yIGxvYWRpbmcgaGFuZCBkZXRlY3Rpb24gbW9kZWxcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuY29uc3QgdW5sb2FkSGFuZERldGVjdGlvbk1vZGVsID0gKCkgPT4ge1xuICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcgPSBmYWxzZTtcbiAgICB3aW5kb3cuU3lzdGVtLmRlbGV0ZU1vZGVsKGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kLmlkKVxuICAgIGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kID0gbnVsbDtcbiAgICB2aWRlby5wYXVzZSgpO1xuICAgIGNvbnN0IHRyYWNrcyA9IHZpZGVvLnNyY09iamVjdC5nZXRUcmFja3MoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFja3NbaV0uc3RvcCgpO1xuICAgIH1cbiAgICB2aWRlby5zcmNPYmplY3QgPSBudWxsO1xuICAgIGNvbnNvbGUubG9nKFwidmlkZW8gc3RvcHBlZFwiKTtcbiAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25Nb2RlbCA9IG51bGw7XG4gICAgY29uc29sZS5sb2coXCJ1bmxvYWRpbmcgaGFuZCBkZXRlY3Rpb24gbW9kZWxcIik7XG59XG5cbmNvbnN0IGdldFZlcnRpY2VzID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB1cHBlckxlZnQgPSBbcmVjdC54LCByZWN0LnldO1xuICAgIGNvbnN0IHVwcGVyUmlnaHQgPSBbcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55XTtcbiAgICBjb25zdCBsb3dlckxlZnQgPSBbcmVjdC54LCByZWN0LnkgKyByZWN0LmhlaWdodF07XG4gICAgY29uc3QgbG93ZXJSaWdodCA9IFtyZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnkgKyByZWN0LmhlaWdodF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBwZXJMZWZ0OiB1cHBlckxlZnQsXG4gICAgICAgIHVwcGVyUmlnaHQ6IHVwcGVyUmlnaHQsXG4gICAgICAgIGxvd2VyTGVmdDogbG93ZXJMZWZ0LFxuICAgICAgICBsb3dlclJpZ2h0OiBsb3dlclJpZ2h0XG4gICAgfTtcbn1cblxuY29uc3QgZGlzdCA9IChwb2ludCwgdmVydGljZXMpID0+IHtcbiAgICBjb25zdCBbcDEsIHAyXSA9IHBvaW50O1xuICAgIGNvbnN0IFt1bDEsIHVsMl0gPSB2ZXJ0aWNlcy51cHBlckxlZnQ7XG4gICAgY29uc3QgW2xsMSwgbGwyXSA9IHZlcnRpY2VzLmxvd2VyTGVmdDtcbiAgICBjb25zdCBbdXIxLCB1cjJdID0gdmVydGljZXMudXBwZXJSaWdodDtcbiAgICBjb25zdCBbbHIxLCBscjJdID0gdmVydGljZXMubG93ZXJSaWdodDtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSByZWN0YW5nbGVcbiAgICAvLyBOZXh0IHdlIGNvbXB1dGUgdGhlIHZlY3RvciBwb2ludGluZyBmcm9tIHRoZSBwb2ludCB0byB0aGUgY2xvc2VzdCBwb2ludFxuICAgIC8vIG9uIHRoZSByZWN0YW5nbGUuIFRoZXJlIGFyZSA5IGNhc2VzLiBUaGUgZmlyc3QgaXMgd2hlbiB0aGUgcG9pbnN0IGlzXG4gICAgLy8gaW5zaWRlIHRoZSByZWN0YW5nbGUuIFRoZSBuZXh0IGZvdXIgY2FzZXMgYXJlIGlmIHRoZSBwb2ludCBpbiBvbmUgb2ZcbiAgICAvLyB0aGUgZm91ciBjb3JuZXJzIGFuZCB0aGUgZmluYWwgZm91ciBjYXNlcyBhcmUgd2hlbiB0aGUgcG9pbnQgaXMgb24gb25lXG4gICAgLy8gb2YgdGhlIGZvdXIgc2lkZXMuXG4gICAgdmFyIFt2MSwgdjJdID0gW251bGwsIG51bGxdO1xuICAgIGlmICgodWwxIDw9IHAxKSAmJiAocDEgPD0gbHIxKSAmJiAodWwyIDw9IHAyKSAmJiAocDIgPD0gbHIyKSkge1xuICAgICAgICAvLyBDYXNlIDA6IGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gICAgICAgIFt2MSwgdjJdID0gWzAsIDBdO1xuICAgIH0gZWxzZSBpZiAoKHAxIDw9IHVsMSkgJiYgKHAyIDw9IHVsMikpIHtcbiAgICAgICAgLy8gQ2FzZSAxOiB1cHBlciBsZWZ0XG4gICAgICAgIFt2MSwgdjJdID0gW3VsMSAtIHAxLCB1bDIgLSBwMl07XG4gICAgfSBlbHNlIGlmICgocDEgPj0gdXIxKSAmJiAocDIgPD0gdXIyKSkge1xuICAgICAgICAvLyBDYXNlIDI6IHVwcGVyIHJpZ2h0XG4gICAgICAgIFt2MSwgdjJdID0gW3VyMSAtIHAxLCB1cjIgLSBwMl07XG4gICAgfSBlbHNlIGlmICgocDEgPD0gbGwxKSAmJiAocDIgPj0gbGwyKSkge1xuICAgICAgICAvLyBDYXNlIDM6IGxvd2VyIGxlZnRcbiAgICAgICAgW3YxLCB2Ml0gPSBbbGwxIC0gcDEsIGxsMiAtIHAyXTtcbiAgICB9IGVsc2UgaWYgKChwMSA+PSBscjEpICYmIChwMiA+PSBscjIpKSB7XG4gICAgICAgIC8vIENhc2UgNDogbG93ZXIgcmlnaHRcbiAgICAgICAgW3YxLCB2Ml0gPSBbbHIxIC0gcDEsIGxyMiAtIHAyXTtcbiAgICB9IGVsc2UgaWYgKHAxIDw9IHVsMSkge1xuICAgICAgICAvLyBDYXNlIDU6IHNpZGUgbGVmdFxuICAgICAgICBbdjEsIHYyXSA9IFt1bDEgLSBwMSwgMF07XG4gICAgfSBlbHNlIGlmIChwMSA+PSBscjEpIHtcbiAgICAgICAgLy8gQ2FzZSA2OiBzaWRlIHJpZ2h0XG4gICAgICAgIFt2MSwgdjJdID0gW2xyMSAtIHAxLCAwXTtcbiAgICB9IGVsc2UgaWYgKHAyIDw9IHVsMikge1xuICAgICAgICAvLyBDYXNlIDc6IHNpZGUgdG9wXG4gICAgICAgIFt2MSwgdjJdID0gWzAsIHVsMiAtIHAyXTtcbiAgICB9IGVsc2UgaWYgKHAyID49IGxyMikge1xuICAgICAgICAvLyBDYXNlIDg6IHNpZGUgYm90dG9tXG4gICAgICAgIFt2MSwgdjJdID0gWzAsIGxyMiAtIHAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYXNlIDk6IGluc2lkZVxuICAgICAgICBbdjEsIHYyXSA9IFswLCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydCh2MSp2MSArIHYyKnYyKTtcbn1cblxuY2xhc3MgSGFuZEludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZERldGVjdGlvbk1vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kRGV0ZWN0aW9uUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmluSGFuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZE1hc2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmREZXRlY3Rpb25BcmVhcyA9IFtdO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IFtbMCwgMF0sIFswLCAwXSwgWzAsIDBdXTtcbiAgICAgICAgLy8gWFhYIC0gT25seSBoZXJlIHRvIGlnbm9yZSB0aGUgdGVuc29yZmxvdyB3YXJuaW5nc1xuICAgICAgICBjb25zb2xlLndhcm4gPSAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgbG9hZEhhbmREZXRlY3Rpb25Nb2RlbCgpO1xuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIHVubG9hZEhhbmREZXRlY3Rpb25Nb2RlbCgpO1xuICAgIH1cbn1cblxuY29uc3QgVGVzdGFibGVzID0ge1xuICAgIGRpc3Q6IGRpc3Rcbn1cblxuY29uc3QgaGFuZEludGVyZmFjZSA9IG5ldyBIYW5kSW50ZXJmYWNlKCk7XG5cbmV4cG9ydCB7XG4gICAgVGVzdGFibGVzLFxuICAgIGhhbmRJbnRlcmZhY2UsXG4gICAgaGFuZEludGVyZmFjZSBhcyBkZWZhdWx0XG59O1xuIiwibGV0IHBhcnRJY29ucyA9IHt9O1xuXG5wYXJ0SWNvbnMud29ybGQgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItd29ybGRcIiB3aWR0aD1cIjQ0XCIgaGVpZ2h0PVwiNDRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzJjM2U1MFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjlcIiAvPlxuICA8bGluZSB4MT1cIjMuNlwiIHkxPVwiOVwiIHgyPVwiMjAuNFwiIHkyPVwiOVwiIC8+XG4gIDxsaW5lIHgxPVwiMy42XCIgeTE9XCIxNVwiIHgyPVwiMjAuNFwiIHkyPVwiMTVcIiAvPlxuICA8cGF0aCBkPVwiTTExLjUgM2ExNyAxNyAwIDAgMCAwIDE4XCIgLz5cbiAgPHBhdGggZD1cIk0xMi41IDNhMTcgMTcgMCAwIDEgMCAxOFwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5zdGFjayA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zdGFja1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMmMzZTUwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCIxMiA0IDQgOCAxMiAxMiAyMCA4IDEyIDRcIiAvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiNCAxMiAxMiAxNiAyMCAxMlwiIC8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCI0IDE2IDEyIDIwIDIwIDE2XCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmNhcmQgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc3F1YXJlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHJlY3QgeD1cIjRcIiB5PVwiNFwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiMlwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5idXR0b24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItaGFuZC1maW5nZXJcIiB3aWR0aD1cIjQ0XCIgaGVpZ2h0PVwiNDRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzJjM2U1MFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTggMTN2LTguNWExLjUgMS41IDAgMCAxIDMgMHY3LjVcIiAvPlxuICA8cGF0aCBkPVwiTTExIDExLjV2LTJhMS41IDEuNSAwIDEgMSAzIDB2Mi41XCIgLz5cbiAgPHBhdGggZD1cIk0xNCAxMC41YTEuNSAxLjUgMCAwIDEgMyAwdjEuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTcgMTEuNWExLjUgMS41IDAgMCAxIDMgMHY0LjVhNiA2IDAgMCAxIC02IDZoLTJoLjIwOGE2IDYgMCAwIDEgLTUuMDEyIC0yLjdhNjkuNzQgNjkuNzQgMCAwIDEgLS4xOTYgLS4zYy0uMzEyIC0uNDc5IC0xLjQwNyAtMi4zODggLTMuMjg2IC01LjcyOGExLjUgMS41IDAgMCAxIC41MzYgLTIuMDIyYTEuODY3IDEuODY3IDAgMCAxIDIuMjggLjI4bDEuNDcgMS40N1wiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy53aW5kb3cgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItd2luZG93XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMiAzYy0zLjg2NiAwIC03IDMuMjcyIC03IDd2MTBhMSAxIDAgMCAwIDEgMWgxMmExIDEgMCAwIDAgMSAtMXYtMTBjMCAtMy43MjggLTMuMTM0IC03IC03IC03elwiIC8+XG4gIDxsaW5lIHgxPVwiNVwiIHkxPVwiMTNcIiB4Mj1cIjE5XCIgeTI9XCIxM1wiIC8+XG4gIDxsaW5lIHgxPVwiMTJcIiB5MT1cIjNcIiB4Mj1cIjEyXCIgeTI9XCIyMVwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5hcmVhID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXNoYXBlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGNpcmNsZSBjeD1cIjVcIiBjeT1cIjVcIiByPVwiMlwiIC8+XG4gIDxjaXJjbGUgY3g9XCIxOVwiIGN5PVwiNVwiIHI9XCIyXCIgLz5cbiAgPGNpcmNsZSBjeD1cIjVcIiBjeT1cIjE5XCIgcj1cIjJcIiAvPlxuICA8Y2lyY2xlIGN4PVwiMTlcIiBjeT1cIjE5XCIgcj1cIjJcIiAvPlxuICA8bGluZSB4MT1cIjVcIiB5MT1cIjdcIiB4Mj1cIjVcIiB5Mj1cIjE3XCIgLz5cbiAgPGxpbmUgeDE9XCI3XCIgeTE9XCI1XCIgeDI9XCIxN1wiIHkyPVwiNVwiIC8+XG4gIDxsaW5lIHgxPVwiN1wiIHkxPVwiMTlcIiB4Mj1cIjE3XCIgeTI9XCIxOVwiIC8+XG4gIDxsaW5lIHgxPVwiMTlcIiB5MT1cIjdcIiB4Mj1cIjE5XCIgeTI9XCIxN1wiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5maWVsZCA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1mb3Jtc1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTIgM2EzIDMgMCAwIDAgLTMgM3YxMmEzIDMgMCAwIDAgMyAzXCIgLz5cbiAgPHBhdGggZD1cIk02IDNhMyAzIDAgMCAxIDMgM3YxMmEzIDMgMCAwIDEgLTMgM1wiIC8+XG4gIDxwYXRoIGQ9XCJNMTMgN2g3YTEgMSAwIDAgMSAxIDF2OGExIDEgMCAwIDEgLTEgMWgtN1wiIC8+XG4gIDxwYXRoIGQ9XCJNNSA3aC0xYTEgMSAwIDAgMCAtMSAxdjhhMSAxIDAgMCAwIDEgMWgxXCIgLz5cbiAgPHBhdGggZD1cIk0xNyAxMmguMDFcIiAvPlxuICA8cGF0aCBkPVwiTTEzIDEyaC4wMVwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5kcmF3aW5nID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXBhbGV0dGVcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEyIDIxYTkgOSAwIDEgMSAwIC0xOGE5IDggMCAwIDEgOSA4YTQuNSA0IDAgMCAxIC00LjUgNGgtMi41YTIgMiAwIDAgMCAtMSAzLjc1YTEuMyAxLjMgMCAwIDEgLTEgMi4yNVwiIC8+XG4gIDxjaXJjbGUgY3g9XCI3LjVcIiBjeT1cIjEwLjVcIiByPVwiLjVcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCI3LjVcIiByPVwiLjVcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgLz5cbiAgPGNpcmNsZSBjeD1cIjE2LjVcIiBjeT1cIjEwLjVcIiByPVwiLjVcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmltYWdlID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXBob3RvXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGxpbmUgeDE9XCIxNVwiIHkxPVwiOFwiIHgyPVwiMTUuMDFcIiB5Mj1cIjhcIiAvPlxuICA8cmVjdCB4PVwiNFwiIHk9XCI0XCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgcng9XCIzXCIgLz5cbiAgPHBhdGggZD1cIk00IDE1bDQgLTRhMyA1IDAgMCAxIDMgMGw1IDVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDE0bDEgLTFhMyA1IDAgMCAxIDMgMGwyIDJcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuZ2VuZXJpYyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1wdXp6bGVcIiB3aWR0aD1cIjQ0XCIgaGVpZ2h0PVwiNDRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzJjM2U1MFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTQgN2gzYTEgMSAwIDAgMCAxIC0xdi0xYTIgMiAwIDAgMSA0IDB2MWExIDEgMCAwIDAgMSAxaDNhMSAxIDAgMCAxIDEgMXYzYTEgMSAwIDAgMCAxIDFoMWEyIDIgMCAwIDEgMCA0aC0xYTEgMSAwIDAgMCAtMSAxdjNhMSAxIDAgMCAxIC0xIDFoLTNhMSAxIDAgMCAxIC0xIC0xdi0xYTIgMiAwIDAgMCAtNCAwdjFhMSAxIDAgMCAxIC0xIDFoLTNhMSAxIDAgMCAxIC0xIC0xdi0zYTEgMSAwIDAgMSAxIC0xaDFhMiAyIDAgMCAwIDAgLTRoLTFhMSAxIDAgMCAxIC0xIC0xdi0zYTEgMSAwIDAgMSAxIC0xXCIgLz5cbjwvc3ZnPlxuYDtcblxuZXhwb3J0IHtcbiAgICBwYXJ0SWNvbnMsXG4gICAgcGFydEljb25zIGFzIGRlZmF1bHRcbn07XG4iLCIvLyBJRCByZWxhdGVkIHV0aWxpdGllc1xuXG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcblxuLyoqXG4gKiBJRCBNYWtlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBnbG9iYWxseVxuICogdW5pcXVlIElEIHZhbHVlcyBmb3IgUGFydHMgaW4gdGhlIFNpbXBsZVRhbGtcbiAqIHdvcmxkLlxuICogSEMgcmVxdWlyZXMgdGhhdCBhbGwgUGFydHMgaGF2ZSB1bmlxdWUgaWRzIGFuZFxuICogdGhhdCB0aGVzZSBzaG91bGQgbm90IGJlIHJlcGVhdGVkIGluIGFueSBnaXZlblxuICogXCJhcHBsaWNhdGlvblwiIGluc3RhbmNlLlxuICogV2UgbmVlZCB0byBkZXRlcm1pbmUgd2hhdCBhbiBcImFwcGxpY2F0aW9uXCIgaXNcbiAqIGluIG91ciBjb250ZXh0LCBidXQgcmVnYXJkbGVzcyB3ZSBjYW4gdXNlIHRoaXNcbiAqIG1vZHVsZSBhcyBhIGRyb3AgaW4gcmVwbGFjZW1lbnQsIGltcGxlbWVudGluZ1xuICogVVVJRHMgb3IgVVJMcyBvciB3aGF0ZXZlciB3ZSB3YW50LlxuICogRm9yIG5vdyB3ZSBqdXN0IGluY3JlbWVudCBhbiBpbnRlZ2VyLlxuICovXG5jb25zdCBpZE1ha2VyID0ge1xuICAgIG5ldzogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGlkID0gdXVpZHY0KCk7XG4gICAgICAgIHJldHVybiBpZC5yZXBsYWNlKC8tL2csICcnKTtcbiAgICB9XG59O1xuXG4vKiBJRCBjaGVja2VyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSByZXNwb25zaWJsZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBpZCBpc1xuICogaXMgdmFsaWQgYW5kIHJldHVybmluZyBpdCBpZiBzb1xuICovXG5jb25zdCBpc1ZhbGlkSWQgPSBmdW5jdGlvbihpZCkge1xuICAgIGlmKGlkID09PSBudWxsIHx8IGlkID09PSB1bmRlZmluZWQgfHwgaWQgPT09IFwiXCIpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmKGlkLmxlbmd0aCAhPSAzMiB8fCBpZC5tYXRjaCgnW2EtejAtOV0qJylbMF0ubGVuZ3RoICE9IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0IHtcbiAgICBpZE1ha2VyLFxuICAgIGlzVmFsaWRJZCxcbiAgICBpZE1ha2VyIGFzIGRlZmF1bHRcbn07XG4iLCJjb25zdCBtZXJyaWFtU2ltU2NvcmUgPSBhc3luYyAoc2VuZGVyLCBkb2NJZCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IFwiaHR0cHM6Ly9wYXRlbnRzLm1lcnJpYW10ZWNoLmNvbS9fYXBpL21lcnJpYW0vXCJcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBcImZpZWxkc1wiOiBbXG4gICAgICAgICAgICBcInRpdGxlXCIsXG4gICAgICAgICAgICBcImRhdGVfcHVibFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwid2VpZ2h0c1wiOiB7XG4gICAgICAgICAgICBcIm1lcnJpYW1cIjowLjcsXG4gICAgICAgICAgICBcImRhdGVcIjowLjMsXG4gICAgICAgICAgICBcImhpZXJhcmNoeVwiOjAuMVxuICAgICAgICB9LFxuICAgICAgICBcImRvY19pZHNcIjogW1xuICAgICAgICAgICAgZG9jSWRcbiAgICAgICAgXSxcbiAgICAgICAgXCJsaW1pdFwiOiA1fVxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiaGVhZGVyc1wiOiB7XG4gICAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBcImJvZHlcIjogSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcbiAgICB9XG4gICAgZmV0Y2godXJsLCBwYXJhbXMpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHJldHVybiBkYXRhLmpzb24oKTtcbiAgICB9KS50aGVuKGpzb24gPT4ge1xuICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ21lcnJpYW1yZXN1bHQnLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAgIHNlbmRlci5zZW5kTWVzc2FnZShtc2csIHNlbmRlcik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7XG4gICAgbWVycmlhbVNpbVNjb3JlLFxuICAgIG1lcnJpYW1TaW1TY29yZSBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTZXJpYWxpemF0aW9uIGFuZCBEZXNlcmlhbGl6YXRpb24gVXRpbGl0eSBDbGFzc2VzXG4gKi9cbmltcG9ydCBpZE1ha2VyIGZyb20gJy4vaWQuanMnO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjAuMlwiO1xuXG5jbGFzcyBTVERlc2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoYVN5c3RlbSl7XG4gICAgICAgIHRoaXMuc3lzdGVtID0gYVN5c3RlbTtcblxuICAgICAgICAvLyBUaGVzZSBjYWNoZXMgYXJlIHVzZWQgZHVyaW5nIHRoZSBwcm9jZXNzXG4gICAgICAgIC8vIGFzIG9wdGltaXphdGlvbnNcbiAgICAgICAgdGhpcy5fbW9kZWxDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9zdWJwYXJ0TWFwQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5faWRDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuX3Byb3BzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fdmlld3NDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9zY3JpcHRDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9yb290c0NhY2hlID0gW107XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldElkIGlzIHRoZSBpZCBvZlxuICAgICAgICAvLyB0aGUgUGFydCB0aGF0IHdlIHdpc2ggdG8gYXBwZW5kIGFueVxuICAgICAgICAvLyBkZXNlcmlhbGl6ZWQgc3VicGFydCB0cmVlIGludG8uXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgd2UgYXNzdW1lIHRoZSB3aG9sZSBzeXN0ZW0sXG4gICAgICAgIC8vIGllIGZ1bGwgZGVzZXJpYWxpemF0aW9uLlxuICAgICAgICB0aGlzLnRhcmdldElkID0gJ3N5c3RlbSc7XG4gICAgICAgIC8vIHRoZSByb290IGlkIGlzIHRoZSBpZCBvZiB0aGUgcm9vdCBwYXJ0IGluc3RhbmNlXG4gICAgICAgIC8vIGJlaW5nIGF0dGFjaGVkXG4gICAgICAgIHRoaXMucm9vdElkID0gbnVsbDtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSB0aGlzLmRlc2VyaWFsaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemVEYXRhID0gdGhpcy5kZXNlcmlhbGl6ZURhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZVBhcnQgPSB0aGlzLmRlc2VyaWFsaXplUGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmF0dGFjaFN1YnBhcnRzID0gdGhpcy5hdHRhY2hTdWJwYXJ0cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMgPSB0aGlzLnNldFByb3BlcnRpZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVWaWV3ID0gdGhpcy5jcmVhdGVWaWV3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXR0YWNoVmlldyA9IHRoaXMuYXR0YWNoVmlldy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFZpZXdNb2RlbCA9IHRoaXMuc2V0Vmlld01vZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29tcGlsZVBhcnRTY3JpcHQgPSB0aGlzLmNvbXBpbGVQYXJ0U2NyaXB0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmcmVzaFdvcmxkID0gdGhpcy5yZWZyZXNoV29ybGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcHBlbmRXb3JsZCA9IHRoaXMuYXBwZW5kV29ybGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRQYXJ0c1RvU3lzdGVtID0gdGhpcy5hZGRQYXJ0c1RvU3lzdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29tcGlsZVNjcmlwdHMgPSB0aGlzLmNvbXBpbGVTY3JpcHRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0RmxhdHRlbmVkUGFydFRyZWUgPSB0aGlzLmdldEZsYXR0ZW5lZFBhcnRUcmVlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0TW9kZWxDbGFzcyA9IHRoaXMuZ2V0TW9kZWxDbGFzcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUlkID0gdGhpcy5oYW5kbGVJZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRocm93RXJyb3IgPSB0aGlzLnRocm93RXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5mbHVzaENhY2hlcyA9IHRoaXMuZmx1c2hDYWNoZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFZpZXdBZGRlZCA9IHRoaXMuZGlzcGF0Y2hWaWV3QWRkZWQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBkZXNlcmlhbGl6ZShhSlNPTlN0cmluZyl7XG4gICAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UoYUpTT05TdHJpbmcpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zeXN0ZW0ucGFydHNCeUlkW3RoaXMudGFyZ2V0SWRdO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZURhdGEoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgZGVzZXJpYWxpemVkIFBhcnRzIHRvIHRoZSBTeXN0ZW0gZGljdCxcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIG5ldyBXb3JsZC5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcnRzVG9TeXN0ZW0odGhpcy5faW5zdGFuY2VDYWNoZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENvbXBpbGUgdGhlIHNjcmlwdHMgb24gKmFsbCogZGVzZXJpYWxpemVkXG4gICAgICAgICAgICAgICAgLy8gcGFydHNcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVTY3JpcHRzKHRoaXMuX2luc3RhbmNlQ2FjaGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIHJvb3QgUGFydCBpbnRvIHdoYXRldmVyXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGl0IHNob3VsZCBnbyBpbnRvLlxuICAgICAgICAgICAgICAgIGxldCByb290UGFydCA9IHRoaXMucm9vdFBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIGxldCByb290VmlldyA9IHRoaXMucm9vdFZpZXdzWzBdO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMudGFyZ2V0SWQgPT0gJ3N5c3RlbScpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hXb3JsZCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5hZGRQYXJ0KHJvb3RQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBhcHBlbmQgdGhlIFBhcnRWaWV3IHJvb3Qgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGl0IHNob3VsZCBnbyBpbiB0aGUgdmlldyB0cmVlLlxuICAgICAgICAgICAgICAgIGlmKHRoaXMudGFyZ2V0SWQgPT0gJ3N5c3RlbScpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFdvcmxkKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7dGhpcy50YXJnZXRJZH1cIl1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Vmlldy5hcHBlbmRDaGlsZChyb290Vmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hWaWV3QWRkZWQocm9vdFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICByb290UGFydC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ25ld01vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkTm90RGVsZWdhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSwgcm9vdFBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlc2VyaWFsaXplRGF0YSgpe1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mbHVzaENhY2hlcygpO1xuICAgICAgICAgICAgLy8gRmlyc3QsIHdlIGVuc3VyZSB0aGF0IHRoZSB0YXJnZXQgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBkZXNlcmlhbGl6aW5nIGludG8gYWN0dWFsbHkgZXhpc3RzXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zeXN0ZW0ucGFydHNCeUlkW3RoaXMudGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYoIXRhcmdldCAmJiB0aGlzLnRhcmdldElkICE9ICdzeXN0ZW0nKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoYFRhcmdldCBpZCAke3RoaXMudGFyZ2V0SWR9IGRvZXMgbm90IGV4aXN0IGluIFN5c3RlbWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWNvbmQsIHdlIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYWxsIG1vZGVscyBpbiB0aGUgc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgLy8gYnV0IHdlIGRvIG5vdCB5ZXQgYXR0YWNoIHRoZWlyIHN1YnBhcnRzLlxuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmRhdGEucGFydHMpLmZvckVhY2gocGFydERhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzZXJpYWxpemVQYXJ0KE9iamVjdC5hc3NpZ24oe30sIHBhcnREYXRhKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRhcmdldHNcbiAgICAgICAgICAgIGZvciAobGV0IG1vZGVsSWQgaW4gdGhpcy5fcHJvcHNDYWNoZSkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wcyA9IHRoaXMuX3Byb3BzQ2FjaGVbbW9kZWxJZF07XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLnRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvbGRJZCBpbiB0aGlzLl9pZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SWQgPSB0aGlzLl9pZENhY2hlW29sZElkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy50YXJnZXQgPT09ICdwYXJ0IGlkICcgKyBvbGRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnRhcmdldCA9ICdwYXJ0IGlkICcgKyBuZXdJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBzY3JpcHRzXG4gICAgICAgICAgICBmb3IgKGxldCBtb2RlbElkIGluIHRoaXMuX3NjcmlwdENhY2hlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjcmlwdCA9IHRoaXMuX3NjcmlwdENhY2hlW21vZGVsSWRdO1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHQgIT09IG51bGwgJiYgc2NyaXB0Lm1hdGNoKCdwYXJ0IGlkJykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgb2xkSWQgaW4gdGhpcy5faWRDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0lkID0gdGhpcy5faWRDYWNoZVtvbGRJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2xkUmUgPSAncGFydCBpZCAnICsgb2xkSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UmUgPSAncGFydCBpZCAnICsgbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2NyaXB0Q2FjaGVbbW9kZWxJZF0ubWF0Y2gob2xkUmUpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobW9kZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlID0gbmV3IFJlZ0V4cChvbGRSZSwgXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjcmlwdENhY2hlW21vZGVsSWRdID0gc2NyaXB0LnJlcGxhY2UocmUsIG5ld1JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcmQsIHdlIGdvIHRocm91Z2ggZWFjaCBjcmVhdGVkIFBhcnQgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIGFuZCBhZGQgYW55IHN1YnBhcnRzIHRvIGl0LiBOb3RlIHRoYXQgdGhpcyBpcyBub3RcbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZVxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VDYWNoZS5mb3JFYWNoKHBhcnRJbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTdWJwYXJ0cyhwYXJ0SW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZvcnRoIGFuZCBmaWZ0aC4gQ3JlYXRlIGFuZCBhdHRhY2ggdmlld3NcbiAgICAgICAgICAgIC8vIE5vdGUgdGhpcyBpcyByZWN1cnNpdmUgdG8gcHJlc2VydmUgdGhlIHN1YnBhcnQgKyB2aWV3IGNoaWxkcmVuIG9yZGVyXG4gICAgICAgICAgICBsZXQgcm9vdCA9IHRoaXMuX2luc3RhbmNlQ2FjaGUuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChwYXJ0LCBcImlkXCIpID09IHRoaXMucm9vdElkO1xuICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZEF0dGFjaFZpZXdzKHJvb3QpO1xuXG4gICAgICAgICAgICAvLyBTaXh0aCwgd2Ugc2V0IGFsbCBwcm9wZXJ0aWVzIG9uIGVhY2ggY3JlYXRlZFxuICAgICAgICAgICAgLy8gUGFydCBtb2RlbCBmcm9tIHRoZSBkZXNlcmlhbGl6ZWQgZGF0YS5cbiAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgdXNpbmcgYSB2aXNpdG9yIG1ldGhvZCBvbiB0aGUgaW5zdGFuY2VzXG4gICAgICAgICAgICAvLyB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyB0aGUgaW4tbWVtb3J5IHZpZXdzIHRoZSBhYmlsaXR5IHRvXG4gICAgICAgICAgICAvLyByZWFjdCB0byBhbnkgaW5pdGlhbCBjaGFuZ2VzIHRvIHRoZWlyIG1vZGVscy5cbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlQ2FjaGUuZm9yRWFjaChwYXJ0SW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhwYXJ0SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhbnNsYXRlIG5ldyBpZHMgdG8gb2xkIG9uZXNcbiAgICAgICAgICAgICAgICBpZiAocGFydEluc3RhbmNlLm5hbWUgPT0gXCJXb3JsZFN0YWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdvcmxkID0gcGFydEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB3b3JsZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lkQ2FjaGVbd29ybGQuY3VycmVudFN0YWNrSWRdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0SW5zdGFuY2UubmFtZSA9PSBcIlN0YWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gcGFydEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lkQ2FjaGVbc3RhY2suY3VycmVudENhcmRJZF1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3TW9kZWwocGFydEluc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBXZSBkZXRlcm1pbmUgd2hpY2ggb2YgdGhlIGluc3RhbmNlcyBpcyBhIFwicm9vdFwiLFxuICAgICAgICAgICAgLy8gbWVhbmluZyB0aGF0IGl0IGhhcywgYXQgdGhpcyBwb2ludCwgbm8gb3duZXIgaW5cbiAgICAgICAgICAgIC8vIHRoZSBkZXNlcmlhbGl6ZWQgZGF0YS4gVGhlcmUgY2FuIGJlIG11bHRpcGxlIHJvb3RzXG4gICAgICAgICAgICAvLyAoYW5kIHRoZXJlZm9yZSBtdWx0aXBsZSB0cmVlcykgaW4gYSBzaW5nbGUgZGVzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICB0aGlzLl9yb290c0NhY2hlID0gdGhpcy5faW5zdGFuY2VDYWNoZS5maWx0ZXIoaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5fb3duZXIgPT0gbnVsbCB8fCBpbnN0YW5jZS5fb3duZXIgPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEluc2VydGlvbiBzaG91bGQgYmUgaGFuZGxlZCBieSBjb21wb3NlZFxuICAgICAgICAgICAgLy8gcHJvbWlzZXMgZWxzZXdoZXJlIChzZWUgaW1wb3J0cyBhbmQgZGVzZXJpYWxpemUoKVxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGVzKVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQW5kQXR0YWNoVmlld3MocGFydEluc3RhbmNlKXtcbiAgICAgICAgdGhpcy5jcmVhdGVWaWV3KHBhcnRJbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYXR0YWNoVmlldyhwYXJ0SW5zdGFuY2UpO1xuICAgICAgICBpZihwYXJ0SW5zdGFuY2Uuc3VicGFydHMubGVuZ3RoKXtcbiAgICAgICAgICAgIHBhcnRJbnN0YW5jZS5zdWJwYXJ0cy5mb3JFYWNoKChzdWJwYXJ0SW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZEF0dGFjaFZpZXdzKHN1YnBhcnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGltcG9ydEZyb21TZXJpYWxpemF0aW9uKGFKU09OU3RyaW5nLCBmaWx0ZXJGdW5jdGlvbil7XG4gICAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UoYUpTT05TdHJpbmcpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zeXN0ZW0ucGFydHNCeUlkW3RoaXMudGFyZ2V0SWRdO1xuICAgICAgICBsZXQgdGFyZ2V0VmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt0aGlzLnRhcmdldElkfVwiXWApO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZURhdGEoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBwcm92aWRlIGEgZmlsdGVyIGZ1bmN0aW9uIG92ZXJcbiAgICAgICAgICAgICAgICAvLyBhbGwgZGVzZXJpYWxpemVkIHBhcnQgaW5zdGFuY2VzLCByZXR1cm5pbmcgb25seVxuICAgICAgICAgICAgICAgIC8vIHRob3NlIHRoYXQgc2hvdWxkIGJlIGluc2VydGVkIGludG8gdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgYWxsIFN0YWNrcyBpbiB0aGUgV29ybGRTdGFjay5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VDYWNoZS5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyb290UGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICByb290UGFydHMuZm9yRWFjaChyb290UGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGxUcmVlUGFydHMgPSB0aGlzLmdldEZsYXR0ZW5lZFBhcnRUcmVlKHJvb3RQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXJ0c1RvU3lzdGVtKGFsbFRyZWVQYXJ0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RQYXJ0cztcblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyb290UGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICByb290UGFydHMuZm9yRWFjaChyb290UGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGxUcmVlUGFydHMgPSB0aGlzLmdldEZsYXR0ZW5lZFBhcnRUcmVlKHJvb3RQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlU2NyaXB0cyhhbGxUcmVlUGFydHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByb290UGFydHM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJvb3RQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJvb3RQYXJ0cy5mb3JFYWNoKHJvb3RQYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLl92aWV3c0NhY2hlW3Jvb3RQYXJ0LmlkXTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFkZFBhcnQocm9vdFBhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWaWV3LmFwcGVuZENoaWxkKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVmlld0FkZGVkKHZpZXcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzZXJpYWxpemVQYXJ0KHBhcnREYXRhKXtcbiAgICAgICAgbGV0IHBhcnRDbGFzcyA9IHRoaXMuZ2V0TW9kZWxDbGFzcyhwYXJ0RGF0YS50eXBlKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IHBhcnRDbGFzcygpO1xuXG4gICAgICAgIC8vIFdlIGNyZWF0ZSBhIG5ldyBJRCBmb3IgdGhpcyBwYXJ0LCBzaW5jZSB3ZSBjYW5ub3RcbiAgICAgICAgLy8gZ3VhcmFudGVlIElEIGNsYXNoZXMgd2l0aCB0aGUgZXhpc3RpbmcgU3lzdGVtLlxuICAgICAgICAvLyBFeGNlcHRpb24gaXMgaWYgdGhlIHVzZU9yaWdpbmFsaWRzIGZsYWcgaXMgc2V0LFxuICAgICAgICAvLyBzdWNoIGFzIGF0IGxvYWQgdGltZVxuICAgICAgICBsZXQge25ld0lkLCBvbGRJZH0gPSB0aGlzLmhhbmRsZUlkKGluc3RhbmNlLCBwYXJ0RGF0YSk7XG4gICAgICAgIGluc3RhbmNlLmlkID0gbmV3SWQ7XG4gICAgICAgIC8vIGNhY2hlIHRoZSBuZXcgcm9vdCBJRCBpZiB0aGlzIGlzIGEgcm9vdCBpbnN0YW5jZVxuICAgICAgICBpZih0aGlzLmRhdGEucm9vdElkID09IG9sZElkKXtcbiAgICAgICAgICAgIHRoaXMucm9vdElkID0gbmV3SWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdG8gb3VyIGNhY2hlcyBhbmQgYWxzbyB0byB0aGUgU3lzdGVtXG4gICAgICAgIHRoaXMuX2lkQ2FjaGVbb2xkSWRdID0gbmV3SWQ7XG4gICAgICAgIHRoaXMuX3NjcmlwdENhY2hlW25ld0lkXSA9IHBhcnREYXRhLnByb3BlcnRpZXMuc2NyaXB0O1xuICAgICAgICB0aGlzLl9wcm9wc0NhY2hlW25ld0lkXSA9IHBhcnREYXRhLnByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuX21vZGVsQ2FjaGVbbmV3SWRdID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuX3N1YnBhcnRNYXBDYWNoZVtuZXdJZF0gPSBwYXJ0RGF0YS5zdWJwYXJ0cztcbiAgICAgICAgdGhpcy5faW5zdGFuY2VDYWNoZS5wdXNoKGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVJZChhUGFydCwgcGFydERhdGEpe1xuICAgICAgICBsZXQgbmV3SWQsIG9sZElkO1xuICAgICAgICBvbGRJZCA9IHBhcnREYXRhLmlkO1xuICAgICAgICBuZXdJZCA9IGFQYXJ0LmlkO1xuICAgICAgICBpZihhUGFydC50eXBlICE9PSAnd29ybGQnKXtcbiAgICAgICAgICAgIG5ld0lkID0gaWRNYWtlci5uZXcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV3SWQsXG4gICAgICAgICAgICBvbGRJZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZFBhcnRzVG9TeXN0ZW0oYUxpc3RPZlBhcnRzKXtcbiAgICAgICAgYUxpc3RPZlBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLnN5c3RlbS5wYXJ0c0J5SWRbcGFydC5pZF0gPSBwYXJ0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21waWxlU2NyaXB0cyhhTGlzdE9mUGFydHMpe1xuICAgICAgICBhTGlzdE9mUGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZVBhcnRTY3JpcHQocGFydCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGF0dGFjaFN1YnBhcnRzKGFQYXJ0KXtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIF9zdWJwYXJ0TWFwQ2FjaGUgc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYW4gZW50cnkgbWFwcGluZyBmcm9tIHRoaXMgYVBhcnQncyAobmV3KVxuICAgICAgICAvLyBpZCB0byBhbiBhcnJheSBvZiBpZHMgb2YgYWxzby1pbml0aWFsaXplZFxuICAgICAgICAvLyBzdWJwYXJ0IG1vZGVsc1xuICAgICAgICBsZXQgc3VicGFydElkcyA9IHRoaXMuX3N1YnBhcnRNYXBDYWNoZVthUGFydC5pZF07XG4gICAgICAgIHN1YnBhcnRJZHMuZm9yRWFjaChzdWJwYXJ0SWQgPT4ge1xuICAgICAgICAgICAgbGV0IG5ld0lkID0gdGhpcy5faWRDYWNoZVtzdWJwYXJ0SWRdO1xuICAgICAgICAgICAgbGV0IHN1YnBhcnRNb2RlbCA9IHRoaXMuX21vZGVsQ2FjaGVbbmV3SWRdO1xuICAgICAgICAgICAgaWYoIXN1YnBhcnRNb2RlbCl7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhUGFydC5hZGRQYXJ0KHN1YnBhcnRNb2RlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFByb3BlcnRpZXMoYVBhcnQpe1xuICAgICAgICBsZXQgcHJvcHMgPSB0aGlzLl9wcm9wc0NhY2hlW2FQYXJ0LmlkXTtcbiAgICAgICAgZGVsZXRlIHByb3BzWydpZCddO1xuICAgICAgICBhUGFydC5zZXRQcm9wc0Zyb21EZXNlcmlhbGl6ZXIocHJvcHMsIHRoaXMpO1xuICAgIH1cblxuICAgIGNyZWF0ZVZpZXcoYVBhcnQpe1xuICAgICAgICBsZXQgbmV3VmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICB0aGlzLnN5c3RlbS50YWdOYW1lRm9yVmlld05hbWVkKGFQYXJ0LnR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IHRoZSBwYXJ0LWlkIGF0dHJpYnV0ZSBzaW5jZSB0aGVzZVxuICAgICAgICAvLyBhcmUgdXNlZCBmb3IgcXVlcmllcyBuZWVkZWQgZm9yIHRoaW5ncyBsaWtlXG4gICAgICAgIC8vIGN1cnJlbnQgc3RhY2sgYW5kIGNhcmRcbiAgICAgICAgbmV3Vmlldy5zZXRBdHRyaWJ1dGUoXCJwYXJ0LWlkXCIsIGFQYXJ0LmlkKTtcbiAgICAgICAgdGhpcy5fdmlld3NDYWNoZVthUGFydC5pZF0gPSBuZXdWaWV3O1xuICAgIH1cblxuICAgIHNldFZpZXdNb2RlbChhUGFydCl7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlld3NDYWNoZVthUGFydC5pZF07XG4gICAgICAgIHZpZXcuc2V0TW9kZWwoYVBhcnQpO1xuICAgIH1cbiAgICBcbiAgICBhdHRhY2hWaWV3KGFQYXJ0KXtcbiAgICAgICAgbGV0IG93bmVyID0gYVBhcnQuX293bmVyO1xuICAgICAgICBpZihvd25lcil7XG4gICAgICAgICAgICBsZXQgb3duZXJWaWV3ID0gdGhpcy5fdmlld3NDYWNoZVtvd25lci5pZF07XG4gICAgICAgICAgICBsZXQgcGFydFZpZXcgPSB0aGlzLl92aWV3c0NhY2hlW2FQYXJ0LmlkXTtcbiAgICAgICAgICAgIG93bmVyLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInZpZXdDaGFuZ2VkXCIsXG4gICAgICAgICAgICAgICAgY2hhbmdlTmFtZTogXCJzdWJwYXJ0LW5ld1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtwYXJ0Vmlld11cbiAgICAgICAgICAgIH0sIG93bmVyVmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21waWxlUGFydFNjcmlwdChhUGFydCl7XG4gICAgICAgIGxldCBzY3JpcHRTdHJpbmcgPSB0aGlzLl9zY3JpcHRDYWNoZVthUGFydC5pZF07XG4gICAgICAgIGlmKHNjcmlwdFN0cmluZyAmJiBzY3JpcHRTdHJpbmcgIT0gXCJcIil7XG4gICAgICAgICAgICB0aGlzLnN5c3RlbS5jb21waWxlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tcGlsZScsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IGFQYXJ0LmlkLFxuICAgICAgICAgICAgICAgIGNvZGVTdHJpbmc6IHNjcmlwdFN0cmluZyxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZnJlc2hXb3JsZCgpe1xuICAgICAgICAvLyBXZSBhc3N1bWUgYSBzaW5nbGUgcm9vdCBwYXJ0IHdhcyBkZXNlcmlhbGl6ZWQgYW5kXG4gICAgICAgIC8vIGF0dGFjaCBpdCBhcyB0aGUgV29ybGQgYWNjb3JkaW5nbHlcbiAgICAgICAgbGV0IG5ld1dvcmxkID0gdGhpcy5yb290UGFydHNbMF07XG4gICAgICAgIGlmKG5ld1dvcmxkLnR5cGUgIT09ICd3b3JsZCcpe1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBGb3VuZCAke3RoaXMucm9vdFBhcnRzLmxlbmd0aH0gcm9vdHMsIGJ1dCBubyB3b3JsZCFgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN5c3RlbS5wYXJ0c0J5SWRbJ3dvcmxkJ10gPSB0aGlzLnJvb3RQYXJ0c1swXTtcbiAgICB9XG5cbiAgICBhcHBlbmRXb3JsZCgpe1xuICAgICAgICAvLyBXZSBhc3N1bWUgYSBzaW5nbGUgcm9vdCB2aWV3IHRoYXQgaXMgYW4gc3Qtd29ybGQuXG4gICAgICAgIGxldCBmb3VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIGlmKGZvdW5kKXtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVwbGFjZUNoaWxkKHRoaXMucm9vdFZpZXdzWzBdLCBmb3VuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnByZXBlbmQodGhpcy5yb290Vmlld3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hWaWV3QWRkZWQoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKSk7XG4gICAgfVxuXG4gICAgZ2V0RmxhdHRlbmVkUGFydFRyZWUoYVBhcnQsIGxpc3Q9W10pe1xuICAgICAgICBsaXN0LnB1c2goYVBhcnQpO1xuICAgICAgICBhUGFydC5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZShzdWJwYXJ0LCBsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIHRocm93RXJyb3IobWVzc2FnZSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVzZXJpYWxpemF0aW9uIEVycm9yOiAke21lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgZ2V0TW9kZWxDbGFzcyhhUGFydFR5cGVTdHIpe1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5zeXN0ZW0uYXZhaWxhYmxlUGFydHNbYVBhcnRUeXBlU3RyXTtcbiAgICAgICAgaWYoIWNscyl7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoYFBhcnQgdHlwZSBcIiR7YVBhcnRUeXBlU3RyfVwiIGRvZXMgbm90IGV4aXN0IGluIHN5c3RlbWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbHM7XG4gICAgfVxuXG4gICAgZmx1c2hDYWNoZXMoKXtcbiAgICAgICAgdGhpcy5fbW9kZWxDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9zdWJwYXJ0TWFwQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5faWRDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuX3Byb3BzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fdmlld3NDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9zY3JpcHRDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9yb290c0NhY2hlID0gW107XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hWaWV3QWRkZWQoYVZpZXcpe1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3N0LXZpZXctYWRkZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBwYXJ0VHlwZTogYVZpZXcubW9kZWwudHlwZSxcbiAgICAgICAgICAgICAgICBwYXJ0SWQ6IGFWaWV3Lm1vZGVsLmlkLFxuICAgICAgICAgICAgICAgIC8vb3duZXJJZDogYVZpZXcubW9kZWwuX293bmVyLmlkIHx8IG51bGxcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgICAgICBhVmlldy5wYXJlbnRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cblxuICAgIGdldCByb290UGFydHMoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RzQ2FjaGU7XG4gICAgfVxuXG4gICAgZ2V0IHJvb3RWaWV3cygpe1xuICAgICAgICByZXR1cm4gdGhpcy5yb290UGFydHMubWFwKHBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdzQ2FjaGVbcGFydC5pZF07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5jbGFzcyBTVFNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGFTeXN0ZW0pe1xuICAgICAgICB0aGlzLnN5c3RlbSA9IGFTeXN0ZW07XG4gICAgICAgIHRoaXMuX29iamVjdENhY2hlID0ge307XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZVBhcnQgPSB0aGlzLnNlcmlhbGl6ZVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5mbHVzaENhY2hlcyA9IHRoaXMuZmx1c2hDYWNoZXMuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoYVJvb3RQYXJ0LCBwcmV0dHk9dHJ1ZSl7XG4gICAgICAgIHRoaXMuZmx1c2hDYWNoZXMoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgICAgICByb290SWQ6IGFSb290UGFydC5pZCxcbiAgICAgICAgICAgIHR5cGU6IGFSb290UGFydC50eXBlLFxuICAgICAgICAgICAgaWQ6IGFSb290UGFydC5pZFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBQYXJ0cyBhbmRcbiAgICAgICAgLy8gc3RvcmUgaW4gZmxhdCBsaXN0XG4gICAgICAgIHRoaXMuc2VyaWFsaXplUGFydChhUm9vdFBhcnQpO1xuXG4gICAgICAgIC8vIFdlIHNldCB0aGUgcmVzdWx0IG9iamVjdHMgcGFydHNcbiAgICAgICAgLy8gZGljdCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgY2FjaGVcbiAgICAgICAgcmVzdWx0LnBhcnRzID0gdGhpcy5fb2JqZWN0Q2FjaGU7XG5cbiAgICAgICAgLy8gRmluYWxseSwgd2UgY29udmVydCB0byBhIHN0cmluZyBhbmRcbiAgICAgICAgLy8gcmV0dXJuXG4gICAgICAgIGlmKHByZXR0eSl7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VyaWFsaXplUGFydChhUGFydCl7XG4gICAgICAgIC8vIFdlIHVzZSB0aGUgc2VyaWFsaXplIG1ldGhvZCBhdmFpbGFibGUgb25cbiAgICAgICAgLy8gYmFzZSBQYXJ0cywgcGFzc2luZyBpbiB0aGlzIHNlcmlhbGl6ZXIgaW5zdGFuY2VcbiAgICAgICAgLy8gYXMgdGhlIHNvbGUgYXJnXG4gICAgICAgIHRoaXMuX29iamVjdENhY2hlW2FQYXJ0LmlkXSA9IGFQYXJ0LnNlcmlhbGl6ZSh0aGlzKTtcbiAgICAgICAgYVBhcnQuc3VicGFydHMuZm9yRWFjaChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplUGFydChzdWJwYXJ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmx1c2hDYWNoZXMoKXtcbiAgICAgICAgdGhpcy5fb2JqZWN0Q2FjaGUgPSB7fTtcbiAgICB9XG59XG5cbmV4cG9ydCB7XG4gICAgU1RTZXJpYWxpemVyLFxuICAgIFNURGVzZXJpYWxpemVyXG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzIGZvciBzZXR0aW5nIHVwIHZhcmlvdXNcbiAqIHN0eWxlIHByb3BlcnRpZXNcbiAqL1xuXG5cbi8qKlxuICogQmFzaWMgc3R5bGUgcHJvcGVydGllcyBhcmUgdGhvc2VcbiAqIGNvbW1vbiB0byBhbGwgKHZpc3VhbCkgUGFydHNcbiAqL1xuY29uc3Qgc2lkZXMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5cbmNvbnN0IGFkZEJhc2ljU3R5bGVQcm9wcyA9ICh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnYmFja2dyb3VuZC10cmFuc3BhcmVuY3knLFxuICAgICAgICAxLFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InLFxuICAgICAgICBcInJnYigyNTUsIDI1NSwgMjU1KVwiLCAvLyB3aGl0ZSBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0cmFuc3BhcmVuY3knLFxuICAgICAgICAxLjAsXG4gICAgKTtcbiAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICAgICBgYm9yZGVyLSR7c30tc3R5bGVgLFxuICAgICAgICAgICAgJ3NvbGlkJ1xuICAgICAgICApO1xuICAgIH0pO1xuICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAwLFxuICAgICAgICApO1xuICAgIH0pO1xuICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgICAgIGBib3JkZXItJHtzfS1jb2xvcmAsXG4gICAgICAgICAgICBcInJnYigwLCAwLCAwKVwiLCAvLyBibGFja1xuICAgICAgICApO1xuICAgIH0pO1xuICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgICAgIGBib3JkZXItJHtzfS10cmFuc3BhcmVuY3lgLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctbGVmdCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctdG9wJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3NoYWRvdy1ibHVyJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3NoYWRvdy1zcHJlYWQnLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LWNvbG9yJyxcbiAgICAgICAgXCJyZ2IoMjM4LCAyMzgsIDIzOClcIiwgLy8gZ3JleVxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3NoYWRvdy10cmFuc3BhcmVuY3knLFxuICAgICAgICAxXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnY29ybmVyLXRvcC1sZWZ0LXJvdW5kJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2Nvcm5lci10b3AtcmlnaHQtcm91bmQnLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnY29ybmVyLWJvdHRvbS1sZWZ0LXJvdW5kJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2Nvcm5lci1ib3R0b20tcmlnaHQtcm91bmQnLFxuICAgICAgICAwXG4gICAgKTtcbn07XG5cbi8qKlxuICogU3R5bGUgcHJvcGVydGllcyBmb3IgUGFydHMgdGhhdCBjYW5cbiAqIGJlIG1vdmVkIGFuZCB0aGF0IGNhbiBoYXZlIGV4cGxpY2l0XG4gKiBkaW1lbnNpb25zLiBFeGFtcGxlczogYnV0dG9ucywgZmllbGRzLlxuICogRXhhbXBsZXMgb2YgdGhvc2UgdGhhdCBjYW4ndDogQ2FyZHMsIFN0YWNrc1xuICovXG5jb25zdCBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMgPSAodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2hpZGUnLFxuICAgICAgICBmYWxzZSxcbiAgICApO1xuICAgIC8vIHNldHRpbmcgd2lkdGggYW5kIGhlaWdodCB0byBudWxsXG4gICAgLy8gZWZmZWN0aXZlbHkgZm9yY2VzIHRvIHRoZSBkZWZhdWx0IHNpemVcbiAgICAvLyBvZiB0aGUgYnV0dG9uIHRvIGZpdCB0aGUgYnV0dG9uIG5hbWVcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICAxMDAsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgbnVsbCxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0b3AnLFxuICAgICAgICAwLFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2xlZnQnLFxuICAgICAgICAwLFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3JvdGF0ZScsXG4gICAgICAgIG51bGwsXG4gICAgKTtcblxuICAgIC8vIGhvcml6b250YWwtcmVzaXppbmcgc3BlY2lmaWVzIGEgc3RyYXRlZ3lcbiAgICAvLyBmb3IgaG93IHRoaXMgUGFydCBzaG91bGQgYWRqdXN0IGl0c1xuICAgIC8vIGhvcml6b250YWwgYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFyZW50LlxuICAgIC8vIFBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgLy8gKiByaWdpZCAtIFN0aWNrIHRvIHRoZSB0b3AsIGxlZnQsIHdpZHRoXG4gICAgLy8gYW5kIGhlaWdodCBwcm9wZXJ0aWVzIGFzIHRoZXkgYXJlIGV4cGxpY2l0bHlcbiAgICAvLyBzZXQ7XG4gICAgLy8gKiBzaHJpbmstd3JhcCAtIEJlY29tZSBsYXJnZSBlbm91Z2ggb24gdGhlIGhvcmktXG4gICAgLy8gem9udGFsIGF4aXMgb25seSB0byBmaXQgYW55IGNoaWxkIGNvbnRlbnRzO1xuICAgIC8vICogc3BhY2UtZmlsbCAtIEZpbGwgYXMgbXVjaCBhcyB3ZSBjYW4gaW4gdGhlXG4gICAgLy8gaG9yaXpvbnRhbCBheGlzIGluIHRoZSBwYXJlbnQgUGFydC5cbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnaG9yaXpvbnRhbC1yZXNpemluZycsXG4gICAgICAgICdyaWdpZCdcbiAgICApO1xuXG4gICAgLy8gdmVydGljYWwtcmVzaXppbmcgc3BlY2lmaWVzIGEgc3RyYXRlZ3lcbiAgICAvLyBmb3IgaG93IHRoaXMgUGFydCBzaG91bGQgYWRqdXN0IGl0c1xuICAgIC8vIHZlcnRpY2FsIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBhcmVudC5cbiAgICAvLyBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgIC8vICogcmlnaWQgLSBTdGljayB0byB0aGUgdG9wLCBsZWZ0LCB3aWR0aFxuICAgIC8vIGFuZCBoZWlnaHQgcHJvcGVydGllcyBhcyB0aGV5IGFyZSBleHBsaWNpdGx5XG4gICAgLy8gc2V0O1xuICAgIC8vICogc2hyaW5rLXdyYXAgLSBCZWNvbWUgbGFyZ2UgZW5vdWdoIG9uIHRoZSBob3JpLVxuICAgIC8vIHpvbnRhbCBheGlzIG9ubHkgdG8gZml0IGFueSBjaGlsZCBjb250ZW50cztcbiAgICAvLyAqIHNwYWNlLWZpbGwgLSBGaWxsIGFzIG11Y2ggYXMgd2UgY2FuIGluIHRoZVxuICAgIC8vIHZlcnRpY2FsIGF4aXMgaW4gdGhlIHBhcmVudCBQYXJ0LlxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd2ZXJ0aWNhbC1yZXNpemluZycsXG4gICAgICAgICdyaWdpZCdcbiAgICApO1xuXG4gICAgLy8gTWFyZ2luIHNwZWNpZmllcyBzb21lIHNwYWNlIGJldHdlZW4gdGhlXG4gICAgLy8gdGFyZ2V0IFBhcnQgYW5kIGFueSBvdGhlciBQYXJ0cyB0aGF0IG1pZ2h0XG4gICAgLy8gYmUgYWRqYWNlbnQgdG8gaXQgaW4gYSBjb21tb24gT3duZXIuIEl0IHdpbGxcbiAgICAvLyBub3QgYmUgaW4gZWZmZWN0IHdoZW4gdGhlIG93bmVyIGlzIHVzaW5nIGFcbiAgICAvLyBzdHJpY3QgbGF5b3V0LlxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0b3AtbWFyZ2luJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3JpZ2h0LW1hcmdpbicsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdib3R0b20tbWFyZ2luJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2xlZnQtbWFyZ2luJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG5cbiAgICAvLyBQaW5uaW5nIHNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdFxuICAgIC8vIGEgZ2l2ZW4gcGFydCBzaG91bGQgXCJzdGlja1wiIHRvIGFcbiAgICAvLyBwYXJ0aWN1bGFyIHNpZGUgb2YgaXRzIG93bmVyIFBhcnQuXG4gICAgLy8gUGlubmluZyBwcm9wZXJ0aWVzIG9ubHkgaGF2ZSBlZmZlY3RcbiAgICAvLyBpbnNpZGUgb2YgUGFydHMgd2l0aCBhIHN0cmljdCBsYXlvdXRcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICdwaW5uaW5nLXRvcCcsXG4gICAgICAgIHBpbm5pbmdTZXR0ZXIsXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlLCAvLyBub3QgcmVhZCBvbmx5XG4gICAgICAgIGZhbHNlIC8vIGRlZmF1bHQgdmFsdWVcblxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAncGlubmluZy1sZWZ0JyxcbiAgICAgICAgcGlubmluZ1NldHRlcixcbiAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgIHJldHVybiBwcm9wT2JqZWN0Ll92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2UsIC8vIG5vdCByZWFkIG9ubHlcbiAgICAgICAgZmFsc2UgLy8gZGVmYXVsdCB2YWx1ZVxuXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICdwaW5uaW5nLWJvdHRvbScsXG4gICAgICAgIHBpbm5pbmdTZXR0ZXIsXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlLCAvLyBub3QgcmVhZCBvbmx5XG4gICAgICAgIGZhbHNlIC8vIGRlZmF1bHQgdmFsdWVcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgJ3Bpbm5pbmctcmlnaHQnLFxuICAgICAgICBwaW5uaW5nU2V0dGVyLFxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHByb3BPYmplY3QuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICBmYWxzZSAvLyBkZWZhdWx0IHZhbHVlXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgIC8vIFBvc3NpYmxlIHZhbHVlcyBmb3IgdGhlIGNvbXBvdW5kXG4gICAgICAgIC8vICdwaW5uaW5nJyBwcm9wZXJ0eSBhcmU6XG4gICAgICAgIC8vICpcIm5vbmVcIiBvciBudWxsXG4gICAgICAgIC8vICp0b3BcbiAgICAgICAgLy8gKnRvcC1yaWdodFxuICAgICAgICAvLyAqdG9wLWxlZnRcbiAgICAgICAgLy8gKmJvdHRvbVxuICAgICAgICAvLyAqYm90dG9tLXJpZ2h0XG4gICAgICAgIC8vICpib3R0b20tbGVmdFxuICAgICAgICAvLyAqbGVmdFxuICAgICAgICAvLyAqcmlnaHRcbiAgICAgICAgJ3Bpbm5pbmcnLFxuICAgICAgICAvLyBTZXR0ZXJcbiAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWx1ZSl7XG4gICAgICAgICAgICBpZighdmFsdWUgfHwgdmFsdWUgPT0gXCJub25lXCIpe1xuICAgICAgICAgICAgICAgIFsndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJ10uZm9yRWFjaChzaWRlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpbiA9IGBwaW5uaW5nLSR7c2lkZX1gO1xuICAgICAgICAgICAgICAgICAgICBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlubmluZ0FkanVzdChwcm9wT3duZXIsIHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBHZXR0ZXJcbiAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCB0b3AgPSBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBwcm9wT3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctdG9wJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBwcm9wT3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctYm90dG9tJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLWxlZnQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLXJpZ2h0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGlmKHRvcCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ3RvcCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGJvdHRvbSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2JvdHRvbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobGVmdCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2xlZnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihyaWdodCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignLScpO1xuICAgICAgICB9XG4gICAgKTtcbn07XG5cbi8qKlxuICogU3R5bGUgcHJvcGVydGllcyBmb3IgUGFydHMgdGhhdCBkaXNwbGF5XG4gKiB0ZXh0XG4gKi9cbmNvbnN0IGFkZFRleHRTdHlsZVByb3BzID0gKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LWFsaWduJyxcbiAgICAgICAgJ2xlZnQnLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtZm9udCcsXG4gICAgICAgICdkZWZhdWx0JyxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LWNvbG9yJyxcbiAgICAgICAgXCJyZ2IoMCwgMCwgMClcIiwgLy8gYmxhY2tcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LXRyYW5zcGFyZW5jeScsXG4gICAgICAgIDEsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1zdHlsZScsXG4gICAgICAgICdwbGFpbicsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1ib2xkJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1pdGFsaWMnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LXNpemUnLFxuICAgICAgICAxNSxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xufTtcblxuLyoqXG4gKiBCYXNpYyBsYXlvdXQgc3R5bGVzIGFyZSB0aG9zZSBwZXJ0YWluaW5nXG4gKiB0byB0aGUgcG9zaXRpb25pbmcgYW5kIHJlc2l6aW5nIG9mIHN1YnBhcnRzLlxuICogRXhhbXBsZXMgaW5jbHVkZSBDYXJkcyBhbmQgQXJlYVxuICovXG5jb25zdCBhZGRMYXlvdXRTdHlsZVByb3BzID0gKHRhcmdldCkgPT4ge1xuICAgIC8vIFRoZSAnbGF5b3V0JyBwcm9wZXJ0eSBpc1xuICAgIC8vIG9uZSBvZiB0d28gc3RyaW5nczpcbiAgICAvLyBzdHJpY3QgLSBFcXVpdmFsZW50IHRvIHRoZSBhYnNvbHV0ZVxuICAgIC8vIGxheW91dCBiYXNlZCBzdHJpY3RseSBvbiBjb29yZGluYXRlc1xuICAgIC8vIGxpc3QgLSBXaWxsIGZvcmNlIGl0ZW1zIGludG8gZWl0aGVyIGEgcm93XG4gICAgLy8gb3IgY29sdW1uIGxpc3QsIGJhc2VkIG9uIHRoZSBwYWlyaW5nIHdpdGhcbiAgICAvLyB0aGUgJ2xpc3REaXJlY3Rpb24nIHByb3BlcnR5XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgJ2xheW91dCcsXG4gICAgICAgICdzdHJpY3QnXG4gICAgKTtcblxuICAgIC8vIGxpc3QtZGlyZWN0aW9uIHNwZWNpZmllcyByb3cgb3IgY29sdW1uXG4gICAgLy8gYW5kIHdpbGwgb25seSBoYXZlIGFuIGVmZmVjdCB3aGVudCB0aGVcbiAgICAvLyBsYXlvdXQgcHJvcGVydHkgaXMgc2V0IHRvICdsaXN0J1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICdsaXN0LWRpcmVjdGlvbicsXG4gICAgICAgICdyb3cnXG4gICAgKTtcblxuICAgIC8vIFdyYXBwaW5nIHNwZWNpZmllcyB3aGV0aGVyIGEgbGlzdCBzaG91bGRcbiAgICAvLyB3cmFwIGFsb25nIGl0cyBkb21pbmFudCBkaW1lbnNpb24gKHJvdyBvciBjb2x1bW4pXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgJ2xpc3Qtd3JhcHBpbmcnLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBQYWRkaW5nIHNwZWNpZmllcyBzb21lIHNwYWNlIGZyb20gdGhlXG4gICAgLy8gYm9yZGVyIG9mIHRoZSB0YXJnZXQgUGFydCB0byB0aGUgYmVnaW5uaW5nXG4gICAgLy8gb2YgdGhlIGxheW91dCBvZiBhbnkgc3VicGFydHMuXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RvcC1wYWRkaW5nJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3JpZ2h0LXBhZGRpbmcnLFxuICAgICAgICBudWxsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnYm90dG9tLXBhZGRpbmcnLFxuICAgICAgICBudWxsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnbGVmdC1wYWRkaW5nJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG5cbiAgICAvLyBMaXN0IGFsaWdubWVudCBkZXNjcmliZXMgaG93IGVsZW1lbnRzIGluXG4gICAgLy8gYSBsaXN0IGxheW91dCBzaG91bGQgYWxpZ24gdGhlbXNlbHZlcyBhbG9uZ1xuICAgIC8vIHRoZSBkb21pbmFudCBkaW1lbnNpb24gKHJvdyBvciBjb2x1bW4pXG4gICAgLy8gVGhleSBhcmUgZXNzZW50aWFsbHkgcHJveGllcyBmb3IgYWxpZ24taXRlbXNcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAnbGlzdC1hbGlnbm1lbnQnLFxuICAgICAgICBudWxsXG4gICAgKTtcblxuICAgIC8vIExpc3QgZGlzdHJpYnV0aW9uIGRlc2NyaWJlcyBob3cgZWxlbWVudHNcbiAgICAvLyBpbiBhIGxpc3QgbGF5b3V0IHNob3VsZCBkaXN0cmlidXRlIHRoZW1zZWx2ZXNcbiAgICAvLyBhY3Jvc3Mgb3IgYWxvbmcgdGhlIGRvbWluYW50IGRpbWVuc2lvblxuICAgIC8vIChyb3cgb3IgY29sdW1uKVxuICAgIC8vIFRoaXMgaXMgZXNzZW50aWFsbHkgYSB3cmFwcGVyIGZvciBqdXN0aWZ5LWNvbnRlbnRcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAnbGlzdC1kaXN0cmlidXRpb24nLFxuICAgICAgICBudWxsXG4gICAgKTtcbn07XG5cbi8qKlxuICAqIEhFTFBFUlNcbiAqKi9cblxuY29uc3QgcGlubmluZ1NldHRlciA9IChwcm9wT3duZXIsIHByb3BPYmplY3QsIHZhbHVlKSA9PiB7XG4gICAgbGV0IHNpZGUgPSBwcm9wT2JqZWN0Lm5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgIGxldCB0b3BMZWZ0O1xuICAgIHN3aXRjaCAoc2lkZSl7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIHRvcExlZnQgPSBcImxlZnRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICB0b3BMZWZ0ID0gXCJ0b3BcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdG9wTGVmdCA9IHNpZGU7XG4gICAgfVxuICAgIC8vIHdlJ2xsIG5lZWQgdG8gZml4IGFuZCB1bi1maXggdGhlIGNvcnJlc3BvbmRpbmcgdG9wIG9yIGxlZnQgcHJvcGVydHkgZGVwZW5kaW5nXG4gICAgLy8gb24gd2hldGhlciB2YWx1ZSBpcyB0cnVlIG9mIGZhbHNlLCByZXNwZWN0aXZlbHlcbiAgICBsZXQgcHJvcCA9IHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChcbiAgICAgICAgdG9wTGVmdCBcbiAgICApO1xuICAgIGxldCBvcHBvc2l0ZVNpZGU7XG4gICAgc3dpdGNoIChzaWRlKXtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBvcHBvc2l0ZVNpZGUgPSBcInJpZ2h0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICBvcHBvc2l0ZVNpZGUgPSBcImxlZnRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBvcHBvc2l0ZVNpZGUgPSBcImJvdHRvbVwiO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIG9wcG9zaXRlU2lkZSA9IFwidG9wXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZih2YWx1ZSl7XG4gICAgICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHBpbm5pbmctYm90dG9tIGlzIGZhbHNlXG4gICAgICAgIHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgYHBpbm5pbmctJHtvcHBvc2l0ZVNpZGV9YCxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHByb3AucmVhZE9ubHkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSB2YWx1ZSBiYWNrIHRvIHRyaWdnZXIgYSBub3RpZmljYXRpb25cbiAgICAgICAgcHJvcC5zZXRWYWx1ZShwcm9wT3duZXIsIHByb3AuX3ZhbHVlKTtcbiAgICAgICAgcHJvcC5yZWFkT25seSA9IGZhbHNlO1xuICAgIH1cbiAgICBwcm9wT2JqZWN0Ll92YWx1ZSA9IHZhbHVlO1xufTtcblxuY29uc3QgcGlubmluZ0FkanVzdCA9IChvd25lciwgdmFsdWUpID0+IHtcbiAgICBsZXQgc2lkZXMgPSBbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuICAgIHNpZGVzLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICAgIGlmKHZhbHVlLnN0YXJ0c1dpdGgoc2lkZSkpe1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICBgcGlubmluZy0ke3NpZGV9YCxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICBgcGlubmluZy0ke3NpZGV9YCxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYodmFsdWUuaW5jbHVkZXMoXCItXCIpKXtcbiAgICAgICAgaWYodmFsdWUuZW5kc1dpdGgoJ2xlZnQnKSl7XG4gICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLWxlZnQnLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLXJpZ2h0JyxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlLmVuZHNXaXRoKCdyaWdodCcpKXtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctbGVmdCcsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLXJpZ2h0JyxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzLFxuICAgIGFkZExheW91dFN0eWxlUHJvcHNcbn07XG4iLCIvKipcbiAqIFN0eWxlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIHJlc3BvbnNpYmxlIGZvciBjb252ZXJ0aW5nXG4gKiBTaW1wbGVUYWxrIHZpc3VhbCBzdHlsaW5nIHRvIGEgZGljdFxuICogT2JqZWN0IG9mIENTUyBKYXZhU2NyaXB0IHR5cGUga2V5LXZhbHVlIHBhaXJzXG4gKi9cblxuLyoqIEkgc3R5bGUgdGhlIHN0eWxlT2JqXG4gKiBzdHlsZU9iajogY3NzIEphdmFTY3JpcHQga2V5OnZhbHVlIHBhaXJzXG4gKiBwcm9wZXJ0eU5hbWU6IChTaW1wbGVUYWxrKSBzdHlsaW5nIHByb3BlcnR5IG5hbWVcbiAqIHByb3BlcnR5VmFsdWU6IChTaW1wbGVUYWxrKSBzdHlsaW5nIHByb3BlcnR5IHZhbHVlXG4gKi9cblxuY29uc3QgY3NzU3R5bGVyID0gKHN0eWxlT2JqLCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpID0+IHtcbiAgICBzd2l0Y2gocHJvcGVydHlOYW1lKXtcblxuICAgIGNhc2UgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgIF9jb2xvclRvUkdCQShzdHlsZU9ialtcImJhY2tncm91bmRDb2xvclwiXSwgcHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeVwiOlxuICAgICAgICAvLyBoZXJlIHdlIHNldCB0aGUgQWxwaGEgdmFsdWUgb2YgdGhlIGN1cnJlbnQgc3R5bGVPYmpbXCJiYWNrZ3JvdW5kQ29sb3JcIl0gcmdiYVxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiYmFja2dyb3VuZENvbG9yXCIsICBfY29sb3JUcmFuc3BhcmVuY3lUb1JHQkEoc3R5bGVPYmpbXCJiYWNrZ3JvdW5kQ29sb3JcIl0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiYm9yZGVyLXRvcC1zdHlsZVwiOlxuICAgIGNhc2UgXCJib3JkZXItYm90dG9tLXN0eWxlXCI6XG4gICAgY2FzZSBcImJvcmRlci1sZWZ0LXN0eWxlXCI6XG4gICAgY2FzZSBcImJvcmRlci1yaWdodC1zdHlsZVwiOiB7XG4gICAgICAgIGxldCBzID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgYm9yZGVyLSR7c30tc3R5bGVgLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgXCJib3JkZXItdG9wLXdpZHRoXCI6XG4gICAgY2FzZSBcImJvcmRlci1ib3R0b20td2lkdGhcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWxlZnQtd2lkdGhcIjpcbiAgICBjYXNlIFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCI6IHtcbiAgICAgICAgbGV0IHMgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtzfS13aWR0aGAsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgXCJib3JkZXItdG9wLWNvbG9yXCI6XG4gICAgY2FzZSBcImJvcmRlci1ib3R0b20tY29sb3JcIjpcbiAgICBjYXNlIFwiYm9yZGVyLXRvcC1jb2xvclwiOlxuICAgIGNhc2UgXCJib3JkZXItcmlnaHQtY29sb3JcIjoge1xuICAgICAgICBsZXQgcyA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYGJvcmRlci0ke3N9LWNvbG9yYCwgIF9jb2xvclRvUkdCQShzdHlsZU9ialtgYm9yZGVyLSR7c30tY29sb3JgXSwgcHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFwiYm9yZGVyLXRvcC10cmFuc3BhcmVuY3lcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWJvdHRvbS10cmFuc3BhcmVuY3lcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWxlZnQtdHJhbnNwYXJlbmN5XCI6XG4gICAgY2FzZSBcImJvcmRlci1yaWdodC10cmFuc3BhcmVuY3lcIjoge1xuICAgICAgICBsZXQgcyA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYGJvcmRlci0ke3N9LWNvbG9yYCwgIF9jb2xvclRyYW5zcGFyZW5jeVRvUkdCQShzdHlsZU9ialtgYm9yZGVyLSR7c30tY29sb3JgXSwgcHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFwiY29ybmVyLXRvcC1sZWZ0LXJvdW5kXCI6XG4gICAgY2FzZSBcImNvcm5lci10b3AtcmlnaHQtcm91bmRcIjpcbiAgICBjYXNlIFwiY29ybmVyLWJvdHRvbS1sZWZ0LXJvdW5kXCI6XG4gICAgY2FzZSBcImNvcm5lci1ib3R0b20tcmlnaHQtcm91bmRcIjp7XG4gICAgICAgIGxldCBjMSA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIGxldCBjMiA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMl07XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYGJvcmRlci0ke2MxfS0ke2MyfS1yYWRpdXNgLCAgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFwic2hhZG93LWxlZnRcIjpcbiAgICBjYXNlIFwic2hhZG93LXRvcFwiOlxuICAgIGNhc2UgXCJzaGFkb3ctYmx1clwiOlxuICAgIGNhc2UgXCJzaGFkb3ctc3ByZWFkXCI6XG4gICAgY2FzZSBcInNoYWRvdy1jb2xvclwiOlxuICAgIGNhc2UgXCJzaGFkb3ctdHJhbnNwYXJlbmN5XCI6XG4gICAgICAgIGxldCBzaGFkb3dQcm9wID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICAgICAgbGV0IFtsZWZ0LCB0b3AsIGJsdXIsIHNwcmVhZCwgY29sb3JdID0gX2Nzc0JveFNoYWRvdyhzdHlsZU9ialtcImJveC1zaGFkb3dcIl0pO1xuICAgICAgICBzd2l0Y2goc2hhZG93UHJvcCl7XG4gICAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICAgICAgY29sb3IgPSBfY29sb3JUb1JHQkEoY29sb3IsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgICAgIGNvbG9yID0gX2NvbG9yVHJhbnNwYXJlbmN5VG9SR0JBKGNvbG9yLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgbGVmdCA9IF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgIHRvcCA9IF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgICAgICBibHVyID0gX2ludFRvUHgocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNwcmVhZFwiOlxuICAgICAgICAgICAgc3ByZWFkID0gX2ludFRvUHgocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiYm94LXNoYWRvd1wiLCBgJHtsZWZ0fSAke3RvcH0gJHtibHVyfSAke3NwcmVhZH0gJHtjb2xvcn1gKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1jb2xvclwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiY29sb3JcIiwgIF9jb2xvclRvUkdCQShzdHlsZU9ialtcImNvbG9yXCJdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtZm9udFwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udEZhbWlseVwiLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtc2l6ZVwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udFNpemVcIiwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtYWxpZ25cIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcInRleHRBbGlnblwiLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtYm9sZFwiOlxuICAgICAgICBpZihwcm9wZXJ0eVZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJmb250LXdlaWdodFwiLCAgXCJib2xkXCIpO1xuICAgICAgICB9IGVsc2UgaWYocHJvcGVydHlWYWx1ZSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnQtd2VpZ2h0XCIsICBcIm5vcm1hbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWl0YWxpY1wiOlxuICAgICAgICBpZihwcm9wZXJ0eVZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJmb250LXN0eWxlXCIsICBcIml0YWxpY1wiKTtcbiAgICAgICAgfSBlbHNlIGlmKHByb3BlcnR5VmFsdWUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJmb250LXN0eWxlXCIsICBcIm5vcm1hbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LXVuZGVybGluZVwiOlxuICAgICAgICBpZihwcm9wZXJ0eVZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0ZXh0RGVjb3JhdGlvblwiLCAgXCJ1bmRlcmxpbmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1zdHJpa2V0aHJvdWdoXCI6XG4gICAgICAgIGlmKHByb3BlcnR5VmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcInRleHREZWNvcmF0aW9uXCIsICBcImxpbmUtdGhyb3VnaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LXRyYW5zcGFyZW5jeVwiOlxuICAgICAgICAvLyBoZXJlIHdlIHNldCB0aGUgQWxwaGEgdmFsdWUgb2YgdGhlIGN1cnJlbnQgc3R5bGVPYmpbXCJjb2xvclwiXSByZ2JhXG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJjb2xvclwiLCAgX2NvbG9yVHJhbnNwYXJlbmN5VG9SR0JBKHN0eWxlT2JqW1wiY29sb3JcIl0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0b3BcIiwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwibGVmdFwiLCAgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwid2lkdGhcIiwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJoZWlnaHRcIiwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwibGVmdC1tYXJnaW5cIjpcbiAgICBjYXNlIFwicmlnaHQtbWFyZ2luXCI6XG4gICAgY2FzZSBcImJvdHRvbS1tYXJnaW5cIjpcbiAgICBjYXNlIFwidG9wLW1hcmdpblwiOlxuICAgICAgICBsZXQgbWFyZ2luU2lkZSA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMF07XG4gICAgICAgIG1hcmdpblNpZGUgPSBgJHttYXJnaW5TaWRlWzBdLnRvVXBwZXJDYXNlKCl9JHttYXJnaW5TaWRlLnNsaWNlKDEpfWA7XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYG1hcmdpbiR7bWFyZ2luU2lkZX1gLCBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImxlZnQtcGFkZGluZ1wiOlxuICAgIGNhc2UgXCJyaWdodC1wYWRkaW5nXCI6XG4gICAgY2FzZSBcImJvdHRvbS1wYWRkaW5nXCI6XG4gICAgY2FzZSBcInRvcC1wYWRkaW5nXCI6XG4gICAgICAgIGxldCBwYWRkaW5nU2lkZSA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMF07XG4gICAgICAgIHBhZGRpbmdTaWRlID0gYCR7cGFkZGluZ1NpZGVbMF0udG9VcHBlckNhc2UoKX0ke3BhZGRpbmdTaWRlLnNsaWNlKDEpfWA7XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYHBhZGRpbmcke3BhZGRpbmdTaWRlfWAsIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1zdHlsZVwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidGV4dFN0eWxlXCIsICBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwicm90YXRlXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0cmFuc2Zvcm1cIiwgIF9pbnRUb1JvdGF0ZURlZyhwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyYW5zcGFyZW5jeVwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwib3BhY2l0eVwiLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImhpZGVcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBzdHlsZU9ialtcImRpc3BsYXlcIl0gPSBcIm5vbmVcIjtcbiAgICAgICAgfSBlbHNlIGlmKHByb3BlcnR5VmFsdWUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIHN0eWxlT2JqW1wiZGlzcGxheVwiXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cblxuICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGZvciB0aGUgZGVmYXVsdCB3ZSBzaW1wbHkgYWxsb3cgU1Qgc3R5bGUgbmFtZXMgdG8gbWFwIDEtMVxuICAgICAgICAvLyB0byBDU1MvSlMgc3R5bGUgbmFtZXMuIFRoaXMgaXMgb25seSBzb21ld2hhdCBzYWZlLCBzaW5jZSB0aGUgRE9NXG4gICAgICAgIC8vIHdpbGwgc2ltcGx5IGlnbm9yZSBub25zZW5zZSBuYW1lcyB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLiBCdXQgaXRcbiAgICAgICAgLy8gZG9lcyBhbGxvdyB1cyB0byBhdm9pZCB3cml0aW5nIGEgcnVsZSBmb3IgZXZlcnkgdGVybSAoZXhhbXBsZTogd2lkdGgsXG4gICAgICAgIC8vIGhlaWdodCwgdG9wLCBsZWZ0IGV0YylcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBwcm9wZXJ0eU5hbWUsICBwcm9wZXJ0eVZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlT2JqO1xuXG59O1xuXG4vLyBJbiBvcmRlciB0byBhdm9pZCBjbGFzaGluZyB3aXRoIHZpZXdzIGludGVyYWN0aW5nXG4vLyB0aGUgc3R5bGUgYXR0cmlidXRlIGRpcmVjdGx5IHdlIGlnbm9yZSBldmVyeXRoaW5nIHRoYXRcbi8vIGlzIGVpdGhlciBudWxsIG9yIHVuZGVmaW5lZFxuLy8gVE9ETyByZXZpZXcgdGhpcyBkZWNpc2lvbiFcbmNvbnN0IF9zZXRPck5vdCA9IChzdHlsZU9iaiwgbmFtZSwgdmFsdWUpID0+IHtcbiAgICBpZih2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgc3R5bGVPYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG59O1xuXG5jb25zdCBfaW50VG9Sb3RhdGVEZWcgPSAobikgPT4ge1xuICAgIGlmKG4gIT09IG51bGwgJiYgbiAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgaWYodHlwZW9mKG4pID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgICAgIG4gPSBuLnNwbGl0KFwiZGVnXCIpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgcm90YXRlKCR7bn1kZWcpYDtcbiAgICB9XG59O1xuXG5cbmNvbnN0IF9pbnRUb1B4ID0gKG4pID0+IHtcbiAgICBpZihuICE9PSBudWxsICYmIG4gIT09IHVuZGVmaW5lZCl7XG4gICAgICAgIGlmKHR5cGVvZihuKSA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICBpZihuID09IFwiZmlsbFwiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIxMDAlXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYoW1widGhpblwiLCBcIm1lZGl1bVwiLCBcInRoaWNrXCJdLmluZGV4T2YobikgPiAtMSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbi5zcGxpdChcInB4XCIpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtufXB4YDtcbiAgICB9XG59O1xuXG4vLyBDb252ZXJ0IGNvbG9ycyB0byByZ2JhXG4vLyBjaGFuZ2UgYSBjc3MgY29sb3IgUkdCIHZhbHVlcywgcHJlc2VydmluZyB0aGUgQShscGhhKSB2YWx1ZVxuY29uc3QgX2NvbG9yVG9SR0JBID0gKGNzc0NvbG9yLCBTVENvbG9yKSA9PiB7XG4gICAgaWYoIVNUQ29sb3Ipe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByLCBnLCBiLCBhLCBfO1xuICAgIC8vIFNUIGNvbG9ycyBhcmUgUkdCXG4gICAgaWYoU1RDb2xvci5zdGFydHNXaXRoKFwicmdiXCIpKXtcbiAgICAgICAgW3IsIGcsIGJdID0gU1RDb2xvci5tYXRjaCgvXFxkKy9nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29sb3JJbmZvID0gYmFzaWNDU1NDb2xvcnNbU1RDb2xvcl07XG4gICAgICAgIGlmKGNvbG9ySW5mbyl7XG4gICAgICAgICAgICByID0gY29sb3JJbmZvW1wiclwiXTtcbiAgICAgICAgICAgIGcgPSBjb2xvckluZm9bXCJnXCJdO1xuICAgICAgICAgICAgYiA9IGNvbG9ySW5mb1tcImJcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoY3NzQ29sb3Ipe1xuICAgICAgICBbXywgXywgXywgYV0gPSBjc3NDb2xvci5tYXRjaCgvW1xcZFxcLl0rL2cpO1xuICAgICAgICAvLyBpZiBBbHBoYSBpcyBub3QgZGVmaW5lZCB0aGVuIHdlIHNldCBpdCB0byAxXG4gICAgICAgIC8vIGRlZmF1bHQgZm9yIGJyb3dzZXJzXG4gICAgfVxuICAgIGlmKCFhKXtcbiAgICAgICAgYSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2F9KWA7XG59XG5cbi8vIGNoYW5nZSB0aGUgQShhbHBoYSkgdmFsdWUsIHByZXNlcnZpbmcgdGhlIFJHQiB2YWx1ZXNcbmNvbnN0IF9jb2xvclRyYW5zcGFyZW5jeVRvUkdCQSA9IChjc3NDb2xvciwgdFZhbHVlKSA9PiB7XG4gICAgaWYoIWNzc0NvbG9yKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByLCBnLCBiO1xuICAgIGxldCBtYXBwZWRDb2xvciA9IGJhc2ljQ1NTQ29sb3JzW2Nzc0NvbG9yXTtcbiAgICBpZihtYXBwZWRDb2xvcil7XG4gICAgICAgIHIgPSBtYXBwZWRDb2xvci5yO1xuICAgICAgICBnID0gbWFwcGVkQ29sb3IuZztcbiAgICAgICAgYiA9IG1hcHBlZENvbG9yLmI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgW3IsIGcsIGJdID0gY3NzQ29sb3IubWF0Y2goL1xcZCsvZyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke3RWYWx1ZX0pYDtcbn1cblxuLy8gQWRkIG1vcmUgY29sb3JzIGFzIG5lZWRlZFxuY29uc3QgYmFzaWNDU1NDb2xvcnMgPSB7XG4gICAgYmxhY2s6IHtoZXg6IFwiIzAwMDAwMFwiLCByOiAwLCBnOiAwLCBiOiAwfSxcblx0XHRzaWx2ZXI6IHtoZXg6IFwiI0MwQzBDMFwiLCByOiAxOTIsIGc6IDE5MiwgYjogMTkyfSxcblx0XHRncmF5OiB7aGV4OiBcIiM4MDgwODBcIiwgcjogMTI4LCBnOiAxMjgsIGI6IDEyOH0sXG5cdFx0d2hpdGU6IHtoZXg6IFwiI0ZGRkZGRlwiLCByOiAyNTUsIGc6IDI1NSwgYjogMjU1fSxcblx0XHRtYXJvb246IHtoZXg6IFwiIzgwMDAwMFwiLCByOiAxMjgsIGc6IDAsIGI6IDB9LFxuXHRcdHJlZDoge2hleDogXCIjRkYwMDAwXCIsIHI6IDI1NSwgZzogMCwgYjogMH0sXG5cdFx0cHVycGxlOiB7aGV4OiBcIiM4MDAwODBcIiwgcjogMTI4LCBnOiAwLCBiOiAxMjh9LFxuXHRcdGZ1Y2hzaWE6IHtoZXg6IFwiI0ZGMDBGRlwiLCByOiAyNTUsIGc6IDAsIGI6IDI1NX0sXG5cdFx0Z3JlZW46IHtoZXg6IFwiIzAwODAwMFwiLCByOiAwLCBnOiAxMjgsIGI6IDB9LFxuXHRcdGxpbWU6IHtoZXg6IFwiIzAwRkYwMFwiLCByOiAwLCBnOiAyNTUsIGI6IDB9LFxuXHRcdG9saXZlOiB7aGV4OiBcIiM4MDgwMDBcIiwgcjogMTI4LCBnOiAxMjgsIGI6IDB9LFxuXHRcdHllbGxvdzoge2hleDogXCIjRkZGRjAwXCIsIHI6IDI1NSwgZzogMjU1LCBiOiAwfSxcblx0XHRuYXZ5OiB7aGV4OiBcIiMwMDAwODBcIiwgcjogMCwgZzogMCwgYjogMTI4fSxcblx0XHRibHVlOiB7aGV4OiBcIiMwMDAwRkZcIiwgcjogMCwgZzogMCwgYjogMjU1fSxcblx0XHR0ZWFsOiB7aGV4OiBcIiMwMDgwODBcIiwgcjogMCwgZzogMTI4LCBiOiAxMjh9LFxuXHRcdGFxdWE6IHtoZXg6IFwiIzAwRkZGRlwiLCByOiAwLCBnOiAyNTUsIGI6IDI1NX0sXG59O1xuXG4vLyB0YWtlIHRoZSBjc3MgYm94LXNoYWRvdyBwcm9wZXJ0eSBhbmQgcmV0dXJuIGl0c1xuLy8gY29tcG9uZW50cyAob2Zmc2V0LXksIG9mZnNldC14LCBibHVyLCBzcHJlYWQgYW5kIGNvbG9yKVxuLy8gaWYgdGhlIHZhbHVlIGlzIG5vdCBkZWZpbmVkIHJldHVybiBhIGRlZmF1bHRcbmNvbnN0IF9jc3NCb3hTaGFkb3cgPSAoY3NzUHJvcFZhbHVlKSA9PntcbiAgICBpZighY3NzUHJvcFZhbHVlKXtcbiAgICAgICAgcmV0dXJuIFtcIjBweFwiLCBcIjBweFwiLCBcIjBweFwiLCBcIjBweFwiLCBcInJnYmEoMCwgMCwgMCwgMSlcIl07XG4gICAgfVxuICAgIGxldCBbaW50VmFsdWVzLCByZ2JhXSA9IGNzc1Byb3BWYWx1ZS5zcGxpdChcIiByZ2JhXCIpO1xuICAgIGxldCBbbGVmdCwgdG9wLCBibHVyLCBzcHJlYWRdID0gaW50VmFsdWVzLnNwbGl0KFwiIFwiKTtcbiAgICByZXR1cm4gW2xlZnQsIHRvcCwgYmx1ciwgc3ByZWFkLCBgcmdiYSR7cmdiYX1gXTtcbn1cblxuZXhwb3J0IHtcbiAgICBjc3NTdHlsZXIsXG4gICAgY3NzU3R5bGVyIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEFyZWFWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgd2ViY29tcG9uZW50IHJlcHJlc2VudGF0aW9uXG4gKiBvZiBhbiBBcmVhLCB3aGljaCBpcyBhIGdyb3VwaW5nIG9mXG4gKiBQYXJ0cyB0aGF0IGhhdmUgc29tZSBraW5kIG9mIGxheW91dFxuICogc3BlY2lmaWVkXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG4gICAgICAgICAgICAgICAgPHN0eWxlPlxuICAgICAgICAgICAgICAgICNhcmVhLXdyYXBwZXIge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmhlcml0O1xuICAgICAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgZmxleC13cmFwOiBpbmhlcml0O1xuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24tY29udGVudDogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBpbmhlcml0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAuY2xpcCB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLmFsbG93LXNjcm9sbCB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L3N0eWxlPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJhcmVhLXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5gO1xuXG5jbGFzcyBBcmVhVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuY2xpcHBpbmdDaGFuZ2VkID0gdGhpcy5jbGlwcGluZ0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbGxvd1Njcm9sbGluZ0NoYW5nZWQgPSB0aGlzLmFsbG93U2Nyb2xsaW5nQ2hhbmdlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFByb3AgY2hhbmdlIGhhbmRsZXJzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjbGlwcGluZycsIHRoaXMuY2xpcHBpbmdDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2FsbG93LXNjcm9sbGluZycsIHRoaXMuYWxsb3dTY3JvbGxpbmdDaGFuZ2VkKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIGxldCBjbGlwcGluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcImNsaXBwaW5nXCJcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGFsbG93U2Nyb2xsaW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwiYWxsb3ctc2Nyb2xsaW5nXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbGlwcGluZ0NoYW5nZWQoY2xpcHBpbmcsIHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB0aGlzLmFsbG93U2Nyb2xsaW5nQ2hhbmdlZChhbGxvd1Njcm9sbGluZywgdGhpcy5tb2RlbC5pZCk7XG4gICAgfVxuXG4gICAgY2xpcHBpbmdDaGFuZ2VkKG5ld1ZhbCwgaWQpe1xuICAgICAgICBsZXQgd3JhcHBlciA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2FyZWEtd3JhcHBlcicpO1xuICAgICAgICBpZihuZXdWYWwgPT0gdHJ1ZSl7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2FsbG93LXNjcm9sbCcpO1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjbGlwJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2NsaXAnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFsbG93U2Nyb2xsaW5nQ2hhbmdlZChuZXdWYWwsIGlkKXtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdhcmVhLXdyYXBwZXInKTtcbiAgICAgICAgaWYobmV3VmFsID09IHRydWUpe1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdjbGlwJyk7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2FsbG93LXNjcm9sbCcpO1xuICAgICAgICAgICAgLy8gdGhpcy5jbGFzc0xpc3QuYWRkKCdvdXRlci1hbGxvdy1zY3JvbGwnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnb3V0ZXItYWxsb3ctc2Nyb2xsJyk7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2FsbG93LXNjcm9sbCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ29udGV4dE1lbnVJdGVtcyhjb250ZXh0TWVudSl7XG4gICAgICAgIGNvbnRleHRNZW51LmFkZFNwYWNlcigpO1xuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdsYXlvdXQnXG4gICAgICAgICk7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2xpc3QtZGlyZWN0aW9uJ1xuICAgICAgICApO1xuICAgICAgICBpZihsYXlvdXQgIT0gJ2xpc3QnKXtcbiAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgIFwiU2V0IExheW91dCB0byBMaXN0XCIsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF5b3V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICBcIlNldCBMYXlvdXQgdG8gU3RyaWN0XCIsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF5b3V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpY3QnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSAncm93Jyl7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiU2V0IExpc3QgRGlyZWN0aW9uIHRvIENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0LWRpcmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbidcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgXCJTZXQgTGlzdCBEaXJlY3Rpb24gdG8gUm93XCIsXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3QtZGlyZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncm93J1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEFyZWFWaWV3LFxuICAgIEFyZWFWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IGxpbmtJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxpbmtcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEwIDE0YTMuNSAzLjUgMCAwIDAgNSAwbDQgLTRhMy41IDMuNSAwIDAgMCAtNSAtNWwtLjUgLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDEwYTMuNSAzLjUgMCAwIDAgLTUgMGwtNCA0YTMuNSAzLjUgMCAwIDAgNSA1bC41IC0uNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuOmhvc3Qge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHBhZGRpbmc6IDFweDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbi53cmFwcGVye1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG59XG48L3N0eWxlPlxuPGRpdiBjbGFzcz1cIndyYXBwZXJcIj5cbiAgICA8YXVkaW8+PC9hdWRpbz5cbiAgICA8c3BhbiBjbGFzcz1cIm5hbWVcIj48L3NwYW4+XG4gICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLW11c2ljXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgIDxjaXJjbGUgY3g9XCI2XCIgY3k9XCIxN1wiIHI9XCIzXCI+PC9jaXJjbGU+XG4gICAgPGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxN1wiIHI9XCIzXCI+PC9jaXJjbGU+XG4gICAgPHBvbHlsaW5lIHBvaW50cz1cIjkgMTcgOSA0IDE5IDQgMTkgMTdcIj48L3BvbHlsaW5lPlxuICAgIDxsaW5lIHgxPVwiOVwiIHkxPVwiOFwiIHgyPVwiMTlcIiB5Mj1cIjhcIj48L2xpbmU+XG4gICAgPC9zdmc+XG48L2Rpdj5cbmA7XG5cbi8vIEhUTUxNZWRpYUVsZW1lbnRTdGF0ZXMgY29waWVkIGZyb21cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3JlYWR5U3RhdGVcbmNvbnN0IG1lZGlhU3RhdGVzID0ge1xuICAgIDA6IFwiSEFWRV9OT1RISU5HXCIsXG4gICAgMTogXCJIQVZFX01FVEFEQVRBXCIsXG4gICAgMjogXCJIQVZFX0NVUlJFTlRfREFUQVwiLFxuICAgIDM6IFwiSEFWRV9GVVRVUkVfREFUQVwiLFxuICAgIDQ6IFwiSEFWRV9FTk9VR0hfREFUQVwiXG59O1xuXG5jbGFzcyBBdWRpb1ZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF1ZGlvTGluayA9IHRoaXMudXBkYXRlQXVkaW9MaW5rLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGxheSA9IHRoaXMucGxheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhdXNlID0gdGhpcy5wYXVzZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIGxldCBhdWRpbyA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpO1xuICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0YXRlQ29kZSA9IGF1ZGlvLnJlYWR5U3RhdGU7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBcInJlYWR5U3RhdGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVN0YXRlc1tzdGF0ZUNvZGVdXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICBsZXQgbmFtZVNwYW4gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKTtcbiAgICAgICAgbmFtZVNwYW4uaW5uZXJUZXh0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwibmFtZVwiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwicmVhZHlTdGF0ZVwiLFxuICAgICAgICAgICBcIkhBVkVfTk9USElOR1wiXG4gICAgICAgICk7XG4gICAgICAgIGxldCBhdWRpbyA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpO1xuICAgICAgICBsZXQgc3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwic3JjXCIpO1xuICAgICAgICBpZihzcmMpe1xuICAgICAgICAgICAgYXVkaW8uc3JjID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3AgY2hhbmdlc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcIm5hbWVcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuYW1lU3Bhbi5pbm5lclRleHQgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwicmVhZHlTdGF0ZVwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGxldCBib3JkZXJDb2xvciA9IFwicmVkXCI7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PSBcIkhBVkVfRlVUVVJFX0RBVEFcIiB8fCB2YWx1ZSA9PSBcIkhBVkVfRU5PVUdIX0RBVEFcIil7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBcImdyZWVuXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgYGJvcmRlci0ke3NpZGV9LWNvbG9yYCwgYm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcInBsYXlcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJzdG9wXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYodmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgICAgIGF1ZGlvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwic3JjXCIsICh1cmwpID0+IHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZSBsb2FkIGlzIGF1dG8tbG9hZGVkIGJ5IHRoZSA8YXVkaW8+IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBhdWRpby5zcmMgPSB1cmw7XG4gICAgICAgICAgICB9IGNhdGNoKGVycm9yKXtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJSZXNvdXJjZU5vdEZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlVHlwZTogXCJhdWRpb1wiLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IHRoaXMubW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtzb3VyY2U6IHVybCwgdHlwZTogXCJ1cmxcIn1cblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7ZXJyb3JNc2d9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGxheSgpe1xuICAgICAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgcmVzb3VyY2UgaXMgcmVhZHlcbiAgICAgICAgbGV0IGF1ZGlvID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiYXVkaW9cIik7XG4gICAgICAgIGxldCByZWFkeVN0YXRlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicmVhZHlTdGF0ZVwiKTtcbiAgICAgICAgaWYocmVhZHlTdGF0ZSA9PSBcIkhBVkVfRlVUVVJFX0RBVEFcIiB8fCByZWFkeVN0YXRlID09IFwiSEFWRV9FTk9VR0hfREFUQVwiKXtcbiAgICAgICAgICAgIGF1ZGlvLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KGBhdWRpbyBpcyBub3QgcmVhZHk7IGN1cnJlbnQgc3RhdGU6ICR7cmVhZHlTdGF0ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhdXNlKCl7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgLy8gcmUtbG9hZHMgdGhlIG1lZGlhLCBzZXR0aW5nIGl0IGJhY2sgdG8gdGhlIGJlZ2duaW5nXG4gICAgc3RvcCgpe1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKS5sb2FkKCk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgdGhlIG9uIGNsaWNrIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNsaWNrIGNvbW1hbmQgbWVzc2FnZSB0byBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b24oKXtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pZCA9ICdoYWxvLWF1ZGlvLWxpbmsnO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlubmVySFRNTCA9IGxpbmtJY29uO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luVG9wID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdyaWdodC1jb2x1bW4nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnRWRpdCBsaW5rIGZvciBhdWRpbyBzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVBdWRpb0xpbmspO1xuICAgIH1cblxuICAgIHVwZGF0ZUF1ZGlvTGluayhldmVudCl7XG4gICAgICAgIC8vIFRlbGxzIHRoZSBtb2RlbCB0byB1cGRhdGUgaXRzXG4gICAgICAgIC8vIHNyYyBsaW5rIGZvciB0aGUgYXVkaW9cbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3NyYydcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoXCJFZGl0IFVSTCBmb3IgYXVkaW86XCIsIGN1cnJlbnRTcmMpO1xuICAgICAgICBpZihyZXN1bHQgJiYgcmVzdWx0ICE9PSAnJyAmJiByZXN1bHQgIT09IGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdsb2FkQXVkaW9Gcm9tU291cmNlJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyByZXN1bHQgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuXG5leHBvcnQge1xuICAgIEF1ZGlvVmlldyxcbiAgICBBdWRpb1ZpZXcgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgbGlua0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbGlua1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAgMTRhMy41IDMuNSAwIDAgMCA1IDBsNCAtNGEzLjUgMy41IDAgMCAwIC01IC01bC0uNSAuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTBhMy41IDMuNSAwIDAgMCAtNSAwbC00IDRhMy41IDMuNSAwIDAgMCA1IDVsLjUgLS41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG46aG9zdCB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcGFkZGluZzogMXB4O1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cbmlmcmFtZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuPC9zdHlsZT5cbjxpZnJhbWUgZnJhbWVib3JkZXI9XCIwXCIgYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPlxuYDtcblxuY2xhc3MgQnJvd3NlclZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJyb3dzZXJMaW5rID0gdGhpcy51cGRhdGVCcm93c2VyTGluay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIGlmKCF0aGlzLmhhbG9CdXR0b24pe1xuICAgICAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIGxldCBpZnJhbWUgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJpZnJhbWVcIik7XG4gICAgICAgIGxldCBzcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJzcmNcIik7XG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwic3JjXCIsICh1cmwpID0+IHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZSBsb2FkIGlzIGF1dG8tbG9hZGVkIGJ5IHRoZSA8YnJvd3Nlcj4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmcmFtZS5zcmMgPSB1cmw7XG4gICAgICAgICAgICB9IGNhdGNoKGVycm9yKXtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJSZXNvdXJjZU5vdEZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlVHlwZTogXCJicm93c2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRJZDogdGhpcy5tb2RlbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczoge3NvdXJjZTogdXJsLCB0eXBlOiBcInVybFwifVxuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtlcnJvck1zZ30sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDApe1xuICAgICAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyB0aGUgb24gY2xpY2sgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZighdGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgY2xpY2sgY29tbWFuZCBtZXNzYWdlIHRvIHNlbGZcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQuIEhlcmUgd2UgYWRkIGEgY3VzdG9tIGJ1dHRvblxuICAgICAgICAvLyB3aGVuIHNob3dpbmcuXG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZighZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChmb3VuZEhhbG8pO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kSGFsby5hcHBlbmQodGhpcy5oYWxvQnV0dG9uKTtcbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbigpe1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlkID0gJ2hhbG8tYnJvd3Nlci1saW5rJztcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBsaW5rSWNvbjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnN0eWxlLm1hcmdpblRvcCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAncmlnaHQtY29sdW1uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0VkaXQgbGluayBmb3IgYnJvd3NlciBzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVCcm93c2VyTGluayk7XG4gICAgfVxuXG4gICAgdXBkYXRlQnJvd3NlckxpbmsoZXZlbnQpe1xuICAgICAgICAvLyBUZWxscyB0aGUgbW9kZWwgdG8gdXBkYXRlIGl0c1xuICAgICAgICAvLyBzcmMgbGluayBmb3IgdGhlIGJyb3dzZXJcbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3NyYydcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoXCJFZGl0IFVSTCBmb3IgYnJvd3NlcjpcIiwgY3VycmVudFNyYyk7XG4gICAgICAgIGlmKHJlc3VsdCAmJiByZXN1bHQgIT09ICcnICYmIHJlc3VsdCAhPT0gY3VycmVudFNyYyl7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ3NldFVSTFRvJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyByZXN1bHQgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuXG5leHBvcnQge1xuICAgIEJyb3dzZXJWaWV3LFxuICAgIEJyb3dzZXJWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEJ1dHRvblZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHdlYmNvbXBvbmVudCByZXByZXNlbnRpbmcgYSBCdXR0b24uXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG4gICAgICAgICAgICAgICAgPHN0eWxlPlxuICAgICAgICAgICAgICAgICAuc3QtYnV0dG9uLWxhYmVsIHtcbiAgICAgICAgICAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgICAgICAgICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICAgICAgICAgICBtYXgtd2lkdGg6IDk1JTtcbiAgICAgICAgICAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L3N0eWxlPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3QtYnV0dG9uLWxhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90Pjwvc2xvdD48IS0tIFRleHQgb2YgdGhlIE5hbWUgLS0+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuYDtcblxuY2xhc3MgQnV0dG9uVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycyA9IHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBTZXR1cCBwcm9wIGNoYW5nZSBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ25hbWUnLCAodmFsdWUsIHBhcnRJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbm5lclRleHQgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgbGV0IGJ1dHRvbk5hbWUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJuYW1lXCIpO1xuICAgICAgICBpZihidXR0b25OYW1lKXtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJUZXh0ID0gYnV0dG9uTmFtZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgYmFzZSBjbGFzcyBpbXBsZW1lbnRhdGlvblxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCl7XG4gICAgICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCF0aGlzLmhhc09wZW5IYWxvKXtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBjbGljayBjb21tYW5kIG1lc3NhZ2UgdG8gc2VsZlxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlIC8vIFNob3VsZCBpZ25vcmUgaWYgU3lzdGVtIEROVVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlcndyaXRpbmcgdGhlIGJhc2UgY2xhc3Mgb3Blbi9jbG9zZSBlZGl0b3IgbWV0aG9kc1xuICAgIG9wZW5FZGl0b3IoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5vcGVuRWRpdG9yRm9yUGFydCh0aGlzLm1vZGVsLmlkKTtcbiAgICB9XG5cbiAgICBjbG9zZUVkaXRvcigpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmNsb3NlRWRpdG9yRm9yUGFydCh0aGlzLm1vZGVsLmlkKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEJ1dHRvblZpZXcsXG4gICAgQnV0dG9uVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBDYXJkVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSB3ZWJjb21wb25lbnQgcmVwcmVzZW50YXRpb24gb2YgYSBDYXJkLlxuICovXG5cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG4gICAgICAgICAgICAgICAgPHN0eWxlPlxuICAgICAgICAgICAgICAgIDwvc3R5bGU+XG4gICAgICAgICAgICAgICAgPHNsb3Q+PC9zbG90PlxuYDtcblxuY2xhc3MgQ2FyZFZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSGFsbyBzZXR0aW5ncy4gQ2FyZHMgZG9uJ3Qgd2FudFxuICAgICAgICAvL2EgaGFsbyB0byBvcGVuXG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgZGVmYXVsdCBjbGFzcyBtZXRob2RcbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDAgJiYgZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ29udGV4dE1lbnVJdGVtcyhjb250ZXh0TWVudSl7XG4gICAgICAgIGNvbnRleHRNZW51LmFkZFNwYWNlcigpO1xuICAgICAgICAvLyBUb29sYm94IHRvZ2dsZSBoaWRlL3VuaGlkZVxuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gd2luZG93LlN5c3RlbS5nZXRDdXJyZW50U3RhY2tNb2RlbCgpO1xuICAgICAgICBsZXQgdG9vbGJveCA9IGN1cnJlbnRTdGFjay5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHBhcnQsIFwibmFtZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09IFwiVG9vbGJveFwiO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gdG9vbGJveCBhdCBhbGwsIHRoYXQncyB3ZWlyZCBidXQgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYodG9vbGJveCl7XG4gICAgICAgICAgICBsZXQgaGlkZGVuID0gdG9vbGJveC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRvb2xib3gsIFwiaGlkZVwiKTtcbiAgICAgICAgICAgIGlmKGhpZGRlbil7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiVW5oaWRlIFRvb2xib3hcIixcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sYm94LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodG9vbGJveCwgXCJoaWRlXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICBcIkhpZGUgVG9vbGJveFwiLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xib3gucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0b29sYm94LCBcImhpZGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBDYXJkVmlldyxcbiAgICBDYXJkVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBGaWVsZFZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSB0aGUgdmlldyBvZiBhbiBGaWVsZCBwYXJ0LlxuICogSSBhbSBhbiBcImludGVyaW1cIiB2aWV3IGludGVuZGVkIHRvIGRpc3BsYXlcbiAqIGFuZCBlZGl0IHBsYWluIHRleHQgb24gYSBDYXJkLlxuICogSSBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBhIG1vcmUgY29tcHJlaGVuc2l2ZVxuICogaW1wbGVtZW50YXRpb24gb2YgRmllbGQvRmllbGRWaWV3IGluIHRoZSBmdXR1cmUuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcbmltcG9ydCBjc3NTdHlsZXIgZnJvbSAnLi4vdXRpbHMvL3N0eWxlci5qcyc7XG5pbXBvcnQgQ29sb3JXaGVlbFdpZGdldCBmcm9tICcuL2RyYXdpbmcvQ29sb3JXaGVlbFdpZGdldC5qcyc7XG5pbXBvcnQgaW50ZXJwcmV0ZXJTZW1hbnRpY3MgZnJvbSAnLi4vLi4vb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyc7XG5pbXBvcnQgY3JlYXRlSGlnaGxpZ2h0ZXIgZnJvbSAnLi4vdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMnO1xuXG5jb25zdCBoYWxvRWRpdEJ1dHRvblNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci10b29sc1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMyAyMWg0bDEzIC0xM2ExLjUgMS41IDAgMCAwIC00IC00bC0xMyAxM3Y0XCIgLz5cbiAgPGxpbmUgeDE9XCIxNC41XCIgeTE9XCI1LjVcIiB4Mj1cIjE4LjVcIiB5Mj1cIjkuNVwiIC8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCIxMiA4IDcgMyAzIDcgOCAxMlwiIC8+XG4gIDxsaW5lIHgxPVwiN1wiIHkxPVwiOFwiIHgyPVwiNS41XCIgeTI9XCI5LjVcIiAvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiMTYgMTIgMjEgMTcgMTcgMjEgMTIgMTZcIiAvPlxuICA8bGluZSB4MT1cIjE2XCIgeTE9XCIxN1wiIHgyPVwiMTQuNVwiIHkyPVwiMTguNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGhhbG9Mb2NrQnV0dG9uU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxvY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxyZWN0IHg9XCI1XCIgeT1cIjExXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjEwXCIgcng9XCIyXCI+PC9yZWN0PlxuICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxNlwiIHI9XCIxXCI+PC9jaXJjbGU+XG4gICA8cGF0aCBkPVwiTTggMTF2LTRhNCA0IDAgMCAxIDggMHY0XCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBoYWxvVW5sb2NrQnV0dG9uU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxvY2stb3BlblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHJlY3QgeD1cIjVcIiB5PVwiMTFcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTBcIiByeD1cIjJcIj48L3JlY3Q+XG4gICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjE2XCIgcj1cIjFcIj48L2NpcmNsZT5cbiAgIDxwYXRoIGQ9XCJNOCAxMXYtNWE0IDQgMCAwIDEgOCAwXCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBmaWVsZFRlbXBsYXRlU3RyaW5nID0gYFxuICAgICAgPHN0eWxlPlxuICAgICAgICAuZmllbGQge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgfVxuXG4gICAgICAgIC5maWVsZCBjb2xvci13aGVlbCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIH1cblxuICAgICAgICAuZmllbGQtdGV4dGFyZWEge1xuICAgICAgICAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIDVweCk7XG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICAgICAgICAgIG92ZXJmbG93LXdyYXA6IGFueXdoZXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogU3ludGF4IEhpZ2hsaWdodGluZ1xuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuc3BhbltkYXRhLXN0LXJ1bGU9XCJtZXNzYWdlTmFtZVwiXXtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cblxuc3BhbltkYXRhLXN0LXJ1bGU9XCJrZXl3b3JkXCJde1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xufVxuXG5zcGFuW2RhdGEtc3QtcnVsZT1cIlBhcmFtZXRlckxpc3QtaXRlbVwiXXtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgY29sb3I6IGdyZXk7XG59XG5cblxuICAgIDwvc3R5bGU+XG4gICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZC10ZXh0YXJlYVwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiPjwvZGl2PlxuICAgIDwvZGl2PmA7XG5cblxuZnVuY3Rpb24gZm9ybWF0RG9jKHNDbWQsIHNWYWx1ZSkge1xuICBkb2N1bWVudC5leGVjQ29tbWFuZChzQ21kLCBmYWxzZSwgc1ZhbHVlKTsgb0RvYy5mb2N1cygpO1xufVxuXG5jbGFzcyBGaWVsZFZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyB0aGlzLmVkaXRvckNvbXBsZXRlciA9IHRoaXMuc2ltcGxlVGFsa0NvbXBsZXRlcjtcbiAgICAgICAgdGhpcy50ZXh0U3R5bGVyID0gY3NzU3R5bGVyOyAgLy8gd2UgbWlnaHQgd2FudCB0byBjb25zaWRlciBhIG1vcmUgcHJvZ3JhbW1hdGljIHdheSB0byBzZXQgdGhpc1xuICAgICAgICB0aGlzLmVkaXRvckNvbXBsZXRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlcyA9IHt9O1xuICAgICAgICB0aGlzLndhbnRzQ29udGV4dE1lbnUgPSBmYWxzZTtcblxuICAgICAgICAvLyBQcmVzZXRzIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nLlxuICAgICAgICAvLyBXaGVuIGhpZ2hsaWdodGluZyBpcyBlbmFibGVkLCB3ZSB3aWxsIGNoZWNrXG4gICAgICAgIC8vIGVhY2ggbGluZSBvZiB0aGUgdGV4dCBmb3IgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBncmFtbWF0aWNhbCBydWxlczpcbiAgICAgICAgdGhpcy5fc3ludGF4UnVsZXMgPSBbXG4gICAgICAgICAgICBcIk1lc3NhZ2VIYW5kbGVyT3BlblwiLFxuICAgICAgICAgICAgXCJNZXNzYWdlSGFuZGxlckNsb3NlXCJcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBmaWVsZFRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uSW5wdXQgPSB0aGlzLm9uSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZUlucHV0ID0gdGhpcy5vbkJlZm9yZUlucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uS2V5ZG93biA9IHRoaXMub25LZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZWRvd24gPSB0aGlzLm9uTW91c2Vkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51ID0gdGhpcy5vcGVuQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51ID0gdGhpcy5jbG9zZUNvbnRleHRNZW51LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9JdCA9IHRoaXMuZG9JdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdGlvbiA9IHRoaXMuaGFuZGxlU2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbkZpZWxkID0gdGhpcy5vcGVuRmllbGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0VG9IdG1sID0gdGhpcy50ZXh0VG9IdG1sLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMgPSB0aGlzLnNldHVwUHJvcEhhbmRsZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2ltcGxlVGFsa0NvbXBsZXRlciA9IHRoaXMuc2ltcGxlVGFsa0NvbXBsZXRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9ucyA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0UmFuZ2UgPSB0aGlzLmluc2VydFJhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCA9IHRoaXMuc2V0UmFuZ2VJblRhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbiA9IHRoaXMuc2V0U2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U3ludGF4ID0gdGhpcy5oaWdobGlnaHRTeW50YXguYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodFN5bnRheCA9IHRoaXMudW5oaWdobGlnaHRTeW50YXguYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2VkaXRhYmxlJywgKHZhbHVlLCBpZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uID0gdGhpcy5oYWxvTG9ja0J1dHRvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uID0gdGhpcy5oYWxvVW5sb2NrQnV0dG9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcImVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gJ3RleHQnIGlzIGEgRHluYW1pY1Byb3Agd2hvc2Ugc2V0dGVyIHdpbGwgc2V0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgIC8vIHZhbHVlIGZvciBgaW5uZXJIVE1MYC4gVGhpcyB3YXkgd2UgY2FuIGhhdmUgcHJvZ3JhbW1hdGljIGNvbnRlbnRcbiAgICAgICAgLy8gc2V0dGluZyBhbmQgc3RpbGwgYWxsb3cgdG8gbm90IGxvb3NlIG1hcmt1cC5cbiAgICAgICAgLy8gJ2lubmVySFRNTCcgaXMgYSBCYXNpY1Byb3AuIFNlZSBob3cgdGhlc2UgYXJlIHNldCwgd2l0aG91dFxuICAgICAgICAvLyBub3RpZmljYXRpb24gaW4gdGhpcy5vbklucHV0KClcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2lubmVySFRNTCcsICh2YWx1ZSwgaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVyVGV4dCxcbiAgICAgICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5LCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyBUaGUgZXZlbnRzIGhlcmUgYXJlIGFkZGVkIHZpYSB0aGUgLmFkZEV2ZW50TGlzdGVuZXIoKSBBUEkgd2hpY2ggaXNcbiAgICAgICAgLy8gZGlzdGluY3QgZnJvbSB0aGUgdGhpcy5ldmVudFJlc3BvbmQoKSB3aGljaCB1c2VzIHRoZSBET00gZWxlbWVudFxuICAgICAgICAvLyBlbGVtZW50Lm9uRXZlbnQgQVBJLiBUaGlzIGFsbG93cyB1cyB0byBkaXN0bmd1aXNoIGJldHdlZW4gXCJjb3JlXCJcbiAgICAgICAgLy8gc3lzdGVtLXdlYiBldmVudHMgdGhhdCB3ZSBkb24ndCB3YW50IG1lZGRsZWQgd2l0aCBhdCB0aGUgbW9tZW50LCBsaWtlXG4gICAgICAgIC8vIGVudGVyaW5nIHRleHQgaW4gYSBmaWVsZCwgYW5kIG9uZXMgZXhwb3NlZCBpbiB0aGUgZW52aXJvbmVtbnQgZm9yIHNjcmlwdGluZ1xuICAgICAgICB0aGlzLnRleHRhcmVhID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZmllbGQtdGV4dGFyZWEnKTtcblxuICAgICAgICB0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0KTtcbiAgICAgICAgLy90aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0JywgdGhpcy5vbkJlZm9yZUlucHV0KTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleWRvd24pO1xuICAgICAgICB0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZWRvd24pO1xuICAgICAgICAvLyBObyBuZWVkIHRvIGFkZCBhIGNsaWNrIGxpc3RlbmVyIGFzIHRoZSBiYXNlIFBhcnRWaWV3IGNsYXNzIGRvZXMgdGhhdFxuXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGRlYWwgd2l0aCByYW5nZSBpbnNlcnRpb25zIChmb3Igc3R5bGluZyB0ZXh0IGZyYWdtZW50cyB3aXRoaW5cbiAgICAgICAgLy8gdGhlIHRleHRhcmVhKSwgd2UgbmVlZCB0byBoYXZlIHRoZSBkZWZhdWx0IHBhcmFncmFwaCB0YWcgPSA8L2JyPi4gT3RoZXJ3aXNlXG4gICAgICAgIC8vIHRoZSBpbnNlcnQgbmV3IGxpbmUgaXMgb2YgdGhlIGZvcm0gPGRpdj48L2JyPjxkaXY+IHdoaWNoIGNhdXNlcyB0aGUgYXBwZWFyYW5jZVxuICAgICAgICAvLyBvZiBuZXdsaW5lcyB3aGVuIG5vZGVzIGFyZSBpbnNlcnRlZCBpbnRvIGEgcmFuZ2VcbiAgICAgICAgLy9kb2N1bWVudC5leGVjQ29tbWFuZChcImRlZmF1bHRQYXJhZ3JhcGhTZXBhcmF0b3JcIiwgZmFsc2UsIFwic3QtbGluZVwiKTtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICB0aGlzLnRleHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0KTtcbiAgICAgICAgLy90aGlzLnRleHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0JywgdGhpcy5vbkJlZm9yZUlucHV0KTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleWRvd24pO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZWRvd24pO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmZpZWxkLXRleHRhcmVhJyk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtb2RlbCwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdGV4dGFyZWFcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgaHRtbCBvZiB0aGUgZmllbGQgbW9kZWxcbiAgICAgICAgbGV0IGlubmVySFRNTCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnaW5uZXJIVE1MJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVySFRNTCA9IGlubmVySFRNTDtcblxuICAgICAgICBsZXQgaXNFZGl0YWJsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImVkaXRhYmxlXCIpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgaXNFZGl0YWJsZSk7XG5cbiAgICAgICAgLy8gc2V0dXAgdGhlIGxvY2svdW5sb2NrIGhhbG8gYnV0dG9uXG4gICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b25zKCk7XG4gICAgICAgIGxldCBlZGl0YWJsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnZWRpdGFibGUnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGVkaXRhYmxlID09PSB0cnVlKXtcbiAgICAgICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSB0aGlzLmhhbG9Mb2NrQnV0dG9uO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKFwiZWRpdGFibGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdGFibGUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSB0aGlzLmhhbG9VbmxvY2tCdXR0b247XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNpbXBsZVRhbGtDb21wbGV0ZXIoZWxlbWVudCl7XG4gICAgICAgIGxldCB0ZXh0Q29udGVudCA9IHRoaXMuaHRtbFRvVGV4dChlbGVtZW50KTtcbiAgICAgICAgbGV0IHN0YXJ0T2ZIYW5kbGVyUmVnZXggPSAvXm9uXFxzKFxcdyspKFxcc3xcXG4pKyQvO1xuICAgICAgICBsZXQgbWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaChzdGFydE9mSGFuZGxlclJlZ2V4KTtcbiAgICAgICAgaWYobWF0Y2gpe1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VOYW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBicmVhayBpcyBhIG5ldyBsaW5lIHRoZW4gYW4gZXh0cmFcbiAgICAgICAgICAgIC8vIDxkaXY+PC9icj48L2Rpdj4gaGFzIGJlZWQgYWRkZWQgaW50byB0aGUgZWxlbWVuIGFscmVhZHlcbiAgICAgICAgICAgIGxldCB0YWJMaW5lID0gXCJcXHRcXG5cIjtcbiAgICAgICAgICAgIGlmKG1hdGNoWzJdID09PSBcIlxcblwiKXtcbiAgICAgICAgICAgICAgICB0YWJMaW5lPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBgJHt0YWJMaW5lfWVuZCAke21lc3NhZ2VOYW1lfWA7XG4gICAgICAgICAgICBsZXQgaW5uZXJIVE1MID0gdGhpcy50ZXh0VG9IdG1sKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGlubmVySFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSSBvdmVycmlkZSBteSBiYXNlLWNsYXNzJ3MgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRhcmdldCByZWxhdGVkIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICBzdHlsZVRleHRDU1MoKXtcbiAgICAgICAgbGV0IHRleHRhcmVhID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZmllbGQtdGV4dGFyZWEnKTtcbiAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwiY3NzVGV4dFN0eWxlXCIpO1xuICAgICAgICBPYmplY3Qua2V5cyhjc3NTdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjc3NTdHlsZVtrZXldO1xuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YXJnZXQgYW5kIHJhbmdlIHNldCB0aGVuIHNlbmQgdGhlIHRhcmdldCBhbiB1cGRhdGUgbWVzc2FnZVxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsICd0YXJnZXQnKTtcbiAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCh0YXJnZXQsIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLCBjc3NTdHlsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIHNldCBhIHRleHQtKiBwcm9wZXJ0eSBvbiBzZWxlY3Rpb24gdG8gc3R5bGUgdGhlIHNlbGVjdGVkIHRleHRcbiAgICAgKiBOb3RlOiB0aGlzIGlzIGRvbmUgZm9yIGV2ZXJ5IGN1cnJlbnQgc2VsZWN0aW9uLCBpLmUuIGV2ZXJ0aGluZ1xuICAgICAqIGluIHRoaXMuc2VsZWN0aW9uUmFuZ2VzXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHByb3BOYW1lLCB2YWx1ZSl7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5zZWxlY3Rpb25SYW5nZXMpLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0eWxlID0ge307XG4gICAgICAgICAgICAvLyAvLyBpZiB0aGUgZG9jdW1lbnQgZnJhZ21lbnQgaGFzIG9uZSBjaGlsZCBub2RlIGFuZCBpdCdzIGEgc3BhblxuICAgICAgICAgICAgLy8gLy8gd2Ugc2hvdWxkIHN0eWxlIHRoYXQgZGlyZWN0bHkuIFRoaXMgYXZvaWRzIHVubmNlc3NhcnkgRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyAvLyBiZWluZyBjcmVhdGVkIHRvIHdyYXAgdGhlIGNvbnRlbnRzLCBzdWNoIGFzIHdoZW4gc3R5bGluZyBpcyBjb250aW51YWxseVxuICAgICAgICAgICAgLy8gLy8gYXBwbGllZCBvdCB0aGUgc2FtZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIGxldCBzcGFuO1xuICAgICAgICAgICAgLy8gaWYoZG9jRnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBkb2NGcmFnbWVudC5jaGlsZE5vZGVzWzBdLm5vZGVOYW1lID09IFwiU1BBTlwiKXtcbiAgICAgICAgICAgIC8vICAgICBzcGFuID0gZG9jRnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIC8vICAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgT2JlamN0LnZhbHVlcyBoZXJlIGZvciB0aGUgRE9NIHN0eWxlIGF0dHJpYnV0ZSBvYmplY3RcbiAgICAgICAgICAgIC8vICAgICAvLyB0aGF0J3Mgd2VpcmRcbiAgICAgICAgICAgIC8vICAgICBPYmplY3QudmFsdWVzKHNwYW4uc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgICAgICBjdXJyZW50U3R5bGVba2V5XSA9IHNwYW4uc3R5bGVba2V5XTtcbiAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgYSBzcGFuIGVsZW1lbnQgdG8gd3JhcCB0aGUgY29udGVudHMgaW4gc3R5bGVcbiAgICAgICAgICAgIC8vICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgLy8gICAgIC8vIFdoaWxlIHRlbXB0aW5nIHRvIHVzZSByYW5nZS5zdXJyb3VuZENvbnRlbnRzKCkgYXZvaWQgdGhpc1xuICAgICAgICAgICAgLy8gICAgIC8vIHNpbmNlIGl0IHdpbGwgZmFpbCB3aXRoIGEgbm9uLWluZm9ybWF0aXZlIGVycm9yIGlmIHRoZSByYW5nZVxuICAgICAgICAgICAgLy8gICAgIC8vIGluY2x1ZGVzIHBhcnRpYWwgbm9kZXMgKGV4IHRleHQgYWNyb3NzIHZhcmlvdXMgbm9kZXMpXG4gICAgICAgICAgICAvLyAgICAgd2hpbGUgKGRvY0ZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIC8vICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkb2NGcmFnbWVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGxldCBjc3NPYmplY3QgPSB0aGlzLnRleHRTdHlsZXIoY3VycmVudFN0eWxlLCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzT2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzcGFuLnN0eWxlW2tleV0gPSBjc3NPYmplY3Rba2V5XTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzcGFuLmFwcGVuZChyYW5nZS5leHRyYWN0Q29udGVudHMoKSk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHNwYW4pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaW5uZXJIVE1MJyxcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVySFRNTCxcbiAgICAgICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YXJnZXQgYW5kIHJhbmdlIHNldCB0aGVuIHNlbmQgdGhlIHRhcmdldCBhbiB1cGRhdGUgbWVzc2FnZVxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCAndGFyZ2V0Jyk7XG4gICAgICAgICAgICBpZih0YXJnZXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCh0YXJnZXQsIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25CZWZvcmVJbnB1dChldmVudCl7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsZWN0ZWRSYW5nZS5jbG9uZVJhbmdlKCk7XG5cbiAgICAgICAgbGV0IGlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgIGlmKCFpbm5lckhUTUwuZW5kc1dpdGgoXCI8ZGl2Pjxicj48L2Rpdj5cIikpe1xuICAgICAgICAgICAgaW5uZXJIVE1MICs9IFwiPGRpdj48YnI+PC9kaXY+XCI7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRQYXJhZ3JhcGhcIil7XG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgbGV0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcbiAgICAgICAgICAgIGxldCBicjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpO1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShicik7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGJyMik7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKGJyMik7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihicjIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25JbnB1dChldmVudCl7XG4gICAgICAgIGxldCBpbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MO1xuICAgICAgICAvKlxuICAgICAgICBpZighaW5uZXJIVE1MLmVuZHNXaXRoKFwiPGJyPlwiKSl7XG4gICAgICAgICAgICBpbm5lckhUTUwgKz0gXCI8YnI+XCI7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAgICAgaWYodGhpcy5lZGl0b3JDb21wbGV0ZXIpe1xuICAgICAgICAgICAgLy8gVE9ETyBzb3J0IG91dCBob3cgdGhpcyB3b3VsZCB3b3JrXG4gICAgICAgICAgICBsZXQgaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTDtcbiAgICAgICAgICAgIGlubmVySFRNTCA9IHRoaXMuZWRpdG9yQ29tcGxldGVyKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVyVGV4dCxcbiAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnksIHRvIHByZXNlcnZlIGNvbnRlbnRlZGl0YWJsZSBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnaW5uZXJIVE1MJyxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwsXG4gICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5XG4gICAgICAgICk7XG4gICAgICAgIC8vIFNpbmNlIHdlIHVwZGF0ZSB0aGUgJ3RleHQnIHByb3BlcnR5IHdpdGhvdXQgbm90aWZpY2F0aW9uLCB0aGUgcGFydC9tb2RlbFxuICAgICAgICAvLyBpcyBub3Qgc2VudCB0aGUgXCJwcm9wZXJ0eUNoYW5nZWRcIiBtZXNzYWdlIHNvIHdlIGRvIHNvIG1hbnVhbGx5XG4gICAgICAgIHRoaXMubW9kZWwucHJvcGVydHlDaGFuZ2VkKFwidGV4dFwiLCBldmVudC50YXJnZXQuaW5uZXJUZXh0KTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YXJnZXQgYW5kIHJhbmdlIHNldCB0aGVuIHNlbmQgdGhlIHRhcmdldCBhbiB1cGRhdGUgbWVzc2FnZVxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsICd0YXJnZXQnKTtcbiAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCh0YXJnZXQsIGV2ZW50LnRhcmdldC5pbm5lckhUTUwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlkb3duKGV2ZW50KXtcbiAgICAgICAgLy8gcHJldmVudCB0aGUgZGVmYXVsdCB0YWIga2V5IHRvIGxlYXZlIGZvY3VzIG9uIHRoZSBmaWVsZFxuICAgICAgICBpZihldmVudC5rZXk9PT1cIlRhYlwiKXtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvL2RvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgZmFsc2UsICcmI3g5Jyk7XG4gICAgICAgICAgICBsZXQgc2VsID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcblxuICAgICAgICAgICAgbGV0IHRhYk5vZGVWYWx1ZSA9ICdcXHQnO1xuICAgICAgICAgICAgbGV0IHRhYk5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0YWJOb2RlVmFsdWUpO1xuXG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHRhYk5vZGUpO1xuXG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKHRhYk5vZGUpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIodGFiTm9kZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgb25Nb3VzZWRvd24oZXZlbnQpe1xuICAgICAgICAvLyBjbGVhciBhbGwgc2VsZWN0aW9uc1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlcyA9IHt9O1xuICAgIH1cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB3ZSB0b2dnbGUgdGhlIGhhbG9cbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyB0ZXh0IGlzIHNlbGVjdGVkIHdlIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBpZih0ZXh0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFsdEtleSBpcyBwcmVzc2VkIHdlIG9wZW4gdGhlIGNvbnRleHQgKFwiZG8gaXRcIikgbWVudVxuICAgICAgICAgICAgICAgICAgICBpZihldmVudC5hbHRLZXkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuY29udGV4dE1lbnVPcGVuKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5Db250ZXh0TWVudSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb24oZXZlbnQubWV0YUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgbm8gY29udGV4dCBtZW51IGlzIG9wZW5cbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb250ZXh0TWVudU9wZW4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgYWxsIHRoZSBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2VzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogSSBoYW5kbGUgc2VsZWN0ZWQgdGV4dCwgY3JlYXRpbmcgYSBuZXcgZmllbGQgbW9kZWwvdmlld1xuICAgICAqIGZvciBldmVyeSByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLCBrZWVwaW5nIHRyYWNrIG9mIGV2ZXJ5IHJhbmdlXG4gICAgICogaW4gdGhpcy5zZWxlY3Rpb24gT2JqZWN0L2RpY3Qgc28gdGhhdCBtb2RpZmljYXRpb24gY2FuIGJlIGluc2VydGVkXG4gICAgICogYmFjayBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVTZWxlY3Rpb24ob3Blbk5ld0ZpZWxkKXtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSsrKXtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGlzIGlzIG5vdCBhIGNvbnRpbnVpbmcgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyBhbmQgdGhhdCB0aGUgcmFuZ2UgaXMgbm90IGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XG4gICAgICAgICAgICBsZXQgY3VycmVudFJhbmdlcyA9IE9iamVjdC52YWx1ZXModGhpcy5zZWxlY3Rpb25SYW5nZXMpO1xuICAgICAgICAgICAgaWYoY3VycmVudFJhbmdlcy5pbmRleE9mKHJhbmdlKSA+PSAwKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGdlbmVyYXRlIG91ciBvd24gcmFuZ2UgaWRzLCBzaW5jZSB3ZSB3YW50IHRoaXMgdG8gY29ycmVzcG9uZCB0b1xuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIG9yZGVyIHdoaWNoIGlzIG5vdCByZXNwZWN0ZWQgYnkgdGhlIGJyb3dzZXIgc2VsZWN0aW9uIG9iamVjdFxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHdlIGRvbid0IGhpdCBvbiBvdGhlciB2aWV3cycgcmFuZ2VzIGJ5IGFjY2lkZW50IHdlIG5lZWQgdW5pcXVlIGlkJ3NcbiAgICAgICAgICAgIGxldCByYW5nZUlkID0gRGF0ZS5ub3coKTsgLy9UT0RPIHdlIG5lZWQgYSBiZXR0ZXIgcmFuZG9tIGlkXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlc1tyYW5nZUlkXSA9IHJhbmdlO1xuICAgICAgICAgICAgaWYob3Blbk5ld0ZpZWxkKXtcbiAgICAgICAgICAgICAgICAvLyBvcGVuIGEgZmllbGQgZm9yIGVhY2ggbmV3IHNlbGVjdGlvbiBhbmQgcG9wdWxhdGUgaXQgd2l0aCB0aGUgcmFuZ2UgaHRtbFxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkZpZWxkKHJhbmdlLCByYW5nZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5GaWVsZChyYW5nZSwgcmFuZ2VJZCl7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBIVE1MIGRvY3VtZW50IGZyYWdtZW50IGZyb20gdGhlIHJhbmdlIHRvIGF2b2lkIGRlYWxpbmcgd2lodCBzdGFydC9lbmRcbiAgICAgICAgLy8gYW5kIG9mZnNldCBjYWxjdWxhdGlvbnNcbiAgICAgICAgLy8gZnJhZ21lbnRzIGRvbid0IGhhdmUgdGhlIGZ1bGwgaHRtbCBET00gZWxlbWVudCBBUEkgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKHJhbmdlLmNsb25lQ29udGVudHMoKSk7XG5cbiAgICAgICAgLy8gVE9ETyB0aGVzZSBzaG91bGQgYWxsIGJlIG1lc3NhZ2VzIGFuZCBjb3JyZXNwbmRpbmcgY29tbWFuZCBoYW5kbGVyIGRlZmluaXRpb25zXG4gICAgICAgIC8vIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBmaWVsZCdzIG93biBzY3JpcHRcbiAgICAgICAgbGV0IGZpZWxkTW9kZWwgPSB3aW5kb3cuU3lzdGVtLm5ld01vZGVsKFwiZmllbGRcIiwgdGhpcy5tb2RlbC5fb3duZXIuaWQsIGBzZWxlY3Rpb24gJHtyYW5nZUlkfWApO1xuICAgICAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoZmllbGRNb2RlbCwgXCJpbm5lckhUTUxcIiwgc3Bhbi5pbm5lckhUTUwpO1xuICAgICAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoZmllbGRNb2RlbCwgXCJ0YXJnZXRcIiwgYGZpZWxkIGlkICR7dGhpcy5tb2RlbC5pZH1gKTtcbiAgICAgICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGZpZWxkTW9kZWwsIFwidGFyZ2V0UmFuZ2VJZFwiLCByYW5nZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogR2l2ZW4gYSB0YWdyZ2V0IHNwZWNpZmllciBhbmQgaHRtbFxuICAgICAgKiBJIGZpcnN0IGxvb2sgdXAgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHRhcmdldCBoYXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICogcmFuZ2UgKGNvbWluZyBmcm9tIHRoZSB0YXJnZXRSYW5nZUlkIHByb3BlcnR5KSwgYW5kIHRoZW4gc2V0IGl0IHdpdGggbXlcbiAgICAgICogaW5uZXJIVE1MLiBOb3RlLCBzaW5jZSB0aGUgdGFyZ2V0IHByb3BlcnR5IHZhbHVlIGlzIGFuIG9iamVjdCBzcGVjaWZpZXIgSVxuICAgICAgKiBjcmVhdGUgYSBzZW1hbnRpY3Mgb2JqZWN0cyBhbmQgaW50ZXJwcmV0IHRoZSB2YWx1ZSByZXN1bHRpbmcgaW4gYSB2YWxpZFxuICAgICAgKiBwYXJ0IGlkLlxuICAgICAgKi9cbiAgICBzZXRSYW5nZUluVGFyZ2V0KHRhcmdldFNwZWNpZmllciwgaHRtbCwgY3NzKXtcbiAgICAgICAgbGV0IHRhcmdldFJhbmdlSWQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgJ3RhcmdldFJhbmdlSWQnKTtcbiAgICAgICAgbGV0IG1hdGNoID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLm1hdGNoKHRhcmdldFNwZWNpZmllciwgXCJPYmplY3RTcGVjaWZpZXJcIik7XG4gICAgICAgIGxldCBzZW1hbnRpY3MgPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oJ2ludGVycHJldCcsIGludGVycHJldGVyU2VtYW50aWNzKHRoaXMubW9kZWwsIHdpbmRvdy5TeXN0ZW0pKTtcbiAgICAgICAgbGV0IHRhcmdldElkID0gc2VtYW50aWNzKG1hdGNoKS5pbnRlcnByZXQoKTtcblxuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiaW5zZXJ0UmFuZ2VcIixcbiAgICAgICAgICAgIGFyZ3M6IFt0YXJnZXRSYW5nZUlkLCBodG1sLCBjc3NdXG4gICAgICAgIH0sIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RhcmdldElkXSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJIGluc2VydCB0aGUgaHRtbCAoc3RyaW5nKSBpbnRvIHRoZSBzcGVjaWZpZWQgcmFuZ2UgKGJ5IGlkKVxuICAgICAqL1xuICAgIGluc2VydFJhbmdlKHJhbmdlSWQsIGh0bWwsIGNzc09iail7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMuc2VsZWN0aW9uUmFuZ2VzW3JhbmdlSWRdO1xuICAgICAgICBpZihyYW5nZSl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIGlmKGNzc09iail7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzT2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gY3NzT2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoc3Bhbik7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHRleHQgYW5kIGlubmVySFRNTCBwcm9wZXJ0aWVzIHdpdGhvdXQgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHNldHRpbmcgb2YgdGhlIHRleHQvaHRtbFxuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJUZXh0LFxuICAgICAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnksIHRvIHByZXNlcnZlIGNvbnRlbnRlZGl0YWJsZSBjb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgZmFsc2UgLy8gZG8gbm90IG5vdGlmeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5Db250ZXh0TWVudSgpe1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBmb2N1c05vZGUgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS5mb2N1c05vZGU7XG4gICAgICAgIGxldCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICBidXR0b24uaWQgPSBcImRvSXRcIjtcbiAgICAgICAgYnV0dG9uLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjEwcHhcIjtcbiAgICAgICAgYnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidmFyKC0tcGFsZXR0ZS1ncmVlbilcIjtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gXCJEbyBpdCFcIjtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmRvSXQpO1xuICAgICAgICBmb2N1c05vZGUuYWZ0ZXIoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudU9wZW4gPSB0cnVlO1xuICAgIH07XG5cbiAgICBjbG9zZUNvbnRleHRNZW51KCl7XG4gICAgICAgIGxldCBidXR0b24gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNkb0l0Jyk7XG4gICAgICAgIGlmKGJ1dHRvbil7XG4gICAgICAgICAgICBidXR0b24ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgdGhlIHNlbGVjdGlvbiBhbmQgc2V0IHRoZSBjb250ZXh0IG1lbnUgdG8gY2xvc2VkXG4gICAgICAgIGRvY3VtZW50LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51T3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvSXQoZXZlbnQpe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgbGV0IHRleHQgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpO1xuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgdGV4dCB0byBtYWtlIHN1cmUgbm8gbmV3bGluZXMgb3Igc3BhY2VzIG1hZGUgaXQgaW5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXltcXHRcXG4gXSsvLCBcIlwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvW1xcdFxcbiBdKyQvLCBcIlwiKTtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgIC8vIHNlbmQgbWVzc2FnZSB0byBjb21waWxlIHRoZSBwcmVwcGVkIHNjcmlwdFxuICAgICAgICBsZXQgc2NyaXB0ID0gYG9uIGRvSXRcXG4gICAke3RleHR9XFxuZW5kIGRvSXRgO1xuICAgICAgICAvLyBzZW5kIHRoZXNlIG1lc3NhZ2VzIGZyb20gdGhlIG1vZGVsIChub3QgdGhlIHZpZXcpXG4gICAgICAgIC8vIHNpbmNlIGlmIHRoZXJlIGlzIGFuIGVycm9yIHRoZSBvcmlnaW5hbCBzZW5kZXIgd2lsbFxuICAgICAgICAvLyBoYXZlIGFuIGlkXG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21waWxlXCIsXG4gICAgICAgICAgICAgICAgY29kZVN0cmluZzogc2NyaXB0LFxuICAgICAgICAgICAgICAgIHRhcmdldElkOiB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImRvSXRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9ucygpe1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uaWQgPSBcImhhbG8tZmllbGQtbG9jay1lZGl0b3JcIjtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLmlubmVySFRNTCA9IGhhbG9Mb2NrQnV0dG9uU1ZHO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnYm90dG9tLXJvdycpO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnTG9jayBFZGl0aW5nJyk7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdzZXRQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgYXJnczogW1wiZWRpdGFibGVcIiwgZmFsc2VdLFxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgLy8gY2xvc2Uvb3BlbiB0aGUgaGFsbyB0byB1cGRhdGUgdGhlIGVkaXRpbmcgc3RhdGUgdG9nZ2xlIGJ1dHRvblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5pZCA9IFwiaGFsby1maWVsZC11bmxvY2stZWRpdG9yXCI7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uaW5uZXJIVE1MID0gaGFsb1VubG9ja0J1dHRvblNWRztcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdib3R0b20tcm93Jyk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ1VubG9jayBFZGl0aW5nJyk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ3NldFByb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJlZGl0YWJsZVwiLCB0cnVlXSxcbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgLy8gY2xvc2Uvb3BlbiB0aGUgaGFsbyB0byB1cGRhdGUgdGhlIGVkaXRpbmcgc3RhdGUgdG9vZ2xlIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uKTtcbiAgICB9XG5cbiAgICAvLyBPdmVyd3JpdGluZyB0aGUgYmFzZSBjbGFzcyBvcGVuL2Nsb3NlIGVkaXRvciBtZXRob2RzXG4gICAgb3BlbkVkaXRvcigpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLm9wZW5FZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgIH1cblxuICAgIGNsb3NlRWRpdG9yKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xvc2VFZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBJIGNvbnZlcnQgcmF3IHRleHQgdG8gaHRtbCByZXNwZWN0aW5nIHRoZSBGaXJlZm94XG4gICAgICogY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZSBndWlkZWxuZXMuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHNpbmdsZSBsaW5zIG9mIHRleHQgYXJlIGxlZnQgYXMgaXM7XG4gICAgICogbXVsdGlsaW5lIHRleHQsIGkuZS4gdGV4dCB3aGljaCBpbmNsdWRlcyBcIlxcblwiLCBpc1xuICAgICAqIHdyYXBwZWQgaW4gPGRpdj48L2Rpdj4gZm9yIGV2ZXJ5IGxpbmU7IGFuZCB0aGUgbGFzdFxuICAgICAqIGxpbmUgZ2V0cyBhIDxicj4gdGFnIGluc2VydGVkIGJlZm9yZSB0aGUgPC9kaXY+IHRvIHJlZmxlY3RcbiAgICAgKiB0aGUgXCJvbi1lbnRlci1rZXlcIiBiZWhhdmlvci5cbiAgICAgKi9cbiAgICB0ZXh0VG9IdG1sKHRleHQpe1xuICAgICAgICBpZih0ZXh0KXtcbiAgICAgICAgICAgIGxldCB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgaWYodGV4dExpbmVzLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgIGxldCBodG1sID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0ZXh0TGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihsaW5lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gYDxkaXY+JHtsaW5lfTwvZGl2PmA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IFwiPGRpdj48YnI+PC9kaXY+XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIGA8ZGl2PiR7aHRtbH08YnI+PC9kaXY+YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGh0bWxUb1RleHQoZWxlbWVudCl7XG4gICAgICAgIC8vIFRPRE8gdGhpcyBpcyB2ZXJ5IG5haXZlIGFuZCBpZ25vcmVzIG1vc3QgcG9zc2libGUgc3RydWN0dXJlXG4gICAgICAgIGlmKGVsZW1lbnQuaW5uZXJIVE1MKXtcbiAgICAgICAgICAgIC8vIGZpcnN0IHJlcGxhY2UgYWxsIHRoZSBcIjwvZGl2PjxkaXY+XCIgd2l0aCBsaW5lIGJyZWFrc1xuICAgICAgICAgICAgbGV0IGNsZWFuSFRNTCA9ICBlbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKC88XFwvZGl2PjxkaXY+L2csIFwiXFxuXCIpO1xuICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgYWxsIGh0bWxcbiAgICAgICAgICAgIGxldCB0ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBjbGVhbkhUTUw7XG4gICAgICAgICAgICBsZXQgY2xlYW5UZXh0ID0gdGVtcEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB0ZW1wRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhblRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZ2hsaWdodFN5bnRheCgpe1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwic3ludGF4XCIpO1xuICAgICAgICBpZihjdXJyZW50ICYmIGN1cnJlbnQgIT09IFwiZmFsc2VcIil7XG4gICAgICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0U3ludGF4KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbWFudGljcyA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgc2VtYW50aWNzLmFkZE9wZXJhdGlvbihcbiAgICAgICAgICAgIFwiaGlnaGxpZ2h0U3ludGF4XCIsXG4gICAgICAgICAgICBjcmVhdGVIaWdobGlnaHRlcih0aGlzKVxuICAgICAgICApO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcInRleHRcIlxuICAgICAgICApO1xuICAgICAgICBpZighdGV4dCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0hUTUwgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLm1hcChsaW5lID0+IHtcbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHJ1bGUgYW5kIHRyeSB0byBtYXRjaFxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3N5bnRheFJ1bGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMuX3N5bnRheFJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5tYXRjaChsaW5lLCBydWxlKTtcbiAgICAgICAgICAgICAgICBpZihtYXRjaC5zdWNjZWVkZWQoKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY3MobWF0Y2gpLmhpZ2hsaWdodFN5bnRheCgpLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcblxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJpbm5lckhUTUxcIixcbiAgICAgICAgICAgIG5ld0hUTUxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZShcInN5bnRheFwiLCB0cnVlKTtcbiAgICB9XG5cbiAgICB1bmhpZ2hsaWdodFN5bnRheCgpe1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcInRleHRcIlxuICAgICAgICApO1xuICAgICAgICBpZighdGV4dCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBsYWluRWxlbWVudHMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLm1hcChsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZGl2LmlubmVyVGV4dCA9IGxpbmU7XG4gICAgICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpbmFsTGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGZpbmFsTGluZS5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgICAgcGxhaW5FbGVtZW50cy5wdXNoKGZpbmFsTGluZSk7XG5cbiAgICAgICAgbGV0IG5ld0hUTUwgPSBcIlwiO1xuICAgICAgICBwbGFpbkVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBuZXdIVE1MICs9IGVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJpbm5lckhUTUxcIixcbiAgICAgICAgICAgIG5ld0hUTUxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZShcInN5bnRheFwiLCBmYWxzZSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBGaWVsZFZpZXcsXG4gICAgRmllbGRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIE5ldyBIYWxvXG4gKi9cblxuLyoqIE5vdGU6IEljb25zIGFyZSBmcm9tIFxuKioqIGh0dHBzOi8vdGFibGVyaWNvbnMuY29tL1xuKiovXG5jb25zdCBkZWxldGVJY29uID1gXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItdHJhc2hcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8bGluZSB4MT1cIjRcIiB5MT1cIjdcIiB4Mj1cIjIwXCIgeTI9XCI3XCIgLz5cbiAgPGxpbmUgeDE9XCIxMFwiIHkxPVwiMTFcIiB4Mj1cIjEwXCIgeTI9XCIxN1wiIC8+XG4gIDxsaW5lIHgxPVwiMTRcIiB5MT1cIjExXCIgeDI9XCIxNFwiIHkyPVwiMTdcIiAvPlxuICA8cGF0aCBkPVwiTTUgN2wxIDEyYTIgMiAwIDAgMCAyIDJoOGEyIDIgMCAwIDAgMiAtMmwxIC0xMlwiIC8+XG4gIDxwYXRoIGQ9XCJNOSA3di0zYTEgMSAwIDAgMSAxIC0xaDRhMSAxIDAgMCAxIDEgMXYzXCIgLz5cbjwvc3ZnPlxuYDtcbmNvbnN0IGVkaXRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWVkaXRcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTkgN2gtM2EyIDIgMCAwIDAgLTIgMnY5YTIgMiAwIDAgMCAyIDJoOWEyIDIgMCAwIDAgMiAtMnYtM1wiIC8+XG4gIDxwYXRoIGQ9XCJNOSAxNWgzbDguNSAtOC41YTEuNSAxLjUgMCAwIDAgLTMgLTNsLTguNSA4LjV2M1wiIC8+XG4gIDxsaW5lIHgxPVwiMTZcIiB5MT1cIjVcIiB4Mj1cIjE5XCIgeTI9XCI4XCIgLz5cbjwvc3ZnPlxuYDtcbmNvbnN0IGdyb3dJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWFycm93cy1kaWFnb25hbC0yXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjE2IDIwIDIwIDIwIDIwIDE2XCIgLz5cbiAgPGxpbmUgeDE9XCIxNFwiIHkxPVwiMTRcIiB4Mj1cIjIwXCIgeTI9XCIyMFwiIC8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCI4IDQgNCA0IDQgOFwiIC8+XG4gIDxsaW5lIHgxPVwiNFwiIHkxPVwiNFwiIHgyPVwiMTBcIiB5Mj1cIjEwXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY29weUljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY29weVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHJlY3QgeD1cIjhcIiB5PVwiOFwiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHJ4PVwiMlwiPjwvcmVjdD5cbiAgIDxwYXRoIGQ9XCJNMTYgOHYtMmEyIDIgMCAwIDAgLTIgLTJoLThhMiAyIDAgMCAwIC0yIDJ2OGEyIDIgMCAwIDAgMiAyaDJcIj48L3BhdGg+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHBhc3RlSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jbGlwYm9hcmQtY2hlY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxwYXRoIGQ9XCJNOSA1aC0yYTIgMiAwIDAgMCAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTBhMiAyIDAgMCAwIDIgLTJ2LTEyYTIgMiAwIDAgMCAtMiAtMmgtMlwiPjwvcGF0aD5cbiAgIDxyZWN0IHg9XCI5XCIgeT1cIjNcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCI0XCIgcng9XCIyXCI+PC9yZWN0PlxuICAgPHBhdGggZD1cIk05IDE0bDIgMmw0IC00XCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0YXJnZXRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWZvY3VzXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPjwvY2lyY2xlPlxuICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI5XCI+PC9jaXJjbGU+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHNldHRpbmdzSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zZXR0aW5nc1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAuMzI1IDQuMzE3Yy40MjYgLTEuNzU2IDIuOTI0IC0xLjc1NiAzLjM1IDBhMS43MjQgMS43MjQgMCAwIDAgMi41NzMgMS4wNjZjMS41NDMgLS45NCAzLjMxIC44MjYgMi4zNyAyLjM3YTEuNzI0IDEuNzI0IDAgMCAwIDEuMDY1IDIuNTcyYzEuNzU2IC40MjYgMS43NTYgMi45MjQgMCAzLjM1YTEuNzI0IDEuNzI0IDAgMCAwIC0xLjA2NiAyLjU3M2MuOTQgMS41NDMgLS44MjYgMy4zMSAtMi4zNyAyLjM3YTEuNzI0IDEuNzI0IDAgMCAwIC0yLjU3MiAxLjA2NWMtLjQyNiAxLjc1NiAtMi45MjQgMS43NTYgLTMuMzUgMGExLjcyNCAxLjcyNCAwIDAgMCAtMi41NzMgLTEuMDY2Yy0xLjU0MyAuOTQgLTMuMzEgLS44MjYgLTIuMzcgLTIuMzdhMS43MjQgMS43MjQgMCAwIDAgLTEuMDY1IC0yLjU3MmMtMS43NTYgLS40MjYgLTEuNzU2IC0yLjkyNCAwIC0zLjM1YTEuNzI0IDEuNzI0IDAgMCAwIDEuMDY2IC0yLjU3M2MtLjk0IC0xLjU0MyAuODI2IC0zLjMxIDIuMzcgLTIuMzdjMSAuNjA4IDIuMjk2IC4wNyAyLjU3MiAtMS4wNjV6XCIgLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIzXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3Qgcm90YXRlSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1yb3RhdGUtY2xvY2t3aXNlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8cGF0aCBkPVwiTTQuMDUgMTFhOCA4IDAgMSAxIC41IDRtLS41IDV2LTVoNVwiPjwvcGF0aD5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gOmhvc3Qge1xuICAgICAtLWhhbG8tYnV0dG9uLWhlaWdodDogMjVweDtcbiAgICAgLS1oYWxvLWJ1dHRvbi13aWR0aDogMjVweDtcbiAgICAgLS1oYWxvLXJpbS1tYXJnaW46IDEwcHg7XG4gICAgIC0taGFsby1idXR0b24td2lkdGgtcGFkZGVkOiBjYWxjKHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoKSArIHZhcigtLWhhbG8tcmltLW1hcmdpbikpO1xuICAgICAtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQ6IGNhbGModmFyKC0taGFsby1idXR0b24taGVpZ2h0KSArIHZhcigtLWhhbG8tcmltLW1hcmdpbikpO1xuICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgIHRvcDogY2FsYygtMSAqIHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpKTtcbiAgICAgbGVmdDogY2FsYygtMSAqIHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoLXBhZGRlZCkpO1xuICAgICB3aWR0aDogY2FsYygxMDAlICsgKDIgKiB2YXIoLS1oYWxvLWJ1dHRvbi13aWR0aC1wYWRkZWQpKSk7XG4gICAgIGhlaWdodDogY2FsYygxMDAlICsgKDIgKiB2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQtcGFkZGVkKSkpO1xuICAgICBjb2xvcjogaW5pdGlhbDtcbiAgICAgei1pbmRleDogMTA7XG4gfVxuXG5cbiAuaGFsby1yb3csXG4gLmhhbG8tY29sdW1uIHtcbiAgICAgZGlzcGxheTogZmxleDtcbiAgICAgcG9zaXRpb246IGFic29sdXRlO1xuIH1cblxuIC5oYWxvLWNvbHVtbiB7XG4gICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gfVxuXG4gI2hhbG8tdG9wLXJvdyxcbiAjaGFsby1ib3R0b20tcm93IHtcbiAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoLXBhZGRlZCkpO1xuICAgICBoZWlnaHQ6IHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpO1xuIH1cblxuICNoYWxvLXRvcC1yb3cge1xuICAgICBsZWZ0OiAwO1xuICAgICB0b3A6IDA7XG4gfVxuXG4gI2hhbG8tYm90dG9tLXJvdyB7XG4gICAgIHJpZ2h0OiAwO1xuICAgICBib3R0b206IDA7XG4gICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuIH1cblxuICNoYWxvLXJpZ2h0LWNvbHVtbixcbiAjaGFsby1sZWZ0LWNvbHVtbiB7XG4gICAgIGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0taGFsby1idXR0b24taGVpZ2h0LXBhZGRlZCkpO1xuICAgICB3aWR0aDogdmFyKC0taGFsby1idXR0b24td2lkdGgtcGFkZGVkKTtcbiB9XG5cbiAjaGFsby1yaWdodC1jb2x1bW4ge1xuICAgICByaWdodDogMDtcbiAgICAgdG9wOiAwO1xuICAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gfVxuXG4gI2hhbG8tbGVmdC1jb2x1bW4ge1xuICAgICBsZWZ0OiAwO1xuICAgICB0b3A6IHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpO1xuIH1cblxuIC5oYWxvLWJ1dHRvbixcbiA6OnNsb3R0ZWQoKikge1xuICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjgpO1xuICAgICB3aWR0aDogdmFyKC0taGFsby1idXR0b24td2lkdGgpO1xuICAgICBoZWlnaHQ6IHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodCk7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyMjAsIDIyMCwgMjIwKTtcbiB9XG5cbiAuaGFsby1idXR0b246aG92ZXJcbiA6OnNsb3R0ZWQoKikuaGFsby1idXR0b246aG92ZXIge1xuICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gfVxuXG4gLmhhbG8tYnV0dG9uOmFjdGl2ZVxuIDo6c2xvdHRlZCgqKS5oYWxvLWJ1dHRvbjphY3RpdmUge1xuICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiB9XG5cbiAuaGFsby1idXR0b24uaGlkZGVuXG4gOjpzbG90dGVkKCopLmhhbG8tYnV0dG9uLmhpZGRlbiB7XG4gICAgIGRpc3BsYXk6IG5vbmU7XG4gfVxuXG48L3N0eWxlPlxuXG48ZGl2IGlkPVwiaGFsby10b3Atcm93XCIgY2xhc3M9XCJoYWxvLXJvd1wiPlxuICAgIDxkaXYgaWQ9XCJoYWxvLWRlbGV0ZVwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIkRlbGV0ZSB0aGlzIHBhcnRcIj5cbiAgICAgICAgJHtkZWxldGVJY29ufVxuICAgIDwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJ0b3Atcm93XCI+PC9zbG90PlxuPC9kaXY+XG5cbjxkaXYgaWQ9XCJoYWxvLWJvdHRvbS1yb3dcIiBjbGFzcz1cImhhbG8tcm93XCI+XG4gICAgPGRpdiBpZD1cImhhbG8tcmVzaXplXCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiUmVzaXplIHRoaXMgcGFydFwiPlxuICAgICAgICAke2dyb3dJY29ufVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoYWxvLXNjcmlwdC1lZGl0XCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiRWRpdCB0aGlzIHBhcnQncyBzY3JpcHRcIj5cbiAgICAgICAgJHtlZGl0SWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwiaGFsby1lZGl0XCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiRWRpdCB0aGlzIHBhcnRcIj5cbiAgICAgICAgJHtzZXR0aW5nc0ljb259XG4gICAgPC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cImJvdHRvbS1yb3dcIj48L3Nsb3Q+XG48L2Rpdj5cblxuPGRpdiBpZD1cImhhbG8tbGVmdC1jb2x1bW5cIiBjbGFzcz1cImhhbG8tY29sdW1uXCI+XG4gICAgPGRpdiBpZD1cImhhbG8tY29weVwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIkNvcHkgdGhpcyBQYXJ0XCI+XG4gICAgICAgICR7Y29weUljb259XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImhhbG8tcGFzdGVcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJQYXN0ZSB0aGUgY29udGVudHMgb2YgY2xpcGJvYXJkIGludG8gdGhpcyBQYXJ0XCI+XG4gICAgICAgICR7cGFzdGVJY29ufVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoYWxvLXRhcmdldFwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIlNlbGVjdCB0aGlzIFBhcnQncyB0YXJnZXRcIj5cbiAgICAgICAgJHt0YXJnZXRJY29ufVxuICAgIDwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJsZWZ0LWNvbHVtblwiPjwvc2xvdD5cbjwvZGl2PlxuXG48ZGl2IGlkPVwiaGFsby1yaWdodC1jb2x1bW5cIiBjbGFzcz1cImhhbG8tY29sdW1uXCI+XG4gICAgPGRpdiBpZD1cImhhbG8tcm90YXRlXCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiUm90YXRlIHRoaXMgcGFydFwiPlxuICAgICAgICAke3JvdGF0ZUljb259XG4gICAgPC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cInJpZ2h0LWNvbHVtblwiPjwvc2xvdD5cbjwvZGl2PlxuXG5gO1xuXG5jbGFzcyBIYWxvIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHRoZSBTaGFkb3cgRE9NIGFuZCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG5cblxuICAgICAgICAvLyBCaW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemVNb3VzZURvd24gPSB0aGlzLm9uUmVzaXplTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemVNb3VzZVVwID0gdGhpcy5vblJlc2l6ZU1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZU1vdXNlTW92ZSA9IHRoaXMub25SZXNpemVNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJvdGF0ZU1vdXNlRG93biA9IHRoaXMub25Sb3RhdGVNb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJvdGF0ZU1vdXNlVXAgPSB0aGlzLm9uUm90YXRlTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUm90YXRlTW91c2VNb3ZlID0gdGhpcy5vblJvdGF0ZU1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRSb290Tm9kZSgpLmhvc3Q7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZWRpdGluZycpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50Lmhhc09wZW5IYWxvID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcblxuICAgICAgICAgICAgLy8gUmVzaXplIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5yZXNpemVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXJlc2l6ZScpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25SZXNpemVNb3VzZURvd24pO1xuICAgICAgICAgICAgaWYoIXRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9SZXNpemUpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJvdGF0ZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMucm90YXRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1yb3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMucm90YXRlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUm90YXRlTW91c2VEb3duKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvUm90YXRlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVsZXRlIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5kZWxldGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLWRlbGV0ZScpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb0RlbGV0ZSk7XG4gICAgICAgICAgICBpZighdGhpcy50YXJnZXRFbGVtZW50LndhbnRzSGFsb0RlbGV0ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWRpdCBidXR0b25cbiAgICAgICAgICAgIHRoaXMuc2NyaXB0RWRpdG9yID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXNjcmlwdC1lZGl0Jyk7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdEVkaXRvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9PcGVuU2NyaXB0RWRpdG9yKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvU2NyaXB0RWRpdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JpcHRFZGl0b3Iuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wcmVoZW5zaXZlIGVkaXRvciBidXR0b25cbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLWVkaXQnKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb09wZW5FZGl0b3IpO1xuICAgICAgICAgICAgaWYoIXRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9FZGl0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLmNvcGllciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1jb3B5Jyk7XG4gICAgICAgICAgICB0aGlzLmNvcGllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9Db3B5KTtcblxuXG4gICAgICAgICAgICAvLyBQYXN0ZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMucGFzdGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXBhc3RlJyk7XG4gICAgICAgICAgICB0aGlzLnBhc3Rlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9QYXN0ZSk7XG5cbiAgICAgICAgICAgIC8vIFRhcmdldCBidXR0b25cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tdGFyZ2V0Jyk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb1RhcmdldCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VFbnRlcik7XG4gICAgICAgICAgICB0aGlzLnRhcmdldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZWRpdGluZycpO1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQuaGFzT3BlbkhhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgIHRoaXMucmVzaXplci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUmVzaXplTW91c2VEb3duKTtcbiAgICB9XG5cblxuICAgIC8qIEV2ZW50IEhhbmRsaW5nICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiB0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvTW92ZSl7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIGxldCBjdXJyZW50VG9wID0gcGFyc2VJbnQodGhpcy50YXJnZXRFbGVtZW50LnN0eWxlLnRvcCk7XG4gICAgICAgIGxldCBjdXJyZW50TGVmdCA9IHBhcnNlSW50KHRoaXMudGFyZ2V0RWxlbWVudC5zdHlsZS5sZWZ0KTtcbiAgICAgICAgbGV0IG5ld1RvcCA9IGV2ZW50Lm1vdmVtZW50WSArIGN1cnJlbnRUb3A7XG4gICAgICAgIGxldCBuZXdMZWZ0ID0gZXZlbnQubW92ZW1lbnRYICsgY3VycmVudExlZnQ7XG5cbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy50YXJnZXRFbGVtZW50Lm1vZGVsO1xuICAgICAgICBtb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG1vZGVsLCBcInRvcFwiLCBuZXdUb3ApO1xuICAgICAgICBtb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG1vZGVsLCBcImxlZnRcIiwgbmV3TGVmdCk7XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVNb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJlc2l6ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUmVzaXplTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVNb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJlc2l6ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUmVzaXplTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVNb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvUmVzaXplKFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRYLFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRZXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb25Sb3RhdGVNb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJvdGF0ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUm90YXRlTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25Sb3RhdGVNb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJvdGF0ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUm90YXRlTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25Sb3RhdGVNb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvUm90YXRlKFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRYLFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRZXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBIYWxvLFxuICAgIEhhbG8gYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgbGlua0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbGlua1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAgMTRhMy41IDMuNSAwIDAgMCA1IDBsNCAtNGEzLjUgMy41IDAgMCAwIC01IC01bC0uNSAuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTBhMy41IDMuNSAwIDAgMCAtNSAwbC00IDRhMy41IDMuNSAwIDAgMCA1IDVsLjUgLS41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgcGljdHVyZUljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcGhvdG9cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxsaW5lIHgxPVwiMTVcIiB5MT1cIjhcIiB4Mj1cIjE1LjAxXCIgeTI9XCI4XCI+PC9saW5lPlxuICAgPHJlY3QgeD1cIjRcIiB5PVwiNFwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiM1wiPjwvcmVjdD5cbiAgIDxwYXRoIGQ9XCJNNCAxNWw0IC00YTMgNSAwIDAgMSAzIDBsNSA1XCI+PC9wYXRoPlxuICAgPHBhdGggZD1cIk0xNCAxNGwxIC0xYTMgNSAwIDAgMSAzIDBsMiAyXCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxpbWcgaWQ9XCJ3cmFwcGVkLWltYWdlXCIgY2xhc3M9XCJoaWRkZW5cIiAvPlxuPHN2ZyBjbGFzcz1cImhpZGRlblwiIGlkPVwid3JhcHBlZC1zdmdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG48L3N2Zz5cbjxzdHlsZT5cbjpob3N0IHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLmhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbmltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4uY3VycmVudGx5LXdyYXBwZWQge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cbjwvc3R5bGU+XG5gO1xuXG5jbGFzcyBJbWFnZVZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMudXBkYXRlSW1hZ2VEYXRhID0gdGhpcy51cGRhdGVJbWFnZURhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdmdJbWFnZSA9IHRoaXMudXBkYXRlU3ZnSW1hZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVCaW5hcnlJbWFnZSA9IHRoaXMudXBkYXRlQmluYXJ5SW1hZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXREZWZhdWx0SW1hZ2UgPSB0aGlzLnNldERlZmF1bHRJbWFnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbWFnZUxpbmsgPSB0aGlzLnVwZGF0ZUltYWdlTGluay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZ0ZvclZpZXdwb3J0ID0gdGhpcy51cGRhdGVTaXppbmdGb3JWaWV3cG9ydC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gcHJvcCBjaGFuZ2VzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwiaW1hZ2VEYXRhXCIsIChpbWFnZURhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKCFpbWFnZURhdGEpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEltYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlRGF0YShpbWFnZURhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBpbWFnZURhdGEuIElmIG5vdCwgdHJ5XG4gICAgICAgIC8vIHRvIGxvYWQgZnJvbSBhIHNyYy5cbiAgICAgICAgbGV0IGN1cnJlbnRJbWFnZURhdGEgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJpbWFnZURhdGFcIlxuICAgICAgICApO1xuICAgICAgICBsZXQgY3VycmVudFNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcInNyY1wiXG4gICAgICAgICk7XG4gICAgICAgIGlmKCFjdXJyZW50SW1hZ2VEYXRhKXtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdsb2FkSW1hZ2VGcm9tJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyBjdXJyZW50U3JjIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2UobXNnLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0SW1hZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2VEYXRhKGN1cnJlbnRJbWFnZURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgaWYoIXRoaXMuaGFsb0J1dHRvbil7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIHNldERlZmF1bHRJbWFnZSgpe1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJpbWFnZURhdGFcIiwgcGljdHVyZUljb24pO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJtaW1lVHlwZVwiLCBcImltYWdlL3N2Z1wiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwic3JjXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUltYWdlRGF0YShwaWN0dXJlSWNvbik7XG4gICAgfVxuXG4gICAgdXBkYXRlSW1hZ2VEYXRhKGltYWdlRGF0YSl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwuaXNTdmcpe1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdmdJbWFnZShpbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCaW5hcnlJbWFnZShpbWFnZURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlQmluYXJ5SW1hZ2UoaW1hZ2VEYXRhKXtcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgaW1hZ2VEYXRhIGlzXG4gICAgICAgIC8vIGEgYmFzZTY0IGVuY29kZWQgZGF0YSB1cmwgZGVzY3JpYmluZ1xuICAgICAgICAvLyB0aGUgYml0cyBvZiB0aGUgaW1hZ2UuXG4gICAgICAgIGxldCBpbWdFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZWQtaW1hZ2UnKTtcbiAgICAgICAgbGV0IHN2Z0VsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnd3JhcHBlZC1zdmcnKTtcbiAgICAgICAgc3ZnRWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIHN2Z0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGltZ0VsLmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGltZ0VsLnNyYyA9IGltYWdlRGF0YTtcbiAgICAgICAgaW1nRWwub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgLy90aGlzLnVwZGF0ZVNpemluZ0ZvclZpZXdwb3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJlc2VydmVBc3BlY3RPblJlc2l6ZSA9IHRydWU7XG4gICAgICAgIGltZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIH1cblxuICAgIHVwZGF0ZVN2Z0ltYWdlKGltYWdlRGF0YSl7XG4gICAgICAgIGxldCBpbWdFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZWQtaW1hZ2UnKTtcbiAgICAgICAgbGV0IGN1cnJlbnRTdmdFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZWQtc3ZnJyk7XG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGxldCB4bWxEb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaW1hZ2VEYXRhLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgIGxldCBuZXdTdmdFbCA9IHhtbERvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgU1ZHIGhhcyBzb21lIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlc1xuICAgICAgICAvLyBzZXQgc28gd2UgaGF2ZSBpbml0aWFsIGRpbWVuc2lvbnMgdG8gZGlzcGxheS4gSWYgbm90IHByZXNlbnQsXG4gICAgICAgIC8vIHB1bGwgZnJvbSB2aWV3Ym94LlxuICAgICAgICBpZighbmV3U3ZnRWwuaGFzQXR0cmlidXRlKCd3aWR0aCcpIHx8ICFuZXdTdmdFbC5oYXNBdHRyaWJ1dGUoJ2hlaWdodCcpKXtcbiAgICAgICAgICAgIGxldCB2aWV3Qm94ID0gbmV3U3ZnRWwuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgICAgICAgICBpZih2aWV3Qm94KXtcbiAgICAgICAgICAgICAgICB2aWV3Qm94ID0gdmlld0JveC5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdCb3hXaWR0aCA9IHBhcnNlSW50KHZpZXdCb3hbMl0pO1xuICAgICAgICAgICAgICAgIGxldCB2aWV3Qm94SGVpZ2h0ID0gcGFyc2VJbnQodmlld0JveFszXSk7XG4gICAgICAgICAgICAgICAgbmV3U3ZnRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB2aWV3Qm94SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBuZXdTdmdFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdmlld0JveFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgbmV3U3ZnRWwuaWQgPSAnd3JhcHBlZC1zdmcnO1xuICAgICAgICBuZXdTdmdFbC5jbGFzc0xpc3QuYWRkKCdjdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBpbWdFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgaW1nRWwuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudGx5LXdyYXBwZWQnKTtcbiAgICAgICAgY3VycmVudFN2Z0VsLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKG5ld1N2Z0VsKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmdGb3JWaWV3cG9ydCgpO1xuICAgICAgICB0aGlzLnByZXNlcnZlQXNwZWN0T25SZXNpemUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbWFnZUxpbmsoZXZlbnQpe1xuICAgICAgICAvLyBUZWxscyB0aGUgbW9kZWwgdG8gdXBkYXRlIGl0c1xuICAgICAgICAvLyBzcmMgbGluayBmb3IgdGhlIGltYWdlXG4gICAgICAgIGxldCBjdXJyZW50U3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdzcmMnXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZXN1bHQgPSB3aW5kb3cucHJvbXB0KFwiRWRpdCBVUkwgZm9yIGltYWdlOlwiLCBjdXJyZW50U3JjKTtcbiAgICAgICAgaWYocmVzdWx0ICYmIHJlc3VsdCAhPT0gJycgJiYgcmVzdWx0ICE9PSBjdXJyZW50U3JjKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbG9hZEltYWdlRnJvbScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsgcmVzdWx0IF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVTaXppbmdGb3JWaWV3cG9ydCgpe1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdCBkaXNwbGF5IGxhcmdlclxuICAgICAgICAvLyB0aGFuIHRoZSBjdXJyZW50IHJlbWFpbmluZyBzdWJyZWN0YW5nbGUgb2YgaXRzIG9yaWdpblxuICAgICAgICAvLyBhbmQgdGhlIGNvcm5lciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgbGV0IHBhZGRpbmcgPSA0MDtcbiAgICAgICAgLy8gRmlyc3QsIHdlIG5lZWQgdG8gZmluZCB0aGUgYWJzb2x1dGUgdG9wIGNvcm5lclxuICAgICAgICAvLyBsb2NhdGlvbnMgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgIGxldCBlbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmN1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGxldCB0b3AgPSAwO1xuICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgIHdoaWxlKGVsKXtcbiAgICAgICAgICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgICAgICAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG4gICAgICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGhlaWdodExpbWl0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIHBhZGRpbmc7XG4gICAgICAgIGlmKChyZWN0LmhlaWdodCArIHRvcCkgPiBoZWlnaHRMaW1pdCl7XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSAoaGVpZ2h0TGltaXQgLSB0b3ApIC8gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAvLyB0aGlzLnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0ICogcmF0aW99cHhgO1xuICAgICAgICAgICAgLy8gdGhpcy5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGggKiByYXRpb31weGA7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAgIChyZWN0LndpZHRoICogcmF0aW8pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgICAgKHJlY3QuaGVpZ2h0ICogcmF0aW8pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9CdXR0b24pO1xuICAgIH1cblxuICAgIG9uSGFsb1Jlc2l6ZShtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICAgIC8vIFdlIHJlc2l6ZSB0aGUgd3JhcHBlZCBzdmcgb3IgaW1nIGluc3RlYWRcbiAgICAgICAgLy8gYW5kIGhhdmUgdGhlIG91dGVyIGNvbXBvbmVudCBzaW1wbHkgcmVhY3QgdG9cbiAgICAgICAgLy8gdGhlIGNoYW5nZS5cbiAgICAgICAgLy8gSWYgdGhlIHBhcnQgaXMgcm90YXRlZCB0aGlzIHdpbGwgdGhyb3cgb2ZmIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgICAgLy8gYnJvd3NlciBjYWxjdWFsdGlvbi4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byByb3RhdGUgdGhlIHBhcnQgdG8gMFxuICAgICAgICAvLyAoaWYgbmVjZXNzYXJ5KSBkbyB0aGUgY2FsY3VsYXRpb25zIGFuZCB0aGVuIHJvdGF0ZSBpdCBiYWNrXG4gICAgICAgIGxldCBhbmdsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiKTtcbiAgICAgICAgaWYoYW5nbGUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwcGVkSW1hZ2UgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5jdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBsZXQgcmVjdCA9IHdyYXBwZWRJbWFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG5ld1dpZHRoLCBuZXdIZWlnaHQ7XG4gICAgICAgIGlmKHRoaXMucHJlc2VydmVBc3BlY3RPblJlc2l6ZSl7XG4gICAgICAgICAgICBsZXQgbWF4V2lkdGggPSByZWN0LndpZHRoICsgbW92ZW1lbnRYO1xuICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgbW92ZW1lbnRZO1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gTWF0aC5taW4obWF4V2lkdGggLyByZWN0LndpZHRoLCBtYXhIZWlnaHQgLyByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSByZWN0LmhlaWdodCAqIHJhdGlvO1xuICAgICAgICAgICAgbmV3V2lkdGggPSByZWN0LndpZHRoICogcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHJlY3Qud2lkdGggKyBtb3ZlbWVudFg7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSByZWN0LmhlaWdodCArIG1vdmVtZW50WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5ld1dpZHRoICYmIG5ld0hlaWdodCl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRoZSByb3RhdGUgYW5nbGUgdG8gdGhlIG9yaWdpbmFsIChpZiBuZWNlc3NhcnkpXG4gICAgICAgIGlmKGFuZ2xlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbigpe1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlkID0gJ2hhbG8taW1hZ2UtbGluayc7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaW5uZXJIVE1MID0gbGlua0ljb247XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zdHlsZS5tYXJnaW5Ub3AgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ3JpZ2h0LWNvbHVtbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdFZGl0IGxpbmsgZm9yIGltYWdlIGZpbGUnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVJbWFnZUxpbmspO1xuICAgIH1cblxuICAgIGFkZENvbnRleHRNZW51SXRlbXMoY29udGV4dE1lbnUpe1xuICAgICAgICBjb250ZXh0TWVudS5hZGRTcGFjZXIoKTtcbiAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnRWRpdCBJbWFnZSBVUkwnLFxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbWFnZUxpbmtcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEltYWdlVmlldyxcbiAgICBJbWFnZVZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogUGFydFZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gKmFic3RyYWN0KiB3ZWJjb21wb2VudCBDdXN0b21FbGVtZW50XG4gKiB0aGF0IHNlcnZlcyBhcyB0aGUgZ2VuZXJpYyB2aWV3IGZvciBhbnkgUGFydFxuICogbW9kZWxzLlxuICogSSBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseSwgbm9yIHNob3VsZFxuICogSSBiZSBhZGRlZCB0byBhbnkgd2ViIHBhZ2UncyByZWdpc3RyeSBvZiBDdXN0b21FbGVtZW50cy5cbiAqIEkgYW0gaW5kZW5kZWQgdG8gYmUgZXh0ZW5kZWQgKHN1YmNsYXNzZWQpIGJ5IHRoZSBhY3R1YWxcbiAqIHZpZXdzIGZvciBlYWNoIFBhcnQga2luZCwgYW5kIHRoZXJlZm9yZSBJIGNvbnRhaW4gYWxsXG4gKiBvZiB0aGUgY29tbW9uIGJlaGF2aW9yLCBpbmNsdWRpbmcgbGlmZWN5Y2xlIG1ldGhvZHMsXG4gKiBmb3IgdGhlc2UuXG4gKi9cbmltcG9ydCBDb250ZXh0TWVudSBmcm9tICcuL2NvbnRleHRtZW51L0NvbnRleHRNZW51LmpzJztcbmltcG9ydCBpbnRlcnByZXRlclNlbWFudGljcyBmcm9tICcuLi8uLi9vaG0vaW50ZXJwcmV0ZXItc2VtYW50aWNzLmpzJztcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3QtY29udGV4dC1tZW51JywgQ29udGV4dE1lbnUpO1xuXG5jbGFzcyBQYXJ0VmlldyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1BhcnRWaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xlbnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMucHJvcENoYW5nZUhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2V0dXBCYXNlUHJvcEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZUhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2V0dXBCYXNlVmlld0NoYW5nZUhhbmRsZXJzKCk7XG5cbiAgICAgICAgLy8gSGFsbyBzZXR0aW5ncy4gQWxsIGFyZSBvbiBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMud2FudHNIYWxvUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG9Sb3RhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsb1NjcmlwdEVkaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsb0VkaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsb0RlbGV0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gdHJ1ZTtcbiAgICAgICAgLy8gTm90ZTogc2VlIGdldHRlciBmb3Igd2FudHNIYWxvTW92ZVxuXG4gICAgICAgIC8vIENvbnRleHQgbWVudSBzZXR0aW5nc1xuICAgICAgICB0aGlzLndhbnRzQ29udGV4dE1lbnUgPSB0cnVlO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXRNb2RlbCA9IHRoaXMuc2V0TW9kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bnNldE1vZGVsID0gdGhpcy51bnNldE1vZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSB0aGlzLnNlbmRNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBCYXNlUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cEJhc2VQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cEJhc2VWaWV3Q2hhbmdlSGFuZGxlcnMgPSB0aGlzLnNldHVwQmFzZVZpZXdDaGFuZ2VIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRMYXlvdXQgPSB0aGlzLmluaXRMYXlvdXQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIGluaXRpYWwgcHJvcGVydHkgbWV0aG9kXG4gICAgICAgIHRoaXMuc3R5bGVDU1MgPSB0aGlzLnN0eWxlQ1NTLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3R5bGVUZXh0Q1NTID0gdGhpcy5zdHlsZVRleHRDU1MuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIHByb3BlcnR5IGNoYW5nZSByZWFjdGlvbiBtZXRob2RzXG4gICAgICAgIHRoaXMucHJpbUhhbmRsZVByb3BDaGFuZ2UgPSB0aGlzLnByaW1IYW5kbGVQcm9wQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlID0gdGhpcy5vblByb3BDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcmltSGFuZGxlVmlld0NoYW5nZSA9IHRoaXMucHJpbUhhbmRsZVZpZXdDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblZpZXdDaGFuZ2UgPSB0aGlzLm9uVmlld0NoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjcmlwdENoYW5nZWQgPSB0aGlzLnNjcmlwdENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sYXlvdXRDaGFuZ2VkID0gdGhpcy5sYXlvdXRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdERpcmVjdGlvbkNoYW5nZWQgPSB0aGlzLmxpc3REaXJlY3Rpb25DaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdFdyYXBwaW5nQ2hhbmdlZCA9IHRoaXMubGlzdFdyYXBwaW5nQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnZSZXNpemluZ0NoYW5nZWQgPSB0aGlzLnZSZXNpemluZ0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oUmVzaXppbmdDaGFuZ2VkID0gdGhpcy5oUmVzaXppbmdDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlubmluZ0xlZnRDaGFuZ2VkID0gdGhpcy5waW5uaW5nTGVmdENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5uaW5nVG9wQ2hhbmdlZCA9IHRoaXMucGlubmluZ1RvcENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5uaW5nQm90dG9tQ2hhbmdlZCA9IHRoaXMucGlubmluZ0JvdHRvbUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkID0gdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdEFsaWdubWVudENoYW5nZWQgPSB0aGlzLmxpc3RBbGlnbm1lbnRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdERpc3RyaWJ1dGlvbkNoYW5nZWQgPSB0aGlzLmxpc3REaXN0cmlidXRpb25DaGFuZ2VkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCB2aWV3IGNoYW5nZSByZWFjdGlvbiBtZXRob2RzXG4gICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZCA9IHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5ld1N1YnBhcnRWaWV3ID0gdGhpcy5uZXdTdWJwYXJ0Vmlldy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgSGFsbyByZWxhdGVkIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vcGVuSGFsbyA9IHRoaXMub3BlbkhhbG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUhhbG8gPSB0aGlzLmNsb3NlSGFsby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb0RlbGV0ZSA9IHRoaXMub25IYWxvRGVsZXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvT3BlbkVkaXRvciA9IHRoaXMub25IYWxvT3BlbkVkaXRvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb09wZW5TY3JpcHRFZGl0b3IgPSB0aGlzLm9uSGFsb09wZW5TY3JpcHRFZGl0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9SZXNpemUgPSB0aGlzLm9uSGFsb1Jlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1JvdGF0ZSA9IHRoaXMub25IYWxvUm90YXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvUGFzdGUgPSB0aGlzLm9uSGFsb1Bhc3RlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvQ29weSA9IHRoaXMub25IYWxvQ29weS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1RhcmdldCA9IHRoaXMub25IYWxvVGFyZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5kSGFsb1RhcmdldCA9IHRoaXMuZW5kSGFsb1RhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlRW50ZXIgPSB0aGlzLm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUxlYXZlID0gdGhpcy5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrID0gdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9PcGVuRWRpdG9yID0gdGhpcy5vbkhhbG9PcGVuRWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25BdXhDbGljayA9IHRoaXMub25BdXhDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2sgPSB0aGlzLm9uQ29udGV4dE1lbnVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0S2V5ID0gdGhpcy5oYW5kbGVUYXJnZXRLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZUNsaWNrID0gdGhpcy5oYW5kbGVUYXJnZXRNb3VzZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdmVyID0gdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU91dCA9IHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZENvbnRleHRNZW51SXRlbXMgPSB0aGlzLmFkZENvbnRleHRNZW51SXRlbXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VGFyZ2V0Vmlld3MgPSB0aGlzLmdldEN1cnJlbnRUYXJnZXRWaWV3cy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgZWRpdG9yIHJlbGF0ZWQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9wZW5FZGl0b3IgPSB0aGlzLm9wZW5FZGl0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvciA9IHRoaXMuY2xvc2VFZGl0b3IuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBDb250ZXh0IG1lbnVcbiAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnVBdCA9IHRoaXMub3BlbkNvbnRleHRNZW51QXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51ID0gdGhpcy5jbG9zZUNvbnRleHRNZW51LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gbWlzY1xuICAgICAgICB0aGlzLmhpZ2hsaWdodCA9IHRoaXMuaGlnaGxpZ2h0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQgPSB0aGlzLnVuaGlnaGxpZ2h0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBsaWZlY3ljbGUgbWV0aG9kc1xuICAgICAgICB0aGlzLmFmdGVyTW9kZWxTZXQgPSB0aGlzLmFmdGVyTW9kZWxTZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZnRlck1vZGVsVW5zZXQgPSB0aGlzLmFmdGVyTW9kZWxVbnNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFmdGVyQ29ubmVjdGVkID0gdGhpcy5hZnRlckNvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFmdGVyRGlzY29ubmVjdGVkID0gdGhpcy5hZnRlckRpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgLy8gRG8gc29tZSB1bml2ZXJzYWwgUGFydFZpZXcgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgLy8gd2hlbiBhdHRhY2hlZCB0byBhIHBhcmVudCBlbGVtZW50LCBsaWtlXG4gICAgICAgICAgICAvLyByZWdpc3RlcmluZyBldmVudCBsaXN0ZW5lcnMgZXRjXG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIG1pZGRsZSBtb3VzZSBidXR0b24gY2xpY2tcbiAgICAgICAgICAgIC8vIHRvIHRvZ2dsZSB0aGUgaGFsb1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhdXhjbGljaycsIHRoaXMub25BdXhDbGljayk7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGRlZmF1bHQgZXZlbnQgaGFuZGxlcnMgbWFudWFsbHldXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVDbGljayk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGxpZmVjeWNsZSBtZXRob2Qgd2hlbiBkb25lXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBhYm92ZVxuICAgICAgICAgICAgdGhpcy5hZnRlckNvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhdXhjbGljaycsIHRoaXMub25BdXhDbGljayk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuICAgICAgICB0aGlzLmFmdGVyRGlzY29ubmVjdGVkKCk7XG4gICAgfVxuXG4gICAgc2V0TW9kZWwoYU1vZGVsKXtcbiAgICAgICAgdGhpcy51bnNldE1vZGVsKCk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIGFNb2RlbC5hZGRQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIGFNb2RlbC5hZGRWaWV3U3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgaWYodGhpcy5pc0xlbnNlZCl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIGFNb2RlbC5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnbGVucy1wYXJ0LWlkJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncGFydC1pZCcsIGFNb2RlbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVhbCB3aXRoICdzcGVjaWFsJyBwcm9wc1xuICAgICAgICBsZXQgd2FudHNNb3ZlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwid2FudHMtbW92ZVwiXG4gICAgICAgICk7XG4gICAgICAgIGlmKHdhbnRzTW92ZSl7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9hZCBhbGwgdGhlIGluaXRpYWwgc3R5bGluZ1xuICAgICAgICB0aGlzLnN0eWxlQ1NTKCk7XG4gICAgICAgIHRoaXMuc3R5bGVUZXh0Q1NTKCk7XG4gICAgICAgIHRoaXMuaW5pdExheW91dCgpO1xuICAgICAgICB0aGlzLmFmdGVyTW9kZWxTZXQoKTtcbiAgICB9XG5cbiAgICB1bnNldE1vZGVsKCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgbGV0IHJlbW92ZWRNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnJlbW92ZVByb3BlcnR5U3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3BhcnQtaWQnLCBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJNb2RlbFVuc2V0KHJlbW92ZWRNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cEJhc2VQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSB3ZSBzaG91bGQgc2V0dXAgYW55XG4gICAgICAgIC8vIHByb3AgY2hhbmdlIGhhbmRsZXJzIHRoYXQgYXJlIHVuaXZlcnNhbFxuICAgICAgICAvLyB0byBhbGwgUGFydFZpZXdzLiBXZSB3b3VsZCBkbyB0aGlzIHZpYVxuICAgICAgICAvLyB0aGUgI29uUHJvcENoYW5nZSBtZXRob2QsIHdoaWNoIHJlZ2lzdGVyc1xuICAgICAgICAvLyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgIC8vIERvIG5vdCBvdmVycmlkZSB0aGlzIG1ldGhvZFxuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgdGhlIHVuaXZlcnNhbHNcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3NjcmlwdCcsIHRoaXMuc2NyaXB0Q2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdudW1iZXInLCB0aGlzLm51bWJlckNoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY3NzU3R5bGUnLCB0aGlzLnN0eWxlQ1NTKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2Nzc1RleHRTdHlsZScsIHRoaXMuc3R5bGVUZXh0Q1NTKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2xheW91dCcsIHRoaXMubGF5b3V0Q2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdsaXN0LWRpcmVjdGlvbicsIHRoaXMubGlzdERpcmVjdGlvbkNoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbGlzdC13cmFwcGluZycsIHRoaXMubGlzdFdyYXBwaW5nQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdsaXN0LWFsaWdubWVudCcsIHRoaXMubGlzdEFsaWdubWVudENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbGlzdC1kaXN0cmlidXRpb24nLCB0aGlzLmxpc3REaXN0cmlidXRpb25DaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2hvcml6b250YWwtcmVzaXppbmcnLCB0aGlzLmhSZXNpemluZ0NoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgndmVydGljYWwtcmVzaXppbmcnLCB0aGlzLnZSZXNpemluZ0NoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgncGlubmluZy10b3AnLCB0aGlzLnBpbm5pbmdUb3BDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Bpbm5pbmctcmlnaHQnLCB0aGlzLnBpbm5pbmdSaWdodENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgncGlubmluZy1sZWZ0JywgdGhpcy5waW5uaW5nTGVmdENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgncGlubmluZy1ib3R0b20nLCB0aGlzLnBpbm5pbmdCb3R0b21DaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3dhbnRzLW1vdmUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmKHZhbHVlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXR1cEJhc2VWaWV3Q2hhbmdlSGFuZGxlcnMoKXtcbiAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSB3ZSBzaG91bGQgc2V0dXAgYW55XG4gICAgICAgIC8vIHZpZXcgY2hhbmdlIGhhbmRsZXJzIHRoYXQgYXJlIHVuaXZlcnNhbFxuICAgICAgICAvLyB0byBhbGwgUGFydFZpZXdzLiBXZSB3b3VsZCBkbyB0aGlzIHZpYVxuICAgICAgICAvLyB0aGUgI29uVmlld0NoYW5nZSBtZXRob2QsIHdoaWNoIHJlZ2lzdGVyc1xuICAgICAgICAvLyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgIC8vIERvIG5vdCBvdmVycmlkZSB0aGlzIG1ldGhvZFxuICAgICAgICB0aGlzLm9uVmlld0NoYW5nZSgnc3VicGFydC1vcmRlcicsIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25WaWV3Q2hhbmdlKCdzdWJwYXJ0LW5ldycsIHRoaXMubmV3U3VicGFydFZpZXcpO1xuICAgIH1cblxuICAgIGluaXRMYXlvdXQoKXtcbiAgICAgICAgLy8gTm90IGFsbCBQYXJ0L1BhcnRWaWV3IHBhaXJzIGhhdmUgdGhlIGxheW91dFxuICAgICAgICAvLyBwcm9wZXJ0aWVzLiBFbnN1cmUgdGhleSBleGlzdCBmaXJzdFxuICAgICAgICBsZXQgaGFzTGF5b3V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCgnbGF5b3V0Jyk7XG4gICAgICAgIGxldCBoYXNCb3hSZXNpemluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoJ3ZlcnRpY2FsLXJlc2l6aW5nJyk7XG4gICAgICAgIGxldCBoYXNQaW5uaW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCgncGlubmluZycpO1xuICAgICAgICBpZihoYXNMYXlvdXQpe1xuICAgICAgICAgICAgbGV0IGluaXRpYWxMYXlvdXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnbGF5b3V0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGlzdERpcmVjdGlvbiA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdsaXN0LWRpcmVjdGlvbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbExpc3RXcmFwcGluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdsaXN0LXdyYXBwaW5nJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2hhbmdlZChpbml0aWFsTGF5b3V0KTtcbiAgICAgICAgICAgIHRoaXMubGlzdERpcmVjdGlvbkNoYW5nZWQoaW5pdGlhbExpc3REaXJlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5saXN0V3JhcHBpbmdDaGFuZ2VkKGluaXRpYWxMaXN0V3JhcHBpbmcpO1xuICAgICAgICAgICAgdGhpcy5saXN0QWxpZ25tZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5saXN0RGlzdHJpYnV0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaGFzQm94UmVzaXppbmcpe1xuICAgICAgICAgICAgbGV0IGluaXRpYWxWUmVzaXppbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAndmVydGljYWwtcmVzaXppbmcnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxIUmVzaXppbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaG9yaXpvbnRhbC1yZXNpemluZydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnZSZXNpemluZ0NoYW5nZWQoaW5pdGlhbFZSZXNpemluZyk7XG4gICAgICAgICAgICB0aGlzLmhSZXNpemluZ0NoYW5nZWQoaW5pdGlhbEhSZXNpemluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihoYXNQaW5uaW5nKXtcbiAgICAgICAgICAgIHRoaXMucGlubmluZ1RvcENoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoaXMucGlubmluZ0JvdHRvbUNoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoaXMucGlubmluZ0xlZnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnBpbm5pbmdSaWdodENoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0eWxlQ1NTKCl7XG4gICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcImNzc1N0eWxlXCIpO1xuICAgICAgICBPYmplY3Qua2V5cyhjc3NTdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjc3NTdHlsZVtrZXldO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0eWxlVGV4dENTUygpe1xuICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJjc3NUZXh0U3R5bGVcIik7XG4gICAgICAgIE9iamVjdC5rZXlzKGNzc1N0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNzc1N0eWxlW2tleV07XG4gICAgICAgICAgICB0aGlzLnN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHRhcmdldCl7XG4gICAgICAgIGlmKCF0aGlzLmlzTGVuc2VkKXtcbiAgICAgICAgICAgIC8vIExlbnNlZCB2aWV3cyBzaG91bGQgbm90IHNlbmQgbWVzc2FnZXNcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHRoaXMsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNlaXZlTWVzc2FnZShhTWVzc2FnZSl7XG4gICAgICAgIHN3aXRjaChhTWVzc2FnZS50eXBlKXtcbiAgICAgICAgY2FzZSAncHJvcGVydHlDaGFuZ2VkJzpcbiAgICAgICAgICAgIHRoaXMucHJpbUhhbmRsZVByb3BDaGFuZ2UoXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UucHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLnZhbHVlLFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLnBhcnRJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2aWV3Q2hhbmdlZCc6XG4gICAgICAgICAgICB0aGlzLnByaW1IYW5kbGVWaWV3Q2hhbmdlKFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNoYW5nZU5hbWUsXG4gICAgICAgICAgICAgICAgLi4uYU1lc3NhZ2UuYXJnc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpbUhhbmRsZVByb3BDaGFuZ2UobmFtZSwgdmFsdWUsIHBhcnRJZCl7XG4gICAgICAgIC8vIFdlIG5vdGlmeSB0aGUgbW9kZWwgdGhhdCB0aGUgcHJvcGVydHkgY2hhbmdlIHNvIHRoYXRcbiAgICAgICAgLy8gb24gcHJvcGVydHlDaGFuZ2VkIGNvbW1hbmQgaGFuZGxlcnMgY291bGQgYmUgaW52b2tlZFxuICAgICAgICAvLyBidXQgd2UgbWFrZSBzdXJlIHRoYXQgdGhpcyBzdG9wcyBhdCB0aGUgc2FpZCBtb2RlbCBhbmRcbiAgICAgICAgLy8gZG9lcyBub3QgZ28gdXAgdGhlIGRlbGVnYXRpb24gY2hhaW5cbiAgICAgICAgbGV0IGNvbW1hbmRNZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdwcm9wZXJ0eUNoYW5nZWQnLFxuICAgICAgICAgICAgYXJnczogW25hbWUsIHZhbHVlXSxcbiAgICAgICAgICAgIHNob3VsZE5vdERlbGVnYXRlOnRydWUsIC8vIGRvIG5vdCBzZW5kIHRoaXMgdXAgdGhlIGRlbGVnYXRpb24gY2hhaW5cbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKGNvbW1hbmRNZXNzYWdlLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgLy8gRmluZCB0aGUgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5hbWVkXG4gICAgICAgIC8vIHByb3BlcnR5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgZG8gbm90aGluZ1xuICAgICAgICBsZXQgaGFuZGxlciA9IHRoaXMucHJvcENoYW5nZUhhbmRsZXJzW25hbWVdO1xuICAgICAgICBpZighaGFuZGxlcil7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gaGFuZGxlcih2YWx1ZSwgcGFydElkKTtcbiAgICB9XG5cblxuICAgIG9uUHJvcENoYW5nZShuYW1lLCBmdW5jKXtcbiAgICAgICAgdGhpcy5wcm9wQ2hhbmdlSGFuZGxlcnNbbmFtZV0gPSBmdW5jO1xuICAgIH1cblxuICAgIHByaW1IYW5kbGVWaWV3Q2hhbmdlKG5hbWUsIC4uLmFyZ3Mpe1xuICAgICAgICAvLyBGaW5kIHRoZSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbmFtZWRcbiAgICAgICAgLy8gcHJvcGVydHkuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBkbyBub3RoaW5nXG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy52aWV3Q2hhbmdlSGFuZGxlcnNbbmFtZV07XG4gICAgICAgIGlmKCFoYW5kbGVyKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIG9uVmlld0NoYW5nZShuYW1lLCBmdW5jKXtcbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlSGFuZGxlcnNbbmFtZV0gPSBmdW5jO1xuICAgIH1cblxuICAgIHNjcmlwdENoYW5nZWQodmFsdWUsIHBhcnRJZCl7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGFyZSBvbmx5IHNlbmRpbmcgdGhlIGNvbXBpbGVcbiAgICAgICAgLy8gbWVzc2FnZSB3aGVuIGRlYWxpbmcgd2l0aCBhICdjb3JlJyBzdC1wYXJ0IHZpZXdzIChub3RcbiAgICAgICAgLy8gd2l0aCBuYXZpZ2F0b3Igb3IgcmVsYXRlZCB2aWV3cylcbiAgICAgICAgaWYodGhpcy50YWdOYW1lLnNwbGl0KFwiLVwiKVswXSAhPSBcIlNUXCIgfHwgdGhpcy5zbG90ID09IFwid3JhcHBlZC12aWV3XCIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbXBpbGUnLFxuICAgICAgICAgICAgY29kZVN0cmluZzogdmFsdWUsXG4gICAgICAgICAgICB0YXJnZXRJZDogcGFydElkXG4gICAgICAgIH0sIHdpbmRvdy5TeXN0ZW0pO1xuICAgIH1cblxuICAgIHN1YnBhcnRPcmRlckNoYW5nZWQoaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpe1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciB0aGUgd3JhcHBlZCB2aWV3c1xuICAgICAgICAvLyBDYXJkUm93IGFuZCBTdGFja1JvdyB3aWxsIGhhbmRsZSB0aGUgdXBkYXRlc1xuICAgICAgICBpZih0aGlzLm5hbWUgPT0gXCJXcmFwcGVkVmlld1wiKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VicGFydE5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgaWYobmV3SW5kZXggPT0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdWJwYXJ0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHdoZXRoZXIgdGhlIGluZGV4IG9mIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGJlZm9yZSBvciBhZnRlciB0aGUgbmV3SW5kZXhcbiAgICAgICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IG5ld0luZGV4KXtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gdGhpcy5jaGlsZE5vZGVzW25ld0luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHN1YnBhcnROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5ld1N1YnBhcnRWaWV3KG5ld1ZpZXcpe1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld1ZpZXcpO1xuICAgIH1cblxuICAgIGxheW91dENoYW5nZWQodmFsdWUsIHBhcnRJZCl7XG4gICAgICAgIGlmKHZhbHVlID09ICdsaXN0Jyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3QtbGF5b3V0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3QtbGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0RGlyZWN0aW9uQ2hhbmdlZCh2YWx1ZSwgcGFydElkKXtcbiAgICAgICAgLy8gUm93IGlzIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gZm9yIGEgbGlzdCBsYXlvdXQsIHNvIG9ubHkgb25lIGV4dHJhXG4gICAgICAgIC8vIENTUyBjbGFzcyBuZWVkcyB0byBiZSB0b2dnbGVkXG4gICAgICAgIGlmKHZhbHVlID09ICdyb3cnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnbGlzdC1jb2x1bW4nKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlID09ICdjb2x1bW4nKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdC1jb2x1bW4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxpc3RXcmFwcGluZ0NoYW5nZWQodmFsdWUsIHBhcnRJZCl7XG4gICAgICAgIGlmKHZhbHVlID09IHRydWUpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd3cmFwLWxpc3QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnd3JhcC1saXN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoUmVzaXppbmdDaGFuZ2VkKHZhbHVlKXtcbiAgICAgICAgaWYodmFsdWUgPT0gJ3NwYWNlLWZpbGwnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaC1zcGFjZS1maWxsJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ2gtcmlnaWQnLFxuICAgICAgICAgICAgICAgICdoLXNocmluay13cmFwJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlID09ICdzaHJpbmstd3JhcCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoLXNocmluay13cmFwJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ2gtcmlnaWQnLFxuICAgICAgICAgICAgICAgICdoLXNwYWNlLWZpbGwnXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT0gJ3JpZ2lkJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2gtcmlnaWQnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICAgICAgICAnaC1zcGFjZS1maWxsJyxcbiAgICAgICAgICAgICAgICAnaC1zaHJpbmstd3JhcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2UmVzaXppbmdDaGFuZ2VkKHZhbHVlKXtcbiAgICAgICAgaWYodmFsdWUgPT0gJ3NwYWNlLWZpbGwnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgndi1zcGFjZS1maWxsJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ3YtcmlnaWQnLFxuICAgICAgICAgICAgICAgICd2LXNocmluay13cmFwJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlID09ICdzaHJpbmstd3JhcCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd2LXNocmluay13cmFwJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ3YtcmlnaWQnLFxuICAgICAgICAgICAgICAgICd2LXNwYWNlLWZpbGwnXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT0gJ3JpZ2lkJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3YtcmlnaWQnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICAgICAgICAndi1zcGFjZS1maWxsJyxcbiAgICAgICAgICAgICAgICAndi1zaHJpbmstd3JhcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwaW5uaW5nVG9wQ2hhbmdlZCgpe1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdwaW5uaW5nLXRvcCdcbiAgICAgICAgKTtcbiAgICAgICAgaWYodG9wKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGluLXRvcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdwaW4tdG9wJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwaW5uaW5nTGVmdENoYW5nZWQoKXtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3Bpbm5pbmctbGVmdCdcbiAgICAgICAgKTtcbiAgICAgICAgaWYobGVmdCl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Bpbi1sZWZ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Bpbi1sZWZ0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwaW5uaW5nUmlnaHRDaGFuZ2VkKCl7XG4gICAgICAgIGxldCByaWdodCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAncGlubmluZy1yaWdodCdcbiAgICAgICAgKTtcbiAgICAgICAgaWYocmlnaHQpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwaW4tcmlnaHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncGluLXJpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwaW5uaW5nQm90dG9tQ2hhbmdlZCgpe1xuICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdwaW5uaW5nLWJvdHRvbSdcbiAgICAgICAgKTtcbiAgICAgICAgaWYoYm90dG9tKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGluLWJvdHRvbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdwaW4tYm90dG9tJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0QWxpZ25tZW50Q2hhbmdlZCgpe1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2xpc3QtYWxpZ25tZW50J1xuICAgICAgICApO1xuICAgICAgICBsZXQgdmFsaWQgPSBbXG4gICAgICAgICAgICAndG9wJyxcbiAgICAgICAgICAgICdib3R0b20nLFxuICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgICAgICdjZW50ZXInXG4gICAgICAgIF07XG4gICAgICAgIGlmKHZhbGlkLmluY2x1ZGVzKHZhbHVlKSl7XG4gICAgICAgICAgICB2YWxpZC5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShgbGlzdC1hbGlnbi0ke3NpZGV9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChgbGlzdC1hbGlnbi0ke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdERpc3RyaWJ1dGlvbkNoYW5nZWQoKXtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdsaXN0LWRpc3RyaWJ1dGlvbidcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHZhbGlkID0gW1xuICAgICAgICAgICAgJ3N0YXJ0JyxcbiAgICAgICAgICAgICdlbmQnLFxuICAgICAgICAgICAgJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAgICAgJ3NwYWNlLWFyb3VuZCcsXG4gICAgICAgICAgICAnY2VudGVyJ1xuICAgICAgICBdO1xuICAgICAgICBpZih2YWxpZC5pbmNsdWRlcyh2YWx1ZSkpe1xuICAgICAgICAgICAgdmFsaWQuZm9yRWFjaChzaWRlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoYGxpc3QtZGlzdHJpYnV0aW9uLSR7c2lkZX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKGBsaXN0LWRpc3RyaWJ1dGlvbi0ke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogTGlmZWN5Y2xlIE1ldGhvZCBEZWZhdWx0cyAqL1xuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxVbnNldChyZW1vdmVkTW9kZWwpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBieSBkZWZhdWx0LlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NcbiAgICB9XG5cbiAgICAvKiBIYWxvIFJlbGF0ZWQgTWV0aG9kcyAqL1xuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBoYWxvIGluXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQncyBzaGFkb3cgcm9vdCBhbHJlYWR5XG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZighZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGxldCBuZXdIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKG5ld0hhbG8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VIYWxvKCl7XG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZihmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlQW50c0JvcmRlcigpe1xuICAgICAgICBpZih0aGlzLmNsYXNzTGlzdC5jb250YWlucygnbWFyY2hpbmctYW50cycpKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnbWFyY2hpbmctYW50cycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdtYXJjaGluZy1hbnRzJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkhhbG9EZWxldGUoKXtcbiAgICAgICAgLy8gV2hhdCB0byBkbyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGVcbiAgICAgICAgLy8gZGVsZXRlIGJ1dHRvbiBvbiBhIGhhbG8gZm9yIHRoaXMgcGFydHZpZXcuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIHRvIHNlbmQgYSBtZXNzYWdlXG4gICAgICAgIC8vIHRvIHRoZSBTeXN0ZW0gdG8gZGVsZXRlIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgIC8vIG1vZGVsIGFuZCAqYWxsKiB2aWV3cyByZWZlcmVuY2luZyB0aGF0XG4gICAgICAgIC8vIG1vZGVsLlxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnZGVsZXRlTW9kZWwnLFxuICAgICAgICAgICAgYXJnczogW3RoaXMubW9kZWwuaWRdXG4gICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIG9uSGFsb09wZW5TY3JpcHRFZGl0b3IoKXtcbiAgICAgICAgLy8gU2VuZCB0aGUgbWVzc2FnZSB0byBvcGVuIGEgc2NyaXB0IGVkaXRvclxuICAgICAgICAvLyB3aXRoIHRoaXMgdmlldydzIG1vZGVsIGFzIHRoZSB0YXJnZXRcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgYXJnczogW3RoaXMubW9kZWwuaWRdXG4gICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIG9uSGFsb09wZW5FZGl0b3IoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5lZGl0b3IucmVuZGVyKHRoaXMubW9kZWwpO1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmVkaXRvci5vcGVuKCk7XG4gICAgfVxuXG4gICAgb25IYWxvUmVzaXplKG1vdmVtZW50WCwgbW92ZW1lbnRZKXtcbiAgICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvbiB3aGF0IHRvIGRvIGR1cmluZ1xuICAgICAgICAvLyBoYWxvIGJ1dHRvbiByZXNpemUgb3BlcnRhdGlvbnMuIFN1YmNsYXNzZXNcbiAgICAgICAgLy8gY2FuIG92ZXJyaWRlIGZvciBjdXN0b20gYmVoYXZpb3IuXG4gICAgICAgIC8vIERlZmF1bHQgaXMgdG8gdXBkYXRlIHRoZSBWaWV3IGNvbXBvbmVudCdzXG4gICAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgc3R5bGUgcHJvcGVydGllcyBkaXJlY3RseS5cbiAgICAgICAgLy8gSWYgdGhlIHBhcnQgaXMgcm90YXRlZCB0aGlzIHdpbGwgdGhyb3cgb2ZmIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgICAgLy8gYnJvd3NlciBjYWxjdWFsdGlvbi4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byByb3RhdGUgdGhlIHBhcnQgdG8gMFxuICAgICAgICAvLyAoaWYgbmVjZXNzYXJ5KSBkbyB0aGUgY2FsY3VsYXRpb25zIGFuZCB0aGVuIHJvdGF0ZSBpdCBiYWNrXG4gICAgICAgIGxldCBhbmdsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiKTtcbiAgICAgICAgaWYoYW5nbGUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG5ld1dpZHRoLCBuZXdIZWlnaHQ7XG4gICAgICAgIGlmKHRoaXMucHJlc2VydmVBc3BlY3RPblJlc2l6ZSl7XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICBsZXQgaHlwID0gTWF0aC5zcXJ0KChtb3ZlbWVudFgqKjIpICsgKG1vdmVtZW50WSoqMikpO1xuICAgICAgICAgICAgaWYobW92ZW1lbnRYIDwgMCB8fCBtb3ZlbWVudFkgPCAwKXtcbiAgICAgICAgICAgICAgICBoeXAgPSBoeXAgKiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0hlaWdodCA9IHJlY3QuaGVpZ2h0ICsgaHlwO1xuICAgICAgICAgICAgbmV3V2lkdGggPSByZWN0LndpZHRoICsgaHlwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3V2lkdGggPSBtb3ZlbWVudFggKyByZWN0LndpZHRoO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gbW92ZW1lbnRZICsgcmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwid2lkdGhcIiwgbmV3V2lkdGgpO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJoZWlnaHRcIiwgbmV3SGVpZ2h0KTtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHJvdGF0ZSBhbmdsZSB0byB0aGUgb3JpZ2luYWwgKGlmIG5lY2Vzc2FyeSlcbiAgICAgICAgaWYoYW5nbGUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIsIGFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSGFsb1JvdGF0ZShtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb24gd2hhdCB0byBkbyBkdXJpbmdcbiAgICAgICAgLy8gaGFsbyBidXR0b24gcm90YXRlIG9wZXJ0YXRpb25zLiBTdWJjbGFzc2VzXG4gICAgICAgIC8vIGNhbiBvdmVycmlkZSBmb3IgY3VzdG9tIGJlaGF2aW9yLlxuICAgICAgICAvLyBEZWZhdWx0IGlzIHRvIHVwZGF0ZSB0aGUgVmlldyBjb21wb25lbnQnc1xuICAgICAgICAvLyByb3RhdGUgc3R5bGUgcHJvcGVydHkgZGlyZWN0bHkuXG4gICAgICAgIGlmKG1vdmVtZW50WCB8fCBtb3ZlbWVudFkpe1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRBbmdsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiKTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmKCFjdXJyZW50QW5nbGUpe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBbmdsZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGhldGExID0gTWF0aC5hdGFuKChyZWN0LmhlaWdodC8yKS8ocmVjdC53aWR0aC8yKSk7XG4gICAgICAgICAgICBsZXQgdGhldGEyID0gTWF0aC5hdGFuKChyZWN0LmhlaWdodC8yICsgbW92ZW1lbnRZKS8ocmVjdC53aWR0aC8yICsgbW92ZW1lbnRYKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlQW5nbGUgPSBNYXRoLmFicygodGhldGEyIC0gdGhldGExKSoxODAvTWF0aC5QSSk7XG4gICAgICAgICAgICBsZXQgbmV3QW5nbGUgPSAoY3VycmVudEFuZ2xlICsgY2hhbmdlQW5nbGUpICUgMzYwO1xuICAgICAgICAgICAgaWYobmV3QW5nbGUgPCAwKXtcbiAgICAgICAgICAgICAgICBuZXdBbmdsZSA9IDM2MCArIG5ld0FuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobmV3QW5nbGUpe1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCBuZXdBbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkhhbG9Db3B5KCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLmNvcHlQYXJ0KHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIG9uSGFsb1Bhc3RlKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLnBhc3RlQ29udGVudHNJbnRvKHRoaXMubW9kZWwpO1xuICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgIH1cblxuICAgIG9uSGFsb1RhcmdldChldmVudCl7XG4gICAgICAgIC8vIEFkZCB0YXJnZXRpbmcgcmVjZWl2ZSBsaXN0ZW5lcnMgdG8gYWxsIFBhcnRWaWV3c1xuICAgICAgICAvLyBvbiB0aGUgY3VycmVudCBjYXJkLlxuICAgICAgICBsZXQgY3VycmVudFN0YWNrVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt3aW5kb3cuU3lzdGVtLndvcmxkLmN1cnJlbnRTdGFjay5pZH1cIl1gKTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt3aW5kb3cuU3lzdGVtLndvcmxkLmN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZC5pZH1cIl1gKTtcbiAgICAgICAgbGV0IHRhcmdldENhcmRQYXJ0cyA9IEFycmF5LmZyb20oY3VycmVudENhcmRWaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ1twYXJ0LWlkXScpKTtcbiAgICAgICAgbGV0IHRhcmdldFN0YWNrUGFydHMgPSBBcnJheS5mcm9tKGN1cnJlbnRTdGFja1ZpZXcucXVlcnlTZWxlY3RvckFsbCgnW3BhcnQtaWRdOm5vdChzdC1jYXJkKTpub3Qoc3Qtc3RhY2spJykpO1xuICAgICAgICBsZXQgYWxsVGFyZ2V0cyA9IHRhcmdldENhcmRQYXJ0cy5jb25jYXQodGFyZ2V0U3RhY2tQYXJ0cyk7XG4gICAgICAgIGFsbFRhcmdldHMuZm9yRWFjaChwYXJ0VmlldyA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVUYXJnZXRLZXkpO1xuICAgICAgICAgICAgcGFydFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU92ZXIpO1xuICAgICAgICAgICAgcGFydFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3V0KTtcbiAgICAgICAgICAgIHBhcnRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZUNsaWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgndGFyZ2V0aW5nLW1vZGUnKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgb25IYWxvVGFyZ2V0QnV0dG9uTW91c2VFbnRlcigpe1xuICAgICAgICAvLyBsaWdodCB1cCB0aGUgY3VycmVudCB0YXJnZXRcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VGFyZ2V0Vmlld3MoKS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LmhpZ2hsaWdodChcInJnYig1NCwgMTcyLCAxMDApXCIpOyAvL2dyZWVuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlTGVhdmUoKXtcbiAgICAgICAgLy8gbGlnaHQgdXAgdGhlIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFRhcmdldFZpZXdzKCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoaWdobGlnaHQoY29sb3Ipe1xuICAgICAgICBpZih0aGlzLm5hbWUgIT0gXCJTdGFja1ZpZXdcIiAmJiB0aGlzLm5hbWUgIT0gXCJXb3JsZFZpZXdcIil7XG4gICAgICAgICAgICB0aGlzLl90ZW1wQmFja2dyb3VuZENvbG9yID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC1jb2xvclwiKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtY29sb3JcIiwgY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5fdGVtcEJhY2tncm91bmRUcmFuc3BhcmVuY3kgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeVwiKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtdHJhbnNwYXJlbmN5XCIsIDEpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB1bmhpZ2hsaWdodCgpe1xuICAgICAgICBpZih0aGlzLm5hbWUgIT0gXCJTdGFja1ZpZXdcIiAmJiB0aGlzLm5hbWUgIT0gXCJXb3JsZFZpZXdcIil7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHRoaXMuX3RlbXBCYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIiwgdGhpcy5fdGVtcEJhY2tncm91bmRUcmFuc3BhcmVuY3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5kSGFsb1RhcmdldCgpe1xuICAgICAgICAvLyBSZW1vdmUgYWxsIHRhcmdldGluZyByZWxhdGVkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAvLyB0aGF0IHdlcmUgYWRkZWQgZHVyaW5nIHRoZSBvbkhhbG9UYXJnZXRcbiAgICAgICAgLy8gaGFuZGxlclxuICAgICAgICBsZXQgY3VycmVudFN0YWNrVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt3aW5kb3cuU3lzdGVtLndvcmxkLmN1cnJlbnRTdGFjay5pZH1cIl1gKTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt3aW5kb3cuU3lzdGVtLndvcmxkLmN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZC5pZH1cIl1gKTtcbiAgICAgICAgbGV0IHRhcmdldENhcmRQYXJ0cyA9IEFycmF5LmZyb20oY3VycmVudENhcmRWaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ1twYXJ0LWlkXScpKTtcbiAgICAgICAgbGV0IHRhcmdldFN0YWNrUGFydHMgPSBBcnJheS5mcm9tKGN1cnJlbnRTdGFja1ZpZXcucXVlcnlTZWxlY3RvckFsbCgnW3BhcnQtaWRdOm5vdChzdC1jYXJkKTpub3Qoc3Qtc3RhY2spJykpO1xuICAgICAgICBsZXQgYWxsVGFyZ2V0cyA9IHRhcmdldENhcmRQYXJ0cy5jb25jYXQodGFyZ2V0U3RhY2tQYXJ0cyk7XG4gICAgICAgIGFsbFRhcmdldHMuZm9yRWFjaChwYXJ0VmlldyA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVUYXJnZXRLZXkpO1xuICAgICAgICAgICAgcGFydFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlVGFyZ2V0S2V5KTtcbiAgICAgICAgICAgIHBhcnRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdmVyKTtcbiAgICAgICAgICAgIHBhcnRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU91dCk7XG4gICAgICAgICAgICBwYXJ0Vmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VDbGljayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3RhcmdldGluZy1tb2RlJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlVGFyZ2V0S2V5KGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQua2V5ID09ICdFc2NhcGUnKXtcbiAgICAgICAgICAgIHRoaXMuZW5kSGFsb1RhcmdldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVGFyZ2V0TW91c2VPdmVyKGV2ZW50KXtcbiAgICAgICAgaWYoIWV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhcmdldGluZycpKXtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCd0YXJnZXRpbmcnKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5oaWdobGlnaHQoXCJyZ2IoMjM0LCA1NSwgNTUpXCIpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQudGFyZ2V0Lm9uQ2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVGFyZ2V0TW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhcmdldGluZycpKXtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCd0YXJnZXRpbmcnKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC51bmhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQudGFyZ2V0Lm9uQ2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVGFyZ2V0TW91c2VDbGljayhldmVudCl7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwICYmIGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgIHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgndGFyZ2V0aW5nJyk7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAndGFyZ2V0JyxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5tb2RlbC5pZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVuZEhhbG9UYXJnZXQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnRhcmdldC51bmhpZ2hsaWdodCgpO1xuICAgICAgICBldmVudC50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudC50YXJnZXQub25DbGljayk7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFRhcmdldFZpZXdzKCl7XG4gICAgICAgIC8vIGNsZWFuIHVwIHRoZSBjdXJyZW50IHRhcmdldFxuICAgICAgICBsZXQgY3VycmVudFRhcmdldCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInRhcmdldFwiKTtcbiAgICAgICAgaWYoY3VycmVudFRhcmdldCl7XG4gICAgICAgICAgICBsZXQgc2VtYW50aWNzID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLmNyZWF0ZVNlbWFudGljcygpO1xuICAgICAgICAgICAgc2VtYW50aWNzLmFkZE9wZXJhdGlvbihcbiAgICAgICAgICAgICAgICAnaW50ZXJwcmV0JyxcbiAgICAgICAgICAgICAgICBpbnRlcnByZXRlclNlbWFudGljcyh0aGlzLm1vZGVsLCB3aW5kb3cuU3lzdGVtKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBtID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLm1hdGNoKGN1cnJlbnRUYXJnZXQsIFwiT2JqZWN0U3BlY2lmaWVyXCIpO1xuICAgICAgICAgICAgbGV0IHRhcmdldElkID0gc2VtYW50aWNzKG0pLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0YXJnZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIG9uQ29udGV4dE1lbnVDbGljayhldmVudCl7XG4gICAgICAgIGlmKHRoaXMud2FudHNDb250ZXh0TWVudSl7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRleHRNZW51SXNPcGVuKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnVBdChcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2xpZW50WVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQXV4Q2xpY2soZXZlbnQpe1xuICAgICAgICAvLyBTaG91bGQgb25seSBvcGVuIGhhbG8gd2hlbiBtaWRkbGVcbiAgICAgICAgLy8gbW91c2UgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDEpe1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZih0aGlzLmNvbnRleHRNZW51SXNPcGVuKXtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwICYmIGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZih0aGlzLndhbnRzSGFsbyl7XG4gICAgICAgICAgICBpZih0aGlzLmhhc09wZW5IYWxvKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFueSBvdGhlciBvcGVuIEhhbG9zXG4gICAgICAgICAgICAgICAgLy8gYW5kIGF1dG9tYXRpY2FsbHkgY2xvc2UgdGhlbVxuICAgICAgICAgICAgICAgIGxldCBleFNlbGVjdG9yID0gYC5lZGl0aW5nOm5vdChbcGFydC1pZD1cIiR7dGhpcy5tb2RlbC5pZH1cIl0pYDtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZXhTZWxlY3RvcikpLmZvckVhY2gob3BlbkhhbG9FbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5IYWxvRWwuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBvcGVuIG9uIHRoaXMgdmlld1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91c2VEb3duKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDAgJiYgIWV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmUnLFxuICAgICAgICAgICAgYXJnczogW2V2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZXVxuICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlVXAoZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvcGVuQ29udGV4dE1lbnVBdCh4LCB5KXtcbiAgICAgICAgbGV0IG1lbnVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWNvbnRleHQtbWVudScpO1xuICAgICAgICBtZW51RWwucmVuZGVyKHRoaXMubW9kZWwpO1xuICAgICAgICBtZW51RWwuc3R5bGUubGVmdCA9IGAke3h9cHhgO1xuICAgICAgICBtZW51RWwuc3R5bGUudG9wID0gYCR7eX1weGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG1lbnVFbCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIG1lbnUgaXMgY29tcGxldGVseVxuICAgICAgICAvLyB3aXRoaW4gdGhlIGN1cnJlbnQgdmlldy4gSWYgbm90IChtZWFuaW5nXG4gICAgICAgIC8vIGl0IGlzIGNsaXBwZWQpLCB0aGVuIGFkanVzdCBzbyBpdCBpc1xuICAgICAgICAvLyBjb21wbGV0ZWx5IGluIHRoZSB2aWV3LlxuICAgICAgICBtZW51RWwuYWRqdXN0VG9DbGllbnRWaWV3KCk7XG4gICAgfVxuXG4gICAgY2xvc2VDb250ZXh0TWVudSgpe1xuICAgICAgICBsZXQgZm91bmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1jb250ZXh0LW1lbnUnKTtcbiAgICAgICAgaWYoZm91bmQpe1xuICAgICAgICAgICAgZm91bmQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDb250ZXh0TWVudUl0ZW1zKGNvbnRleHRNZW51KXtcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgdG9cbiAgICAgICAgLy8gZG8gbm90aGlucy5cbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gcGFzc2VkLWluIGNvbnRleHRNZW51IG9iamVjdCB0byBjb25zdHJ1Y3RcbiAgICAgICAgLy8gbGlzdCBpdGVtcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGVpciBuZWVkc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0IHdhbnRzSGFsb01vdmUoKXtcbiAgICAgICAgaWYoIXRoaXMucGFyZW50RWxlbWVudCB8fCAhdGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRFbGVtZW50Lm1vZGVsO1xuICAgICAgICBpZighcGFyZW50TW9kZWwpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGFzTGF5b3V0ID0gcGFyZW50TW9kZWwucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBwYXJlbnRNb2RlbCxcbiAgICAgICAgICAgICdsYXlvdXQnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYoIWhhc0xheW91dCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJlbnRMYXlvdXQgPSBwYXJlbnRNb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgcGFyZW50TW9kZWwsXG4gICAgICAgICAgICAnbGF5b3V0J1xuICAgICAgICApO1xuICAgICAgICBpZihwYXJlbnRMYXlvdXQgPT09ICdzdHJpY3QnIHwgIXBhcmVudExheW91dCB8fCBwYXJlbnRMYXlvdXQgPT0gXCJcIil7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgY29udGV4dE1lbnVJc09wZW4oKXtcbiAgICAgICAgbGV0IGZvdW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtY29udGV4dC1tZW51Jyk7XG4gICAgICAgIGlmKGZvdW5kKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBFZGl0b3IgcmVsYXRlZCBtZXRob2RzICovXG4gICAgb3BlbkVkaXRvcigpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzXG4gICAgfVxuXG4gICAgY2xvc2VFZGl0b3IoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgUGFydFZpZXcsXG4gICAgUGFydFZpZXcgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgbGlua0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbGlua1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAgMTRhMy41IDMuNSAwIDAgMCA1IDBsNCAtNGEzLjUgMy41IDAgMCAwIC01IC01bC0uNSAuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTBhMy41IDMuNSAwIDAgMCAtNSAwbC00IDRhMy41IDMuNSAwIDAgMCA1IDVsLjUgLS41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG46aG9zdCB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcGFkZGluZzogMXB4O1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xufVxuXG4ud3JhcHBlcntcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxufVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJuYW1lXCI+PC9zcGFuPlxuICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1idWlsZGluZy1icmlkZ2UtMlwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgICA8cGF0aCBkPVwiTTYgN2gxMmEyIDIgMCAwIDEgMiAydjlhMSAxIDAgMCAxIC0xIDFoLTJhMSAxIDAgMCAxIC0xIC0xdi0yYTQgNCAwIDAgMCAtOCAwdjJhMSAxIDAgMCAxIC0xIDFoLTJhMSAxIDAgMCAxIC0xIC0xdi05YTIgMiAwIDAgMSAyIC0yXCI+PC9wYXRoPlxuICAgIDwvc3ZnPlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBSZXNvdXJjZVZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlc291cmNlTGluayA9IHRoaXMudXBkYXRlUmVzb3VyY2VMaW5rLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlID0gdGhpcy5pbmRpY2F0ZVJlYWR5U3RhdGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICAvLyBpZiB0aGUgcmVzb3VyY2VOYW1lIHByb3BlcnR5IGlzIHNldCB0aGVuIG1ha2Ugc3VyZSBpdCBpcyBsb2FkZWRcbiAgICAgICAgLy8gVE9ETzogaSBkb24ndCBsaWtlIHRoaXMgdmlldyBhc2tpbmcgdGhlIG1vZGVsIHRvIGxvYWQhXG4gICAgICAgIGxldCByZXNvdXJjZU5hbWUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyZXNvdXJjZU5hbWVcIik7XG4gICAgICAgIGlmKHJlc291cmNlTmFtZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLmxvYWRSZXNvdXJjZShbdGhpc10sIHJlc291cmNlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInNyY1wiKTtcbiAgICAgICAgaWYoc3JjKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0U291cmNlVG8oW3RoaXNdLCBzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lU3BhbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5uYW1lXCIpO1xuICAgICAgICBuYW1lU3Bhbi5pbm5lclRleHQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJuYW1lXCIpO1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJyZWFkeVN0YXRlXCIsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlKHN0YXRlKTtcbiAgICAgICAgLy8gcHJvcCBjaGFuZ2VzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwibmFtZVwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIG5hbWVTcGFuLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJyZWFkeVN0YXRlXCIsIHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJzcmNcIiwgKHVybCkgPT4ge1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDApe1xuICAgICAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyB0aGUgb24gY2xpY2sgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZighdGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgY2xpY2sgY29tbWFuZCBtZXNzYWdlIHRvIHNlbGZcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluZGljYXRlUmVhZHlTdGF0ZSh2YWx1ZSl7XG4gICAgICAgIGxldCBib3JkZXJDb2xvciA9IFwicmVkXCI7XG4gICAgICAgIGlmKHZhbHVlID09IFwiZmV0Y2hpbmdcIil7XG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IFwieWVsbG93XCI7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSBcInJlYWR5XCIpe1xuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBcImdyZWVuXCI7XG4gICAgICAgIH07XG4gICAgICAgIFtcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiXS5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgYGJvcmRlci0ke3NpZGV9LWNvbG9yYCwgYm9yZGVyQ29sb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b24oKXtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pZCA9ICdoYWxvLXJlc291cmNlLWxpbmsnO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlubmVySFRNTCA9IGxpbmtJY29uO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luVG9wID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdyaWdodC1jb2x1bW4nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnRWRpdCBsaW5rIGZvciByZXNvdXJjZScpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnVwZGF0ZVJlc291cmNlTGluayk7XG4gICAgfVxuXG4gICAgdXBkYXRlUmVzb3VyY2VMaW5rKGV2ZW50KXtcbiAgICAgICAgLy8gVGVsbHMgdGhlIG1vZGVsIHRvIHVwZGF0ZSBpdHNcbiAgICAgICAgLy8gc3JjIGxpbmsgZm9yIHRoZSByZXNvdXJjZVxuICAgICAgICBsZXQgY3VycmVudFNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnc3JjJ1xuICAgICAgICApO1xuICAgICAgICBsZXQgcmVzdWx0ID0gd2luZG93LnByb21wdChcIkVkaXQgVVJMIGZvciByZXNvdXJjZTpcIiwgY3VycmVudFNyYyk7XG4gICAgICAgIGlmKHJlc3VsdCAmJiByZXN1bHQgIT09ICcnICYmIHJlc3VsdCAhPT0gY3VycmVudFNyYyl7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2xvYWRSZXNvdXJjZScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsgcmVzdWx0IF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcblxuZXhwb3J0IHtcbiAgICBSZXNvdXJjZVZpZXcsXG4gICAgUmVzb3VyY2VWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFN0YWNrVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIFdlYmNvbXBvbmVudCAoY3VzdG9tIGVsZW1lbnQpIHJlcHJlc2VudGluZ1xuICogdGhlIHZpZXcgb2YgYSBTdGFjay5cbiAqIEkgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgY3VycmVudCB2aWV3cG9ydFxuICogd2hlbiBJIGFtIGJlaW5nIGRpc3BsYXllZC5cbiAqIE15IGNoaWxkIGVsZW1lbnRzIGFyZSBCYWNrZ3JvdW5kVmlldyBhbmQgQ2FyZFZpZXdcbiAqL1xuXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi4vcGFydHMvU3RhY2suanMnO1xuXG4vLyBieSBkZWZhdWx0LCBzdGFja3MgYXJlIGhpZGRlbiB1bmxlc3MgdGhleSdyZVxuLy8gdGhlIGN1cnJlbnQgc3RhY2ssIG9yIGVsc2UgdGhleSBoYXZlIHRoZSBjbGFzc1xuLy8gd2luZG93LXN0YWNrIChzdWdnZXN0aW5nIHRoZXJlJ3Mgd2luZG93IHBhcnRcbi8vIHdobyB3aXNoZXMgdG8gZGlzcGxheSBpdClcbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYDxzbG90Pjwvc2xvdD5gO1xuXG5jbGFzcyBTdGFja1ZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0aW5nIGFuZCBzaGFkb3cgZG9tXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEhhbG8gc2V0dGluZ3MuIENhcmRzIGRvbid0IHdhbnRcbiAgICAgICAgLy9hIGhhbG8gdG8gb3BlblxuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBjdXJyZW50LW5lc3MgcHJvcCBjaGFuZ2VcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2N1cnJlbnQnLCB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UpO1xuXG4gICAgICAgIC8vIEJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UgPSB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIERvIGFuIGluaXRpYWwgc2V0dGluZyBvZiB0aGVcbiAgICAgICAgLy8gY3VycmVudCBjYXJkXG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSgpO1xuICAgIH1cblxuICAgIGhhbmRsZUN1cnJlbnRDaGFuZ2UoKXtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IHByb3AgaXMgdGhlIGNhcmQgSURcbiAgICAgICAgLy8gb2YgdGhlIGNoaWxkIENhcmQgdGhhdCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgb25lLiBXZSByZW1vdmUgdGhlIGN1cnJlbnQtY2FyZCBjbGFzcyBmcm9tXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBjdXJyZW50IGNhcmQgYW5kIGFkZCBpdCB0byB0aGUgbmV3IG9uZS5cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuY3VycmVudC1jYXJkJyk7XG4gICAgICAgIGxldCBuZXh0Q3VycmVudElkID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdjdXJyZW50J1xuICAgICAgICApO1xuICAgICAgICBsZXQgc2hvdWxkTm90aWZ5ID0gZmFsc2U7XG4gICAgICAgIGxldCBzZWxlY3RvciA9IGA6c2NvcGUgPiBzdC1jYXJkW3BhcnQtaWQ9XCIke25leHRDdXJyZW50SWR9XCJdYDtcbiAgICAgICAgaWYodGhpcy5pc0xlbnNlZCl7XG4gICAgICAgICAgICBzZWxlY3RvciA9IGA6c2NvcGUgPiBzdC1jYXJkW2xlbnMtcGFydC1pZD1cIiR7bmV4dEN1cnJlbnRJZH1cIl1gO1xuICAgICAgICAgICAgc2hvdWxkTm90aWZ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dEN1cnJlbnRDYXJkID0gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gY3VycmVudENhcmQgYW5kIG5vIG5leHQgY3VycmVudENhcmQgd2Ugc2V0IGl0IHRvIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyBjYXJkIGNoaWxkICh0aGlzIGNhbiBoYXBwZW4gd2hlbiBuZXcgaWRzIGFyZSBjcmVhdGVkIG9uIGRlc2VyaWFsaXphdGlvbiBhbmQgc29cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgcHJvcGVydHkgc3RvcmVkIGlkIGlzIG5vIGxvbmdlciByZWxldmFudClcbiAgICAgICAgaWYoIW5leHRDdXJyZW50Q2FyZCAmJiAhY3VycmVudENhcmQpe1xuICAgICAgICAgICAgbmV4dEN1cnJlbnRDYXJkID0gdGhpcy5xdWVyeVNlbGVjdG9yKGA6c2NvcGUgPiBzdC1jYXJkYCk7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gY2FyZHMgYXQgYWxsLCB0aGlzIG11c3QgYmUgYSBicmFuZCBuZXcgc3RhY2tcbiAgICAgICAgICAgIGlmKCFuZXh0Q3VycmVudENhcmQpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgICAgICAgIG5leHRDdXJyZW50Q2FyZC5pZCxcbiAgICAgICAgICAgICAgICBzaG91bGROb3RpZnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYobmV4dEN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIG5leHRDdXJyZW50Q2FyZC5jbGFzc0xpc3QuYWRkKCdjdXJyZW50LWNhcmQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50Q2FyZCAmJiBjdXJyZW50Q2FyZCAhPSBuZXh0Q3VycmVudENhcmQpe1xuICAgICAgICAgICAgY3VycmVudENhcmQuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudC1jYXJkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSBzdWJjbGFzcyBtZXRob2RzXG4gICAgbmV3U3VicGFydFZpZXcobmV3Vmlldyl7XG4gICAgICAgIGlmKHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggJiYgbmV3Vmlldy5uYW1lID09IFwiQ2FyZFZpZXdcIil7XG4gICAgICAgICAgICBsZXQgbGFzdENhcmROb2RlO1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoY2hpbGQubmFtZSA9PSBcIkNhcmRWaWV3XCIpe1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2FyZE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKGxhc3RDYXJkTm9kZSl7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IGNhcmRcbiAgICAgICAgICAgICAgICBsYXN0Q2FyZE5vZGUuYWZ0ZXIobmV3Vmlldyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXJlIGFyZSBubyBjYXJkc1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBiZWZvcmUgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLmluc2VydEJlZm9yZShuZXdWaWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Vmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmV4cG9ydCB7XG4gICAgU3RhY2tWaWV3LFxuICAgIFN0YWNrVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBXaW5kb3dWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIHRoZSB2aWV3IG9mIGEgV2luZG93IFBhcnQuXG4gKiBXaW5kb3dzIGFyZSB3cmFwcGVycyBmb3IgU3RhY2tzL1N0YWNrVmlld3MgdGhhdFxuICogYXBwZWFyIGFzIHRoZSBzdWJwYXJ0cyBvZiBvdGhlciBTdGFja3Mgb3IgQ2FyZHMuXG4gKiBUaGV5IGFyZSBleGFtcGxlcyBvZiBob3cgd2UgY2FuIHVzZSBzdGFjayBhbmQgY2FyZFxuICogY29tcG9zaXRpb24gdG8gY3JlYXRlIG1vcmUgY29tcGxleCBVSXMuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuICoge1xuICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuIH1cblxuIC5zdC13aW5kb3ctYmFyIHtcbiAgICAgZGlzcGxheTogZmxleDtcbiAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgd2lkdGg6IDEwMCU7XG4gICAgIG1pbi1oZWlnaHQ6IDI1cHg7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyMTgsIDIxOCwgMjE4KTtcbiAgICAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcbiAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiB9XG4gLnN0LXdpbmRvdy1idXR0b24ge1xuICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgd2lkdGg6IDEycHg7XG4gICAgIGhlaWdodDogMTJweDtcbiAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDE1MCwgMTUwKTtcbiAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gfVxuIC5jbG9zZS1idXR0b24ge1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgNTAsIDUwLCAwLjQpO1xuIH1cbiAuc2hhZGUtYnV0dG9uIHtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMC4gMC40KTtcbiB9XG4gLmV4cGFuZC1idXR0b24ge1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE1MCwgMjU1LCAwLCAwLjgpO1xuIH1cbiAuc3Qtd2luZG93LXBhbmUge1xuICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICBtaW4taGVpZ2h0OiA1MHB4O1xuICAgICBmbGV4OiAxO1xuIH1cbiAuc3Qtd2luZG93LXBhbmUuc2hhZGVkIHtcbiAgICAgZGlzcGxheTogbm9uZTtcbiB9XG4gLnN0LXdpbmRvdy1ncmlwcGVyIHtcbiAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgdG9wOiBjYWxjKDEwMCUgLSAxNXB4KTtcbiAgICAgd2lkdGg6IDMwcHg7XG4gICAgIGhlaWdodDogMzBweDtcbiB9XG4gLnN0LXdpbmRvdy10aXRsZSB7XG4gICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgbWF4LXdpZHRoOiA3MCU7XG4gfVxuIC5yaWdodC1ncmlwcGVyIHtcbiAgICAgbGVmdDogY2FsYygxMDAlIC0gMTVweCk7XG4gfVxuIC5yaWdodC1ncmlwcGVyOmhvdmVyIHtcbiAgICAgY3Vyc29yOiBud3NlLXJlc2l6ZTtcbiB9XG4gLmxlZnQtZ3JpcHBlciB7XG4gICAgIHJpZ2h0OiBjYWxjKDEwMCUgLSAxNXB4KTtcbiB9XG4gLmxlZnQtZ3JpcHBlcjpob3ZlciB7XG4gICAgIGN1cnNvcjogbmVzdy1yZXNpemU7XG4gfVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYmFyXCI+XG4gICAgPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1idXR0b24gY2xvc2UtYnV0dG9uXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1idXR0b24gc2hhZGUtYnV0dG9uXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1idXR0b24gZXhwYW5kLWJ1dHRvblwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctdGl0bGVcIj5cbiAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgIDwvZGl2PlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwic3Qtd2luZG93LXBhbmVcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbjxkaXYgY2xhc3M9XCJzdC13aW5kb3ctZ3JpcHBlciByaWdodC1ncmlwcGVyXCIgZGF0YS1ncmlwLWVuZD1cInJpZ2h0XCI+PC9kaXY+XG5gO1xuXG5jbGFzcyBXaW5kb3dWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdmFyIHRlbXBsYXRlQ29udGVudCA9IHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlQ29udGVudCk7XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd25JbkJhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU2hhZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV4cGFuZENhY2hlID0ge307XG5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgYXJlIGdyaXBwaW5nIHRoZVxuICAgICAgICAvLyBib3R0b20gcmlnaHQgY29ybmVyIGZvciBhIHJlc2l6ZVxuICAgICAgICB0aGlzLmlzR3JpcHBpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0dXBDbGlja0FuZERyYWcgPSB0aGlzLnNldHVwQ2xpY2tBbmREcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBCYXJCdXR0b25zID0gdGhpcy5zZXR1cEJhckJ1dHRvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cEV4cGFuZGVyQXJlYXMgPSB0aGlzLnNldHVwRXhwYW5kZXJBcmVhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlSW5CYXIgPSB0aGlzLm9uTW91c2VNb3ZlSW5CYXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bkluQmFyID0gdGhpcy5vbk1vdXNlRG93bkluQmFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwQWZ0ZXJEcmFnID0gdGhpcy5vbk1vdXNlVXBBZnRlckRyYWcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TaGFkZSA9IHRoaXMub25TaGFkZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRXhwYW5kID0gdGhpcy5vbkV4cGFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uR3JpcERvd24gPSB0aGlzLm9uR3JpcERvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkdyaXBVcCA9IHRoaXMub25HcmlwVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkdyaXBNb3ZlID0gdGhpcy5vbkdyaXBNb3ZlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0dXAgcHJvcCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3RpdGxlJywgdGhpcy5zZXRUaXRsZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgdGhpcy5zZXR1cENsaWNrQW5kRHJhZygpO1xuICAgICAgICB0aGlzLnNldHVwQmFyQnV0dG9ucygpO1xuICAgICAgICB0aGlzLnNldHVwRXhwYW5kZXJBcmVhcygpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5zZXRUaXRsZShcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd0aXRsZSdcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXR1cENsaWNrQW5kRHJhZygpe1xuICAgICAgICBsZXQgYmFyID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3Qtd2luZG93LWJhcicpO1xuICAgICAgICBiYXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkluQmFyKTtcbiAgICB9XG5cbiAgICBzZXR1cEJhckJ1dHRvbnMoKXtcbiAgICAgICAgbGV0IGNsb3NlQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuY2xvc2UtYnV0dG9uJyk7XG4gICAgICAgIGxldCBzaGFkZUJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnNoYWRlLWJ1dHRvbicpO1xuICAgICAgICBsZXQgZXhwYW5kQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZXhwYW5kLWJ1dHRvbicpO1xuXG4gICAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsb3NlKTtcbiAgICAgICAgc2hhZGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uU2hhZGUpO1xuICAgICAgICBleHBhbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRXhwYW5kKTtcbiAgICB9XG5cbiAgICBzZXR1cEV4cGFuZGVyQXJlYXMoKXtcbiAgICAgICAgbGV0IGxvd2VyUmlnaHQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5yaWdodC1ncmlwcGVyJyk7XG4gICAgICAgIGxvd2VyUmlnaHQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbkdyaXBEb3duKTtcbiAgICB9XG5cbiAgICBvbkV4cGFuZChldmVudCl7XG4gICAgICAgIGlmKHRoaXMuaXNFeHBhbmRlZCl7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gdGhpcy5leHBhbmRDYWNoZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5leHBhbmRDYWNoZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRvcCA9IHRoaXMuZXhwYW5kQ2FjaGUudG9wO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gdGhpcy5leHBhbmRDYWNoZS5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZENhY2hlID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnN0eWxlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLnN0eWxlLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnN0eWxlLmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTZXQgbmV3IHZhbHVlcyBiYXNlZCBvbiB3aW5kb3cgc2l6ZVxuICAgICAgICAgICAgdGhpcy5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSBcIjEwMHZ3XCI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmhlaWdodCA9IFwiMTAwdmhcIjtcbiAgICAgICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNoYWRlKGV2ZW50KXtcbiAgICAgICAgbGV0IHBhbmUgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zdC13aW5kb3ctcGFuZScpO1xuICAgICAgICBpZih0aGlzLmlzU2hhZGVkKXtcbiAgICAgICAgICAgIHBhbmUuY2xhc3NMaXN0LnJlbW92ZSgnc2hhZGVkJyk7XG4gICAgICAgICAgICB0aGlzLmlzU2hhZGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ3NoYWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5pc1NoYWRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsb3NlKGV2ZW50KXtcbiAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnd2luZG93Q2xvc2UnLFxuICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZShtc2csIHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIG9uTW91c2VEb3duSW5CYXIoZXZlbnQpe1xuICAgICAgICB0aGlzLm1vdXNlRG93bkluQmFyID0gdHJ1ZTtcbiAgICAgICAgbGV0IGJhciA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUluQmFyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwQWZ0ZXJEcmFnKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlVXBBZnRlckRyYWcoZXZlbnQpe1xuICAgICAgICB0aGlzLm1vdXNlRG93bkluQmFyID0gZmFsc2U7XG4gICAgICAgIGxldCBiYXIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcEFmdGVyRHJhZyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVJbkJhcik7XG4gICAgfVxuXG4gICAgb25Nb3VzZU1vdmVJbkJhcihldmVudCl7XG4gICAgICAgIGxldCBjdXJyZW50VG9wID0gcGFyc2VJbnQodGhpcy5zdHlsZS50b3ApO1xuICAgICAgICBsZXQgY3VycmVudExlZnQgPSBwYXJzZUludCh0aGlzLnN0eWxlLmxlZnQpO1xuICAgICAgICAvLyBsZXQgbmV3VG9wID0gYCR7Y3VycmVudFRvcCArIGV2ZW50Lm1vdmVtZW50WX1weGA7XG4gICAgICAgIC8vIGxldCBuZXdMZWZ0ID0gYCR7Y3VycmVudExlZnQgKyBldmVudC5tb3ZlbWVudFh9cHhgO1xuICAgICAgICBsZXQgbmV3VG9wID0gY3VycmVudFRvcCArIGV2ZW50Lm1vdmVtZW50WTtcbiAgICAgICAgbGV0IG5ld0xlZnQgPSBjdXJyZW50TGVmdCArIGV2ZW50Lm1vdmVtZW50WDtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwidG9wXCIsIG5ld1RvcCk7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImxlZnRcIiwgbmV3TGVmdCk7XG4gICAgfVxuXG4gICAgb25HcmlwVXAoZXZlbnQpe1xuICAgICAgICB0aGlzLmlzR3JpcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkdyaXBNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25HcmlwVXApO1xuICAgIH1cblxuICAgIG9uR3JpcERvd24oZXZlbnQpe1xuICAgICAgICB0aGlzLmlzR3JpcHBpbmcgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uR3JpcE1vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkdyaXBVcCk7XG4gICAgfVxuXG4gICAgb25HcmlwTW92ZShldmVudCl7XG4gICAgICAgIGlmKHRoaXMuaXNHcmlwcGluZyl7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBjdXJyZW50IHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgICAgICAvLyBhbmQgc2V0IHRoZSBwcm9wZXJ0eSB0byB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgbGV0IGJveCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBsZXQgbmV3V2lkdGggPSBNYXRoLmZsb29yKGJveC53aWR0aCkgKyBldmVudC5tb3ZlbWVudFg7XG4gICAgICAgICAgICBpZihuZXdXaWR0aCl7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwid2lkdGhcIiwgbmV3V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5ld0hlaWdodCA9IE1hdGguZmxvb3IoYm94LmhlaWdodCkgKyBldmVudC5tb3ZlbWVudFk7XG4gICAgICAgICAgICBpZihuZXdIZWlnaHQpe1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImhlaWdodFwiLCBuZXdIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGl0bGUoYVN0cmluZyl7XG4gICAgICAgIGxldCB0aXRsZUFyZWEgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnLnN0LXdpbmRvdy10aXRsZSA+IHNwYW4nXG4gICAgICAgICk7XG4gICAgICAgIHRpdGxlQXJlYS5pbm5lclRleHQgPSBhU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHN1YmNsYXNzIG1ldGhvZHNcbiAgICBuZXdTdWJwYXJ0VmlldyhuZXdWaWV3KXtcbiAgICAgICAgLy8gc2xvdCB0aGUgbmV3IHZpZXcgaW50byB0aGUgd2luZG93IHBhbmVcbiAgICAgICAgbGV0IHBhbmUgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zdC13aW5kb3ctcGFuZScpO1xuICAgICAgICBwYW5lLmFwcGVuZChuZXdWaWV3KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdWaWV3KTtcbiAgICB9XG5cblxufTtcblxuZXhwb3J0IHtcbiAgICBXaW5kb3dWaWV3LFxuICAgIFdpbmRvd1ZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogV29ybGRWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBXZWJjb21wb25lbnQgKGN1c3RvbSBlbGVtZW50KSB0aGF0IHJlcHJlc2VudHNcbiAqIGEgdmlldyBvZiBhIFdvcmxkU3RhY2sgbW9kZWwuXG4gKiBNeSBlbGVtZW50IGNoaWxkcmVuIHNob3VsZCBjb250YWluIGEgc2luZ2xlIFN0YWNrVmlldyByZXByZXNlbnRpbmdcbiAqIHRoZSBjdXJyZW50IGRpc3BsYXllZCBzdGFjayAodGhpcyBjb21lcyBmcm9tIHRoZSBtb2RlbCkuXG4gKiBJIGFtIHRoZSByb290LWxldmVsIGVsZW1lbnQgZm9yIHRoZSBTaW1wbGVUYWxrIHN5c3RlbSBpbiBhIHdlYlxuICogcGFnZS4gVGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIG9mIG1lIG9uIGFueSBnaXZlbiBIVE1MIHBhZ2UuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgPHNsb3Q+PC9zbG90PmA7XG5cbmNvbnN0IE5PREVTX1RPX0lHTk9SRV9XSEVOX0FSUk9XX0tFWSA9IFtcbiAgICAnVEVYVEFSRUEnLFxuICAgICdJTlBVVCcsXG4gICAgJ1NULUZJRUxEJ1xuXTtcblxuY2xhc3MgV29ybGRWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRlbXBsYXRpbmcgYW5kIHNoYWRvdyBkb21cbiAgICAgICAgLy8gVE9ETzogUHV0IHRoZSB0ZW1wbGF0ZSBkZWZpbml0aW9uIGluIHRoaXNcbiAgICAgICAgLy8gbW9kdWxlIGFzIGZvcm1hdHRlZCB0ZXh0XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUaGUgd29ybGQgbmV2ZXIgd2FudHMgYSBoYWxvXG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRTdGFjayA9IHRoaXMudXBkYXRlQ3VycmVudFN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZU1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMgPSB0aGlzLnNldHVwUHJvcEhhbmRsZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldHVwIHByb3AgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy51cGRhdGVDdXJyZW50U3RhY2spO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gRG8gYW4gaW5pdGlhbCB1cGRhdGUgdG8gZGlzcGxheVxuICAgICAgICAvLyB0aGUgbW9kZWwncyBjdXJyZW50IHN0YWNrXG4gICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFN0YWNrKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQ3VycmVudFN0YWNrKCl7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBwcm9wIGlzIHRoZSBzdGFjayBJRFxuICAgICAgICAvLyBvZiB0aGUgY2hpbGQgU3RhY2sgdGhhdCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgb25lLiBXZSByZW1vdmUgdGhlIGN1cnJlbnQtc3RhY2sgY2xhc3MgZnJvbVxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgY3VycmVudCBzdGFjayBhbmQgYWRkIGl0IHRvIHRoZSBuZXcgb25lLlxuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuY3VycmVudC1zdGFjaycpO1xuICAgICAgICBsZXQgbmV4dEN1cnJlbnRJZCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IG5leHRDdXJyZW50U3RhY2sgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYDpzY29wZSA+IHN0LXN0YWNrW3BhcnQtaWQ9XCIke25leHRDdXJyZW50SWR9XCJdYCk7XG4gICAgICAgIGlmKG5leHRDdXJyZW50U3RhY2spe1xuICAgICAgICAgICAgbmV4dEN1cnJlbnRTdGFjay5jbGFzc0xpc3QuYWRkKCdjdXJyZW50LXN0YWNrJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gcHJldmVudCB0aGUgc2V0dGluZyBvZiB0aGUgc2FtZSBpZCBhcyB0aGUgY3VycmVudCBzdGFjayBtYWtlIHN1cmVcbiAgICAgICAgLy8gbmV4dCBhbmQgY3VycmVudCBhcmUgbm90IHRoZSBzYW1lXG4gICAgICAgIGlmKGN1cnJlbnRTdGFjayAmJiBjdXJyZW50U3RhY2sgIT0gbmV4dEN1cnJlbnRTdGFjayl7XG4gICAgICAgICAgICBjdXJyZW50U3RhY2suY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudC1zdGFjaycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlS2V5RG93bihldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmFsdEtleSAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmNvZGUgPT0gXCJTcGFjZVwiKXtcbiAgICAgICAgICAgIGxldCBuYXZpZ2F0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1uYXZpZ2F0b3InKTtcbiAgICAgICAgICAgIG5hdmlnYXRvci50b2dnbGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJpbmQgYXJyb3cga2V5IGV2ZW50cyBpZiBhbmQgb25seSBpZlxuICAgICAgICAgICAgLy8gdGhlIGZvY3VzIGlzIG5vdCBpbiBhbnkga2luZCBvZiB0ZXh0IGlucHV0LlxuICAgICAgICAgICAgLy8gV2Ugc2VuZCB0aGUgYXJyb3dLZXkgY29tbWFuZCB0byB0aGUgY3VycmVudCBjYXJkXG4gICAgICAgICAgICBpZihldmVudC5jb2RlLnN0YXJ0c1dpdGgoJ0Fycm93Jykpe1xuICAgICAgICAgICAgICAgIGlmKCFOT0RFU19UT19JR05PUkVfV0hFTl9BUlJPV19LRVkuaW5jbHVkZXMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnYXJyb3dLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGFyZyBpcyB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY29kZS5zcGxpdCgnQXJyb3cnKVsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwuY3VycmVudFN0YWNrLmN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSBzdWJjbGFzcyBtZXRob2RzXG4gICAgbmV3U3VicGFydFZpZXcobmV3Vmlldyl7XG4gICAgICAgIGlmKHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggJiYgbmV3Vmlldy5uYW1lID09IFwiU3RhY2tWaWV3XCIpe1xuICAgICAgICAgICAgbGV0IGxhc3RTdGFja05vZGU7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZihjaGlsZC5uYW1lID09IFwiU3RhY2tWaWV3XCIpe1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tOb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZihsYXN0U3RhY2tOb2RlKXtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3Qgc3RhY2tcbiAgICAgICAgICAgICAgICBsYXN0U3RhY2tOb2RlLmFmdGVyKG5ld1ZpZXcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGVyZSBhcmUgbm8gc3RhY2tzXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGJlZm9yZSBhbGwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0uaW5zZXJ0QmVmb3JlKG5ld1ZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuZXhwb3J0IHtcbiAgICBXb3JsZFZpZXcsXG4gICAgV29ybGRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvLyBQUkVBTUJMRVxuaW1wb3J0IENvbnRleHRNZW51SXRlbSBmcm9tICcuL0NvbnRleHRNZW51SXRlbS5qcyc7XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0LWNvbnRleHQtbWVudS1pdGVtJywgQ29udGV4dE1lbnVJdGVtKTtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYm94LXNoYWRvdzogMXB4IDJweCAxMHB4IHJnYmEoNTAsIDUwLCA1MCwgMC43KTtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgICAgIG1pbi13aWR0aDogMjAwcHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICB9XG5cbiAgICA6aG9zdC1jb250ZXh0KGxpKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMTAwJTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgfVxuXG4gICAgOmhvc3QtY29udGV4dChsaSk6aG92ZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cblxuICAgIGhlYWRlciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC41KTtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTZweDtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xuICAgICAgICBwYWRkaW5nLXRvcDogOHB4O1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIH1cblxuICAgIGhlYWRlciA+IGg0IHtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgbWFyZ2luOjA7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cblxuPC9zdHlsZT5cbjxoZWFkZXI+XG4gICAgPGg0PjwvaDQ+XG48L2hlYWRlcj5cbjx1bCBpZD1cImxpc3QtaXRlbXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L3VsPlxuYDtcblxuY2xhc3MgQ29udGV4dE1lbnUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmFkZEhhbG9Ub2dnbGVJdGVtID0gdGhpcy5hZGRIYWxvVG9nZ2xlSXRlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZE5hdmlnYXRvclRvZ2dsZUl0ZW0gPSB0aGlzLmFkZE5hdmlnYXRvclRvZ2dsZUl0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRDb3B5QW5kUGFzdGVJdGVtcyA9IHRoaXMuYWRkQ29weUFuZFBhc3RlSXRlbXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRPcGVuRWRpdG9ySXRlbSA9IHRoaXMuYWRkT3BlbkVkaXRvckl0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRTY3JpcHRFZGl0SXRlbSA9IHRoaXMuYWRkU2NyaXB0RWRpdEl0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRNb3ZlbWVudEl0ZW1zID0gdGhpcy5hZGRNb3ZlbWVudEl0ZW1zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUGFydFN1Ym1lbnUgPSB0aGlzLmFkZFBhcnRTdWJtZW51LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0gPSB0aGlzLmFkZExpc3RJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkU3BhY2VyID0gdGhpcy5hZGRTcGFjZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oaWRlSGVhZGVyID0gdGhpcy5oaWRlSGVhZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRqdXN0VG9DbGllbnRWaWV3ID0gdGhpcy5hZGp1c3RUb0NsaWVudFZpZXcuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICBsZXQgaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlciA+IGg0Jyk7XG4gICAgICAgIGxldCBoZWFkZXJUZXh0ID0gYCR7dGhpcy5tb2RlbC50eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0aGlzLm1vZGVsLnR5cGUuc2xpY2UoMSl9YDtcbiAgICAgICAgaGVhZGVyVGV4dCA9IGBhICR7aGVhZGVyVGV4dH1gO1xuICAgICAgICBoZWFkZXJFbC50ZXh0Q29udGVudCA9IGhlYWRlclRleHQ7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBkZWZhdWx0IG1lbnUgaXRlbXNcbiAgICAgICAgdGhpcy5hZGRIYWxvVG9nZ2xlSXRlbSgpO1xuICAgICAgICB0aGlzLmFkZENvcHlBbmRQYXN0ZUl0ZW1zKCk7XG4gICAgICAgIHRoaXMuYWRkT3BlbkVkaXRvckl0ZW0oKTtcbiAgICAgICAgdGhpcy5hZGRQYXJ0U3VibWVudSgpO1xuICAgICAgICB0aGlzLmFkZFNjcmlwdEVkaXRJdGVtKCk7XG4gICAgICAgIHRoaXMuYWRkTW92ZW1lbnRJdGVtcygpO1xuICAgICAgICB0aGlzLmFkZE5hdmlnYXRvclRvZ2dsZUl0ZW0oKTtcblxuICAgICAgICAvLyBBZGQgVmlldy1zcGVjaWZpYyBpdGVtc1xuICAgICAgICBsZXQgdmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt0aGlzLm1vZGVsLmlkfVwiXWApO1xuICAgICAgICB2aWV3LmFkZENvbnRleHRNZW51SXRlbXModGhpcyk7XG4gICAgfVxuXG4gICAgYWRkTGlzdEl0ZW0obGFiZWwsIGNhbGxiYWNrLCBzdWJtZW51PW51bGwpe1xuICAgICAgICBsZXQgaXRlbUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtY29udGV4dC1tZW51LWl0ZW0nKTtcbiAgICAgICAgaXRlbUVsLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICAgIGl0ZW1FbC5jbGFzc0xpc3QuYWRkKCdjb250ZXh0LW1lbnUtaXRlbScpO1xuICAgICAgICBpdGVtRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFjayk7XG4gICAgICAgIGl0ZW1FbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihzdWJtZW51KXtcbiAgICAgICAgICAgIHN1Ym1lbnUuY2xhc3NMaXN0LmFkZCgnY29udGV4dC1zdWJtZW51JywgJ3N1Ym1lbnUtaGlkZGVuJyk7XG4gICAgICAgICAgICBzdWJtZW51LnNldEF0dHJpYnV0ZSgnc2xvdCcsICdzdWJtZW51Jyk7XG4gICAgICAgICAgICBpdGVtRWwuYXBwZW5kKHN1Ym1lbnUpO1xuICAgICAgICAgICAgaXRlbUVsLnNob3dDYXJldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kKGl0ZW1FbCk7XG4gICAgfVxuXG4gICAgYWRkSGFsb1RvZ2dsZUl0ZW0oKXtcbiAgICAgICAgbGV0IHRhcmdldCA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICAvLyBkb24ndCBhZGQgaGFsbyBvcHRpb24gdG8gY2FyZHMsIHNpbmNlIHlvdSBjYW4ndCBzZWUgdGhvc2VcbiAgICAgICAgaWYodGFyZ2V0Lm5hbWUgIT0gXCJDYXJkVmlld1wiKXtcbiAgICAgICAgICAgIGlmKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRpbmcnKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgJ0Nsb3NlIEhhbG8nLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICdPcGVuIEhhbG8nLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5vcGVuSGFsbygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZE5hdmlnYXRvclRvZ2dsZUl0ZW0oKXtcbiAgICAgICAgbGV0IG5hdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LW5hdmlnYXRvcicpO1xuICAgICAgICBpZihuYXYuY2xhc3NMaXN0LmNvbnRhaW5zKCdvcGVuJykpe1xuICAgICAgICAgICAgbmF2LmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ0Nsb3NlIE5hdmlnYXRvcicsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5hdi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdPcGVuIE5hdmlnYXRvcicsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5hdi5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIG5hdi5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZENvcHlBbmRQYXN0ZUl0ZW1zKCl7XG4gICAgICAgIC8vIEFkZCBjb3B5IGl0ZW1cbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdDb3B5JyxcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLmNvcHlQYXJ0KHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEFkZCBwYXN0ZSBidXQgb25seSBpZjpcbiAgICAgICAgLy8gMS4gVGhlcmUgaXMgY2xpcGJvYXJkIGNvbnRlbnRzO1xuICAgICAgICAvLyAyLiBUaGUgcGFydCB0eXBlIGluIHRoZSBjbGlwYm9hcmQgaXNcbiAgICAgICAgLy8gICAgb25lIHRoYXQgaXMgYWNjZXB0ZWQgYnkgdGhpcyBtb2RlbCdzIHBhcnRcbiAgICAgICAgaWYod2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29udGVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGxldCBwYXJ0VHlwZSA9IHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLmNvbnRlbnRzWzBdLnBhcnRUeXBlO1xuICAgICAgICAgICAgaWYodGhpcy5tb2RlbC5hY2NlcHRzU3VicGFydChwYXJ0VHlwZSkpe1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IGBQYXN0ZSAoYSAke3BhcnRUeXBlWzBdLnRvVXBwZXJDYXNlKCl9JHtwYXJ0VHlwZS5zbGljZSgxKX0pYDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKGxhYmVsLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQucGFzdGVDb250ZW50c0ludG8odGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRPcGVuRWRpdG9ySXRlbSgpe1xuICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgJ09wZW4gRWRpdG9yJyxcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0ub3BlbkVkaXRvckZvclBhcnQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYWRkU2NyaXB0RWRpdEl0ZW0oKXtcbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdFZGl0IFNjcmlwdCcsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5tb2RlbC5pZF1cbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgJ0VkaXQgV29ybGQgU2NyaXB0JyxcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsnd29ybGQnXVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCB3aW5kb3dBbmNlc3RvciA9IHRoaXMubW9kZWwuZmluZEFuY2VzdG9yT2ZUeXBlKCd3aW5kb3cnKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlICE9ICd3aW5kb3cnICYmIHdpbmRvd0FuY2VzdG9yICE9PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ0VkaXQgT3duaW5nIFdpbmRvdyBTY3JpcHQnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbd2luZG93QW5jZXN0b3IuaWRdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCBjYXJkQW5jZXN0b3IgPSB0aGlzLm1vZGVsLmZpbmRBbmNlc3Rvck9mVHlwZSgnY2FyZCcpO1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgIT0gJ2NhcmQnICYmIGNhcmRBbmNlc3Rvcil7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdFZGl0IE93bmluZyBDYXJkIFNjcmlwdCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtjYXJkQW5jZXN0b3IuaWRdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhY2tBbmNlc3RvciA9IHRoaXMubW9kZWwuZmluZEFuY2VzdG9yT2ZUeXBlKCdzdGFjaycpO1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgIT0gJ3N0YWNrJyAmJiBzdGFja0FuY2VzdG9yKXtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ0VkaXQgT3duaW5nIFN0YWNrIFNjcmlwdCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtzdGFja0FuY2VzdG9yLmlkXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkUGFydFN1Ym1lbnUoKXtcbiAgICAgICAgLy8gRmlyc3QsIHdlIG5lZWQgdG8gZ2V0IGEgbGlzdCBvZiBuYW1lc1xuICAgICAgICAvLyBvZiBzdWJwYXJ0cyB0aGF0IHRoaXMgbW9kZWwgYWNjZXB0c1xuICAgICAgICBsZXQgc3VicGFydE5hbWVzO1xuICAgICAgICBpZih0aGlzLm1vZGVsLmFjY2VwdGVkU3VicGFydFR5cGVzWzBdID09IFwiKlwiKXtcbiAgICAgICAgICAgIC8vIFRoaXMgbW9kZWwgYWNjZXB0cyBhbGwgc3VicGFydCB0eXBlcy5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IHRoZSBuYW1lcyBmb3IgdGhlc2Ugc3VicGFydHMsXG4gICAgICAgICAgICAvLyB3aGljaCBhcmUgcmVnaXN0ZXJlZCBhdCB0aGUgU3lzdGVtIGxldmVsLlxuICAgICAgICAgICAgc3VicGFydE5hbWVzID0gT2JqZWN0LmtleXMod2luZG93LlN5c3RlbS5hdmFpbGFibGVWaWV3cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJwYXJ0TmFtZXMgPSB0aGlzLm1vZGVsLmFjY2VwdGVkU3VicGFydFR5cGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHN1YnBhcnQgbmFtZXMgKG1lYW5pbmdcbiAgICAgICAgLy8gdGhlIGdpdmVuIHBhcnQsIGxpa2UgYSBidXR0b24sIGRvZXNuJ3RcbiAgICAgICAgLy8gYWNjZXB0IGFueSBzdWJwYXJ0cyksIHRoZW4gd2UgZG8gbm90aGluZy5cbiAgICAgICAgaWYoc3VicGFydE5hbWVzLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB3ZSBjb25zdHJ1Y3QgdGhlIHN1Ym1lbnUgZm9yIGFkZGluZyBwYXJ0c1xuICAgICAgICAvLyBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgICAgICBsZXQgc3VibWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWNvbnRleHQtbWVudScpO1xuICAgICAgICBzdWJtZW51LmhpZGVIZWFkZXIoKTtcbiAgICAgICAgc3VicGFydE5hbWVzLmZvckVhY2goc3VicGFydE5hbWUgPT4ge1xuICAgICAgICAgICAgc3VibWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICBzdWJwYXJ0TmFtZVswXS50b1VwcGVyQ2FzZSgpICsgc3VicGFydE5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbmV3TW9kZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnBhcnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTm93IGFkZCB0aGUgbGlzdCBpdGVtIHRoYXQgd2lsbCBcInJldmVhbFwiXG4gICAgICAgIC8vIHRoZSBzdWJtZW51XG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnQWRkIGEgbmV3IHBhcnQnLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN1Ym1lbnVcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgYWRkTW92ZW1lbnRJdGVtcygpe1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm1vZGVsLl9vd25lci5zdWJwYXJ0cy5pbmRleE9mKHRoaXMubW9kZWwpO1xuICAgICAgICBsZXQgb3duZXJMZW5ndGggPSB0aGlzLm1vZGVsLl9vd25lci5zdWJwYXJ0cy5sZW5ndGg7XG4gICAgICAgIGlmKG93bmVyTGVuZ3RoICYmIGluZGV4IDwgb3duZXJMZW5ndGggLSAxKXtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbW92ZURvd24gb3B0aW9uXG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdNb3ZlIERvd24nLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZURvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ01vdmUgdG8gTGFzdCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3ZlVG9MYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW5kZXggPiAwKXtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbW92ZVVwIG9wdGlvblxuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnTW92ZSBVcCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3ZlVXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ01vdmUgdG8gRmlyc3QnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZVRvRmlyc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFNwYWNlcigpe1xuICAgICAgICBsZXQgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnY29udGV4dC1tZW51LXNwYWNlcicpO1xuICAgICAgICB0aGlzLmFwcGVuZChpdGVtKTtcbiAgICB9XG5cbiAgICBoaWRlSGVhZGVyKCl7XG4gICAgICAgIGxldCBoZWFkZXJFbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignaGVhZGVyJyk7XG4gICAgICAgIGhlYWRlckVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG5cbiAgICBhZGp1c3RUb0NsaWVudFZpZXcoKXtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgcGFkZGluZyA9IDEwO1xuICAgICAgICBsZXQgdmlld3BvcnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IHZpZXdwb3J0SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgbGV0IGJvdHRvbURpZmYgPSAocmVjdC5ib3R0b20gKyBwYWRkaW5nKSAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICBsZXQgcmlnaHREaWZmID0gKHJlY3QucmlnaHQgKyBwYWRkaW5nKSAtIHZpZXdwb3J0V2lkdGg7XG4gICAgICAgIGlmKGJvdHRvbURpZmYgPiAwKXtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUudG9wID0gYCR7KHJlY3QudG9wIC0gYm90dG9tRGlmZil9cHhgO1xuXG4gICAgICAgICAgICAvLyBSZXBvc2l0aW9uIGFueSBoaWRkZW4gc3VibWVudXMsIHNvIHRoZXkgb3BlblxuICAgICAgICAgICAgLy8gYWJvdmVcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5jaGlsZHJlbikuZmlsdGVyKGNoaWxkRWwgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEVsLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKGl0ZW1XaXRoU3VibWVudSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGl0ZW1XaXRoU3VibWVudS5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3VibWVudS1hcmVhJyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IGAkeygtMSAqIGl0ZW1XaXRoU3VibWVudS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpfXB4YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmKHJpZ2h0RGlmZiA+IDApe1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0IC0gcmlnaHREaWZmfXB4YDtcblxuICAgICAgICAgICAgLy8gUmVwb3NpdGlvbiBhbnkgaGlkZGVuIHN1Ym1lbnVzLCBzbyB0aGV5IG9wZW5cbiAgICAgICAgICAgIC8vIHRvIHRoZSBsZWZ0IChpbnN0ZWFkIG9mIHJpZ2h0KVxuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuKS5maWx0ZXIoY2hpbGRFbCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkRWwuY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH0pLmZvckVhY2goaXRlbVdpdGhTdWJtZW51ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gaXRlbVdpdGhTdWJtZW51Ll9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zdWJtZW51LWFyZWEnKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IGAkeygtMSAqIGl0ZW1XaXRoU3VibWVudS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCl9cHhgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIENvbnRleHRNZW51LFxuICAgIENvbnRleHRNZW51IGFzIGRlZmF1bHRcbn07XG4iLCJjb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gICAgLnN1Ym1lbnUtYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMTAwJTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgfVxuXG4gICAgOmhvc3QoOmhvdmVyKSAuc3VibWVudS1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG5cbiAgICAubGFiZWwtYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgLmNhcmV0LmhpZGRlbiB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgIC5jYXJldCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICAgICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBjbGFzcz1cImxhYmVsLWFyZWFcIj5cbiAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+PHNsb3Q+PC9zbG90Pjwvc3Bhbj5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZXQgaGlkZGVuXCI+4oaSPC9kaXY+XG48L2Rpdj5cbjxkaXYgY2xhc3M9XCJzdWJtZW51LWFyZWFcIj5cbiAgICA8c2xvdCBuYW1lPVwic3VibWVudVwiPjwvc2xvdD5cbjwvZGl2PlxuYDtcblxuY2xhc3MgQ29udGV4dE1lbnVJdGVtIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgc2hhZG93IGRvbSBhbmQgdGVtcGxhdGVcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zaG93Q2FyZXQgPSB0aGlzLnNob3dDYXJldC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHNob3dDYXJldCgpe1xuICAgICAgICBsZXQgY2FyZXRFbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmNhcmV0Jyk7XG4gICAgICAgIGNhcmV0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7ICAgIFxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQ29udGV4dE1lbnVJdGVtLFxuICAgIENvbnRleHRNZW51SXRlbSBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBDb2xvclBpY2tlclRvb2xcbiAqIEkgcHJvdmlkZSBhIGNvbG9yIGNob29yc2VyIGNhcGFiaWxpdHlcbiAqIGZvciB0aGUgc2hhZG93IGNhbnZhcyBvZiBteSBwYXJlbnQgZWxlbWVudC5cbiAqIEJydXNoZXMgb24gbXkgcGFyZW50IERyYXdpbmcgY2FudmFzIHdpbGwgdXNlXG4gKiB3aGF0ZXZlciBjb2xvciBJIGhhdmUgY3VycmVudGx5IHNlbGVjdGVkLlxuICogSSBhbSBleHBsaWNpdGx5IGRlc2lnbmVkIGZvciB1c2Ugd2l0aFxuICogRHJhd2luZ1ZpZXcqL1xuaW1wb3J0IHtDb2xvcldoZWVsV2lkZ2V0fSBmcm9tICcuL0NvbG9yV2hlZWxXaWRnZXQuanMnO1xuY29uc3QgY29sb3JQaWNrZXJTVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY29sb3Itc3dhdGNoXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xOSAzaC00YTIgMiAwIDAgMCAtMiAydjEyYTQgNCAwIDAgMCA4IDB2LTEyYTIgMiAwIDAgMCAtMiAtMlwiIC8+XG4gIDxwYXRoIGQ9XCJNMTMgNy4zNWwtMiAtMmEyIDIgMCAwIDAgLTIuODI4IDBsLTIuODI4IDIuODI4YTIgMiAwIDAgMCAwIDIuODI4bDkgOVwiIC8+XG4gIDxwYXRoIGQ9XCJNNy4zIDEzaC0yLjNhMiAyIDAgMCAwIC0yIDJ2NGEyIDIgMCAwIDAgMiAyaDEyXCIgLz5cbiAgPGxpbmUgeDE9XCIxN1wiIHkxPVwiMTdcIiB4Mj1cIjE3XCIgeTI9XCIxNy4wMVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGNvbG9yUGlja2VyVGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA2cHg7XG4gICAgfVxuXG4gICAgI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgLS1hY3RpdmUtY29sb3I6IGJsYWNrO1xuICAgICAgICAtLWluYWN0aXZlLWNvbG9yOiByZ2IoMTcwLCAxNzAsIDE3MCk7XG4gICAgICAgIC0taG92ZXItY29sb3I6IHJnYigxNDAsIDE0MCwgMTQwKTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0taW5hY3RpdmUtY29sb3IpO1xuICAgICAgICBjb2xvcjogdmFyKC0taW5hY3RpdmUtY29sb3IpO1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgIH1cblxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+ICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgIGNvbG9yLXdoZWVsIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIH1cblxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+IGNvbG9yLXdoZWVsIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBpZD1cInRvb2wtYnV0dG9uXCI+XG4ke2NvbG9yUGlja2VyU1ZHfVxuPC9kaXY+XG48Y29sb3Itd2hlZWw+PC9jb2xvci13aGVlbD5cbmA7XG5cblxuY2xhc3MgQ29sb3JQaWNrZXJUb29sIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHNoYWRvdyBkb20uIFRoaXMgdG9vbCB3aWxsXG4gICAgICAgIC8vIGRpc3BsYXkgaXRzZWxmIGFzIGEgYnV0dG9uIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIHRvZ2dsZWQgd2l0aGluIGl0cyBwYXJlbnQgRHJhd2luZ1ZpZXcuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IGNvbG9yUGlja2VyVGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLnNoYWRvdy5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBkcmF3aW5nIGNvbnRleHQgaXMgbnVsbC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHNldCBpZiBhbmQgd2hlbiB0aGlzIHRvb2xcbiAgICAgICAgLy8gaXMgY29ubmVjdGVkIHRvIGEgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgLy8gdGhhdCBoYXMgYSBjb250ZXh0XG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy5lbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZSA9IHRoaXMudG9nZ2xlQWN0aXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Db2xvclNlbGVjdGVkID0gdGhpcy5vbkNvbG9yU2VsZWN0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZWQgPSB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcyA9IHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYoIXRoaXMuaGFzQXR0cmlidXRlKCdjdXJyZW50LWNvbG9yJykpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjdXJyZW50LWNvbG9yJywgJ3JnYmEoMCwgMCwgMCwgMCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBJIGFtIHRoZSBvbmx5IHRvb2wgaW4gbXkgcGFyZW50LFxuICAgICAgICAgICAgICAgIC8vIHNldCBteXNlbGYgdG8gYWN0aXZlXG4gICAgICAgICAgICAgICAgbGV0IHNpYmxpbmdUb29scyA9IHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKTtcbiAgICAgICAgICAgICAgICBpZihzaWJsaW5nVG9vbHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndG9vbC1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVBY3RpdmUpO1xuICAgICAgICAgICAgdGhpcy5jb2xvcldoZWVsID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2NvbG9yLXdoZWVsJyk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yV2hlZWwuYWRkRXZlbnRMaXN0ZW5lcignY29sb3Itc2VsZWN0ZWQnLCB0aGlzLm9uQ29sb3JTZWxlY3RlZCk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yV2hlZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNwYXJlbmN5LWNoYW5nZWQnLCB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgICAgIHRoaXMuYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVBY3RpdmUpO1xuICAgICAgICB0aGlzLmNvbG9yV2hlZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29sb3Itc2VsZWN0ZWQnLCB0aGlzLm9uQ29sb3JTZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuY29sb3JXaGVlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc3BhcmVuY3ktY2hhbmdlZCcsIHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2VkKTtcbiAgICB9XG5cbiAgICBzdGFydCh4LCB5KXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGluIHRoaXMgdG9vbFxuICAgIH1cblxuICAgIGVuZCh4LCB5KXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGluIHRoaXMgdG9vbFxuICAgIH1cblxuICAgIG9uTW92ZSh4LCB5KXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGluIHRoaXMgdG9vbFxuICAgIH1cblxuICAgIHNldENvbnRleHRGcm9tQXR0cmlidXRlcygpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgaW4gdGhpcyB0b29sXG4gICAgfVxuXG4gICAgb25Db2xvclNlbGVjdGVkKGV2ZW50KXtcbiAgICAgICAgbGV0IGNvbG9ySW5mbyA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgbGV0IGNvbG9yU3RyID0gYHJnYmEoJHtjb2xvckluZm8ucn0sICR7Y29sb3JJbmZvLmd9LCAke2NvbG9ySW5mby5ifSwgJHtjb2xvckluZm8uYWxwaGF9KWA7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3JTdHI7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yU3RyO1xuICAgIH1cblxuICAgIG9uVHJhbnNwYXJlbmN5Q2hhbmdlZChldmVudCl7XG4gICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcInNldFByb3BlcnR5XCIsXG4gICAgICAgICAgICBhcmdzOiBbXCJ0cmFuc3BhcmVuY3lcIiwgZXZlbnQuZGV0YWlsXVxuICAgICAgICB9LCB0aGlzLnBhcmVudEVsZW1lbnQubW9kZWwpO1xuICAgIH1cblxuICAgIHRvZ2dsZUFjdGl2ZShldmVudCl7XG4gICAgICAgIGxldCBpc0FjdGl2ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKTtcbiAgICAgICAgaWYoaXNBY3RpdmUgPT0gXCJ0cnVlXCIpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QsIGZpbmQgYW55IG90aGVyIHRvb2xzIGluIG15IHBhcmVudFxuICAgICAgICAgICAgLy8gZWxlbWVudCBhbmQgZGVhY3RpdmF0ZSB0aGVtLlxuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpID09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG9vbCB0byBiZSBhY3RpdmVcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2NvbG9yLXBpY2tlci10b29sJywgQ29sb3JQaWNrZXJUb29sKTtcblxuZXhwb3J0IHtcbiAgICBDb2xvclBpY2tlclRvb2wsXG4gICAgQ29sb3JQaWNrZXJUb29sIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIENvbG9yV2hlZWxXaWRnZXRcbiAqIEkgYW0gYSAqZ2VuZXJpYyB1c2UqIHdlYmNvbXBvbmVudCByZXByZXNlbnRpbmdcbiAqIGEgQ29sb3JXaGVlbCBzZWxlY3Rpb24gd2lkZ2V0LlxuICogSSBvcGVyYXRlIGFzIGEgZmxvYXRpbmcgbW9kYWwgd2luZG93IHdpdGggYVxuICogY2lyY3VsYXIgY29sb3Igd2hlZWwgYXMgd2VsbCBhcyBhIGxpc3Qgb2ZcbiAqIHJlY2VudGx5IHNlbGVjdGVkIGNvbG9ycy5cbiAqIEkgYW0gZGVzaWduZWQgdG8gYmUgdXNlZCBieSBhbnkgcGFyZW50IGVsZW1lbnQuXG4gKiBJIHdpbGwgdHJpZ2dlciBhbiBldmVudCBjYWxsZWQgJ2NvbG9yLWNoYW5nZScgd2hlbmV2ZXJcbiAqIGEgbmV3IGNvbG9yIGhhcyBiZWVuIHNlbGVjdGVkIGZyb20gd2l0aGluIG1lXG4gKi9cblxuY29uc3QgY29sb3JXaGVlbFRlbXBsYXRlID0gYFxuPHN0eWxlPlxuICA6aG9zdCB7XG4gICAgZGlzcGxheTogaW5pdGlhbCAhaW1wb3J0YW50O1xuICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gIH1cblxuICAjcGFsZXR0ZS1iYXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgaGVpZ2h0OiAyMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjAwLCAyMDAsIDIwMCk7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuXG4gICNwYWxldHRlLXRpdGxlIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIH1cblxuICAjY2xvc2UtYnV0dG9uIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTJweDtcbiAgICBoZWlnaHQ6IDEycHg7XG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxMnB4O1xuICB9XG5cbiAgI3BhbGV0dGUtY29udGVudCB7XG4gICAgZmxleDogMTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cbiAgI2hvdmVyLWNvbG9yIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDI1cHg7XG4gIH1cbiAgI29wdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICAgIG1hcmdpbi10b3A6IDVweDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgfVxuXG4gICNvcHRpb25zID4gbGFiZWx7XG4gICAgZm9udC1zaXplOiAuOHJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICAjcmVjZW50LWNvbG9ycyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgcGFkZGluZy1sZWZ0OiAxNXB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDE1cHg7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICB9XG4gIC5yZWNlbnQtY29sb3ItaXRlbSB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgd2lkdGg6IDI2cHg7XG4gICAgaGVpZ2h0OiAyNnB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjgpO1xuICB9XG5cbiAgLnJlY2VudC1jb2xvci1pdGVtLnNlbGVjdGVkIHtcbiAgICBib3JkZXI6IDJweCBzb2xpZCBibGFjaztcbiAgfVxuXG48L3N0eWxlPlxuPGRpdiBpZD1cInBhbGV0dGUtd3JhcHBlclwiPlxuICA8ZGl2IGlkPVwicGFsZXR0ZS1iYXJcIj48ZGl2IGlkPVwiY2xvc2UtYnV0dG9uXCI+eDwvZGl2PjxzcGFuIGlkPVwicGFsZXR0ZS10aXRsZVwiPjwvc3Bhbj48L2Rpdj5cbiAgPGRpdiBpZD1cInBhbGV0dGUtY29udGVudFwiPlxuICAgIDxkaXYgaWQ9XCJvcHRpb25zXCI+XG4gICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgaWQ9XCJ0cmFuc3BhcmVuY3lcIiBuYW1lPVwidHJhbnNwYXJlbmN5XCIgbWluPVwiMFwiIG1heD1cIjFcIiBzdGVwPVwiMC4xXCIgdmFsdWU9XCIxXCI+XG4gICAgICA8IS0tIDxsYWJlbCBmb3I9XCJ0cmFuc3BhcmVuY3lcIj5UcmFuc3BhcmVuY3k8L2xhYmVsPi0tPlxuICAgIDwvZGl2PlxuICAgIDx1bCBpZD1cInJlY2VudC1jb2xvcnNcIj5cbiAgICAgIDxsaSBjbGFzcz1cInJlY2VudC1jb2xvci1pdGVtIHNlbGVjdGVkXCI+PC9saT5cbiAgICAgIDxsaSBjbGFzcz1cInJlY2VudC1jb2xvci1pdGVtXCI+PC9saT5cbiAgICAgIDxsaSBjbGFzcz1cInJlY2VudC1jb2xvci1pdGVtXCI+PC9saT5cbiAgICA8L3VsPlxuICAgIDxjYW52YXMgaWQ9XCJjb2xvci13aGVlbFwiIHdpZHRoPVwiMTUwXCIgaGVpZ2h0PVwiMTUwXCI+PC9jYW52YXM+XG4gICAgPGRpdiBpZD1cImhvdmVyLWNvbG9yXCI+PC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBDb2xvcldoZWVsV2lkZ2V0IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gU2V0dXAgc2hhZG93IGRvbSBhbmQgdGVtcGxhdGVcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gY29sb3JXaGVlbFRlbXBsYXRlO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgbG9jYWwgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uV2hlZWxNb3VzZUVudGVyID0gdGhpcy5vbldoZWVsTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV2hlZWxNb3VzZUxlYXZlID0gdGhpcy5vbldoZWVsTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV2hlZWxNb3VzZU1vdmUgPSB0aGlzLm9uV2hlZWxNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldoZWVsQ2xpY2sgPSB0aGlzLm9uV2hlZWxDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSXRlbUNsaWNrID0gdGhpcy5vbkl0ZW1DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQmFyTW91c2VEb3duID0gdGhpcy5vbkJhck1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQmFyTW91c2VVcCA9IHRoaXMub25CYXJNb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25CYXJNb3VzZU1vdmUgPSB0aGlzLm9uQmFyTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlID0gdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9kcmF3V2hlZWwgPSB0aGlzLl9kcmF3V2hlZWwuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5iYXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3BhbGV0dGUtYmFyJyk7XG4gICAgICAgICAgICAvLyBnaXZlIHRoZSB3aWRnZXQgYSB0aXRsZSBpZiBwcm92aWRlZFxuICAgICAgICAgICAgaWYodGhpcy5uYW1lKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3BhbGV0dGUtdGl0bGUnKS5pbm5lclRleHQgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCBldmVudHNcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbldoZWVsQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25XaGVlbE1vdXNlRW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5iYXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbkJhck1vdXNlRG93bik7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCcucmVjZW50LWNvbG9yLWl0ZW0nKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uSXRlbUNsaWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lTbGlkZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zcGFyZW5jeScpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lTbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2UpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBjb2xvciB3aGVlbCB0byB0aGUgY2FudmFzXG4gICAgICAgICAgICB0aGlzLl9kcmF3V2hlZWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbldoZWVsQ2xpY2spO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbldoZWVsTW91c2VFbnRlcik7XG4gICAgICAgIHRoaXMuYmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25CYXJNb3VzZURvd24pO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcucmVjZW50LWNvbG9yLWl0ZW0nKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25JdGVtQ2xpY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lTbGlkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlKTtcbiAgICB9XG5cblxuICAgIG9uV2hlZWxNb3VzZUVudGVyKGV2ZW50KXtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGltYWdlIGRhdGEgZm9yIHRoZSB3aG9sZSBjYW52YXNcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIC8vIEJpbmQgc3Vic2VxdWVudCBldmVudHNcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbldoZWVsTW91c2VNb3ZlKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25XaGVlbE1vdXNlTGVhdmUpO1xuICAgIH1cblxuICAgIG9uV2hlZWxNb3VzZUxlYXZlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbldoZWVsTW91c2VNb3ZlKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25XaGVlbE1vdXNlTGVhdmUpO1xuICAgICAgICB0aGlzLl9jYWNoZWRJbWFnZURhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIG9uV2hlZWxNb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBnZXRQb3NpdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICAgIGxldCByZ2IgPSBnZXRSR0JGcm9tSW1hZ2VEYXRhKFxuICAgICAgICAgICAgcG9zaXRpb24ueCxcbiAgICAgICAgICAgIHBvc2l0aW9uLnksXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZEltYWdlRGF0YS5kYXRhXG4gICAgICAgICk7XG4gICAgICAgIGxldCBob3ZlckNvbG9yQXJlYSA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaG92ZXItY29sb3InKTtcbiAgICAgICAgbGV0IG5ld1N0eWxlID0gYHJnYmEoJHtyZ2JbMF19LCAke3JnYlsxXX0sICR7cmdiWzJdfSwgJHtyZ2JbM119KWA7XG4gICAgICAgIGhvdmVyQ29sb3JBcmVhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG5ld1N0eWxlO1xuICAgIH1cblxuICAgIG9uV2hlZWxDbGljayhldmVudCl7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uRnJvbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgbGV0IHJnYiA9IGdldFJHQkZyb21JbWFnZURhdGEoXG4gICAgICAgICAgICBwb3NpdGlvbi54LFxuICAgICAgICAgICAgcG9zaXRpb24ueSxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkSW1hZ2VEYXRhLmRhdGFcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGNvbG9ySW5mbyA9IHtcbiAgICAgICAgICAgIHI6IHJnYlswXSxcbiAgICAgICAgICAgIGc6IHJnYlsxXSxcbiAgICAgICAgICAgIGI6IHJnYlsyXSxcbiAgICAgICAgICAgIGFscGhhOiByZ2JbM11cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG5ld0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjb2xvci1zZWxlY3RlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDogY29sb3JJbmZvXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29sb3IgPSBjb2xvckluZm87XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZWNlbnQgY29sb3Igc3dhdGNoZXNcbiAgICAgICAgbGV0IGN1cnJlbnRTd2F0Y2hTZWxlY3Rpb24gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnJlY2VudC1jb2xvci1pdGVtLnNlbGVjdGVkJyk7XG4gICAgICAgIGlmKGN1cnJlbnRTd2F0Y2hTZWxlY3Rpb24pe1xuICAgICAgICAgICAgY3VycmVudFN3YXRjaFNlbGVjdGlvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgcmdiYSgke2NvbG9ySW5mby5yfSwgJHtjb2xvckluZm8uZ30sICR7Y29sb3JJbmZvLmJ9LCAke2NvbG9ySW5mby5hbHBoYX0pYDtcbiAgICAgICAgICAgIGN1cnJlbnRTd2F0Y2hTZWxlY3Rpb24uc2VsZWN0ZWRDb2xvciA9IGNvbG9ySW5mbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uVHJhbnNwYXJlbmN5Q2hhbmdlKGV2ZW50KXtcbiAgICAgICAgbGV0IGNvbW1hbmQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInNlbGVjdG9yLWNvbW1hbmRcIik7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyB0cmFuc3BhcmVuY3kgLSB0ZXh0IG9yIGJhY2tncm91bmRcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHdoYXQgdGhpcyBjb2xvciB3aGVlbCBpcyBzZXR1cCB0byB1cGRhdGVcbiAgICAgICAgbGV0IHByb3BOYW1lID0gXCJiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeVwiO1xuICAgICAgICBpZihjb21tYW5kID09PSBcInRleHQtY29sb3JcIil7XG4gICAgICAgICAgICBwcm9wTmFtZSA9IFwidGV4dC10cmFuc3BhcmVuY3lcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnREZXRhaWwgPSB7cHJvcE5hbWU6IHByb3BOYW1lLCB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlfTtcbiAgICAgICAgbGV0IG5ld0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd0cmFuc3BhcmVuY3ktY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDogZXZlbnREZXRhaWwsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIH1cblxuICAgIG9uSXRlbUNsaWNrKGV2ZW50KXtcbiAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGlzIG5vdCB0aGUgY3VycmVudGx5XG4gICAgICAgIC8vIHNlbGVjdGVkIHJlY2VudCBpdGVtLCBmaW5kIHRoZSBvbmUgdGhhdCBpc1xuICAgICAgICAvLyBhbmQgdG9nZ2xlIHRoZSBzZWxlY3Rpb24gY2xhc3MsIHRoZW4gdG9nZ2xlXG4gICAgICAgIC8vIHRoaXMgaXRlbSdzIHNlbGVjdGlvbiBjbGFzcy5cbiAgICAgICAgaWYoIWV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpe1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnLnJlY2VudC1jb2xvci1pdGVtLnNlbGVjdGVkJykpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0LnNlbGVjdGVkQ29sb3Ipe1xuICAgICAgICAgICAgbGV0IG5ld0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjb2xvci1zZWxlY3RlZCcsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IGV2ZW50LnRhcmdldC5zZWxlY3RlZENvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkJhck1vdXNlRG93bihldmVudCl7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25CYXJNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkJhck1vdXNlVXApO1xuICAgIH1cblxuICAgIG9uQmFyTW91c2VVcChldmVudCl7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25CYXJNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkJhck1vdXNlVXApO1xuICAgIH1cblxuICAgIG9uQmFyTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgbGV0IG5ld1RvcCA9IHRoaXMub2Zmc2V0VG9wICsgZXZlbnQubW92ZW1lbnRZO1xuICAgICAgICBsZXQgbmV3TGVmdCA9IHRoaXMub2Zmc2V0TGVmdCArIGV2ZW50Lm1vdmVtZW50WDtcbiAgICAgICAgdGhpcy5zdHlsZS50b3AgPSBgJHtuZXdUb3B9cHhgO1xuICAgICAgICB0aGlzLnN0eWxlLmxlZnQgPSBgJHtuZXdMZWZ0fXB4YDtcbiAgICB9XG5cbiAgICBvbkNsb3NlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBfZHJhd1doZWVsKCl7XG4gICAgICAgIGxldCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBkcmF3Q2lyY2xlKGN0eCwgdGhpcy5jYW52YXMud2lkdGggLyAyKTtcbiAgICB9XG59O1xuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjb2xvci13aGVlbCcsIENvbG9yV2hlZWxXaWRnZXQpO1xuXG4vKiogVXRpbGl0eSBGdW5jdGlvbnMgKiovXG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tXG4vLyBodHRwczovL21lZGl1bS5jb20vQGJhbnRpYy9oYW5kLWNvZGluZy1hLWNvbG9yLXdoZWVsLXdpdGgtY2FudmFzLTc4MjU2YzlkN2Q0M1xuY29uc3QgZHJhd0NpcmNsZSA9IChjdHgsIHJhZGl1cykgPT4ge1xuICAgIGxldCBpbWFnZSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMipyYWRpdXMsIDIqcmFkaXVzKTtcbiAgICBsZXQgZGF0YSA9IGltYWdlLmRhdGE7XG5cbiAgICBmb3IgKGxldCB4ID0gLXJhZGl1czsgeCA8IHJhZGl1czsgeCsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAtcmFkaXVzOyB5IDwgcmFkaXVzOyB5KyspIHtcblxuICAgICAgICAgICAgbGV0IFtyLCBwaGldID0geHkycG9sYXIoeCwgeSk7XG5cbiAgICAgICAgICAgIGlmIChyID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBhbGwgKHgseSkgY29vcmRpbmF0ZXMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2lyY2xlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkZWcgPSByYWQyZGVnKHBoaSk7XG5cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoaXMgcGl4ZWwgaW4gdGhlIGltYWdlIGRhdGEgYXJyYXkuXG4gICAgICAgICAgICBsZXQgcm93TGVuZ3RoID0gMipyYWRpdXM7XG4gICAgICAgICAgICBsZXQgYWRqdXN0ZWRYID0geCArIHJhZGl1czsgLy8gY29udmVydCB4IGZyb20gWy01MCwgNTBdIHRvIFswLCAxMDBdICh0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlIGRhdGEgYXJyYXkpXG4gICAgICAgICAgICBsZXQgYWRqdXN0ZWRZID0geSArIHJhZGl1czsgLy8gY29udmVydCB5IGZyb20gWy01MCwgNTBdIHRvIFswLCAxMDBdICh0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlIGRhdGEgYXJyYXkpXG4gICAgICAgICAgICBsZXQgcGl4ZWxXaWR0aCA9IDQ7IC8vIGVhY2ggcGl4ZWwgcmVxdWlyZXMgNCBzbG90cyBpbiB0aGUgZGF0YSBhcnJheVxuICAgICAgICAgICAgbGV0IGluZGV4ID0gKGFkanVzdGVkWCArIChhZGp1c3RlZFkgKiByb3dMZW5ndGgpKSAqIHBpeGVsV2lkdGg7XG5cbiAgICAgICAgICAgIGxldCBodWUgPSBkZWc7XG4gICAgICAgICAgICBsZXQgc2F0dXJhdGlvbiA9IHIgLyByYWRpdXM7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAxLjA7XG5cbiAgICAgICAgICAgIGxldCBbcmVkLCBncmVlbiwgYmx1ZV0gPSBoc3YycmdiKGh1ZSwgc2F0dXJhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgbGV0IGFscGhhID0gMjU1O1xuXG4gICAgICAgICAgICBkYXRhW2luZGV4XSA9IHJlZDtcbiAgICAgICAgICAgIGRhdGFbaW5kZXgrMV0gPSBncmVlbjtcbiAgICAgICAgICAgIGRhdGFbaW5kZXgrMl0gPSBibHVlO1xuICAgICAgICAgICAgZGF0YVtpbmRleCszXSA9IGFscGhhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG59O1xuXG4vLyBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BiYW50aWMvaGFuZC1jb2RpbmctYS1jb2xvci13aGVlbC13aXRoLWNhbnZhcy03ODI1NmM5ZDdkNDNcbmNvbnN0IHh5MnBvbGFyID0gKHgsIHkpID0+IHtcbiAgICBsZXQgciA9IE1hdGguc3FydCh4KnggKyB5KnkpO1xuICAgIGxldCBwaGkgPSBNYXRoLmF0YW4yKHksIHgpO1xuICAgIHJldHVybiBbciwgcGhpXTtcbn07XG5cbi8vIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb206XG4vLyBodHRwczovL21lZGl1bS5jb20vQGJhbnRpYy9oYW5kLWNvZGluZy1hLWNvbG9yLXdoZWVsLXdpdGgtY2FudmFzLTc4MjU2YzlkN2Q0M3NcbmNvbnN0IHJhZDJkZWcgPSAocmFkKSA9PiB7XG4gICAgcmV0dXJuICgocmFkICsgTWF0aC5QSSkgLyAoMiAqIE1hdGguUEkpKSAqIDM2MDtcbn07XG5cbi8vIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb206XG4vLyBodHRwczovL21lZGl1bS5jb20vQGJhbnRpYy9oYW5kLWNvZGluZy1hLWNvbG9yLXdoZWVsLXdpdGgtY2FudmFzLTc4MjU2YzlkN2Q0M1xuY29uc3QgaHN2MnJnYiA9IChodWUsIHNhdHVyYXRpb24sIHZhbHVlKSA9PiB7XG4gICAgbGV0IGNocm9tYSA9IHZhbHVlICogc2F0dXJhdGlvbjtcbiAgICBsZXQgaHVlMSA9IGh1ZSAvIDYwO1xuICAgIGxldCB4ID0gY2hyb21hICogKDEtIE1hdGguYWJzKChodWUxICUgMikgLSAxKSk7XG4gICAgbGV0IHIxLCBnMSwgYjE7XG4gICAgaWYgKGh1ZTEgPj0gMCAmJiBodWUxIDw9IDEpIHtcbiAgICAgICAgKFtyMSwgZzEsIGIxXSA9IFtjaHJvbWEsIHgsIDBdKTtcbiAgICB9IGVsc2UgaWYgKGh1ZTEgPj0gMSAmJiBodWUxIDw9IDIpIHtcbiAgICAgICAgKFtyMSwgZzEsIGIxXSA9IFt4LCBjaHJvbWEsIDBdKTtcbiAgICB9IGVsc2UgaWYgKGh1ZTEgPj0gMiAmJiBodWUxIDw9IDMpIHtcbiAgICAgICAgKFtyMSwgZzEsIGIxXSA9IFswLCBjaHJvbWEsIHhdKTtcbiAgICB9IGVsc2UgaWYgKGh1ZTEgPj0gMyAmJiBodWUxIDw9IDQpIHtcbiAgICAgICAgKFtyMSwgZzEsIGIxXSA9IFswLCB4LCBjaHJvbWFdKTtcbiAgICB9IGVsc2UgaWYgKGh1ZTEgPj0gNCAmJiBodWUxIDw9IDUpIHtcbiAgICAgICAgKFtyMSwgZzEsIGIxXSA9IFt4LCAwLCBjaHJvbWFdKTtcbiAgICB9IGVsc2UgaWYgKGh1ZTEgPj0gNSAmJiBodWUxIDw9IDYpIHtcbiAgICAgICAgKFtyMSwgZzEsIGIxXSA9IFtjaHJvbWEsIDAsIHhdKTtcbiAgICB9XG5cbiAgICBsZXQgbSA9IHZhbHVlIC0gY2hyb21hO1xuICAgIGxldCBbcixnLGJdID0gW3IxK20sIGcxK20sIGIxK21dO1xuXG4gICAgLy8gQ2hhbmdlIHIsZyxiIHZhbHVlcyBmcm9tIFswLDFdIHRvIFswLDI1NV1cbiAgICByZXR1cm4gWzI1NSpyLDI1NSpnLDI1NSpiXTtcbn07XG5cbmNvbnN0IGdldFBvc2l0aW9uRnJvbUV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBsZXQgb2Zmc2V0WCA9IHRhcmdldC5vZmZzZXRMZWZ0O1xuICAgIGxldCBvZmZzZXRZID0gdGFyZ2V0Lm9mZnNldFRvcDtcbiAgICBsZXQgY2hlY2sgPSB0YXJnZXQub2Zmc2V0UGFyZW50O1xuICAgIHdoaWxlKGNoZWNrKXtcbiAgICAgICAgb2Zmc2V0WCArPSBjaGVjay5vZmZzZXRMZWZ0O1xuICAgICAgICBvZmZzZXRZICs9IGNoZWNrLm9mZnNldFRvcDtcbiAgICAgICAgY2hlY2sgPSBjaGVjay5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBvZmZzZXRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gb2Zmc2V0WVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldFJHQkZyb21JbWFnZURhdGEgPSAoeCwgeSwgd2lkdGgsIGRhdGEpID0+IHtcbiAgICBsZXQgaW5kZXggPSAoeSAqIHdpZHRoICsgeCkgKiA0O1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGFbaW5kZXhdLCAvLyByXG4gICAgICAgIGRhdGFbaW5kZXggKyAxXSwgLy8gZ1xuICAgICAgICBkYXRhW2luZGV4ICsgMl0sIC8vIGJcbiAgICAgICAgZGF0YVtpbmRleCArIDNdIC8vIGFscGhhXG4gICAgXTtcbn07XG5cbmV4cG9ydCB7XG4gICAgQ29sb3JXaGVlbFdpZGdldCxcbiAgICBDb2xvcldoZWVsV2lkZ2V0IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIERyYXdpbmdWaWV3XG4gKiBFeHBlcmltZW50YWwuXG4gKiBUaGlzIGlzIHN0aWxsIGEgcHVyZSB3ZWJjb21wb25lbnQgYW5kIGlzIG5vdFxuICogbGlua2VkIGF0IGFsbCB0byBTaW1wbGVUYWxrIHlldC5cbiAqXG4gKi9cbmltcG9ydCB7UGFydFZpZXd9IGZyb20gJy4uL1BhcnRWaWV3LmpzJztcbmltcG9ydCB7UGVuY2lsVG9vbH0gZnJvbSAnLi9QZW5jaWxUb29sLmpzJztcbmltcG9ydCB7RXJhc2VyVG9vbH0gZnJvbSAnLi9FcmFzZXJUb29sLmpzJztcbmltcG9ydCB7Q29sb3JQaWNrZXJUb29sfSBmcm9tICcuL0NvbG9yUGlja2VyVG9vbC5qcyc7XG5cbmNvbnN0IGhhbG9CdXR0b25TVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItdG9vbFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNNyAxMGgzdi0zbC0zLjUgLTMuNWE2IDYgMCAwIDEgOCA4bDYgNmEyIDIgMCAwIDEgLTMgM2wtNi02YTYgNiAwIDAgMSAtOCAtOGwzLjUgMy41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG4gICAgI3Rvb2wtYnV0dG9ucyB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogY2FsYygxMDAlICsgNXB4KTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgfVxuICAgIDpob3N0KC5zaG93LWJvcmRlcil7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICAgIH1cbiAgICA6aG9zdCg6bm90KFttb2RlPVwiZHJhd2luZ1wiXSkpID4gI3Rvb2wtYnV0dG9ucyB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuPC9zdHlsZT5cbjxjYW52YXM+PC9jYW52YXMgPlxuPGRpdiBpZD1cInRvb2wtYnV0dG9uc1wiPlxuPHNsb3Q+PC9zbG90PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBEcmF3aW5nVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHNoYWRvdyBkb21cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLnNoYWRvdy5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclRvb2wgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaXNDdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZUxlYXZlID0gdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9SZXNpemUgPSB0aGlzLm9uSGFsb1Jlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvZ2dsZU1vZGUgPSB0aGlzLnRvZ2dsZU1vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZnRlckRyYXdBY3Rpb24gPSB0aGlzLmFmdGVyRHJhd0FjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc3RvcmVJbWFnZUZyb21Nb2RlbCA9IHRoaXMucmVzdG9yZUltYWdlRnJvbU1vZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMgPSB0aGlzLnNldHVwUHJvcEhhbmRsZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW9kZUNoYW5nZWQgPSB0aGlzLm1vZGVDaGFuZ2VkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0dXAgcHJvcCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ21vZGUnLCB0aGlzLm1vZGVDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2ltYWdlJywgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGltYWdlQml0cyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdpbWFnZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVJbWFnZUZyb21Nb2RlbChpbWFnZUJpdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Nob3ctYm9yZGVyJywgKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYodmFsKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Nob3ctYm9yZGVyJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdy1ib3JkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCd3aWR0aCcsICh2YWwpID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdoYXQgd2Ugd2FudCBpcyB0aGUgY2FsY3VsYXRlZCBDU1MsIG5vdCB0aGUgU1QgcGFydCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiY3NzU3R5bGVcIik7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3cucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgY3NzU3R5bGUud2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2hlaWdodCcsICh2YWwpID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdoYXQgd2Ugd2FudCBpcyB0aGUgY2FsY3VsYXRlZCBDU1MsIG5vdCB0aGUgU1QgcGFydCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiY3NzU3R5bGVcIik7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3cucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGNzc1N0eWxlLmhlaWdodCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZGVDaGFuZ2VkKHZhbHVlKXtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21vZGUnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLnNoYWRvdy5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG5cbiAgICAgICAgLy8gU2V0IGFuZCBzdG9yZSB0aGUgZHJhd2luZyBjb250ZXh0XG4gICAgICAgIHRoaXMuZHJhd2luZ0NvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIC8vIElmIEkgZG9uJ3QgaGF2ZSB0aGUgZGVmYXVsdCB0b29scywgYWRkXG4gICAgICAgIC8vIHRoZW0gYXMgcmVhbCBkb20gY2hpbGRyZW4gbm93XG4gICAgICAgIGxldCBwZW5jaWxDaGlsZCA9IHRoaXMucXVlcnlTZWxlY3RvcigncGVuY2lsLXRvb2wnKTtcbiAgICAgICAgaWYoIXBlbmNpbENoaWxkKXtcbiAgICAgICAgICAgIGxldCBuZXdQZW5jaWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwZW5jaWwtdG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQobmV3UGVuY2lsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXJhc2VyQ2hpbGQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2VyYXNlci10b29sJyk7XG4gICAgICAgIGlmKCFlcmFzZXJDaGlsZCl7XG4gICAgICAgICAgICBsZXQgbmV3RXJhc2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZXJhc2VyLXRvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5ld0VyYXNlcik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29sb3JQaWNrZXJDaGlsZCA9IHRoaXMucXVlcnlTZWxlY3RvcignY29sb3ItcGlja2VyLXRvb2wnKTtcbiAgICAgICAgaWYoIWNvbG9yUGlja2VyQ2hpbGQpe1xuICAgICAgICAgICAgbGV0IG5ld0NvbG9yUGlja2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sb3ItcGlja2VyLXRvb2wnKTtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBpcyBhIHRvdGFsIGhhY2sgc2luY2UgZHJhd2luZyBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBzdHlsZXMgYXQgdGhlIG1vbWVudFxuICAgICAgICAgICAgdGhpcy5hcHBlbmQobmV3Q29sb3JQaWNrZXIpO1xuICAgICAgICAgICAgbmV3Q29sb3JQaWNrZXIuY29sb3JXaGVlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2RpdiNvcHRpb25zJykuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgdGhpcy5jb2xvclBpY2tlclRvb2wgPSBuZXdDb2xvclBpY2tlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLmhhbG9CdXR0b24pe1xuICAgICAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICAvLyBzZXR1cCB0aGUgY2FudmFzIGhlaWdodCBhbmQgd2lkdGhcbiAgICAgICAgLy8gTm90ZTogd2hhdCB3ZSB3YW50IGlzIHRoZSBjYWxjdWxhdGVkIENTUywgbm90IHRoZSBTVCBwYXJ0IHByb3BlcnR5IHZhbHVlXG4gICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImNzc1N0eWxlXCIpO1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3cucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgY3NzU3R5bGUuaGVpZ2h0KTtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGNzc1N0eWxlLndpZHRoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRJbWFnZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnaW1hZ2UnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRJbWFnZSl7XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVJbWFnZUZyb21Nb2RlbChjdXJyZW50SW1hZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluaXRpYWxTaG93Qm9yZGVyID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdzaG93LWJvcmRlcidcbiAgICAgICAgKTtcbiAgICAgICAgaWYoaW5pdGlhbFNob3dCb3JkZXIpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzaG93LWJvcmRlcicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZighdGhpcy5pbkRyYXdpbmdNb2RlKSB7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBtb3VzZVVwIGNvbW1hbmQgbWVzc2FnZSB0byBzZWxmXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3VzZVVwJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVRvb2wgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ1tyb2xlPVwidG9vbFwiXVthY3RpdmU9XCJ0cnVlXCJdJyk7XG4gICAgICAgIGlmKCF0aGlzLmFjdGl2ZVRvb2wpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgICAgICB0aGlzLmFjdGl2ZVRvb2wuc3RhcnQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5hY3RpdmVUb29sICYmIHRoaXMuaW5EcmF3aW5nTW9kZSl7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRvb2wub25Nb3ZlKFxuICAgICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICAgICAgZXZlbnQub2Zmc2V0WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcIndhbnRzLW1vdmVcIikpe1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZScsXG4gICAgICAgICAgICAgICAgYXJnczogW2V2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZXVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlVXAoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5hY3RpdmVUb29sICYmIHRoaXMuaW5EcmF3aW5nTW9kZSAmJiB0aGlzLmlzQ3VycmVudGx5RHJhd2luZyl7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRvb2wuZW5kKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgICAgICAgICAgdGhpcy5hZnRlckRyYXdBY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3cucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgfVxuXG5cbiAgICBvbk1vdXNlTGVhdmUoZXZlbnQpe1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbGVmdCB0aGUgYXJlYVxuICAgICAgICAvLyB3aGlsZSBkcmF3aW5nLiBTbyBjYWxsIHRoZSBhY3RpdmVUb29sJ3NcbiAgICAgICAgLy8gZW5kIG1ldGhvZFxuICAgICAgICB0aGlzLmFjdGl2ZVRvb2wuZW5kKFxuICAgICAgICAgICAgZXZlbnQub2Zmc2V0WCxcbiAgICAgICAgICAgIGV2ZW50Lm9mZnNldFlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5pc0N1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZnRlckRyYXdBY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgb25IYWxvUmVzaXplKG1vdmVtZW50WCwgbW92ZW1lbnRZKXtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgbGV0IGN1cnJlbnRJbWFnZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnaW1hZ2UnXG4gICAgICAgICk7XG4gICAgICAgIC8vIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aCArIG1vdmVtZW50WDtcbiAgICAgICAgLy8gY2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgKyBtb3ZlbWVudFk7XG4gICAgICAgIGxldCBuZXdXaWR0aCA9IGNhbnZhcy53aWR0aCArIG1vdmVtZW50WDtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IGNhbnZhcy5oZWlnaHQgKyBtb3ZlbWVudFk7XG4gICAgICAgIGlmKG5ld1dpZHRoICYmIG5ld0hlaWdodCl7XG4gICAgICAgICAgICAvLyB0aGlzLnN0eWxlLndpZHRoID0gYCR7bmV3V2lkdGh9cHhgO1xuICAgICAgICAgICAgLy8gdGhpcy5zdHlsZS5oZWlnaHQgPSBgJHtuZXdIZWlnaHR9cHhgO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwoY3VycmVudEltYWdlKTtcbiAgICB9XG5cbiAgICBhZnRlckRyYXdBY3Rpb24oKXtcbiAgICAgICAgLy8gRW5jb2RlIGNhbnZhcyBjb250ZW50cyBhcyBiYXNlNjQgcG5nXG4gICAgICAgIC8vIGFuZCBzZXQgdG8gbW9kZWwncyBpbWFnZSBwcm9wZXJ0eVxuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgIGNhbnZhcy50b0RhdGFVUkwoKVxuICAgICAgICApO1xuICAgICAgICAvL3RoaXMuc2V0QXR0cmlidXRlKFwibW9kZVwiLCBcIlwiKTtcbiAgICB9XG5cbiAgICByZXN0b3JlSW1hZ2VGcm9tTW9kZWwoYmFzZTY0SW1hZ2VEYXRhKXtcbiAgICAgICAgLy8gQ2xlYXIgYW5kIGRyYXcgdGhlIGltYWdlIHRvIHJlc3RvcmUgdG9cbiAgICAgICAgLy8gdGhlIGNhbnZhc1xuICAgICAgICBpZihiYXNlNjRJbWFnZURhdGEpe1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IGJhc2U2NEltYWdlRGF0YTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBib3JkZXIgdG8gaGlkZVxuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3Nob3ctYm9yZGVyJyxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9uKCl7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaWQgPSBcImhhbG8tZHJhd2luZy10b2dnbGUtbW9kZVwiO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlubmVySFRNTCA9IGhhbG9CdXR0b25TVkc7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnYm90dG9tLXJvdycpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdUb2dnbGUgZHJhd2luZyB0b29scycpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZU1vZGUpO1xuICAgIH1cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQuIEhlcmUgd2UgYWRkIGEgY3VzdG9tIGJ1dHRvblxuICAgICAgICAvLyB3aGVuIHNob3dpbmcuXG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZighZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChmb3VuZEhhbG8pO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kSGFsby5hcHBlbmQodGhpcy5oYWxvQnV0dG9uKTtcbiAgICB9XG5cbiAgICB0b2dnbGVNb2RlKCl7XG4gICAgICAgIGxldCBjdXJyZW50TW9kZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RlJyk7XG4gICAgICAgIGxldCBuZXh0TW9kZSA9ICd2aWV3aW5nJzsgLy8gQnkgZGVmYXVsdCwgc2V0IHRvIHZpZXdpbmdcbiAgICAgICAgbGV0IGlzRW1wdHkgPSAoIWN1cnJlbnRNb2RlIHx8IGN1cnJlbnRNb2RlID09IHVuZGVmaW5lZCB8fCBjdXJyZW50TW9kZSA9PSBcIlwiKTtcbiAgICAgICAgaWYoY3VycmVudE1vZGUgPT0gJ3ZpZXdpbmcnIHx8IGlzRW1wdHkpe1xuICAgICAgICAgICAgbmV4dE1vZGUgPSAnZHJhd2luZyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdtb2RlJyxcbiAgICAgICAgICAgIG5leHRNb2RlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IGluRHJhd2luZ01vZGUoKXtcbiAgICAgICAgaWYoIXRoaXMubW9kZWwpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb2RlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21vZGUnKTtcbiAgICAgICAgaWYobW9kZSA9PSAnZHJhd2luZycpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRHJhd2luZ1ZpZXcsXG4gICAgRHJhd2luZ1ZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogRXJhc2VyVG9vbFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgcHJvdmlkZSBlcmFzZXItbGlrZSBmdW5jdGlvbmFsaXR5IG9uXG4gKiBteSBwYXJlbnQgZWxlbWVudCdzIHNoYWRvdyBjYW52YXMuXG4gKiBJIGFtIHNwZWNpZmljYWxseSBkZXNpZ25lZCBmb3IgdXNlIGFzIGFcbiAqIGNoaWxkIG9mIERyYXdpbmdWaWV3XG4gKi9cbmNvbnN0IGVyYXNlclNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1lcmFzZXJcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTE5IDE5aC0xMWwtNCAtNGExIDEgMCAwIDEgMCAtMS40MWwxMCAtMTBhMSAxIDAgMCAxIDEuNDEgMGw1IDVhMSAxIDAgMCAxIDAgMS40MWwtOSA5XCIgLz5cbiAgPGxpbmUgeDE9XCIxOFwiIHkxPVwiMTIuM1wiIHgyPVwiMTEuN1wiIHkyPVwiNlwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGVyYXNlclRvb2xUZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuICAgIH1cbiAgICAjdG9vbC1idXR0b24ge1xuICAgICAgICAtLWFjdGl2ZS1jb2xvcjogYmxhY2s7XG4gICAgICAgIC0taW5hY3RpdmUtY29sb3I6IHJnYigxNzAsIDE3MCwgMTcwKTtcbiAgICAgICAgLS1ob3Zlci1jb2xvcjogcmdiKDE0MCwgMTQwLCAxNDApO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0taW5hY3RpdmUtY29sb3IpO1xuICAgICAgICBjb2xvcjogdmFyKC0taW5hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiAjdG9vbC1idXR0b24ge1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICAjYnJ1c2hlcy1jb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA2cHg7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgICNicnVzaC1hZGp1c3RlciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgI2JydXNoLXNsaWRlcixcbiAgICAjYnJ1c2gtbnVtYmVyIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG4gICAgI2JydXNoLW51bWJlciB7XG4gICAgICAgIG1heC13aWR0aDogM3JlbTtcbiAgICB9XG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pID4gI2JydXNoZXMtY29udGFpbmVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBpZD1cInRvb2wtYnV0dG9uXCI+XG4gICR7ZXJhc2VyU1ZHfVxuPC9kaXY+XG48ZGl2IGlkPVwiYnJ1c2hlcy1jb250YWluZXJcIj5cbiAgPGRpdiBpZD1cImJydXNoLWFkanVzdGVyXCI+XG4gICAgPGlucHV0IGlkPVwiYnJ1c2gtc2xpZGVyXCIgdHlwZT1cInJhbmdlXCIgbWluPVwiMVwiIG1heD1cIjEwMFwiIHN0ZXA9XCIxXCI+XG4gICAgPGlucHV0IGlkPVwiYnJ1c2gtbnVtYmVyXCIgdHlwZT1cIm51bWJlclwiPlxuICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxuY2xhc3MgRXJhc2VyVG9vbCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHNoYWRvdyBkb20uIFRoaXMgdG9vbCB3aWxsXG4gICAgICAgIC8vIGRpc3BsYXkgaXRzZWxmIGFzIGEgYnV0dG9uIHRoYXQgY2FuXG4gICAgICAgIC8vIGJlIHRvZ2dsZWQuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IGVyYXNlclRvb2xUZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEZWZhdWx0IGRyYXdpbmcgY29udGV4dCBpcyBudWxsLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgc2V0IGlmIGFuZCB3aGVuIHRoaXMgdG9vbCBpc1xuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gYSBwYXJlbnQgZWxlbWVudCB0aGF0IGhhcyBhIGNvbnRleHRcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmQgPSB0aGlzLmVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlID0gdGhpcy50b2dnbGVBY3RpdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMgPSB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlID0gdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UgPSB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICAgICAgICBpZighdGhpcy5oYXNBdHRyaWJ1dGUoJ3dpZHRoJykpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsICc2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgSSBhbSB0aGUgb25seSB0b29sIGluIG15IHBhcmVudCxcbiAgICAgICAgICAgICAgICAvLyBzZXQgbXlzZWxmIHRvIGFjdGl2ZVxuICAgICAgICAgICAgICAgIGxldCBzaWJsaW5nVG9vbHMgPSB0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYoc2libGluZ1Rvb2xzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5idXR0b24gPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2wtYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2JydXNoLXNsaWRlcicpO1xuICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlci5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0ID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdicnVzaC1udW1iZXInKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBpcyBjdXJyZW50bHkgYSB3aWR0aCBzZXQsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNsaWRlciBhbmQgbnVtYmVyIGlucHV0IGFjY29yZGluZ2x5XG4gICAgICAgICAgICBsZXQgY3VycmVudFdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZihjdXJyZW50V2lkdGgpe1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIudmFsdWUgPSBwYXJzZUludChjdXJyZW50V2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC52YWx1ZSA9IHBhcnNlSW50KGN1cnJlbnRXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgICAgIHRoaXMuYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVBY3RpdmUpO1xuICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSk7XG4gICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZSk7XG4gICAgfVxuXG4gICAgc3RhcnQoeCwgeSl7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRoaXMuY2FjaGVkU3Ryb2tlU3R5bGUgPSB0aGlzLmN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKHgsIHkpe1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGVuZCh4LCB5KXtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jYWNoZWRTdHJva2VTdHlsZTtcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMoKXtcbiAgICAgICAgLy8gbGluZSBjYXBcbiAgICAgICAgbGV0IGxpbmVDYXAgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGluZS1jYXAnKTtcbiAgICAgICAgaWYobGluZUNhcCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7IC8vIGRlZmF1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbmUgam9pblxuICAgICAgICBsZXQgbGluZUpvaW4gPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGluZS1qb2luJyk7XG4gICAgICAgIGlmKGxpbmVKb2luKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVKb2luID0gbGluZUpvaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbmUgd2lkdGhcbiAgICAgICAgbGV0IGxpbmVXaWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgICAgICBpZihsaW5lV2lkdGgpe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gcGFyc2VJbnQobGluZVdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IDY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpe1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICdsaW5lLWpvaW4nLFxuICAgICAgICAgICAgJ2xpbmUtY2FwJ1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWwsIG5ld1ZhbCl7XG4gICAgICAgIGlmKG5hbWUgPT0gJ3dpZHRoJyl7XG4gICAgICAgICAgICBpZih0aGlzLmJydXNoU2xpZGVyKXtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnZhbHVlID0gcGFyc2VJbnQobmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuYnJ1c2hOdW1iZXJJbnB1dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LnZhbHVlID0gcGFyc2VJbnQobmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG5cbiAgICB0b2dnbGVBY3RpdmUoZXZlbnQpe1xuICAgICAgICBsZXQgaXNBY3RpdmUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlJyk7XG4gICAgICAgIGlmKGlzQWN0aXZlID09IFwidHJ1ZVwiKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBmaW5kIGFueSBvdGhlciB0b29scyBpbiBteSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgYW5kIGRlYWN0aXZhdGUgdGhlbS5cbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIHRvb2wgdG8gYmUgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlcmFzZXItdG9vbCcsIEVyYXNlclRvb2wpO1xuXG5leHBvcnQge1xuICAgIEVyYXNlclRvb2wsXG4gICAgRXJhc2VyVG9vbCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBQZW5jaWxUb29sXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBwcm92aWRlIHBlbmNpbC1saWtlIGRyYXdpbmcgY2FwYWJpbGl0eVxuICogb24gdGhlIHNoYWRvdyBjYW52YXMgb2YgbXkgcGFyZW50IGVsZW1lbnQuXG4gKiBJIGFtIGV4cGxpY2l0bHkgZGVzaWduZWQgZm9yIHVzZSB3aXRoXG4gKiBEcmF3aW5nVmlld1xuICovXG5jb25zdCBwZW5jaWxTVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcGVuY2lsXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk00IDIwaDRsMTAuNSAtMTAuNWExLjUgMS41IDAgMCAwIC00IC00bC0xMC41IDEwLjV2NFwiIC8+XG4gIDxsaW5lIHgxPVwiMTMuNVwiIHkxPVwiNi41XCIgeDI9XCIxNy41XCIgeTI9XCIxMC41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgcGVuY2lsVGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDZweDtcbiAgICB9XG4gICAgI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgLS1hY3RpdmUtY29sb3I6IGJsYWNrO1xuICAgICAgICAtLWluYWN0aXZlLWNvbG9yOiByZ2IoMTcwLCAxNzAsIDE3MCk7XG4gICAgICAgIC0taG92ZXItY29sb3I6IHJnYigxNDAsIDE0MCwgMTQwKTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pID4gI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgICAgICBjb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgI2JydXNoZXMtY29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAjYnJ1c2gtYWRqdXN0ZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA2cHg7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgICNicnVzaC1zbGlkZXIsXG4gICAgI2JydXNoLW51bWJlciB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgICNicnVzaC1udW1iZXIge1xuICAgICAgICBtYXgtd2lkdGg6IDNyZW07XG4gICAgfVxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+ICNicnVzaGVzLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJ0b29sLWJ1dHRvblwiPlxuICAke3BlbmNpbFNWR31cbjwvZGl2PlxuPGRpdiBpZD1cImJydXNoZXMtY29udGFpbmVyXCI+XG4gIDxkaXYgaWQ9XCJicnVzaC1hZGp1c3RlclwiPlxuICAgIDxpbnB1dCBpZD1cImJydXNoLXNsaWRlclwiIHR5cGU9XCJyYW5nZVwiIG1pbj1cIjFcIiBtYXg9XCIxMDBcIiBzdGVwPVwiMVwiPlxuICAgIDxpbnB1dCBpZD1cImJydXNoLW51bWJlclwiIHR5cGU9XCJudW1iZXJcIj5cbiAgPC9kaXY+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIFBlbmNpbFRvb2wgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXQgdXAgc2hhZG93IGRvbS4gVGhpcyB0b29sIHdpbGxcbiAgICAgICAgLy8gZGlzcGxheSBpdHNlbGYgYXMgYSBidXR0b24gdGhhdCBjYW5cbiAgICAgICAgLy8gYmUgdG9nZ2xlZC5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gcGVuY2lsVGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLnNoYWRvdy5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBkcmF3aW5nIGNvbnRleHRcbiAgICAgICAgLy8gaXMgbnVsbC4gVGhpcyB3aWxsIGJlIHNldFxuICAgICAgICAvLyBpZiBhbmQgd2hlbiB0aGlzIHRvb2wgaXNcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIGEgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgLy8gdGhhdCBoYXMgYSBjb250ZXh0XG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy5lbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZSA9IHRoaXMudG9nZ2xlQWN0aXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzID0gdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSA9IHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlID0gdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYoIXRoaXMuaGFzQXR0cmlidXRlKCd3aWR0aCcpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnNicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIElmIEkgYW0gdGhlIG9ubHkgdG9vbCBpbiBteSBwYXJlbnQsXG4gICAgICAgICAgICAgICAgLy8gc2V0IG15c2VsZiB0byBhY3RpdmVcbiAgICAgICAgICAgICAgICBsZXQgc2libGluZ1Rvb2xzID0gdGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpO1xuICAgICAgICAgICAgICAgIGlmKHNpYmxpbmdUb29scy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0b29sLWJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2ZSk7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdicnVzaC1zbGlkZXInKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dCA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYnJ1c2gtbnVtYmVyJyk7XG4gICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgaXMgY3VycmVudGx5IGEgd2lkdGggc2V0LFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBzbGlkZXIgYW5kIG51bWJlciBpbnB1dCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYoY3VycmVudFdpZHRoKXtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIudmFsdWUgPSBwYXJzZUludChjdXJyZW50V2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC52YWx1ZSA9IHBhcnNlSW50KGN1cnJlbnRXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgICAgIHRoaXMuYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVBY3RpdmUpO1xuICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSk7XG4gICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZSk7XG4gICAgfVxuXG4gICAgc3RhcnQoeCwgeSl7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKHgsIHkpe1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGVuZCh4LCB5KXtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzKCl7XG4gICAgICAgIC8vIGxpbmUgY2FwXG4gICAgICAgIGxldCBsaW5lQ2FwID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xpbmUtY2FwJyk7XG4gICAgICAgIGlmKGxpbmVDYXApe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lQ2FwID0gXCJyb3VuZFwiOyAvLyBkZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW5lIGpvaW5cbiAgICAgICAgbGV0IGxpbmVKb2luID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xpbmUtam9pbicpO1xuICAgICAgICBpZihsaW5lSm9pbil7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW5lIHdpZHRoXG4gICAgICAgIGxldCBsaW5lV2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgaWYobGluZVdpZHRoKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHBhcnNlSW50KGxpbmVXaWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSA2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKXtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAnbGluZS1qb2luJyxcbiAgICAgICAgICAgICdsaW5lLWNhcCdcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsLCBuZXdWYWwpe1xuICAgICAgICBpZihuYW1lID09ICd3aWR0aCcpe1xuICAgICAgICAgICAgaWYodGhpcy5icnVzaFNsaWRlcil7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlci52YWx1ZSA9IHBhcnNlSW50KG5ld1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmJydXNoTnVtYmVySW5wdXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC52YWx1ZSA9IHBhcnNlSW50KG5ld1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVCcnVzaFNsaWRlckNoYW5nZShldmVudCl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZShldmVudCl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlQWN0aXZlKGV2ZW50KXtcbiAgICAgICAgbGV0IGlzQWN0aXZlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpO1xuICAgICAgICBpZihpc0FjdGl2ZSA9PSBcInRydWVcIil7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZmluZCBhbnkgb3RoZXIgdG9vbHMgaW4gbXkgcGFyZW50XG4gICAgICAgICAgICAvLyBlbGVtZW50IGFuZCBkZWFjdGl2YXRlIHRoZW0uXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnYWN0aXZlJykgPT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhpcyB0b29sIHRvIGJlIGFjdGl2ZVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdwZW5jaWwtdG9vbCcsIFBlbmNpbFRvb2wpO1xuXG5leHBvcnQge1xuICAgIFBlbmNpbFRvb2wsXG4gICAgUGVuY2lsVG9vbCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IEVkaXRvclRhYiBmcm9tICcuL0VkaXRvclRhYi5qcyc7XG5pbXBvcnQgRWRpdG9yUHJvcExpc3QgZnJvbSAnLi9FZGl0b3JQcm9wTGlzdC5qcyc7XG5pbXBvcnQgRWRpdG9yTWVzc2VuZ2VyIGZyb20gJy4vRWRpdG9yTWVzc2VuZ2VyLmpzJztcbmltcG9ydCBFZGl0b3JDdXN0b21MaXN0IGZyb20gJy4vRWRpdG9yQ3VzdG9tTGlzdC5qcyc7XG5pbXBvcnQgRWRpdG9yU3VicGFydHNQYW5lIGZyb20gJy4vRWRpdG9yU3VicGFydHNQYW5lLmpzJztcbmltcG9ydCBwYXJ0SWNvbnMgZnJvbSAnLi4vLi4vdXRpbHMvaWNvbnMuanMnO1xuLy8gUFJFQU1CTEVcblxuLy8gQWRkIGVkaXRvciB0YWIgZWxlbWVudFxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLXRhYicsIEVkaXRvclRhYik7XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3ItcHJvcHMtbGlzdCcsIEVkaXRvclByb3BMaXN0KTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1jdXN0b20tbGlzdCcsIEVkaXRvckN1c3RvbUxpc3QpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLW1lc3NlbmdlcicsIEVkaXRvck1lc3Nlbmdlcik7XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3Itc3VicGFydHMnLCBFZGl0b3JTdWJwYXJ0c1BhbmUpO1xuXG5jb25zdCBjbG9zZUJ1dHRvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci14XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiM5ZTllOWVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGxpbmUgeDE9XCIxOFwiIHkxPVwiNlwiIHgyPVwiNlwiIHkyPVwiMThcIiAvPlxuICA8bGluZSB4MT1cIjZcIiB5MT1cIjZcIiB4Mj1cIjE4XCIgeTI9XCIxOFwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHNjcmlwdEljb24gPSBgXG48c3ZnIGlkPSdzY3JpcHQnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItZmlsZS1jb2RlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICAgIDxwYXRoIGQ9XCJNMTQgM3Y0YTEgMSAwIDAgMCAxIDFoNFwiIC8+XG4gICAgPHBhdGggZD1cIk0xNyAyMWgtMTBhMiAyIDAgMCAxIC0yIC0ydi0xNGEyIDIgMCAwIDEgMiAtMmg3bDUgNXYxMWEyIDIgMCAwIDEgLTIgMnpcIiAvPlxuICAgIDxwYXRoIGQ9XCJNMTAgMTNsLTEgMmwxIDJcIiAvPlxuICAgIDxwYXRoIGQ9XCJNMTQgMTNsMSAybC0xIDJcIiAvPlxuPC9zdmc+YDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTA1JSk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAxNTBtcyBsaW5lYXI7XG4gICAgICAgIHdpZHRoOiA0MDBweDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgICAgcGFkZGluZzogOHB4O1xuICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gICAgICAgIGJveC1zaGFkb3c6IDBweCAxcHggMTBweCAycHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIH1cbiAgICBcbiAgICA6aG9zdCgub3Blbil7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwJSk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAxNTBtcyBsaW5lYXI7XG4gICAgICAgIHotaW5kZXg6IDEwMDtcbiAgICB9XG5cbiAgICA6aG9zdCg6OmFmdGVyKSB7XG4gICAgICAgIGNvbnRlbnQ6IFwiIFwiO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHdpZHRoOiA1cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAtMTA7XG4gICAgICAgIGJveC1zaGFkb3c6IDBweCAwcHggM3B4IDEwcHggcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjYpO1xuICAgIH1cblxuICAgIDo6c2xvdHRlZChlZGl0b3ItcHJvcHMtbGlzdDpub3QoLnNob3ctcGFuZSkpLFxuICAgIDo6c2xvdHRlZChlZGl0b3ItbWVzc2VuZ2VyOm5vdCguc2hvdy1wYW5lKSksXG4gICAgOjpzbG90dGVkKGVkaXRvci1jdXN0b20tbGlzdDpub3QoLnNob3ctcGFuZSkpLFxuICAgIDo6c2xvdHRlZChlZGl0b3Itc3VicGFydHM6bm90KC5zaG93LXBhbmUpKXtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICAjdGFiLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cbiAgICBcbiAgICAjcGFuZS1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG1hcmdpbi10b3A6IDIwcHg7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuXG4gICAgI2hlYWRlci1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICAgIH1cblxuICAgIC5oZWFkZXItc2lkZSB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG1hcmdpbi10b3A6IDIwcHg7XG4gICAgfVxuXG4gICAgI2Rpc3BsYXktYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDMwcHg7XG4gICAgfVxuXG4gICAgI2hlYWRlci1hcmVhIGgzIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgICAgICBtYXJnaW4tbGVmdDogNXB4O1xuICAgICAgICBmb250LXNpemU6IDEuN3JlbTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLWxlZnQgPiBpbnB1dCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgcGFkZGluZzogNHB4O1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC44KTtcbiAgICAgICAgZm9udC1zaXplOiAxLjFyZW07XG4gICAgfVxuXG4gICAgI2hlYWRlci1yaWdodCA+IGJ1dHRvbiB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgZm9udC1zaXplOiAwLjg1ZW07XG4gICAgfVxuXG4gICAgI2hlYWRlci1yaWdodCA+IGJ1dHRvbjpob3ZlciB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxNTAsIDE1MCwgMTUwLCAwLjMpO1xuICAgIH1cblxuICAgICNoZWFkZXItcmlnaHQgPiBidXR0b246YWN0aXZlIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxNTAsIDE1MCwgMTUwLCAwLjgpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIyMCwgMjIwLCAyMjApO1xuICAgIH1cblxuICAgICNoZWFkZXItcmlnaHQgPiBidXR0b24gPiBzdmcge1xuICAgICAgICBoZWlnaHQ6IDEuM2VtO1xuICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA4cHg7XG4gICAgfVxuXG4gICAgI2hlYWRlci1sZWZ0IHtcbiAgICAgICAgbWF4LXdpZHRoOiA4MCU7XG4gICAgfVxuXG4gICAgI2hlYWRlci1sZWZ0IHNwYW4ge1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDEuMXJlbTtcbiAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuXG4gICAgI2ljb24tZGlzcGxheS1hcmVhIHtcbiAgICAgICAgd2lkdGg6IDEuN3JlbTtcbiAgICAgICAgaGVpZ2h0OiAxLjdyZW07XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDVweDtcbiAgICB9XG4gICAgI2ljb24tZGlzcGxheS1hcmVhID4gc3ZnIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5cbiAgICAjY2xvc2UtYnV0dG9uIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiA1O1xuICAgICAgICByaWdodDogNTtcbiAgICB9XG4gICAgI2Nsb3NlLWJ1dHRvbjpob3ZlciB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBpZD1cImNsb3NlLWJ1dHRvblwiPiR7Y2xvc2VCdXR0b259PC9kaXY+XG48ZGl2IGlkPVwiaGVhZGVyLWFyZWFcIj5cbiAgICA8ZGl2IGlkPVwiaGVhZGVyLWxlZnRcIiBjbGFzcz1cImhlYWRlci1zaWRlXCI+XG4gICAgICAgIDxkaXYgaWQ9XCJkaXNwbGF5LWFyZWFcIj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJpY29uLWRpc3BsYXktYXJlYVwiPjwvZGl2PlxuICAgICAgICAgICAgPGgzPjwvaDM+PHNwYW4+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJwYXJ0LW5hbWUtaW5wdXRcIi8+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImhlYWRlci1yaWdodFwiIGNsYXNzPVwiaGVhZGVyLXNpZGVcIj5cbiAgICAgICAgPGJ1dHRvbiBpZD1cImVkaXQtc2NyaXB0LWJ1dHRvblwiPlxuICAgICAgICAgICAgJHtzY3JpcHRJY29ufVxuICAgICAgICAgICAgPHNwYW4+RWRpdCBTY3JpcHQ8L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuPC9kaXY+XG48ZGl2IGlkPVwidGFiLWFyZWFcIj5cbiAgICA8ZWRpdG9yLXRhYiBhY3RpdmU9XCJ0cnVlXCIgbmFtZT1cInByb3BlcnRpZXNcIj5Qcm9wZXJ0aWVzPC9lZGl0b3ItdGFiPlxuICAgIDxlZGl0b3ItdGFiIG5hbWU9XCJjdXN0b21cIj5DdXN0b208L2VkaXRvci10YWI+XG4gICAgPGVkaXRvci10YWIgbmFtZT1cIm1lc3NlbmdlclwiPk1lc3NlbmdlcjwvZWRpdG9yLXRhYj5cbiAgICA8ZWRpdG9yLXRhYiBuYW1lPVwic3VicGFydHNcIj5TdWJwYXJ0czwvZWRpdG9yLXRhYj5cbjwvZGl2PlxuPGRpdiBpZD1cInBhbmUtYXJlYVwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbjwvZGl2PlxuYDtcblxuY2xhc3MgRWRpdG9yIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy50b2dnbGUgPSB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW4gPSB0aGlzLm9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNlbnRlck9uRWxlbWVudCA9IHRoaXMuY2VudGVyT25FbGVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudW5kb0NlbnRlck9uRWxlbWVudCA9IHRoaXMudW5kb0NlbnRlck9uRWxlbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhlYWRlciA9IHRoaXMudXBkYXRlSGVhZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hlY2tGb3JOYXZpZ2F0aW9uID0gdGhpcy5jaGVja0Zvck5hdmlnYXRpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlTWVzc2FnZSA9IHRoaXMucmVjZWl2ZU1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRhYkFjdGl2YXRlZCA9IHRoaXMub25UYWJBY3RpdmF0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk5hbWVJbnB1dENoYW5nZSA9IHRoaXMub25OYW1lSW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkVkaXRTY3JpcHRDbGljayA9IHRoaXMub25FZGl0U2NyaXB0Q2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcigndGFiLWFjdGl2YXRlZCcsIHRoaXMub25UYWJBY3RpdmF0ZWQpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnY2xvc2UtYnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50c1xuICAgICAgICAgICAgbGV0IG5hbWVJbnB1dCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3BhcnQtbmFtZS1pbnB1dCcpO1xuICAgICAgICAgICAgbmFtZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25OYW1lSW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgICAgICBsZXQgZWRpdFNjcmlwdEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2VkaXQtc2NyaXB0LWJ1dHRvbicpO1xuICAgICAgICAgICAgZWRpdFNjcmlwdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25FZGl0U2NyaXB0Q2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCd0YWItYWN0aXZhdGVkJywgdGhpcy5vblRhYkFjdGl2YXRlZCk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2Nsb3NlLWJ1dHRvbicpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgdGhpcy5jbG9zZVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgIGxldCBuYW1lSW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdwYXJ0LW5hbWUtaW5wdXQnKTtcbiAgICAgICAgbmFtZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25OYW1lSW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgIGxldCBlZGl0U2NyaXB0QnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRpdC1zY3JpcHQtYnV0dG9uJyk7XG4gICAgICAgIGVkaXRTY3JpcHRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRWRpdFNjcmlwdENsaWNrKTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKXtcbiAgICAgICAgaWYodGhpcy5pc09wZW4pe1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuKCl7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICB0aGlzLmNlbnRlck9uRWxlbWVudCgpO1xuICAgIH1cblxuICAgIGNsb3NlKCl7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xuICAgICAgICB0aGlzLnVuZG9DZW50ZXJPbkVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgaWYodGhpcy5tb2RlbCl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnJlbW92ZVByb3BlcnR5U3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICB0aGlzLm1vZGVsLmFkZFByb3BlcnR5U3Vic2NyaWJlcih0aGlzKTtcblxuICAgICAgICAvLyBJZiB0aGUgaW5jb21pbmcgbW9kZWwgaXMgYSBDYXJkIG9yXG4gICAgICAgIC8vIFN0YWNrIHRoYXQgaXMgbm90IHRoZSBjdXJyZW50IG9uZSxcbiAgICAgICAgLy8gd2UgbmF2aWdhdGUgdG8gaXRcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICdjYXJkJyB8fCB0aGlzLm1vZGVsLnR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yTmF2aWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xvc2UgYW55IG9wZW4gSGFsb3MuXG4gICAgICAgIC8vIElmIHRoZSBuZXcgbW9kZWwgd2FudHMgYSBIYWxvLFxuICAgICAgICAvLyBvcGVuIGl0IG9uIHRoZSBWaWV3IGZvciB0aGF0IE1vZGVsLlxuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC5lZGl0aW5nYCkpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgZWwuY2xvc2VIYWxvKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGFyZ2V0VmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt0aGlzLm1vZGVsLmlkfVwiXWApO1xuICAgICAgICBpZih0YXJnZXRWaWV3ICYmIHRhcmdldFZpZXcud2FudHNIYWxvKXtcbiAgICAgICAgICAgIHRhcmdldFZpZXcub3BlbkhhbG8oKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy51cGRhdGVIZWFkZXIoKTtcblxuICAgICAgICAvLyBDbGVhciBzbG90dGVkIGlubmVyIERPTVxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAgICAgLy8gQWRkIHBhbmVzXG4gICAgICAgIGxldCBwcm9wc1BhbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItcHJvcHMtbGlzdCcpO1xuICAgICAgICBwcm9wc1BhbmUuc2V0QXR0cmlidXRlKCd0YWItbmFtZScsICdwcm9wZXJ0aWVzJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQocHJvcHNQYW5lKTtcbiAgICAgICAgcHJvcHNQYW5lLnJlbmRlcih0aGlzLm1vZGVsKTtcblxuICAgICAgICBsZXQgbWVzc2VuZ2VyUGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1tZXNzZW5nZXInKTtcbiAgICAgICAgbWVzc2VuZ2VyUGFuZS5zZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJywgJ21lc3NlbmdlcicpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG1lc3NlbmdlclBhbmUpO1xuICAgICAgICBtZXNzZW5nZXJQYW5lLnJlbmRlcih0aGlzLm1vZGVsKTtcblxuICAgICAgICBsZXQgY3VzdG9tUGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1jdXN0b20tbGlzdCcpO1xuICAgICAgICBjdXN0b21QYW5lLnNldEF0dHJpYnV0ZSgndGFiLW5hbWUnLCAnY3VzdG9tJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY3VzdG9tUGFuZSk7XG4gICAgICAgIGN1c3RvbVBhbmUucmVuZGVyKHRoaXMubW9kZWwpO1xuXG4gICAgICAgIGxldCBzdWJwYXJ0c1BhbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3Itc3VicGFydHMnKTtcbiAgICAgICAgc3VicGFydHNQYW5lLnNldEF0dHJpYnV0ZSgndGFiLW5hbWUnLCAnc3VicGFydHMnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdWJwYXJ0c1BhbmUpO1xuICAgICAgICBzdWJwYXJ0c1BhbmUucmVuZGVyKHRoaXMubW9kZWwpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGFjdGl2ZSB0YWIgYW5kIHNob3cgaXRzIGNvcnJlc3BvbmRpbmcgcGFuZVxuICAgICAgICBsZXQgYWN0aXZlVGFiID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGBlZGl0b3ItdGFiW2FjdGl2ZT1cInRydWVcIl1gKTtcbiAgICAgICAgaWYoYWN0aXZlVGFiKXtcbiAgICAgICAgICAgIGxldCBhY3RpdmVOYW1lID0gYWN0aXZlVGFiLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t0YWItbmFtZV0nKSkuZm9yRWFjaChwYW5lID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHBhbmUuZ2V0QXR0cmlidXRlKCd0YWItbmFtZScpO1xuICAgICAgICAgICAgICAgIGlmKG5hbWUgPT0gYWN0aXZlTmFtZSl7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuY2xhc3NMaXN0LmFkZCgnc2hvdy1wYW5lJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93LXBhbmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgcGFuZSBpcyBhbHJlYWR5IG9wZW4sIHRoZW4gY2VudGVyXG4gICAgICAgIC8vIG9uIHRoZSBwcmltYXJ5IHZpZXcgZWxlbWVudCBmb3IgdGhlIG1vZGVsXG4gICAgICAgIGlmKHRoaXMuaXNPcGVuKXtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyT25FbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjZW50ZXJPbkVsZW1lbnQoKXtcbiAgICAgICAgLy8gVXNlIENTUyB0cmFuc2Zvcm1zIG9mIHRoZSB3aG9sZSBXb3JsZCB0byBjZW50ZXIgb25cbiAgICAgICAgLy8gdGhlIHByaW1hcnkgdmlldyBlbGVtZW50IG9mIHRoZSBQYXJ0IGJlaW5nIGVkaXRlZCxcbiAgICAgICAgLy8gaWYgc2V0LiBJZiBub3Qgc2V0LCBkbyBub3RoaW5nLlxuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBlZGl0aW5nIGEgQ2FyZCwgU3RhY2ssIG9yIFdvcmxkLCB0aGVuXG4gICAgICAgICAgICAvLyB3ZSB1bmNlbnRlciBhbmQgcmV0dXJuXG4gICAgICAgICAgICBsZXQgaXNDYXJkU3RhY2tPcldvcmxkID0gWydjYXJkJywgJ3N0YWNrJywgJ3dvcmxkJ10uaW5jbHVkZXModGhpcy5tb2RlbC50eXBlKTtcbiAgICAgICAgICAgIGlmKGlzQ2FyZFN0YWNrT3JXb3JsZCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5kb0NlbnRlck9uRWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgcGFydFZpZXcgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZCh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgICAgIGxldCB3b3JsZFZpZXcgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZCgnd29ybGQnKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gd29ybGRWaWV3LmdldEF0dHJpYnV0ZSgnY2VudGVyZWQtb24nKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnQgPT0gdGhpcy5tb2RlbC5pZC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtZW51UmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBsZXQgcGFydFJlY3QgPSBwYXJ0Vmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBhY3R1YWwgdmlld2FibGUgd2lkdGgsIHBsdXMgdGhlIGVkaXRvciBtZW51XG4gICAgICAgICAgICBsZXQgdmlld1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggKyBtZW51UmVjdC53aWR0aDtcbiAgICAgICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSBtZW51UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBYIHRyYW5zbGF0aW9uXG4gICAgICAgICAgICBsZXQgdGFyZ2V0WCA9ICh2aWV3V2lkdGggLSBwYXJ0UmVjdC53aWR0aCkgLyAyO1xuICAgICAgICAgICAgbGV0IG5ld1g7XG4gICAgICAgICAgICBpZih0YXJnZXRYIDwgcGFydFJlY3QubGVmdCl7XG4gICAgICAgICAgICAgICAgbmV3WCA9IChwYXJ0UmVjdC5sZWZ0IC0gdGFyZ2V0WCkgKiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3WCA9IHRhcmdldFggLSBwYXJ0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgWSB0cmFuc2xhdGlvblxuICAgICAgICAgICAgbGV0IHRhcmdldFkgPSAodmlld0hlaWdodCAtIHBhcnRSZWN0LmhlaWdodCkgLyAyO1xuICAgICAgICAgICAgbGV0IG5ld1k7XG4gICAgICAgICAgICBpZih0YXJnZXRZIDwgcGFydFJlY3QudG9wKXtcbiAgICAgICAgICAgICAgICBuZXdZID0gKHBhcnRSZWN0LnRvcCAtIHRhcmdldFkpICogLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1kgPSB0YXJnZXRZIC0gcGFydFJlY3QudG9wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3b3JsZFZpZXcuc2V0QXR0cmlidXRlKCdjZW50ZXJlZC1vbicsIHRoaXMubW9kZWwuaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgdHJhbnNmb3JtIGFuZCB0cmFuc2l0aW9uXG4gICAgICAgICAgICB3b3JsZFZpZXcuc3R5bGUudHJhbnNpdGlvbiA9IFwidHJhbnNmb3JtIDAuM3MgZWFzZS1vdXRcIjtcbiAgICAgICAgICAgIHdvcmxkVmlldy5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7bmV3WH1weCwgJHtuZXdZfXB4KWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bmRvQ2VudGVyT25FbGVtZW50KCl7XG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZCgnd29ybGQnKTtcbiAgICAgICAgd29ybGRWaWV3LnJlbW92ZUF0dHJpYnV0ZSgnY2VudGVyZWQtb24nKTtcbiAgICAgICAgd29ybGRWaWV3LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2Zvcm0nKTtcbiAgICB9XG5cbiAgICB1cGRhdGVIZWFkZXIoKXtcbiAgICAgICAgbGV0IG5hbWVJbnB1dCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI2hlYWRlci1sZWZ0ID4gaW5wdXQnKTtcbiAgICAgICAgbGV0IHR5cGVEaXNwbGF5ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjZGlzcGxheS1hcmVhID4gaDMnKTtcbiAgICAgICAgbGV0IGlkRGlzcGxheSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI2Rpc3BsYXktYXJlYSA+IHNwYW4nKTtcbiAgICAgICAgbGV0IGljb25EaXNwbGF5ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaWNvbi1kaXNwbGF5LWFyZWEnKTtcblxuICAgICAgICBsZXQgcGFydE5hbWUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYocGFydE5hbWUgJiYgcGFydE5hbWUgIT09IFwiXCIpe1xuICAgICAgICAgICAgbmFtZUlucHV0LnZhbHVlID0gcGFydE5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lSW5wdXQudmFsdWUgPSBcIihVbm5hbWVkKVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZURpc3BsYXkudGV4dENvbnRlbnQgPSB0aGlzLm1vZGVsLnR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLm1vZGVsLnR5cGUuc2xpY2UoMSk7XG4gICAgICAgIGlkRGlzcGxheS50ZXh0Q29udGVudCA9IGBpZD0ke3RoaXMubW9kZWwuaWR9YDtcbiAgICAgICAgaWREaXNwbGF5LnRpdGxlID0gdGhpcy5tb2RlbC5pZDtcblxuICAgICAgICBpZihPYmplY3Qua2V5cyhwYXJ0SWNvbnMpLmluY2x1ZGVzKHRoaXMubW9kZWwudHlwZSkpe1xuICAgICAgICAgICAgaWNvbkRpc3BsYXkuaW5uZXJIVE1MID0gcGFydEljb25zW3RoaXMubW9kZWwudHlwZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpY29uRGlzcGxheS5pbm5lckhUTUwgPSBwYXJ0SWNvbnMuZ2VuZXJpYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrRm9yTmF2aWdhdGlvbigpe1xuICAgICAgICAvLyBJZiB0aGUgbW9kZWwgaXMgYSBDYXJkIG9yIFN0YWNrIHRoYXRcbiAgICAgICAgLy8gaXMgbm90IHRoZSBjdXJyZW50IChpZSwgbm90IGJlaW5nIGRpc3BsYXllZFxuICAgICAgICAvLyBpbiB0aGUgbWFpbiB3aW5kb3cpLCB0aGVuIHdlIHNob3VsZCBuYXZpZ2F0ZVxuICAgICAgICAvLyB0byBpdFxuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gd2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2s7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IGN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZDtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICdjYXJkJyAmJiB0aGlzLm1vZGVsLmlkICE9IGN1cnJlbnRDYXJkLmlkKXtcbiAgICAgICAgICAgIGN1cnJlbnRTdGFjay5nb1RvQ2FyZEJ5SWQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ3N0YWNrJyAmJiB0aGlzLm1vZGVsLmlkICE9IGN1cnJlbnRTdGFjay5pZCl7XG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLndvcmxkLmdvVG9TdGFja0J5SWQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgcmVjZWl2ZU1lc3NhZ2UoYU1lc3NhZ2Upe1xuICAgICAgICBzd2l0Y2goYU1lc3NhZ2UudHlwZSl7XG4gICAgICAgIGNhc2UgJ3Byb3BlcnR5Q2hhbmdlZCc6XG4gICAgICAgICAgICAvLyBGaW5kIGFueSBuZXN0ZWQgZWRpdG9yLXByb3AtaXRlbSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gYW5kIHJlLXJlbmRlciwgc28gdGhleSBkaXNwbGF5IHRoZSBjb3JyZWN0XG4gICAgICAgICAgICAvLyB2YWx1ZXMgaW4gdGhlIGVkaXRvclxuICAgICAgICAgICAgbGV0IHF1ZXJ5U3RyaW5nID0gYGVkaXRvci1wcm9wLWl0ZW1bbmFtZT1cIiR7YU1lc3NhZ2UucHJvcGVydHlOYW1lfVwiXVtvd25lci1pZD1cIiR7YU1lc3NhZ2UucGFydElkfVwiXWA7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChxdWVyeVN0cmluZykpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVsLnByb3BlcnR5LnZhbHVlICE9PSBhTWVzc2FnZS52YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblRhYkFjdGl2YXRlZChldmVudCl7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdlZGl0b3ItdGFiJykpXG4gICAgICAgICAgICAuZmlsdGVyKHRhYkVsID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiRWwgIT09IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIH0pLmZvckVhY2godGFiRWwgPT4ge1xuICAgICAgICAgICAgICAgIHRhYkVsLnJlbW92ZUF0dHJpYnV0ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBHZXQgdGhlIG5hbWUgb2YgdGhlIGFjdGl2YXRlZCB0YWJcbiAgICAgICAgbGV0IHRhcmdldE5hbWUgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbdGFiLW5hbWVdJykpLmZvckVhY2gocGFuZSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHBhbmUuZ2V0QXR0cmlidXRlKCd0YWItbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZSA9PSB0YXJnZXROYW1lKXtcbiAgICAgICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ3Nob3ctcGFuZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3ctcGFuZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbk5hbWVJbnB1dENoYW5nZShldmVudCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgbGV0IG5ld05hbWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgbmV3TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRWRpdFNjcmlwdENsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy5tb2RlbCl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuaWRcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBpc09wZW4oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdvcGVuJyk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3IsXG4gICAgRWRpdG9yIGFzIGRlZmF1bHRcbn07XG4iLCJcblxuLy8gUFJFQU1CTEVcblxuY29uc3QgY2FyZXREb3duSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jYXJldC1kb3duXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xOCAxNWwtNiAtNmwtNiA2aDEyXCIgdHJhbnNmb3JtPVwicm90YXRlKDE4MCAxMiAxMilcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjYXJldFJpZ2h0SWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jYXJldC1yaWdodFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTggMTVsLTYgLTZsLTYgNmgxMlwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAxMiAxMilcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC1zaXplOiAwLjhyZW07XG4gICAgfVxuXG4gICAgI3Byb3BzLWxpc3Qge1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgfVxuICAgICNmaWx0ZXItYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cbiAgICAjZmlsdGVyLWFyZWEgPiBpbnB1dCB7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGZvbnQtc2l6ZTogMS4wcmVtO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDZweDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogNnB4O1xuICAgICAgICBwYWRkaW5nLXRvcDogM3B4O1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogM3B4O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuOCk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICB9XG4gICAgXG4gICAgI25ldy1wcm9wLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICAjbmV3LXByb3AtYXJlYS5vcGVuID4gI25ldy1wcm9wLWZvcm0ge1xuICAgICAgICBkaXNwbGF5OmZsZXg7XG4gICAgfVxuXG4gICAgI25ldy1wcm9wLWZvcm0ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICAucm93IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDFlbTtcbiAgICB9XG5cbiAgICBoMyB7XG4gICAgICAgIHBhZGRpbmc6IDBweDtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMWVtO1xuICAgIH1cblxuICAgICNuZXctcHJvcC1mb3JtID4gLnJvdyA+ICoge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDE2cHg7XG4gICAgICAgIHBhZGRpbmctbGVmdDogOHB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XG4gICAgfVxuICAgICNuZXctcHJvcC1mb3JtIGlucHV0IHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuNyk7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIHBhZGRpbmc6IDZweDtcbiAgICB9XG5cbiAgICAjbmV3LXByb3AtbmFtZTppbnZhbGlkIHtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJlZDtcbiAgICB9XG4gICAgXG4gICAgc2VsZWN0IHtcbiAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgfVxuICAgICNhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sIHtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgfVxuXG4gICAgI2FkZC1wcm9wLWRyb3Bkb3duLWNvbnRyb2w6aG92ZXIsXG4gICAgI2FkZC1wcm9wLWRyb3Bkb3duLWNvbnRyb2wgbGFiZWwge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuXG4gICAgI2NhcmV0LWJ1dHRvbiB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDEuNWVtO1xuICAgICAgICBoZWlnaHQ6IDEuNWVtO1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMXMgbGluZWFyO1xuICAgIH1cblxuICAgICNjYXJldC1idXR0b24gPiBzdmcge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbiAgICAjbmV3LXByb3AtYXJlYS5vcGVuICNjYXJldC1idXR0b24ge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGxpbmVhcjtcbiAgICB9XG5cbjwvc3R5bGU+XG48ZGl2IGlkPVwibmV3LXByb3AtYXJlYVwiPlxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIiBpZD1cImFkZC1wcm9wLWRyb3Bkb3duLWNvbnRyb2xcIj5cbiAgICAgICAgPGgzPjxsYWJlbCBmb3I9XCJjYXJldC1idXR0b25cIj5BZGQgTmV3IFByb3BlcnR5PC9sYWJlbD48L2gzPlxuICAgICAgICA8ZGl2IGlkPVwiY2FyZXQtYnV0dG9uXCI+JHtjYXJldFJpZ2h0SWNvbn08L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwibmV3LXByb3AtZm9ybVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwibmV3LXByb3AtbmFtZVwiPlByb3BlcnR5IE5hbWUgPC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwibmV3LXByb3AtbmFtZVwiIHBsYWNlaG9sZGVyPVwicHJvcGVydHktbmFtZVwiIHBhdHRlcm49XCJbYS16XFxcXC1dezMsNjR9XCIvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImRlZmF1bHQtdmFsLXNlbGVjdFwiPkRlZmF1bHQgdmFsdWUgdHlwZTwvbGFiZWw+XG4gICAgICAgICAgICA8c2VsZWN0IGlkPVwiZGVmYXVsdC12YWwtc2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiIHNlbGVjdGVkPk5vbmU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwic3RyaW5nXCI+VGV4dDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJudW1iZXJcIj5OdW1iZXI8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiYm9vbGVhblwiPlRydWUgb3IgRmFsc2U8L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImRlZmF1bHQtdmFsdWVcIj5EZWZhdWx0IHZhbHVlIDwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImRlZmF1bHQtdmFsdWVcIiBwbGFjZWhvbGRlcj1cIkRlZmF1bHQgdmFsdWVcIiBkaXNhYmxlZC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCIgaWQ9XCJzdWJtaXQtY29udHJvbFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInN1Ym1pdC1wcm9wXCI+Q3JlYXRlPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG48ZGl2IGlkPVwiZmlsdGVyLWFyZWFcIj5cbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImZpbHRlci1pbnB1dFwiIG5hbWU9XCJmaWx0ZXItaW5wdXRcIiBwbGFjZWhvbGRlcj1cIkZpbHRlci4uLlwiLz5cbiAgICA8YnV0dG9uIGlkPVwiY2xlYXJcIj5DbGVhcjwvYnV0dG9uPlxuPC9kaXY+XG48dWwgaWQ9XCJwcm9wcy1saXN0XCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC91bD5cbmA7XG5cbmNsYXNzIEVkaXRvckN1c3RvbUxpc3QgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVzZXRGb3JtID0gdGhpcy5yZXNldEZvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkRlZmF1bHROZXdUeXBlQ2hhbmdlID0gdGhpcy5vbkRlZmF1bHROZXdUeXBlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DYXJldENsaWNrID0gdGhpcy5vbkNhcmV0Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNyZWF0ZVN1Ym1pdCA9IHRoaXMub25DcmVhdGVTdWJtaXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkZpbHRlcklucHV0ID0gdGhpcy5vbkZpbHRlcklucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25GaWx0ZXJDbGVhckNsaWNrID0gdGhpcy5vbkZpbHRlckNsZWFyQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcFR5cGVTZWxlY3QgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdkZWZhdWx0LXZhbC1zZWxlY3QnKTtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcE5hbWVJbnB1dCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25ldy1wcm9wLW5hbWUnKTtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZSA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2RlZmF1bHQtdmFsdWUnKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvcENvbnRyb2wgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sJyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BGb3JtID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbmV3LXByb3AtZm9ybScpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdzdWJtaXQtcHJvcCcpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2NsZWFyJyk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcklucHV0ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLWlucHV0Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvcENvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2FyZXRDbGljayk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DcmVhdGVTdWJtaXQpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25GaWx0ZXJJbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkZpbHRlckNsZWFyQ2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IG1haW4gZG9tIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAvLyBDcmVhdGUgYSBzb3J0ZWQgY29weSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gb2JqZWN0c1xuICAgICAgICBsZXQgY3VzdG9tUHJvcHMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2N1c3RvbS1wcm9wZXJ0aWVzJ1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNvcnRlZCBsaXN0IG9mIHRoZSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICAvLyBhdmFpbGFibGVcbiAgICAgICAgdGhpcy5wcm9wTGlzdCA9IE9iamVjdC52YWx1ZXMoY3VzdG9tUHJvcHMpXG4gICAgICAgICAgICAuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdC5uYW1lLmxvY2FsZUNvbXBhcmUoc2Vjb25kLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBwcm9wZXJ0eSBpdGVtcyBhbmQgaW5zZXJ0IHRoZW1cbiAgICAgICAgdGhpcy5wcm9wTGlzdC5mb3JFYWNoKHByb3BPYmplY3QgPT4ge1xuICAgICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLXByb3AtaXRlbScpO1xuICAgICAgICAgICAgZWwuc2V0UHJvcGVydHkocHJvcE9iamVjdCwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBwcm9wT2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCB1cCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5uZXdQcm9wVHlwZVNlbGVjdC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uRGVmYXVsdE5ld1R5cGVDaGFuZ2UpO1xuICAgICAgICB0aGlzLm5ld1Byb3BUeXBlU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25EZWZhdWx0TmV3VHlwZUNoYW5nZSk7XG4gICAgfVxuXG4gICAgb25EZWZhdWx0TmV3VHlwZUNoYW5nZShldmVudCl7XG4gICAgICAgIGxldCBvcHRpb24gPSBldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zWzBdO1xuICAgICAgICBzd2l0Y2gob3B0aW9uLnZhbHVlKXtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBcIlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgndHlwZScsICdudW1iZXInKTtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob3B0aW9uLnZhbHVlID09IFwiXCIpe1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNhcmV0Q2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgbmV3UHJvcEFyZWEgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCduZXctcHJvcC1hcmVhJyk7XG4gICAgICAgIG5ld1Byb3BBcmVhLmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKTtcbiAgICB9XG5cbiAgICBvbkNyZWF0ZVN1Ym1pdChldmVudCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgbGV0IHByb3BOYW1lID0gdGhpcy5uZXdQcm9wTmFtZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmKHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS50eXBlID09ICdjaGVja2JveCcpe1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5jaGVja2VkO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS50eXBlID09ICdudW1iZXInKXtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIHByb3BlcnR5IGNyZWF0ZSBtZXNzYWdlXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICduZXdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5pZFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNyZWF0ZWQgcHJvcCB0byB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gdmFsdWVcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gUmUtcmVuZGVyIHRoaXMgcGFuZVxuICAgICAgICAgICAgdGhpcy5yZXNldEZvcm0oKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHRoaXMubW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlsdGVyQnkodGV4dCl7XG4gICAgICAgIC8vIEZpbmQgYWxsIG9mIHRoZSBwcm9wIGl0ZW0gZWxlbWVudHMgd2hvc2VcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZSBkb2VzICpub3QqIGluY2x1ZGUgdGhlIHN1YnN0cmluZyxcbiAgICAgICAgLy8gYW5kIHNldCB0aG9zZSB0byBub3QgZGlzcGxheVxuICAgICAgICBsZXQgYWxsRWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnZWRpdG9yLXByb3AtaXRlbScpKTtcbiAgICAgICAgYWxsRWxlbWVudHMuZm9yRWFjaChwcm9wRWwgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBwcm9wRWwuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICBpZihuYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGV4dCkpe1xuICAgICAgICAgICAgICAgIHByb3BFbC5jbGFzc0xpc3QucmVtb3ZlKCdpdGVtLWhpZGRlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wRWwuY2xhc3NMaXN0LmFkZCgnaXRlbS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25GaWx0ZXJJbnB1dChldmVudCl7XG4gICAgICAgIHRoaXMuZmlsdGVyQnkoZXZlbnQudGFyZ2V0LnZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIG9uRmlsdGVyQ2xlYXJDbGljayhldmVudCl7XG4gICAgICAgIHRoaXMuZmlsdGVySW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmZpbHRlckJ5KFwiXCIpO1xuICAgIH1cblxuICAgIHJlc2V0Rm9ybSgpe1xuICAgICAgICB0aGlzLm5ld1Byb3BOYW1lSW5wdXQudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudmFsdWUgPSBudWxsO1xuICAgICAgICBpZih0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudHlwZSA9PSAnY2hlY2tlZCcpe1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5uZXdQcm9wVHlwZVNlbGVjdC5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvckN1c3RvbUxpc3QsXG4gICAgRWRpdG9yQ3VzdG9tTGlzdCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IGludGVycHJldGVyU2VtYW50aWNzIGZyb20gJy4uLy4uLy4uL29obS9pbnRlcnByZXRlci1zZW1hbnRpY3MuanMnO1xuaW1wb3J0IHtvbkxvY2F0aW9uTGlua0NsaWNrLCBnZXRMb2NhdGlvblN0cmluZ0Zvcn0gZnJvbSAnLi91dGlscy9zdWJwYXJ0cy5qcyc7XG5cbi8vIFBSRUFNQkxFXG5jb25zdCBhcnJvd0xlZnRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWFycm93LW5hcnJvdy1sZWZ0XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGxpbmUgeDE9XCI1XCIgeTE9XCIxMlwiIHgyPVwiMTlcIiB5Mj1cIjEyXCIgLz5cbiAgPGxpbmUgeDE9XCI1XCIgeTE9XCIxMlwiIHgyPVwiOVwiIHkyPVwiMTZcIiAvPlxuICA8bGluZSB4MT1cIjVcIiB5MT1cIjEyXCIgeDI9XCI5XCIgeTI9XCI4XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY2xpcGJvYXJkSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jbGlwYm9hcmRcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTkgNWgtMmEyIDIgMCAwIDAgLTIgMnYxMmEyIDIgMCAwIDAgMiAyaDEwYTIgMiAwIDAgMCAyIC0ydi0xMmEyIDIgMCAwIDAgLTIgLTJoLTJcIiAvPlxuICA8cmVjdCB4PVwiOVwiIHk9XCIzXCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMlwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0KC5oaWRkZW4pe1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAuYnV0dG9uLWxpbmsge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxNTAsIDE1MCwgMTUwLCAwLjMpO1xuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMC4ycyBlYXNlLW91dDtcbiAgICAgICAgdmVydGljYWwtYWxpZ25tZW50OiBjZW50ZXI7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICBwYWRkaW5nOiAwcHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMWVtO1xuICAgIH1cblxuICAgIC5idXR0b24tbGluazpob3ZlciB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC43KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgLmJ1dHRvbi1saW5rID4gc3ZnIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgb3BhY2l0eTogMC43O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMHB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBlYXNlLW91dDtcbiAgICB9XG5cbiAgICAuYnV0dG9uLWxpbms6aG92ZXIgPiBzdmcge1xuICAgICAgICBvcGFjaXR5OiAxLjA7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNXB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBlYXNlLW91dDtcbiAgICB9XG48L3N0eWxlPlxuPHAgY2xhc3M9XCJwYXJ0LWluZm9cIj5cbiAgICBNeSA8YnV0dG9uIGlkPVwib3duZXItbGlua1wiIGNsYXNzPVwiYnV0dG9uLWxpbmtcIiB0aXRsZT1cIlwiPjxzcGFuPjwvc3Bhbj4ke2Fycm93TGVmdEljb259PC9idXR0b24+IGlzIG5hbWVkIDxzcGFuIGNsYXNzPVwicGFydC1uYW1lXCI+PC9zcGFuPiBhbmQgaXMgbG9jYXRlZCBhdCA8YnV0dG9uIGlkPVwibG9jYXRpb24tbGlua1wiIGNsYXNzPVwiYnV0dG9uLWxpbmtcIiB0aXRsZT1cIkNvcHkgbG9jYXRpb25cIj48c3Bhbj48L3NwYW4+JHtjbGlwYm9hcmRJY29ufTwvYnV0dG9uPiA8YnV0dG9uIGlkPVwiaWQtbGlua1wiIGNsYXNzPVwiYnV0dG9uLWxpbmtcIiB0aXRsZT1cIkNvcHkgaWRcIj48c3Bhbj5Db3B5IGlkPC9zcGFuPiR7Y2xpcGJvYXJkSWNvbn08L2J1dHRvbj5cbjwvcD5cbmA7XG5cbmNsYXNzIEVkaXRvckxvY2F0aW9uSW5mbyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBY2NlcHRlZCB2YWx1ZXMgZm9yIHRoZSBraW5kIGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLmFsbG93ZWRLaW5kcyA9IFsnc3RhY2snLCAnY2FyZCcsICdvd25lciddO1xuXG4gICAgICAgIC8vIGRlZmluZSBhbmQgYmluZCBtZXRob2RzXG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25TdHJpbmdGb3IgPSBnZXRMb2NhdGlvblN0cmluZ0Zvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2sgPSBvbkxvY2F0aW9uTGlua0NsaWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmhhbmRsZVN0YWNrS2luZCA9IHRoaXMuaGFuZGxlU3RhY2tLaW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2FyZEtpbmQgPSB0aGlzLmhhbmRsZUNhcmRLaW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5mbyA9IHRoaXMudXBkYXRlSW5mby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEFuY2VzdG9yT2ZUeXBlRm9yID0gdGhpcy5nZXRBbmNlc3Rvck9mVHlwZUZvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MgPSB0aGlzLmdldExvY2F0aW9uVmlld3MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxpbmtDbGljayA9IHRoaXMub25MaW5rQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRW50ZXIgPSB0aGlzLm9uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VMZWF2ZSA9IHRoaXMub25Nb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgIGxldCBvd25lckxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdvd25lci1saW5rJyk7XG4gICAgICAgIGxldCBsb2NhdGlvbkxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1saW5rJyk7XG4gICAgICAgIGxldCBpZExpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdpZC1saW5rJyk7XG4gICAgICAgIG93bmVyTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25MaW5rQ2xpY2spO1xuICAgICAgICBsb2NhdGlvbkxpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25DbGljayk7XG4gICAgICAgIGlkTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkNsaWNrKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgICAgIGlkTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuICAgICAgICBsb2NhdGlvbkxpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgbGV0IG93bmVyTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ293bmVyLWxpbmsnKTtcbiAgICAgICAgbGV0IGxvY2F0aW9uTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2xvY2F0aW9uLWxpbmsnKTtcbiAgICAgICAgbGV0IGlkTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2lkLWxpbmsnKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uQ2xpY2spO1xuICAgICAgICBpZExpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25DbGljayk7XG4gICAgICAgIG93bmVyTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuICAgICAgICBsb2NhdGlvbkxpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgICAgICBpZExpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcbiAgICAgICAgbGV0IGtpbmQgPSB0aGlzLmdldEF0dHJpYnV0ZSgna2luZCcpO1xuICAgICAgICBpZigha2luZCB8fCAhdGhpcy5hbGxvd2VkS2luZHMuaW5jbHVkZXMoa2luZCkpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ3dvcmxkJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcblxuICAgICAgICAvLyBVcGRhdGUgZWxlbWVudCByZWZlcmVuY2VzXG4gICAgICAgIHRoaXMub3duZXJMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnb3duZXItbGluaycpO1xuICAgICAgICB0aGlzLm93bmVyTGlua1R5cGVTcGFuID0gdGhpcy5vd25lckxpbmtCdXR0b24ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2xvY2F0aW9uLWxpbmsnKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkxpbmtTcGFuID0gdGhpcy5sb2NhdGlvbkxpbmtCdXR0b24ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICB0aGlzLmlkTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2lkLWxpbmsnKTtcbiAgICAgICAgdGhpcy5pZExpbmtTcGFuID0gdGhpcy5pZExpbmtCdXR0b24ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICB0aGlzLm5hbWVTcGFuID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdwIC5wYXJ0LW5hbWUnKTtcblxuICAgICAgICBpZihraW5kID09ICdzdGFjaycpe1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGFja0tpbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmKGtpbmQgPT0nY2FyZCcpe1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDYXJkS2luZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbmZvKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVJbmZvKCl7XG4gICAgICAgIGxldCBraW5kID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2tpbmQnKTtcbiAgICAgICAgbGV0IGFuY2VzdG9yID0gdGhpcy5tb2RlbC5fb3duZXI7XG4gICAgICAgIGlmKGtpbmQgPT0gJ3N0YWNrJyB8fCBraW5kID09ICdjYXJkJyl7XG4gICAgICAgICAgICBhbmNlc3RvciA9IHRoaXMuZ2V0QW5jZXN0b3JPZlR5cGVGb3IodGhpcy5tb2RlbCwga2luZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBjYW5ub3QgZmluZCBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW5cbiAgICAgICAgLy8ga2luZCwgdGhlbiB3ZSBoaWRlIHRoaXMgZmllbGRcbiAgICAgICAgaWYoIWFuY2VzdG9yKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgbmFtZSBzcGFuXG4gICAgICAgIGxldCBhbmNlc3Rvck5hbWUgPSBhbmNlc3Rvci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgYW5jZXN0b3IsXG4gICAgICAgICAgICAnbmFtZSdcbiAgICAgICAgKTtcbiAgICAgICAgaWYoIWFuY2VzdG9yTmFtZSl7XG4gICAgICAgICAgICBhbmNlc3Rvck5hbWUgPSAnKHVubmFtZWQpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2VzdG9yTmFtZSA9IGBcIiR7YW5jZXN0b3JOYW1lfVwiYDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWVTcGFuLnRleHRDb250ZW50ID0gYW5jZXN0b3JOYW1lO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBraW5kIHNwYW5cbiAgICAgICAgbGV0IGtpbmRMYWJlbCA9IGtpbmRbMF0udG9VcHBlckNhc2UoKSArIGtpbmQuc2xpY2UoMSk7XG4gICAgICAgIHRoaXMub3duZXJMaW5rVHlwZVNwYW4udGV4dENvbnRlbnQgPSBraW5kTGFiZWw7XG5cbiAgICAgICAgLy8gVXBkYXRlIGxvY2F0aW9uIGxpbmsgc3BhblxuICAgICAgICB0aGlzLmxvY2F0aW9uTGlua1NwYW4udGV4dENvbnRlbnQgPSB0aGlzLmdldExvY2F0aW9uU3RyaW5nRm9yKGFuY2VzdG9yKTtcblxuICAgICAgICAvLyBVcGRhdGUgYnV0dG9uIHRpdGxlc1xuICAgICAgICBsZXQgZWRpdFRpdGxlID0gYEVkaXQgb3duaW5nICR7a2luZExhYmVsfWA7XG4gICAgICAgIGlmKGtpbmQgPT0gJ293bmVyJyl7XG4gICAgICAgICAgICBlZGl0VGl0bGUgPSAnRWRpdCBPd25lcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vd25lckxpbmtCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgICAgIGVkaXRUaXRsZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgcmVmLWlkIGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncmVmLWlkJywgYW5jZXN0b3IuaWQpO1xuICAgIH1cblxuICAgIGhhbmRsZVN0YWNrS2luZCgpe1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ3N0YWNrJyB8fCB0aGlzLm1vZGVsLnR5cGUgPT0gJ3dvcmxkJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSW5mbygpO1xuICAgIH1cblxuICAgIGhhbmRsZUNhcmRLaW5kKCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnY2FyZCcgfHwgdGhpcy5tb2RlbC50eXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUluZm8oKTtcbiAgICB9XG5cbiAgICBnZXRBbmNlc3Rvck9mVHlwZUZvcihhUGFydCwgYVR5cGUpe1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgY3VycmVudE93bmVyID0gYVBhcnQuX293bmVyO1xuICAgICAgICB3aGlsZShjdXJyZW50T3duZXIpe1xuICAgICAgICAgICAgaWYoY3VycmVudE93bmVyLnR5cGUgPT0gYVR5cGUpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJlbnRPd25lcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRPd25lciA9IGN1cnJlbnRPd25lci5fb3duZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBvbkxpbmtDbGljayhldmVudCl7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWYtaWQnKTtcbiAgICAgICAgaWYoaWQgJiYgdGhpcy5tb2RlbCl7XG4gICAgICAgICAgICAvLyBSZS1yZW5kZXIgdGhlIGVkaXRvciBvbiB0aGUgUGFydFxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlZCBieSB0aGUgZm91bmQgaWRcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtpZF07XG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmVkaXRvci5yZW5kZXIodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91c2VFbnRlcihldmVudCl7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyhldmVudCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy5oaWdobGlnaHQoXCJyZ2IoNTQsIDE3MiwgMTAwKVwiKTsgLy8gZ3JlZW5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25Nb3VzZUxlYXZlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzKGV2ZW50KS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LnVuaGlnaGxpZ2h0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldExvY2F0aW9uVmlld3MoZXZlbnQpe1xuICAgICAgICBsZXQgdGFyZ2V0SWQ7XG4gICAgICAgIGxldCBzcGFuID0gZXZlbnQuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIGlmKHNwYW4ucGFyZW50RWxlbWVudC5pZCA9PSAnaWQtbGluaycpe1xuICAgICAgICAgICAgdGFyZ2V0SWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmLWlkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2VtYW50aWNzID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLmNyZWF0ZVNlbWFudGljcygpO1xuICAgICAgICAgICAgc2VtYW50aWNzLmFkZE9wZXJhdGlvbihcbiAgICAgICAgICAgICAgICAnaW50ZXJwcmV0JyxcbiAgICAgICAgICAgICAgICBpbnRlcnByZXRlclNlbWFudGljcyh3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFsnd29ybGQnXSwgd2luZG93LlN5c3RlbSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgbSA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5tYXRjaChzcGFuLnRleHRDb250ZW50LCBcIk9iamVjdFNwZWNpZmllclwiKTtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IHNlbWFudGljcyhtKS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGNhbm5vdCBsb2NhdGUgJHtzcGFuLnRleHRDb250ZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGFyZ2V0SWQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yTG9jYXRpb25JbmZvLFxuICAgIEVkaXRvckxvY2F0aW9uSW5mbyBhcyBkZWZhdWx0XG59O1xuIiwiXG5cbi8vIFBSRUFNQkxFXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC1zaXplOiAwLjhyZW07XG4gICAgfVxuICAgXG4gICAgdGV4dGFyZWEge1xuICAgICAgICByZXNpemU6IG5vbmU7XG4gICAgICAgIGZsZXg6IDAuMjU7XG4gICAgfVxuPC9zdHlsZT5cbjxoMz5TZW5kIHRoaXMgPHNwYW4+PC9zcGFuPiBhIE1lc3NhZ2U6PC9oMz5cbjx0ZXh0YXJlYSBwbGFjZWhvbGRlcj1cIlR5cGUgeW91ciBTaW1wbGV0YWxrIG1lc3NhZ2UgaGVyZS4uLlwiPjwvdGV4dGFyZWE+XG48YnV0dG9uPlNlbmQ8L2J1dHRvbj5cbmA7XG5cbmNsYXNzIEVkaXRvck1lc3NlbmdlciBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VGaWVsZElucHV0ID0gdGhpcy5vbk1lc3NhZ2VGaWVsZElucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VGcm9tVGV4dCA9IHRoaXMuc2VuZE1lc3NhZ2VGcm9tVGV4dC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc2VuZE1lc3NhZ2VGcm9tVGV4dCk7XG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlRmllbGQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25NZXNzYWdlRmllbGRJbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLm1lc3NhZ2VGaWVsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25NZXNzYWdlRmllbGRJbnB1dCk7XG4gICAgICAgIHRoaXMuc2VuZEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc2VuZE1lc3NhZ2VGcm9tVGV4dCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIFxuICAgICAgICBsZXQgcGFydFR5cGVMYWJlbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignaDMgPiBzcGFuJyk7XG4gICAgICAgIHBhcnRUeXBlTGFiZWwudGV4dENvbnRlbnQgPSB0aGlzLm1vZGVsLnR5cGU7XG4gICAgfVxuXG4gICAgb25NZXNzYWdlRmllbGRJbnB1dChldmVudCl7XG5cbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZUZyb21UZXh0KCl7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5tZXNzYWdlRmllbGQudmFsdWU7XG4gICAgICAgIGxldCBzY3JpcHQgPSBgb24gZG9JdFxcblxcdCR7dGV4dH1cXG5lbmQgZG9JdGA7XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbXBpbGUnLFxuICAgICAgICAgICAgY29kZVN0cmluZzogc2NyaXB0LFxuICAgICAgICAgICAgdGFyZ2V0SWQ6IHRoaXMubW9kZWwuaWRcbiAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdkb0l0JyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yTWVzc2VuZ2VyLFxuICAgIEVkaXRvck1lc3NlbmdlciBhcyBkZWZhdWx0XG59O1xuIiwiLy8gUFJFQU1CTEVcblxuY29uc3QgY2hlY2tJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNpcmNsZS1jaGVja1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDBiMzQxXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiOVwiIC8+XG4gIDxwYXRoIGQ9XCJNOSAxMmwyIDJsNCAtNFwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGNhbmNlbEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2lyY2xlLXhcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiI2ZmMjgyNVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjlcIiAvPlxuICA8cGF0aCBkPVwiTTEwIDEwbDQgNG0wIC00bC00IDRcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICBsaSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgcGFkZGluZzogNnB4O1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDhweDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogOHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiA2cHg7XG4gICAgfVxuICAgXG4gICAgbGkgPiBsYWJlbCB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgfVxuXG4gICAgOmhvc3Qge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICA6aG9zdCguaXRlbS1oaWRkZW4pIHtcbiAgICAgICAgZGlzcGxheTpub25lO1xuICAgIH1cblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgb3BhY2l0eTogMS4wO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgbGluZWFyO1xuICAgIH1cblxuICAgIGJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgICAgIG9wYWNpdHk6IDAuMDU7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHk6IDAuMXMgbGluZWFyO1xuICAgIH1cblxuICAgIGJ1dHRvbjpob3ZlciB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5cbiAgICBidXR0b24uYnV0dG9uLWhpZGRlbiB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgbGFiZWwge1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIH1cblxuICAgIGlucHV0IHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuNSk7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgfVxuICAgIFxuICAgIGlucHV0OmZvY3VzIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjgpO1xuICAgIH1cbjwvc3R5bGU+XG48bGk+XG4gICAgPGxhYmVsIGZvcj1cInByb3AtdmFsdWVcIj48L2xhYmVsPlxuICAgIDxpbnB1dCBpZD1cInByb3AtdmFsdWVcIiBuYW1lPVwicHJvcC12YWx1ZVwiLz5cbiAgICA8YnV0dG9uIGlkPVwiYWNjZXB0XCIgZGlzYWJsZWQ+JHtjaGVja0ljb259PC9idXR0b24+XG4gICAgPGJ1dHRvbiBpZD1cImNhbmNlbFwiIGRpc2FibGVkPiR7Y2FuY2VsSWNvbn08L2J1dHRvbj5cbjwvbGk+XG5gO1xuXG5jbGFzcyBFZGl0b3JQcm9wSXRlbSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGVyZSBpcyBubyBwcm9wZXJ0eVxuICAgICAgICB0aGlzLnByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vd25lciA9IG51bGw7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25JbnB1dENoYW5nZSA9IHRoaXMub25JbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSW5wdXRJbnB1dCA9IHRoaXMub25JbnB1dElucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25BY2NlcHRDbGljayA9IHRoaXMub25BY2NlcHRDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2FuY2VsQ2xpY2sgPSB0aGlzLm9uQ2FuY2VsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkVudGVyS2V5ID0gdGhpcy5vbkVudGVyS2V5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBOdW1lcmljSW5wdXQgPSB0aGlzLnNldHVwTnVtZXJpY0lucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5hYmxlQnV0dG9ucyA9IHRoaXMuZW5hYmxlQnV0dG9ucy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpc2FibGVCdXR0b25zID0gdGhpcy5kaXNhYmxlQnV0dG9ucy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHNldFByb3BlcnR5KGFQcm9wZXJ0eSwgYW5Pd25lcil7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gYVByb3BlcnR5O1xuICAgICAgICB0aGlzLm93bmVyID0gYW5Pd25lcjtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVsZW1lbnQgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsIHRoaXMucHJvcGVydHkubmFtZSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdvd25lci1pZCcsIHRoaXMub3duZXIuaWQpO1xuXG4gICAgICAgIC8vIEFkZCBuZXcgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5vbkVudGVyS2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLm9uRW50ZXJLZXkpO1xuICAgIH1cblxuICAgIHJlbmRlcigpe1xuICAgICAgICB0aGlzLmxhYmVsRWxlbWVudCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignbGFiZWwnKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYWNjZXB0Jyk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnY2FuY2VsJyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFueSBoaWRlIGNsYXNzZXNcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYnV0dG9uLWhpZGRlbicpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdidXR0b24taGlkZGVuJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYW55IGJvdW5kIGV2ZW50c1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25JbnB1dElucHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbklucHV0Q2hhbmdlKTtcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQWNjZXB0Q2xpY2spO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DYW5jZWxDbGljayk7XG5cbiAgICAgICAgLy8gQWRkIG5ldyBldmVudHNcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXRJbnB1dCk7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25JbnB1dENoYW5nZSk7XG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkFjY2VwdENsaWNrKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2FuY2VsQ2xpY2spO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5sYWJlbEVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aGlzLnByb3BlcnR5Lm5hbWV9OmA7XG4gICAgICAgIGxldCBjdXJyZW50VmFsID0gdGhpcy5wcm9wZXJ0eS5nZXRWYWx1ZSh0aGlzLm93bmVyKTtcbiAgICAgICAgaWYoY3VycmVudFZhbCA9PSBudWxsIHx8IGN1cnJlbnRWYWwgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIC8vIERvIHNvbWV0aGluZyBkaWZmZXJlbnQgaGVyZVxuICAgICAgICB9IGVsc2UgaWYodHlwZW9mKGN1cnJlbnRWYWwpID09ICdudW1iZXInKXtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBOdW1lcmljSW5wdXQoKTtcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihjdXJyZW50VmFsKSA9PSAnYm9vbGVhbicpe1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5jaGVja2VkID0gY3VycmVudFZhbDtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J1dHRvbi1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J1dHRvbi1oaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgY3VycmVudFZhbCk7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlID0gY3VycmVudFZhbDtcbiAgICB9XG5cbiAgICBzZXR1cE51bWVyaWNJbnB1dCgpe1xuICAgICAgICBpZih0aGlzLnByb3BlcnR5Lm5hbWUuZW5kc1dpdGgoJy10cmFuc3BhcmVuY3knKSl7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAncmFuZ2UnKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3RlcCcsICcwLjA1Jyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21pbicsICcwLjAnKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWF4JywgJzEuMCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ251bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25JbnB1dENoYW5nZShldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC50eXBlID09IFwiY2hlY2tib3hcIil7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5Lm5hbWUsXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbklucHV0SW5wdXQoZXZlbnQpe1xuICAgICAgICBsZXQgaW5wdXRUeXBlID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICBpZihpbnB1dFR5cGUgPT0gJ3JhbmdlJyl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbkFjY2VwdENsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0LnZhbHVlICE9PSB0aGlzLnByb3BlcnR5LmdldFZhbHVlKHRoaXMub3duZXIpKXtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQnV0dG9ucygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25FbnRlcktleShldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmtleSA9PSAnRW50ZXInKXtcbiAgICAgICAgICAgIHRoaXMub25BY2NlcHRDbGljaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5hYmxlQnV0dG9ucygpe1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICBkaXNhYmxlQnV0dG9ucygpe1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICB9XG5cbiAgICBvbkFjY2VwdENsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5pbnB1dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmKHRoaXMuaW5wdXRFbGVtZW50LnR5cGUgPT0gJ251bWJlcicpe1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGlzTmFOKHZhbHVlKSl7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgcGFyc2UgdGhlIHZhbHVlIGp1c3QgbGV0IGl0IGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCBtaWdodCBiZSBhIHByb3Agc3R5bGUga2V5d29yZCBzdWNoIGFzIFwiZmlsbFwiXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2UgbWlnaHQgd2FudCB0byBsaW1pdCB0aGlzIHRvIGEgc2V0IG9mIHByb3Aga2V5d29yZHNcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYodGhpcy5pbnB1dEVsZW1lbnQudHlwZSA9PSAncmFuZ2UnKXtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmlucHV0RWxlbWVudC50eXBlID09ICdjaGVja2JveCcpe1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmlucHV0RWxlbWVudC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMub3duZXIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5Lm5hbWUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc2FibGVCdXR0b25zKCk7XG4gICAgfVxuXG4gICAgb25DYW5jZWxDbGljayhldmVudCl7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlID0gdGhpcy5vd25lci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5vd25lcixcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkubmFtZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc2FibGVCdXR0b25zKCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JQcm9wSXRlbSxcbiAgICBFZGl0b3JQcm9wSXRlbSBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IEVkaXRvclByb3BJdGVtIGZyb20gJy4vRWRpdG9yUHJvcEl0ZW0uanMnO1xuXG4vLyBQUkVBTUJMRVxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLXByb3AtaXRlbScsIEVkaXRvclByb3BJdGVtKTtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cblxuICAgICNwcm9wcy1saXN0IHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIH1cbiAgICAjZmlsdGVyLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG4gICAgI2ZpbHRlci1hcmVhID4gaW5wdXQge1xuICAgICAgICBtaW4td2lkdGg6IDA7XG4gICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBmb250LXNpemU6IDEuMHJlbTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA2cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDZweDtcbiAgICAgICAgcGFkZGluZy10b3A6IDNweDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDNweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjgpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJmaWx0ZXItYXJlYVwiPlxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiZmlsdGVyLWlucHV0XCIgbmFtZT1cImZpbHRlci1pbnB1dFwiIHBsYWNlaG9sZGVyPVwiRmlsdGVyLi4uXCIvPlxuICAgIDxidXR0b24gaWQ9XCJjbGVhclwiPkNsZWFyPC9idXR0b24+XG48L2Rpdj5cbjx1bCBpZD1cInByb3BzLWxpc3RcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L3VsPlxuYDtcblxuY29uc3Qgc3BlY2lhbFByb3BzID0gW1xuICAgICdjc3NTdHlsZScsXG4gICAgJ2Nzc1RleHRTdHlsZScsXG4gICAgJ2lkJyxcbiAgICAnbmFtZScsXG4gICAgJ3RhcmdldCcsXG4gICAgJ2V2ZW50cycsXG4gICAgJ2N1cnJlbnQnLFxuICAgICdzY3JpcHQnLFxuICAgICdjdXN0b20tcHJvcGVydGllcydcbl07XG5cbmNsYXNzIEVkaXRvclByb3BMaXN0IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSW5wdXQgPSB0aGlzLm9uSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkZpbHRlckNsZWFyQ2xpY2sgPSB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnB1dEVsZW1lbnQgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXItaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjbGVhcicpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25GaWx0ZXJDbGVhckNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuXG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBtYWluIERPTSBjaGlsZHJlblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIGxldCBpbnB1dEVsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLWlucHV0Jyk7XG4gICAgICAgIGlucHV0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXQpO1xuICAgICAgICBpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0KTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBzb3J0ZWQgY29weSBvZiB0aGUgcHJvcGVydHkgb2JqZWN0c1xuICAgICAgICB0aGlzLnByb3BMaXN0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5hbGwuc2xpY2UoKS5maWx0ZXIocHJvcCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzcGVjaWFsUHJvcHMuaW5jbHVkZXMocHJvcC5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BMaXN0XG4gICAgICAgICAgICAuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Lm5hbWUubG9jYWxlQ29tcGFyZShzZWNvbmQubmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgbGlzdCBpdGVtIGVsZW1lbnRzIGFuZCBpbnNlcnQgdGhlbVxuICAgICAgICB0aGlzLnByb3BMaXN0LmZvckVhY2gocHJvcE9iamVjdCA9PiB7XG4gICAgICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItcHJvcC1pdGVtJyk7XG4gICAgICAgICAgICBlbC5zZXRQcm9wZXJ0eShwcm9wT2JqZWN0LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbmFtZScsIHByb3BPYmplY3QubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsdGVyQnkodGV4dCl7XG4gICAgICAgIC8vIEZpbmQgYWxsIG9mIHRoZSBwcm9wIGl0ZW0gZWxlbWVudHMgd2hvc2VcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZSBkb2VzICpub3QqIGluY2x1ZGUgdGhlIHN1YnN0cmluZyxcbiAgICAgICAgLy8gYW5kIHNldCB0aG9zZSB0byBub3QgZGlzcGxheVxuICAgICAgICBsZXQgYWxsRWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnZWRpdG9yLXByb3AtaXRlbScpKTtcbiAgICAgICAgYWxsRWxlbWVudHMuZm9yRWFjaChwcm9wRWwgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBwcm9wRWwuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICBpZihuYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGV4dCkpe1xuICAgICAgICAgICAgICAgIHByb3BFbC5jbGFzc0xpc3QucmVtb3ZlKCdpdGVtLWhpZGRlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wRWwuY2xhc3NMaXN0LmFkZCgnaXRlbS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25JbnB1dChldmVudCl7XG4gICAgICAgIHRoaXMuZmlsdGVyQnkoZXZlbnQudGFyZ2V0LnZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIG9uRmlsdGVyQ2xlYXJDbGljayhldmVudCl7XG4gICAgICAgIHRoaXMuZmlsdGVySW5wdXRFbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5maWx0ZXJCeShcIlwiKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvclByb3BMaXN0LFxuICAgIEVkaXRvclByb3BMaXN0IGFzIGRlZmF1bHRcbn07XG4iLCIvLyBQUkVBTUJMRVxuaW1wb3J0IEVkaXRvckxvY2F0aW9uSW5mbyBmcm9tICcuL0VkaXRvckxvY2F0aW9uSW5mby5qcyc7XG5pbXBvcnQgcGFydEljb25zIGZyb20gJy4uLy4uL3V0aWxzL2ljb25zLmpzJztcbmltcG9ydCB7b25Mb2NhdGlvbkxpbmtDbGljaywgZ2V0TG9jYXRpb25TdHJpbmdGb3J9IGZyb20gJy4vdXRpbHMvc3VicGFydHMuanMnO1xuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3ItbG9jYXRpb24taW5mbycsIEVkaXRvckxvY2F0aW9uSW5mbyk7XG5cbmNvbnN0IGNsaXBib2FyZEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2xpcGJvYXJkXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk05IDVoLTJhMiAyIDAgMCAwIC0yIDJ2MTJhMiAyIDAgMCAwIDIgMmgxMGEyIDIgMCAwIDAgMiAtMnYtMTJhMiAyIDAgMCAwIC0yIC0yaC0yXCIgLz5cbiAgPHJlY3QgeD1cIjlcIiB5PVwiM1wiIHdpZHRoPVwiNlwiIGhlaWdodD1cIjRcIiByeD1cIjJcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC1zaXplOiAwLjhyZW07XG4gICAgfVxuXG4gICAgOmhvc3QoKSA+IGxpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xuICAgIH1cblxuICAgIC5pZC1saW5rLFxuICAgIC5sb2NhdGlvbi1saW5rIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC4zKTtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgZWFzZS1vdXQ7XG4gICAgICAgIHZlcnRpY2FsLWFsaWdubWVudDogY2VudGVyO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgcGFkZGluZzogMHB4O1xuICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICB9XG5cbiAgICAuaWQtbGluazpob3ZlcixcbiAgICAubG9jYXRpb24tbGluazpob3ZlciB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC43KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgLmlkLWxpbmsgPiBzdmcsXG4gICAgLmxvY2F0aW9uLWxpbmsgPiBzdmcge1xuICAgICAgICBtYXJnaW4tbGVmdDogOHB4O1xuICAgICAgICBvcGFjaXR5OiAwLjc7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwcHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIC5pZC1saW5rOmhvdmVyID4gc3ZnLFxuICAgIC5sb2NhdGlvbi1saW5rOmhvdmVyID4gc3ZnIHtcbiAgICAgICAgb3BhY2l0eTogMS4wO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTVweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgc2VjdGlvbiB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIG1hcmdpbjogNnB4O1xuICAgIH1cblxuICAgICNidXR0b24tYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOydcbiAgICB9XG5cbiAgICAjc3VicGFydHMtbGlzdC13cmFwcGVyIHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIH1cblxuICAgIC5oaWRkZW4ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgICNzdWJwYXJ0cy1hcmVhIHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAzMnB4O1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIH1cbjwvc3R5bGU+XG48c2VjdGlvbiBpZD1cImJ1dHRvbi1hcmVhXCI+XG4gICAgPHNsb3QgbmFtZT1cImJ1dHRvblwiPjwvc2xvdD5cbjwvc2VjdGlvbj5cbjxzZWN0aW9uIGlkPVwibG9jYXRpb24tYXJlYVwiPlxuICAgIDxoMz5QYXJ0IExvY2F0aW9uIGFuZCBPd25lcnM8L2gzPlxuICAgIDxwIGNsYXNzPVwicGFydC1pbmZvXCI+XG4gICAgICAgIEkgYW0gbG9jYXRlZCBhdCA8YnV0dG9uIGNsYXNzPVwibG9jYXRpb24tbGlua1wiPjxzcGFuPjwvc3Bhbj4ke2NsaXBib2FyZEljb259PC9idXR0b24+XG4gICAgICAgIGFuZCBteSBpZCBpcyA8YnV0dG9uIGNsYXNzPVwiaWQtbGlua1wiPjxzcGFuPjwvc3Bhbj4ke2NsaXBib2FyZEljb259PC9idXR0b24+XG4gICAgPC9wPlxuICAgIDxzbG90IG5hbWU9XCJhbmNlc3Rvci1pbmZvXCI+PC9zbG90PlxuPC9zZWN0aW9uPlxuPHNlY3Rpb24gaWQ9XCJzdWJwYXJ0cy1saXN0LXdyYXBwZXJcIj5cbiAgICA8aDM+U3VicGFydHM8L2gzPlxuICAgIDxvbCBpZD1cInN1YnBhcnRzLWFyZWFcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvb2w+XG48L3NlY3Rpb24+XG5gO1xuXG5jbGFzcyBFZGl0b3JTdWJwYXJ0c1BhbmUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZGVmaW5lIGFuZCBiaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblN0cmluZ0ZvciA9IGdldExvY2F0aW9uU3RyaW5nRm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayA9IG9uTG9jYXRpb25MaW5rQ2xpY2suYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMub25BZGRTdWJwYXJ0ID0gdGhpcy5vbkFkZFN1YnBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN1YnBhcnRJdGVtQ2xpY2sgPSB0aGlzLm9uU3VicGFydEl0ZW1DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU3VicGFydEl0ZW1Nb3VzZUVudGVyID0gdGhpcy5vblN1YnBhcnRJdGVtTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU3VicGFydEl0ZW1Nb3VzZUxlYXZlID0gdGhpcy5vblN1YnBhcnRJdGVtTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUFkZFBhcnRCdXR0b24gPSB0aGlzLmNyZWF0ZUFkZFBhcnRCdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTdWJwYXJ0Q29tcG9uZW50ID0gdGhpcy5jcmVhdGVTdWJwYXJ0Q29tcG9uZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyA9IHRoaXMuZ2V0TG9jYXRpb25WaWV3cy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2xvY2F0aW9uLWFyZWEnKTtcbiAgICAgICAgICAgIHRoaXMubXlMb2NhdGlvbkFyZWEgPSB0aGlzLmhlYWRlckVsLnF1ZXJ5U2VsZWN0b3IoJ3AnKTtcbiAgICAgICAgICAgIHRoaXMubXlMb2NhdGlvbkJ1dHRvbiA9IHRoaXMubXlMb2NhdGlvbkFyZWEucXVlcnlTZWxlY3RvcignLmxvY2F0aW9uLWxpbmsnKTtcbiAgICAgICAgICAgIHRoaXMubXlJZEJ1dHRvbiA9IHRoaXMubXlMb2NhdGlvbkFyZWEucXVlcnlTZWxlY3RvcignLmlkLWxpbmsnKTtcblxuICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyIHRvIGJ1dHRvbnNcbiAgICAgICAgICAgIHRoaXMubXlMb2NhdGlvbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayk7XG4gICAgICAgICAgICB0aGlzLm15SWRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5teUxvY2F0aW9uQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrKTtcbiAgICAgICAgdGhpcy5teUlkQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrKTtcbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcbiAgICAgICAgdGhpcy5oZWFkZXJFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2xvY2F0aW9uLWFyZWEnKTtcblxuICAgICAgICAvLyBDbGVhciBhbnkgRE9NIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcblxuXG4gICAgICAgIC8vIENyZWF0ZSBsb2NhdGlvbiBsaW5rIGVsZW1lbnRzXG4gICAgICAgIC8vIGFuZCBhbHNvIHRoZSBzZWxmLWxvY2F0aW9uIGVsZW1lbnRcbiAgICAgICAgbGV0IG15TG9jYXRpb25UZXh0ID0gdGhpcy5nZXRMb2NhdGlvblN0cmluZ0Zvcih0aGlzLm1vZGVsKTtcbiAgICAgICAgdGhpcy5teUxvY2F0aW9uQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS50ZXh0Q29udGVudCA9IG15TG9jYXRpb25UZXh0O1xuICAgICAgICB0aGlzLm15SWRCdXR0b24ucXVlcnlTZWxlY3Rvcignc3BhbicpLnRleHRDb250ZW50ID0gdGhpcy5tb2RlbC5pZC50b1N0cmluZygpO1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ3dvcmxkJyl7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbmZvIGVsZW1lbnRzXG4gICAgICAgICAgICBbJ3N0YWNrJywgJ2NhcmQnLCAnb3duZXInXS5mb3JFYWNoKGtpbmQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbmZvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItbG9jYXRpb24taW5mbycpO1xuICAgICAgICAgICAgICAgIGluZm9FbC5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnYW5jZXN0b3ItaW5mbycpO1xuICAgICAgICAgICAgICAgIGluZm9FbC5zZXRBdHRyaWJ1dGUoJ2tpbmQnLCBraW5kKTtcbiAgICAgICAgICAgICAgICBpbmZvRWwucmVuZGVyKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaW5mb0VsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBcImFkZCBzdWJwYXJ0XCIgYnV0dG9ucyBmb3IgcGFydHMgdGhhdCBhcmUgYWNjZXB0ZWQgYnkgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgTW9kZWwgcGFydC5cbiAgICAgICAgdGhpcy5tb2RlbC5hY2NlcHRlZFN1YnBhcnRUeXBlcy5mb3JFYWNoKHBhcnRUeXBlID0+IHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5jcmVhdGVBZGRQYXJ0QnV0dG9uKHBhcnRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBsYWJlbEhlYWRlciA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI3N1YnBhcnRzLWxpc3Qtd3JhcHBlciA+IGgzJyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwuc3VicGFydHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGxhYmVsSGVhZGVyLnRleHRDb250ZW50ID0gXCJDdXJyZW50IFN1YnBhcnRzXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJlbEhlYWRlci50ZXh0Q29udGVudCA9IFwiVGhlcmUgYXJlIG5vIHN1YnBhcnRzXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsLnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuY3JlYXRlU3VicGFydENvbXBvbmVudChzdWJwYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNyZWF0ZVN1YnBhcnRDb21wb25lbnQoYVBhcnQpe1xuICAgICAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnc3VicGFydC1pdGVtJyk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKCdyZWYtaWQnLCBhUGFydC5pZCk7XG4gICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uU3VicGFydEl0ZW1DbGljayk7XG4gICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlRW50ZXIpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uU3VicGFydEl0ZW1Nb3VzZUxlYXZlKTtcblxuICAgICAgICAvLyBBZGQgaWNvbiBhcmVhIGFuIFNWRyBmb3IgUGFydFxuICAgICAgICBsZXQgaWNvbkFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaWNvbkFyZWEuY2xhc3NMaXN0LmFkZCgnaWNvbi1kaXNwbGF5LWFyZWEnKTtcbiAgICAgICAgbGV0IGljb25JbWFnZTtcbiAgICAgICAgaWYoT2JqZWN0LmtleXMocGFydEljb25zKS5pbmNsdWRlcyhhUGFydC50eXBlKSl7XG4gICAgICAgICAgICBpY29uSW1hZ2UgPSBwYXJ0SWNvbnNbYVBhcnQudHlwZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpY29uSW1hZ2UgPSBwYXJ0SWNvbnMuZ2VuZXJpYztcbiAgICAgICAgfVxuICAgICAgICBpY29uQXJlYS5pbm5lckhUTUwgPSBpY29uSW1hZ2U7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKGljb25BcmVhKTtcblxuICAgICAgICAvLyBBZGQgbGFiZWwsIG5hbWUsIGFuZCBpZCBpbmZvXG4gICAgICAgIGxldCBsYWJlbEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgICAgICBsYWJlbEFyZWEudGV4dENvbnRlbnQgPSBgYSAke2FQYXJ0LnR5cGVbMF0udG9VcHBlckNhc2UoKX0ke2FQYXJ0LnR5cGUuc2xpY2UoMSl9YDtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQobGFiZWxBcmVhKTtcbiAgICAgICAgbGV0IG5hbWUgPSBhUGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgYVBhcnQsXG4gICAgICAgICAgICAnbmFtZSdcbiAgICAgICAgKTtcbiAgICAgICAgaWYobmFtZSAmJiBuYW1lICE9IFwiXCIpe1xuICAgICAgICAgICAgbGV0IG5hbWVBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgbmFtZUFyZWEuY2xhc3NMaXN0LmFkZCgnbmFtZS1zcGFuJyk7XG4gICAgICAgICAgICBuYW1lQXJlYS50ZXh0Q29udGVudCA9IGBcIiR7bmFtZX1cImA7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZChuYW1lQXJlYSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaWRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBpZEFyZWEuY2xhc3NMaXN0LmFkZCgnaWQtc3BhbicpO1xuICAgICAgICBpZEFyZWEudGV4dENvbnRlbnQgPSBgKCR7YVBhcnQuaWR9KWA7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKGlkQXJlYSk7XG5cbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgY3JlYXRlQWRkUGFydEJ1dHRvbihhUGFydE5hbWUpe1xuICAgICAgICBsZXQgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGxldCBpY29uID0gcGFydEljb25zW2FQYXJ0TmFtZV07XG4gICAgICAgIGlmKCFpY29uKXtcbiAgICAgICAgICAgIGljb24gPSBwYXJ0SWNvbnMuZ2VuZXJpYztcbiAgICAgICAgfVxuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnLCBhUGFydE5hbWUpO1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsIGBBZGQgYSAke2FQYXJ0TmFtZX0gdG8gdGhpcyAke3RoaXMubW9kZWwudHlwZX1gKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2FkZC1wYXJ0LWJ1dHRvbicpO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQWRkU3VicGFydCk7XG4gICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBpY29uO1xuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cblxuICAgIG9uU3VicGFydEl0ZW1DbGljayhldmVudCl7XG4gICAgICAgIGxldCBpZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdyZWYtaWQnKTtcbiAgICAgICAgbGV0IHRhcmdldFBhcnQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtpZF07XG4gICAgICAgIGlmKHRhcmdldFBhcnQpe1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5lZGl0b3IucmVuZGVyKHRhcmdldFBhcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25TdWJwYXJ0SXRlbU1vdXNlRW50ZXIoZXZlbnQpe1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MoZXZlbnQpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0KFwicmdiKDU0LCAxNzIsIDEwMClcIik7IC8vIGdyZWVuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uU3VicGFydEl0ZW1Nb3VzZUxlYXZlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzKGV2ZW50KS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LnVuaGlnaGxpZ2h0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uQWRkU3VicGFydChldmVudCl7XG4gICAgICAgIGxldCB0eXBlID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpO1xuICAgICAgICBpZih0eXBlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ25ld01vZGVsJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuaWRcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBnZXRMb2NhdGlvblZpZXdzKGV2ZW50KXtcbiAgICAgICAgbGV0IHRhcmdldElkID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlZi1pZCcpO1xuICAgICAgICBsZXQgc3BhbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5maW5kVmlld3NCeUlkKHRhcmdldElkKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvclN1YnBhcnRzUGFuZSxcbiAgICBFZGl0b3JTdWJwYXJ0c1BhbmUgYXMgZGVmYXVsdFxufTtcbiIsIi8vIFBSRUFNQkxFXG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHBhZGRpbmc6IDZweDtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjcpO1xuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMC4ycyBsaW5lYXIsIG9wYWNpdHkgMC4ycyBsaW5lYXI7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIH1cblxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKXtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYmEoMjAwLCAwLCAwLCAwLjkpO1xuICAgICAgICBvcGFjaXR5OiAxLjA7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGxpbmVhciwgb3BhY2l0eSAwLjJzIGxpbmVhcjtcbiAgICB9XG5cbiAgICA6aG9zdCg6aG92ZXIpe1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cbjxzcGFuIGlkPVwibGFiZWxcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L3NwYW4+XG5gO1xuXG5jbGFzcyBFZGl0b3JUYWIgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdGFiIGlzIGN1cnJlbnRseSBhY3RpdmF0ZWQsIGVtaXRcbiAgICAgICAgICAgIC8vIHRoZSB0YWItYWN0aXZhZWQgbWVzc2FnZVxuICAgICAgICAgICAgaWYodGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpID09IFwidHJ1ZVwiKXtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJ0YWItYWN0aXZhdGVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IGlzQWN0aXZlID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKSA9PSBcInRydWVcIik7XG4gICAgICAgIGlmKCFpc0FjdGl2ZSl7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ3RydWUnKTtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcInRhYi1hY3RpdmF0ZWRcIiwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yVGFiLFxuICAgIEVkaXRvclRhYiBhcyBkZWZhdWx0XG59O1xuIiwiIGNvbnN0IGdldExvY2F0aW9uU3RyaW5nRm9yID0gKGFQYXJ0KSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBsZXQgY3VycmVudFBhcnQgPSBhUGFydDtcbiAgICAgICAgbGV0IGN1cnJlbnRPd25lciA9IGFQYXJ0Ll9vd25lcjtcbiAgICAgICAgd2hpbGUoY3VycmVudE93bmVyKXtcbiAgICAgICAgICAgIGxldCBpbmRleEluUGFyZW50ID0gY3VycmVudE93bmVyLnN1YnBhcnRzLmZpbHRlcigoc3VicGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gY3VycmVudFBhcnQudHlwZTtcbiAgICAgICAgICAgIH0pLmluZGV4T2YoY3VycmVudFBhcnQpICsgMTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgJHtjdXJyZW50UGFydC50eXBlfSAke2luZGV4SW5QYXJlbnR9IG9mIGA7XG4gICAgICAgICAgICBjdXJyZW50UGFydCA9IGN1cnJlbnRQYXJ0Ll9vd25lcjtcbiAgICAgICAgICAgIGN1cnJlbnRPd25lciA9IGN1cnJlbnRPd25lci5fb3duZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICd0aGlzIHdvcmxkJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5jb25zdCBvbkxvY2F0aW9uTGlua0NsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCB0ZXh0ID0gZXZlbnQuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKCdzcGFuJykudGV4dENvbnRlbnQ7XG4gICAgICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaW5wdXQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGlucHV0KTtcbiAgICAgICAgbGV0IGN1cnJlbnRGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGV4dDtcbiAgICAgICAgY29uc29sZS5sb2coaW5wdXQudmFsdWUpO1xuICAgICAgICBpbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlKCk7XG4gICAgICAgIGN1cnJlbnRGb2N1cy5mb2N1cygpO1xufVxuXG5leHBvcnQge1xuICAgIGdldExvY2F0aW9uU3RyaW5nRm9yLFxuICAgIG9uTG9jYXRpb25MaW5rQ2xpY2tcbn07XG4iLCIvKipcbiAqIE5hdmlnYXRvciBDYXJkIFJvd1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSB2aWV3IG9uIGEgZ2l2ZW4gU3RhY2sgdGhhdCBzaG93cyBlYWNoXG4gKiBzdWJwYXJ0IGNhcmQgaXRlbSBhcyBhIHdyYXBwZWQgbGVucyB2aWV3IGFsb25nXG4gKiBhIHJvdy5cbiAqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4uL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG48L3N0eWxlPlxuPHNsb3QgbmFtZT1cImNhcmRzXCI+PC9zbG90PlxuYDtcblxuY2xhc3MgQ2FyZFJvdyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5pbml0VmlldyA9IHRoaXMuaW5pdFZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRXcmFwcGVkQ2FyZCA9IHRoaXMuYWRkV3JhcHBlZENhcmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlID0gdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydEFkZGVkID0gdGhpcy5oYW5kbGVQYXJ0QWRkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCA9IHRoaXMuaGFuZGxlUGFydFJlbW92ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zaG93SW5pdGlhbGx5ID0gdGhpcy5zaG93SW5pdGlhbGx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25XcmFwcGVyQ2xpY2sgPSB0aGlzLm9uV3JhcHBlckNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgY29udGV4dCBtZW51IHRvIG9wZW4gaW4gdGhlIG5hdiBzaW5jZVxuICAgICAgICAvLyBpdCBkb2Vucyd0IG1ha2Ugc2Vuc2UgYXRtIGFuZCB3aWxsIGVycm9yXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVDbGljayk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2FyZC1pZCcsIHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY3VycmVudCcsIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgU3RhY2sgTW9kZWwncyBtYWluIHZpZXcgZWxlbWVudC5cbiAgICAgICAgLy8gV2UgYWRkIHRoZSBzdC12aWV3LWFkZGVkL3JlbW92ZWQgQ3VzdG9tRXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIC8vIGhlcmUgc28gd2UgY2FuIHJlYWN0IG9ubHkgdG8gZGlyZWN0IHN0YWNrIGFkZGl0aW9uc1xuICAgICAgICAvLyB0byB0aGUgU3RhY2sgKGFuZCBub3QsIHNheSwgdG8gV2luZG93cyBvciBvdGhlciBuZXN0ZWQga2luZHMpXG4gICAgICAgIGxldCBzdGFja1ZpZXcgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZCh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgc3RhY2tWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHN0YWNrVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsVW5zZXQocmVtb3ZlZE1vZGVsKXtcbiAgICAgICAgbGV0IHN0YWNrVmlldyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKHJlbW92ZWRNb2RlbC5pZCk7XG4gICAgICAgIHN0YWNrVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICBzdGFja1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ3VycmVudENoYW5nZSgpe1xuICAgICAgICBpZighdGhpcy5tb2RlbC5jdXJyZW50Q2FyZCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdyYXBwZXJzID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3dyYXBwZWQtdmlldycpKTtcbiAgICAgICAgd3JhcHBlcnMuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVkSWQgPSB3cmFwcGVyLmdldEF0dHJpYnV0ZSgnd3JhcHBlZC1pZCcpO1xuICAgICAgICAgICAgaWYod3JhcHBlZElkID09IHRoaXMubW9kZWwuY3VycmVudENhcmQuaWQudG9TdHJpbmcoKSl7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjdXJyZW50Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVQYXJ0QWRkZWQoZXZlbnQpe1xuICAgICAgICAvLyBUaGlzIGhhbmRsZXIgaXMgZm9yIHRoZSBzdC12aWV3LWFkZGVkXG4gICAgICAgIC8vIEN1c3RvbUV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIGJ5IFN5c3RlbSB3aGVuXG4gICAgICAgIC8vIG5ld01vZGVsKCkgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdjYXJkJyl7XG4gICAgICAgICAgICBsZXQgY2FyZFBhcnQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtldmVudC5kZXRhaWwucGFydElkXTtcbiAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlZENhcmQoY2FyZFBhcnQpO1xuICAgICAgICAgICAgdGhpcy5zaG93SW5pdGlhbGx5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVQYXJ0UmVtb3ZlZChldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnY2FyZCcpe1xuICAgICAgICAgICAgbGV0IHdyYXBwZWRWaWV3ID0gdGhpcy5xdWVyeVNlbGVjdG9yKGB3cmFwcGVkLXZpZXdbd3JhcHBlZC1pZD1cIiR7ZXZlbnQuZGV0YWlsLnBhcnRJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmKHdyYXBwZWRWaWV3KXtcbiAgICAgICAgICAgICAgICB3cmFwcGVkVmlldy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIG51bWJlciBkaXNwbGF5IG9mIGFsbCB3cmFwcGVkIHZpZXdzIGluIHRoZSByb3dcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKGB3cmFwcGVkLXZpZXdgKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25XcmFwcGVyQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgd3JhcHBlcklzQ3VycmVudCA9IGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2N1cnJlbnQnKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbCAmJiAhd3JhcHBlcklzQ3VycmVudCl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLmdvVG9DYXJkQnlJZChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCd3cmFwcGVkLWlkJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFZpZXcoKXtcbiAgICAgICAgLy8gRmlyc3QsIHdlIGNsZWFyIG91dCBhbnkgZXhpc3RpbmcgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgb3ZlciBlYWNoIGNhcmQgb2YgdGhlIHN0YWNrIGFuZDpcbiAgICAgICAgLy8gKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgY2FyZCB2aWV3IGVsZW1lbnQ7XG4gICAgICAgIC8vICogQXR0YWNoIHRoZSBjb3JyZWN0IG1vZGVsO1xuICAgICAgICAvLyAqIFNldCBpdCB0byBiZSBhIGxlbnNlZCB2aWV3O1xuICAgICAgICAvLyAqIERvIHRoZSBzYW1lIGZvciBhbGwgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5XG4gICAgICAgIHRoaXMubW9kZWwuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnY2FyZCc7XG4gICAgICAgIH0pLmZvckVhY2goY2FyZFBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRXcmFwcGVkQ2FyZChjYXJkUGFydCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzZXR0aW5nIHRoZSBjdXJyZW50XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSgpO1xuICAgIH1cblxuICAgIHNob3dJbml0aWFsbHkoKXtcbiAgICAgICAgLy8gTm90aGluZyBmb3Igbm93XG4gICAgfVxuXG4gICAgYWRkV3JhcHBlZENhcmQoYUNhcmQpe1xuICAgICAgICAvLyBJbnNlcnQgdGhlIGxlbnNlZCBDYXJkVmlldyBpbnRvIHRoZSB3cmFwcGVyXG4gICAgICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnd3JhcHBlZC12aWV3Jyk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKCdzbG90JywgJ2NhcmRzJyk7XG4gICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uV3JhcHBlckNsaWNrKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgd3JhcHBlci5zZXRNb2RlbChhQ2FyZCk7XG4gICAgfVxuXG4gICAgc3VicGFydE9yZGVyQ2hhbmdlZChpZCwgY3VycmVudEluZGV4LCBuZXdJbmRleCl7XG4gICAgICAgIGxldCBzdWJwYXJ0Tm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICBpZighc3VicGFydE5vZGUpe1xuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIG1vZGVsIHN1YnBhcnQgd2hpY2ggaXMgbm90IGEgY2FyZCBhbmQgaGVuY2Ugbm90XG4gICAgICAgICAgICAvLyBkaXNwbGF5ZWQgaW4gdGhlIENhcmRSb3dcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihuZXdJbmRleCA9PSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHN1YnBhcnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYWNjb3VudCBmb3Igd2hldGhlciB0aGUgaW5kZXggb2YgdGhpc1xuICAgICAgICAgICAgLy8gaXMgYmVmb3JlIG9yIGFmdGVyIHRoZSBuZXdJbmRleFxuICAgICAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbmV3SW5kZXgpe1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gbmV3SW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbbmV3SW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoc3VicGFydE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBudW1iZXIgZGlzcGxheSBvZiBhbGwgd3JhcHBlZCB2aWV3cyBpbiB0aGUgcm93XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKGB3cmFwcGVkLXZpZXdgKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn07XG5cbmV4cG9ydCB7XG4gICAgQ2FyZFJvdyxcbiAgICBDYXJkUm93IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFNpbXBsZVRhbGsgTmF2aWdhdG9yIFdlYmNvbXBvbmVudFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaGlzIGlzIGEgc3RhbmRhbG9uZSBjb21wb25lbnQgdGhhdCBhbGxvd3NcbiAqIGF1dGhvcnMgdG8gbmF2aWdhdGUgdGhlIFdvcmxkU3RhY2sgYW5kIGluZGl2aWR1YWxcbiAqIFN0YWNrcyB0aGVyZWluIHVzaW5nIGEgY29udmVuaWVudCBwb3Atb3V0IHRyYXkgZnJvbVxuICogdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuLlxuICoqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4uL1BhcnRWaWV3LmpzJztcbmltcG9ydCBXcmFwcGVkVmlldyBmcm9tICcuL1dyYXBwZWRWaWV3LmpzJztcbmltcG9ydCBTdGFja1JvdyBmcm9tICcuL1N0YWNrUm93LmpzJztcbmltcG9ydCBDYXJkUm93IGZyb20gJy4vQ2FyZFJvdy5qcyc7XG5cbi8vIEFkZCBhbnkgbmVlZGVkIGN1c3RvbUVsZW1lbnRzXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCduYXYtc3RhY2stcm93JywgU3RhY2tSb3cpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbmF2LWNhcmQtcm93JywgQ2FyZFJvdyk7XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCd3cmFwcGVkLXZpZXcnLCBXcmFwcGVkVmlldyk7XG5cbmNvbnN0IHN0YWNrSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zdGFja1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHBvbHlsaW5lIHBvaW50cz1cIjEyIDQgNCA4IDEyIDEyIDIwIDggMTIgNFwiPjwvcG9seWxpbmU+XG4gICA8cG9seWxpbmUgcG9pbnRzPVwiNCAxMiAxMiAxNiAyMCAxMlwiPjwvcG9seWxpbmU+XG4gICA8cG9seWxpbmUgcG9pbnRzPVwiNCAxNiAxMiAyMCAyMCAxNlwiPjwvcG9seWxpbmU+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGNhcmRJY29uID0gYFxuPHN2Z1xuICAgeG1sbnM6ZGM9XCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1wiXG4gICB4bWxuczpjYz1cImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1wiXG4gICB4bWxuczpyZGY9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCJcbiAgIHhtbG5zOnN2Zz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXN0YWNrXCJcbiAgIHdpZHRoPVwiNTBcIlxuICAgaGVpZ2h0PVwiMjAuODMzMzA5XCJcbiAgIHZpZXdCb3g9XCIwIDAgMjQgOS45OTk5ODg0XCJcbiAgIHN0cm9rZS13aWR0aD1cIjJcIlxuICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgIGZpbGw9XCJub25lXCJcbiAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxuICAgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIlxuICAgdmVyc2lvbj1cIjEuMVwiXG4gICBpZD1cInN2Zzg5M1wiPlxuICA8bWV0YWRhdGFcbiAgICAgaWQ9XCJtZXRhZGF0YTg5OVwiPlxuICAgIDxyZGY6UkRGPlxuICAgICAgPGNjOldvcmtcbiAgICAgICAgIHJkZjphYm91dD1cIlwiPlxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cbiAgICAgICAgPGRjOnR5cGVcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcIiAvPlxuICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT5cbiAgICAgIDwvY2M6V29yaz5cbiAgICA8L3JkZjpSREY+XG4gIDwvbWV0YWRhdGE+XG4gIDxkZWZzXG4gICAgIGlkPVwiZGVmczg5N1wiIC8+XG4gIDxwYXRoXG4gICAgIHN0cm9rZT1cIm5vbmVcIlxuICAgICBkPVwiTSAtMi43NjY5MTUxLC0xLjI1NjQ5NDggSCAyMS4yMzMwODUgViAyMi43NDM1MDUgSCAtMi43NjY5MTUxIFpcIlxuICAgICBmaWxsPVwibm9uZVwiXG4gICAgIGlkPVwicGF0aDg4NVwiIC8+XG4gIDxwb2x5bGluZVxuICAgICBwb2ludHM9XCIxMiA0IDQgOCAxMiAxMiAyMCA4IDEyIDRcIlxuICAgICBpZD1cInBvbHlsaW5lODg3XCJcbiAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsLTMpXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDI3MXB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDRweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0O1xuICAgICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSk7XG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDUwLCA1MCwgNTAsIDAuNCk7XG4gICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgICAgICAgb3ZlcmZsb3cteDogYXV0bztcbiAgICAgICAgei1pbmRleDogMTAwMDtcbiAgICB9XG5cbiAgICAubmF2LWRpc3BsYXktcm93IHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7XG4gICAgfVxuICAgIC5uYXYtaWNvbiB7XG4gICAgICAgIGNvbG9yOiBncmF5O1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDMwcHg7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJzdGFja3MtZGlzcGxheVwiIGNsYXNzPVwibmF2LWRpc3BsYXktcm93XCI+XG4gICAgPGRpdiBpZD1cInN0YWNrLWljb25cIiBjbGFzcz1cIm5hdi1pY29uXCI+JHtzdGFja0ljb259PC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cInN0YWNrLXJvd1wiPjwvc2xvdD5cbjwvZGl2PlxuPGRpdiBpZD1cImNhcmRzLWRpc3BsYXlcIiBjbGFzcz1cIm5hdi1kaXNwbGF5LXJvd1wiPlxuICAgIDxkaXYgaWQ9XCJjYXJkLWljb25cIiBjbGFzcz1cIm5hdi1pY29uXCI+JHtjYXJkSWNvbn08L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwiY2FyZC1yb3dcIj48L3Nsb3Q+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIFNUTmF2aWdhdG9yIGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCB1cCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMudG9nZ2xlID0gdGhpcy50b2dnbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuID0gdGhpcy5vcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSA9IHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRBZGRlZCA9IHRoaXMuaGFuZGxlUGFydEFkZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQgPSB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2FyZFJvd0ZvciA9IHRoaXMuY3JlYXRlQ2FyZFJvd0Zvci5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIGNvbnRleHQgbWVudSB0byBvcGVuIGluIHRoZSBuYXYgc2luY2VcbiAgICAgICAgLy8gaXQgZG9lbnMndCBtYWtlIHNlbnNlIGF0bSBhbmQgd2lsbCBlcnJvclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpO1xuICAgICAgICB3b3JsZFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1hZGRlZCcsIHRoaXMuaGFuZGxlUGFydEFkZGVkKTtcbiAgICAgICAgd29ybGRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctcmVtb3ZlZCcsIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcblxuICAgICAgICAvLyBSZXNwb25kIHRvIHRoZSBTeXN0ZW0gcGFydC1hZGRlZCBDdXN0b21FdmVudFxuICAgICAgICBsZXQgd29ybGRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgd29ybGRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHdvcmxkVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcblxuICAgICAgICAvLyBBZGQgYSBTdGFja1JvdyB2aWV3LlxuICAgICAgICB0aGlzLnN0YWNrUm93RWwgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IG5hdi1zdGFjay1yb3cnKTtcbiAgICAgICAgaWYoIXRoaXMuc3RhY2tSb3dFbCl7XG4gICAgICAgICAgICB0aGlzLnN0YWNrUm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYtc3RhY2stcm93Jyk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrUm93RWwuc2V0QXR0cmlidXRlKCdzbG90JywgJ3N0YWNrLXJvdycpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLnN0YWNrUm93RWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2tSb3dFbC5zZXRNb2RlbCh0aGlzLm1vZGVsKTtcblxuICAgICAgICAvLyBDcmVhdGUgYW55IG5lZWRlZCBDYXJkUm93IHZpZXdzIGZvciBhbGwgc3RhY2tzXG4gICAgICAgIC8vIGN1cnJlbnRseSBpbiB0aGUgd29ybGRcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pLmZvckVhY2goc3RhY2tQYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2FyZFJvd0ZvcihzdGFja1BhcnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0IHRoZSBTdGFja1Jvd1xuICAgICAgICB0aGlzLnN0YWNrUm93RWwuaW5pdFZpZXcoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBjYXJkL3N0YWNrIHZhbHVlc1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UoKTtcblxuICAgICAgICAvLyBSZXNwb25kIHRvIGV2ZW50dWFsIGN1cnJlbnQtbmVzcyBwcm9wXG4gICAgICAgIC8vIGNoYW5nZXMgZnJvbSB0aGUgV29ybGRTdGFjay5cbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2N1cnJlbnQnLCB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UpO1xuICAgIH1cblxuICAgIGhhbmRsZUN1cnJlbnRDaGFuZ2UoKXtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRoaXMgbWVhbnMgdGhhdCB0aGUgY3VycmVudCAqc3RhY2sqIGhhcyBjaGFuZ2VkLlxuICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIGZpbmQgdGhlIGNvcnJlY3QgQ2FyZFJvdyBmb3IgaXQgYW5kIHNldCBpdFxuICAgICAgICAvLyB0byBiZSB0aGUgc2xvdHRlZCBvbmUgaW4gdGhlIHNoYWRvdyBET01cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5tb2RlbC5jdXJyZW50U3RhY2suaWQudG9TdHJpbmcoKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ25hdi1jYXJkLXJvdycpKS5mb3JFYWNoKGNhcmRSb3cgPT4ge1xuICAgICAgICAgICAgbGV0IHJvd0lkID0gY2FyZFJvdy5nZXRBdHRyaWJ1dGUoJ3N0YWNrLWlkJyk7XG4gICAgICAgICAgICBjYXJkUm93LnJlbW92ZUF0dHJpYnV0ZSgnc2xvdCcpO1xuICAgICAgICAgICAgaWYoY3VycmVudFN0YWNrSWQgPT0gcm93SWQpe1xuICAgICAgICAgICAgICAgIGNhcmRSb3cuc2V0QXR0cmlidXRlKCdzbG90JywgJ2NhcmQtcm93Jyk7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShjYXJkUm93LnF1ZXJ5U2VsZWN0b3JBbGwoJ3dyYXBwZWQtdmlldycpKS5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZVNjYWxpbmcoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydEFkZGVkKGV2ZW50KXtcbiAgICAgICAgLy8gSWYgYSBuZXcgc3RhY2sgaXMgYWRkZWQsIHdlIG5lZWQgdG8gY3JlYXRlXG4gICAgICAgIC8vIGEgbmV3IENhcmRSb3cgZm9yIGl0LlxuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICBsZXQgc3RhY2tQYXJ0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbZXZlbnQuZGV0YWlsLnBhcnRJZF07XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNhcmRSb3dGb3Ioc3RhY2tQYXJ0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVBhcnRSZW1vdmVkKGV2ZW50KXtcbiAgICAgICAgLy8gSWYgYSBzdGFjayBoYXMgYmVlbiByZW1vdmVkLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY29ycmVzcG9uZGluZyBDYXJkUm93XG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIGxldCBjYXJkUm93ID0gdGhpcy5xdWVyeVNlbGVjdG9yKGBbc3RhY2staWQ9XCIke2V2ZW50LmRldGFpbC5wYXJ0SWR9XCJdYCk7XG4gICAgICAgICAgICBpZihjYXJkUm93KXtcbiAgICAgICAgICAgICAgICBjYXJkUm93LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlQ2FyZFJvd0ZvcihhU3RhY2spe1xuICAgICAgICBsZXQgY2FyZFJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25hdi1jYXJkLXJvdycpO1xuICAgICAgICBjYXJkUm93LnNldEF0dHJpYnV0ZSgnc3RhY2staWQnLCBhU3RhY2suaWQpO1xuICAgICAgICBjYXJkUm93LnNldE1vZGVsKGFTdGFjayk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2FyZFJvdyk7XG4gICAgICAgIGNhcmRSb3cuaW5pdFZpZXcoKTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKXtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJyk7XG4gICAgICAgIGlmKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdvcGVuJykpe1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuKCl7XG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKDApXCI7XG4gICAgfVxuXG4gICAgY2xvc2UoKXtcbiAgICAgICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVkoMTAwJSlcIjtcbiAgICB9XG5cbiAgICBcbn07XG5cbmV4cG9ydCB7XG4gICAgU1ROYXZpZ2F0b3IsXG4gICAgU1ROYXZpZ2F0b3IgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogTmF2aWdhdG9yIFN0YWNrIFJvd1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSB2aWV3IG9uIHRoZSBXb3JsZFN0YWNrIHRoYXQgc2hvd3MgZWFjaFxuICogc3VicGFydCBzdGFjayBpdGVtIGFzIGEgd3JhcHBlZCBsZW5zIHZpZXcgYWxvbmdcbiAqIGEgcm93LlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi4vUGFydFZpZXcuanMnO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cbjwvc3R5bGU+XG48c2xvdCBuYW1lPVwic3RhY2tzXCI+PC9zbG90PlxuYDtcblxuY2xhc3MgU3RhY2tSb3cgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgdXAgdGVtcGxhdGVcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmluaXRWaWV3ID0gdGhpcy5pbml0Vmlldy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFdyYXBwZWRTdGFjayA9IHRoaXMuYWRkV3JhcHBlZFN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSA9IHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRBZGRlZCA9IHRoaXMuaGFuZGxlUGFydEFkZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQgPSB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2hvd0luaXRpYWxseSA9IHRoaXMuc2hvd0luaXRpYWxseS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV3JhcHBlckNsaWNrID0gdGhpcy5vbldyYXBwZXJDbGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIGNvbnRleHQgbWVudSB0byBvcGVuIGluIHRoZSBuYXYgc2luY2VcbiAgICAgICAgLy8gaXQgZG9lbnMndCBtYWtlIHNlbnNlIGF0bSBhbmQgd2lsbCBlcnJvclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuICAgIH1cblxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3RhY2staWQnLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2N1cnJlbnQnLCB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIFdvcmxkIE1vZGVsJ3MgbWFpbiB2aWV3IGVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGFkZCB0aGUgc3Qtdmlldy1hZGRlZCBDdXN0b21FdmVudCBsaXN0ZW5lclxuICAgICAgICAvLyBoZXJlIHNvIHdlIGNhbiByZWFjdCBvbmx5IHRvIGRpcmVjdCBzdGFjayBhZGRpdGlvbnNcbiAgICAgICAgLy8gdG8gdGhlIFdvcmxkU3RhY2sgKGFuZCBub3QsIHNheSwgdG8gV2luZG93cyBvciBvdGhlciBuZXN0ZWQga2luZHMpXG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpO1xuICAgICAgICB3b3JsZFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1hZGRlZCcsIHRoaXMuaGFuZGxlUGFydEFkZGVkKTtcbiAgICAgICAgd29ybGRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctcmVtb3ZlZCcsIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxVbnNldCgpe1xuICAgICAgICBsZXQgd29ybGRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgd29ybGRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDdXJyZW50Q2hhbmdlKCl7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSB0aGlzLm1vZGVsLmN1cnJlbnRTdGFjay5pZDtcbiAgICAgICAgbGV0IHdyYXBwZWRWaWV3cyA9IEFycmF5LmZyb20oXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3dyYXBwZWQtdmlldycpXG4gICAgICAgICk7XG4gICAgICAgIHdyYXBwZWRWaWV3cy5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgbGV0IHdyYXBwZWRJZCA9IHdyYXBwZXIuZ2V0QXR0cmlidXRlKCd3cmFwcGVkLWlkJyk7XG4gICAgICAgICAgICBpZih3cmFwcGVkSWQgPT0gdGhpcy5tb2RlbC5jdXJyZW50U3RhY2suaWQudG9TdHJpbmcoKSl7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjdXJyZW50Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVQYXJ0QWRkZWQoZXZlbnQpe1xuICAgICAgICAvLyBUaGlzIGhhbmRsZXIgaXMgZm9yIHRoZSBzdC12aWV3LWFkZGVkXG4gICAgICAgIC8vIEN1c3RvbUV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIGJ5IFN5c3RlbSB3aGVuXG4gICAgICAgIC8vIG5ld01vZGVsKCkgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgbGV0IHN0YWNrUGFydCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW2V2ZW50LmRldGFpbC5wYXJ0SWRdO1xuICAgICAgICAgICAgdGhpcy5hZGRXcmFwcGVkU3RhY2soc3RhY2tQYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0luaXRpYWxseSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydFJlbW92ZWQoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICBsZXQgd3JhcHBlZFZpZXcgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYHdyYXBwZWQtdmlld1t3cmFwcGVkLWlkPVwiJHtldmVudC5kZXRhaWwucGFydElkfVwiXWApO1xuICAgICAgICAgICAgaWYod3JhcHBlZFZpZXcpe1xuICAgICAgICAgICAgICAgIHdyYXBwZWRWaWV3LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgbnVtYmVycyBvZiByZW1haW5pbmcgd3JhcHBlZCB2aWV3cyBpbiB0aGlzIFN0YWNrUm93XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnd3JhcHBlZC12aWV3JykpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uV3JhcHBlckNsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IHdyYXBwZXJJc0N1cnJlbnQgPSBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjdXJyZW50Jyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwgJiYgIXdyYXBwZXJJc0N1cnJlbnQpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5nb1RvU3RhY2tCeUlkKFxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3dyYXBwZWQtaWQnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRWaWV3KCl7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3Rpbmcgd3JhcHBlZCB2aWV3c1xuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBvdmVyIGVhY2ggY29ycmVzcG9uZGluZyBTdGFjayBhbmQ6XG4gICAgICAgIC8vICogQ3JlYXRlIGEgY2xvbmUgb2YgaXRzIHZpZXcgbm9kZTtcbiAgICAgICAgLy8gKiBBdHRhY2ggdGhlIGNvcnJlY3QgbW9kZWw7XG4gICAgICAgIC8vICogU2V0IGl0IHRvIGJlIGEgbGVuc2VkIHZpZXdcbiAgICAgICAgLy8gKiBEbyB0aGUgc2FtZSBmb3IgYWxsIGNoaWxkcmVuLCByZWN1cnNpdmVseVxuICAgICAgICB0aGlzLm1vZGVsLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ3N0YWNrJztcbiAgICAgICAgfSkuZm9yRWFjaChzdGFja1BhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRXcmFwcGVkU3RhY2soc3RhY2tQYXJ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGhlIGluaXRpYWwgY3VycmVudC1uZXNzIGRpc3BsYXlcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKCk7XG4gICAgfVxuXG4gICAgc2hvd0luaXRpYWxseSgpe1xuICAgICAgICAvLyBOb3RoaW5nIGZvciBub3dcbiAgICB9XG5cbiAgICBhZGRXcmFwcGVkU3RhY2soYVN0YWNrKXsgIFxuICAgICAgICAvLyBJbnNlcnQgdGhlIGxlbnNlZCBTdGFja1ZpZXcgaW50byB0aGUgd3JhcHBlclxuICAgICAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3dyYXBwZWQtdmlldycpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcInNsb3RcIiwgXCJzdGFja3NcIik7XG4gICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uV3JhcHBlckNsaWNrKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgd3JhcHBlci5zZXRNb2RlbChhU3RhY2spO1xuICAgIH1cblxuICAgIHN1YnBhcnRPcmRlckNoYW5nZWQoaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpe1xuICAgICAgICBsZXQgc3VicGFydE5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgaWYoIXN1YnBhcnROb2RlKXtcbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBtb2RlbCBzdWJwYXJ0IHdoaWNoIGlzIG5vdCBhIHN0YWNrIGFuZCBoZW5jZSBub3RcbiAgICAgICAgICAgIC8vIGRpc3BsYXllZCBpbiB0aGUgU3RhY2tSb3dcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihuZXdJbmRleCA9PSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHN1YnBhcnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYWNjb3VudCBmb3Igd2hldGhlciB0aGUgaW5kZXggb2YgdGhpc1xuICAgICAgICAgICAgLy8gaXMgYmVmb3JlIG9yIGFmdGVyIHRoZSBuZXdJbmRleFxuICAgICAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbmV3SW5kZXgpe1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gbmV3SW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbbmV3SW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoc3VicGFydE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBudW1iZXIgZGlzcGxheSBvZiBhbGwgd3JhcHBlZCB2aWV3cyBpbiB0aGUgcm93XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKGB3cmFwcGVkLXZpZXdgKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFN0YWNrUm93LFxuICAgIFN0YWNrUm93IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFdyYXBwZWRWaWV3IENvbXBvbmVudFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgcGxhaW4gV2ViY29tcG9uZW50IHdob3NlIHB1cnBvc2UgaXMgdG9cbiAqIHdyYXAgYSB2aXN1YWwgY29weSBvZiBhbiBhY3R1YWwgU2ltcGxlVGFsayBWaWV3XG4gKiBlbGVtZW50IGFuZCBkaXNwbGF5IGl0IGluIGEgc2NhbGVkIGRvd24gZm9ybWF0LlxuICogSSBtYWtlIGEgY2xvbmVkIGNvcHkgb2YgdGhlIHVuZGVybHlpbmcgdmlldyBhbmRcbiAqIGF0dGFjaCBpdCB0byB0aGUgc2FtZSBtb2RlbCBhcyB0aGUgb3JpZ2luYWwuXG4gKiovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi4vUGFydFZpZXcuanMnO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICAjbnVtYmVyLWRpc3BsYXkge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1pbjtcbiAgICAgICAgZm9udC1zaXplOiAyLjJyZW07XG4gICAgfVxuXG4gICAgI251bWJlci1kaXNwbGF5ID4gc3BhbiB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTBweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGxpbmVhcjtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuXG4gICAgOmhvc3QoOm5vdCguY3VycmVudCkpID4gI251bWJlci1kaXNwbGF5IHtcbiAgICAgICAgb3BhY2l0eTogMC44O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSk7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlLW91dDtcbiAgICAgICAgei1pbmRleDogMTAwMDtcbiAgICB9XG5cbiAgICA6aG9zdCg6bm90KC5jdXJyZW50KSkgPiAjbnVtYmVyLWRpc3BsYXkgPiBzcGFuIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDBweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGxpbmVhcjtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBpZD1cIm51bWJlci1kaXNwbGF5XCI+XG4gICAgPHNwYW4+PC9zcGFuPlxuPC9kaXY+XG48c2xvdCBuYW1lPVwid3JhcHBlZC12aWV3XCI+PC9zbG90PlxuYDtcblxuXG5jbGFzcyBXcmFwcGVkVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCB1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93RG9tXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQ2hpbGRTbG90dGVkID0gdGhpcy5vbkNoaWxkU2xvdHRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNjYWxpbmcgPSB0aGlzLnVwZGF0ZVNjYWxpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVOdW1iZXJDaGFuZ2UgPSB0aGlzLmhhbmRsZU51bWJlckNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFdyYXBwZWRWaWV3ID0gdGhpcy5hZGRXcmFwcGVkVmlldy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVseVVwZGF0ZUxlbnNWaWV3cyA9IHRoaXMuX3JlY3Vyc2l2ZWx5VXBkYXRlTGVuc1ZpZXdzLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICAvLyBCaW5kIGEgbGlzdGVuZXIgZm9yIHRoZSBzbG90IGNoYW5nZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbmV2ZXIgYW55XG4gICAgICAgICAgICAvLyB1bmRlcmx5aW5nIGVsZW1lbnQgaXMgc2xvdHRlZCwgc28gd2VcbiAgICAgICAgICAgIC8vIGtub3cgdG8gcmVjb21wdXRlIHRoZSBhcHByb3ByaWF0ZSBzaXppbmdcbiAgICAgICAgICAgIC8vIGFuZCBzdHlsaW5nXG4gICAgICAgICAgICBsZXQgc2xvdEVsID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzbG90Jyk7XG4gICAgICAgICAgICBzbG90RWwuYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMub25DaGlsZFNsb3R0ZWQpO1xuXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBjb250ZXh0IG1lbnUgdG8gb3BlbiBpbiB0aGUgbmF2IHNpbmNlXG4gICAgICAgICAgICAvLyBpdCBkb2Vucyd0IG1ha2Ugc2Vuc2UgYXRtIGFuZCB3aWxsIGVycm9yXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgbGV0IHNsb3RFbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc2xvdCcpO1xuICAgICAgICBzbG90RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMub25DaGlsZFNsb3R0ZWQpO1xuICAgIH1cblxuICAgIG9uQ2hpbGRTbG90dGVkKGV2ZW50KXtcbiAgICAgICAgLy90aGlzLnVwZGF0ZVNjYWxpbmcoKTtcbiAgICAgICAgLy90aGlzLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdudW1iZXInLCB0aGlzLmhhbmRsZU51bWJlckNoYW5nZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgIHRoaXMuYWRkV3JhcHBlZFZpZXcodGhpcy5tb2RlbCk7XG4gICAgICAgIHRoaXMudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVNjYWxpbmcoKXtcbiAgICAgICAgbGV0IGZpcnN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuWzBdO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgdGhlIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgICAgLy8gYWN0dWFsIHZpZXcgZm9yIHRoZSBsZW5zLWVkIHBhcnQsIGluIG9yZGVyIHRvIGdldFxuICAgICAgICAvLyBpdHMgY3VycmVudCBkaW1lbnNpb25zLlxuICAgICAgICBsZXQgcGFydElkID0gZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcpO1xuICAgICAgICBsZXQgcmVmRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0LXdvcmxkYCk7XG4gICAgICAgIGxldCB3cmFwQm94ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGlubmVyQm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3Qtd29ybGRgKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjYWxpbmdYID0gKHdyYXBCb3gud2lkdGggLyBpbm5lckJveC53aWR0aCk7XG4gICAgICAgIGxldCByZWZFbGVtZW50Qm94ID0gcmVmRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IGAke3JlZkVsZW1lbnRCb3gud2lkdGh9cHhgO1xuICAgICAgICBmaXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IGAke3JlZkVsZW1lbnRCb3guaGVpZ2h0fXB4YDtcbiAgICAgICAgZmlyc3RDaGlsZC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzY2FsaW5nWH0pYDtcbiAgICAgICAgZmlyc3RDaGlsZC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcIjBweCAwcHhcIjtcbiAgICB9XG5cbiAgICB1cGRhdGVOdW1iZXJEaXNwbGF5KCl7XG4gICAgICAgIGxldCBmaXJzdENoaWxkID0gdGhpcy5jaGlsZHJlblswXTtcbiAgICAgICAgbGV0IG1vZGVsID0gZmlyc3RDaGlsZC5tb2RlbDtcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIGxvb2sgYXQgc3VicGFydHMgb2YgdGhlIHNhbWUgdHlwZSAoc3RhY2sgb3IgY2FyZClcbiAgICAgICAgbGV0IHN1YnBhcnRzID0gbW9kZWwuX293bmVyLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnR5cGUgPT0gcGFydC50eXBlO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG51bURpc3BsYXkgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNudW1iZXItZGlzcGxheSA+IHNwYW4nKTtcbiAgICAgICAgbnVtRGlzcGxheS5pbm5lclRleHQgPSBzdWJwYXJ0cy5pbmRleE9mKG1vZGVsKSArIDE7XG4gICAgfVxuXG4gICAgaGFuZGxlTnVtYmVyQ2hhbmdlKCl7XG4gICAgICAgIC8vIFVwZGF0ZSBudW1iZXIgZGlzcGxheSBvZiBhbGwgd3JhcHBlZCB2aWV3cyBpbiB0aGUgcm93XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoYHdyYXBwZWQtdmlld2ApKS5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgd3JhcHBlci51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZFdyYXBwZWRWaWV3KGFQYXJ0TW9kZWwpe1xuICAgICAgICAvLyBGaXJzdCwgY2xlYXIgb3V0IGFueSBleGlzdGluZ1xuICAgICAgICAvLyBjaGlsZCBlbGVtZW50c1xuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbGVuc2VkIGNvcHkgb2YgdGhlIGdpdmVuXG4gICAgICAgIC8vIHZpZXcgYW5kIHVwZGF0ZSBrZXkgYXR0cmlidXRlcyBvbiBpdFxuICAgICAgICBsZXQgb3JpZ2luYWxWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke2FQYXJ0TW9kZWwuaWR9XCJdYCk7XG4gICAgICAgIGxldCBsZW5zZWRWaWV3ID0gb3JpZ2luYWxWaWV3LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgbGVuc2VkVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIGFQYXJ0TW9kZWwuaWQpO1xuICAgICAgICBsZW5zZWRWaWV3LnNldEF0dHJpYnV0ZSgnc2xvdCcsICd3cmFwcGVkLXZpZXcnKTtcbiAgICAgICAgbGVuc2VkVmlldy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIGxlbnNlZFZpZXcud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5saW5lIHRoZSBpbml0aWFsIHNjYWxpbmcgc3R5bGUgcHJvcGVydGllcy5cbiAgICAgICAgLy8gV2UgYmVnaW4gd2l0aCBhbiBleHRyZW1lbHkgc21hbGwgYW1vdW50IHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgYWRqdXN0ZWQgbGF0ZXIgZHVyaW5nIHVwZGF0ZVNjYWxpbmcoKTtcbiAgICAgICAgbGVuc2VkVmlldy5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHswLjAwMX0pYDtcbiAgICAgICAgbGVuc2VkVmlldy5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcIjBweCAwcHhcIjtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNyZWF0ZSBsZW5zIHZpZXdzIG9mIGFsbCBzdWJwYXJ0IGNoaWxkcmVuXG4gICAgICAgIC8vIGFuZCBhcHBlbmQgdGhlbSBpbiB0aGUgY29ycmVjdCBwbGFjZXNcbiAgICAgICAgbGVuc2VkVmlldy5pc0xlbnNlZCA9IHRydWU7XG4gICAgICAgIGxlbnNlZFZpZXcuc2V0TW9kZWwoYVBhcnRNb2RlbCk7XG4gICAgICAgIGxlbnNlZFZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgIGlmKGxlbnNlZFZpZXcuaGFuZGxlQ3VycmVudENoYW5nZSl7XG4gICAgICAgICAgICBsZW5zZWRWaWV3LmhhbmRsZUN1cnJlbnRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWN1cnNpdmVseVVwZGF0ZUxlbnNWaWV3cyhsZW5zZWRWaWV3LCBhUGFydE1vZGVsLmlkKTtcblxuICAgICAgICAvLyBJbnNlcnQgdGhlIHJvb3QgbGVuc2VkIHZpZXcgaW50byB0aGUgd3JhcHBlclxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd3JhcHBlZC1pZCcsIGFQYXJ0TW9kZWwuaWQpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGxlbnNlZFZpZXcpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNjYWxpbmcoKTtcbiAgICB9XG5cbiAgICBfcmVjdXJzaXZlbHlVcGRhdGVMZW5zVmlld3MobGVuc2VkVmlldywgYW5JZCl7XG4gICAgICAgIGxldCBzdWJWaWV3cyA9IEFycmF5LmZyb20obGVuc2VkVmlldy5jaGlsZHJlbikuZmlsdGVyKGNoaWxkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5pc1BhcnRWaWV3O1xuICAgICAgICB9KTtcbiAgICAgICAgc3ViVmlld3MuZm9yRWFjaChzdWJWaWV3ID0+IHtcbiAgICAgICAgICAgIHN1YlZpZXcuaXNMZW5zZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3ViVmlldy53YW50c0hhbG8gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzdWJJZCA9IHN1YlZpZXcuZ2V0QXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICBzdWJWaWV3LnNldEF0dHJpYnV0ZSgnbGVucy1wYXJ0LWlkJywgc3ViSWQpO1xuICAgICAgICAgICAgbGV0IG1vZGVsID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbc3ViSWRdO1xuICAgICAgICAgICAgc3ViVmlldy5zZXRNb2RlbChtb2RlbCk7XG4gICAgICAgICAgICBzdWJWaWV3LnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlbHlVcGRhdGVMZW5zVmlld3Moc3ViVmlldywgc3ViSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogUGFydFZpZXcgT3ZlcnJpZGVzICoqL1xuICAgIHN0eWxlQ1NTKCl7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICB9XG5cbiAgICBzdHlsZVRleHRDU1MoKXtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cblxuICAgIGxheW91dENoYW5nZWQoKXtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgV3JhcHBlZFZpZXcsXG4gICAgV3JhcHBlZFZpZXcgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCB7QWN0aXZhdGlvbkNvbnRleHR9IGZyb20gJy4uL29iamVjdHMvRXhlY3V0aW9uU3RhY2suanMnO1xuXG4vLyBIZWxwZXJzXG5mdW5jdGlvbiBmaW5kTmVhcmVzdFBhcmVudE9mS2luZChhUGFydCwgYVBhcnRUeXBlKXtcbiAgICBsZXQgb3duZXIgPSBhUGFydC5fb3duZXI7XG4gICAgd2hpbGUob3duZXIpe1xuICAgICAgICBpZihvd25lci50eXBlID09IGFQYXJ0VHlwZSl7XG4gICAgICAgICAgICByZXR1cm4gb3duZXI7XG4gICAgICAgIH1cbiAgICAgICAgb3duZXIgPSBvd25lci5fb3duZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgJ3RoaXMnIGlzIGEgJHthUGFydC50eXBlfSwgbm90IGEgJHthUGFydFR5cGV9IG9yIGRvZXMgbm90IGhhdmUgYSBwYXJlbnQgb2YgYSAke2FQYXJ0VHlwZX0hYCk7XG59XG5cbi8vIGNoZWNrIGZvciBwb3NzaWJsZUFuY2VzdG9yLmFjY2VwdHNTdWJwYXJ0KGFQYXJ0LnR5cGUpXG4vLyBhbmQgaWYgbm90IGdvIHRvIG93bmVyIGFuZCBjaGVjayBhZ2FpblxuZnVuY3Rpb24gZmluZEZpcnN0UG9zc2libGVBbmNlc3RvcihhUGFydCwgYVBhcnRUeXBlKXtcbiAgICBpZihfc3VicGFydENoZWNrKGFQYXJ0LCBhUGFydFR5cGUpKXtcbiAgICAgICAgcmV0dXJuIGFQYXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBvd25lciA9IGFQYXJ0Ll9vd25lcjtcbiAgICAgICAgd2hpbGUob3duZXIpe1xuICAgICAgICAgICAgaWYoX3N1YnBhcnRDaGVjayhvd25lciwgYVBhcnRUeXBlKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG93bmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3duZXIgPSBvd25lci5fb3duZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhICR7YVBhcnQudHlwZX0sIGRvZXMgbm90IGFjY2VwdCBub3IgaGFzIGFueSBhbmNlc3RvcnMgd2hpY2ggYWNjZXB0IHBhcnQgdHlwZSAke2FQYXJ0VHlwZX1gKTtcbn1cblxuZnVuY3Rpb24gX3N1YnBhcnRDaGVjayhhUGFydCwgYVBhcnRUeXBlKXtcbiAgICBpZihhUGFydFR5cGUgPT0gJ3BhcnQnKXtcbiAgICAgICAgcmV0dXJuIGFQYXJ0LmFjY2VwdGVkU3VicGFydFR5cGVzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIHJldHVybiBhUGFydC5hY2NlcHRzU3VicGFydChhUGFydFR5cGUpO1xufVxuXG5jbGFzcyBTVFZhcmlhYmxlUmVmZXJlbmNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgU1RWYXJpYWJsZVJlZmVyZW5jZUVycm9yLnByb3RvdHlwZSxcbiAgICAnbmFtZScsXG4gICAge1xuICAgICAgICB2YWx1ZTogJ1NUVmFyaWFibGVSZWZlcmVuY2VFcnJvcidcbiAgICB9XG4pO1xuXG5jb25zdCBjcmVhdGVJbnRlcnByZXRlclNlbWFudGljcyA9IChwYXJ0Q29udGV4dCwgc3lzdGVtQ29udGV4dCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIFNjcmlwdDogZnVuY3Rpb24oc2NyaXB0UGFydHMsIF8pe1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFBhcnRzLmludGVycHJldCgpO1xuICAgICAgICB9LFxuICAgICAgICBNZXNzYWdlSGFuZGxlcjogZnVuY3Rpb24oaGFuZGxlck9wZW4sIGxpbmVUZXJtLCBvcHRpb25hbFN0YXRlbWVudExpc3QsIGhhbmRsZXJDbG9zZSl7XG4gICAgICAgICAgICBsZXQge21lc3NhZ2VOYW1lLCBwYXJhbWV0ZXJzfSA9IGhhbmRsZXJPcGVuLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IGhhbmRsZXJGdW5jdGlvbiA9IGZ1bmN0aW9uKHNlbmRlcnMsIC4uLmFyZ3Mpe1xuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGdyYW1tYXIsIHRoZSBTdGF0ZW1lbnRMaXN0IGlzXG4gICAgICAgICAgICAgICAgLy8gYW4gb3B0aW9uYWwgcnVsZSwgbWVhbmluZyB0aGUgcmVzdWx0IG9mIHRoZSBydWxlXG4gICAgICAgICAgICAgICAgLy8gaXMgYW4gZW1wdHkgYXJyYXkgKG5vIHN0YXRlbWVudGxpc3QpIG9yIGEgc2luZ2xlXG4gICAgICAgICAgICAgICAgLy8gaXRlbSBhcnJheSAodGhlIHN0YXRlbWVudGxpc3QpXG4gICAgICAgICAgICAgICAgaWYob3B0aW9uYWxTdGF0ZW1lbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc3RhdGVtZW50TGlzdCA9IG9wdGlvbmFsU3RhdGVtZW50TGlzdC5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgICAgIC8vIE5leHQsIHdlIGluaXRpYWxpemUgYSBuZXcgQWN0aXZhdGlvbkNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdpbGwgaG9sZCBhbGwgdmFyaWFibGUgaW5mb3JtYXRpb24gZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgLy8gV2UgcHVzaCBpdCB0byB0aGUgdG9wIG9mIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBzdGFja1xuICAgICAgICAgICAgICAgIC8vIGFuZCBzZXQgdGhlIGFyZ3VtZW50IHZhcmlhYmxlcyB0byBsb2NhbHNcbiAgICAgICAgICAgICAgICBhcmdzLmZvckVhY2goKGFyZ1ZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJnTmFtZSA9IHBhcmFtZXRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1Db250ZXh0LmV4ZWN1dGlvblN0YWNrLmN1cnJlbnQuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgU3RhdGVtZW50TGlzdCBpcyBib3RoIG9wdGlvbmFsICphbmQqIG1hZGUgdXBcbiAgICAgICAgICAgICAgICAvLyBvZiBpdGVyYWJsZSBTdGF0ZW1lbnRMaW5lIHJ1bGVzIChpZSwgJ1N0YXRlbWVudExpbmUrJyBpbiBncmFtbWFyKSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIFwidW53cmFwXCIgdGhlc2Ugbm9kZXMgd2l0aG91dCBjYWxsaW5nIGludGVycHJldCgpIG9uIHRoZW0uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgZXhwcmVzc2lvbnMgd2l0aGluIHRoZSBzdGF0ZW1lbnRzLCBsaWtlIHZhcmlhYmxlIGxvb2t1cHMsXG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdCBjYWxsZWQgYmVmb3JlIGFueSBwcmVjZWRpbmcgc3RhdGVtZW50cyBoYXZlIGJlZW4gaW50ZXJwcmV0ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgbWVzc2FnZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc2VudC4gRm9yIGV4YW1wbGUsIHN0YXRlbWVudCAxIG1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gc2V0IGEgdmFyaWFibGUgdGhhdCBzdGF0ZW1lbnQgMiBuZWVkcyB0byBsb29rdXAgYW5kIHVzZSwgc28gd2Ugd2FudCB0aGUgbG9va3VwIHRvXG4gICAgICAgICAgICAgICAgLy8gb2NjdXIgYWZ0ZXIgc3RhdGVtZW50IDEgaGFzIGJlZW4gaW50ZXJwcmV0ZWQgYW5kIHRoZSBtZXNzYWdlIGZvciBpdCBoYXNcbiAgICAgICAgICAgICAgICAvLyBiZWVuIHNlbnQuXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50TGlzdC5jaGlsZHJlbi5mb3JFYWNoKHN0YXRlbWVudExpbmVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50TGluZXMuY2hpbGRyZW4uZm9yRWFjaChzdGF0ZW1lbnRMaW5lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gc3RhdGVtZW50TGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwYXJ0Q29udGV4dC5fY29tbWFuZEhhbmRsZXJzW21lc3NhZ2VOYW1lXSA9IGhhbmRsZXJGdW5jdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBNZXNzYWdlSGFuZGxlck9wZW46IGZ1bmN0aW9uKGxpdGVyYWxPbiwgbWVzc2FnZU5hbWUsIG9wdGlvbmFsUGFyYW1ldGVyTGlzdCl7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBQYXJhbWV0ZXJMaXN0IGhlcmUgaXMgb3B0aW9uYWwsIGlmXG4gICAgICAgICAgICAvLyBpdCBpcyBzZXQgaXQgd2lsbCBiZSBpbiB0aGUgZm9ybSBvZiBhIHNpemUgMSBhcnJheS5cbiAgICAgICAgICAgIC8vIFRoaXMgc2luZ2xlIGFycmF5IGl0ZW0gd2lsbCBpdHNlbGYgYmUgYW4gYXJyYXkgb2YgdGhlXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgdmFyaWFibGUgbmFtZXMuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFuIGVtcHR5IGFycmF5IGluZGljYXRlcyBubyBwYXJhbXNcbiAgICAgICAgICAgIC8vIGFyZSBwYXNzZWQgaW4gZm9yIHRoaXMgaGFuZGxlclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IG9wdGlvbmFsUGFyYW1ldGVyTGlzdC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKHBhcmFtcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VOYW1lOiBtZXNzYWdlTmFtZS5zb3VyY2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFBhcmFtZXRlckxpc3Q6IGZ1bmN0aW9uKHBhcmFtZXRlclN0cmluZyl7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyU3RyaW5nLmFzSXRlcmF0aW9uKCkuY2hpbGRyZW4ubWFwKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICBJbkNsYXVzZTogZnVuY3Rpb24oaW5MaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2Fuc3dlcjogZnVuY3Rpb24oYW5zd2VyLCBleHByZXNzaW9uKXtcbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiYW5zd2VyXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLmludGVycHJldCgpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9nb1RvRGlyZWN0aW9uOiBmdW5jdGlvbihnb1RvTGl0ZXJhbCwgbmV4dFByZXZpb3VzLCBzeXN0ZW1PYmplY3Qpe1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChuZXh0UHJldmlvdXMuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChzeXN0ZW1PYmplY3Quc291cmNlU3RyaW5nKXtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goc3lzdGVtT2JqZWN0LnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZ28gdG8gZGlyZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9nb1RvQnlPYmplY3RTcGVjaWZpZXI6IGZ1bmN0aW9uKGdvVG9MaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpIC8vIGlkIG9mIHRoZSBvYmplY3RcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZ28gdG9cIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2dvVG9XZWJzaXRlOiBmdW5jdGlvbihnb1RvTGl0ZXJhbCwgd2Vic2l0ZUxpdGVyYWwsIHVybCl7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICB1cmwuaW50ZXJwcmV0KClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZ28gdG8gd2Vic2l0ZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYWRkUHJvcGVydHk6IGZ1bmN0aW9uKGFkZExpdGVyYWwsIHByb3BlcnR5TGl0ZXJhbCwgcHJvcE5hbWVBc0xpdGVyYWwsIHRvTGl0ZXJhbCwgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCBzcGVjaWZpZWRPYmplY3RJZCA9IHN5c3RlbU9iamVjdC5pbnRlcnByZXQoKVswXSB8fCBudWxsO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgcHJvcE5hbWVBc0xpdGVyYWwuaW50ZXJwcmV0KCksIC8vIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkT2JqZWN0SWRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwibmV3UHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2FkZE1vZGVsOiBmdW5jdGlvbihhZGRMaXRlcmFsLCBuZXdQYXJ0VHlwZSwgb3B0aW9uYWxQYXJ0TmFtZSl7XG4gICAgICAgICAgICAvLyBoZXJlIG5vIG93bmVyIGhhcyBiZWVuIHByb3ZpZGVkIHNvIHdlIGFzc3VtZSBpdCBpcyB0aGUgZmlyc3QgcG9zc2libGUgb25lXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZmluZEZpcnN0UG9zc2libGVBbmNlc3RvcihwYXJ0Q29udGV4dCwgbmV3UGFydFR5cGUuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIG5ld1BhcnRUeXBlLnNvdXJjZVN0cmluZyxcbiAgICAgICAgICAgICAgICBwYXJlbnQuaWRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgb3B0aW9uYWxOYW1lID0gb3B0aW9uYWxQYXJ0TmFtZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsTmFtZSAmJiBvcHRpb25hbE5hbWUubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9uYWxOYW1lWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJuZXdNb2RlbFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYWRkTW9kZWxUbzogZnVuY3Rpb24oYWRkTGl0ZXJhbCwgbmV3UGFydFR5cGUsIG9wdGlvbmFsUGFydE5hbWUsIHRvTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIG5ld1BhcnRUeXBlLnNvdXJjZVN0cmluZywgLy8gVGhlIGtpbmQgb2YgcGFydCB0byBhZGRcbiAgICAgICAgICAgICAgICBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCkgLy8gaWQgb2YgdGhlIHBhcmVudCBtb2RlbCBwYXJ0XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgb3B0aW9uYWxOYW1lID0gb3B0aW9uYWxQYXJ0TmFtZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsTmFtZSAmJiBvcHRpb25hbE5hbWUubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9uYWxOYW1lWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJuZXdNb2RlbFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfcHV0VmFyaWFibGU6IGZ1bmN0aW9uKHB1dExpdGVyYWwsIHZhbHVlLCBpbnRvTGl0ZXJhbCwgZ2xvYmFsTGl0ZXJhbCwgZGVzdGluYXRpb24pe1xuICAgICAgICAgICAgbGV0IGdsb2JhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoZ2xvYmFsTGl0ZXJhbC5zb3VyY2VTdHJpbmcpe1xuICAgICAgICAgICAgICAgIGdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgdmFsdWUuaW50ZXJwcmV0KCksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIGdsb2JhbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdwdXRJbnRvJyxcbiAgICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2RlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbihkZWxldGVMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lQXNMaXRlcmFsLCBmcm9tTGl0ZXJhbCwgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCBzcGVjaWZpZWRPYmplY3RJZCA9IHN5c3RlbU9iamVjdC5pbnRlcnByZXQoKVswXSB8fCBudWxsO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgcHJvcE5hbWVBc0xpdGVyYWwuaW50ZXJwcmV0KCksIC8vIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkT2JqZWN0SWRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZGVsZXRlUHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2RlbGV0ZU1vZGVsOiBmdW5jdGlvbihkZWxldGVMaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpIC8vIGlkIG9mIHRoZSBvYmplY3RcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZGVsZXRlTW9kZWxcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX3NldFByb3BlcnR5OiBmdW5jdGlvbihzZXRMaXRlcmFsLCBwcm9wTmFtZUFzTGl0ZXJhbCwgdG9MaXRlcmFsLCBsaXRlcmFsT3JWYXJOYW1lLCBvcHRpb25hbEluQ2xhdXNlKXtcbiAgICAgICAgICAgIGxldCBzcGVjaWZpZWRPYmplY3RJZCA9IG9wdGlvbmFsSW5DbGF1c2UuaW50ZXJwcmV0KClbMF0gfHwgbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHByb3BOYW1lQXNMaXRlcmFsLmludGVycHJldCgpLCAvLyBUaGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIGxpdGVyYWxPclZhck5hbWUuaW50ZXJwcmV0KCksIC8vIFRoZSB2YWx1ZSBvciBhIHZhciByZXByZXNlbnRpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkT2JqZWN0SWRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwic2V0UHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX3NldFNlbGVjdGlvbjogZnVuY3Rpb24oc2V0TGl0ZXJhbCwgc2VsZWN0aW9uTGl0ZXJhbCwgcHJvcE5hbWVBc0xpdGVyYWwsIHRvTGl0ZXJhbCwgbGl0ZXJhbE9yVmFyTmFtZSwgb3B0aW9uYWxJbkNsYXVzZSl7XG4gICAgICAgICAgICBsZXQgc3BlY2lmaWVkT2JqZWN0SWQgPSBvcHRpb25hbEluQ2xhdXNlLmludGVycHJldCgpWzBdIHx8IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZUFzTGl0ZXJhbC5pbnRlcnByZXQoKSwgLy8gVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBsaXRlcmFsT3JWYXJOYW1lLmludGVycHJldCgpLCAvLyBUaGUgdmFsdWUgb3IgYSB2YXIgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgIHNwZWNpZmllZE9iamVjdElkXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcInNldFNlbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYXNrOiBmdW5jdGlvbihhc2tMaXRlcmFsLCBxdWVzdGlvbil7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImFza1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsgcXVlc3Rpb24uaW50ZXJwcmV0KCkgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX3RlbGxDb21tYW5kOiBmdW5jdGlvbih0ZWxsTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyLCB0b0xpdGVyYWwsIGNvbW1hbmQpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICd0ZWxsJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5pbnRlcnByZXQoKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hcmJpdHJhcnlDb21tYW5kOiBmdW5jdGlvbihjb21tYW5kTmFtZSwgb3B0aW9uYWxBcmd1bWVudExpc3Qpe1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgYXJndW1lbnQgbGlzdCBpcyBvcHRpb25hbCBoZXJlLCBpdCB3aWxsXG4gICAgICAgICAgICAvLyBiZSBlaXRoZXIgYW4gZW1wdHkgYXJyYXkgKG5vIGFyZ3VtZW50cykgb3IgYSBzaXplIDFcbiAgICAgICAgICAgIC8vIGFycmF5ICh3aGljaCBpdHNlbGYgd2lsbCBjb250YWluIGFuIGFycmF5IG9mIHRoZSBhcmd1bWVudHMpXG4gICAgICAgICAgICBsZXQgb3B0aW9uYWxBcmd1bWVudHMgPSBvcHRpb25hbEFyZ3VtZW50TGlzdC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsQXJndW1lbnRzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsQXJndW1lbnRzID0gb3B0aW9uYWxBcmd1bWVudHNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IGNvbW1hbmROYW1lLnNvdXJjZVN0cmluZyxcbiAgICAgICAgICAgICAgICBhcmdzOiBvcHRpb25hbEFyZ3VtZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kQXJndW1lbnRMaXN0OiBmdW5jdGlvbihsaXN0KXtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmFzSXRlcmF0aW9uKCkuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3RhdGVtZW50TGluZTogZnVuY3Rpb24oc3RhdGVtZW50LCBuZXdsaW5lKXtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gc3RhdGVtZW50LmludGVycHJldCgpO1xuXG4gICAgICAgICAgICAvLyBTb21lIHN0YXRlbWVudHMsIGxpa2UgaWYtdGhlbiBjb250cm9sc1xuICAgICAgICAgICAgLy8gYW5kIHJlcGVhdCBjb250cm9scywgZG8gbm90IHJlc3VsdCBpblxuICAgICAgICAgICAgLy8gbWVzc2FnZXMgYnV0IHJldHVybiBudWxsLlxuICAgICAgICAgICAgLy8gV2UgaWdub3JlIHRoZXNlLlxuICAgICAgICAgICAgaWYobWVzc2FnZSAmJiB0eXBlb2YobWVzc2FnZSkgIT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZFJlc3VsdCA9IHBhcnRDb250ZXh0LnNlbmRNZXNzYWdlKG1lc3NhZ2UsIHBhcnRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBzeXN0ZW1Db250ZXh0LmV4ZWN1dGlvblN0YWNrLmN1cnJlbnQuc2V0TG9jYWwoJ2l0JywgY29tbWFuZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFN0YXRlbWVudDogZnVuY3Rpb24oYWN0dWFsU3RhdGVtZW50LCBvcHRpb25hbENvbW1lbnQpe1xuICAgICAgICAgICAgcmV0dXJuIGFjdHVhbFN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX2FkZEV4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwcmVzc2lvbiwgb3BlcmF0aW9uLCBzZWNvbmRFeHByZXNzaW9uKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ICsgc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fbWludXNFeHByOiBmdW5jdGlvbihmaXJzdEV4cHIsIG9wZXJhdGlvbiwgc2Vjb25kRXhwcil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmaXJzdEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX2RpdmlkZUV4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwciwgb3BlcmF0aW9uLCBzZWNvbmRFeHByKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0IC8gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fbW9kdWxvRGl2aWRlRXhwcjogZnVuY3Rpb24oZmlyc3RFeHByLCBvcGVyYXRpb24sIHNlY29uZEV4cHIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHNlY29uZEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgJSBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvbl90aW1lc0V4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwcmVzc2lvbiwgb3BlcmF0aW9uLCBzZWNvbmRFeHByZXNzaW9uKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ICogc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fc3RyaW5nQ29uY2F0RXhwcjogZnVuY3Rpb24oZmlyc3RFeHByZXNzaW9uLCBvcGVyYXRpb24sIHNlY29uZEV4cHJlc3Npb24pe1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBlbmNvdW50ZXIgdGhlIFwiJlwiIG9wZXJhdG9yLCB3ZSBjb2VyY2UgYm90aCBleHByZXNzaW9ucyBpbnRvXG4gICAgICAgICAgICAvLyBhIHN0cmluZ1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByZXNzaW9uLmludGVycHJldCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwcmVzc2lvbi5pbnRlcnByZXQoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2ZpcnN0fSR7c2Vjb25kfWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRmFjdG9yX3BhcmVuRmFjdG9yOiBmdW5jdGlvbihsZWZ0UGFyZW4sIGV4cHJlc3Npb24sIHJpZ2h0UGFyZW4pe1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRmFjdG9yX25vdEZhY3RvcjogZnVuY3Rpb24obm90TGl0ZXJhbCwgZXhwcmVzc2lvbil7XG4gICAgICAgICAgICByZXR1cm4gIWV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXF1YWxpdHlDb25kaXRpb25hbDogZnVuY3Rpb24oZXhwcjEsIGNvbXBhcmF0b3JMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBleHByMS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBleHByMi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIE5vbkVxdWFsaXR5Q29uZGl0aW9uYWw6IGZ1bmN0aW9uKGV4cHIxLCBjb21wYXJhdG9yTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgIT09IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb25kaXRpb25hbF9ndENvbXBhcmlzb246IGZ1bmN0aW9uKGV4cHIxLCBndExpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID4gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsX2x0Q29tcGFyaXNvbjogZnVuY3Rpb24oZXhwcjEsIGx0TGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPCBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxfZ3RlQ29tcGFyaXNvbjogZnVuY3Rpb24oZXhwcjEsIGd0ZUxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID49IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb25kaXRpb25hbF9sdGVDb21wYXJpc29uOiBmdW5jdGlvbihleHByMSwgbHRlTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZXJlSXNBbk9iamVjdENvbmRpdGlvbmFsOiBmdW5jdGlvbih0aGVyZUxpdGVyYWwsIGlzTGl0ZXJhbCwgYU9yQW5MaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzTm90QW5PYmplY3RDb25kaXRpb25hbDogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIG5vdExpdGVyYWwsIGFPckFuTGl0ZXJhbCwgaW5DbGF1c2Upe1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzQVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIGFMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lLCBvZkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXJ0IHdpdGggaWQgJHt0YXJnZXRJZH0gKCR7dGhpcy5zb3VyY2VTdHJpbmd9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKHByb3BOYW1lLmludGVycHJldCgpKTtcbiAgICAgICAgICAgIGlmKHByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzQVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aG91dFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIGFMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lKXtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IHBhcnRDb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKHByb3BOYW1lLmludGVycHJldCgpKTtcbiAgICAgICAgICAgIGlmKHByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzTm90QVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIG5vdExpdGVyYWwsIGFMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lLCBvZkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXJ0IHdpdGggaWQgJHt0YXJnZXRJZH0gKCR7dGhpcy5zb3VyY2VTdHJpbmd9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKHByb3BOYW1lLmludGVycHJldCgpKTtcbiAgICAgICAgICAgIGlmKHByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzTm90QVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aG91dFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIG5vdExpdGVyYWwsIGFMaXRlcmFsLCBwcm9wTGl0ZXJhbCwgcHJvcE5hbWUpe1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gcGFydENvbnRleHQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUuaW50ZXJwcmV0KCkpO1xuICAgICAgICAgICAgaWYocHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlbklubGluZTogZnVuY3Rpb24oaWZMaXRlcmFsLCBjb25kaXRpb25hbCwgdGhlbkxpdGVyYWwsIHN0YXRlbWVudCwgb3B0aW9uYWxDb21tZW50KXtcbiAgICAgICAgICAgIGxldCBzaG91bGRFdmFsdWF0ZSA9IGNvbmRpdGlvbmFsLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoc2hvdWxkRXZhbHVhdGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlblNpbmdsZWxpbmVfd2l0aG91dEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0xLCB0aGVuTGluZSl7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gaWZMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoY29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhlbkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlblNpbmdsZWxpbmVfd2l0aEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0xLCB0aGVuTGluZSwgbGluZVRlcm0yLCBlbHNlTGluZSl7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gaWZMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoY29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhlbkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbHNlTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBJZlRoZW5NdWx0aWxpbmVfd2l0aEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0sIG11bHRpVGhlbiwgbXVsdGlFbHNlLCBlbmRJZkxpbmUpe1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvbiA9IGlmTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKGNvbmRpdGlvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11bHRpVGhlbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11bHRpRWxzZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBJZlRoZW5NdWx0aWxpbmVfd2l0aG91dEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0sIG11bHRpVGhlbiwgZW5kSWZMaW5lKXtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBpZkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihjb25kaXRpb24pe1xuICAgICAgICAgICAgICAgIHJldHVybiBtdWx0aVRoZW4uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBJZkxpbmU6IGZ1bmN0aW9uKGlmTGl0ZXJhbCwgY29uZGl0aW9uYWwsIG9wdGlvbmFsQ29tbWVudCl7XG4gICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uYWwuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlbkxpbmU6IGZ1bmN0aW9uKHRoZW5MaXRlcmFsLCBzdGF0ZW1lbnQsIG9wdGlvbmFsQ29tbWVudCl7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEVsc2VMaW5lOiBmdW5jdGlvbihlbHNlTGl0ZXJhbCwgc3RhdGVtZW50LCBvcHRpb25hbENvbW1lbnQpe1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb250cm9sU3RhdGVtZW50TGluZTogZnVuY3Rpb24oc3RhdGVtZW50TGluZSl7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50TGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBNdWx0aVRoZW46IGZ1bmN0aW9uKHRoZW5MaXRlcmFsLCBvcHRpb25hbENvbW1lbnQsIGxpbnRUZXJtLCBjb250cm9sU3RhdGVtZW50TGluZXMpe1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xTdGF0ZW1lbnRMaW5lcy5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBNdWx0aUVsc2U6IGZ1bmN0aW9uKGVsc2VMaXRlcmFsLCBvcHRpb25hbENvbW1lbnQsIGxpbmVUZXJtLCBjb250cm9sU3RhdGVtZW50TGluZXMpe1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xTdGF0ZW1lbnRMaW5lcy5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBLaW5kQ29uZGl0aW9uYWw6IGZ1bmN0aW9uKGV4cHIxLCBjb21wYXJhdG9yTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgLy8gVE9ETzogRmxlc2ggb3V0IHRoaXMgZnVuY3Rpb24gdG8gYWNjb3VudCBmb3JcbiAgICAgICAgICAgIC8vIHZhcmlvdXMgb2JqZWN0IHR5cGVzIGFuZCB0aGVpciBraW5kIGNvbXBhcmlzb25zXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTm90S2luZENvbmRpdGlvbmFsOiBmdW5jdGlvbihleHByMSwgY29tcGFyYXRvckxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIC8vIFRPRE86IEZsZXNoIG91dCB0aGlzIGZ1bmN0aW9uIHRvIGFjY291bnQgZm9yXG4gICAgICAgICAgICAvLyB2YXJpb3VzIG9iamVjdCB0eXBlcyBhbmQgdGhlaXIga2luZCBjb21wYXJpc29uc1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0Q29udHJvbEZvcm1fZm9yTnVtVGltZXM6IGZ1bmN0aW9uKHJlcGVhdExpdCwgb3B0aW9uYWxGb3JMaXQsIGludE9yVmFyLCB0aW1lc0xpdCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcGVhdFR5cGU6ICdmb3JOdW1UaW1lcycsXG4gICAgICAgICAgICAgICAgbnVtVGltZXM6IGludE9yVmFyLmludGVycHJldCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdENvbnRyb2xGb3JtX3VudGlsQ29uZGl0aW9uOiBmdW5jdGlvbihyZXBlYXRMaXQsIHVudGlsTGl0LCBjb25kaXRpb25hbCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcGVhdFR5cGU6ICd1bnRpbENvbmRpdGlvbicsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBjb25kaXRpb25hbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRDb250cm9sRm9ybV93aGlsZUNvbmRpdGlvbjogZnVuY3Rpb24ocmVwZWF0TGl0LCB3aGlsZUxpdCwgY29uZGl0aW9uYWwpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXBlYXRUeXBlOiAnd2hpbGVDb25kaXRpb24nLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0Q29udHJvbEZvcm1fd2l0aFN0YXJ0RmluaXNoOiBmdW5jdGlvbihyZXBlYXRMaXQsIHdpdGhMaXQsIHZhck5hbWUsIGVxTGl0LCBmaXJzdFZhbCwgdG9MaXQsIHNlY29uZFZhbCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcGVhdFR5cGU6ICd3aXRoU3RhcnRGaW5pc2gnLFxuICAgICAgICAgICAgICAgIHZhck5hbWU6IHZhck5hbWUuc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFZhbC5pbnRlcnByZXQoKSxcbiAgICAgICAgICAgICAgICBmaW5pc2g6IHNlY29uZFZhbC5pbnRlcnByZXQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRBZGp1c3RfZXhpdDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByZXR1cm4gJ2V4aXQgcmVwZWF0JztcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRBZGp1c3RfbmV4dDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByZXR1cm4gJ25leHQgcmVwZWF0JztcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRCbG9jazogZnVuY3Rpb24ocmVwZWF0Q29udHJvbCwgbGluZVRlcm0sIHN0YXRlbWVudExpbmVPclJlcEFkanVzdFBsdXMsIGVuZExpdGVyYWwpe1xuICAgICAgICAgICAgbGV0IHJlcGVhdEluZm8gPSByZXBlYXRDb250cm9sLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHN0YXRlbWVudExpbmVzID0gc3RhdGVtZW50TGluZU9yUmVwQWRqdXN0UGx1cy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHN3aXRjaChyZXBlYXRJbmZvLnJlcGVhdFR5cGUpe1xuICAgICAgICAgICAgY2FzZSAnZm9yTnVtVGltZXMnOlxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gcmVwZWF0SW5mby5udW1UaW1lczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRQYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBzdGF0ZW1lbnRMaW5lcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlbWVudCA9IHN0YXRlbWVudExpbmVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGN1cnJlbnRTdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT0gJ2V4aXQgcmVwZWF0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzdWx0ID09ICduZXh0IHJlcGVhdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkUGFzcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkQnJlYWspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGUgbWFpbiBmb3IgbG9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBCcmVhayBvdXQgb2YgdGhlIHN3aXRjaFxuICAgICAgICAgICAgY2FzZSAndW50aWxDb25kaXRpb24nOlxuICAgICAgICAgICAgICAgIGxldCB1bnRpbFRlc3RDb25kaXRpb24gPSByZXBlYXRJbmZvLmNvbmRpdGlvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSghdW50aWxUZXN0Q29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdGF0ZW1lbnRMaW5lcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlbWVudCA9IHN0YXRlbWVudExpbmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGN1cnJlbnRTdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PSAnZXhpdCByZXBlYXQnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzdWx0ID09ICduZXh0IHJlcGVhdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkQnJlYWspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGUgb3V0ZXIgd2hpbGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVudGlsVGVzdENvbmRpdGlvbiA9IHJlcGVhdEluZm8uY29uZGl0aW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhazsgLy8gQnJlYWsgb3V0IG9mIHRoZSBzd2l0Y2ggY2FzZVxuICAgICAgICAgICAgY2FzZSAnd2hpbGVDb25kaXRpb24nOlxuICAgICAgICAgICAgICAgIGxldCB3aGlsZVRlc3RDb25kaXRpb24gPSByZXBlYXRJbmZvLmNvbmRpdGlvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSh3aGlsZVRlc3RDb25kaXRpb24pe1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHN0YXRlbWVudExpbmVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGVtZW50ID0gc3RhdGVtZW50TGluZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudFN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PSAnZXhpdCByZXBlYXQnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihyZXN1bHQgPT0gXCJuZXh0IHJlcGVhdFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoaXMgaW5uZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHNob3VsZEJyZWFrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2Ygb3V0ZXIgd2hpbGUgbG9vcCAoZW5kIHJlcGVhdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZVRlc3RDb25kaXRpb24gPSByZXBlYXRJbmZvLmNvbmRpdGlvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiBzd2l0Y2ggY2FzZVxuICAgICAgICAgICAgY2FzZSAnd2l0aFN0YXJ0RmluaXNoJzpcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSBhc3N1bWUgdGhhdCBzdGFydCBpcyBsZXNzIHRoYW5cbiAgICAgICAgICAgICAgICAvLyBmaW5pc2guIFdlIHNob3VsZCBwcm9iYWJseSB0aHJvdyBhbiBlcnJvciBpZlxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGlmKHJlcGVhdEluZm8uc3RhcnQgPiByZXBlYXRJbmZvLmZpbmlzaCl7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVwZWF0IGVycm9yOiBzdGFydCBncmVhdGVyIHRoYW4gZmluaXNoYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gcmVwZWF0SW5mby5zdGFydDsgaSA8PSByZXBlYXRJbmZvLmZpbmlzaDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtQ29udGV4dC5leGVjdXRpb25TdGFjay5jdXJyZW50LnNldExvY2FsKHJlcGVhdEluZm8udmFyTmFtZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkUGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgc3RhdGVtZW50TGluZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRMaW5lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBjdXJyZW50U3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09IFwiZXhpdCByZXBlYXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzdWx0ID09IFwibmV4dCByZXBlYXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRQYXNzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRCcmVhayl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoZSBvdXRlciAocmVwZWF0KSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBQcm9wZXJ0eVZhbHVlX3dpdGhTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZUxpdGVyYWwsIHByb3BOYW1lLCBvZkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXJ0IHdpdGggaWQgJHt0YXJnZXRJZH0gKCR7dGhpcy5zb3VyY2VTdHJpbmd9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wTmFtZS5pbnRlcnByZXQoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBQcm9wZXJ0eVZhbHVlX3dpdGhvdXRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZUxpdGVyYWwsIHByb3BOYW1lKXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q29udGV4dC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHBhcnRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHByb3BOYW1lLmludGVycHJldCgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBPYmplY3QgU3BlY2lmaWVycyAqKi9cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydEJ5VGFyZ2V0IFBhcnRpYWwgU3BlY2lmaWVyXG4gICAgICAgICAqIHJlZmVycyB0byBwYXJ0aWFscyB0aGF0IHNwZWNpZnkgYSBwYXJ0XG4gICAgICAgICAqIHNwZWNpZmllZCBpbiB0aGUgXCJ0YXJnZXRcIiBQYXJ0UHJvcGVydHlcbiAgICAgICAgICogb2YgdGhlIGNvbnRleHQgcGFydC4gVGhlIHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiB0YXJnZXQgcHJvcGVydHkgaXMgYW55IHZhbGlkIE9iamVjdFNwZWNpZmllclxuICAgICAgICAgKiBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWFsU3BlY2lmaWVyX3BhcnRCeVRhcmdldCh0YXJnZXRMaXRlcmFsKXtcbiAgICAgICAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRQcm9wVmFsdWUgPSBjb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoY29udGV4dCwgXCJ0YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBwYXJ0Q29udGV4dCBzaW5jZSB0aGUgY29udGV4dCBvYmplY3QgbWlnaHQgbm90IGhhdmUgYW55IHNlbWFudGljcyBzZXQgb24gaXRcbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgYSBjb250ZXh0IG9iamVjdC9wYXJ0IHdoaWNoIGRvZXMgbm90IGhhdmUgYSBzY3JpcHQgd2hpY2ggaGFzIGJlZW5cbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCB3aWxsIG5vdCBoYXZlIGhhZCBjb250ZXh0Ll9zZW1hbnRpY3Mgc2V0LlxuICAgICAgICAgICAgICAgIGxldCBzZW1hbnRpY3MgPSBwYXJ0Q29udGV4dC5fc2VtYW50aWNzO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaE9iamVjdCA9IHN5c3RlbUNvbnRleHQuZ3JhbW1hci5tYXRjaCh0YXJnZXRQcm9wVmFsdWUsICdPYmplY3RTcGVjaWZpZXInKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobWF0Y2hPYmplY3QpLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1Db250ZXh0LnBhcnRzQnlJZFt0YXJnZXRJZF07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudENhcmQgUGFydGlhbCBTcGVjaWZpZXJcbiAgICAgICAgICogcmVmZXJzIHRvIHBhcnRpYWxzIHRoYXQgc3BlY2lmeSB0aGUgY3VycmVudCBjYXJkXG4gICAgICAgICAqIGRlcGVuZGluZyBvbiB0aGUgc3RhY2sgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfY3VycmVudENhcmQ6IGZ1bmN0aW9uKGN1cnJlbnRMaXRlcmFsLCBjYXJkTGl0ZXJhbCl7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0UGFydC5jdXJyZW50Q2FyZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlJbmRleCBQYXJ0aWFsIFNwZWNpZmllclxuICAgICAgICAgKiByZWZlcnMgdG8gcGFydGlhbHMgdGhhdCBzcGVjaWZ5IGEgcGFydFxuICAgICAgICAgKiB0eXBlIGFuZCBhbiBpbnRlZ2VyIGxpdGVyYWwsIGZvciBleDpcbiAgICAgICAgICogICAgIGZpZWxkIDNcbiAgICAgICAgICogVGhlIGFib3ZlIGV4YW1wbGUgcmVmZXJzIHRvIHRoZSB0aGlyZFxuICAgICAgICAgKiBmaWVsZCBwYXJ0IGluIGl0cyBvd25lci9wYXJlbnQgcGFydC5cbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfcGFydEJ5SW5kZXg6IGZ1bmN0aW9uKG9iamVjdFR5cGUsIGludGVnZXJMaXRlcmFsKXtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGludGVnZXJMaXRlcmFsLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoaW5kZXggPCAxKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnQgaW5kaWNlcyBtdXN0IGJlIDEgb3IgZ3JlYXRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICBpZihvYmplY3RUeXBlLnNvdXJjZVN0cmluZyA9PSAncGFydCcpe1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA+IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSBwYXJ0IG51bWJlcmVkICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRQYXJ0LnN1YnBhcnRzW2luZGV4LTFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0c09mVHlwZSA9IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gb2JqZWN0VHlwZS5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA+IHBhcnRzT2ZUeXBlLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSAke29iamVjdFR5cGUuc291cmNlU3RyaW5nfSBudW1iZXJlZCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c09mVHlwZVtpbmRleC0xXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydEJ5TnVtZXJpY2FsSW5kZXggUGFydGlhbCBTcGVjaWZpZXJcbiAgICAgICAgICogcmVmZXJzIHRvIHBhcnRpYWwgdGhhdCBzcGVjaWZ5IGEgcGFydFxuICAgICAgICAgKiB0eXBlIHByZWNlZGVkIGJ5IHRoZSBFbmdsaXNoIHdvcmQgZm9yIHRoZVxuICAgICAgICAgKiBudW1iZXIuIEZvciB0aGUgbW9tZW50IHdlIGFjY2VwdCBmaXJzdCAtIHRlbnRoXG4gICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAqICAgICBzaXh0aCBidXR0b25cbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfcGFydEJ5TnVtZXJpY2FsSW5kZXg6IGZ1bmN0aW9uKG51bWVyaWNhbEtleXdvcmQsIG9iamVjdFR5cGUpe1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVtZXJpY2FsS2V5d29yZC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgaWYob2JqZWN0VHlwZS5zb3VyY2VTdHJpbmcgPT0gJ3BhcnQnKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPiBjb250ZXh0UGFydC5zdWJwYXJ0cy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHRQYXJ0LnR5cGV9WyR7Y29udGV4dFBhcnQuaWR9XSBkb2VzIG5vdCBoYXZlIGEgcGFydCBudW1iZXJlZCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4IDwgMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhlIFwibGFzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIG9mIHRoZSBkZXNpcmVkIGNvbGxlY3Rpb24gd2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0UGFydC5zdWJwYXJ0c1tjb250ZXh0UGFydC5zdWJwYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0UGFydC5zdWJwYXJ0c1tpbmRleC0xXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0c09mVHlwZSA9IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gb2JqZWN0VHlwZS5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA+IHBhcnRzT2ZUeXBlLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSAke29iamVjdFR5cGUuc291cmNlU3RyaW5nfSBudW1iZXJlZCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4IDwgMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhlIFwibGFzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIG9mIHRoZSBkZXNpcmVkIGNvbGxlY3Rpb24gd2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c09mVHlwZVtwYXJ0c09mVHlwZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c09mVHlwZVtpbmRleC0xXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlOYW1lIFBhcnRpYWwgU3BlY2lmaWVyXG4gICAgICAgICAqIHJlZmVycyB0byBhIHBhcnRpYWwgdGhhdCBzcGVjaWZpZXMgYSBwYXJ0XG4gICAgICAgICAqIGJ5IGl0cyBuYW1lIHByb3BlcnR5LiBFeGFtcGxlOlxuICAgICAgICAgKiAgICAgY2FyZCBcIk15IEN1c3RvbSBDYXJkXCJcbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfcGFydEJ5TmFtZTogZnVuY3Rpb24ob2JqZWN0VHlwZSwgc3RyaW5nTGl0ZXJhbCl7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHN0cmluZ0xpdGVyYWwuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihvYmplY3RUeXBlLnNvdXJjZVN0cmluZyA9PSAncGFydCcpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZE5hbWUgPSBzdWJwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PSBmb3VuZE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihmb3VuZC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0UGFydC50eXBlfVske2NvbnRleHRQYXJ0LmlkfV0gZG9lcyBub3QgaGF2ZSBhIHBhcnQgbmFtZWQgXCIke25hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb250ZXh0UGFydC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09IG9iamVjdFR5cGUuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmROYW1lID0gc3VicGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnBhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kTmFtZSA9PSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZm91bmQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSAke29iamVjdFR5cGUuc291cmNlU3RyaW5nfSBuYW1lZCBcIiR7bmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAndGhpcycgc3BlY2lmaWVyIGlzIGEgdGVybWluYWwgKGZpbmFsKVxuICAgICAgICAgKiBzcGVjaWZpZXIgdGhhdCByZWZlcnMgdG8gb25lIG9mIHRocmVlIHRoaW5nczpcbiAgICAgICAgICogMS4gdGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgcGFydCBleGVjdXRpbmcgdGhlIHNjcmlwdCxcbiAgICAgICAgICogICAgZXhhbXBsZTogdGhpcyBidXR0b25cbiAgICAgICAgICogMi4gQ2FyZCwgd2hpY2ggcmVmZXJzIHRvIHRoZSBjYXJkIHRoYXQgb3ducyB0aGVcbiAgICAgICAgICogICAgcGFydCB0aGF0IGlzIGN1cnJlbnRseSBleGVjdXRpbmcgdGhlIHNjcmlwdCwgZXg6XG4gICAgICAgICAqICAgIHRoaXMgY2FyZFxuICAgICAgICAgKiAzLiBTdGFjaywgd2hpY2ggcmVmZXJzIHRvIHRoZSBzdGFjayB0aGF0IG93bnMgdGhlXG4gICAgICAgICAqICAgIHBhcnQgdGhhdCBpcyBjdXJyZW50bHkgZXhlY3V0aW5nIHRoZSBzY3JpcHQsIGV4OlxuICAgICAgICAgKiAgICB0aGlzIHN0YWNrXG4gICAgICAgICAqL1xuICAgICAgICBUZXJtaW5hbFNwZWNpZmllcl90aGlzU3lzdGVtT2JqZWN0OiBmdW5jdGlvbih0aGlzTGl0ZXJhbCwgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCB0YXJnZXRUeXBlID0gc3lzdGVtT2JqZWN0LnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0VHlwZSA9PSBwYXJ0Q29udGV4dC50eXBlKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRDb250ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5kTmVhcmVzdFBhcmVudE9mS2luZChwYXJ0Q29udGV4dCwgdGFyZ2V0VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICdjdXJyZW50JyBzcGVjaWZpZXIgaXMgYSB0ZXJtaW5hbCAoZmluYWwpXG4gICAgICAgICAqIHNwZWNpZmllciB0aGF0IHJlZmVycyB0byBlaXRoZXIgdGhlIGN1cnJlbnQgY2FyZCBvciBzdGFja1xuICAgICAgICAgKiBiZWluZyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIFRoZXJlIGFyZSBvbmx5IHR3byBwb3NzaWJsZSB2YWxpZCBvcHRpb25zOlxuICAgICAgICAgKiAgICAgYGN1cnJlbnQgY2FyZGBcbiAgICAgICAgICogICAgIGBjdXJyZW50IHN0YWNrYFxuICAgICAgICAgKi9cbiAgICAgICAgVGVybWluYWxTcGVjaWZpZXJfY3VycmVudFN5c3RlbU9iamVjdDogZnVuY3Rpb24oY3VycmVudExpdGVyYWwsIHN5c3RlbU9iamVjdCl7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VHlwZSA9IHN5c3RlbU9iamVjdC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIGlmKHRhcmdldFR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1Db250ZXh0LmdldEN1cnJlbnRTdGFja01vZGVsKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRhcmdldFR5cGUgPT0gJ2NhcmQnKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbUNvbnRleHQuZ2V0Q3VycmVudENhcmRNb2RlbCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0YXJnZXRUeXBlfSBjYW5ub3QgYmUgYSAnY3VycmVudCcgc3lzdGVtIG9iamVjdGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlJZCBzcGVjaWZpZXIgaXMgYSB0ZXJtaW5hbCAoZmluYWwpXG4gICAgICAgICAqIHNwZWNpZmllciB0aGF0IHJlZmVycyB0byBhIGdpdmVuIHBhcnQgdHlwZVxuICAgICAgICAgKiBieSBpdHMgdW5pcXVlIHN5c3RlbSBpZC4gRm9yIGFueSBraW5kIG9mIHBhcnQsXG4gICAgICAgICAqIHdlIHVzZSBgcGFydCBpZCA8b2JqZWN0SWQ+YFxuICAgICAgICAgKiBFeGFtcGxlczogYGNhcmQgaWQgMjY2YCBgcGFydCBpZCA1YFxuICAgICAgICAgKi9cbiAgICAgICAgVGVybWluYWxTcGVjaWZpZXJfcGFydEJ5SWQ6IGZ1bmN0aW9uKG9iamVjdFR5cGUsIGlkTGl0ZXJhbCwgb2JqZWN0SWQpe1xuICAgICAgICAgICAgbGV0IGlkID0gb2JqZWN0SWQuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbaWRdO1xuICAgICAgICAgICAgaWYoIWZvdW5kKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kICR7b2JqZWN0VHlwZS5zb3VyY2VTdHJpbmd9IHdpdGggaWQgJHtvYmplY3RJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFwicHJlZml4ZWRcIiBxdWVyaWVkIHNwZWNpZmllciBpcyBqdXN0XG4gICAgICAgICAqIGEgUGFydGlhbFNwZWNpZmllciB3aXRoIFwib2ZcIiBpbiBmcm9udCBvZiBpdCwgaW5kaWNhdGluZ1xuICAgICAgICAgKiB0aGF0IGEgZGlmZmVyZW50IHBhcnRpYWwgd2lsbCBwcmVjZWRlIGl0IGJlIHF1ZXJpZWQgaW5zaWRlIG9mIGl0LlxuICAgICAgICAgKiBFeGFtcGxlIGBvZiBidXR0b24gXCJNeSBCdXR0b25cImBcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJpZWRTcGVjaWZpZXJfcHJlZml4ZWQ6IGZ1bmN0aW9uKHBhcnRpYWxTcGVjaWZpZXIsIG9mTGl0ZXJhbCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBuZXN0ZWQgcXVlcmllZCBzcGVjaWZpZXIgaXMgb25lIHRoYXQgaGFzIHR3b1xuICAgICAgICAgKiBvciBtb3JlIHByZWZpeGVkIHNwZWNpZmllcnMuIFRoZSBzaW1wbGVzdCB3b3VsZCBiZVxuICAgICAgICAgKiBzb21ldGhpbmcgbGlrZTpcbiAgICAgICAgICogICAgIGBvZiBjYXJkIFwiTXkgQ2FyZFwiIG9mIHN0YWNrIFwiQW5vdGhlciBuYW1lZCBzdGFja1wiYFxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcmllZFNwZWNpZmllcl9uZXN0ZWQ6IGZ1bmN0aW9uKGZpcnN0UXVlcnksIHNlY29uZFF1ZXJ5KXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gc2Vjb25kUXVlcnkuaW50ZXJwcmV0KCkoY29udGV4dFBhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBvdXRlciA9IGZpcnN0UXVlcnkuaW50ZXJwcmV0KCkoaW5uZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9iamVjdFNwZWNpZmllciB3aXRob3V0IGFuIGFubm90YXRlZFxuICAgICAgICAgKiBydWxlIG1lYW5zIGl0IHdhcyBpbnRlcnByZXRlZCBhcyBqdXN0XG4gICAgICAgICAqIGEgVGVybWluYWxTcGVjaWZpZXIgb2Ygc29tZSBzb3J0LlxuICAgICAgICAgKiBIb3dldmVyLCB3ZSBuZWVkIHRvIGV4dHJhY3QgdGhlIGlkXG4gICAgICAgICAqIGFuZCByZXR1cm4gdGhhdCByZXN1bHQsIHNpbmNlIHRoYXQgaXMgd2hhdCBpc1xuICAgICAgICAgKiBleHBlY3RlZCBvZiBhbGwgaW50ZXJwcmV0ZWQgT2JqZWN0U3BlY2lmaWVyc1xuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX3NpbmdsZVRlcm1pbmFsOiBmdW5jdGlvbih0ZXJtaW5hbFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0ZXJtaW5hbFNwZWNpZmllci5pbnRlcnByZXQoKSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIENvbXBvdW5kIHdpdGggdGVybWluYWwgc3BlY2lmaWVyIGlzIGEgUXVlcmllZFNwZWNpZmllclxuICAgICAgICAgKiB0aGF0IGZpbmlzaGVzIHdpdGggYSBUZXJtaW5hbCBzcGVjaWZpZXIuXG4gICAgICAgICAqIEV4YW1wbGU6IGBvZiBidXR0b24gMyBvZiBjYXJkIFwiU29tZSBuYW1lZCBjYXJkXCIgb2YgY3VycmVudCBzdGFja2BcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdFNwZWNpZmllcl9jb21wb3VuZFF1ZXJ5V2l0aFRlcm1pbmFsOiBmdW5jdGlvbihxdWVyaWVkU3BlY2lmaWVyLCB0ZXJtaW5hbFNwZWNpZmllcil7XG4gICAgICAgICAgICAvLyBUaGUgdGVybWluYWwgaGVyZSBpcyB0aGUgdWx0aW1hdGUgcGFydCBjb250ZXh0XG4gICAgICAgICAgICBsZXQgZmluYWxQYXJ0ID0gdGVybWluYWxTcGVjaWZpZXIuaW50ZXJwcmV0KCkoKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBxdWVyaWVkU3BlY2lmaWVyLmludGVycHJldCgpKGZpbmFsUGFydCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIENvbXBvdW5kIHdpdGhvdXQgdGVybWluYWwgc3BlY2lmaWVyIGlzIGEgUXVlcmllZFNwZWNpZmllclxuICAgICAgICAgKiB0aGF0IGZpbmlzaGVzIHdpdGggYSBQYXJ0aWFsIHNwZWNpZmllci5cbiAgICAgICAgICogRXhhbXBsZTogYG9mIGJ1dHRvbiAzIG9mIGZpcnN0IGNhcmRgICh3aGljaCBjYW4gY29udGludWUgYC4ub2YgY3VycmVudCBzdGFja2AgZXRjKVxuICAgICAgICAgKiBgZmlyc3QgYnV0dG9uIG9mIGZpcnN0IGFyZWEgb2Ygc3RhY2sgM2BcbiAgICAgICAgICogYGZpcnN0IGJ1dHRvbiBvZiBhcmVhIHR3byBvZiBzdGFjayAzYFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX2NvbXBvdW5kUXVlcnlXaXRob3V0VGVybWluYWw6IGZ1bmN0aW9uKHF1ZXJpZWRTcGVjaWZpZXIsIHBhcnRpYWxTcGVjaWZpZXIpe1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcnRpYWxTcGVjZmllciByZWZlcnMgdG8gZWl0aGVyIGFyZWEsIGNhcmQgb3Igc3RhY2tcbiAgICAgICAgICAgIC8vIHRoZW4gZ28gdG8gaXRzIG93bmVyIGZvciB0aGUgY29udGV4dFxuICAgICAgICAgICAgLy8gaWYgaXQgcmVmZXJzIHRvIHRoZSBjdXJyZW50IGNhcmQgdGhlbiBmaW5kIHRoZSBvd25lciBmb3IgdGhlIGNvbnRleHRcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHBhcnRpYWxTcGVjaWZpZXIuY2hpbGRyZW5bMF0uY2hpbGRyZW47XG4gICAgICAgICAgICBsZXQgc3lzdGVtT2JqZWN0U3RyaW5nO1xuICAgICAgICAgICAgaWYoY2hpbGRyZW5bMF0uc291cmNlU3RyaW5nID09IFwiY3VycmVudFwiICYmIGNoaWxkcmVuWzFdLnNvdXJjZVN0cmluZyA9PSBcImNhcmRcIil7XG4gICAgICAgICAgICAgICAgc3lzdGVtT2JqZWN0U3RyaW5nID0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkLmN0b3JOYW1lID09IFwic3lzdGVtT2JqZWN0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3lzdGVtT2JqZWN0U3RyaW5nID0gY2hpbGQuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmluYWxQYXJ0ID0gZmluZEZpcnN0UG9zc2libGVBbmNlc3RvcihwYXJ0Q29udGV4dCwgc3lzdGVtT2JqZWN0U3RyaW5nKTtcbiAgICAgICAgICAgIGxldCBmaW5hbFBhcnRpYWwgPSBwYXJ0aWFsU3BlY2lmaWVyLmludGVycHJldCgpKGZpbmFsUGFydCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcXVlcmllZFNwZWNpZmllci5pbnRlcnByZXQoKShmaW5hbFBhcnRpYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaW5nbGUgbm9uLXRlcm1pbmFsIE9iamVjdFNwZWNpZmllciBpcyBqdXN0IGEgUGFydGlhbFxuICAgICAgICAgKiBzcGVjaWZpZXIgYnkgaXRzZWxmLiBXaGVuIHByZXNlbnQgb3V0c2lkZSBvZiBhIFF1ZXJpZWRTcGVjaWZpZXIsXG4gICAgICAgICAqIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgdHJlYXRlZFxuICAgICAgICAgKiBhcyB0ZXJtaW5hbC9maW5hbC4gRm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAgICBidXR0b24gNFxuICAgICAgICAgKiBieSBpdHNlbGYgYXMgYSB3aG9sZSBzcGVjaWZpZXIgd2lsbCBiZSBpbnRlcnByZXRlZCBhc1xuICAgICAgICAgKiBgYnV0dG9uIDQgb2YgdGhpcyBjYXJkYFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX3NpbmdsZU5vblRlcm1pbmFsOiBmdW5jdGlvbihwYXJ0aWFsU3BlY2lmaWVyKXtcbiAgICAgICAgICAgIC8vIEEgc2luZ2xlIG5vbi10ZXJtaW5hbCBvYmplY3Qgc3BlY2lmaWVyIGlzIG9uZVxuICAgICAgICAgICAgLy8gd2hvc2UgdGVybWluYWwgb2JqZWN0IGlzIGltcGxpY2l0bHkgYXNzdW1lZCB0b1xuICAgICAgICAgICAgLy8gYmUgdGhlIGNhcmQgb3IgdGhlIHN0YWNrIGluIHdoaWNoIHRoZSBjdXJyZW50IGNvbnRleHQgcGFydFxuICAgICAgICAgICAgLy8gZXhpc3RzLlxuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gcGFydGlhbFNwZWNpZmllci5jaGlsZHJlblswXS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGxldCBzeXN0ZW1PYmplY3RTdHJpbmc7XG4gICAgICAgICAgICBpZihjaGlsZHJlblswXS5zb3VyY2VTdHJpbmcgPT0gXCJjdXJyZW50XCIgJiYgY2hpbGRyZW5bMV0uc291cmNlU3RyaW5nID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtQ29udGV4dC5nZXRDdXJyZW50Q2FyZE1vZGVsKCkuaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkLnNvdXJjZVN0cmluZyA9PSBcInBhcnRcIiB8fCBjaGlsZC5zb3VyY2VTdHJpbmcgPT0gXCJ0YXJnZXRcIiB8fCBjaGlsZC5jdG9yTmFtZSA9PSAnc3lzdGVtT2JqZWN0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeXN0ZW1PYmplY3RTdHJpbmcgPSBjaGlsZC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBzeXN0ZW1PYmplY3QgaXMgdGhlIHRhcmdldCAoZGVmaW5lZCBpbiBpdCdzIFwidGFyZ2V0XCIgcGFydCBwcm9wZXJ0eSksIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZmlyc3QgZ2V0IHRoZSB0YXJnZXQgcHJvcGVydHkgdmFsdWUgKHN0cmluZykgYW5kIGludGVycHJldCB0aGF0XG4gICAgICAgICAgICBpZihzeXN0ZW1PYmplY3RTdHJpbmcgPT0gXCJ0YXJnZXRcIil7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFByb3BWYWx1ZSA9IHBhcnRDb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQocGFydENvbnRleHQsIFwidGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgIGxldCBzZW1hbnRpY3MgPSBwYXJ0Q29udGV4dC5fc2VtYW50aWNzO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaE9iamVjdCA9IHN5c3RlbUNvbnRleHQuZ3JhbW1hci5tYXRjaCh0YXJnZXRQcm9wVmFsdWUsICdPYmplY3RTcGVjaWZpZXInKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobWF0Y2hPYmplY3QpLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRJZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZihzeXN0ZW1PYmplY3RTdHJpbmcgPT0gXCJjdXJyZW50IGNhcmRcIil7XG4gICAgICAgICAgICAgICAgc3lzdGVtT2JqZWN0U3RyaW5nID0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmluYWxQYXJ0ID0gZmluZEZpcnN0UG9zc2libGVBbmNlc3RvcihwYXJ0Q29udGV4dCwgc3lzdGVtT2JqZWN0U3RyaW5nKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJ0aWFsU3BlY2lmaWVyLmludGVycHJldCgpKGZpbmFsUGFydCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdFNwZWNpZmllcl9zaW5nbGVUZXJtaW5hbDogZnVuY3Rpb24odGVybWluYWxTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRlcm1pbmFsU3BlY2lmaWVyLmludGVycHJldCgpKHBhcnRDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW55TGl0ZXJhbDogZnVuY3Rpb24odGhlTGl0ZXJhbCl7XG4gICAgICAgICAgICByZXR1cm4gdGhlTGl0ZXJhbC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmdMaXRlcmFsOiBmdW5jdGlvbihvcGVuUXVvdGUsIHRleHQsIGNsb3NlUXVvdGUpe1xuICAgICAgICAgICAgcmV0dXJuIHRleHQuc291cmNlU3RyaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJvb2xlYW5MaXRlcmFsOiBmdW5jdGlvbih0ZXh0KXtcbiAgICAgICAgICAgIGlmKHRleHQuc291cmNlU3RyaW5nID09ICd0cnVlJyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0ZXh0LnNvdXJjZVN0cmluZyA9PSAnZmFsc2UnKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm9vbGVhbiBsaXRlcmFsOiAke3RleHR9YCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZWdlckxpdGVyYWw6IGZ1bmN0aW9uKG5lZ2F0aXZlU2lnbiwgaW50ZWdlcil7XG4gICAgICAgICAgICBsZXQgaW50ID0gcGFyc2VJbnQoaW50ZWdlci5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IGhhc05lZ2F0aXZlID0gKG5lZ2F0aXZlU2lnbi5zb3VyY2VTdHJpbmcgPT0gXCItXCIpO1xuICAgICAgICAgICAgaWYoaGFzTmVnYXRpdmUpe1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIGludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnQ7IFxuICAgICAgICB9LFxuXG4gICAgICAgIGZsb2F0TGl0ZXJhbDogZnVuY3Rpb24obmVnYXRpdmVTaWduLCBvbmVzUGxhY2UsIGRlY2ltYWwsIHJlc3RQbGFjZSl7XG4gICAgICAgICAgICBsZXQgZmxvYXRTdHJpbmcgPSBgJHtvbmVzUGxhY2Uuc291cmNlU3RyaW5nfS4ke3Jlc3RQbGFjZS5zb3VyY2VTdHJpbmd9YDtcbiAgICAgICAgICAgIGxldCBoYXNOZWdhdGl2ZSA9IChuZWdhdGl2ZVNpZ24uc291cmNlU3RyaW5nID09IFwiLVwiKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZsb2F0KGZsb2F0U3RyaW5nKTtcbiAgICAgICAgICAgIGlmKGhhc05lZ2F0aXZlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIG51bWVyaWNhbEtleXdvcmQ6IGZ1bmN0aW9uKG51bWVyYWxOYW1lKXtcbiAgICAgICAgICAgIHN3aXRjaChudW1lcmFsTmFtZS5zb3VyY2VTdHJpbmcpe1xuICAgICAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIGNhc2UgJ3RoaXJkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIGNhc2UgJ2ZvdXJ0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICBjYXNlICdmaWZ0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICBjYXNlICdzaXh0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICBjYXNlICdzZXZlbnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgICAgIGNhc2UgJ2VpZ2h0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgICBjYXNlICduaW50aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICBjYXNlICd0ZW50aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFyaWFibGVOYW1lOiBmdW5jdGlvbihsZXR0ZXJQbHVzLCBvcHRpb25hbERpZ2l0cyl7XG4gICAgICAgICAgICAvLyBMb29rdXAgdGhlIHZhcmlhYmxlIGluIHRoZSBwYXJ0J3NcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YXJpYWJsZSBpcyBub3QgYSBrZXkgb24gdGhlIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHdlIHRocm93IGFuIGVycm9yOiB0aGlzIG1lYW5zIHRoZSB2YXJpYWJsZSBoYXMgbm90IHlldFxuICAgICAgICAgICAgLy8gYmVlbiBkZWZpbmVkIGJ1dCBpcyBiZWluZyBsb29rZWQgdXAuXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzeXN0ZW1Db250ZXh0LmV4ZWN1dGlvblN0YWNrLmN1cnJlbnQuZ2V0KHRoaXMuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgIGlmKHZhbHVlID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNUVmFyaWFibGVSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFZhcmlhYmxlICR7dGhpcy5zb3VyY2VTdHJpbmd9IGhhcyBub3QgYmVlbiBkZWZpbmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWVudDogZnVuY3Rpb24oZGFzaGVzTGl0ZXJhbCwgbm9uTGluZVRlcm1pbmF0b3JDaGFycyl7XG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgZG9lc24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgLy8gd2l0aCBjb21tZW50cy5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF90ZXJtaW5hbCgpe1xuXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuXG5leHBvcnQge1xuICAgIGNyZWF0ZUludGVycHJldGVyU2VtYW50aWNzLFxuICAgIGNyZWF0ZUludGVycHJldGVyU2VtYW50aWNzIGFzIGRlZmF1bHRcbn07XG4iLCJ2YXIgb2htID0gcmVxdWlyZSgnLi4nKTtcbm1vZHVsZS5leHBvcnRzID0gb2htLm1ha2VSZWNpcGUoW1wiZ3JhbW1hclwiLHtcInNvdXJjZVwiOlwiQnVpbHRJblJ1bGVzIHtcXG5cXG4gIGFsbnVtICAoYW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXIpXFxuICAgID0gbGV0dGVyXFxuICAgIHwgZGlnaXRcXG5cXG4gIGxldHRlciAgKGEgbGV0dGVyKVxcbiAgICA9IGxvd2VyXFxuICAgIHwgdXBwZXJcXG4gICAgfCB1bmljb2RlTHRtb1xcblxcbiAgZGlnaXQgIChhIGRpZ2l0KVxcbiAgICA9IFxcXCIwXFxcIi4uXFxcIjlcXFwiXFxuXFxuICBoZXhEaWdpdCAgKGEgaGV4YWRlY2ltYWwgZGlnaXQpXFxuICAgID0gZGlnaXRcXG4gICAgfCBcXFwiYVxcXCIuLlxcXCJmXFxcIlxcbiAgICB8IFxcXCJBXFxcIi4uXFxcIkZcXFwiXFxuXFxuICBMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IE5vbmVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgfCBFbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuXFxuICBOb25lbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gZWxlbSAoc2VwIGVsZW0pKlxcblxcbiAgRW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IC8qIG5vdGhpbmcgKi9cXG5cXG4gIGxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gbm9uZW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICB8IGVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG5cXG4gIG5vbmVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgPSBlbGVtIChzZXAgZWxlbSkqXFxuXFxuICBlbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gLyogbm90aGluZyAqL1xcblxcbn1cIn0sXCJCdWlsdEluUnVsZXNcIixudWxsLG51bGwse1wiYWxudW1cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOCw3OF19LFwiYW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJcIixbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MCw3OF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYwLDY2XX0sXCJsZXR0ZXJcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzMsNzhdfSxcImRpZ2l0XCIsW11dXV0sXCJsZXR0ZXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MiwxNDJdfSxcImEgbGV0dGVyXCIsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA3LDE0Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNywxMTJdfSxcImxvd2VyXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExOSwxMjRdfSxcInVwcGVyXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwxNDJdfSxcInVuaWNvZGVMdG1vXCIsW11dXV0sXCJkaWdpdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NiwxNzddfSxcImEgZGlnaXRcIixbXSxbXCJyYW5nZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2OSwxNzddfSxcIjBcIixcIjlcIl1dLFwiaGV4RGlnaXRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODEsMjU0XX0sXCJhIGhleGFkZWNpbWFsIGRpZ2l0XCIsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE5LDI1NF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxOSwyMjRdfSxcImRpZ2l0XCIsW11dLFtcInJhbmdlXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMxLDIzOV19LFwiYVwiLFwiZlwiXSxbXCJyYW5nZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NiwyNTRdfSxcIkFcIixcIkZcIl1dXSxcIkxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1OCwzMzZdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyODIsMzM2XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjgyLDMwN119LFwiTm9uZW1wdHlMaXN0T2ZcIixbW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyOTcsMzAxXX0sMF0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMDMsMzA2XX0sMV1dXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMTQsMzM2XX0sXCJFbXB0eUxpc3RPZlwiLFtbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzMyNiwzMzBdfSwwXSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzMzMiwzMzVdfSwxXV1dXV0sXCJOb25lbXB0eUxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM0MCwzODhdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzIsMzg4XX0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzIsMzc2XX0sMF0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzM3NywzODhdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzgsMzg2XX0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzgsMzgxXX0sMV0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODIsMzg2XX0sMF1dXV1dLFwiRW1wdHlMaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszOTIsNDM0XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDM4LDQzOF19XV0sXCJsaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0MzgsNTE2XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDYyLDUxNl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ2Miw0ODddfSxcIm5vbmVtcHR5TGlzdE9mXCIsW1tcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDc3LDQ4MV19LDBdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDgzLDQ4Nl19LDFdXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDk0LDUxNl19LFwiZW1wdHlMaXN0T2ZcIixbW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MDYsNTEwXX0sMF0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MTIsNTE1XX0sMV1dXV1dLFwibm9uZW1wdHlMaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MjAsNTY4XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTUyLDU2OF19LFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTUyLDU1Nl19LDBdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NTcsNTY4XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTU4LDU2Nl19LFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTU4LDU2MV19LDFdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTYyLDU2Nl19LDBdXV1dXSxcImVtcHR5TGlzdE9mXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTcyLDYxNF19LG51bGwsW1wiZWxlbVwiLFwic2VwXCJdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzYxNiw2MTZdfV1dfV0pO1xuIiwidmFyIG9obSA9IHJlcXVpcmUoJy4uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG9obS5tYWtlUmVjaXBlKFtcImdyYW1tYXJcIix7XCJzb3VyY2VcIjpcIk9obSB7XFxuXFxuICBHcmFtbWFyc1xcbiAgICA9IEdyYW1tYXIqXFxuXFxuICBHcmFtbWFyXFxuICAgID0gaWRlbnQgU3VwZXJHcmFtbWFyPyBcXFwie1xcXCIgUnVsZSogXFxcIn1cXFwiXFxuXFxuICBTdXBlckdyYW1tYXJcXG4gICAgPSBcXFwiPDpcXFwiIGlkZW50XFxuXFxuICBSdWxlXFxuICAgID0gaWRlbnQgRm9ybWFscz8gcnVsZURlc2NyPyBcXFwiPVxcXCIgIFJ1bGVCb2R5ICAtLSBkZWZpbmVcXG4gICAgfCBpZGVudCBGb3JtYWxzPyAgICAgICAgICAgIFxcXCI6PVxcXCIgT3ZlcnJpZGVSdWxlQm9keSAgLS0gb3ZlcnJpZGVcXG4gICAgfCBpZGVudCBGb3JtYWxzPyAgICAgICAgICAgIFxcXCIrPVxcXCIgUnVsZUJvZHkgIC0tIGV4dGVuZFxcblxcbiAgUnVsZUJvZHlcXG4gICAgPSBcXFwifFxcXCI/IE5vbmVtcHR5TGlzdE9mPFRvcExldmVsVGVybSwgXFxcInxcXFwiPlxcblxcbiAgVG9wTGV2ZWxUZXJtXFxuICAgID0gU2VxIGNhc2VOYW1lICAtLSBpbmxpbmVcXG4gICAgfCBTZXFcXG5cXG4gIE92ZXJyaWRlUnVsZUJvZHlcXG4gICAgPSBcXFwifFxcXCI/IE5vbmVtcHR5TGlzdE9mPE92ZXJyaWRlVG9wTGV2ZWxUZXJtLCBcXFwifFxcXCI+XFxuXFxuICBPdmVycmlkZVRvcExldmVsVGVybVxcbiAgICA9IFxcXCIuLi5cXFwiICAtLSBzdXBlclNwbGljZVxcbiAgICB8IFRvcExldmVsVGVybVxcblxcbiAgRm9ybWFsc1xcbiAgICA9IFxcXCI8XFxcIiBMaXN0T2Y8aWRlbnQsIFxcXCIsXFxcIj4gXFxcIj5cXFwiXFxuXFxuICBQYXJhbXNcXG4gICAgPSBcXFwiPFxcXCIgTGlzdE9mPFNlcSwgXFxcIixcXFwiPiBcXFwiPlxcXCJcXG5cXG4gIEFsdFxcbiAgICA9IE5vbmVtcHR5TGlzdE9mPFNlcSwgXFxcInxcXFwiPlxcblxcbiAgU2VxXFxuICAgID0gSXRlcipcXG5cXG4gIEl0ZXJcXG4gICAgPSBQcmVkIFxcXCIqXFxcIiAgLS0gc3RhclxcbiAgICB8IFByZWQgXFxcIitcXFwiICAtLSBwbHVzXFxuICAgIHwgUHJlZCBcXFwiP1xcXCIgIC0tIG9wdFxcbiAgICB8IFByZWRcXG5cXG4gIFByZWRcXG4gICAgPSBcXFwiflxcXCIgTGV4ICAtLSBub3RcXG4gICAgfCBcXFwiJlxcXCIgTGV4ICAtLSBsb29rYWhlYWRcXG4gICAgfCBMZXhcXG5cXG4gIExleFxcbiAgICA9IFxcXCIjXFxcIiBCYXNlICAtLSBsZXhcXG4gICAgfCBCYXNlXFxuXFxuICBCYXNlXFxuICAgID0gaWRlbnQgUGFyYW1zPyB+KHJ1bGVEZXNjcj8gXFxcIj1cXFwiIHwgXFxcIjo9XFxcIiB8IFxcXCIrPVxcXCIpICAtLSBhcHBsaWNhdGlvblxcbiAgICB8IG9uZUNoYXJUZXJtaW5hbCBcXFwiLi5cXFwiIG9uZUNoYXJUZXJtaW5hbCAgICAgICAgICAgLS0gcmFuZ2VcXG4gICAgfCB0ZXJtaW5hbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIHRlcm1pbmFsXFxuICAgIHwgXFxcIihcXFwiIEFsdCBcXFwiKVxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBwYXJlblxcblxcbiAgcnVsZURlc2NyICAoYSBydWxlIGRlc2NyaXB0aW9uKVxcbiAgICA9IFxcXCIoXFxcIiBydWxlRGVzY3JUZXh0IFxcXCIpXFxcIlxcblxcbiAgcnVsZURlc2NyVGV4dFxcbiAgICA9ICh+XFxcIilcXFwiIGFueSkqXFxuXFxuICBjYXNlTmFtZVxcbiAgICA9IFxcXCItLVxcXCIgKH5cXFwiXFxcXG5cXFwiIHNwYWNlKSogbmFtZSAoflxcXCJcXFxcblxcXCIgc3BhY2UpKiAoXFxcIlxcXFxuXFxcIiB8ICZcXFwifVxcXCIpXFxuXFxuICBuYW1lICAoYSBuYW1lKVxcbiAgICA9IG5hbWVGaXJzdCBuYW1lUmVzdCpcXG5cXG4gIG5hbWVGaXJzdFxcbiAgICA9IFxcXCJfXFxcIlxcbiAgICB8IGxldHRlclxcblxcbiAgbmFtZVJlc3RcXG4gICAgPSBcXFwiX1xcXCJcXG4gICAgfCBhbG51bVxcblxcbiAgaWRlbnQgIChhbiBpZGVudGlmaWVyKVxcbiAgICA9IG5hbWVcXG5cXG4gIHRlcm1pbmFsXFxuICAgID0gXFxcIlxcXFxcXFwiXFxcIiB0ZXJtaW5hbENoYXIqIFxcXCJcXFxcXFxcIlxcXCJcXG5cXG4gIG9uZUNoYXJUZXJtaW5hbFxcbiAgICA9IFxcXCJcXFxcXFxcIlxcXCIgdGVybWluYWxDaGFyIFxcXCJcXFxcXFxcIlxcXCJcXG5cXG4gIHRlcm1pbmFsQ2hhclxcbiAgICA9IGVzY2FwZUNoYXJcXG4gICAgfCB+XFxcIlxcXFxcXFxcXFxcIiB+XFxcIlxcXFxcXFwiXFxcIiB+XFxcIlxcXFxuXFxcIiBhbnlcXG5cXG4gIGVzY2FwZUNoYXIgIChhbiBlc2NhcGUgc2VxdWVuY2UpXFxuICAgID0gXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIGJhY2tzbGFzaFxcbiAgICB8IFxcXCJcXFxcXFxcXFxcXFxcXFwiXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBkb3VibGVRdW90ZVxcbiAgICB8IFxcXCJcXFxcXFxcXFxcXFwnXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBzaW5nbGVRdW90ZVxcbiAgICB8IFxcXCJcXFxcXFxcXGJcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBiYWNrc3BhY2VcXG4gICAgfCBcXFwiXFxcXFxcXFxuXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gbGluZUZlZWRcXG4gICAgfCBcXFwiXFxcXFxcXFxyXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gY2FycmlhZ2VSZXR1cm5cXG4gICAgfCBcXFwiXFxcXFxcXFx0XFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gdGFiXFxuICAgIHwgXFxcIlxcXFxcXFxcdVxcXCIgaGV4RGlnaXQgaGV4RGlnaXQgaGV4RGlnaXQgaGV4RGlnaXQgIC0tIHVuaWNvZGVFc2NhcGVcXG4gICAgfCBcXFwiXFxcXFxcXFx4XFxcIiBoZXhEaWdpdCBoZXhEaWdpdCAgICAgICAgICAgICAgICAgICAgLS0gaGV4RXNjYXBlXFxuXFxuICBzcGFjZVxcbiAgICs9IGNvbW1lbnRcXG5cXG4gIGNvbW1lbnRcXG4gICAgPSBcXFwiLy9cXFwiICh+XFxcIlxcXFxuXFxcIiBhbnkpKiAmKFxcXCJcXFxcblxcXCIgfCBlbmQpICAtLSBzaW5nbGVMaW5lXFxuICAgIHwgXFxcIi8qXFxcIiAoflxcXCIqL1xcXCIgYW55KSogXFxcIiovXFxcIiAgLS0gbXVsdGlMaW5lXFxuXFxuICB0b2tlbnMgPSB0b2tlbipcXG5cXG4gIHRva2VuID0gY2FzZU5hbWUgfCBjb21tZW50IHwgaWRlbnQgfCBvcGVyYXRvciB8IHB1bmN0dWF0aW9uIHwgdGVybWluYWwgfCBhbnlcXG5cXG4gIG9wZXJhdG9yID0gXFxcIjw6XFxcIiB8IFxcXCI9XFxcIiB8IFxcXCI6PVxcXCIgfCBcXFwiKz1cXFwiIHwgXFxcIipcXFwiIHwgXFxcIitcXFwiIHwgXFxcIj9cXFwiIHwgXFxcIn5cXFwiIHwgXFxcIiZcXFwiXFxuXFxuICBwdW5jdHVhdGlvbiA9IFxcXCI8XFxcIiB8IFxcXCI+XFxcIiB8IFxcXCIsXFxcIiB8IFxcXCItLVxcXCJcXG59XCJ9LFwiT2htXCIsbnVsbCxcIkdyYW1tYXJzXCIse1wiR3JhbW1hcnNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5LDMyXX0sbnVsbCxbXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQsMzJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNCwzMV19LFwiR3JhbW1hclwiLFtdXV1dLFwiR3JhbW1hclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM2LDgzXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MCw4M119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzUwLDU1XX0sXCJpZGVudFwiLFtdXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1Niw2OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU2LDY4XX0sXCJTdXBlckdyYW1tYXJcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzAsNzNdfSxcIntcIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0LDc5XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQsNzhdfSxcIlJ1bGVcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODAsODNdfSxcIn1cIl1dXSxcIlN1cGVyR3JhbW1hclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3LDExNl19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA2LDExNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA2LDExMF19LFwiPDpcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExLDExNl19LFwiaWRlbnRcIixbXV1dXSxcIlJ1bGVfZGVmaW5lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDE4MV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDE3MF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwxMzZdfSxcImlkZW50XCIsW11dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNywxNDVdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzcsMTQ0XX0sXCJGb3JtYWxzXCIsW11dXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDYsMTU2XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ2LDE1NV19LFwicnVsZURlc2NyXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NywxNjBdfSxcIj1cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYyLDE3MF19LFwiUnVsZUJvZHlcIixbXV1dXSxcIlJ1bGVfb3ZlcnJpZGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODgsMjQ4XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODgsMjM1XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg4LDE5M119LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk0LDIwMl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5NCwyMDFdfSxcIkZvcm1hbHNcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE0LDIxOF19LFwiOj1cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE5LDIzNV19LFwiT3ZlcnJpZGVSdWxlQm9keVwiLFtdXV1dLFwiUnVsZV9leHRlbmRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTUsMzA1XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTUsMjk0XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU1LDI2MF19LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjYxLDI2OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI2MSwyNjhdfSxcIkZvcm1hbHNcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjgxLDI4NV19LFwiKz1cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjg2LDI5NF19LFwiUnVsZUJvZHlcIixbXV1dXSxcIlJ1bGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjAsMzA1XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEsMzA1XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDE3MF19LFwiUnVsZV9kZWZpbmVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg4LDIzNV19LFwiUnVsZV9vdmVycmlkZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTUsMjk0XX0sXCJSdWxlX2V4dGVuZFwiLFtdXV1dLFwiUnVsZUJvZHlcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMDksMzYyXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMjQsMzYyXX0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI0LDMyOF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI0LDMyN119LFwifFwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI5LDM2Ml19LFwiTm9uZW1wdHlMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzQ0LDM1Nl19LFwiVG9wTGV2ZWxUZXJtXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzU4LDM2MV19LFwifFwiXV1dXV0sXCJUb3BMZXZlbFRlcm1faW5saW5lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDQwOF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDM5N119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4NSwzODhdfSxcIlNlcVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODksMzk3XX0sXCJjYXNlTmFtZVwiLFtdXV1dLFwiVG9wTGV2ZWxUZXJtXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzY2LDQxOF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDQxOF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4NSwzOTddfSxcIlRvcExldmVsVGVybV9pbmxpbmVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDE1LDQxOF19LFwiU2VxXCIsW11dXV0sXCJPdmVycmlkZVJ1bGVCb2R5XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDIyLDQ5MV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDQ1LDQ5MV19LFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ0NSw0NDldfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ0NSw0NDhdfSxcInxcIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ1MCw0OTFdfSxcIk5vbmVtcHR5TGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ2NSw0ODVdfSxcIk92ZXJyaWRlVG9wTGV2ZWxUZXJtXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDg3LDQ5MF19LFwifFwiXV1dXV0sXCJPdmVycmlkZVRvcExldmVsVGVybV9zdXBlclNwbGljZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzUyMiw1NDNdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTIyLDUyN119LFwiLi4uXCJdXSxcIk92ZXJyaWRlVG9wTGV2ZWxUZXJtXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDk1LDU2Ml19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTIyLDU2Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzUyMiw1MjddfSxcIk92ZXJyaWRlVG9wTGV2ZWxUZXJtX3N1cGVyU3BsaWNlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU1MCw1NjJdfSxcIlRvcExldmVsVGVybVwiLFtdXV1dLFwiRm9ybWFsc1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU2Niw2MDZdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU4MCw2MDZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU4MCw1ODNdfSxcIjxcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTg0LDYwMl19LFwiTGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU5MSw1OTZdfSxcImlkZW50XCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTk4LDYwMV19LFwiLFwiXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjAzLDYwNl19LFwiPlwiXV1dLFwiUGFyYW1zXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjEwLDY0N119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjIzLDY0N119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjIzLDYyNl19LFwiPFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MjcsNjQzXX0sXCJMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjM0LDYzN119LFwiU2VxXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjM5LDY0Ml19LFwiLFwiXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjQ0LDY0N119LFwiPlwiXV1dLFwiQWx0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjUxLDY4NV19LG51bGwsW10sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjYxLDY4NV19LFwiTm9uZW1wdHlMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjc2LDY3OV19LFwiU2VxXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjgxLDY4NF19LFwifFwiXV1dXSxcIlNlcVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzY4OSw3MDRdfSxudWxsLFtdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2OTksNzA0XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjk5LDcwM119LFwiSXRlclwiLFtdXV1dLFwiSXRlcl9zdGFyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDczNl19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDcyN119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzcxOSw3MjNdfSxcIlByZWRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MjQsNzI3XX0sXCIqXCJdXV0sXCJJdGVyX3BsdXNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDMsNzYwXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDMsNzUxXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQzLDc0N119LFwiUHJlZFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0OCw3NTFdfSxcIitcIl1dXSxcIkl0ZXJfb3B0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzY3LDc4M119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzY3LDc3NV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc2Nyw3NzFdfSxcIlByZWRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NzIsNzc1XX0sXCI/XCJdXV0sXCJJdGVyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzA4LDc5NF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDc5NF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzcxOSw3MjddfSxcIkl0ZXJfc3RhclwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDMsNzUxXX0sXCJJdGVyX3BsdXNcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzY3LDc3NV19LFwiSXRlcl9vcHRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzkwLDc5NF19LFwiUHJlZFwiLFtdXV1dLFwiUHJlZF9ub3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODI0XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODE2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODEyXX0sXCJ+XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgxMyw4MTZdfSxcIkxleFwiLFtdXV1dLFwiUHJlZF9sb29rYWhlYWRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODUyXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODM4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODM0XX0sXCImXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgzNSw4MzhdfSxcIkxleFwiLFtdXV1dLFwiUHJlZFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc5OCw4NjJdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgwOSw4NjJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODE2XX0sXCJQcmVkX25vdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODM4XX0sXCJQcmVkX2xvb2thaGVhZFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NTksODYyXX0sXCJMZXhcIixbXV1dXSxcIkxleF9sZXhcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODkyXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODg0XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODc5XX0sXCIjXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg4MCw4ODRdfSxcIkJhc2VcIixbXV1dXSxcIkxleFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg2Niw5MDNdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3Niw5MDNdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODg0XX0sXCJMZXhfbGV4XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg5OSw5MDNdfSxcIkJhc2VcIixbXV1dXSxcIkJhc2VfYXBwbGljYXRpb25cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MTgsOTc5XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MTgsOTYzXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTE4LDkyM119LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTI0LDkzMV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkyNCw5MzBdfSxcIlBhcmFtc1wiLFtdXV0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTMyLDk2M119LFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkzNCw5NjJdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MzQsOTQ4XX0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTM0LDk0NF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkzNCw5NDNdfSxcInJ1bGVEZXNjclwiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5NDUsOTQ4XX0sXCI9XCJdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk1MSw5NTVdfSxcIjo9XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTU4LDk2Ml19LFwiKz1cIl1dXV1dLFwiQmFzZV9yYW5nZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk4NiwxMDQxXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5ODYsMTAyMl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk4NiwxMDAxXX0sXCJvbmVDaGFyVGVybWluYWxcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDAyLDEwMDZdfSxcIi4uXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwMDcsMTAyMl19LFwib25lQ2hhclRlcm1pbmFsXCIsW11dXV0sXCJCYXNlX3Rlcm1pbmFsXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA0OCwxMTA2XX0sbnVsbCxbXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDQ4LDEwNTZdfSxcInRlcm1pbmFsXCIsW11dXSxcIkJhc2VfcGFyZW5cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTEzLDExNjhdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMTMsMTEyNF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExMywxMTE2XX0sXCIoXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMTcsMTEyMF19LFwiQWx0XCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTEyMSwxMTI0XX0sXCIpXCJdXV0sXCJCYXNlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTA3LDExNjhdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkxOCwxMTY4XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTE4LDk2M119LFwiQmFzZV9hcHBsaWNhdGlvblwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5ODYsMTAyMl19LFwiQmFzZV9yYW5nZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDQ4LDEwNTZdfSxcIkJhc2VfdGVybWluYWxcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExMywxMTI0XX0sXCJCYXNlX3BhcmVuXCIsW11dXV0sXCJydWxlRGVzY3JcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTcyLDEyMzFdfSxcImEgcnVsZSBkZXNjcmlwdGlvblwiLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMTAsMTIzMV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIxMCwxMjEzXX0sXCIoXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMTQsMTIyN119LFwicnVsZURlc2NyVGV4dFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMjgsMTIzMV19LFwiKVwiXV1dLFwicnVsZURlc2NyVGV4dFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMzUsMTI2Nl19LG51bGwsW10sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNTUsMTI2Nl19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNTYsMTI2NF19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNTYsMTI2MF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI1NywxMjYwXX0sXCIpXCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjYxLDEyNjRdfSxcImFueVwiLFtdXV1dXSxcImNhc2VOYW1lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI3MCwxMzM4XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjg1LDEzMzhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyODUsMTI4OV19LFwiLS1cIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTAsMTMwNF19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTEsMTMwMl19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTEsMTI5Nl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5MiwxMjk2XX0sXCJcXG5cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTcsMTMwMl19LFwic3BhY2VcIixbXV1dXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzA1LDEzMDldfSxcIm5hbWVcIixbXV0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTAsMTMyNF19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTEsMTMyMl19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTEsMTMxNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxMiwxMzE2XX0sXCJcXG5cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTcsMTMyMl19LFwic3BhY2VcIixbXV1dXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzI2LDEzMzddfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMjYsMTMzMF19LFwiXFxuXCJdLFtcImxvb2thaGVhZFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMzMsMTMzN119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMzNCwxMzM3XX0sXCJ9XCJdXV1dXSxcIm5hbWVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzQyLDEzODJdfSxcImEgbmFtZVwiLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNjMsMTM4Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNjMsMTM3Ml19LFwibmFtZUZpcnN0XCIsW11dLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzczLDEzODJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzczLDEzODFdfSxcIm5hbWVSZXN0XCIsW11dXV1dLFwibmFtZUZpcnN0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM4NiwxNDE4XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDAyLDE0MThdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MDIsMTQwNV19LFwiX1wiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDEyLDE0MThdfSxcImxldHRlclwiLFtdXV1dLFwibmFtZVJlc3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDIyLDE0NTJdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MzcsMTQ1Ml19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQzNywxNDQwXX0sXCJfXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NDcsMTQ1Ml19LFwiYWxudW1cIixbXV1dXSxcImlkZW50XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ1NiwxNDg5XX0sXCJhbiBpZGVudGlmaWVyXCIsW10sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ4NSwxNDg5XX0sXCJuYW1lXCIsW11dXSxcInRlcm1pbmFsXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ5MywxNTMxXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTA4LDE1MzFdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1MDgsMTUxMl19LFwiXFxcIlwiXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUxMywxNTI2XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUxMywxNTI1XX0sXCJ0ZXJtaW5hbENoYXJcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUyNywxNTMxXX0sXCJcXFwiXCJdXV0sXCJvbmVDaGFyVGVybWluYWxcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTM1LDE1NzldfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NTcsMTU3OV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU1NywxNTYxXX0sXCJcXFwiXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NjIsMTU3NF19LFwidGVybWluYWxDaGFyXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU3NSwxNTc5XX0sXCJcXFwiXCJdXV0sXCJ0ZXJtaW5hbENoYXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTgzLDE2NDBdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MDIsMTY0MF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MDIsMTYxMl19LFwiZXNjYXBlQ2hhclwiLFtdXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjE5LDE2NDBdfSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjE5LDE2MjRdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MjAsMTYyNF19LFwiXFxcXFwiXV0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYyNSwxNjMwXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjI2LDE2MzBdfSxcIlxcXCJcIl1dLFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MzEsMTYzNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYzMiwxNjM2XX0sXCJcXG5cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MzcsMTY0MF19LFwiYW55XCIsW11dXV1dLFwiZXNjYXBlQ2hhcl9iYWNrc2xhc2hcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgzLDE3MzhdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4MywxNjg5XX0sXCJcXFxcXFxcXFwiXV0sXCJlc2NhcGVDaGFyX2RvdWJsZVF1b3RlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTc0NSwxODAyXX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE3NDUsMTc1MV19LFwiXFxcXFxcXCJcIl1dLFwiZXNjYXBlQ2hhcl9zaW5nbGVRdW90ZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4MDksMTg2Nl19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODA5LDE4MTVdfSxcIlxcXFwnXCJdXSxcImVzY2FwZUNoYXJfYmFja3NwYWNlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg3MywxOTI4XX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4NzMsMTg3OF19LFwiXFxcXGJcIl1dLFwiZXNjYXBlQ2hhcl9saW5lRmVlZFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5MzUsMTk4OV19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTM1LDE5NDBdfSxcIlxcXFxuXCJdXSxcImVzY2FwZUNoYXJfY2FycmlhZ2VSZXR1cm5cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTk2LDIwNTZdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk5NiwyMDAxXX0sXCJcXFxcclwiXV0sXCJlc2NhcGVDaGFyX3RhYlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIwNjMsMjExMl19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDYzLDIwNjhdfSxcIlxcXFx0XCJdXSxcImVzY2FwZUNoYXJfdW5pY29kZUVzY2FwZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMTksMjE3OF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjExOSwyMTYwXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTE5LDIxMjRdfSxcIlxcXFx1XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMjUsMjEzM119LFwiaGV4RGlnaXRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjEzNCwyMTQyXX0sXCJoZXhEaWdpdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTQzLDIxNTFdfSxcImhleERpZ2l0XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxNTIsMjE2MF19LFwiaGV4RGlnaXRcIixbXV1dXSxcImVzY2FwZUNoYXJfaGV4RXNjYXBlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE4NSwyMjQwXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTg1LDIyMDhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxODUsMjE5MF19LFwiXFxcXHhcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE5MSwyMTk5XX0sXCJoZXhEaWdpdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjAwLDIyMDhdfSxcImhleERpZ2l0XCIsW11dXV0sXCJlc2NhcGVDaGFyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY0NCwyMjQwXX0sXCJhbiBlc2NhcGUgc2VxdWVuY2VcIixbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgzLDIyNDBdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgzLDE2ODldfSxcImVzY2FwZUNoYXJfYmFja3NsYXNoXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE3NDUsMTc1MV19LFwiZXNjYXBlQ2hhcl9kb3VibGVRdW90ZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODA5LDE4MTVdfSxcImVzY2FwZUNoYXJfc2luZ2xlUXVvdGVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg3MywxODc4XX0sXCJlc2NhcGVDaGFyX2JhY2tzcGFjZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTM1LDE5NDBdfSxcImVzY2FwZUNoYXJfbGluZUZlZWRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk5NiwyMDAxXX0sXCJlc2NhcGVDaGFyX2NhcnJpYWdlUmV0dXJuXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIwNjMsMjA2OF19LFwiZXNjYXBlQ2hhcl90YWJcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjExOSwyMTYwXX0sXCJlc2NhcGVDaGFyX3VuaWNvZGVFc2NhcGVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE4NSwyMjA4XX0sXCJlc2NhcGVDaGFyX2hleEVzY2FwZVwiLFtdXV1dLFwic3BhY2VcIjpbXCJleHRlbmRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjQ0LDIyNjNdfSxudWxsLFtdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyNTYsMjI2M119LFwiY29tbWVudFwiLFtdXV0sXCJjb21tZW50X3NpbmdsZUxpbmVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjgxLDIzMjddfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjMxMl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4MSwyMjg1XX0sXCIvL1wiXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4NiwyMjk4XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4NywyMjk2XX0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4NywyMjkyXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjg4LDIyOTJdfSxcIlxcblwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI5MywyMjk2XX0sXCJhbnlcIixbXV1dXSxbXCJsb29rYWhlYWRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjk5LDIzMTJdfSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzAxLDIzMTFdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMDEsMjMwNV19LFwiXFxuXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMDgsMjMxMV19LFwiZW5kXCIsW11dXV1dXSxcImNvbW1lbnRfbXVsdGlMaW5lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMzNCwyMzcwXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzM0LDIzNTZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzQsMjMzOF19LFwiLypcIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzksMjM1MV19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNDAsMjM0OV19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNDAsMjM0NV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM0MSwyMzQ1XX0sXCIqL1wiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM0NiwyMzQ5XX0sXCJhbnlcIixbXV1dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNTIsMjM1Nl19LFwiKi9cIl1dXSxcImNvbW1lbnRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjY3LDIzNzBdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjM3MF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjMxMl19LFwiY29tbWVudF9zaW5nbGVMaW5lXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzQsMjM1Nl19LFwiY29tbWVudF9tdWx0aUxpbmVcIixbXV1dXSxcInRva2Vuc1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNzQsMjM4OV19LG51bGwsW10sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzODMsMjM4OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzODMsMjM4OF19LFwidG9rZW5cIixbXV1dXSxcInRva2VuXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM5MywyNDY5XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDAxLDI0NjldfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDAxLDI0MDldfSxcImNhc2VOYW1lXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MTIsMjQxOV19LFwiY29tbWVudFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDIyLDI0MjddfSxcImlkZW50XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MzAsMjQzOF19LFwib3BlcmF0b3JcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ0MSwyNDUyXX0sXCJwdW5jdHVhdGlvblwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDU1LDI0NjNdfSxcInRlcm1pbmFsXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NjYsMjQ2OV19LFwiYW55XCIsW11dXV0sXCJvcGVyYXRvclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NzMsMjUzOF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ4NCwyNTM4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDg0LDI0ODhdfSxcIjw6XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ5MSwyNDk0XX0sXCI9XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ5NywyNTAxXX0sXCI6PVwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MDQsMjUwOF19LFwiKz1cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTExLDI1MTRdfSxcIipcIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTE3LDI1MjBdfSxcIitcIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTIzLDI1MjZdfSxcIj9cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTI5LDI1MzJdfSxcIn5cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTM1LDI1MzhdfSxcIiZcIl1dXSxcInB1bmN0dWF0aW9uXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU0MiwyNTc4XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTU2LDI1NzhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NTYsMjU1OV19LFwiPFwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NjIsMjU2NV19LFwiPlwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NjgsMjU3MV19LFwiLFwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NzQsMjU3OF19LFwiLS1cIl1dXX1dKTtcbiIsInZhciBvaG0gPSByZXF1aXJlKCcuLicpO1xubW9kdWxlLmV4cG9ydHMgPSBvaG0ubWFrZVJlY2lwZShbXCJncmFtbWFyXCIse1wic291cmNlXCI6XCJPcGVyYXRpb25zQW5kQXR0cmlidXRlcyB7XFxuXFxuICBBdHRyaWJ1dGVTaWduYXR1cmUgPVxcbiAgICBuYW1lXFxuXFxuICBPcGVyYXRpb25TaWduYXR1cmUgPVxcbiAgICBuYW1lIEZvcm1hbHM/XFxuXFxuICBGb3JtYWxzXFxuICAgID0gXFxcIihcXFwiIExpc3RPZjxuYW1lLCBcXFwiLFxcXCI+IFxcXCIpXFxcIlxcblxcbiAgbmFtZSAgKGEgbmFtZSlcXG4gICAgPSBuYW1lRmlyc3QgbmFtZVJlc3QqXFxuXFxuICBuYW1lRmlyc3RcXG4gICAgPSBcXFwiX1xcXCJcXG4gICAgfCBsZXR0ZXJcXG5cXG4gIG5hbWVSZXN0XFxuICAgID0gXFxcIl9cXFwiXFxuICAgIHwgYWxudW1cXG5cXG59XCJ9LFwiT3BlcmF0aW9uc0FuZEF0dHJpYnV0ZXNcIixudWxsLFwiQXR0cmlidXRlU2lnbmF0dXJlXCIse1wiQXR0cmlidXRlU2lnbmF0dXJlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjksNThdfSxudWxsLFtdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU0LDU4XX0sXCJuYW1lXCIsW11dXSxcIk9wZXJhdGlvblNpZ25hdHVyZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzYyLDEwMF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODcsMTAwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODcsOTFdfSxcIm5hbWVcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTIsMTAwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTIsOTldfSxcIkZvcm1hbHNcIixbXV1dXV0sXCJGb3JtYWxzXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA0LDE0M119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTE4LDE0M119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTE4LDEyMV19LFwiKFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjIsMTM5XX0sXCJMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5LDEzM119LFwibmFtZVwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNSwxMzhdfSxcIixcIl1dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MCwxNDNdfSxcIilcIl1dXSxcIm5hbWVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDcsMTg3XX0sXCJhIG5hbWVcIixbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgsMTg3XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4LDE3N119LFwibmFtZUZpcnN0XCIsW11dLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNzgsMTg3XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTc4LDE4Nl19LFwibmFtZVJlc3RcIixbXV1dXV0sXCJuYW1lRmlyc3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTEsMjIzXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDcsMjIzXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDcsMjEwXX0sXCJfXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxNywyMjNdfSxcImxldHRlclwiLFtdXV1dLFwibmFtZVJlc3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjcsMjU3XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDIsMjU3XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDIsMjQ1XX0sXCJfXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MiwyNTddfSxcImFsbnVtXCIsW11dXV19XSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCcuLi9zcmMvY29tbW9uJykuYXNzZXJ0O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gSGVscGVyc1xuXG5mdW5jdGlvbiBnZXRQcm9wKG5hbWUsIHRoaW5nLCBmbikge1xuICByZXR1cm4gZm4odGhpbmdbbmFtZV0pO1xufVxuXG5mdW5jdGlvbiBtYXBQcm9wKG5hbWUsIHRoaW5nLCBmbikge1xuICByZXR1cm4gdGhpbmdbbmFtZV0ubWFwKGZuKTtcbn1cblxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB3YWxrIGEgc2luZ2xlIHByb3BlcnR5IG9mIGEgbm9kZS5cbi8vIGBkZXNjcmlwdG9yYCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBwcm9wZXJ0eSBuYW1lLCBvcHRpb25hbGx5IGVuZGluZ1xuLy8gd2l0aCAnW10nIChlLmcuLCAnY2hpbGRyZW5bXScpLlxuZnVuY3Rpb24gZ2V0UHJvcFdhbGtGbihkZXNjcmlwdG9yKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVzY3JpcHRvci5zcGxpdCgvID9cXFtcXF0vKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBtYXBQcm9wLmJpbmQobnVsbCwgcGFydHNbMF0pO1xuICB9XG4gIHJldHVybiBnZXRQcm9wLmJpbmQobnVsbCwgZGVzY3JpcHRvcik7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BzKHdhbGtGbnMsIHRoaW5nLCBmbikge1xuICByZXR1cm4gd2Fsa0Zucy5tYXAod2Fsa0ZuID0+IHdhbGtGbih0aGluZywgZm4pKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Fsa0ZuKHNoYXBlKSB7XG4gIGlmICh0eXBlb2Ygc2hhcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGdldFByb3BzLmJpbmQobnVsbCwgW2dldFByb3BXYWxrRm4oc2hhcGUpXSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzaGFwZSkpIHtcbiAgICByZXR1cm4gZ2V0UHJvcHMuYmluZChudWxsLCBzaGFwZS5tYXAoZ2V0UHJvcFdhbGtGbikpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydCh0eXBlb2Ygc2hhcGUgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBhIHN0cmluZywgQXJyYXksIG9yIGZ1bmN0aW9uJyk7XG4gICAgYXNzZXJ0KHNoYXBlLmxlbmd0aCA9PT0gMiwgJ0V4cGVjdGVkIGEgZnVuY3Rpb24gb2YgYXJpdHkgMiwgZ290ICcgKyBzaGFwZS5sZW5ndGgpO1xuICAgIHJldHVybiBzaGFwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1Jlc3RyaWN0ZWRJZGVudGlmaWVyKHN0cikge1xuICByZXR1cm4gL15bYS16QS1aX11bMC05YS16QS1aX10qJC8udGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiB0cmltKHMpIHtcbiAgcmV0dXJuIHMudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNpZ25hdHVyZShzaWcpIHtcbiAgY29uc3QgcGFydHMgPSBzaWcuc3BsaXQoL1soKV0vKS5tYXAodHJpbSk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDMgJiYgcGFydHNbMl0gPT09ICcnKSB7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzWzBdO1xuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBpZiAocGFydHNbMV0ubGVuZ3RoID4gMCkge1xuICAgICAgcGFyYW1zID0gcGFydHNbMV0uc3BsaXQoJywnKS5tYXAodHJpbSk7XG4gICAgfVxuICAgIGlmIChpc1Jlc3RyaWN0ZWRJZGVudGlmaWVyKG5hbWUpICYmIHBhcmFtcy5ldmVyeShpc1Jlc3RyaWN0ZWRJZGVudGlmaWVyKSkge1xuICAgICAgcmV0dXJuIHtuYW1lLCBmb3JtYWxzOiBwYXJhbXN9O1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmF0aW9uIHNpZ25hdHVyZTogJyArIHNpZyk7XG59XG5cbi8qXG4gIEEgVmlzaXRvckZhbWlseSBjb250YWlucyBhIHNldCBvZiByZWN1cnNpdmUgb3BlcmF0aW9ucyB0aGF0IGFyZSBkZWZpbmVkIG92ZXIgc29tZSBraW5kIG9mXG4gIHRyZWUgc3RydWN0dXJlLiBUaGUgYGNvbmZpZ2AgcGFyYW1ldGVyIHNwZWNpZmllcyBob3cgdG8gd2FsayB0aGUgdHJlZTpcbiAgLSAnZ2V0VGFnJyBpcyBmdW5jdGlvbiB3aGljaCwgZ2l2ZW4gYSBub2RlIGluIHRoZSB0cmVlLCByZXR1cm5zIHRoZSBub2RlJ3MgJ3RhZycgKHR5cGUpXG4gIC0gJ3NoYXBlcycgYW4gb2JqZWN0IHRoYXQgbWFwcyBmcm9tIGEgdGFnIHRvIGEgdmFsdWUgdGhhdCBkZXNjcmliZXMgaG93IHRvIHJlY3Vyc2l2ZWx5XG4gICAgZXZhbHVhdGUgdGhlIG9wZXJhdGlvbiBmb3Igbm9kZXMgb2YgdGhhdCB0eXBlLiBUaGUgdmFsdWUgY2FuIGJlOlxuICAgICogYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgcHJvcGVydHkgbmFtZSB0aGF0IGhvbGRzIHRoYXQgbm9kZSdzIG9ubHkgY2hpbGRcbiAgICAqIGFuIEFycmF5IG9mIHByb3BlcnR5IG5hbWVzIChvciBhbiBlbXB0eSBhcnJheSBpbmRpY2F0aW5nIGEgbGVhZiB0eXBlKSwgb3JcbiAgICAqIGEgZnVuY3Rpb24gdGFraW5nIHR3byBhcmd1bWVudHMgKG5vZGUsIGZuKSwgYW5kIHJldHVybmluZyBhbiBBcnJheSB3aGljaCBpcyB0aGUgcmVzdWx0XG4gICAgICBvZiBhcHBseSBgZm5gIHRvIGVhY2ggb2YgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gVmlzaXRvckZhbWlseShjb25maWcpIHtcbiAgdGhpcy5fc2hhcGVzID0gY29uZmlnLnNoYXBlcztcbiAgdGhpcy5fZ2V0VGFnID0gY29uZmlnLmdldFRhZztcblxuICB0aGlzLkFkYXB0ZXIgPSBmdW5jdGlvbih0aGluZywgZmFtaWx5KSB7XG4gICAgdGhpcy5fYWRhcHRlZSA9IHRoaW5nO1xuICAgIHRoaXMuX2ZhbWlseSA9IGZhbWlseTtcbiAgfTtcbiAgdGhpcy5BZGFwdGVyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoZWVleSEnKTtcbiAgfTtcbiAgdGhpcy5vcGVyYXRpb25zID0ge307XG5cbiAgdGhpcy5fYXJpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2dldENoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgT2JqZWN0LmtleXModGhpcy5fc2hhcGVzKS5mb3JFYWNoKGsgPT4ge1xuICAgIGNvbnN0IHNoYXBlID0gc2VsZi5fc2hhcGVzW2tdO1xuICAgIHNlbGYuX2dldENoaWxkcmVuW2tdID0gZ2V0V2Fsa0ZuKHNoYXBlKTtcblxuICAgIC8vIEEgZnVuY3Rpb24gbWVhbnMgdGhlIGFyaXR5IGlzbid0IGZpeGVkLCBzbyBkb24ndCBwdXQgYW4gZW50cnkgaW4gdGhlIGFyaXR5IG1hcC5cbiAgICBpZiAodHlwZW9mIHNoYXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmLl9hcml0aWVzW2tdID0gQXJyYXkuaXNBcnJheShzaGFwZSkgPyBzaGFwZS5sZW5ndGggOiAxO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuX3dyYXAgPSBmdW5jdGlvbih0aGluZykgeyByZXR1cm4gbmV3IHNlbGYuQWRhcHRlcih0aGluZywgc2VsZik7IH07XG59XG5cblZpc2l0b3JGYW1pbHkucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbih0aGluZykge1xuICByZXR1cm4gdGhpcy5fd3JhcCh0aGluZyk7XG59O1xuXG5WaXNpdG9yRmFtaWx5LnByb3RvdHlwZS5fY2hlY2tBY3Rpb25EaWN0ID0gZnVuY3Rpb24oZGljdCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgT2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChrID0+IHtcbiAgICBhc3NlcnQoayBpbiBzZWxmLl9nZXRDaGlsZHJlbiwgXCJVbnJlY29nbml6ZWQgYWN0aW9uIG5hbWUgJ1wiICsgayArIFwiJ1wiKTtcbiAgICBjb25zdCBhY3Rpb24gPSBkaWN0W2tdO1xuICAgIGFzc2VydCh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nLCBcIktleSAnXCIgKyBrICsgXCInOiBleHBlY3RlZCBmdW5jdGlvbiwgZ290IFwiICsgYWN0aW9uKTtcbiAgICBpZiAoayBpbiBzZWxmLl9hcml0aWVzKSB7XG4gICAgICBjb25zdCBleHBlY3RlZCA9IHNlbGYuX2FyaXRpZXNba107XG4gICAgICBjb25zdCBhY3R1YWwgPSBkaWN0W2tdLmxlbmd0aDtcbiAgICAgIGFzc2VydChhY3R1YWwgPT09IGV4cGVjdGVkLFxuICAgICAgICAgIFwiQWN0aW9uICdcIiArIGsgKyBcIicgaGFzIHRoZSB3cm9uZyBhcml0eTogZXhwZWN0ZWQgXCIgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsKTtcbiAgICB9XG4gIH0pO1xufTtcblxuVmlzaXRvckZhbWlseS5wcm90b3R5cGUuYWRkT3BlcmF0aW9uID0gZnVuY3Rpb24oc2lnbmF0dXJlLCBhY3Rpb25zKSB7XG4gIGNvbnN0IHNpZyA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIGNvbnN0IG5hbWUgPSBzaWcubmFtZTtcbiAgdGhpcy5fY2hlY2tBY3Rpb25EaWN0KGFjdGlvbnMpO1xuICB0aGlzLm9wZXJhdGlvbnNbbmFtZV0gPSB7XG4gICAgbmFtZSxcbiAgICBmb3JtYWxzOiBzaWcuZm9ybWFscyxcbiAgICBhY3Rpb25zXG4gIH07XG5cbiAgY29uc3QgZmFtaWx5ID0gdGhpcztcbiAgdGhpcy5BZGFwdGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHRhZyA9IGZhbWlseS5fZ2V0VGFnKHRoaXMuX2FkYXB0ZWUpO1xuICAgIGFzc2VydCh0YWcgaW4gZmFtaWx5Ll9nZXRDaGlsZHJlbiwgXCJnZXRUYWcgcmV0dXJuZWQgdW5yZWNvZ25pemVkIHRhZyAnXCIgKyB0YWcgKyBcIidcIik7XG4gICAgYXNzZXJ0KHRhZyBpbiBhY3Rpb25zLCBcIk5vIGFjdGlvbiBmb3IgJ1wiICsgdGFnICsgXCInIGluIG9wZXJhdGlvbiAnXCIgKyBuYW1lICsgXCInXCIpO1xuXG4gICAgLy8gQ3JlYXRlIGFuIFwiYXJndW1lbnRzIG9iamVjdFwiIGZyb20gdGhlIGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoaXNcbiAgICAvLyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUuXG4gICAgY29uc3QgYXJncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3Nbc2lnLmZvcm1hbHNbaV1dID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZEFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICBjb25zdCBhbnMgPSBhY3Rpb25zW3RhZ10uYXBwbHkodGhpcywgZmFtaWx5Ll9nZXRDaGlsZHJlblt0YWddKHRoaXMuX2FkYXB0ZWUsIGZhbWlseS5fd3JhcCkpO1xuICAgIHRoaXMuYXJncyA9IG9sZEFyZ3M7XG4gICAgcmV0dXJuIGFucztcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBWaXNpdG9yRmFtaWx5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVmlzaXRvckZhbWlseTogcmVxdWlyZSgnLi9WaXNpdG9yRmFtaWx5JyksXG4gIHNlbWFudGljc0ZvclRvQVNUOiByZXF1aXJlKCcuL3NlbWFudGljcy10b0FTVCcpLnNlbWFudGljcyxcbiAgdG9BU1Q6IHJlcXVpcmUoJy4vc2VtYW50aWNzLXRvQVNUJykuaGVscGVyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi4vc3JjL3BleHBycycpO1xuY29uc3QgTWF0Y2hSZXN1bHQgPSByZXF1aXJlKCcuLi9zcmMvTWF0Y2hSZXN1bHQnKTtcbmNvbnN0IEdyYW1tYXIgPSByZXF1aXJlKCcuLi9zcmMvR3JhbW1hcicpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgndXRpbC1leHRlbmQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGRlZmF1bHRPcGVyYXRpb24gPSB7XG4gIF90ZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmltaXRpdmVWYWx1ZTtcbiAgfSxcblxuICBfbm9udGVybWluYWwoY2hpbGRyZW4pIHtcbiAgICBjb25zdCBjdG9yTmFtZSA9IHRoaXMuX25vZGUuY3Rvck5hbWU7XG4gICAgY29uc3QgbWFwcGluZyA9IHRoaXMuYXJncy5tYXBwaW5nO1xuXG4gICAgLy8gd2l0aG91dCBjdXN0b21pemF0aW9uXG4gICAgaWYgKCFtYXBwaW5nLmhhc093blByb3BlcnR5KGN0b3JOYW1lKSkge1xuICAgICAgLy8gaW50ZXJtZWRpYXRlIG5vZGVcbiAgICAgIGlmICh0aGlzLl9ub2RlIGluc3RhbmNlb2YgcGV4cHJzLkFsdCB8fCB0aGlzLl9ub2RlIGluc3RhbmNlb2YgcGV4cHJzLkFwcGx5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXS50b0FTVChtYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgLy8gbGV4aWNhbCBydWxlXG4gICAgICBpZiAodGhpcy5pc0xleGljYWwoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIHNpbmd1bGFyIG5vZGUgKGUuZy4gb25seSBzdXJyb3VuZGVkIGJ5IGxpdGVyYWxzIG9yIGxvb2thaGVhZHMpXG4gICAgICBjb25zdCByZWFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gIWNoaWxkLmlzVGVybWluYWwoKSk7XG4gICAgICBpZiAocmVhbENoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcmVhbENoaWxkcmVuWzBdLnRvQVNUKG1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0OiB0ZXJtcyB3aXRoIG11bHRpcGxlIGNoaWxkcmVuXG4gICAgfVxuXG4gICAgLy8gZGlyZWN0IGZvcndhcmRcbiAgICBpZiAodHlwZW9mIG1hcHBpbmdbY3Rvck5hbWVdID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW21hcHBpbmdbY3Rvck5hbWVdXS50b0FTVChtYXBwaW5nKTtcbiAgICB9XG5cbiAgICAvLyBuYW1lZC9tYXBwZWQgY2hpbGRyZW4gb3IgdW5uYW1lZCBjaGlsZHJlbiAoJzAnLCAnMScsICcyJywgLi4uKVxuICAgIGNvbnN0IHByb3BNYXAgPSBtYXBwaW5nW2N0b3JOYW1lXSB8fCBjaGlsZHJlbjtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogY3Rvck5hbWVcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wTWFwKSB7XG4gICAgICBjb25zdCBtYXBwZWRQcm9wID0gbWFwcGluZ1tjdG9yTmFtZV0gJiYgbWFwcGluZ1tjdG9yTmFtZV1bcHJvcF07XG4gICAgICBpZiAodHlwZW9mIG1hcHBlZFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIGRpcmVjdCBmb3J3YXJkXG4gICAgICAgIG5vZGVbcHJvcF0gPSBjaGlsZHJlblttYXBwZWRQcm9wXS50b0FTVChtYXBwaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnc3RyaW5nJykgfHwgKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnYm9vbGVhbicpIHx8XG4gICAgICAgICAgKG1hcHBlZFByb3AgPT09IG51bGwpKSB7XG4gICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICBub2RlW3Byb3BdID0gbWFwcGVkUHJvcDtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnb2JqZWN0JykgJiYgKG1hcHBlZFByb3AgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgIC8vIHByaW1pdGl2ZSBudW1iZXIgKG11c3QgYmUgdW5ib3hlZClcbiAgICAgICAgbm9kZVtwcm9wXSA9IE51bWJlcihtYXBwZWRQcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcHBlZFByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gY29tcHV0ZWQgdmFsdWVcbiAgICAgICAgbm9kZVtwcm9wXSA9IG1hcHBlZFByb3AuY2FsbCh0aGlzLCBjaGlsZHJlbik7XG4gICAgICB9IGVsc2UgaWYgKG1hcHBlZFByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bcHJvcF0gJiYgIWNoaWxkcmVuW3Byb3BdLmlzVGVybWluYWwoKSkge1xuICAgICAgICAgIG5vZGVbcHJvcF0gPSBjaGlsZHJlbltwcm9wXS50b0FTVChtYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWxldGUgcHJlZGVmaW5lZCAndHlwZScgcHJvcGVydGllcywgbGlrZSAndHlwZScsIGlmIGV4cGxpY2l0ZWx5IHJlbW92ZWRcbiAgICAgICAgICBkZWxldGUgbm9kZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBfaXRlcihjaGlsZHJlbikge1xuICAgIGlmICh0aGlzLl9ub2RlLmlzT3B0aW9uYWwoKSkge1xuICAgICAgaWYgKHRoaXMubnVtQ2hpbGRyZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF0udG9BU1QodGhpcy5hcmdzLm1hcHBpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC50b0FTVCh0aGlzLmFyZ3MubWFwcGluZyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgTm9uZW1wdHlMaXN0T2YoZmlyc3QsIHNlcCwgcmVzdCkge1xuICAgIHJldHVybiBbZmlyc3QudG9BU1QodGhpcy5hcmdzLm1hcHBpbmcpXS5jb25jYXQocmVzdC50b0FTVCh0aGlzLmFyZ3MubWFwcGluZykpO1xuICB9LFxuXG4gIEVtcHR5TGlzdE9mKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLy8gUmV0dXJucyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgaW5jbHVkZXMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgKEFTVClcbi8vIGZvciB0aGUgZ2l2ZW4gbWF0Y2ggcmVzdWx0IGByZXNgIGNvbnRhaW5nIGEgY29uY3JldGUgc3ludGF4IHRyZWUgKENTVCkgYW5kIGdyYW1tYXIuXG4vLyBUaGUgb3B0aW9uYWwgYG1hcHBpbmdgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBjdXN0b21pemUgaG93IHRoZSBub2RlcyBvZiB0aGUgQ1NUXG4vLyBhcmUgbWFwcGVkIHRvIHRoZSBBU1QgKHNlZSAvZG9jL2V4dHJhcy5tZCN0b2FzdG1hdGNocmVzdWx0LW1hcHBpbmcpLlxuZnVuY3Rpb24gdG9BU1QocmVzLCBtYXBwaW5nKSB7XG4gIGlmICghKHJlcyBpbnN0YW5jZW9mIE1hdGNoUmVzdWx0KSB8fCByZXMuZmFpbGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvQVNUKCkgZXhwZWN0cyBhIHN1Y2Nlc2Z1bGwgTWF0Y2hSZXN1bHQgYXMgZmlyc3QgcGFyYW1ldGVyJyk7XG4gIH1cblxuICBtYXBwaW5nID0gZXh0ZW5kKHt9LCBtYXBwaW5nKTtcbiAgY29uc3Qgb3BlcmF0aW9uID0gZXh0ZW5kKHt9LCBkZWZhdWx0T3BlcmF0aW9uKTtcbiAgZm9yIChjb25zdCB0ZXJtTmFtZSBpbiBtYXBwaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBwaW5nW3Rlcm1OYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3BlcmF0aW9uW3Rlcm1OYW1lXSA9IG1hcHBpbmdbdGVybU5hbWVdO1xuICAgICAgZGVsZXRlIG1hcHBpbmdbdGVybU5hbWVdO1xuICAgIH1cbiAgfVxuICBjb25zdCBnID0gcmVzLl9jc3QuZ3JhbW1hcjtcbiAgY29uc3QgcyA9IGcuY3JlYXRlU2VtYW50aWNzKCkuYWRkT3BlcmF0aW9uKCd0b0FTVChtYXBwaW5nKScsIG9wZXJhdGlvbik7XG4gIHJldHVybiBzKHJlcykudG9BU1QobWFwcGluZyk7XG59XG5cbi8vIFJldHVybnMgYSBzZW1hbnRpY3MgY29udGFpbmcgdGhlIHRvQVNUKG1hcHBpbmcpIG9wZXJhdGlvbiBmb3IgdGhlIGdpdmVuIGdyYW1tYXIgZy5cbmZ1bmN0aW9uIHNlbWFudGljc0ZvclRvQVNUKGcpIHtcbiAgaWYgKCEoZyBpbnN0YW5jZW9mIEdyYW1tYXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZW1hbnRpY3NUb0FTVCgpIGV4cGVjdHMgYSBHcmFtbWFyIGFzIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgcmV0dXJuIGcuY3JlYXRlU2VtYW50aWNzKCkuYWRkT3BlcmF0aW9uKCd0b0FTVChtYXBwaW5nKScsIGRlZmF1bHRPcGVyYXRpb24pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaGVscGVyOiB0b0FTVCxcbiAgc2VtYW50aWNzOiBzZW1hbnRpY3NGb3JUb0FTVFxufTtcbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEdyYW1tYXJEZWNsID0gcmVxdWlyZSgnLi9HcmFtbWFyRGVjbCcpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEJ1aWxkZXIoKSB7fVxuXG5CdWlsZGVyLnByb3RvdHlwZSA9IHtcbiAgY3VycmVudERlY2w6IG51bGwsXG4gIGN1cnJlbnRSdWxlTmFtZTogbnVsbCxcblxuICBuZXdHcmFtbWFyKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEdyYW1tYXJEZWNsKG5hbWUpO1xuICB9LFxuXG4gIGdyYW1tYXIobWV0YUluZm8sIG5hbWUsIHN1cGVyR3JhbW1hciwgZGVmYXVsdFN0YXJ0UnVsZSwgcnVsZXMpIHtcbiAgICBjb25zdCBnRGVjbCA9IG5ldyBHcmFtbWFyRGVjbChuYW1lKTtcbiAgICBpZiAoc3VwZXJHcmFtbWFyKSB7XG4gICAgICBnRGVjbC53aXRoU3VwZXJHcmFtbWFyKHRoaXMuZnJvbVJlY2lwZShzdXBlckdyYW1tYXIpKTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTdGFydFJ1bGUpIHtcbiAgICAgIGdEZWNsLndpdGhEZWZhdWx0U3RhcnRSdWxlKGRlZmF1bHRTdGFydFJ1bGUpO1xuICAgIH1cbiAgICBpZiAobWV0YUluZm8gJiYgbWV0YUluZm8uc291cmNlKSB7XG4gICAgICBnRGVjbC53aXRoU291cmNlKG1ldGFJbmZvLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RGVjbCA9IGdEZWNsO1xuICAgIE9iamVjdC5rZXlzKHJ1bGVzKS5mb3JFYWNoKHJ1bGVOYW1lID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgICBjb25zdCBydWxlUmVjaXBlID0gcnVsZXNbcnVsZU5hbWVdO1xuXG4gICAgICBjb25zdCBhY3Rpb24gPSBydWxlUmVjaXBlWzBdOyAvLyBkZWZpbmUvZXh0ZW5kL292ZXJyaWRlXG4gICAgICBjb25zdCBtZXRhSW5mbyA9IHJ1bGVSZWNpcGVbMV07XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHJ1bGVSZWNpcGVbMl07XG4gICAgICBjb25zdCBmb3JtYWxzID0gcnVsZVJlY2lwZVszXTtcbiAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmZyb21SZWNpcGUocnVsZVJlY2lwZVs0XSk7XG5cbiAgICAgIGxldCBzb3VyY2U7XG4gICAgICBpZiAoZ0RlY2wuc291cmNlICYmIG1ldGFJbmZvICYmIG1ldGFJbmZvLnNvdXJjZUludGVydmFsKSB7XG4gICAgICAgIHNvdXJjZSA9IGdEZWNsLnNvdXJjZS5zdWJJbnRlcnZhbChcbiAgICAgICAgICAgIG1ldGFJbmZvLnNvdXJjZUludGVydmFsWzBdLFxuICAgICAgICAgICAgbWV0YUluZm8uc291cmNlSW50ZXJ2YWxbMV0gLSBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbFswXSk7XG4gICAgICB9XG4gICAgICBnRGVjbFthY3Rpb25dKHJ1bGVOYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjcmlwdGlvbiwgc291cmNlKTtcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbnRSdWxlTmFtZSA9IHRoaXMuY3VycmVudERlY2wgPSBudWxsO1xuICAgIHJldHVybiBnRGVjbC5idWlsZCgpO1xuICB9LFxuXG4gIHRlcm1pbmFsKHgpIHtcbiAgICByZXR1cm4gbmV3IHBleHBycy5UZXJtaW5hbCh4KTtcbiAgfSxcblxuICByYW5nZShmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgcGV4cHJzLlJhbmdlKGZyb20sIHRvKTtcbiAgfSxcblxuICBwYXJhbShpbmRleCkge1xuICAgIHJldHVybiBuZXcgcGV4cHJzLlBhcmFtKGluZGV4KTtcbiAgfSxcblxuICBhbHQoLyogdGVybTEsIHRlcm0yLCAuLi4gKi8pIHtcbiAgICBsZXQgdGVybXMgPSBbXTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcmd1bWVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3VtZW50c1tpZHhdO1xuICAgICAgaWYgKCEoYXJnIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgICBhcmcgPSB0aGlzLmZyb21SZWNpcGUoYXJnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBwZXhwcnMuQWx0KSB7XG4gICAgICAgIHRlcm1zID0gdGVybXMuY29uY2F0KGFyZy50ZXJtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXJtcy5wdXNoKGFyZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXJtcy5sZW5ndGggPT09IDEgPyB0ZXJtc1swXSA6IG5ldyBwZXhwcnMuQWx0KHRlcm1zKTtcbiAgfSxcblxuICBzZXEoLyogZmFjdG9yMSwgZmFjdG9yMiwgLi4uICovKSB7XG4gICAgbGV0IGZhY3RvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcmd1bWVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3VtZW50c1tpZHhdO1xuICAgICAgaWYgKCEoYXJnIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgICBhcmcgPSB0aGlzLmZyb21SZWNpcGUoYXJnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBwZXhwcnMuU2VxKSB7XG4gICAgICAgIGZhY3RvcnMgPSBmYWN0b3JzLmNvbmNhdChhcmcuZmFjdG9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3JzLnB1c2goYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY3RvcnMubGVuZ3RoID09PSAxID8gZmFjdG9yc1swXSA6IG5ldyBwZXhwcnMuU2VxKGZhY3RvcnMpO1xuICB9LFxuXG4gIHN0YXIoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5TdGFyKGV4cHIpO1xuICB9LFxuXG4gIHBsdXMoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5QbHVzKGV4cHIpO1xuICB9LFxuXG4gIG9wdChleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLk9wdChleHByKTtcbiAgfSxcblxuICBub3QoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5Ob3QoZXhwcik7XG4gIH0sXG5cbiAgbGEoZXhwcikge1xuICAgIC8vIFRPRE86IHRlbXBvcmFyeSB0byBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgb2xkIHJlY2lwZXNcbiAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQoZXhwcik7XG4gIH0sXG5cbiAgbG9va2FoZWFkKGV4cHIpIHtcbiAgICBpZiAoIShleHByIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgZXhwciA9IHRoaXMuZnJvbVJlY2lwZShleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuTG9va2FoZWFkKGV4cHIpO1xuICB9LFxuXG4gIGxleChleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLkxleChleHByKTtcbiAgfSxcblxuICBhcHAocnVsZU5hbWUsIG9wdFBhcmFtcykge1xuICAgIGlmIChvcHRQYXJhbXMgJiYgb3B0UGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIG9wdFBhcmFtcyA9IG9wdFBhcmFtcy5tYXAoZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByID8gcGFyYW0gOlxuICAgICAgICAgIHRoaXMuZnJvbVJlY2lwZShwYXJhbSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuQXBwbHkocnVsZU5hbWUsIG9wdFBhcmFtcyk7XG4gIH0sXG5cbiAgLy8gTm90ZSB0aGF0IHVubGlrZSBvdGhlciBtZXRob2RzIGluIHRoaXMgY2xhc3MsIHRoaXMgbWV0aG9kIGNhbm5vdCBiZSB1c2VkIGFzIGFcbiAgLy8gY29udmVuaWVuY2UgY29uc3RydWN0b3IuIEl0IG9ubHkgd29ya3Mgd2l0aCByZWNpcGVzLCBiZWNhdXNlIGl0IHJlbGllcyBvblxuICAvLyBgdGhpcy5jdXJyZW50RGVjbGAgYW5kIGB0aGlzLmN1cnJlbnRSdWxlTmFtZWAgYmVpbmcgc2V0LlxuICBzcGxpY2UoYmVmb3JlVGVybXMsIGFmdGVyVGVybXMpIHtcbiAgICByZXR1cm4gbmV3IHBleHBycy5TcGxpY2UoXG4gICAgICAgIHRoaXMuY3VycmVudERlY2wuc3VwZXJHcmFtbWFyLFxuICAgICAgICB0aGlzLmN1cnJlbnRSdWxlTmFtZSxcbiAgICAgICAgYmVmb3JlVGVybXMubWFwKHRlcm0gPT4gdGhpcy5mcm9tUmVjaXBlKHRlcm0pKSxcbiAgICAgICAgYWZ0ZXJUZXJtcy5tYXAodGVybSA9PiB0aGlzLmZyb21SZWNpcGUodGVybSkpKTtcbiAgfSxcblxuICBmcm9tUmVjaXBlKHJlY2lwZSkge1xuICAgIC8vIHRoZSBtZXRhLWluZm8gb2YgJ2dyYW1tYXInIGlzIHByb2Nlc3NlZCBpbiBCdWlsZGVyLmdyYW1tYXJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzW3JlY2lwZVswXV0uYXBwbHkodGhpcyxcbiAgICAgIHJlY2lwZVswXSA9PT0gJ2dyYW1tYXInID8gcmVjaXBlLnNsaWNlKDEpIDogcmVjaXBlLnNsaWNlKDIpKTtcblxuICAgIGNvbnN0IG1ldGFJbmZvID0gcmVjaXBlWzFdO1xuICAgIGlmIChtZXRhSW5mbykge1xuICAgICAgaWYgKG1ldGFJbmZvLnNvdXJjZUludGVydmFsICYmIHRoaXMuY3VycmVudERlY2wpIHtcbiAgICAgICAgcmVzdWx0LndpdGhTb3VyY2UoXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREZWNsLnNvdXJjZUludGVydmFsLmFwcGx5KHRoaXMuY3VycmVudERlY2wsIG1ldGFJbmZvLnNvdXJjZUludGVydmFsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRmFpbHVyZSA9IHJlcXVpcmUoJy4vRmFpbHVyZScpO1xuY29uc3QgVGVybWluYWxOb2RlID0gcmVxdWlyZSgnLi9ub2RlcycpLlRlcm1pbmFsTm9kZTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJy4vY29tbW9uJykuYXNzZXJ0O1xuY29uc3Qge1BFeHByLCBUZXJtaW5hbH0gPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG5jbGFzcyBDYXNlSW5zZW5zaXRpdmVUZXJtaW5hbCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IocGFyYW0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JqID0gcGFyYW07XG4gIH1cblxuICBfZ2V0U3RyaW5nKHN0YXRlKSB7XG4gICAgY29uc3QgdGVybWluYWwgPSBzdGF0ZS5jdXJyZW50QXBwbGljYXRpb24oKS5hcmdzW3RoaXMub2JqLmluZGV4XTtcbiAgICBhc3NlcnQodGVybWluYWwgaW5zdGFuY2VvZiBUZXJtaW5hbCwgJ2V4cGVjdGVkIGEgVGVybWluYWwgZXhwcmVzc2lvbicpO1xuICAgIHJldHVybiB0ZXJtaW5hbC5vYmo7XG4gIH1cblxuICAvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgUEV4cHIgQVBJXG5cbiAgYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV2YWwoc3RhdGUpIHtcbiAgICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICAgIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gICAgY29uc3QgbWF0Y2hTdHIgPSB0aGlzLl9nZXRTdHJpbmcoc3RhdGUpO1xuICAgIGlmICghaW5wdXRTdHJlYW0ubWF0Y2hTdHJpbmcobWF0Y2hTdHIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCBtYXRjaFN0ciksIG9yaWdQb3MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgZXhhbXBsZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVGVybWluYWwuLi5cbiAgICBjb25zdCBzdHIgPSB0aGlzLm9iai5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykudmFsdWU7XG5cbiAgICAvLyAuLi5hbmQgcmFuZG9tbHkgc3dpdGNoIGNoYXJhY3RlcnMgdG8gdXBwZXJjYXNlL2xvd2VyY2FzZS5cbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsdWUgKz0gTWF0aC5yYW5kb20oKSA8IDAuNSA/IHN0cltpXS50b0xvY2FsZUxvd2VyQ2FzZSgpIDogc3RyW2ldLnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB7dmFsdWV9O1xuICB9XG5cbiAgZ2V0QXJpdHkoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBzdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpIHtcbiAgICByZXR1cm4gbmV3IENhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsKHRoaXMub2JqLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykpO1xuICB9XG5cbiAgdG9EaXNwbGF5U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm9iai50b0Rpc3BsYXlTdHJpbmcoKSArICcgKGNhc2UtaW5zZW5zaXRpdmUpJztcbiAgfVxuXG4gIHRvRmFpbHVyZShncmFtbWFyKSB7XG4gICAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIHRoaXMub2JqLnRvRmFpbHVyZShncmFtbWFyKSArICcgKGNhc2UtaW5zZW5zaXRpdmUpJywgJ2Rlc2NyaXB0aW9uJyk7XG4gIH1cblxuICBfaXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqLl9pc051bGxhYmxlKGdyYW1tYXIsIG1lbW8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FzZUluc2Vuc2l0aXZlVGVybWluYWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBgRmFpbHVyZWBzIHJlcHJlc2VudCBleHByZXNzaW9ucyB0aGF0IHdlcmVuJ3QgbWF0Y2hlZCB3aGlsZSBwYXJzaW5nLiBUaGV5IGFyZSB1c2VkIHRvIGdlbmVyYXRlXG4gIGVycm9yIG1lc3NhZ2VzIGF1dG9tYXRpY2FsbHkuIFRoZSBpbnRlcmZhY2Ugb2YgYEZhaWx1cmVgcyBpbmNsdWRlcyB0aGUgY29sbG93aW5nIG1ldGhvZHM6XG5cbiAgLSBnZXRUZXh0KCkgOiBTdHJpbmdcbiAgLSBnZXRUeXBlKCkgOiBTdHJpbmcgIChvbmUgb2Yge1wiZGVzY3JpcHRpb25cIiwgXCJzdHJpbmdcIiwgXCJjb2RlXCJ9KVxuICAtIGlzRGVzY3JpcHRpb24oKSA6IGJvb2xcbiAgLSBpc1N0cmluZ1Rlcm1pbmFsKCkgOiBib29sXG4gIC0gaXNDb2RlKCkgOiBib29sXG4gIC0gaXNGbHVmZnkoKSA6IGJvb2xcbiAgLSBtYWtlRmx1ZmZ5KCkgOiB2b2lkXG4gIC0gc3Vic3VtZXMoRmFpbHVyZSkgOiBib29sXG4qL1xuXG5mdW5jdGlvbiBpc1ZhbGlkVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSAnZGVzY3JpcHRpb24nIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdjb2RlJztcbn1cblxuZnVuY3Rpb24gRmFpbHVyZShwZXhwciwgdGV4dCwgdHlwZSkge1xuICBpZiAoIWlzVmFsaWRUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEZhaWx1cmUgdHlwZTogJyArIHR5cGUpO1xuICB9XG4gIHRoaXMucGV4cHIgPSBwZXhwcjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5mbHVmZnkgPSBmYWxzZTtcbn1cblxuRmFpbHVyZS5wcm90b3R5cGUuZ2V0UEV4cHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGV4cHI7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRleHQ7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGU7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5pc0Rlc2NyaXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09ICdkZXNjcmlwdGlvbic7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5pc1N0cmluZ1Rlcm1pbmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09ICdzdHJpbmcnO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuaXNDb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09ICdjb2RlJztcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmlzRmx1ZmZ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZsdWZmeTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLm1ha2VGbHVmZnkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mbHVmZnkgPSB0cnVlO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuY2xlYXJGbHVmZnkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mbHVmZnkgPSBmYWxzZTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLnN1YnN1bWVzID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gdGhpcy5nZXRUZXh0KCkgPT09IHRoYXQuZ2V0VGV4dCgpICYmXG4gICAgICB0aGlzLnR5cGUgPT09IHRoYXQudHlwZSAmJlxuICAgICAgKCF0aGlzLmlzRmx1ZmZ5KCkgfHwgdGhpcy5pc0ZsdWZmeSgpICYmIHRoYXQuaXNGbHVmZnkoKSk7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSAnc3RyaW5nJyA/XG4gICAgSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRUZXh0KCkpIDpcbiAgICB0aGlzLmdldFRleHQoKTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGZhaWx1cmUgPSBuZXcgRmFpbHVyZSh0aGlzLnBleHByLCB0aGlzLnRleHQsIHRoaXMudHlwZSk7XG4gIGlmICh0aGlzLmlzRmx1ZmZ5KCkpIHtcbiAgICBmYWlsdXJlLm1ha2VGbHVmZnkoKTtcbiAgfVxuICByZXR1cm4gZmFpbHVyZTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLnRvS2V5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCkgKyAnIycgKyB0aGlzLnR5cGU7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBGYWlsdXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgQ2FzZUluc2Vuc2l0aXZlVGVybWluYWwgPSByZXF1aXJlKCcuL0Nhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsJyk7XG5jb25zdCBNYXRjaGVyID0gcmVxdWlyZSgnLi9NYXRjaGVyJyk7XG5jb25zdCBTZW1hbnRpY3MgPSByZXF1aXJlKCcuL1NlbWFudGljcycpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZ2V0U29ydGVkUnVsZVZhbHVlcyhncmFtbWFyKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhncmFtbWFyLnJ1bGVzKS5zb3J0KCkubWFwKG5hbWUgPT4gZ3JhbW1hci5ydWxlc1tuYW1lXSk7XG59XG5cbmZ1bmN0aW9uIEdyYW1tYXIoXG4gICAgbmFtZSxcbiAgICBzdXBlckdyYW1tYXIsXG4gICAgcnVsZXMsXG4gICAgb3B0RGVmYXVsdFN0YXJ0UnVsZSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnN1cGVyR3JhbW1hciA9IHN1cGVyR3JhbW1hcjtcbiAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICBpZiAob3B0RGVmYXVsdFN0YXJ0UnVsZSkge1xuICAgIGlmICghKG9wdERlZmF1bHRTdGFydFJ1bGUgaW4gcnVsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXJ0IHJ1bGU6ICdcIiArIG9wdERlZmF1bHRTdGFydFJ1bGUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiJyBpcyBub3QgYSBydWxlIGluIGdyYW1tYXIgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0U3RhcnRSdWxlID0gb3B0RGVmYXVsdFN0YXJ0UnVsZTtcbiAgfVxufVxuXG5sZXQgb2htR3JhbW1hcjtcbmxldCBidWlsZEdyYW1tYXI7XG5cbi8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBmcm9tIG1haW4uanMgb25jZSBPaG0gaGFzIGxvYWRlZC5cbkdyYW1tYXIuaW5pdEFwcGxpY2F0aW9uUGFyc2VyID0gZnVuY3Rpb24oZ3JhbW1hciwgYnVpbGRlckZuKSB7XG4gIG9obUdyYW1tYXIgPSBncmFtbWFyO1xuICBidWlsZEdyYW1tYXIgPSBidWlsZGVyRm47XG59O1xuXG5HcmFtbWFyLnByb3RvdHlwZSA9IHtcbiAgbWF0Y2hlcigpIHtcbiAgICByZXR1cm4gbmV3IE1hdGNoZXIodGhpcyk7XG4gIH0sXG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIGdyYW1tYXIgaXMgYSBidWlsdC1pbiBncmFtbWFyLCBvdGhlcndpc2UgZmFsc2UuXG4gIC8vIE5PVEU6IFRoaXMgbWlnaHQgZ2l2ZSBhbiB1bmV4cGVjdGVkIHJlc3VsdCBpZiBjYWxsZWQgYmVmb3JlIEJ1aWx0SW5SdWxlcyBpcyBkZWZpbmVkIVxuICBpc0J1aWx0SW4oKSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IEdyYW1tYXIuUHJvdG9CdWlsdEluUnVsZXMgfHwgdGhpcyA9PT0gR3JhbW1hci5CdWlsdEluUnVsZXM7XG4gIH0sXG5cbiAgZXF1YWxzKGcpIHtcbiAgICBpZiAodGhpcyA9PT0gZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERvIHRoZSBjaGVhcGVzdCBjb21wYXJpc29ucyBmaXJzdC5cbiAgICBpZiAoZyA9PSBudWxsIHx8XG4gICAgICAgIHRoaXMubmFtZSAhPT0gZy5uYW1lIHx8XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSAhPT0gZy5kZWZhdWx0U3RhcnRSdWxlIHx8XG4gICAgICAgICEodGhpcy5zdXBlckdyYW1tYXIgPT09IGcuc3VwZXJHcmFtbWFyIHx8IHRoaXMuc3VwZXJHcmFtbWFyLmVxdWFscyhnLnN1cGVyR3JhbW1hcikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG15UnVsZXMgPSBnZXRTb3J0ZWRSdWxlVmFsdWVzKHRoaXMpO1xuICAgIGNvbnN0IG90aGVyUnVsZXMgPSBnZXRTb3J0ZWRSdWxlVmFsdWVzKGcpO1xuICAgIHJldHVybiBteVJ1bGVzLmxlbmd0aCA9PT0gb3RoZXJSdWxlcy5sZW5ndGggJiYgbXlSdWxlcy5ldmVyeSgocnVsZSwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJ1bGUuZGVzY3JpcHRpb24gPT09IG90aGVyUnVsZXNbaV0uZGVzY3JpcHRpb24gJiZcbiAgICAgICAgICAgICBydWxlLmZvcm1hbHMuam9pbignLCcpID09PSBvdGhlclJ1bGVzW2ldLmZvcm1hbHMuam9pbignLCcpICYmXG4gICAgICAgICAgICAgcnVsZS5ib2R5LnRvU3RyaW5nKCkgPT09IG90aGVyUnVsZXNbaV0uYm9keS50b1N0cmluZygpO1xuICAgIH0pO1xuICB9LFxuXG4gIG1hdGNoKGlucHV0LCBvcHRTdGFydEFwcGxpY2F0aW9uKSB7XG4gICAgY29uc3QgbSA9IHRoaXMubWF0Y2hlcigpO1xuICAgIG0ucmVwbGFjZUlucHV0UmFuZ2UoMCwgMCwgaW5wdXQpO1xuICAgIHJldHVybiBtLm1hdGNoKG9wdFN0YXJ0QXBwbGljYXRpb24pO1xuICB9LFxuXG4gIHRyYWNlKGlucHV0LCBvcHRTdGFydEFwcGxpY2F0aW9uKSB7XG4gICAgY29uc3QgbSA9IHRoaXMubWF0Y2hlcigpO1xuICAgIG0ucmVwbGFjZUlucHV0UmFuZ2UoMCwgMCwgaW5wdXQpO1xuICAgIHJldHVybiBtLnRyYWNlKG9wdFN0YXJ0QXBwbGljYXRpb24pO1xuICB9LFxuXG4gIHNlbWFudGljcygpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBldmVudHVhbGx5ISBEZXByZWNhdGVkIGluIHYwLjEyLlxuICAgIHRocm93IG5ldyBFcnJvcignc2VtYW50aWNzKCkgaXMgZGVwcmVjYXRlZCAtLSB1c2UgY3JlYXRlU2VtYW50aWNzKCkgaW5zdGVhZC4nKTtcbiAgfSxcblxuICBjcmVhdGVTZW1hbnRpY3MoKSB7XG4gICAgcmV0dXJuIFNlbWFudGljcy5jcmVhdGVTZW1hbnRpY3ModGhpcyk7XG4gIH0sXG5cbiAgZXh0ZW5kU2VtYW50aWNzKHN1cGVyU2VtYW50aWNzKSB7XG4gICAgcmV0dXJuIFNlbWFudGljcy5jcmVhdGVTZW1hbnRpY3ModGhpcywgc3VwZXJTZW1hbnRpY3MuX2dldFNlbWFudGljcygpKTtcbiAgfSxcblxuICAvLyBDaGVjayB0aGF0IGV2ZXJ5IGtleSBpbiBgYWN0aW9uRGljdGAgY29ycmVzcG9uZHMgdG8gYSBzZW1hbnRpYyBhY3Rpb24sIGFuZCB0aGF0IGl0IG1hcHMgdG9cbiAgLy8gYSBmdW5jdGlvbiBvZiB0aGUgY29ycmVjdCBhcml0eS4gSWYgbm90LCB0aHJvdyBhbiBleGNlcHRpb24uXG4gIF9jaGVja1RvcERvd25BY3Rpb25EaWN0KHdoYXQsIG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBmdW5jdGlvbiBpc1NwZWNpYWxBY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGEgPT09ICdfaXRlcicgfHwgYSA9PT0gJ190ZXJtaW5hbCcgfHwgYSA9PT0gJ19ub250ZXJtaW5hbCcgfHwgYSA9PT0gJ19kZWZhdWx0JztcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ibGVtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBhY3Rpb25EaWN0KSB7XG4gICAgICBjb25zdCB2ID0gYWN0aW9uRGljdFtrXTtcbiAgICAgIGlmICghaXNTcGVjaWFsQWN0aW9uKGspICYmICEoayBpbiB0aGlzLnJ1bGVzKSkge1xuICAgICAgICBwcm9ibGVtcy5wdXNoKFwiJ1wiICsgayArIFwiJyBpcyBub3QgYSB2YWxpZCBzZW1hbnRpYyBhY3Rpb24gZm9yICdcIiArIHRoaXMubmFtZSArIFwiJ1wiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvYmxlbXMucHVzaChcbiAgICAgICAgICAgIFwiJ1wiICsgayArIFwiJyBtdXN0IGJlIGEgZnVuY3Rpb24gaW4gYW4gYWN0aW9uIGRpY3Rpb25hcnkgZm9yICdcIiArIHRoaXMubmFtZSArIFwiJ1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbCA9IHYubGVuZ3RoO1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IHRoaXMuX3RvcERvd25BY3Rpb25Bcml0eShrKTtcbiAgICAgICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICBwcm9ibGVtcy5wdXNoKFxuICAgICAgICAgICAgICBcIlNlbWFudGljIGFjdGlvbiAnXCIgKyBrICsgXCInIGhhcyB0aGUgd3JvbmcgYXJpdHk6IFwiICtcbiAgICAgICAgICAgICAgJ2V4cGVjdGVkICcgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvYmxlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcHJldHR5UHJvYmxlbXMgPSBwcm9ibGVtcy5tYXAocHJvYmxlbSA9PiAnLSAnICsgcHJvYmxlbSk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkZvdW5kIGVycm9ycyBpbiB0aGUgYWN0aW9uIGRpY3Rpb25hcnkgb2YgdGhlICdcIiArIG5hbWUgKyBcIicgXCIgKyB3aGF0ICsgJzpcXG4nICtcbiAgICAgICAgICBwcmV0dHlQcm9ibGVtcy5qb2luKCdcXG4nKSk7XG4gICAgICBlcnJvci5wcm9ibGVtcyA9IHByb2JsZW1zO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybiB0aGUgZXhwZWN0ZWQgYXJpdHkgZm9yIGEgc2VtYW50aWMgYWN0aW9uIG5hbWVkIGBhY3Rpb25OYW1lYCwgd2hpY2hcbiAgLy8gaXMgZWl0aGVyIGEgcnVsZSBuYW1lIG9yIGEgc3BlY2lhbCBhY3Rpb24gbmFtZSBsaWtlICdfbm9udGVybWluYWwnLlxuICBfdG9wRG93bkFjdGlvbkFyaXR5KGFjdGlvbk5hbWUpIHtcbiAgICBpZiAoYWN0aW9uTmFtZSA9PT0gJ19pdGVyJyB8fCBhY3Rpb25OYW1lID09PSAnX25vbnRlcm1pbmFsJyB8fCBhY3Rpb25OYW1lID09PSAnX2RlZmF1bHQnKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbk5hbWUgPT09ICdfdGVybWluYWwnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucnVsZXNbYWN0aW9uTmFtZV0uYm9keS5nZXRBcml0eSgpO1xuICB9LFxuXG4gIF9pbmhlcml0c0Zyb20oZ3JhbW1hcikge1xuICAgIGxldCBnID0gdGhpcy5zdXBlckdyYW1tYXI7XG4gICAgd2hpbGUgKGcpIHtcbiAgICAgIGlmIChnLmVxdWFscyhncmFtbWFyLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGcgPSBnLnN1cGVyR3JhbW1hcjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHRvUmVjaXBlKG9wdFZhck5hbWUpIHtcbiAgICBjb25zdCBtZXRhSW5mbyA9IHt9O1xuICAgIC8vIEluY2x1ZGUgdGhlIGdyYW1tYXIgc291cmNlIGlmIGl0IGlzIGF2YWlsYWJsZS5cbiAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgIG1ldGFJbmZvLnNvdXJjZSA9IHRoaXMuc291cmNlLmNvbnRlbnRzO1xuICAgIH1cblxuICAgIGxldCBzdXBlckdyYW1tYXIgPSBudWxsO1xuICAgIGlmICh0aGlzLnN1cGVyR3JhbW1hciAmJiAhdGhpcy5zdXBlckdyYW1tYXIuaXNCdWlsdEluKCkpIHtcbiAgICAgIHN1cGVyR3JhbW1hciA9IEpTT04ucGFyc2UodGhpcy5zdXBlckdyYW1tYXIudG9SZWNpcGUoKSk7XG4gICAgfVxuXG4gICAgbGV0IHN0YXJ0UnVsZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSkge1xuICAgICAgc3RhcnRSdWxlID0gdGhpcy5kZWZhdWx0U3RhcnRSdWxlO1xuICAgIH1cblxuICAgIGNvbnN0IHJ1bGVzID0ge307XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcy5ydWxlcykuZm9yRWFjaChydWxlTmFtZSA9PiB7XG4gICAgICBjb25zdCBydWxlSW5mbyA9IHNlbGYucnVsZXNbcnVsZU5hbWVdO1xuICAgICAgY29uc3QgYm9keSA9IHJ1bGVJbmZvLmJvZHk7XG4gICAgICBjb25zdCBpc0RlZmluaXRpb24gPSAhc2VsZi5zdXBlckdyYW1tYXIgfHwgIXNlbGYuc3VwZXJHcmFtbWFyLnJ1bGVzW3J1bGVOYW1lXTtcblxuICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgIGlmIChpc0RlZmluaXRpb24pIHtcbiAgICAgICAgb3BlcmF0aW9uID0gJ2RlZmluZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVyYXRpb24gPSBib2R5IGluc3RhbmNlb2YgcGV4cHJzLkV4dGVuZCA/ICdleHRlbmQnIDogJ292ZXJyaWRlJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0YUluZm8gPSB7fTtcbiAgICAgIGlmIChydWxlSW5mby5zb3VyY2UgJiYgc2VsZi5zb3VyY2UpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWQgPSBydWxlSW5mby5zb3VyY2UucmVsYXRpdmVUbyhzZWxmLnNvdXJjZSk7XG4gICAgICAgIG1ldGFJbmZvLnNvdXJjZUludGVydmFsID0gW2FkanVzdGVkLnN0YXJ0SWR4LCBhZGp1c3RlZC5lbmRJZHhdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGlzRGVmaW5pdGlvbiA/IHJ1bGVJbmZvLmRlc2NyaXB0aW9uIDogbnVsbDtcbiAgICAgIGNvbnN0IGJvZHlSZWNpcGUgPSBib2R5Lm91dHB1dFJlY2lwZShydWxlSW5mby5mb3JtYWxzLCBzZWxmLnNvdXJjZSk7XG5cbiAgICAgIHJ1bGVzW3J1bGVOYW1lXSA9IFtcbiAgICAgICAgb3BlcmF0aW9uLCAvLyBcImRlZmluZVwiL1wiZXh0ZW5kXCIvXCJvdmVycmlkZVwiXG4gICAgICAgIG1ldGFJbmZvLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgcnVsZUluZm8uZm9ybWFscyxcbiAgICAgICAgYm9keVJlY2lwZVxuICAgICAgXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShbXG4gICAgICAnZ3JhbW1hcicsXG4gICAgICBtZXRhSW5mbyxcbiAgICAgIHRoaXMubmFtZSxcbiAgICAgIHN1cGVyR3JhbW1hcixcbiAgICAgIHN0YXJ0UnVsZSxcbiAgICAgIHJ1bGVzXG4gICAgXSk7XG4gIH0sXG5cbiAgLy8gVE9ETzogQ29tZSB1cCB3aXRoIGJldHRlciBuYW1lcyBmb3IgdGhlc2UgbWV0aG9kcy5cbiAgLy8gVE9ETzogV3JpdGUgdGhlIGFuYWxvZyBvZiB0aGVzZSBtZXRob2RzIGZvciBpbmhlcml0ZWQgYXR0cmlidXRlcy5cbiAgdG9PcGVyYXRpb25BY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvT3BlcmF0aW9uT3JBdHRyaWJ1dGVBY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKTtcbiAgfSxcbiAgdG9BdHRyaWJ1dGVBY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvT3BlcmF0aW9uT3JBdHRyaWJ1dGVBY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKTtcbiAgfSxcblxuICBfdG9PcGVyYXRpb25PckF0dHJpYnV0ZUFjdGlvbkRpY3Rpb25hcnlUZW1wbGF0ZSgpIHtcbiAgICAvLyBUT0RPOiBhZGQgdGhlIHN1cGVyLWdyYW1tYXIncyB0ZW1wbGF0ZXMgYXQgdGhlIHJpZ2h0IHBsYWNlLCBlLmcuLCBhIGNhc2UgZm9yIEFkZEV4cHJfcGx1c1xuICAgIC8vIHNob3VsZCBhcHBlYXIgbmV4dCB0byBvdGhlciBjYXNlcyBvZiBBZGRFeHByLlxuXG4gICAgY29uc3Qgc2IgPSBuZXcgY29tbW9uLlN0cmluZ0J1ZmZlcigpO1xuICAgIHNiLmFwcGVuZCgneycpO1xuXG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJ1bGVOYW1lIGluIHRoaXMucnVsZXMpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnJ1bGVzW3J1bGVOYW1lXS5ib2R5O1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzYi5hcHBlbmQoJywnKTtcbiAgICAgIH1cbiAgICAgIHNiLmFwcGVuZCgnXFxuJyk7XG4gICAgICBzYi5hcHBlbmQoJyAgJyk7XG4gICAgICB0aGlzLmFkZFNlbWFudGljQWN0aW9uVGVtcGxhdGUocnVsZU5hbWUsIGJvZHksIHNiKTtcbiAgICB9XG5cbiAgICBzYi5hcHBlbmQoJ1xcbn0nKTtcbiAgICByZXR1cm4gc2IuY29udGVudHMoKTtcbiAgfSxcblxuICBhZGRTZW1hbnRpY0FjdGlvblRlbXBsYXRlKHJ1bGVOYW1lLCBib2R5LCBzYikge1xuICAgIHNiLmFwcGVuZChydWxlTmFtZSk7XG4gICAgc2IuYXBwZW5kKCc6IGZ1bmN0aW9uKCcpO1xuICAgIGNvbnN0IGFyaXR5ID0gdGhpcy5fdG9wRG93bkFjdGlvbkFyaXR5KHJ1bGVOYW1lKTtcbiAgICBzYi5hcHBlbmQoY29tbW9uLnJlcGVhdCgnXycsIGFyaXR5KS5qb2luKCcsICcpKTtcbiAgICBzYi5hcHBlbmQoJykge1xcbicpO1xuICAgIHNiLmFwcGVuZCgnICB9Jyk7XG4gIH0sXG5cbiAgLy8gUGFyc2UgYSBzdHJpbmcgd2hpY2ggZXhwcmVzc2VzIGEgcnVsZSBhcHBsaWNhdGlvbiBpbiB0aGlzIGdyYW1tYXIsIGFuZCByZXR1cm4gdGhlXG4gIC8vIHJlc3VsdGluZyBBcHBseSBub2RlLlxuICBwYXJzZUFwcGxpY2F0aW9uKHN0cikge1xuICAgIGxldCBhcHA7XG4gICAgaWYgKHN0ci5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAvLyBzaW1wbGUgYXBwbGljYXRpb25cbiAgICAgIGFwcCA9IG5ldyBwZXhwcnMuQXBwbHkoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyYW1ldGVyaXplZCBhcHBsaWNhdGlvblxuICAgICAgY29uc3QgY3N0ID0gb2htR3JhbW1hci5tYXRjaChzdHIsICdCYXNlX2FwcGxpY2F0aW9uJyk7XG4gICAgICBhcHAgPSBidWlsZEdyYW1tYXIoY3N0LCB7fSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIGFwcGxpY2F0aW9uIGlzIHZhbGlkLlxuICAgIGlmICghKGFwcC5ydWxlTmFtZSBpbiB0aGlzLnJ1bGVzKSkge1xuICAgICAgdGhyb3cgZXJyb3JzLnVuZGVjbGFyZWRSdWxlKGFwcC5ydWxlTmFtZSwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybWFscyA9IHRoaXMucnVsZXNbYXBwLnJ1bGVOYW1lXS5mb3JtYWxzO1xuICAgIGlmIChmb3JtYWxzLmxlbmd0aCAhPT0gYXBwLmFyZ3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJ1bGVzW2FwcC5ydWxlTmFtZV0uc291cmNlO1xuICAgICAgdGhyb3cgZXJyb3JzLndyb25nTnVtYmVyT2ZQYXJhbWV0ZXJzKGFwcC5ydWxlTmFtZSwgZm9ybWFscy5sZW5ndGgsIGFwcC5hcmdzLmxlbmd0aCwgc291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbiAgfVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyBncmFtbWFyIGNvbnRhaW5zIGEgZmV3IHJ1bGVzIHRoYXQgY291bGRuJ3QgYmUgd3JpdHRlbiAgaW4gXCJ1c2VybGFuZFwiLlxuLy8gQXQgdGhlIGJvdHRvbSBvZiBzcmMvbWFpbi5qcywgd2UgY3JlYXRlIGEgc3ViLWdyYW1tYXIgb2YgdGhpcyBncmFtbWFyIHRoYXQncyBjYWxsZWRcbi8vIGBCdWlsdEluUnVsZXNgLiBUaGF0IGdyYW1tYXIgY29udGFpbnMgc2V2ZXJhbCBjb252ZW5pZW5jZSBydWxlcywgZS5nLiwgYGxldHRlcmAgYW5kXG4vLyBgZGlnaXRgLCBhbmQgaXMgaW1wbGljaXRseSB0aGUgc3VwZXItZ3JhbW1hciBvZiBhbnkgZ3JhbW1hciB3aG9zZSBzdXBlci1ncmFtbWFyXG4vLyBpc24ndCBzcGVjaWZpZWQuXG5HcmFtbWFyLlByb3RvQnVpbHRJblJ1bGVzID0gbmV3IEdyYW1tYXIoXG4gICAgJ1Byb3RvQnVpbHRJblJ1bGVzJywgLy8gbmFtZVxuICAgIHVuZGVmaW5lZCwgLy8gc3VwZXJncmFtbWFyXG4gICAge1xuICAgICAgYW55OiB7XG4gICAgICAgIGJvZHk6IHBleHBycy5hbnksXG4gICAgICAgIGZvcm1hbHM6IFtdLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2FueSBjaGFyYWN0ZXInLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgYm9keTogcGV4cHJzLmVuZCxcbiAgICAgICAgZm9ybWFsczogW10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnZW5kIG9mIGlucHV0JyxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBjYXNlSW5zZW5zaXRpdmU6IHtcbiAgICAgICAgYm9keTogbmV3IENhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsKG5ldyBwZXhwcnMuUGFyYW0oMCkpLFxuICAgICAgICBmb3JtYWxzOiBbJ3N0ciddLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsb3dlcjoge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlVuaWNvZGVDaGFyKCdMbCcpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhIGxvd2VyY2FzZSBsZXR0ZXInLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cHBlcjoge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlVuaWNvZGVDaGFyKCdMdScpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhbiB1cHBlcmNhc2UgbGV0dGVyJyxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gVW5pb24gb2YgTHQgKHRpdGxlY2FzZSksIExtIChtb2RpZmllciksIGFuZCBMbyAob3RoZXIpLCBpLmUuIGFueSBsZXR0ZXIgbm90IGluIExsIG9yIEx1LlxuICAgICAgdW5pY29kZUx0bW86IHtcbiAgICAgICAgYm9keTogbmV3IHBleHBycy5Vbmljb2RlQ2hhcignTHRtbycpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhIFVuaWNvZGUgY2hhcmFjdGVyIGluIEx0LCBMbSwgb3IgTG8nLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8vIFRoZXNlIHJ1bGVzIGFyZSBub3QgdHJ1bHkgcHJpbWl0aXZlICh0aGV5IGNvdWxkIGJlIHdyaXR0ZW4gaW4gdXNlcmxhbmQpIGJ1dCBhcmUgZGVmaW5lZFxuICAgICAgLy8gaGVyZSBmb3IgYm9vdHN0cmFwcGluZyBwdXJwb3Nlcy5cbiAgICAgIHNwYWNlczoge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlN0YXIobmV3IHBleHBycy5BcHBseSgnc3BhY2UnKSksXG4gICAgICAgIGZvcm1hbHM6IFtdXG4gICAgICB9LFxuICAgICAgc3BhY2U6IHtcbiAgICAgICAgYm9keTogbmV3IHBleHBycy5SYW5nZSgnXFx4MDAnLCAnICcpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhIHNwYWNlJ1xuICAgICAgfVxuICAgIH1cbik7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYW1tYXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBHcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyJyk7XG5jb25zdCBJbnB1dFN0cmVhbSA9IHJlcXVpcmUoJy4vSW5wdXRTdHJlYW0nKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgU3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIENvbnN0cnVjdG9yc1xuXG5mdW5jdGlvbiBHcmFtbWFyRGVjbChuYW1lKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG59XG5cbi8vIEhlbHBlcnNcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLnNvdXJjZUludGVydmFsID0gZnVuY3Rpb24oc3RhcnRJZHgsIGVuZElkeCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2Uuc3ViSW50ZXJ2YWwoc3RhcnRJZHgsIGVuZElkeCAtIHN0YXJ0SWR4KTtcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5lbnN1cmVTdXBlckdyYW1tYXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnN1cGVyR3JhbW1hcikge1xuICAgIHRoaXMud2l0aFN1cGVyR3JhbW1hcihcbiAgICAgICAgLy8gVE9ETzogVGhlIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24gYmVsb3cgaXMgYW4gdWdseSBoYWNrLiBJdCdzIGtpbmQgb2Ygb2sgYmVjYXVzZVxuICAgICAgICAvLyBJIGRvdWJ0IGFueW9uZSB3aWxsIGV2ZXIgdHJ5IHRvIGRlY2xhcmUgYSBncmFtbWFyIGNhbGxlZCBgQnVpbHRJblJ1bGVzYC4gU3RpbGwsXG4gICAgICAgIC8vIHdlIHNob3VsZCB0cnkgdG8gZmluZCBhIGJldHRlciB3YXkgdG8gZG8gdGhpcy5cbiAgICAgICAgdGhpcy5uYW1lID09PSAnQnVpbHRJblJ1bGVzJyA/XG4gICAgICAgICAgICBHcmFtbWFyLlByb3RvQnVpbHRJblJ1bGVzIDpcbiAgICAgICAgICAgIEdyYW1tYXIuQnVpbHRJblJ1bGVzKTtcbiAgfVxuICByZXR1cm4gdGhpcy5zdXBlckdyYW1tYXI7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuZW5zdXJlU3VwZXJHcmFtbWFyUnVsZUZvck92ZXJyaWRpbmcgPSBmdW5jdGlvbihuYW1lLCBzb3VyY2UpIHtcbiAgY29uc3QgcnVsZUluZm8gPSB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hcigpLnJ1bGVzW25hbWVdO1xuICBpZiAoIXJ1bGVJbmZvKSB7XG4gICAgdGhyb3cgZXJyb3JzLmNhbm5vdE92ZXJyaWRlVW5kZWNsYXJlZFJ1bGUobmFtZSwgdGhpcy5zdXBlckdyYW1tYXIubmFtZSwgc291cmNlKTtcbiAgfVxuICByZXR1cm4gcnVsZUluZm87XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuaW5zdGFsbE92ZXJyaWRkZW5PckV4dGVuZGVkUnVsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGJvZHksIHNvdXJjZSkge1xuICBjb25zdCBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyA9IGNvbW1vbi5nZXREdXBsaWNhdGVzKGZvcm1hbHMpO1xuICBpZiAoZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IGVycm9ycy5kdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyhuYW1lLCBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcywgc291cmNlKTtcbiAgfVxuICBjb25zdCBydWxlSW5mbyA9IHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyKCkucnVsZXNbbmFtZV07XG4gIGNvbnN0IGV4cGVjdGVkRm9ybWFscyA9IHJ1bGVJbmZvLmZvcm1hbHM7XG4gIGNvbnN0IGV4cGVjdGVkTnVtRm9ybWFscyA9IGV4cGVjdGVkRm9ybWFscyA/IGV4cGVjdGVkRm9ybWFscy5sZW5ndGggOiAwO1xuICBpZiAoZm9ybWFscy5sZW5ndGggIT09IGV4cGVjdGVkTnVtRm9ybWFscykge1xuICAgIHRocm93IGVycm9ycy53cm9uZ051bWJlck9mUGFyYW1ldGVycyhuYW1lLCBleHBlY3RlZE51bUZvcm1hbHMsIGZvcm1hbHMubGVuZ3RoLCBzb3VyY2UpO1xuICB9XG4gIHJldHVybiB0aGlzLmluc3RhbGwobmFtZSwgZm9ybWFscywgYm9keSwgcnVsZUluZm8uZGVzY3JpcHRpb24sIHNvdXJjZSk7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGJvZHksIGRlc2NyaXB0aW9uLCBzb3VyY2UpIHtcbiAgdGhpcy5ydWxlc1tuYW1lXSA9IHtcbiAgICBib2R5OiBib2R5LmludHJvZHVjZVBhcmFtcyhmb3JtYWxzKSxcbiAgICBmb3JtYWxzLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHNvdXJjZVxuICB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFN0dWZmIHRoYXQgeW91IHNob3VsZCBvbmx5IGRvIG9uY2VcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLndpdGhTdXBlckdyYW1tYXIgPSBmdW5jdGlvbihzdXBlckdyYW1tYXIpIHtcbiAgaWYgKHRoaXMuc3VwZXJHcmFtbWFyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgc3VwZXIgZ3JhbW1hciBvZiBhIEdyYW1tYXJEZWNsIGNhbm5vdCBiZSBzZXQgbW9yZSB0aGFuIG9uY2UnKTtcbiAgfVxuICB0aGlzLnN1cGVyR3JhbW1hciA9IHN1cGVyR3JhbW1hcjtcbiAgdGhpcy5ydWxlcyA9IE9iamVjdC5jcmVhdGUoc3VwZXJHcmFtbWFyLnJ1bGVzKTtcblxuICAvLyBHcmFtbWFycyB3aXRoIGFuIGV4cGxpY2l0IHN1cGVyZ3JhbW1hciBpbmhlcml0IGEgZGVmYXVsdCBzdGFydCBydWxlLlxuICBpZiAoIXN1cGVyR3JhbW1hci5pc0J1aWx0SW4oKSkge1xuICAgIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSA9IHN1cGVyR3JhbW1hci5kZWZhdWx0U3RhcnRSdWxlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLndpdGhEZWZhdWx0U3RhcnRSdWxlID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgdGhpcy5kZWZhdWx0U3RhcnRSdWxlID0gcnVsZU5hbWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLndpdGhTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgdGhpcy5zb3VyY2UgPSBuZXcgSW5wdXRTdHJlYW0oc291cmNlKS5pbnRlcnZhbCgwLCBzb3VyY2UubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBDcmVhdGVzIGEgR3JhbW1hciBpbnN0YW5jZSwgYW5kIGlmIGl0IHBhc3NlcyB0aGUgc2FuaXR5IGNoZWNrcywgcmV0dXJucyBpdC5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBncmFtbWFyID0gbmV3IEdyYW1tYXIoXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hcigpLFxuICAgICAgdGhpcy5ydWxlcyxcbiAgICAgIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSk7XG5cbiAgLy8gVE9ETzogY2hhbmdlIHRoZSBwZXhwci5wcm90b3R5cGUuYXNzZXJ0Li4uIG1ldGhvZHMgdG8gbWFrZSB0aGVtIGFkZFxuICAvLyBleGNlcHRpb25zIHRvIGFuIGFycmF5IHRoYXQncyBwcm92aWRlZCBhcyBhbiBhcmcuIFRoZW4gd2UnbGwgYmUgYWJsZSB0b1xuICAvLyBzaG93IG1vcmUgdGhhbiBvbmUgZXJyb3Igb2YgdGhlIHNhbWUgdHlwZSBhdCBhIHRpbWUuXG4gIC8vIFRPRE86IGluY2x1ZGUgdGhlIG9mZmVuZGluZyBwZXhwciBpbiB0aGUgZXJyb3JzLCB0aGF0IHdheSB3ZSBjYW4gc2hvd1xuICAvLyB0aGUgcGFydCBvZiB0aGUgc291cmNlIHRoYXQgY2F1c2VkIGl0LlxuICBjb25zdCBncmFtbWFyRXJyb3JzID0gW107XG4gIGxldCBncmFtbWFySGFzSW52YWxpZEFwcGxpY2F0aW9ucyA9IGZhbHNlO1xuICBPYmplY3Qua2V5cyhncmFtbWFyLnJ1bGVzKS5mb3JFYWNoKHJ1bGVOYW1lID0+IHtcbiAgICBjb25zdCBib2R5ID0gZ3JhbW1hci5ydWxlc1tydWxlTmFtZV0uYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eShydWxlTmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZ3JhbW1hckVycm9ycy5wdXNoKGUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYm9keS5hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZ3JhbW1hckVycm9ycy5wdXNoKGUpO1xuICAgICAgZ3JhbW1hckhhc0ludmFsaWRBcHBsaWNhdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGlmICghZ3JhbW1hckhhc0ludmFsaWRBcHBsaWNhdGlvbnMpIHtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGNhbiBvbmx5IGJlIGRvbmUgaWYgdGhlIGdyYW1tYXIgaGFzIG5vIGludmFsaWQgYXBwbGljYXRpb25zLlxuICAgIE9iamVjdC5rZXlzKGdyYW1tYXIucnVsZXMpLmZvckVhY2gocnVsZU5hbWUgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IGdyYW1tYXIucnVsZXNbcnVsZU5hbWVdLmJvZHk7XG4gICAgICB0cnkge1xuICAgICAgICBib2R5LmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyLCBbXSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGdyYW1tYXJFcnJvcnMucHVzaChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoZ3JhbW1hckVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgZXJyb3JzLnRocm93RXJyb3JzKGdyYW1tYXJFcnJvcnMpO1xuICB9XG4gIGlmICh0aGlzLnNvdXJjZSkge1xuICAgIGdyYW1tYXIuc291cmNlID0gdGhpcy5zb3VyY2U7XG4gIH1cblxuICByZXR1cm4gZ3JhbW1hcjtcbn07XG5cbi8vIFJ1bGUgZGVjbGFyYXRpb25zXG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbihuYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjcmlwdGlvbiwgc291cmNlKSB7XG4gIHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyKCk7XG4gIGlmICh0aGlzLnN1cGVyR3JhbW1hci5ydWxlc1tuYW1lXSkge1xuICAgIHRocm93IGVycm9ycy5kdXBsaWNhdGVSdWxlRGVjbGFyYXRpb24obmFtZSwgdGhpcy5uYW1lLCB0aGlzLnN1cGVyR3JhbW1hci5uYW1lLCBzb3VyY2UpO1xuICB9IGVsc2UgaWYgKHRoaXMucnVsZXNbbmFtZV0pIHtcbiAgICB0aHJvdyBlcnJvcnMuZHVwbGljYXRlUnVsZURlY2xhcmF0aW9uKG5hbWUsIHRoaXMubmFtZSwgdGhpcy5uYW1lLCBzb3VyY2UpO1xuICB9XG4gIGNvbnN0IGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzID0gY29tbW9uLmdldER1cGxpY2F0ZXMoZm9ybWFscyk7XG4gIGlmIChkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgZXJyb3JzLmR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzKG5hbWUsIGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzLCBzb3VyY2UpO1xuICB9XG4gIHJldHVybiB0aGlzLmluc3RhbGwobmFtZSwgZm9ybWFscywgYm9keSwgZGVzY3JpcHRpb24sIHNvdXJjZSk7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbihuYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjSWdub3JlZCwgc291cmNlKSB7XG4gIHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyUnVsZUZvck92ZXJyaWRpbmcobmFtZSwgc291cmNlKTtcbiAgdGhpcy5pbnN0YWxsT3ZlcnJpZGRlbk9yRXh0ZW5kZWRSdWxlKG5hbWUsIGZvcm1hbHMsIGJvZHksIHNvdXJjZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGZyYWdtZW50LCBkZXNjSWdub3JlZCwgc291cmNlKSB7XG4gIGNvbnN0IHJ1bGVJbmZvID0gdGhpcy5lbnN1cmVTdXBlckdyYW1tYXIoKS5ydWxlc1tuYW1lXTtcbiAgaWYgKCFydWxlSW5mbykge1xuICAgIHRocm93IGVycm9ycy5jYW5ub3RFeHRlbmRVbmRlY2xhcmVkUnVsZShuYW1lLCB0aGlzLnN1cGVyR3JhbW1hci5uYW1lLCBzb3VyY2UpO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBuZXcgcGV4cHJzLkV4dGVuZCh0aGlzLnN1cGVyR3JhbW1hciwgbmFtZSwgZnJhZ21lbnQpO1xuICBib2R5LnNvdXJjZSA9IGZyYWdtZW50LnNvdXJjZTtcbiAgdGhpcy5pbnN0YWxsT3ZlcnJpZGRlbk9yRXh0ZW5kZWRSdWxlKG5hbWUsIGZvcm1hbHMsIGJvZHksIHNvdXJjZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gR3JhbW1hckRlY2w7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWwnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIElucHV0U3RyZWFtKHNvdXJjZSkge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLmV4YW1pbmVkTGVuZ3RoID0gMDtcbn1cblxuSW5wdXRTdHJlYW0ucHJvdG90eXBlID0ge1xuICBhdEVuZCgpIHtcbiAgICBjb25zdCBhbnMgPSB0aGlzLnBvcyA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuZXhhbWluZWRMZW5ndGggPSBNYXRoLm1heCh0aGlzLmV4YW1pbmVkTGVuZ3RoLCB0aGlzLnBvcyArIDEpO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgbmV4dCgpIHtcbiAgICBjb25zdCBhbnMgPSB0aGlzLnNvdXJjZVt0aGlzLnBvcysrXTtcbiAgICB0aGlzLmV4YW1pbmVkTGVuZ3RoID0gTWF0aC5tYXgodGhpcy5leGFtaW5lZExlbmd0aCwgdGhpcy5wb3MpO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgbWF0Y2hTdHJpbmcocywgb3B0SWdub3JlQ2FzZSkge1xuICAgIGxldCBpZHg7XG4gICAgaWYgKG9wdElnbm9yZUNhc2UpIHtcbiAgICAgIC8qXG4gICAgICAgIENhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvbiBpcyBhIHRyaWNreSBidXNpbmVzcy4gU29tZSBub3RhYmxlIGdvdGNoYXMgaW5jbHVkZSB0aGVcbiAgICAgICAgXCJUdXJraXNoIElcIiBwcm9ibGVtIChodHRwOi8vd3d3LmkxOG5ndXkuY29tL3VuaWNvZGUvdHVya2lzaC1pMThuLmh0bWwpIGFuZCB0aGUgZmFjdFxuICAgICAgICB0aGF0IHRoZSBHZXJtYW4gRXNzemV0ICjDnykgdHVybnMgaW50byBcIlNTXCIgaW4gdXBwZXIgY2FzZS5cblxuICAgICAgICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgbG9jYWxlLWludmFyaWFudCBjb21wYXJpc29uLCB3aGljaCBtZWFucyBpdCBtYXkgbm90IG9iZXlcbiAgICAgICAgbG9jYWxlLXNwZWNpZmljIGV4cGVjdGF0aW9ucyAoZS5nLiBcImlcIiA9PiBcIsSwXCIpLlxuICAgICAgICovXG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBhY3R1YWwgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBzW2lkeF07XG4gICAgICAgIGlmIChhY3R1YWwgPT0gbnVsbCB8fCBhY3R1YWwudG9VcHBlckNhc2UoKSAhPT0gZXhwZWN0ZWQudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgaXMgY2FzZS1zZW5zaXRpdmUgY29tcGFyaXNvbi5cbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKHRoaXMubmV4dCgpICE9PSBzW2lkeF0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNvdXJjZVNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gIH0sXG5cbiAgaW50ZXJ2YWwoc3RhcnRJZHgsIG9wdEVuZElkeCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2UsIHN0YXJ0SWR4LCBvcHRFbmRJZHggPyBvcHRFbmRJZHggOiB0aGlzLnBvcyk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0U3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jb21tb24nKS5hc3NlcnQ7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gSW50ZXJ2YWwoc291cmNlU3RyaW5nLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gIHRoaXMuc291cmNlU3RyaW5nID0gc291cmNlU3RyaW5nO1xuICB0aGlzLnN0YXJ0SWR4ID0gc3RhcnRJZHg7XG4gIHRoaXMuZW5kSWR4ID0gZW5kSWR4O1xufVxuXG5JbnRlcnZhbC5jb3ZlcmFnZSA9IGZ1bmN0aW9uKC8qIGludGVydmFsMSwgaW50ZXJ2YWwyLCAuLi4gKi8pIHtcbiAgY29uc3Qgc291cmNlU3RyaW5nID0gYXJndW1lbnRzWzBdLnNvdXJjZVN0cmluZztcbiAgbGV0IHN0YXJ0SWR4ID0gYXJndW1lbnRzWzBdLnN0YXJ0SWR4O1xuICBsZXQgZW5kSWR4ID0gYXJndW1lbnRzWzBdLmVuZElkeDtcbiAgZm9yIChsZXQgaWR4ID0gMTsgaWR4IDwgYXJndW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IGFyZ3VtZW50c1tpZHhdO1xuICAgIGlmIChpbnRlcnZhbC5zb3VyY2VTdHJpbmcgIT09IHNvdXJjZVN0cmluZykge1xuICAgICAgdGhyb3cgZXJyb3JzLmludGVydmFsU291cmNlc0RvbnRNYXRjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydElkeCA9IE1hdGgubWluKHN0YXJ0SWR4LCBhcmd1bWVudHNbaWR4XS5zdGFydElkeCk7XG4gICAgICBlbmRJZHggPSBNYXRoLm1heChlbmRJZHgsIGFyZ3VtZW50c1tpZHhdLmVuZElkeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgSW50ZXJ2YWwoc291cmNlU3RyaW5nLCBzdGFydElkeCwgZW5kSWR4KTtcbn07XG5cbkludGVydmFsLnByb3RvdHlwZSA9IHtcbiAgY292ZXJhZ2VXaXRoKC8qIGludGVydmFsMSwgaW50ZXJ2YWwyLCAuLi4gKi8pIHtcbiAgICBjb25zdCBpbnRlcnZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGludGVydmFscy5wdXNoKHRoaXMpO1xuICAgIHJldHVybiBJbnRlcnZhbC5jb3ZlcmFnZS5hcHBseSh1bmRlZmluZWQsIGludGVydmFscyk7XG4gIH0sXG5cbiAgY29sbGFwc2VkTGVmdCgpIHtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLnN0YXJ0SWR4LCB0aGlzLnN0YXJ0SWR4KTtcbiAgfSxcblxuICBjb2xsYXBzZWRSaWdodCgpIHtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLmVuZElkeCwgdGhpcy5lbmRJZHgpO1xuICB9LFxuXG4gIGdldExpbmVBbmRDb2x1bW4oKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0TGluZUFuZENvbHVtbih0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCk7XG4gIH0sXG5cbiAgZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBbdGhpcy5zdGFydElkeCwgdGhpcy5lbmRJZHhdO1xuICAgIHJldHVybiB1dGlsLmdldExpbmVBbmRDb2x1bW5NZXNzYWdlKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLnN0YXJ0SWR4LCByYW5nZSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiAwLCAxLCBvciAyIGludGVydmFscyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiB0aGVcbiAgLy8gaW50ZXJ2YWwgZGlmZmVyZW5jZSBvcGVyYXRpb24uXG4gIG1pbnVzKHRoYXQpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VTdHJpbmcgIT09IHRoYXQuc291cmNlU3RyaW5nKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW50ZXJ2YWxTb3VyY2VzRG9udE1hdGNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0SWR4ID09PSB0aGF0LnN0YXJ0SWR4ICYmIHRoaXMuZW5kSWR4ID09PSB0aGF0LmVuZElkeCkge1xuICAgICAgLy8gYHRoaXNgIGFuZCBgdGhhdGAgYXJlIHRoZSBzYW1lIGludGVydmFsIVxuICAgICAgcmV0dXJuIFtcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0SWR4IDwgdGhhdC5zdGFydElkeCAmJiB0aGF0LmVuZElkeCA8IHRoaXMuZW5kSWR4KSB7XG4gICAgICAvLyBgdGhhdGAgc3BsaXRzIGB0aGlzYCBpbnRvIHR3byBpbnRlcnZhbHNcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCwgdGhhdC5zdGFydElkeCksXG4gICAgICAgIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhhdC5lbmRJZHgsIHRoaXMuZW5kSWR4KVxuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRJZHggPCB0aGF0LmVuZElkeCAmJiB0aGF0LmVuZElkeCA8IHRoaXMuZW5kSWR4KSB7XG4gICAgICAvLyBgdGhhdGAgY29udGFpbnMgYSBwcmVmaXggb2YgYHRoaXNgXG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHRoYXQuZW5kSWR4LCB0aGlzLmVuZElkeClcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0SWR4IDwgdGhhdC5zdGFydElkeCAmJiB0aGF0LnN0YXJ0SWR4IDwgdGhpcy5lbmRJZHgpIHtcbiAgICAgIC8vIGB0aGF0YCBjb250YWlucyBhIHN1ZmZpeCBvZiBgdGhpc2BcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCwgdGhhdC5zdGFydElkeClcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGB0aGF0YCBhbmQgYHRoaXNgIGRvIG5vdCBvdmVybGFwXG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzXG4gICAgICBdO1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgbmV3IEludGVydmFsIHRoYXQgaGFzIHRoZSBzYW1lIGV4dGVudCBhcyB0aGlzIG9uZSwgYnV0IHdoaWNoIGlzIHJlbGF0aXZlXG4gIC8vIHRvIGB0aGF0YCwgYW4gSW50ZXJ2YWwgdGhhdCBmdWxseSBjb3ZlcnMgdGhpcyBvbmUuXG4gIHJlbGF0aXZlVG8odGhhdCkge1xuICAgIGlmICh0aGlzLnNvdXJjZVN0cmluZyAhPT0gdGhhdC5zb3VyY2VTdHJpbmcpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbnRlcnZhbFNvdXJjZXNEb250TWF0Y2goKTtcbiAgICB9XG4gICAgYXNzZXJ0KHRoaXMuc3RhcnRJZHggPj0gdGhhdC5zdGFydElkeCAmJiB0aGlzLmVuZElkeCA8PSB0aGF0LmVuZElkeCxcbiAgICAgICAgJ290aGVyIGludGVydmFsIGRvZXMgbm90IGNvdmVyIHRoaXMgb25lJyk7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZyxcbiAgICAgICAgdGhpcy5zdGFydElkeCAtIHRoYXQuc3RhcnRJZHgsXG4gICAgICAgIHRoaXMuZW5kSWR4IC0gdGhhdC5zdGFydElkeCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIG5ldyBJbnRlcnZhbCB3aGljaCBjb250YWlucyB0aGUgc2FtZSBjb250ZW50cyBhcyB0aGlzIG9uZSxcbiAgLy8gYnV0IHdpdGggd2hpdGVzcGFjZSB0cmltbWVkIGZyb20gYm90aCBlbmRzLiAoVGhpcyBvbmx5IG1ha2VzIHNlbnNlIHdoZW5cbiAgLy8gdGhlIGlucHV0IHN0cmVhbSBpcyBhIHN0cmluZy4pXG4gIHRyaW1tZWQoKSB7XG4gICAgY29uc3QgY29udGVudHMgPSB0aGlzLmNvbnRlbnRzO1xuICAgIGNvbnN0IHN0YXJ0SWR4ID0gdGhpcy5zdGFydElkeCArIGNvbnRlbnRzLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBjb25zdCBlbmRJZHggPSB0aGlzLmVuZElkeCAtIGNvbnRlbnRzLm1hdGNoKC9cXHMqJC8pWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCBzdGFydElkeCwgZW5kSWR4KTtcbiAgfSxcblxuICBzdWJJbnRlcnZhbChvZmZzZXQsIGxlbikge1xuICAgIGNvbnN0IG5ld1N0YXJ0SWR4ID0gdGhpcy5zdGFydElkeCArIG9mZnNldDtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCBuZXdTdGFydElkeCwgbmV3U3RhcnRJZHggKyBsZW4pO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbnRlcnZhbC5wcm90b3R5cGUsIHtcbiAgY29udGVudHM6IHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fY29udGVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9jb250ZW50cyA9IHRoaXMuc291cmNlU3RyaW5nLnNsaWNlKHRoaXMuc3RhcnRJZHgsIHRoaXMuZW5kSWR4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50cztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgbGVuZ3RoOiB7XG4gICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5lbmRJZHggLSB0aGlzLnN0YXJ0SWR4OyB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfVxufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVydmFsO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBNYXRjaFJlc3VsdChcbiAgICBtYXRjaGVyLFxuICAgIGlucHV0LFxuICAgIHN0YXJ0RXhwcixcbiAgICBjc3QsXG4gICAgY3N0T2Zmc2V0LFxuICAgIHJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbixcbiAgICBvcHRSZWNvcmRlZEZhaWx1cmVzKSB7XG5cbiAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB0aGlzLnN0YXJ0RXhwciA9IHN0YXJ0RXhwcjtcbiAgdGhpcy5fY3N0ID0gY3N0O1xuICB0aGlzLl9jc3RPZmZzZXQgPSBjc3RPZmZzZXQ7XG4gIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IHJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbjtcbiAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZXMgPSBvcHRSZWNvcmRlZEZhaWx1cmVzO1xuXG4gIGlmICh0aGlzLmZhaWxlZCgpKSB7XG4gICAgY29tbW9uLmRlZmluZUxhenlQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGV0YWlsID0gJ0V4cGVjdGVkICcgKyB0aGlzLmdldEV4cGVjdGVkVGV4dCgpO1xuICAgICAgcmV0dXJuIHV0aWwuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UodGhpcy5pbnB1dCwgdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSkgKyBkZXRhaWw7XG4gICAgfSk7XG4gICAgY29tbW9uLmRlZmluZUxhenlQcm9wZXJ0eSh0aGlzLCAnc2hvcnRNZXNzYWdlJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBkZXRhaWwgPSAnZXhwZWN0ZWQgJyArIHRoaXMuZ2V0RXhwZWN0ZWRUZXh0KCk7XG4gICAgICBjb25zdCBlcnJvckluZm8gPSB1dGlsLmdldExpbmVBbmRDb2x1bW4odGhpcy5pbnB1dCwgdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSk7XG4gICAgICByZXR1cm4gJ0xpbmUgJyArIGVycm9ySW5mby5saW5lTnVtICsgJywgY29sICcgKyBlcnJvckluZm8uY29sTnVtICsgJzogJyArIGRldGFpbDtcbiAgICB9KTtcbiAgfVxufVxuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuc3VjY2VlZGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuX2NzdDtcbn07XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS5mYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnN1Y2NlZWRlZCgpO1xufTtcblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uO1xufTtcblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmdldFJpZ2h0bW9zdEZhaWx1cmVzID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmlnaHRtb3N0RmFpbHVyZXMpIHtcbiAgICB0aGlzLm1hdGNoZXIuc2V0SW5wdXQodGhpcy5pbnB1dCk7XG4gICAgY29uc3QgbWF0Y2hSZXN1bHRXaXRoRmFpbHVyZXMgPVxuICAgICAgICB0aGlzLm1hdGNoZXIuX21hdGNoKHRoaXMuc3RhcnRFeHByLCBmYWxzZSwgdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSk7XG4gICAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZXMgPSBtYXRjaFJlc3VsdFdpdGhGYWlsdXJlcy5nZXRSaWdodG1vc3RGYWlsdXJlcygpO1xuICB9XG4gIHJldHVybiB0aGlzLl9yaWdodG1vc3RGYWlsdXJlcztcbn07XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zdWNjZWVkZWQoKSA/XG4gICAgICAnW21hdGNoIHN1Y2NlZWRlZF0nIDpcbiAgICAgICdbbWF0Y2ggZmFpbGVkIGF0IHBvc2l0aW9uICcgKyB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpICsgJ10nO1xufTtcblxuLy8gUmV0dXJuIGEgc3RyaW5nIHN1bW1hcml6aW5nIHRoZSBleHBlY3RlZCBjb250ZW50cyBvZiB0aGUgaW5wdXQgc3RyZWFtIHdoZW5cbi8vIHRoZSBtYXRjaCBmYWlsdXJlIG9jY3VycmVkLlxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmdldEV4cGVjdGVkVGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdWNjZWVkZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBleHBlY3RlZCB0ZXh0IG9mIGEgc3VjY2Vzc2Z1bCBNYXRjaFJlc3VsdCcpO1xuICB9XG5cbiAgY29uc3Qgc2IgPSBuZXcgY29tbW9uLlN0cmluZ0J1ZmZlcigpO1xuICBsZXQgZmFpbHVyZXMgPSB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVzKCk7XG5cbiAgLy8gRmlsdGVyIG91dCB0aGUgZmx1ZmZ5IGZhaWx1cmVzIHRvIG1ha2UgdGhlIGRlZmF1bHQgZXJyb3IgbWVzc2FnZXMgbW9yZSB1c2VmdWxcbiAgZmFpbHVyZXMgPSBmYWlsdXJlcy5maWx0ZXIoZmFpbHVyZSA9PiAhZmFpbHVyZS5pc0ZsdWZmeSgpKTtcblxuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBmYWlsdXJlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgaWYgKGlkeCA+IDApIHtcbiAgICAgIGlmIChpZHggPT09IGZhaWx1cmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc2IuYXBwZW5kKGZhaWx1cmVzLmxlbmd0aCA+IDIgPyAnLCBvciAnIDogJyBvciAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNiLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2IuYXBwZW5kKGZhaWx1cmVzW2lkeF0udG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIHNiLmNvbnRlbnRzKCk7XG59O1xuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcG9zID0gdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKTtcbiAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLmlucHV0LCBwb3MsIHBvcyk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaFJlc3VsdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IElucHV0U3RyZWFtID0gcmVxdWlyZSgnLi9JbnB1dFN0cmVhbScpO1xuY29uc3QgTWF0Y2hSZXN1bHQgPSByZXF1aXJlKCcuL01hdGNoUmVzdWx0Jyk7XG5jb25zdCBQb3NJbmZvID0gcmVxdWlyZSgnLi9Qb3NJbmZvJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vVHJhY2UnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhcHBseVNwYWNlcyA9IG5ldyBwZXhwcnMuQXBwbHkoJ3NwYWNlcycpO1xuXG5mdW5jdGlvbiBNYXRjaFN0YXRlKG1hdGNoZXIsIHN0YXJ0RXhwciwgb3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gIHRoaXMuc3RhcnRFeHByID0gc3RhcnRFeHByO1xuXG4gIHRoaXMuZ3JhbW1hciA9IG1hdGNoZXIuZ3JhbW1hcjtcbiAgdGhpcy5pbnB1dCA9IG1hdGNoZXIuaW5wdXQ7XG4gIHRoaXMuaW5wdXRTdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0obWF0Y2hlci5pbnB1dCk7XG4gIHRoaXMubWVtb1RhYmxlID0gbWF0Y2hlci5tZW1vVGFibGU7XG5cbiAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgdGhpcy5fYmluZGluZ09mZnNldHMgPSBbXTtcbiAgdGhpcy5fYXBwbGljYXRpb25TdGFjayA9IFtdO1xuICB0aGlzLl9wb3NTdGFjayA9IFswXTtcbiAgdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrID0gW2ZhbHNlXTtcblxuICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IC0xO1xuICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb25TdGFjayA9IFtdO1xuICB0aGlzLl9yZWNvcmRlZEZhaWx1cmVzU3RhY2sgPSBbXTtcblxuICBpZiAob3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcyA9IG9wdFBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcztcbiAgICB0aGlzLnJlY29yZGVkRmFpbHVyZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG59XG5cbk1hdGNoU3RhdGUucHJvdG90eXBlID0ge1xuICBwb3NUb09mZnNldChwb3MpIHtcbiAgICByZXR1cm4gcG9zIC0gdGhpcy5fcG9zU3RhY2tbdGhpcy5fcG9zU3RhY2subGVuZ3RoIC0gMV07XG4gIH0sXG5cbiAgZW50ZXJBcHBsaWNhdGlvbihwb3NJbmZvLCBhcHApIHtcbiAgICB0aGlzLl9wb3NTdGFjay5wdXNoKHRoaXMuaW5wdXRTdHJlYW0ucG9zKTtcbiAgICB0aGlzLl9hcHBsaWNhdGlvblN0YWNrLnB1c2goYXBwKTtcbiAgICB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2sucHVzaChmYWxzZSk7XG4gICAgcG9zSW5mby5lbnRlcihhcHApO1xuICAgIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvblN0YWNrLnB1c2godGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24pO1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gLTE7XG4gIH0sXG5cbiAgZXhpdEFwcGxpY2F0aW9uKHBvc0luZm8sIG9wdE5vZGUpIHtcbiAgICBjb25zdCBvcmlnUG9zID0gdGhpcy5fcG9zU3RhY2sucG9wKCk7XG4gICAgdGhpcy5fYXBwbGljYXRpb25TdGFjay5wb3AoKTtcbiAgICB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2sucG9wKCk7XG4gICAgcG9zSW5mby5leGl0KCk7XG5cbiAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IE1hdGgubWF4KFxuICAgICAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbixcbiAgICAgICAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uU3RhY2sucG9wKCkpO1xuXG4gICAgaWYgKG9wdE5vZGUpIHtcbiAgICAgIHRoaXMucHVzaEJpbmRpbmcob3B0Tm9kZSwgb3JpZ1Bvcyk7XG4gICAgfVxuICB9LFxuXG4gIGVudGVyTGV4aWZpZWRDb250ZXh0KCkge1xuICAgIHRoaXMuaW5MZXhpZmllZENvbnRleHRTdGFjay5wdXNoKHRydWUpO1xuICB9LFxuXG4gIGV4aXRMZXhpZmllZENvbnRleHQoKSB7XG4gICAgdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrLnBvcCgpO1xuICB9LFxuXG4gIGN1cnJlbnRBcHBsaWNhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25TdGFja1t0aGlzLl9hcHBsaWNhdGlvblN0YWNrLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIGluU3ludGFjdGljQ29udGV4dCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuaW5wdXRTdHJlYW0uc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50QXBwbGljYXRpb24gPSB0aGlzLmN1cnJlbnRBcHBsaWNhdGlvbigpO1xuICAgIGlmIChjdXJyZW50QXBwbGljYXRpb24pIHtcbiAgICAgIHJldHVybiBjdXJyZW50QXBwbGljYXRpb24uaXNTeW50YWN0aWMoKSAmJiAhdGhpcy5pbkxleGlmaWVkQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgdG9wLWxldmVsIGNvbnRleHQgaXMgc3ludGFjdGljIGlmIHRoZSBzdGFydCBhcHBsaWNhdGlvbiBpcy5cbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0RXhwci5mYWN0b3JzWzBdLmlzU3ludGFjdGljKCk7XG4gICAgfVxuICB9LFxuXG4gIGluTGV4aWZpZWRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2tbdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIHNraXBTcGFjZXMoKSB7XG4gICAgdGhpcy5wdXNoRmFpbHVyZXNJbmZvKCk7XG4gICAgdGhpcy5ldmFsKGFwcGx5U3BhY2VzKTtcbiAgICB0aGlzLnBvcEJpbmRpbmcoKTtcbiAgICB0aGlzLnBvcEZhaWx1cmVzSW5mbygpO1xuICAgIHJldHVybiB0aGlzLmlucHV0U3RyZWFtLnBvcztcbiAgfSxcblxuICBza2lwU3BhY2VzSWZJblN5bnRhY3RpY0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5TeW50YWN0aWNDb250ZXh0KCkgP1xuICAgICAgICB0aGlzLnNraXBTcGFjZXMoKSA6XG4gICAgICAgIHRoaXMuaW5wdXRTdHJlYW0ucG9zO1xuICB9LFxuXG4gIG1heWJlU2tpcFNwYWNlc0JlZm9yZShleHByKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuQXBwbHkgJiYgZXhwci5pc1N5bnRhY3RpYygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5za2lwU3BhY2VzKCk7XG4gICAgfSBlbHNlIGlmIChleHByLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UoKSAmJiBleHByICE9PSBhcHBseVNwYWNlcykge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcFNwYWNlc0lmSW5TeW50YWN0aWNDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0U3RyZWFtLnBvcztcbiAgICB9XG4gIH0sXG5cbiAgcHVzaEJpbmRpbmcobm9kZSwgb3JpZ1Bvcykge1xuICAgIHRoaXMuX2JpbmRpbmdzLnB1c2gobm9kZSk7XG4gICAgdGhpcy5fYmluZGluZ09mZnNldHMucHVzaCh0aGlzLnBvc1RvT2Zmc2V0KG9yaWdQb3MpKTtcbiAgfSxcblxuICBwb3BCaW5kaW5nKCkge1xuICAgIHRoaXMuX2JpbmRpbmdzLnBvcCgpO1xuICAgIHRoaXMuX2JpbmRpbmdPZmZzZXRzLnBvcCgpO1xuICB9LFxuXG4gIG51bUJpbmRpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gIH0sXG5cbiAgdHJ1bmNhdGVCaW5kaW5ncyhuZXdMZW5ndGgpIHtcbiAgICAvLyBZZXMsIHRoaXMgaXMgdGhpcyByZWFsbHkgZmFzdGVyIHRoYW4gc2V0dGluZyB0aGUgYGxlbmd0aGAgcHJvcGVydHkgKHRlc3RlZCB3aXRoXG4gICAgLy8gYmluL2VzNWJlbmNoIG9uIE5vZGUgdjYuMS4wKS5cbiAgICB3aGlsZSAodGhpcy5fYmluZGluZ3MubGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB0aGlzLnBvcEJpbmRpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Q3VycmVudFBvc0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9zSW5mbyh0aGlzLmlucHV0U3RyZWFtLnBvcyk7XG4gIH0sXG5cbiAgZ2V0UG9zSW5mbyhwb3MpIHtcbiAgICBsZXQgcG9zSW5mbyA9IHRoaXMubWVtb1RhYmxlW3Bvc107XG4gICAgaWYgKCFwb3NJbmZvKSB7XG4gICAgICBwb3NJbmZvID0gdGhpcy5tZW1vVGFibGVbcG9zXSA9IG5ldyBQb3NJbmZvKCk7XG4gICAgfVxuICAgIHJldHVybiBwb3NJbmZvO1xuICB9LFxuXG4gIHByb2Nlc3NGYWlsdXJlKHBvcywgZXhwcikge1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gTWF0aC5tYXgodGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sIHBvcyk7XG5cbiAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzICYmIHBvcyA9PT0gdGhpcy5wb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY3VycmVudEFwcGxpY2F0aW9uKCk7XG4gICAgICBpZiAoYXBwKSB7XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgcGFyYW1ldGVycyB3aXRoIHRoZSBhY3R1YWwgcGV4cHJzIHRoYXQgd2VyZSBwYXNzZWQgdG9cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgcnVsZS5cbiAgICAgICAgZXhwciA9IGV4cHIuc3Vic3RpdHV0ZVBhcmFtcyhhcHAuYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGJyYW5jaCBpcyBvbmx5IHJlYWNoZWQgZm9yIHRoZSBcImVuZC1jaGVja1wiIHRoYXQgaXNcbiAgICAgICAgLy8gcGVyZm9ybWVkIGFmdGVyIHRoZSB0b3AtbGV2ZWwgYXBwbGljYXRpb24uIEluIHRoYXQgY2FzZSxcbiAgICAgICAgLy8gZXhwciA9PT0gcGV4cHJzLmVuZCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHN1YnN0aXR1dGVcbiAgICAgICAgLy8gcGFyYW1ldGVycy5cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNvcmRGYWlsdXJlKGV4cHIudG9GYWlsdXJlKHRoaXMuZ3JhbW1hciksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVjb3JkRmFpbHVyZShmYWlsdXJlLCBzaG91bGRDbG9uZUlmTmV3KSB7XG4gICAgY29uc3Qga2V5ID0gZmFpbHVyZS50b0tleSgpO1xuICAgIGlmICghdGhpcy5yZWNvcmRlZEZhaWx1cmVzW2tleV0pIHtcbiAgICAgIHRoaXMucmVjb3JkZWRGYWlsdXJlc1trZXldID0gc2hvdWxkQ2xvbmVJZk5ldyA/IGZhaWx1cmUuY2xvbmUoKSA6IGZhaWx1cmU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXNba2V5XS5pc0ZsdWZmeSgpICYmICFmYWlsdXJlLmlzRmx1ZmZ5KCkpIHtcbiAgICAgIHRoaXMucmVjb3JkZWRGYWlsdXJlc1trZXldLmNsZWFyRmx1ZmZ5KCk7XG4gICAgfVxuICB9LFxuXG4gIHJlY29yZEZhaWx1cmVzKGZhaWx1cmVzLCBzaG91bGRDbG9uZUlmTmV3KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoZmFpbHVyZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHNlbGYucmVjb3JkRmFpbHVyZShmYWlsdXJlc1trZXldLCBzaG91bGRDbG9uZUlmTmV3KTtcbiAgICB9KTtcbiAgfSxcblxuICBjbG9uZVJlY29yZGVkRmFpbHVyZXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlY29yZGVkRmFpbHVyZXMpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgYW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLnJlY29yZGVkRmFpbHVyZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGFuc1trZXldID0gc2VsZi5yZWNvcmRlZEZhaWx1cmVzW2tleV0uY2xvbmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIGdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb247XG4gIH0sXG5cbiAgX2dldFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID49IDAgP1xuICAgICAgICB0aGlzLnBvc1RvT2Zmc2V0KHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKSA6XG4gICAgICAgIC0xO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIG1lbW9pemVkIHRyYWNlIGVudHJ5IGZvciBgZXhwcmAgYXQgYHBvc2AsIGlmIG9uZSBleGlzdHMsIGBudWxsYCBvdGhlcndpc2UuXG4gIGdldE1lbW9pemVkVHJhY2VFbnRyeShwb3MsIGV4cHIpIHtcbiAgICBjb25zdCBwb3NJbmZvID0gdGhpcy5tZW1vVGFibGVbcG9zXTtcbiAgICBpZiAocG9zSW5mbyAmJiBleHByLnJ1bGVOYW1lKSB7XG4gICAgICBjb25zdCBtZW1vUmVjID0gcG9zSW5mby5tZW1vW2V4cHIudG9NZW1vS2V5KCldO1xuICAgICAgaWYgKG1lbW9SZWMgJiYgbWVtb1JlYy50cmFjZUVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbWVtb1JlYy50cmFjZUVudHJ5LmNsb25lV2l0aEV4cHIoZXhwcik7XG4gICAgICAgIGVudHJ5LmlzTWVtb2l6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBuZXcgdHJhY2UgZW50cnksIHdpdGggdGhlIGN1cnJlbnRseSBhY3RpdmUgdHJhY2UgYXJyYXkgYXMgaXRzIGNoaWxkcmVuLlxuICBnZXRUcmFjZUVudHJ5KHBvcywgZXhwciwgc3VjY2VlZGVkLCBiaW5kaW5ncykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgcGV4cHJzLkFwcGx5KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzLmN1cnJlbnRBcHBsaWNhdGlvbigpO1xuICAgICAgY29uc3QgYWN0dWFscyA9IGFwcCA/IGFwcC5hcmdzIDogW107XG4gICAgICBleHByID0gZXhwci5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRNZW1vaXplZFRyYWNlRW50cnkocG9zLCBleHByKSB8fFxuICAgICAgICAgICBuZXcgVHJhY2UodGhpcy5pbnB1dCwgcG9zLCB0aGlzLmlucHV0U3RyZWFtLnBvcywgZXhwciwgc3VjY2VlZGVkLCBiaW5kaW5ncywgdGhpcy50cmFjZSk7XG4gIH0sXG5cbiAgaXNUcmFjaW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMudHJhY2U7XG4gIH0sXG5cbiAgaGFzTmVjZXNzYXJ5SW5mbyhtZW1vUmVjKSB7XG4gICAgaWYgKHRoaXMudHJhY2UgJiYgIW1lbW9SZWMudHJhY2VFbnRyeSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMgJiZcbiAgICAgICAgdGhpcy5pbnB1dFN0cmVhbS5wb3MgKyBtZW1vUmVjLnJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPT09IHRoaXMucG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gICAgICByZXR1cm4gISFtZW1vUmVjLmZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuXG4gIHVzZU1lbW9pemVkUmVzdWx0KG9yaWdQb3MsIG1lbW9SZWMpIHtcbiAgICBpZiAodGhpcy50cmFjZSkge1xuICAgICAgdGhpcy50cmFjZS5wdXNoKG1lbW9SZWMudHJhY2VFbnRyeSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVtb1JlY1JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IHRoaXMuaW5wdXRTdHJlYW0ucG9zICsgbWVtb1JlYy5yaWdodG1vc3RGYWlsdXJlT2Zmc2V0O1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID1cbiAgICAgICAgTWF0aC5tYXgodGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sIG1lbW9SZWNSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24pO1xuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMgJiZcbiAgICAgICAgdGhpcy5wb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMgPT09IG1lbW9SZWNSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gJiZcbiAgICAgICAgbWVtb1JlYy5mYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb24pIHtcbiAgICAgIHRoaXMucmVjb3JkRmFpbHVyZXMobWVtb1JlYy5mYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb24sIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGggPVxuICAgICAgICBNYXRoLm1heCh0aGlzLmlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoLCBtZW1vUmVjLmV4YW1pbmVkTGVuZ3RoICsgb3JpZ1Bvcyk7XG5cbiAgICBpZiAobWVtb1JlYy52YWx1ZSkge1xuICAgICAgdGhpcy5pbnB1dFN0cmVhbS5wb3MgKz0gbWVtb1JlYy5tYXRjaExlbmd0aDtcbiAgICAgIHRoaXMucHVzaEJpbmRpbmcobWVtb1JlYy52YWx1ZSwgb3JpZ1Bvcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8vIEV2YWx1YXRlIGBleHByYCBhbmQgcmV0dXJuIGB0cnVlYCBpZiBpdCBzdWNjZWVkZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBPbiBzdWNjZXNzLCBgYmluZGluZ3NgXG4gIC8vIHdpbGwgaGF2ZSBgZXhwci5nZXRBcml0eSgpYCBtb3JlIGVsZW1lbnRzIHRoYW4gYmVmb3JlLCBhbmQgdGhlIGlucHV0IHN0cmVhbSdzIHBvc2l0aW9uIG1heVxuICAvLyBoYXZlIGluY3JlYXNlZC4gT24gZmFpbHVyZSwgYGJpbmRpbmdzYCBhbmQgcG9zaXRpb24gd2lsbCBiZSB1bmNoYW5nZWQuXG4gIGV2YWwoZXhwcikge1xuICAgIGNvbnN0IGlucHV0U3RyZWFtID0gdGhpcy5pbnB1dFN0cmVhbTtcbiAgICBjb25zdCBvcmlnTnVtQmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG5cbiAgICBsZXQgb3JpZ1JlY29yZGVkRmFpbHVyZXM7XG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcykge1xuICAgICAgb3JpZ1JlY29yZGVkRmFpbHVyZXMgPSB0aGlzLnJlY29yZGVkRmFpbHVyZXM7XG4gICAgICB0aGlzLnJlY29yZGVkRmFpbHVyZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gICAgY29uc3QgbWVtb1BvcyA9IHRoaXMubWF5YmVTa2lwU3BhY2VzQmVmb3JlKGV4cHIpO1xuXG4gICAgbGV0IG9yaWdUcmFjZTtcbiAgICBpZiAodGhpcy50cmFjZSkge1xuICAgICAgb3JpZ1RyYWNlID0gdGhpcy50cmFjZTtcbiAgICAgIHRoaXMudHJhY2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBEbyB0aGUgYWN0dWFsIGV2YWx1YXRpb24uXG4gICAgY29uc3QgYW5zID0gZXhwci5ldmFsKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMudHJhY2UpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3Muc2xpY2Uob3JpZ051bUJpbmRpbmdzKTtcbiAgICAgIGNvbnN0IHRyYWNlRW50cnkgPSB0aGlzLmdldFRyYWNlRW50cnkobWVtb1BvcywgZXhwciwgYW5zLCBiaW5kaW5ncyk7XG4gICAgICB0cmFjZUVudHJ5LmlzSW1wbGljaXRTcGFjZXMgPSBleHByID09PSBhcHBseVNwYWNlcztcbiAgICAgIHRyYWNlRW50cnkuaXNSb290Tm9kZSA9IGV4cHIgPT09IHRoaXMuc3RhcnRFeHByO1xuICAgICAgb3JpZ1RyYWNlLnB1c2godHJhY2VFbnRyeSk7XG4gICAgICB0aGlzLnRyYWNlID0gb3JpZ1RyYWNlO1xuICAgIH1cblxuICAgIGlmIChhbnMpIHtcbiAgICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMgJiYgaW5wdXRTdHJlYW0ucG9zID09PSB0aGlzLnBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5yZWNvcmRlZEZhaWx1cmVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgc2VsZi5yZWNvcmRlZEZhaWx1cmVzW2tleV0ubWFrZUZsdWZmeSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIGFuZCB0aGUgYmluZGluZ3MuXG4gICAgICBpbnB1dFN0cmVhbS5wb3MgPSBvcmlnUG9zO1xuICAgICAgdGhpcy50cnVuY2F0ZUJpbmRpbmdzKG9yaWdOdW1CaW5kaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcykge1xuICAgICAgdGhpcy5yZWNvcmRGYWlsdXJlcyhvcmlnUmVjb3JkZWRGYWlsdXJlcywgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgZ2V0TWF0Y2hSZXN1bHQoKSB7XG4gICAgdGhpcy5ldmFsKHRoaXMuc3RhcnRFeHByKTtcbiAgICBsZXQgcmlnaHRtb3N0RmFpbHVyZXM7XG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByaWdodG1vc3RGYWlsdXJlcyA9IE9iamVjdC5rZXlzKHRoaXMucmVjb3JkZWRGYWlsdXJlcykubWFwKGtleSA9PiBzZWxmLnJlY29yZGVkRmFpbHVyZXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWF0Y2hSZXN1bHQoXG4gICAgICAgIHRoaXMubWF0Y2hlcixcbiAgICAgICAgdGhpcy5pbnB1dCxcbiAgICAgICAgdGhpcy5zdGFydEV4cHIsXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzWzBdLFxuICAgICAgICB0aGlzLl9iaW5kaW5nT2Zmc2V0c1swXSxcbiAgICAgICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sXG4gICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzKTtcbiAgfSxcblxuICBnZXRUcmFjZSgpIHtcbiAgICB0aGlzLnRyYWNlID0gW107XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSB0aGlzLmdldE1hdGNoUmVzdWx0KCk7XG5cbiAgICAvLyBUaGUgdHJhY2Ugbm9kZSBmb3IgdGhlIHN0YXJ0IHJ1bGUgaXMgYWx3YXlzIHRoZSBsYXN0IGVudHJ5LiBJZiBpdCBpcyBhIHN5bnRhY3RpYyBydWxlLFxuICAgIC8vIHRoZSBmaXJzdCBlbnRyeSBpcyBmb3IgYW4gYXBwbGljYXRpb24gb2YgJ3NwYWNlcycuXG4gICAgLy8gVE9ETyhwZHVicm95KTogQ2xlYW4gdGhpcyB1cCBieSBpbnRyb2R1Y2luZyBhIHNwZWNpYWwgYE1hdGNoPHN0YXJ0QXBwbD5gIHJ1bGUsIHdoaWNoIHdpbGxcbiAgICAvLyBlbnN1cmUgdGhhdCB0aGVyZSBpcyBhbHdheXMgYSBzaW5nbGUgcm9vdCB0cmFjZSBub2RlLlxuICAgIGNvbnN0IHJvb3RUcmFjZSA9IHRoaXMudHJhY2VbdGhpcy50cmFjZS5sZW5ndGggLSAxXTtcbiAgICByb290VHJhY2UucmVzdWx0ID0gbWF0Y2hSZXN1bHQ7XG4gICAgcmV0dXJuIHJvb3RUcmFjZTtcbiAgfSxcblxuICBwdXNoRmFpbHVyZXNJbmZvKCkge1xuICAgIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvblN0YWNrLnB1c2godGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24pO1xuICAgIHRoaXMuX3JlY29yZGVkRmFpbHVyZXNTdGFjay5wdXNoKHRoaXMucmVjb3JkZWRGYWlsdXJlcyk7XG4gIH0sXG5cbiAgcG9wRmFpbHVyZXNJbmZvKCkge1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uU3RhY2sucG9wKCk7XG4gICAgdGhpcy5yZWNvcmRlZEZhaWx1cmVzID0gdGhpcy5fcmVjb3JkZWRGYWlsdXJlc1N0YWNrLnBvcCgpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaFN0YXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgTWF0Y2hTdGF0ZSA9IHJlcXVpcmUoJy4vTWF0Y2hTdGF0ZScpO1xuXG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gTWF0Y2hlcihncmFtbWFyKSB7XG4gIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG4gIHRoaXMubWVtb1RhYmxlID0gW107XG4gIHRoaXMuaW5wdXQgPSAnJztcbn1cblxuTWF0Y2hlci5wcm90b3R5cGUuZ2V0SW5wdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW5wdXQ7XG59O1xuXG5NYXRjaGVyLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAodGhpcy5pbnB1dCAhPT0gc3RyKSB7XG4gICAgdGhpcy5yZXBsYWNlSW5wdXRSYW5nZSgwLCB0aGlzLmlucHV0Lmxlbmd0aCwgc3RyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLnJlcGxhY2VJbnB1dFJhbmdlID0gZnVuY3Rpb24oc3RhcnRJZHgsIGVuZElkeCwgc3RyKSB7XG4gIGNvbnN0IGN1cnJlbnRJbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIGlmIChzdGFydElkeCA8IDAgfHwgc3RhcnRJZHggPiBjdXJyZW50SW5wdXQubGVuZ3RoIHx8XG4gICAgICBlbmRJZHggPCAwIHx8IGVuZElkeCA+IGN1cnJlbnRJbnB1dC5sZW5ndGggfHxcbiAgICAgIHN0YXJ0SWR4ID4gZW5kSWR4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGljZXM6ICcgKyBzdGFydElkeCArICcgYW5kICcgKyBlbmRJZHgpO1xuICB9XG5cbiAgLy8gdXBkYXRlIGlucHV0XG4gIHRoaXMuaW5wdXQgPSBjdXJyZW50SW5wdXQuc2xpY2UoMCwgc3RhcnRJZHgpICsgc3RyICsgY3VycmVudElucHV0LnNsaWNlKGVuZElkeCk7XG5cbiAgLy8gdXBkYXRlIG1lbW8gdGFibGUgKHNpbWlsYXIgdG8gdGhlIGFib3ZlKVxuICBjb25zdCByZXN0T2ZNZW1vVGFibGUgPSB0aGlzLm1lbW9UYWJsZS5zbGljZShlbmRJZHgpO1xuICB0aGlzLm1lbW9UYWJsZS5sZW5ndGggPSBzdGFydElkeDtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc3RyLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLm1lbW9UYWJsZS5wdXNoKHVuZGVmaW5lZCk7XG4gIH1cbiAgcmVzdE9mTWVtb1RhYmxlLmZvckVhY2goXG4gICAgICBmdW5jdGlvbihwb3NJbmZvKSB7IHRoaXMubWVtb1RhYmxlLnB1c2gocG9zSW5mbyk7IH0sXG4gICAgICB0aGlzKTtcblxuICAvLyBJbnZhbGlkYXRlIG1lbW9SZWNzXG4gIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXJ0SWR4OyBwb3MrKykge1xuICAgIGNvbnN0IHBvc0luZm8gPSB0aGlzLm1lbW9UYWJsZVtwb3NdO1xuICAgIGlmIChwb3NJbmZvKSB7XG4gICAgICBwb3NJbmZvLmNsZWFyT2Jzb2xldGVFbnRyaWVzKHBvcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvcHRTdGFydEFwcGxpY2F0aW9uU3RyKSB7XG4gIHJldHVybiB0aGlzLl9tYXRjaCh0aGlzLl9nZXRTdGFydEV4cHIob3B0U3RhcnRBcHBsaWNhdGlvblN0ciksIGZhbHNlKTtcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24ob3B0U3RhcnRBcHBsaWNhdGlvblN0cikge1xuICByZXR1cm4gdGhpcy5fbWF0Y2godGhpcy5fZ2V0U3RhcnRFeHByKG9wdFN0YXJ0QXBwbGljYXRpb25TdHIpLCB0cnVlKTtcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLl9tYXRjaCA9IGZ1bmN0aW9uKHN0YXJ0RXhwciwgdHJhY2luZywgb3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gIGNvbnN0IHN0YXRlID0gbmV3IE1hdGNoU3RhdGUodGhpcywgc3RhcnRFeHByLCBvcHRQb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpO1xuICByZXR1cm4gdHJhY2luZyA/IHN0YXRlLmdldFRyYWNlKCkgOiBzdGF0ZS5nZXRNYXRjaFJlc3VsdCgpO1xufTtcblxuLypcbiAgUmV0dXJucyB0aGUgc3RhcnRpbmcgZXhwcmVzc2lvbiBmb3IgdGhpcyBNYXRjaGVyJ3MgYXNzb2NpYXRlZCBncmFtbWFyLiBJZiBgb3B0U3RhcnRBcHBsaWNhdGlvblN0cmBcbiAgaXMgc3BlY2lmaWVkLCBpdCBpcyBhIHN0cmluZyBleHByZXNzaW5nIGEgcnVsZSBhcHBsaWNhdGlvbiBpbiB0aGUgZ3JhbW1hci4gSWYgbm90IHNwZWNpZmllZCwgdGhlXG4gIGdyYW1tYXIncyBkZWZhdWx0IHN0YXJ0IHJ1bGUgd2lsbCBiZSB1c2VkLlxuKi9cbk1hdGNoZXIucHJvdG90eXBlLl9nZXRTdGFydEV4cHIgPSBmdW5jdGlvbihvcHRTdGFydEFwcGxpY2F0aW9uU3RyKSB7XG4gIGNvbnN0IGFwcGxpY2F0aW9uU3RyID0gb3B0U3RhcnRBcHBsaWNhdGlvblN0ciB8fCB0aGlzLmdyYW1tYXIuZGVmYXVsdFN0YXJ0UnVsZTtcbiAgaWYgKCFhcHBsaWNhdGlvblN0cikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzdGFydCBydWxlIGFyZ3VtZW50IC0tIHRoZSBncmFtbWFyIGhhcyBubyBkZWZhdWx0IHN0YXJ0IHJ1bGUuJyk7XG4gIH1cblxuICBjb25zdCBzdGFydEFwcCA9IHRoaXMuZ3JhbW1hci5wYXJzZUFwcGxpY2F0aW9uKGFwcGxpY2F0aW9uU3RyKTtcbiAgcmV0dXJuIG5ldyBwZXhwcnMuU2VxKFtzdGFydEFwcCwgcGV4cHJzLmVuZF0pO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0Y2hlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3V0aWwtZXh0ZW5kJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBOYW1lc3BhY2UoKSB7XG59XG5OYW1lc3BhY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuTmFtZXNwYWNlLmFzTmFtZXNwYWNlID0gZnVuY3Rpb24ob2JqT3JOYW1lc3BhY2UpIHtcbiAgaWYgKG9iak9yTmFtZXNwYWNlIGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIG9iak9yTmFtZXNwYWNlO1xuICB9XG4gIHJldHVybiBOYW1lc3BhY2UuY3JlYXRlTmFtZXNwYWNlKG9iak9yTmFtZXNwYWNlKTtcbn07XG5cbi8vIENyZWF0ZSBhIG5ldyBuYW1lc3BhY2UuIElmIGBvcHRQcm9wc2AgaXMgc3BlY2lmaWVkLCBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbi8vIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgbmFtZXNwYWNlLlxuTmFtZXNwYWNlLmNyZWF0ZU5hbWVzcGFjZSA9IGZ1bmN0aW9uKG9wdFByb3BzKSB7XG4gIHJldHVybiBOYW1lc3BhY2UuZXh0ZW5kKE5hbWVzcGFjZS5wcm90b3R5cGUsIG9wdFByb3BzKTtcbn07XG5cbi8vIENyZWF0ZSBhIG5ldyBuYW1lc3BhY2Ugd2hpY2ggZXh0ZW5kcyBhbm90aGVyIG5hbWVzcGFjZS4gSWYgYG9wdFByb3BzYCBpc1xuLy8gc3BlY2lmaWVkLCBhbGwgb2YgaXRzIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBuYW1lc3BhY2UuXG5OYW1lc3BhY2UuZXh0ZW5kID0gZnVuY3Rpb24obmFtZXNwYWNlLCBvcHRQcm9wcykge1xuICBpZiAobmFtZXNwYWNlICE9PSBOYW1lc3BhY2UucHJvdG90eXBlICYmICEobmFtZXNwYWNlIGluc3RhbmNlb2YgTmFtZXNwYWNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIE5hbWVzcGFjZSBvYmplY3Q6ICcgKyBuYW1lc3BhY2UpO1xuICB9XG4gIGNvbnN0IG5zID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IE5hbWVzcGFjZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXh0ZW5kKG5zLCBvcHRQcm9wcyk7XG59O1xuXG4vLyBUT0RPOiBTaG91bGQgdGhpcyBiZSBhIHJlZ3VsYXIgbWV0aG9kP1xuTmFtZXNwYWNlLnRvU3RyaW5nID0gZnVuY3Rpb24obnMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChucyk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBOYW1lc3BhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBQb3NJbmZvKCkge1xuICB0aGlzLmFwcGxpY2F0aW9uTWVtb0tleVN0YWNrID0gW107IC8vIGFjdGl2ZSBhcHBsaWNhdGlvbnMgYXQgdGhpcyBwb3NpdGlvblxuICB0aGlzLm1lbW8gPSB7fTtcbiAgdGhpcy5tYXhFeGFtaW5lZExlbmd0aCA9IDA7XG4gIHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9IC0xO1xuICB0aGlzLmN1cnJlbnRMZWZ0UmVjdXJzaW9uID0gdW5kZWZpbmVkO1xufVxuXG5Qb3NJbmZvLnByb3RvdHlwZSA9IHtcbiAgaXNBY3RpdmUoYXBwbGljYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5pbmRleE9mKGFwcGxpY2F0aW9uLnRvTWVtb0tleSgpKSA+PSAwO1xuICB9LFxuXG4gIGVudGVyKGFwcGxpY2F0aW9uKSB7XG4gICAgdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5wdXNoKGFwcGxpY2F0aW9uLnRvTWVtb0tleSgpKTtcbiAgfSxcblxuICBleGl0KCkge1xuICAgIHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2sucG9wKCk7XG4gIH0sXG5cbiAgc3RhcnRMZWZ0UmVjdXJzaW9uKGhlYWRBcHBsaWNhdGlvbiwgbWVtb1JlYykge1xuICAgIG1lbW9SZWMuaXNMZWZ0UmVjdXJzaW9uID0gdHJ1ZTtcbiAgICBtZW1vUmVjLmhlYWRBcHBsaWNhdGlvbiA9IGhlYWRBcHBsaWNhdGlvbjtcbiAgICBtZW1vUmVjLm5leHRMZWZ0UmVjdXJzaW9uID0gdGhpcy5jdXJyZW50TGVmdFJlY3Vyc2lvbjtcbiAgICB0aGlzLmN1cnJlbnRMZWZ0UmVjdXJzaW9uID0gbWVtb1JlYztcblxuICAgIGNvbnN0IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrID0gdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjaztcbiAgICBjb25zdCBpbmRleE9mRmlyc3RJbnZvbHZlZFJ1bGUgPVxuICAgICAgICBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5pbmRleE9mKGhlYWRBcHBsaWNhdGlvbi50b01lbW9LZXkoKSkgKyAxO1xuICAgIGNvbnN0IGludm9sdmVkQXBwbGljYXRpb25NZW1vS2V5cyA9IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLnNsaWNlKGluZGV4T2ZGaXJzdEludm9sdmVkUnVsZSk7XG5cbiAgICBtZW1vUmVjLmlzSW52b2x2ZWQgPSBmdW5jdGlvbihhcHBsaWNhdGlvbk1lbW9LZXkpIHtcbiAgICAgIHJldHVybiBpbnZvbHZlZEFwcGxpY2F0aW9uTWVtb0tleXMuaW5kZXhPZihhcHBsaWNhdGlvbk1lbW9LZXkpID49IDA7XG4gICAgfTtcblxuICAgIG1lbW9SZWMudXBkYXRlSW52b2x2ZWRBcHBsaWNhdGlvbk1lbW9LZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKGxldCBpZHggPSBpbmRleE9mRmlyc3RJbnZvbHZlZFJ1bGU7IGlkeCA8IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb25NZW1vS2V5ID0gYXBwbGljYXRpb25NZW1vS2V5U3RhY2tbaWR4XTtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW52b2x2ZWQoYXBwbGljYXRpb25NZW1vS2V5KSkge1xuICAgICAgICAgIGludm9sdmVkQXBwbGljYXRpb25NZW1vS2V5cy5wdXNoKGFwcGxpY2F0aW9uTWVtb0tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGVuZExlZnRSZWN1cnNpb24oKSB7XG4gICAgdGhpcy5jdXJyZW50TGVmdFJlY3Vyc2lvbiA9IHRoaXMuY3VycmVudExlZnRSZWN1cnNpb24ubmV4dExlZnRSZWN1cnNpb247XG4gIH0sXG5cbiAgLy8gTm90ZTogdGhpcyBtZXRob2QgZG9lc24ndCBnZXQgY2FsbGVkIGZvciB0aGUgXCJoZWFkXCIgb2YgYSBsZWZ0IHJlY3Vyc2lvbiAtLSBmb3IgTFIgaGVhZHMsXG4gIC8vIHRoZSBtZW1vaXplZCByZXN1bHQgKHdoaWNoIHN0YXJ0cyBvdXQgYmVpbmcgYSBmYWlsdXJlKSBpcyBhbHdheXMgdXNlZC5cbiAgc2hvdWxkVXNlTWVtb2l6ZWRSZXN1bHQobWVtb1JlYykge1xuICAgIGlmICghbWVtb1JlYy5pc0xlZnRSZWN1cnNpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjayA9IHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2s7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYXBwbGljYXRpb25NZW1vS2V5U3RhY2subGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29uc3QgYXBwbGljYXRpb25NZW1vS2V5ID0gYXBwbGljYXRpb25NZW1vS2V5U3RhY2tbaWR4XTtcbiAgICAgIGlmIChtZW1vUmVjLmlzSW52b2x2ZWQoYXBwbGljYXRpb25NZW1vS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIG1lbW9pemUobWVtb0tleSwgbWVtb1JlYykge1xuICAgIHRoaXMubWVtb1ttZW1vS2V5XSA9IG1lbW9SZWM7XG4gICAgdGhpcy5tYXhFeGFtaW5lZExlbmd0aCA9IE1hdGgubWF4KHRoaXMubWF4RXhhbWluZWRMZW5ndGgsIG1lbW9SZWMuZXhhbWluZWRMZW5ndGgpO1xuICAgIHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9XG4gICAgICAgIE1hdGgubWF4KHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCwgbWVtb1JlYy5yaWdodG1vc3RGYWlsdXJlT2Zmc2V0KTtcbiAgICByZXR1cm4gbWVtb1JlYztcbiAgfSxcblxuICBjbGVhck9ic29sZXRlRW50cmllcyhwb3MsIGludmFsaWRhdGVkSWR4KSB7XG4gICAgaWYgKHBvcyArIHRoaXMubWF4RXhhbWluZWRMZW5ndGggPD0gaW52YWxpZGF0ZWRJZHgpIHtcbiAgICAgIC8vIE9wdGltaXphdGlvbjogbm9uZSBvZiB0aGUgcnVsZSBhcHBsaWNhdGlvbnMgdGhhdCB3ZXJlIG1lbW9pemVkIGhlcmUgZXhhbWluZWQgdGhlXG4gICAgICAvLyBpbnRlcnZhbCBvZiB0aGUgaW5wdXQgdGhhdCBjaGFuZ2VkLCBzbyBub3RoaW5nIGhhcyB0byBiZSBpbnZhbGlkYXRlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZW1vID0gdGhpcy5tZW1vO1xuICAgIHRoaXMubWF4RXhhbWluZWRMZW5ndGggPSAwO1xuICAgIHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9IC0xO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKG1lbW8pLmZvckVhY2goayA9PiB7XG4gICAgICBjb25zdCBtZW1vUmVjID0gbWVtb1trXTtcbiAgICAgIGlmIChwb3MgKyBtZW1vUmVjLmV4YW1pbmVkTGVuZ3RoID4gaW52YWxpZGF0ZWRJZHgpIHtcbiAgICAgICAgZGVsZXRlIG1lbW9ba107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLm1heEV4YW1pbmVkTGVuZ3RoID0gTWF0aC5tYXgoc2VsZi5tYXhFeGFtaW5lZExlbmd0aCwgbWVtb1JlYy5leGFtaW5lZExlbmd0aCk7XG4gICAgICAgIHNlbGYubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9XG4gICAgICAgICAgICBNYXRoLm1heChzZWxmLm1heFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQsIG1lbW9SZWMucmlnaHRtb3N0RmFpbHVyZU9mZnNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc0luZm87XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBJbnB1dFN0cmVhbSA9IHJlcXVpcmUoJy4vSW5wdXRTdHJlYW0nKTtcbmNvbnN0IEl0ZXJhdGlvbk5vZGUgPSByZXF1aXJlKCcuL25vZGVzJykuSXRlcmF0aW9uTm9kZTtcbmNvbnN0IE1hdGNoUmVzdWx0ID0gcmVxdWlyZSgnLi9NYXRjaFJlc3VsdCcpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBnbG9iYWxBY3Rpb25TdGFjayA9IFtdO1xubGV0IHByb3RvdHlwZUdyYW1tYXI7XG5sZXQgcHJvdG90eXBlR3JhbW1hclNlbWFudGljcztcblxuLy8gSlNPTiBpcyBub3QgYSB2YWxpZCBzdWJzZXQgb2YgSmF2YVNjcmlwdCBiZWNhdXNlIHRoZXJlIGFyZSB0d28gcG9zc2libGUgbGluZSB0ZXJtaW5hdG9ycyxcbi8vIFUrMjAyOCAobGluZSBzZXBhcmF0b3IpIGFuZCBVKzIwMjkgKHBhcmFncmFwaCBzZXBhcmF0b3IpIHRoYXQgYXJlIGFsbG93ZWQgaW4gSlNPTiBzdHJpbmdzXG4vLyBidXQgbm90IGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGpzb25Ub0pTKCkgcHJvcGVybHkgZW5jb2RlcyB0aG9zZSB0d28gY2hhcmFjdGVycyBpbiBKU09OIHNvIHRoYXQgaXQgY2FuIHNlYW1sZXNzbHkgYmVcbi8vIGluc2VydGVkIGludG8gSmF2YVNjcmlwdCBjb2RlIChwbHVzIHRoZSBlbmNvZGVkIHZlcnNpb24gaXMgc3RpbGwgdmFsaWQgSlNPTilcbmZ1bmN0aW9uIGpzb25Ub0pTKHN0cikge1xuICBjb25zdCBvdXRwdXQgPSBzdHIucmVwbGFjZSgvW1xcdTIwMjhcXHUyMDI5XS9nLCAoY2hhciwgcG9zLCBzdHIpID0+IHtcbiAgICBjb25zdCBoZXggPSBjaGFyLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gJ1xcXFx1JyArICcwMDAwJy5zbGljZShoZXgubGVuZ3RoKSArIGhleDtcbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIFdyYXBwZXJzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFdyYXBwZXJzIGRlY29yYXRlIENTVCBub2RlcyB3aXRoIGFsbCBvZiB0aGUgZnVuY3Rpb25hbGl0eSAoaS5lLiwgb3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcylcbi8vIHByb3ZpZGVkIGJ5IGEgU2VtYW50aWNzIChzZWUgYmVsb3cpLiBgV3JhcHBlcmAgaXMgdGhlIGFic3RyYWN0IHN1cGVyY2xhc3Mgb2YgYWxsIHdyYXBwZXJzLiBBXG4vLyBgV3JhcHBlcmAgbXVzdCBoYXZlIGBfbm9kZWAgYW5kIGBfc2VtYW50aWNzYCBpbnN0YW5jZSB2YXJpYWJsZXMsIHdoaWNoIHJlZmVyIHRvIHRoZSBDU1Qgbm9kZSBhbmRcbi8vIFNlbWFudGljcyAocmVzcC4pIGZvciB3aGljaCBpdCB3YXMgY3JlYXRlZCwgYW5kIGEgYF9jaGlsZFdyYXBwZXJzYCBpbnN0YW5jZSB2YXJpYWJsZSB3aGljaCBpc1xuLy8gdXNlZCB0byBjYWNoZSB0aGUgd3JhcHBlciBpbnN0YW5jZXMgdGhhdCBhcmUgY3JlYXRlZCBmb3IgaXRzIGNoaWxkIG5vZGVzLiBTZXR0aW5nIHRoZXNlIGluc3RhbmNlXG4vLyB2YXJpYWJsZXMgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjb25zdHJ1Y3RvciBvZiBlYWNoIFNlbWFudGljcy1zcGVjaWZpYyBzdWJjbGFzcyBvZlxuLy8gYFdyYXBwZXJgLlxuY2xhc3MgV3JhcHBlciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIHNvdXJjZUludGVydmFsLCBiYXNlSW50ZXJ2YWwpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZUludGVydmFsO1xuXG4gICAgLy8gVGhlIGludGVydmFsIHRoYXQgdGhlIGNoaWxkT2Zmc2V0cyBvZiBgbm9kZWAgYXJlIHJlbGF0aXZlIHRvLiBJdCBzaG91bGQgYmUgdGhlIHNvdXJjZVxuICAgIC8vIG9mIHRoZSBjbG9zZXN0IE5vbnRlcm1pbmFsIG5vZGUuXG4gICAgdGhpcy5fYmFzZUludGVydmFsID0gYmFzZUludGVydmFsO1xuXG4gICAgaWYgKG5vZGUuaXNOb250ZXJtaW5hbCgpKSB7XG4gICAgICBjb21tb24uYXNzZXJ0KHNvdXJjZUludGVydmFsID09PSBiYXNlSW50ZXJ2YWwpO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZFdyYXBwZXJzID0gW107XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tzZW1hbnRpY3Mgd3JhcHBlciBmb3IgJyArIHRoaXMuX25vZGUuZ3JhbW1hci5uYW1lICsgJ10nO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgdXNlZCBieSBvaG0gZWRpdG9yIHRvIGRpc3BsYXkgYSBub2RlIHdyYXBwZXIgYXBwcm9wcmlhdGVseS5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICBfZm9yZ2V0TWVtb2l6ZWRSZXN1bHRGb3IoYXR0cmlidXRlTmFtZSkge1xuICAgIC8vIFJlbW92ZSB0aGUgbWVtb2l6ZWQgYXR0cmlidXRlIGZyb20gdGhlIGNzdE5vZGUgYW5kIGFsbCBpdHMgY2hpbGRyZW4uXG4gICAgZGVsZXRlIHRoaXMuX25vZGVbdGhpcy5fc2VtYW50aWNzLmF0dHJpYnV0ZUtleXNbYXR0cmlidXRlTmFtZV1dO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC5fZm9yZ2V0TWVtb2l6ZWRSZXN1bHRGb3IoYXR0cmlidXRlTmFtZSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB3cmFwcGVyIG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQgbm9kZS4gQ2hpbGQgd3JhcHBlcnMgYXJlIGNyZWF0ZWQgbGF6aWx5IGFuZFxuICAvLyBjYWNoZWQgaW4gdGhlIHBhcmVudCB3cmFwcGVyJ3MgYF9jaGlsZFdyYXBwZXJzYCBpbnN0YW5jZSB2YXJpYWJsZS5cbiAgY2hpbGQoaWR4KSB7XG4gICAgaWYgKCEoMCA8PSBpZHggJiYgaWR4IDwgdGhpcy5fbm9kZS5udW1DaGlsZHJlbigpKSkge1xuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIGhlcmUuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgY2hpbGRXcmFwcGVyID0gdGhpcy5fY2hpbGRXcmFwcGVyc1tpZHhdO1xuICAgIGlmICghY2hpbGRXcmFwcGVyKSB7XG4gICAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLl9ub2RlLmNoaWxkQXQoaWR4KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25vZGUuY2hpbGRPZmZzZXRzW2lkeF07XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX2Jhc2VJbnRlcnZhbC5zdWJJbnRlcnZhbChvZmZzZXQsIGNoaWxkTm9kZS5tYXRjaExlbmd0aCk7XG4gICAgICBjb25zdCBiYXNlID0gY2hpbGROb2RlLmlzTm9udGVybWluYWwoKSA/IHNvdXJjZSA6IHRoaXMuX2Jhc2VJbnRlcnZhbDtcbiAgICAgIGNoaWxkV3JhcHBlciA9IHRoaXMuX2NoaWxkV3JhcHBlcnNbaWR4XSA9IHRoaXMuX3NlbWFudGljcy53cmFwKGNoaWxkTm9kZSwgc291cmNlLCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkV3JhcHBlcjtcbiAgfVxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgd3JhcHBlcnMgb2YgYWxsIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZSBhc3NvY2lhdGVkXG4gIC8vIHdpdGggdGhpcyB3cmFwcGVyLlxuICBfY2hpbGRyZW4oKSB7XG4gICAgLy8gRm9yY2UgdGhlIGNyZWF0aW9uIG9mIGFsbCBjaGlsZCB3cmFwcGVyc1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX25vZGUubnVtQ2hpbGRyZW4oKTsgaWR4KyspIHtcbiAgICAgIHRoaXMuY2hpbGQoaWR4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkV3JhcHBlcnM7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBjb3JyZXNwb25kcyB0byBhbiBpdGVyYXRpb25cbiAgLy8gZXhwcmVzc2lvbiwgaS5lLiwgYSBLbGVlbmUtKiwgS2xlZW5lLSssIG9yIGFuIG9wdGlvbmFsLiBSZXR1cm5zIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICBpc0l0ZXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5pc0l0ZXJhdGlvbigpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgaXMgYSB0ZXJtaW5hbCBub2RlLCBgZmFsc2VgXG4gIC8vIG90aGVyd2lzZS5cbiAgaXNUZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5pc1Rlcm1pbmFsKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBpcyBhIG5vbnRlcm1pbmFsIG5vZGUsIGBmYWxzZWBcbiAgLy8gb3RoZXJ3aXNlLlxuICBpc05vbnRlcm1pbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLmlzTm9udGVybWluYWwoKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3cmFwcGVyIGlzIGEgbm9udGVybWluYWwgbm9kZVxuICAvLyBjb3JyZXNwb25kaW5nIHRvIGEgc3ludGFjdGljIHJ1bGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICBpc1N5bnRhY3RpYygpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vbnRlcm1pbmFsKCkgJiYgdGhpcy5fbm9kZS5pc1N5bnRhY3RpYygpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgaXMgYSBub250ZXJtaW5hbCBub2RlXG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gYSBsZXhpY2FsIHJ1bGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICBpc0xleGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb250ZXJtaW5hbCgpICYmIHRoaXMuX25vZGUuaXNMZXhpY2FsKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBpcyBhbiBpdGVyYXRvciBub2RlXG4gIC8vIGhhdmluZyBlaXRoZXIgb25lIG9yIG5vIGNoaWxkICg/IG9wZXJhdG9yKSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vIE90aGVyd2lzZSwgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5pc09wdGlvbmFsKCk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgX2l0ZXIgd3JhcHBlciBpbiB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgdGhpcyB3cmFwcGVyLlxuICBpdGVyYXRpb24ob3B0Q2hpbGRXcmFwcGVycykge1xuICAgIGNvbnN0IGNoaWxkV3JhcHBlcnMgPSBvcHRDaGlsZFdyYXBwZXJzIHx8IFtdO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IGNoaWxkV3JhcHBlcnMubWFwKGMgPT4gYy5fbm9kZSk7XG4gICAgY29uc3QgaXRlciA9IG5ldyBJdGVyYXRpb25Ob2RlKHRoaXMuX25vZGUuZ3JhbW1hciwgY2hpbGROb2RlcywgW10sIC0xLCBmYWxzZSk7XG5cbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5fc2VtYW50aWNzLndyYXAoaXRlciwgbnVsbCwgbnVsbCk7XG4gICAgd3JhcHBlci5fY2hpbGRXcmFwcGVycyA9IGNoaWxkV3JhcHBlcnM7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvLyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIG9mIHRoaXMgQ1NUIG5vZGUuXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4oKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG5hbWUgb2YgZ3JhbW1hciBydWxlIHRoYXQgY3JlYXRlZCB0aGlzIENTVCBub2RlLlxuICBnZXQgY3Rvck5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuY3Rvck5hbWU7XG4gIH1cblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBldmVudHVhbGx5IChkZXByZWNhdGVkIGluIHYwLjEyKS5cbiAgZ2V0IGludGVydmFsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBpbnRlcnZhbGAgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCAtLSB1c2UgYHNvdXJjZWAgaW5zdGVhZCcpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIG9mIHRoaXMgQ1NUIG5vZGUuXG4gIGdldCBudW1DaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5udW1DaGlsZHJlbigpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcHJpbWl0aXZlIHZhbHVlIG9mIHRoaXMgQ1NUIG5vZGUsIGlmIGl0J3MgYSB0ZXJtaW5hbCBub2RlLiBPdGhlcndpc2UsXG4gIC8vIHRocm93cyBhbiBleGNlcHRpb24uXG4gIGdldCBwcmltaXRpdmVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5pc1Rlcm1pbmFsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ub2RlLnByaW1pdGl2ZVZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcInRyaWVkIHRvIGFjY2VzcyB0aGUgJ3ByaW1pdGl2ZVZhbHVlJyBhdHRyaWJ1dGUgb2YgYSBub24tdGVybWluYWwgQ1NUIG5vZGVcIik7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgaW5wdXQgc3RyZWFtIGNvbnN1bWVkIGJ5IHRoaXMgQ1NUIG5vZGUuXG4gIGdldCBzb3VyY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbnRlbnRzO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIFNlbWFudGljcyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBIFNlbWFudGljcyBpcyBhIGNvbnRhaW5lciBmb3IgYSBmYW1pbHkgb2YgT3BlcmF0aW9ucyBhbmQgQXR0cmlidXRlcyBmb3IgYSBnaXZlbiBncmFtbWFyLlxuLy8gU2VtYW50aWNzIGVuYWJsZSBtb2R1bGFyaXR5IChkaWZmZXJlbnQgY2xpZW50cyBvZiBhIGdyYW1tYXIgY2FuIGNyZWF0ZSB0aGVpciBzZXQgb2Ygb3BlcmF0aW9uc1xuLy8gYW5kIGF0dHJpYnV0ZXMgaW4gaXNvbGF0aW9uKSBhbmQgZXh0ZW5zaWJpbGl0eSBldmVuIHdoZW4gb3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcyBhcmUgbXV0dWFsbHktXG4vLyByZWN1cnNpdmUuIFRoaXMgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgZXhjZXB0IGZyb21cbi8vIGBTZW1hbnRpY3MuY3JlYXRlU2VtYW50aWNzYC4gVGhlIG5vcm1hbCB3YXlzIHRvIGNyZWF0ZSBhIFNlbWFudGljcywgZ2l2ZW4gYSBncmFtbWFyICdnJywgYXJlXG4vLyBgZy5jcmVhdGVTZW1hbnRpY3MoKWAgYW5kIGBnLmV4dGVuZFNlbWFudGljcyhwYXJlbnRTZW1hbnRpY3MpYC5cbmZ1bmN0aW9uIFNlbWFudGljcyhncmFtbWFyLCBzdXBlclNlbWFudGljcykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgdGhpcy5jaGVja2VkQWN0aW9uRGljdHMgPSBmYWxzZTtcblxuICAvLyBDb25zdHJ1Y3RvciBmb3Igd3JhcHBlciBpbnN0YW5jZXMsIHdoaWNoIGFyZSBwYXNzZWQgYXMgdGhlIGFyZ3VtZW50cyB0byB0aGUgc2VtYW50aWMgYWN0aW9uc1xuICAvLyBvZiBhbiBvcGVyYXRpb24gb3IgYXR0cmlidXRlLiBPcGVyYXRpb25zIGFuZCBhdHRyaWJ1dGVzIHJlcXVpcmUgZG91YmxlIGRpc3BhdGNoOiB0aGUgc2VtYW50aWNcbiAgLy8gYWN0aW9uIGlzIGNob3NlbiBiYXNlZCBvbiBib3RoIHRoZSBub2RlJ3MgdHlwZSBhbmQgdGhlIHNlbWFudGljcy4gV3JhcHBlcnMgZW5zdXJlIHRoYXRcbiAgLy8gdGhlIGBleGVjdXRlYCBtZXRob2QgaXMgY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgKG1vc3Qgc3BlY2lmaWMpIHNlbWFudGljcyBvYmplY3QgYXMgYW5cbiAgLy8gYXJndW1lbnQuXG4gIHRoaXMuV3JhcHBlciA9IGNsYXNzIGV4dGVuZHMgKHN1cGVyU2VtYW50aWNzID8gc3VwZXJTZW1hbnRpY3MuV3JhcHBlciA6IFdyYXBwZXIpIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzb3VyY2VJbnRlcnZhbCwgYmFzZUludGVydmFsKSB7XG4gICAgICBzdXBlcihub2RlLCBzb3VyY2VJbnRlcnZhbCwgYmFzZUludGVydmFsKTtcbiAgICAgIHNlbGYuY2hlY2tBY3Rpb25EaWN0c0lmSGF2ZW50QWxyZWFkeSgpO1xuICAgICAgdGhpcy5fc2VtYW50aWNzID0gc2VsZjtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5zdXBlciA9IHN1cGVyU2VtYW50aWNzO1xuICBpZiAoc3VwZXJTZW1hbnRpY3MpIHtcbiAgICBpZiAoIShncmFtbWFyLmVxdWFscyh0aGlzLnN1cGVyLmdyYW1tYXIpIHx8IGdyYW1tYXIuX2luaGVyaXRzRnJvbSh0aGlzLnN1cGVyLmdyYW1tYXIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IGV4dGVuZCBhIHNlbWFudGljcyBmb3IgZ3JhbW1hciAnXCIgKyB0aGlzLnN1cGVyLmdyYW1tYXIubmFtZSArXG4gICAgICAgICAgXCInIGZvciB1c2Ugd2l0aCBncmFtbWFyICdcIiArIGdyYW1tYXIubmFtZSArIFwiJyAobm90IGEgc3ViLWdyYW1tYXIpXCIpO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBPYmplY3QuY3JlYXRlKHRoaXMuc3VwZXIub3BlcmF0aW9ucyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnN1cGVyLmF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuYXR0cmlidXRlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBBc3NpZ24gdW5pcXVlIHN5bWJvbHMgZm9yIGVhY2ggb2YgdGhlIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGZyb20gdGhlIHN1cGVyLXNlbWFudGljcyBzbyB0aGF0XG4gICAgLy8gdGhleSBhcmUgbWVtb2l6ZWQgaW5kZXBlbmRlbnRseS5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5hdHRyaWJ1dGVLZXlzLCBhdHRyaWJ1dGVOYW1lLCB7XG4gICAgICAgIHZhbHVlOiB1dGlsLnVuaXF1ZUlkKGF0dHJpYnV0ZU5hbWUpXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYXR0cmlidXRlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbn1cblxuU2VtYW50aWNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ1tzZW1hbnRpY3MgZm9yICcgKyB0aGlzLmdyYW1tYXIubmFtZSArICddJztcbn07XG5cblNlbWFudGljcy5wcm90b3R5cGUuY2hlY2tBY3Rpb25EaWN0c0lmSGF2ZW50QWxyZWFkeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY2hlY2tlZEFjdGlvbkRpY3RzKSB7XG4gICAgdGhpcy5jaGVja0FjdGlvbkRpY3RzKCk7XG4gICAgdGhpcy5jaGVja2VkQWN0aW9uRGljdHMgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBDaGVja3MgdGhhdCB0aGUgYWN0aW9uIGRpY3Rpb25hcmllcyBmb3IgYWxsIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgaW4gdGhpcyBzZW1hbnRpY3MsXG4vLyBpbmNsdWRpbmcgdGhlIG9uZXMgdGhhdCB3ZXJlIGluaGVyaXRlZCBmcm9tIHRoZSBzdXBlci1zZW1hbnRpY3MsIGFncmVlIHdpdGggdGhlIGdyYW1tYXIuXG4vLyBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIG9uZSBvciBtb3JlIG9mIHRoZW0gZG9lc24ndC5cblNlbWFudGljcy5wcm90b3R5cGUuY2hlY2tBY3Rpb25EaWN0cyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgbmFtZTtcbiAgZm9yIChuYW1lIGluIHRoaXMub3BlcmF0aW9ucykge1xuICAgIHRoaXMub3BlcmF0aW9uc1tuYW1lXS5jaGVja0FjdGlvbkRpY3QodGhpcy5ncmFtbWFyKTtcbiAgfVxuICBmb3IgKG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdLmNoZWNrQWN0aW9uRGljdCh0aGlzLmdyYW1tYXIpO1xuICB9XG59O1xuXG5TZW1hbnRpY3MucHJvdG90eXBlLnRvUmVjaXBlID0gZnVuY3Rpb24oc2VtYW50aWNzT25seSkge1xuICBmdW5jdGlvbiBoYXNTdXBlclNlbWFudGljcyhzKSB7XG4gICAgcmV0dXJuIHMuc3VwZXIgIT09IFNlbWFudGljcy5CdWlsdEluU2VtYW50aWNzLl9nZXRTZW1hbnRpY3MoKTtcbiAgfVxuXG4gIGxldCBzdHIgPSAnKGZ1bmN0aW9uKGcpIHtcXG4nO1xuICBpZiAoaGFzU3VwZXJTZW1hbnRpY3ModGhpcykpIHtcbiAgICBzdHIgKz0gJyAgdmFyIHNlbWFudGljcyA9ICcgKyB0aGlzLnN1cGVyLnRvUmVjaXBlKHRydWUpICsgJyhnJztcblxuICAgIGNvbnN0IHN1cGVyU2VtYW50aWNzR3JhbW1hciA9IHRoaXMuc3VwZXIuZ3JhbW1hcjtcbiAgICBsZXQgcmVsYXRlZEdyYW1tYXIgPSB0aGlzLmdyYW1tYXI7XG4gICAgd2hpbGUgKHJlbGF0ZWRHcmFtbWFyICE9PSBzdXBlclNlbWFudGljc0dyYW1tYXIpIHtcbiAgICAgIHN0ciArPSAnLnN1cGVyR3JhbW1hcic7XG4gICAgICByZWxhdGVkR3JhbW1hciA9IHJlbGF0ZWRHcmFtbWFyLnN1cGVyR3JhbW1hcjtcbiAgICB9XG5cbiAgICBzdHIgKz0gJyk7XFxuJztcbiAgICBzdHIgKz0gJyAgcmV0dXJuIGcuZXh0ZW5kU2VtYW50aWNzKHNlbWFudGljcyknO1xuICB9IGVsc2Uge1xuICAgIHN0ciArPSAnICByZXR1cm4gZy5jcmVhdGVTZW1hbnRpY3MoKSc7XG4gIH1cbiAgWydPcGVyYXRpb24nLCAnQXR0cmlidXRlJ10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjb25zdCBzZW1hbnRpY09wZXJhdGlvbnMgPSB0aGlzW3R5cGUudG9Mb3dlckNhc2UoKSArICdzJ107XG4gICAgT2JqZWN0LmtleXMoc2VtYW50aWNPcGVyYXRpb25zKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29uc3Qge2FjdGlvbkRpY3QsIGZvcm1hbHMsIGJ1aWx0SW5EZWZhdWx0fSA9IHNlbWFudGljT3BlcmF0aW9uc1tuYW1lXTtcblxuICAgICAgbGV0IHNpZ25hdHVyZSA9IG5hbWU7XG4gICAgICBpZiAoZm9ybWFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNpZ25hdHVyZSArPSAnKCcgKyBmb3JtYWxzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIGxldCBtZXRob2Q7XG4gICAgICBpZiAoaGFzU3VwZXJTZW1hbnRpY3ModGhpcykgJiYgdGhpcy5zdXBlclt0eXBlLnRvTG93ZXJDYXNlKCkgKyAncyddW25hbWVdKSB7XG4gICAgICAgIG1ldGhvZCA9ICdleHRlbmQnICsgdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9ICdhZGQnICsgdHlwZTtcbiAgICAgIH1cbiAgICAgIHN0ciArPSAnXFxuICAgIC4nICsgbWV0aG9kICsgJygnICsgSlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlKSArICcsIHsnO1xuXG4gICAgICBjb25zdCBzcmNBcnJheSA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMoYWN0aW9uRGljdCkuZm9yRWFjaChhY3Rpb25OYW1lID0+IHtcbiAgICAgICAgaWYgKGFjdGlvbkRpY3RbYWN0aW9uTmFtZV0gIT09IGJ1aWx0SW5EZWZhdWx0KSB7XG4gICAgICAgICAgbGV0IHNvdXJjZSA9IGFjdGlvbkRpY3RbYWN0aW9uTmFtZV0udG9TdHJpbmcoKS50cmltKCk7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG1ldGhvZCBzaG9ydGhhbmQgdG8gcGxhaW4gb2xkIGZ1bmN0aW9uIHN5bnRheC5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGFyYy9vaG0vaXNzdWVzLzI2M1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC9eLipcXCgvLCAnZnVuY3Rpb24oJyk7XG5cbiAgICAgICAgICBzcmNBcnJheS5wdXNoKCdcXG4gICAgICAnICsgSlNPTi5zdHJpbmdpZnkoYWN0aW9uTmFtZSkgKyAnOiAnICsgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzdHIgKz0gc3JjQXJyYXkuam9pbignLCcpICsgJ1xcbiAgICB9KSc7XG4gICAgfSk7XG4gIH0pO1xuICBzdHIgKz0gJztcXG4gIH0pJztcblxuICBpZiAoIXNlbWFudGljc09ubHkpIHtcbiAgICBzdHIgPVxuICAgICAgJyhmdW5jdGlvbigpIHtcXG4nICtcbiAgICAgICcgIHZhciBncmFtbWFyID0gdGhpcy5mcm9tUmVjaXBlKCcgKyBqc29uVG9KUyh0aGlzLmdyYW1tYXIudG9SZWNpcGUoKSkgKyAnKTtcXG4nICtcbiAgICAgICcgIHZhciBzZW1hbnRpY3MgPSAnICsgc3RyICsgJyhncmFtbWFyKTtcXG4nICtcbiAgICAgICcgIHJldHVybiBzZW1hbnRpY3M7XFxuJyArXG4gICAgICAnfSk7XFxuJztcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHR5cGUpIHtcbiAgaWYgKCFwcm90b3R5cGVHcmFtbWFyKSB7XG4gICAgLy8gVGhlIE9wZXJhdGlvbnMgYW5kIEF0dHJpYnV0ZXMgZ3JhbW1hciB3b24ndCBiZSBhdmFpbGFibGUgd2hpbGUgT2htIGlzIGxvYWRpbmcsXG4gICAgLy8gYnV0IHdlIGNhbiBnZXQgYXdheSB0aGUgZm9sbG93aW5nIHNpbXBsaWZpY2F0aW9uIGIvYyBub25lIG9mIHRoZSBvcGVyYXRpb25zXG4gICAgLy8gdGhhdCBhcmUgdXNlZCB3aGlsZSBsb2FkaW5nIHRha2UgYXJndW1lbnRzLlxuICAgIGNvbW1vbi5hc3NlcnQoc2lnbmF0dXJlLmluZGV4T2YoJygnKSA9PT0gLTEpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBzaWduYXR1cmUsXG4gICAgICBmb3JtYWxzOiBbXVxuICAgIH07XG4gIH1cblxuICBjb25zdCByID0gcHJvdG90eXBlR3JhbW1hci5tYXRjaChcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHR5cGUgPT09ICdvcGVyYXRpb24nID8gJ09wZXJhdGlvblNpZ25hdHVyZScgOiAnQXR0cmlidXRlU2lnbmF0dXJlJyk7XG4gIGlmIChyLmZhaWxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHIubWVzc2FnZSk7XG4gIH1cblxuICByZXR1cm4gcHJvdG90eXBlR3JhbW1hclNlbWFudGljcyhyKS5wYXJzZSgpO1xufVxuXG5mdW5jdGlvbiBuZXdEZWZhdWx0QWN0aW9uKHR5cGUsIG5hbWUsIGRvSXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgdGhpc1RoaW5nID0gdGhpcy5fc2VtYW50aWNzLm9wZXJhdGlvbnNbbmFtZV0gfHwgdGhpcy5fc2VtYW50aWNzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgY29uc3QgYXJncyA9IHRoaXNUaGluZy5mb3JtYWxzLm1hcChmb3JtYWwgPT4gc2VsZi5hcmdzW2Zvcm1hbF0pO1xuXG4gICAgaWYgKHRoaXMuaXNJdGVyYXRpb24oKSkge1xuICAgICAgLy8gVGhpcyBDU1Qgbm9kZSBjb3JyZXNwb25kcyB0byBhbiBpdGVyYXRpb24gZXhwcmVzc2lvbiBpbiB0aGUgZ3JhbW1hciAoKiwgKywgb3IgPykuIFRoZVxuICAgICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyB0byBtYXAgdGhpcyBvcGVyYXRpb24gb3IgYXR0cmlidXRlIG92ZXIgYWxsIG9mIGl0cyBjaGlsZCBub2Rlcy5cbiAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoY2hpbGQgPT4gZG9JdC5hcHBseShjaGlsZCwgYXJncykpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgQ1NUIG5vZGUgY29ycmVzcG9uZHMgdG8gYSBub24tdGVybWluYWwgaW4gdGhlIGdyYW1tYXIgKGUuZy4sIEFkZEV4cHIpLiBUaGUgZmFjdCB0aGF0XG4gICAgLy8gd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGlzIGFjdGlvbiBkaWN0aW9uYXJ5IGRvZXNuJ3QgaGF2ZSBhbiBhY3Rpb24gZm9yIHRoaXMgcGFydGljdWxhclxuICAgIC8vIG5vbi10ZXJtaW5hbCBvciBhIGdlbmVyaWMgYF9ub250ZXJtaW5hbGAgYWN0aW9uLlxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIEFzIGEgY29udmVuaWVuY2UsIGlmIHRoaXMgbm9kZSBvbmx5IGhhcyBvbmUgY2hpbGQsIHdlIGp1c3QgcmV0dXJuIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vIGFwcGx5aW5nIHRoaXMgb3BlcmF0aW9uIC8gYXR0cmlidXRlIHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgcmV0dXJuIGRvSXQuYXBwbHkoY2hpbGRyZW5bMF0sIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHdlIHRocm93IGFuIGV4Y2VwdGlvbiB0byBsZXQgdGhlIHByb2dyYW1tZXIga25vdyB0aGF0IHdlIGRvbid0IGtub3cgd2hhdFxuICAgICAgLy8gdG8gZG8gd2l0aCB0aGlzIG5vZGUuXG4gICAgICB0aHJvdyBlcnJvcnMubWlzc2luZ1NlbWFudGljQWN0aW9uKHRoaXMuY3Rvck5hbWUsIG5hbWUsIHR5cGUsIGdsb2JhbEFjdGlvblN0YWNrKTtcbiAgICB9XG4gIH07XG59XG5cblNlbWFudGljcy5wcm90b3R5cGUuYWRkT3BlcmF0aW9uT3JBdHRyaWJ1dGUgPSBmdW5jdGlvbih0eXBlLCBzaWduYXR1cmUsIGFjdGlvbkRpY3QpIHtcbiAgY29uc3QgdHlwZVBsdXJhbCA9IHR5cGUgKyAncyc7XG5cbiAgY29uc3QgcGFyc2VkTmFtZUFuZEZvcm1hbEFyZ3MgPSBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHR5cGUpO1xuICBjb25zdCBuYW1lID0gcGFyc2VkTmFtZUFuZEZvcm1hbEFyZ3MubmFtZTtcbiAgY29uc3QgZm9ybWFscyA9IHBhcnNlZE5hbWVBbmRGb3JtYWxBcmdzLmZvcm1hbHM7XG5cbiAgLy8gVE9ETzogY2hlY2sgdGhhdCB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIGZvcm1hbCBhcmd1bWVudHNcblxuICB0aGlzLmFzc2VydE5ld05hbWUobmFtZSwgdHlwZSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBhY3Rpb24gZGljdGlvbmFyeSBmb3IgdGhpcyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUgdGhhdCBjb250YWlucyBhIGBfZGVmYXVsdGAgYWN0aW9uXG4gIC8vIHdoaWNoIGRlZmluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgaXRlcmF0aW9uLCB0ZXJtaW5hbCwgYW5kIG5vbi10ZXJtaW5hbCBub2Rlcy4uLlxuICBjb25zdCBidWlsdEluRGVmYXVsdCA9IG5ld0RlZmF1bHRBY3Rpb24odHlwZSwgbmFtZSwgZG9JdCk7XG4gIGNvbnN0IHJlYWxBY3Rpb25EaWN0ID0ge19kZWZhdWx0OiBidWlsdEluRGVmYXVsdH07XG4gIC8vIC4uLiBhbmQgYWRkIGluIHRoZSBhY3Rpb25zIHN1cHBsaWVkIGJ5IHRoZSBwcm9ncmFtbWVyLCB3aGljaCBtYXkgb3ZlcnJpZGUgc29tZSBvciBhbGwgb2YgdGhlXG4gIC8vIGRlZmF1bHQgb25lcy5cbiAgT2JqZWN0LmtleXMoYWN0aW9uRGljdCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICByZWFsQWN0aW9uRGljdFtuYW1lXSA9IGFjdGlvbkRpY3RbbmFtZV07XG4gIH0pO1xuXG4gIGNvbnN0IGVudHJ5ID0gdHlwZSA9PT0gJ29wZXJhdGlvbicgP1xuICAgICAgbmV3IE9wZXJhdGlvbihuYW1lLCBmb3JtYWxzLCByZWFsQWN0aW9uRGljdCwgYnVpbHRJbkRlZmF1bHQpIDpcbiAgICAgIG5ldyBBdHRyaWJ1dGUobmFtZSwgcmVhbEFjdGlvbkRpY3QsIGJ1aWx0SW5EZWZhdWx0KTtcblxuICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgKGl0IHdpbGwgaGFwcGVuIGxhdGVyIGFueXdheSkgYnV0IGl0J3MgYmV0dGVyIHRvXG4gIC8vIGNhdGNoIGVycm9ycyBlYXJseS5cbiAgZW50cnkuY2hlY2tBY3Rpb25EaWN0KHRoaXMuZ3JhbW1hcik7XG5cbiAgdGhpc1t0eXBlUGx1cmFsXVtuYW1lXSA9IGVudHJ5O1xuXG4gIGZ1bmN0aW9uIGRvSXQoKSB7XG4gICAgLy8gRGlzcGF0Y2ggdG8gbW9zdCBzcGVjaWZpYyB2ZXJzaW9uIG9mIHRoaXMgb3BlcmF0aW9uIC8gYXR0cmlidXRlIC0tIGl0IG1heSBoYXZlIGJlZW5cbiAgICAvLyBvdmVycmlkZGVuIGJ5IGEgc3ViLXNlbWFudGljcy5cbiAgICBjb25zdCB0aGlzVGhpbmcgPSB0aGlzLl9zZW1hbnRpY3NbdHlwZVBsdXJhbF1bbmFtZV07XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBjYWxsZXIgcGFzc2VkIHRoZSBjb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IHRoaXNUaGluZy5mb3JtYWxzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkIHRvICcgKyBuYW1lICsgJyAnICsgdHlwZSArICcgKGV4cGVjdGVkICcgK1xuICAgICAgICAgIHRoaXNUaGluZy5mb3JtYWxzLmxlbmd0aCArICcsIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcpJyk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIFwiYXJndW1lbnRzIG9iamVjdFwiIGZyb20gdGhlIGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoaXNcbiAgICAvLyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUuXG4gICAgY29uc3QgYXJncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYXJndW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IGZvcm1hbCA9IHRoaXNUaGluZy5mb3JtYWxzW2lkeF07XG4gICAgICBhcmdzW2Zvcm1hbF0gPSBhcmd1bWVudHNbaWR4XTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRBcmdzID0gdGhpcy5hcmdzO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgY29uc3QgYW5zID0gdGhpc1RoaW5nLmV4ZWN1dGUodGhpcy5fc2VtYW50aWNzLCB0aGlzKTtcbiAgICB0aGlzLmFyZ3MgPSBvbGRBcmdzO1xuICAgIHJldHVybiBhbnM7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ29wZXJhdGlvbicpIHtcbiAgICB0aGlzLldyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZG9JdDtcbiAgICB0aGlzLldyYXBwZXIucHJvdG90eXBlW25hbWVdLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1snICsgbmFtZSArICcgb3BlcmF0aW9uXSc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5XcmFwcGVyLnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBkb0l0LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlIC8vIFNvIHRoZSBwcm9wZXJ0eSBjYW4gYmUgZGVsZXRlZC5cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5hdHRyaWJ1dGVLZXlzLCBuYW1lLCB7XG4gICAgICB2YWx1ZTogdXRpbC51bmlxdWVJZChuYW1lKVxuICAgIH0pO1xuICB9XG59O1xuXG5TZW1hbnRpY3MucHJvdG90eXBlLmV4dGVuZE9wZXJhdGlvbk9yQXR0cmlidXRlID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgYWN0aW9uRGljdCkge1xuICBjb25zdCB0eXBlUGx1cmFsID0gdHlwZSArICdzJztcblxuICAvLyBNYWtlIHN1cmUgdGhhdCBgbmFtZWAgcmVhbGx5IGlzIGp1c3QgYSBuYW1lLCBpLmUuLCB0aGF0IGl0IGRvZXNuJ3QgYWxzbyBjb250YWluIGZvcm1hbHMuXG4gIHBhcnNlU2lnbmF0dXJlKG5hbWUsICdhdHRyaWJ1dGUnKTtcblxuICBpZiAoISh0aGlzLnN1cGVyICYmIG5hbWUgaW4gdGhpcy5zdXBlclt0eXBlUGx1cmFsXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICtcbiAgICAgICAgXCInOiBkaWQgbm90IGluaGVyaXQgYW4gXCIgKyB0eXBlICsgJyB3aXRoIHRoYXQgbmFtZScpO1xuICB9XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpc1t0eXBlUGx1cmFsXSwgbmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICsgXCInIGFnYWluXCIpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IG9wZXJhdGlvbiAvIGF0dHJpYnV0ZSB3aG9zZSBhY3Rpb25EaWN0IGRlbGVnYXRlcyB0byB0aGUgc3VwZXIgb3BlcmF0aW9uIC9cbiAgLy8gYXR0cmlidXRlJ3MgYWN0aW9uRGljdCwgYW5kIHdoaWNoIGhhcyBhbGwgdGhlIGtleXMgZnJvbSBgaW5oZXJpdGVkQWN0aW9uRGljdGAuXG4gIGNvbnN0IGluaGVyaXRlZEZvcm1hbHMgPSB0aGlzW3R5cGVQbHVyYWxdW25hbWVdLmZvcm1hbHM7XG4gIGNvbnN0IGluaGVyaXRlZEFjdGlvbkRpY3QgPSB0aGlzW3R5cGVQbHVyYWxdW25hbWVdLmFjdGlvbkRpY3Q7XG4gIGNvbnN0IG5ld0FjdGlvbkRpY3QgPSBPYmplY3QuY3JlYXRlKGluaGVyaXRlZEFjdGlvbkRpY3QpO1xuICBPYmplY3Qua2V5cyhhY3Rpb25EaWN0KS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIG5ld0FjdGlvbkRpY3RbbmFtZV0gPSBhY3Rpb25EaWN0W25hbWVdO1xuICB9KTtcblxuICB0aGlzW3R5cGVQbHVyYWxdW25hbWVdID0gdHlwZSA9PT0gJ29wZXJhdGlvbicgP1xuICAgICAgbmV3IE9wZXJhdGlvbihuYW1lLCBpbmhlcml0ZWRGb3JtYWxzLCBuZXdBY3Rpb25EaWN0KSA6XG4gICAgICBuZXcgQXR0cmlidXRlKG5hbWUsIG5ld0FjdGlvbkRpY3QpO1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgaXMgbm90IHN0cmljdGx5IG5lY2Vzc2FyeSAoaXQgd2lsbCBoYXBwZW4gbGF0ZXIgYW55d2F5KSBidXQgaXQncyBiZXR0ZXIgdG9cbiAgLy8gY2F0Y2ggZXJyb3JzIGVhcmx5LlxuICB0aGlzW3R5cGVQbHVyYWxdW25hbWVdLmNoZWNrQWN0aW9uRGljdCh0aGlzLmdyYW1tYXIpO1xufTtcblxuU2VtYW50aWNzLnByb3RvdHlwZS5hc3NlcnROZXdOYW1lID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICBpZiAoV3JhcHBlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgYWRkICcgKyB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJzogdGhhdCdzIGEgcmVzZXJ2ZWQgbmFtZVwiKTtcbiAgfVxuICBpZiAobmFtZSBpbiB0aGlzLm9wZXJhdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgYWRkICcgKyB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJzogYW4gb3BlcmF0aW9uIHdpdGggdGhhdCBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICB9XG4gIGlmIChuYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBhZGQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICsgXCInOiBhbiBhdHRyaWJ1dGUgd2l0aCB0aGF0IG5hbWUgYWxyZWFkeSBleGlzdHNcIik7XG4gIH1cbn07XG5cbi8vIFJldHVybnMgYSB3cmFwcGVyIGZvciB0aGUgZ2l2ZW4gQ1NUIGBub2RlYCBpbiB0aGlzIHNlbWFudGljcy5cbi8vIElmIGBub2RlYCBpcyBhbHJlYWR5IGEgd3JhcHBlciwgcmV0dXJucyBgbm9kZWAgaXRzZWxmLiAgLy8gVE9ETzogd2h5IGlzIHRoaXMgbmVlZGVkP1xuU2VtYW50aWNzLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24obm9kZSwgc291cmNlLCBvcHRCYXNlSW50ZXJ2YWwpIHtcbiAgY29uc3QgYmFzZUludGVydmFsID0gb3B0QmFzZUludGVydmFsIHx8IHNvdXJjZTtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0aGlzLldyYXBwZXIgPyBub2RlIDogbmV3IHRoaXMuV3JhcHBlcihub2RlLCBzb3VyY2UsIGJhc2VJbnRlcnZhbCk7XG59O1xuXG4vLyBDcmVhdGVzIGEgbmV3IFNlbWFudGljcyBpbnN0YW5jZSBmb3IgYGdyYW1tYXJgLCBpbmhlcml0aW5nIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgZnJvbVxuLy8gYG9wdFN1cGVyU2VtYW50aWNzYCwgaWYgaXQgaXMgc3BlY2lmaWVkLiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY3RzIGFzIGEgcHJveHkgZm9yIHRoZSBuZXdcbi8vIFNlbWFudGljcyBpbnN0YW5jZS4gV2hlbiB0aGF0IGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCBhIENTVCBub2RlIGFzIGFuIGFyZ3VtZW50LCBpdCByZXR1cm5zXG4vLyBhIHdyYXBwZXIgZm9yIHRoYXQgbm9kZSB3aGljaCBnaXZlcyBhY2Nlc3MgdG8gdGhlIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgcHJvdmlkZWQgYnkgdGhpc1xuLy8gc2VtYW50aWNzLlxuU2VtYW50aWNzLmNyZWF0ZVNlbWFudGljcyA9IGZ1bmN0aW9uKGdyYW1tYXIsIG9wdFN1cGVyU2VtYW50aWNzKSB7XG4gIGNvbnN0IHMgPSBuZXcgU2VtYW50aWNzKFxuICAgICAgZ3JhbW1hcixcbiAgICAgIG9wdFN1cGVyU2VtYW50aWNzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIG9wdFN1cGVyU2VtYW50aWNzIDpcbiAgICAgICAgICBTZW1hbnRpY3MuQnVpbHRJblNlbWFudGljcy5fZ2V0U2VtYW50aWNzKCkpO1xuXG4gIC8vIFRvIGVuYWJsZSBjbGllbnRzIHRvIGludm9rZSBhIHNlbWFudGljcyBsaWtlIGEgZnVuY3Rpb24sIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWN0cyBhcyBhIHByb3h5XG4gIC8vIGZvciBgc2AsIHdoaWNoIGlzIHRoZSByZWFsIGBTZW1hbnRpY3NgIGluc3RhbmNlLlxuICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIEFTZW1hbnRpY3MobWF0Y2hSZXN1bHQpIHtcbiAgICBpZiAoIShtYXRjaFJlc3VsdCBpbnN0YW5jZW9mIE1hdGNoUmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnU2VtYW50aWNzIGV4cGVjdGVkIGEgTWF0Y2hSZXN1bHQsIGJ1dCBnb3QgJyArIGNvbW1vbi51bmV4cGVjdGVkT2JqVG9TdHJpbmcobWF0Y2hSZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKG1hdGNoUmVzdWx0LmZhaWxlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwbHkgU2VtYW50aWNzIHRvICcgKyBtYXRjaFJlc3VsdC50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjc3QgPSBtYXRjaFJlc3VsdC5fY3N0O1xuICAgIGlmIChjc3QuZ3JhbW1hciAhPT0gZ3JhbW1hcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHVzZSBhIE1hdGNoUmVzdWx0IGZyb20gZ3JhbW1hciAnXCIgKyBjc3QuZ3JhbW1hci5uYW1lICtcbiAgICAgICAgICBcIicgd2l0aCBhIHNlbWFudGljcyBmb3IgJ1wiICsgZ3JhbW1hci5uYW1lICsgXCInXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFN0cmVhbSA9IG5ldyBJbnB1dFN0cmVhbShtYXRjaFJlc3VsdC5pbnB1dCk7XG4gICAgcmV0dXJuIHMud3JhcChjc3QsIGlucHV0U3RyZWFtLmludGVydmFsKG1hdGNoUmVzdWx0Ll9jc3RPZmZzZXQsIG1hdGNoUmVzdWx0LmlucHV0Lmxlbmd0aCkpO1xuICB9O1xuXG4gIC8vIEZvcndhcmQgcHVibGljIG1ldGhvZHMgZnJvbSB0aGUgcHJveHkgdG8gdGhlIHNlbWFudGljcyBpbnN0YW5jZS5cbiAgcHJveHkuYWRkT3BlcmF0aW9uID0gZnVuY3Rpb24oc2lnbmF0dXJlLCBhY3Rpb25EaWN0KSB7XG4gICAgcy5hZGRPcGVyYXRpb25PckF0dHJpYnV0ZSgnb3BlcmF0aW9uJywgc2lnbmF0dXJlLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5LmV4dGVuZE9wZXJhdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBzLmV4dGVuZE9wZXJhdGlvbk9yQXR0cmlidXRlKCdvcGVyYXRpb24nLCBuYW1lLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5LmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBzLmFkZE9wZXJhdGlvbk9yQXR0cmlidXRlKCdhdHRyaWJ1dGUnLCBuYW1lLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5LmV4dGVuZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBzLmV4dGVuZE9wZXJhdGlvbk9yQXR0cmlidXRlKCdhdHRyaWJ1dGUnLCBuYW1lLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5Ll9nZXRBY3Rpb25EaWN0ID0gZnVuY3Rpb24ob3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgYWN0aW9uID0gcy5vcGVyYXRpb25zW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV0gfHwgcy5hdHRyaWJ1dGVzW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV07XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lICsgJ1wiIGlzIG5vdCBhIHZhbGlkIG9wZXJhdGlvbiBvciBhdHRyaWJ1dGUgJyArXG4gICAgICAgICduYW1lIGluIHRoaXMgc2VtYW50aWNzIGZvciBcIicgKyBncmFtbWFyLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbi5hY3Rpb25EaWN0O1xuICB9O1xuICBwcm94eS5fcmVtb3ZlID0gZnVuY3Rpb24ob3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lKSB7XG4gICAgbGV0IHNlbWFudGljO1xuICAgIGlmIChvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWUgaW4gcy5vcGVyYXRpb25zKSB7XG4gICAgICBzZW1hbnRpYyA9IHMub3BlcmF0aW9uc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgICAgZGVsZXRlIHMub3BlcmF0aW9uc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lIGluIHMuYXR0cmlidXRlcykge1xuICAgICAgc2VtYW50aWMgPSBzLmF0dHJpYnV0ZXNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGRlbGV0ZSBzLmF0dHJpYnV0ZXNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICB9XG4gICAgZGVsZXRlIHMuV3JhcHBlci5wcm90b3R5cGVbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICByZXR1cm4gc2VtYW50aWM7XG4gIH07XG4gIHByb3h5LmdldE9wZXJhdGlvbk5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMub3BlcmF0aW9ucyk7XG4gIH07XG4gIHByb3h5LmdldEF0dHJpYnV0ZU5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMuYXR0cmlidXRlcyk7XG4gIH07XG4gIHByb3h5LmdldEdyYW1tYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcy5ncmFtbWFyO1xuICB9O1xuICBwcm94eS50b1JlY2lwZSA9IGZ1bmN0aW9uKHNlbWFudGljc09ubHkpIHtcbiAgICByZXR1cm4gcy50b1JlY2lwZShzZW1hbnRpY3NPbmx5KTtcbiAgfTtcblxuICAvLyBNYWtlIHRoZSBwcm94eSdzIHRvU3RyaW5nKCkgd29yay5cbiAgcHJveHkudG9TdHJpbmcgPSBzLnRvU3RyaW5nLmJpbmQocyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgc2VtYW50aWNzIGZvciB0aGUgcHJveHkuXG4gIHByb3h5Ll9nZXRTZW1hbnRpY3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcztcbiAgfTtcblxuICByZXR1cm4gcHJveHk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBPcGVyYXRpb24gLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQW4gT3BlcmF0aW9uIHJlcHJlc2VudHMgYSBmdW5jdGlvbiB0byBiZSBhcHBsaWVkIHRvIGEgY29uY3JldGUgc3ludGF4IHRyZWUgKENTVCkgLS0gaXQncyB2ZXJ5XG4vLyBzaW1pbGFyIHRvIGEgVmlzaXRvciAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WaXNpdG9yX3BhdHRlcm4pLiBBbiBvcGVyYXRpb24gaXMgZXhlY3V0ZWQgYnlcbi8vIHJlY3Vyc2l2ZWx5IHdhbGtpbmcgdGhlIENTVCwgYW5kIGF0IGVhY2ggbm9kZSwgaW52b2tpbmcgdGhlIG1hdGNoaW5nIHNlbWFudGljIGFjdGlvbiBmcm9tXG4vLyBgYWN0aW9uRGljdGAuIFNlZSBgT3BlcmF0aW9uLnByb3RvdHlwZS5leGVjdXRlYCBmb3IgZGV0YWlscyBvZiBob3cgYSBDU1Qgbm9kZSdzIG1hdGNoaW5nIHNlbWFudGljXG4vLyBhY3Rpb24gaXMgZm91bmQuXG5jbGFzcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBmb3JtYWxzLCBhY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5mb3JtYWxzID0gZm9ybWFscztcbiAgICB0aGlzLmFjdGlvbkRpY3QgPSBhY3Rpb25EaWN0O1xuICAgIHRoaXMuYnVpbHRJbkRlZmF1bHQgPSBidWlsdEluRGVmYXVsdDtcbiAgfVxuXG4gIGNoZWNrQWN0aW9uRGljdChncmFtbWFyKSB7XG4gICAgZ3JhbW1hci5fY2hlY2tUb3BEb3duQWN0aW9uRGljdCh0aGlzLnR5cGVOYW1lLCB0aGlzLm5hbWUsIHRoaXMuYWN0aW9uRGljdCk7XG4gIH1cblxuICAvLyBFeGVjdXRlIHRoaXMgb3BlcmF0aW9uIG9uIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggYG5vZGVXcmFwcGVyYCBpbiB0aGUgY29udGV4dCBvZiB0aGVcbiAgLy8gZ2l2ZW4gU2VtYW50aWNzIGluc3RhbmNlLlxuICBleGVjdXRlKHNlbWFudGljcywgbm9kZVdyYXBwZXIpIHtcbiAgICB0cnkge1xuICAgICAgLy8gTG9vayBmb3IgYSBzZW1hbnRpYyBhY3Rpb24gd2hvc2UgbmFtZSBtYXRjaGVzIHRoZSBub2RlJ3MgY29uc3RydWN0b3IgbmFtZSwgd2hpY2ggaXMgZWl0aGVyXG4gICAgICAvLyB0aGUgbmFtZSBvZiBhIHJ1bGUgaW4gdGhlIGdyYW1tYXIsIG9yICdfdGVybWluYWwnIChmb3IgYSB0ZXJtaW5hbCBub2RlKSwgb3IgJ19pdGVyJyAoZm9yIGFuXG4gICAgICAvLyBpdGVyYXRpb24gbm9kZSkuIEluIHRoZSBsYXR0ZXIgY2FzZSwgdGhlIGFjdGlvbiBmdW5jdGlvbiByZWNlaXZlcyBhIHNpbmdsZSBhcmd1bWVudCwgd2hpY2hcbiAgICAgIC8vIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgQ1NUIG5vZGUuXG4gICAgICBjb25zdCBjdG9yTmFtZSA9IG5vZGVXcmFwcGVyLl9ub2RlLmN0b3JOYW1lO1xuICAgICAgbGV0IGFjdGlvbkZuID0gdGhpcy5hY3Rpb25EaWN0W2N0b3JOYW1lXTtcbiAgICAgIGxldCBhbnM7XG4gICAgICBpZiAoYWN0aW9uRm4pIHtcbiAgICAgICAgZ2xvYmFsQWN0aW9uU3RhY2sucHVzaChbdGhpcywgY3Rvck5hbWVdKTtcbiAgICAgICAgYW5zID0gdGhpcy5kb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCBhY3Rpb25Gbiwgbm9kZVdyYXBwZXIuaXNJdGVyYXRpb24oKSk7XG4gICAgICAgIHJldHVybiBhbnM7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBhY3Rpb24gZGljdGlvbmFyeSBkb2VzIG5vdCBjb250YWluIGEgc2VtYW50aWMgYWN0aW9uIGZvciB0aGlzIHNwZWNpZmljIHR5cGUgb2Ygbm9kZS5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBub250ZXJtaW5hbCBub2RlIGFuZCB0aGUgcHJvZ3JhbW1lciBoYXMgcHJvdmlkZWQgYSBgX25vbnRlcm1pbmFsYCBzZW1hbnRpY1xuICAgICAgLy8gYWN0aW9uLCB3ZSBpbnZva2UgaXQ6XG4gICAgICBpZiAobm9kZVdyYXBwZXIuaXNOb250ZXJtaW5hbCgpKSB7XG4gICAgICAgIGFjdGlvbkZuID0gdGhpcy5hY3Rpb25EaWN0Ll9ub250ZXJtaW5hbDtcbiAgICAgICAgaWYgKGFjdGlvbkZuKSB7XG4gICAgICAgICAgZ2xvYmFsQWN0aW9uU3RhY2sucHVzaChbdGhpcywgJ19ub250ZXJtaW5hbCcsIGN0b3JOYW1lXSk7XG4gICAgICAgICAgYW5zID0gdGhpcy5kb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCBhY3Rpb25GbiwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIGFucztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGludm9rZSB0aGUgJ19kZWZhdWx0JyBzZW1hbnRpYyBhY3Rpb24uXG4gICAgICBnbG9iYWxBY3Rpb25TdGFjay5wdXNoKFt0aGlzLCAnZGVmYXVsdCBhY3Rpb24nLCBjdG9yTmFtZV0pO1xuICAgICAgYW5zID0gdGhpcy5kb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCB0aGlzLmFjdGlvbkRpY3QuX2RlZmF1bHQsIHRydWUpO1xuICAgICAgcmV0dXJuIGFucztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZ2xvYmFsQWN0aW9uU3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlIGBhY3Rpb25GbmAgb24gdGhlIENTVCBub2RlIHRoYXQgY29ycmVzcG9uZHMgdG8gYG5vZGVXcmFwcGVyYCwgaW4gdGhlIGNvbnRleHQgb2ZcbiAgLy8gYHNlbWFudGljc2AuIElmIGBvcHRQYXNzQ2hpbGRyZW5Bc0FycmF5YCBpcyB0cnV0aHksIGBhY3Rpb25GbmAgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZVxuICAvLyBhcmd1bWVudCwgd2hpY2ggaXMgYW4gYXJyYXkgb2Ygd3JhcHBlcnMuIE90aGVyd2lzZSwgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYGFjdGlvbkZuYCB3aWxsXG4gIC8vIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhlIENTVCBub2RlLlxuICBkb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCBhY3Rpb25Gbiwgb3B0UGFzc0NoaWxkcmVuQXNBcnJheSkge1xuICAgIHJldHVybiBvcHRQYXNzQ2hpbGRyZW5Bc0FycmF5ID9cbiAgICAgICAgYWN0aW9uRm4uY2FsbChub2RlV3JhcHBlciwgbm9kZVdyYXBwZXIuX2NoaWxkcmVuKCkpIDpcbiAgICAgICAgYWN0aW9uRm4uYXBwbHkobm9kZVdyYXBwZXIsIG5vZGVXcmFwcGVyLl9jaGlsZHJlbigpKTtcbiAgfVxufVxuXG5PcGVyYXRpb24ucHJvdG90eXBlLnR5cGVOYW1lID0gJ29wZXJhdGlvbic7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIEF0dHJpYnV0ZSAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBdHRyaWJ1dGVzIGFyZSBPcGVyYXRpb25zIHdob3NlIHJlc3VsdHMgYXJlIG1lbW9pemVkLiBUaGlzIG1lYW5zIHRoYXQsIGZvciBhbnkgZ2l2ZW4gc2VtYW50aWNzLFxuLy8gdGhlIHNlbWFudGljIGFjdGlvbiBmb3IgYSBDU1Qgbm9kZSB3aWxsIGJlIGludm9rZWQgbm8gbW9yZSB0aGFuIG9uY2UuXG5jbGFzcyBBdHRyaWJ1dGUgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBhY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCkge1xuICAgIHN1cGVyKG5hbWUsIFtdLCBhY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCk7XG4gIH1cblxuICBleGVjdXRlKHNlbWFudGljcywgbm9kZVdyYXBwZXIpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZVdyYXBwZXIuX25vZGU7XG4gICAgY29uc3Qga2V5ID0gc2VtYW50aWNzLmF0dHJpYnV0ZUtleXNbdGhpcy5uYW1lXTtcbiAgICBpZiAoIW5vZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIHN1cGVyLXNlbmQgLS0gaXNuJ3QgSlMgYmVhdXRpZnVsPyA6L1xuICAgICAgbm9kZVtrZXldID0gT3BlcmF0aW9uLnByb3RvdHlwZS5leGVjdXRlLmNhbGwodGhpcywgc2VtYW50aWNzLCBub2RlV3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiBub2RlW2tleV07XG4gIH1cbn1cblxuQXR0cmlidXRlLnByb3RvdHlwZS50eXBlTmFtZSA9ICdhdHRyaWJ1dGUnO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIERlZmVycmVkIGluaXRpYWxpemF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tXG5cbnV0aWwuYXdhaXRCdWlsdEluUnVsZXMoYnVpbHRJblJ1bGVzID0+IHtcbiAgY29uc3Qgb3BlcmF0aW9uc0FuZEF0dHJpYnV0ZXNHcmFtbWFyID0gcmVxdWlyZSgnLi4vZGlzdC9vcGVyYXRpb25zLWFuZC1hdHRyaWJ1dGVzJyk7XG4gIGluaXRCdWlsdEluU2VtYW50aWNzKGJ1aWx0SW5SdWxlcyk7XG4gIGluaXRQcm90b3R5cGVQYXJzZXIob3BlcmF0aW9uc0FuZEF0dHJpYnV0ZXNHcmFtbWFyKTsgLy8gcmVxdWlyZXMgQnVpbHRJblNlbWFudGljc1xufSk7XG5cbmZ1bmN0aW9uIGluaXRCdWlsdEluU2VtYW50aWNzKGJ1aWx0SW5SdWxlcykge1xuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIGVtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0aW9uKCk7XG4gICAgfSxcbiAgICBub25FbXB0eShmaXJzdCwgXywgcmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0aW9uKFtmaXJzdF0uY29uY2F0KHJlc3QuY2hpbGRyZW4pKTtcbiAgICB9XG4gIH07XG5cbiAgU2VtYW50aWNzLkJ1aWx0SW5TZW1hbnRpY3MgPSBTZW1hbnRpY3NcbiAgICAgIC5jcmVhdGVTZW1hbnRpY3MoYnVpbHRJblJ1bGVzLCBudWxsKVxuICAgICAgLmFkZE9wZXJhdGlvbignYXNJdGVyYXRpb24nLCB7XG4gICAgICAgIGVtcHR5TGlzdE9mOiBhY3Rpb25zLmVtcHR5LFxuICAgICAgICBub25lbXB0eUxpc3RPZjogYWN0aW9ucy5ub25FbXB0eSxcbiAgICAgICAgRW1wdHlMaXN0T2Y6IGFjdGlvbnMuZW1wdHksXG4gICAgICAgIE5vbmVtcHR5TGlzdE9mOiBhY3Rpb25zLm5vbkVtcHR5XG4gICAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3RvdHlwZVBhcnNlcihncmFtbWFyKSB7XG4gIHByb3RvdHlwZUdyYW1tYXJTZW1hbnRpY3MgPSBncmFtbWFyLmNyZWF0ZVNlbWFudGljcygpLmFkZE9wZXJhdGlvbigncGFyc2UnLCB7XG4gICAgQXR0cmlidXRlU2lnbmF0dXJlKG5hbWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUucGFyc2UoKSxcbiAgICAgICAgZm9ybWFsczogW11cbiAgICAgIH07XG4gICAgfSxcbiAgICBPcGVyYXRpb25TaWduYXR1cmUobmFtZSwgb3B0Rm9ybWFscykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZS5wYXJzZSgpLFxuICAgICAgICBmb3JtYWxzOiBvcHRGb3JtYWxzLnBhcnNlKClbMF0gfHwgW11cbiAgICAgIH07XG4gICAgfSxcbiAgICBGb3JtYWxzKG9wYXJlbiwgZnMsIGNwYXJlbikge1xuICAgICAgcmV0dXJuIGZzLmFzSXRlcmF0aW9uKCkucGFyc2UoKTtcbiAgICB9LFxuICAgIG5hbWUoZmlyc3QsIHJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVN0cmluZztcbiAgICB9XG4gIH0pO1xuICBwcm90b3R5cGVHcmFtbWFyID0gZ3JhbW1hcjtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbWFudGljcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEludGVydmFsID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGFyZSB1c2VkIGluIHRoZSBgdG9TdHJpbmdgIG91dHB1dC5cbmNvbnN0IEJBTExPVF9YID0gJ1xcdTI3MTcnO1xuY29uc3QgQ0hFQ0tfTUFSSyA9ICdcXHUyNzEzJztcbmNvbnN0IERPVF9PUEVSQVRPUiA9ICdcXHUyMkM1JztcbmNvbnN0IFJJR0hUV0FSRFNfRE9VQkxFX0FSUk9XID0gJ1xcdTIxRDInO1xuY29uc3QgU1lNQk9MX0ZPUl9IT1JJWk9OVEFMX1RBQlVMQVRJT04gPSAnXFx1MjQwOSc7XG5jb25zdCBTWU1CT0xfRk9SX0xJTkVfRkVFRCA9ICdcXHUyNDBBJztcbmNvbnN0IFNZTUJPTF9GT1JfQ0FSUklBR0VfUkVUVVJOID0gJ1xcdTI0MEQnO1xuXG5jb25zdCBGbGFncyA9IHtcbiAgc3VjY2VlZGVkOiAxIDw8IDAsXG4gIGlzUm9vdE5vZGU6IDEgPDwgMSxcbiAgaXNJbXBsaWNpdFNwYWNlczogMSA8PCAyLFxuICBpc01lbW9pemVkOiAxIDw8IDMsXG4gIGlzSGVhZE9mTGVmdFJlY3Vyc2lvbjogMSA8PCA0LFxuICB0ZXJtaW5hdGVzTFI6IDEgPDwgNVxufTtcblxuZnVuY3Rpb24gc3BhY2VzKG4pIHtcbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBuKS5qb2luKCcnKTtcbn1cblxuLy8gUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcG9ydGlvbiBvZiBgaW5wdXRgIGF0IG9mZnNldCBgcG9zYC5cbi8vIFRoZSByZXN1bHQgd2lsbCBjb250YWluIGV4YWN0bHkgYGxlbmAgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIGdldElucHV0RXhjZXJwdChpbnB1dCwgcG9zLCBsZW4pIHtcbiAgY29uc3QgZXhjZXJwdCA9IGFzRXNjYXBlZFN0cmluZyhpbnB1dC5zbGljZShwb3MsIHBvcyArIGxlbikpO1xuXG4gIC8vIFBhZCB0aGUgb3V0cHV0IGlmIG5lY2Vzc2FyeS5cbiAgaWYgKGV4Y2VycHQubGVuZ3RoIDwgbGVuKSB7XG4gICAgcmV0dXJuIGV4Y2VycHQgKyBjb21tb24ucmVwZWF0KCcgJywgbGVuIC0gZXhjZXJwdC5sZW5ndGgpLmpvaW4oJycpO1xuICB9XG4gIHJldHVybiBleGNlcnB0O1xufVxuXG5mdW5jdGlvbiBhc0VzY2FwZWRTdHJpbmcob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFJlcGxhY2Ugbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzIHdpdGggdmlzaWJsZSBzeW1ib2xzLlxuICAgIHJldHVybiBvYmpcbiAgICAgICAgLnJlcGxhY2UoLyAvZywgRE9UX09QRVJBVE9SKVxuICAgICAgICAucmVwbGFjZSgvXFx0L2csIFNZTUJPTF9GT1JfSE9SSVpPTlRBTF9UQUJVTEFUSU9OKVxuICAgICAgICAucmVwbGFjZSgvXFxuL2csIFNZTUJPTF9GT1JfTElORV9GRUVEKVxuICAgICAgICAucmVwbGFjZSgvXFxyL2csIFNZTUJPTF9GT1JfQ0FSUklBR0VfUkVUVVJOKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIFRyYWNlIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIFRyYWNlKGlucHV0LCBwb3MxLCBwb3MyLCBleHByLCBzdWNjZWVkZWQsIGJpbmRpbmdzLCBvcHRDaGlsZHJlbikge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MxID0gcG9zMTtcbiAgdGhpcy5wb3MyID0gcG9zMjtcbiAgdGhpcy5zb3VyY2UgPSBuZXcgSW50ZXJ2YWwoaW5wdXQsIHBvczEsIHBvczIpO1xuICB0aGlzLmV4cHIgPSBleHByO1xuICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gIHRoaXMuY2hpbGRyZW4gPSBvcHRDaGlsZHJlbiB8fCBbXTtcbiAgdGhpcy50ZXJtaW5hdGluZ0xSRW50cnkgPSBudWxsO1xuXG4gIHRoaXMuX2ZsYWdzID0gc3VjY2VlZGVkID8gRmxhZ3Muc3VjY2VlZGVkIDogMDtcbn1cblxuLy8gQSB2YWx1ZSB0aGF0IGNhbiBiZSByZXR1cm5lZCBmcm9tIHZpc2l0b3IgZnVuY3Rpb25zIHRvIGluZGljYXRlIHRoYXQgYVxuLy8gbm9kZSBzaG91bGQgbm90IGJlIHJlY3Vyc2VkIGludG8uXG5UcmFjZS5wcm90b3R5cGUuU0tJUCA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2UucHJvdG90eXBlLCAnZGlzcGxheVN0cmluZycsIHtcbiAgZ2V0KCkgeyByZXR1cm4gdGhpcy5leHByLnRvRGlzcGxheVN0cmluZygpOyB9XG59KTtcblxuLy8gRm9yIGNvbnZlbmllbmNlLCBjcmVhdGUgYSBnZXR0ZXIgYW5kIHNldHRlciBmb3IgdGhlIGJvb2xlYW4gZmxhZ3MgaW4gYEZsYWdzYC5cbk9iamVjdC5rZXlzKEZsYWdzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICBjb25zdCBtYXNrID0gRmxhZ3NbbmFtZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFjZS5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgbWFzaykgIT09IDA7XG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzIHw9IG1hc2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mbGFncyAmPSB+bWFzaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSk7XG5cblRyYWNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jbG9uZVdpdGhFeHByKHRoaXMuZXhwcik7XG59O1xuXG5UcmFjZS5wcm90b3R5cGUuY2xvbmVXaXRoRXhwciA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgY29uc3QgYW5zID0gbmV3IFRyYWNlKFxuICAgICAgdGhpcy5pbnB1dCwgdGhpcy5wb3MsIHRoaXMucG9zMiwgZXhwciwgdGhpcy5zdWNjZWVkZWQsIHRoaXMuYmluZGluZ3MsIHRoaXMuY2hpbGRyZW4pO1xuXG4gIGFucy5pc0hlYWRPZkxlZnRSZWN1cnNpb24gPSB0aGlzLmlzSGVhZE9mTGVmdFJlY3Vyc2lvbjtcbiAgYW5zLmlzSW1wbGljaXRTcGFjZXMgPSB0aGlzLmlzSW1wbGljaXRTcGFjZXM7XG4gIGFucy5pc01lbW9pemVkID0gdGhpcy5pc01lbW9pemVkO1xuICBhbnMuaXNSb290Tm9kZSA9IHRoaXMuaXNSb290Tm9kZTtcbiAgYW5zLnRlcm1pbmF0ZXNMUiA9IHRoaXMudGVybWluYXRlc0xSO1xuICBhbnMudGVybWluYXRpbmdMUkVudHJ5ID0gdGhpcy50ZXJtaW5hdGluZ0xSRW50cnk7XG4gIHJldHVybiBhbnM7XG59O1xuXG4vLyBSZWNvcmQgdGhlIHRyYWNlIGluZm9ybWF0aW9uIGZvciB0aGUgdGVybWluYXRpbmcgY29uZGl0aW9uIG9mIHRoZSBMUiBsb29wLlxuVHJhY2UucHJvdG90eXBlLnJlY29yZExSVGVybWluYXRpb24gPSBmdW5jdGlvbihydWxlQm9keVRyYWNlLCB2YWx1ZSkge1xuICB0aGlzLnRlcm1pbmF0aW5nTFJFbnRyeSA9XG4gICAgICBuZXcgVHJhY2UodGhpcy5pbnB1dCwgdGhpcy5wb3MsIHRoaXMucG9zMiwgdGhpcy5leHByLCBmYWxzZSwgW3ZhbHVlXSwgW3J1bGVCb2R5VHJhY2VdKTtcbiAgdGhpcy50ZXJtaW5hdGluZ0xSRW50cnkudGVybWluYXRlc0xSID0gdHJ1ZTtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoaXMgdHJhY2Ugbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kZW50cywgY2FsbGluZyBhIHZpc2l0b3IgZnVuY3Rpb25cbi8vIGZvciBlYWNoIG5vZGUgdGhhdCBpcyB2aXNpdGVkLiBJZiBgdmlzdG9yT2JqT3JGbmAgaXMgYW4gb2JqZWN0LCB0aGVuIGl0cyAnZW50ZXInIHByb3BlcnR5XG4vLyBpcyBhIGZ1bmN0aW9uIHRvIGNhbGwgYmVmb3JlIHZpc2l0aW5nIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUsIGFuZCBpdHMgJ2V4aXQnIHByb3BlcnR5IGlzXG4vLyBhIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXJ3YXJkcy4gSWYgYHZpc2l0b3JPYmpPckZuYCBpcyBhIGZ1bmN0aW9uLCBpdCByZXByZXNlbnRzIHRoZSAnZW50ZXInXG4vLyBmdW5jdGlvbi5cbi8vXG4vLyBUaGUgZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IHRoZSBUcmFjZSBub2RlLCBpdHMgcGFyZW50IFRyYWNlLCBhbmQgYSBudW1iZXJcbi8vIHJlcHJlc2VudGluZyB0aGUgZGVwdGggb2YgdGhlIG5vZGUgaW4gdGhlIHRyZWUuIChUaGUgcm9vdCBub2RlIGhhcyBkZXB0aCAwLikgYG9wdFRoaXNBcmdgLCBpZlxuLy8gc3BlY2lmaWVkLCBpcyB0aGUgdmFsdWUgdG8gdXNlIGZvciBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHZpc2l0b3IgZnVuY3Rpb25zLlxuVHJhY2UucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbih2aXNpdG9yT2JqT3JGbiwgb3B0VGhpc0FyZykge1xuICBsZXQgdmlzaXRvciA9IHZpc2l0b3JPYmpPckZuO1xuICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2aXNpdG9yID0ge2VudGVyOiB2aXNpdG9yfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF93YWxrKG5vZGUsIHBhcmVudCwgZGVwdGgpIHtcbiAgICBsZXQgcmVjdXJzZSA9IHRydWU7XG4gICAgaWYgKHZpc2l0b3IuZW50ZXIpIHtcbiAgICAgIGlmICh2aXNpdG9yLmVudGVyLmNhbGwob3B0VGhpc0FyZywgbm9kZSwgcGFyZW50LCBkZXB0aCkgPT09IFRyYWNlLnByb3RvdHlwZS5TS0lQKSB7XG4gICAgICAgIHJlY3Vyc2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIF93YWxrKGNoaWxkLCBub2RlLCBkZXB0aCArIDEpO1xuICAgICAgfSk7XG4gICAgICBpZiAodmlzaXRvci5leGl0KSB7XG4gICAgICAgIHZpc2l0b3IuZXhpdC5jYWxsKG9wdFRoaXNBcmcsIG5vZGUsIHBhcmVudCwgZGVwdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodGhpcy5pc1Jvb3ROb2RlKSB7XG4gICAgLy8gRG9uJ3QgdmlzaXQgdGhlIHJvb3Qgbm9kZSBpdHNlbGYsIG9ubHkgaXRzIGNoaWxkcmVuLlxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjID0+IHsgX3dhbGsoYywgbnVsbCwgMCk7IH0pO1xuICB9IGVsc2Uge1xuICAgIF93YWxrKHRoaXMsIG51bGwsIDApO1xuICB9XG59O1xuXG4vLyBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYWNlLlxuLy8gU2FtcGxlOlxuLy8gICAgIDEy4ouFK+KLhTLii4Uq4ouFMyDinJMgZXhwIOKHkiAgXCIxMlwiXG4vLyAgICAgMTLii4Ur4ouFMuKLhSrii4UzICAg4pyTIGFkZEV4cCAoTFIpIOKHkiAgXCIxMlwiXG4vLyAgICAgMTLii4Ur4ouFMuKLhSrii4UzICAgICAgIOKclyBhZGRFeHBfcGx1c1xuVHJhY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNiID0gbmV3IGNvbW1vbi5TdHJpbmdCdWZmZXIoKTtcbiAgdGhpcy53YWxrKChub2RlLCBwYXJlbnQsIGRlcHRoKSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5TS0lQO1xuICAgIH1cbiAgICBjb25zdCBjdG9yTmFtZSA9IG5vZGUuZXhwci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIC8vIERvbid0IHByaW50IGFueXRoaW5nIGZvciBBbHQgbm9kZXMuXG4gICAgaWYgKGN0b3JOYW1lID09PSAnQWx0Jykge1xuICAgICAgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgfVxuICAgIHNiLmFwcGVuZChnZXRJbnB1dEV4Y2VycHQobm9kZS5pbnB1dCwgbm9kZS5wb3MsIDEwKSArIHNwYWNlcyhkZXB0aCAqIDIgKyAxKSk7XG4gICAgc2IuYXBwZW5kKChub2RlLnN1Y2NlZWRlZCA/IENIRUNLX01BUksgOiBCQUxMT1RfWCkgKyAnICcgKyBub2RlLmRpc3BsYXlTdHJpbmcpO1xuICAgIGlmIChub2RlLmlzSGVhZE9mTGVmdFJlY3Vyc2lvbikge1xuICAgICAgc2IuYXBwZW5kKCcgKExSKScpO1xuICAgIH1cbiAgICBpZiAobm9kZS5zdWNjZWVkZWQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXNFc2NhcGVkU3RyaW5nKG5vZGUuc291cmNlLmNvbnRlbnRzKTtcbiAgICAgIHNiLmFwcGVuZCgnICcgKyBSSUdIVFdBUkRTX0RPVUJMRV9BUlJPVyArICcgICcpO1xuICAgICAgc2IuYXBwZW5kKHR5cGVvZiBjb250ZW50cyA9PT0gJ3N0cmluZycgPyAnXCInICsgY29udGVudHMgKyAnXCInIDogY29udGVudHMpO1xuICAgIH1cbiAgICBzYi5hcHBlbmQoJ1xcbicpO1xuICB9KTtcbiAgcmV0dXJuIHNiLmNvbnRlbnRzKCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3V0aWwtZXh0ZW5kJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIFN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBIZWxwZXJzXG5cbmNvbnN0IGVzY2FwZVN0cmluZ0ZvciA9IHt9O1xuZm9yIChsZXQgYyA9IDA7IGMgPCAxMjg7IGMrKykge1xuICBlc2NhcGVTdHJpbmdGb3JbY10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuZXNjYXBlU3RyaW5nRm9yW1wiJ1wiLmNoYXJDb2RlQXQoMCldID0gXCJcXFxcJ1wiO1xuZXNjYXBlU3RyaW5nRm9yWydcIicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXFwiJztcbmVzY2FwZVN0cmluZ0ZvclsnXFxcXCcuY2hhckNvZGVBdCgwKV0gPSAnXFxcXFxcXFwnO1xuZXNjYXBlU3RyaW5nRm9yWydcXGInLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxiJztcbmVzY2FwZVN0cmluZ0ZvclsnXFxmJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcZic7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcbicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXG4nO1xuZXNjYXBlU3RyaW5nRm9yWydcXHInLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxyJztcbmVzY2FwZVN0cmluZ0ZvclsnXFx0Jy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcdCc7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcdTAwMGInLmNoYXJDb2RlQXQoMCldID0gJ1xcXFx2JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMuYWJzdHJhY3QgPSBmdW5jdGlvbihvcHRNZXRob2ROYW1lKSB7XG4gIGNvbnN0IG1ldGhvZE5hbWUgPSBvcHRNZXRob2ROYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndGhpcyBtZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnIGlzIGFic3RyYWN0ISAnICtcbiAgICAgICcoaXQgaGFzIG5vIGltcGxlbWVudGF0aW9uIGluIGNsYXNzICcgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnKScpO1xuICB9O1xufTtcblxuZXhwb3J0cy5hc3NlcnQgPSBmdW5jdGlvbihjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGEgbGF6aWx5LWNvbXB1dGVkLCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lZCBgcHJvcE5hbWVgXG4vLyBvbiB0aGUgb2JqZWN0IGBvYmpgLiBgZ2V0dGVyRm5gIHdpbGwgYmUgY2FsbGVkIHRvIGNvbXB1dGUgdGhlIHZhbHVlIHRoZVxuLy8gZmlyc3QgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQuXG5leHBvcnRzLmRlZmluZUxhenlQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcE5hbWUsIGdldHRlckZuKSB7XG4gIGxldCBtZW1vO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wTmFtZSwge1xuICAgIGdldCgpIHtcbiAgICAgIGlmICghbWVtbykge1xuICAgICAgICBtZW1vID0gZ2V0dGVyRm4uY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmopIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBvYmopO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblxuZXhwb3J0cy5yZXBlYXRGbiA9IGZ1bmN0aW9uKGZuLCBuKSB7XG4gIGNvbnN0IGFyciA9IFtdO1xuICB3aGlsZSAobi0tID4gMCkge1xuICAgIGFyci5wdXNoKGZuKCkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5leHBvcnRzLnJlcGVhdFN0ciA9IGZ1bmN0aW9uKHN0ciwgbikge1xuICByZXR1cm4gbmV3IEFycmF5KG4gKyAxKS5qb2luKHN0cik7XG59O1xuXG5leHBvcnRzLnJlcGVhdCA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgcmV0dXJuIGV4cG9ydHMucmVwZWF0Rm4oKCkgPT4geCwgbik7XG59O1xuXG5leHBvcnRzLmdldER1cGxpY2F0ZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICBjb25zdCBkdXBsaWNhdGVzID0gW107XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFycmF5Lmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCB4ID0gYXJyYXlbaWR4XTtcbiAgICBpZiAoYXJyYXkubGFzdEluZGV4T2YoeCkgIT09IGlkeCAmJiBkdXBsaWNhdGVzLmluZGV4T2YoeCkgPCAwKSB7XG4gICAgICBkdXBsaWNhdGVzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXBsaWNhdGVzO1xufTtcblxuZXhwb3J0cy5jb3B5V2l0aG91dER1cGxpY2F0ZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICBjb25zdCBub0R1cGxpY2F0ZXMgPSBbXTtcbiAgYXJyYXkuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgaWYgKG5vRHVwbGljYXRlcy5pbmRleE9mKGVudHJ5KSA8IDApIHtcbiAgICAgIG5vRHVwbGljYXRlcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9EdXBsaWNhdGVzO1xufTtcblxuZXhwb3J0cy5pc1N5bnRhY3RpYyA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGZpcnN0Q2hhciA9IHJ1bGVOYW1lWzBdO1xuICByZXR1cm4gZmlyc3RDaGFyID09PSBmaXJzdENoYXIudG9VcHBlckNhc2UoKTtcbn07XG5cbmV4cG9ydHMuaXNMZXhpY2FsID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgcmV0dXJuICFleHBvcnRzLmlzU3ludGFjdGljKHJ1bGVOYW1lKTtcbn07XG5cbmV4cG9ydHMucGFkTGVmdCA9IGZ1bmN0aW9uKHN0ciwgbGVuLCBvcHRDaGFyKSB7XG4gIGNvbnN0IGNoID0gb3B0Q2hhciB8fCAnICc7XG4gIGlmIChzdHIubGVuZ3RoIDwgbGVuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmVwZWF0U3RyKGNoLCBsZW4gLSBzdHIubGVuZ3RoKSArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuLy8gU3RyaW5nQnVmZmVyXG5cbmV4cG9ydHMuU3RyaW5nQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RyaW5ncyA9IFtdO1xufTtcblxuZXhwb3J0cy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLnN0cmluZ3MucHVzaChzdHIpO1xufTtcblxuZXhwb3J0cy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbnRlbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN0cmluZ3Muam9pbignJyk7XG59O1xuXG4vLyBDaGFyYWN0ZXIgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmdcblxuZXhwb3J0cy5lc2NhcGVDaGFyID0gZnVuY3Rpb24oYywgb3B0RGVsaW0pIHtcbiAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gIGlmICgoYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIikgJiYgb3B0RGVsaW0gJiYgYyAhPT0gb3B0RGVsaW0pIHtcbiAgICByZXR1cm4gYztcbiAgfSBlbHNlIGlmIChjaGFyQ29kZSA8IDEyOCkge1xuICAgIHJldHVybiBlc2NhcGVTdHJpbmdGb3JbY2hhckNvZGVdO1xuICB9IGVsc2UgaWYgKDEyOCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8IDI1Nikge1xuICAgIHJldHVybiAnXFxcXHgnICsgZXhwb3J0cy5wYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KSwgMiwgJzAnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ1xcXFx1JyArIGV4cG9ydHMucGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNiksIDQsICcwJyk7XG4gIH1cbn07XG5cbmV4cG9ydHMudW5lc2NhcGVDaGFyID0gZnVuY3Rpb24ocykge1xuICBpZiAocy5jaGFyQXQoMCkgPT09ICdcXFxcJykge1xuICAgIHN3aXRjaCAocy5jaGFyQXQoMSkpIHtcbiAgICAgIGNhc2UgJ2InOiByZXR1cm4gJ1xcYic7XG4gICAgICBjYXNlICdmJzogcmV0dXJuICdcXGYnO1xuICAgICAgY2FzZSAnbic6IHJldHVybiAnXFxuJztcbiAgICAgIGNhc2UgJ3InOiByZXR1cm4gJ1xccic7XG4gICAgICBjYXNlICd0JzogcmV0dXJuICdcXHQnO1xuICAgICAgY2FzZSAndic6IHJldHVybiAnXFx2JztcbiAgICAgIGNhc2UgJ3gnOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzLnN1YnN0cmluZygyLCA0KSwgMTYpKTtcbiAgICAgIGNhc2UgJ3UnOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzLnN1YnN0cmluZygyLCA2KSwgMTYpKTtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBzLmNoYXJBdCgxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmb3IgcHJvZHVjaW5nIGEgZGVzY3JpcHRpb24gb2YgYW4gdW5rbm93biBvYmplY3QgaW4gYSBzYWZlIHdheS5cbi8vIEVzcGVjaWFsbHkgdXNlZnVsIGZvciBlcnJvciBtZXNzYWdlcyB3aGVyZSBhbiB1bmV4cGVjdGVkIHR5cGUgb2Ygb2JqZWN0IHdhcyBlbmNvdW50ZXJlZC5cbmV4cG9ydHMudW5leHBlY3RlZE9ialRvU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbiAgfVxuICBjb25zdCBiYXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgdHJ5IHtcbiAgICBsZXQgdHlwZU5hbWU7XG4gICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgdHlwZU5hbWUgPSBvYmouY29uc3RydWN0b3IubmFtZTtcbiAgICB9IGVsc2UgaWYgKGJhc2VUb1N0cmluZy5pbmRleE9mKCdbb2JqZWN0ICcpID09PSAwKSB7XG4gICAgICB0eXBlTmFtZSA9IGJhc2VUb1N0cmluZy5zbGljZSg4LCAtMSk7IC8vIEV4dHJhY3QgZS5nLiBcIkFycmF5XCIgZnJvbSBcIltvYmplY3QgQXJyYXldXCIuXG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOYW1lID0gdHlwZW9mIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVOYW1lICsgJzogJyArIEpTT04uc3RyaW5naWZ5KFN0cmluZyhvYmopKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBiYXNlVG9TdHJpbmc7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG5jb25zdCBOYW1lc3BhY2UgPSByZXF1aXJlKCcuL05hbWVzcGFjZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgb3B0SW50ZXJ2YWwpIHtcbiAgbGV0IGU7XG4gIGlmIChvcHRJbnRlcnZhbCkge1xuICAgIGUgPSBuZXcgRXJyb3Iob3B0SW50ZXJ2YWwuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UoKSArIG1lc3NhZ2UpO1xuICAgIGUuc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICBlLmludGVydmFsID0gb3B0SW50ZXJ2YWw7XG4gIH0gZWxzZSB7XG4gICAgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gZXJyb3JzIGFib3V0IGludGVydmFscyAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpbnRlcnZhbFNvdXJjZXNEb250TWF0Y2goKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcIkludGVydmFsIHNvdXJjZXMgZG9uJ3QgbWF0Y2hcIik7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIGVycm9ycyBhYm91dCBncmFtbWFycyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBHcmFtbWFyIHN5bnRheCBlcnJvclxuXG5mdW5jdGlvbiBncmFtbWFyU3ludGF4RXJyb3IobWF0Y2hGYWlsdXJlKSB7XG4gIGNvbnN0IGUgPSBuZXcgRXJyb3IoKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdtZXNzYWdlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG1hdGNoRmFpbHVyZS5tZXNzYWdlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnc2hvcnRNZXNzYWdlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuICdFeHBlY3RlZCAnICsgbWF0Y2hGYWlsdXJlLmdldEV4cGVjdGVkVGV4dCgpO1xuICAgIH1cbiAgfSk7XG4gIGUuaW50ZXJ2YWwgPSBtYXRjaEZhaWx1cmUuZ2V0SW50ZXJ2YWwoKTtcbiAgcmV0dXJuIGU7XG59XG5cbi8vIFVuZGVjbGFyZWQgZ3JhbW1hclxuXG5mdW5jdGlvbiB1bmRlY2xhcmVkR3JhbW1hcihncmFtbWFyTmFtZSwgbmFtZXNwYWNlLCBpbnRlcnZhbCkge1xuICBjb25zdCBtZXNzYWdlID0gbmFtZXNwYWNlID9cbiAgICAgICdHcmFtbWFyICcgKyBncmFtbWFyTmFtZSArICcgaXMgbm90IGRlY2xhcmVkIGluIG5hbWVzcGFjZSAnICsgTmFtZXNwYWNlLnRvU3RyaW5nKG5hbWVzcGFjZSkgOlxuICAgICAgJ1VuZGVjbGFyZWQgZ3JhbW1hciAnICsgZ3JhbW1hck5hbWU7XG4gIHJldHVybiBjcmVhdGVFcnJvcihtZXNzYWdlLCBpbnRlcnZhbCk7XG59XG5cbi8vIER1cGxpY2F0ZSBncmFtbWFyIGRlY2xhcmF0aW9uXG5cbmZ1bmN0aW9uIGR1cGxpY2F0ZUdyYW1tYXJEZWNsYXJhdGlvbihncmFtbWFyLCBuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKCdHcmFtbWFyICcgKyBncmFtbWFyLm5hbWUgKyAnIGlzIGFscmVhZHkgZGVjbGFyZWQgaW4gdGhpcyBuYW1lc3BhY2UnKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gcnVsZXMgLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVW5kZWNsYXJlZCBydWxlXG5cbmZ1bmN0aW9uIHVuZGVjbGFyZWRSdWxlKHJ1bGVOYW1lLCBncmFtbWFyTmFtZSwgb3B0SW50ZXJ2YWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ1J1bGUgJyArIHJ1bGVOYW1lICsgJyBpcyBub3QgZGVjbGFyZWQgaW4gZ3JhbW1hciAnICsgZ3JhbW1hck5hbWUsXG4gICAgICBvcHRJbnRlcnZhbCk7XG59XG5cbi8vIENhbm5vdCBvdmVycmlkZSB1bmRlY2xhcmVkIHJ1bGVcblxuZnVuY3Rpb24gY2Fubm90T3ZlcnJpZGVVbmRlY2xhcmVkUnVsZShydWxlTmFtZSwgZ3JhbW1hck5hbWUsIG9wdFNvdXJjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnQ2Fubm90IG92ZXJyaWRlIHJ1bGUgJyArIHJ1bGVOYW1lICsgJyBiZWNhdXNlIGl0IGlzIG5vdCBkZWNsYXJlZCBpbiAnICsgZ3JhbW1hck5hbWUsXG4gICAgICBvcHRTb3VyY2UpO1xufVxuXG4vLyBDYW5ub3QgZXh0ZW5kIHVuZGVjbGFyZWQgcnVsZVxuXG5mdW5jdGlvbiBjYW5ub3RFeHRlbmRVbmRlY2xhcmVkUnVsZShydWxlTmFtZSwgZ3JhbW1hck5hbWUsIG9wdFNvdXJjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnQ2Fubm90IGV4dGVuZCBydWxlICcgKyBydWxlTmFtZSArICcgYmVjYXVzZSBpdCBpcyBub3QgZGVjbGFyZWQgaW4gJyArIGdyYW1tYXJOYW1lLFxuICAgICAgb3B0U291cmNlKTtcbn1cblxuLy8gRHVwbGljYXRlIHJ1bGUgZGVjbGFyYXRpb25cblxuZnVuY3Rpb24gZHVwbGljYXRlUnVsZURlY2xhcmF0aW9uKHJ1bGVOYW1lLCBncmFtbWFyTmFtZSwgZGVjbEdyYW1tYXJOYW1lLCBvcHRTb3VyY2UpIHtcbiAgbGV0IG1lc3NhZ2UgPSBcIkR1cGxpY2F0ZSBkZWNsYXJhdGlvbiBmb3IgcnVsZSAnXCIgKyBydWxlTmFtZSArXG4gICAgICBcIicgaW4gZ3JhbW1hciAnXCIgKyBncmFtbWFyTmFtZSArIFwiJ1wiO1xuICBpZiAoZ3JhbW1hck5hbWUgIT09IGRlY2xHcmFtbWFyTmFtZSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgKG9yaWdpbmFsbHkgZGVjbGFyZWQgaW4gJ1wiICsgZGVjbEdyYW1tYXJOYW1lICsgXCInKVwiO1xuICB9XG4gIHJldHVybiBjcmVhdGVFcnJvcihtZXNzYWdlLCBvcHRTb3VyY2UpO1xufVxuXG4vLyBXcm9uZyBudW1iZXIgb2YgcGFyYW1ldGVyc1xuXG5mdW5jdGlvbiB3cm9uZ051bWJlck9mUGFyYW1ldGVycyhydWxlTmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCwgc291cmNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdXcm9uZyBudW1iZXIgb2YgcGFyYW1ldGVycyBmb3IgcnVsZSAnICsgcnVsZU5hbWUgK1xuICAgICAgICAgICcgKGV4cGVjdGVkICcgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsICsgJyknLFxuICAgICAgc291cmNlKTtcbn1cblxuLy8gV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xuXG5mdW5jdGlvbiB3cm9uZ051bWJlck9mQXJndW1lbnRzKHJ1bGVOYW1lLCBleHBlY3RlZCwgYWN0dWFsLCBleHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBydWxlICcgKyBydWxlTmFtZSArXG4gICAgICAgICAgJyAoZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJywgZ290ICcgKyBhY3R1YWwgKyAnKScsXG4gICAgICBleHByLnNvdXJjZSk7XG59XG5cbi8vIER1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXNcblxuZnVuY3Rpb24gZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMocnVsZU5hbWUsIGR1cGxpY2F0ZXMsIHNvdXJjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnRHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcyBpbiBydWxlICcgKyBydWxlTmFtZSArICc6ICcgKyBkdXBsaWNhdGVzLmpvaW4oJywgJyksXG4gICAgICBzb3VyY2UpO1xufVxuXG4vLyBJbnZhbGlkIHBhcmFtZXRlciBleHByZXNzaW9uXG5cbmZ1bmN0aW9uIGludmFsaWRQYXJhbWV0ZXIocnVsZU5hbWUsIGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ0ludmFsaWQgcGFyYW1ldGVyIHRvIHJ1bGUgJyArIHJ1bGVOYW1lICsgJzogJyArIGV4cHIgKyAnIGhhcyBhcml0eSAnICsgZXhwci5nZXRBcml0eSgpICtcbiAgICAgICAgICcsIGJ1dCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgbXVzdCBoYXZlIGFyaXR5IDEnLFxuICAgICAgZXhwci5zb3VyY2UpO1xufVxuXG4vLyBBcHBsaWNhdGlvbiBvZiBzeW50YWN0aWMgcnVsZSBmcm9tIGxleGljYWwgcnVsZVxuXG5mdW5jdGlvbiBhcHBsaWNhdGlvbk9mU3ludGFjdGljUnVsZUZyb21MZXhpY2FsQ29udGV4dChydWxlTmFtZSwgYXBwbHlFeHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdDYW5ub3QgYXBwbHkgc3ludGFjdGljIHJ1bGUgJyArIHJ1bGVOYW1lICsgJyBmcm9tIGhlcmUgKGluc2lkZSBhIGxleGljYWwgY29udGV4dCknLFxuICAgICAgYXBwbHlFeHByLnNvdXJjZSk7XG59XG5cbi8vIEluY29ycmVjdCBhcmd1bWVudCB0eXBlXG5cbmZ1bmN0aW9uIGluY29ycmVjdEFyZ3VtZW50VHlwZShleHBlY3RlZFR5cGUsIGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKCdJbmNvcnJlY3QgYXJndW1lbnQgdHlwZTogZXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZSwgZXhwci5zb3VyY2UpO1xufVxuXG4vLyBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIHN1cGVyLXNwbGljZSBvcGVyYXRvciAoYC4uLmApIGluIHRoZSBydWxlIGJvZHkuXG5cbmZ1bmN0aW9uIG11bHRpcGxlU3VwZXJTcGxpY2VzKGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFwiJy4uLicgY2FuIGFwcGVhciBhdCBtb3N0IG9uY2UgaW4gYSBydWxlIGJvZHlcIiwgZXhwci5zb3VyY2UpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBLbGVlbmUgb3BlcmF0b3JzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGtsZWVuZUV4cHJIYXNOdWxsYWJsZU9wZXJhbmQoa2xlZW5lRXhwciwgYXBwbGljYXRpb25TdGFjaykge1xuICBjb25zdCBhY3R1YWxzID0gYXBwbGljYXRpb25TdGFjay5sZW5ndGggPiAwID9cbiAgICBhcHBsaWNhdGlvblN0YWNrW2FwcGxpY2F0aW9uU3RhY2subGVuZ3RoIC0gMV0uYXJncyA6XG4gICAgW107XG4gIGNvbnN0IGV4cHIgPSBrbGVlbmVFeHByLmV4cHIuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKTtcbiAgbGV0IG1lc3NhZ2UgPVxuICAgICdOdWxsYWJsZSBleHByZXNzaW9uICcgKyBleHByICsgXCIgaXMgbm90IGFsbG93ZWQgaW5zaWRlICdcIiArXG4gICAga2xlZW5lRXhwci5vcGVyYXRvciArIFwiJyAocG9zc2libGUgaW5maW5pdGUgbG9vcClcIjtcbiAgaWYgKGFwcGxpY2F0aW9uU3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBhcHBsaWNhdGlvblN0YWNrXG4gICAgICAgIC5tYXAoYXBwID0+IG5ldyBwZXhwcnMuQXBwbHkoYXBwLnJ1bGVOYW1lLCBhcHAuYXJncykpXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICBtZXNzYWdlICs9ICdcXG5BcHBsaWNhdGlvbiBzdGFjayAobW9zdCByZWNlbnQgYXBwbGljYXRpb24gbGFzdCk6XFxuJyArIHN0YWNrVHJhY2U7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGtsZWVuZUV4cHIuZXhwci5zb3VyY2UpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBhcml0eSAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpbmNvbnNpc3RlbnRBcml0eShydWxlTmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCwgZXhwcikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnUnVsZSAnICsgcnVsZU5hbWUgKyAnIGludm9sdmVzIGFuIGFsdGVybmF0aW9uIHdoaWNoIGhhcyBpbmNvbnNpc3RlbnQgYXJpdHkgJyArXG4gICAgICAgICAgJyhleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnLCBnb3QgJyArIGFjdHVhbCArICcpJyxcbiAgICAgIGV4cHIuc291cmNlKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gcHJvcGVydGllcyAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBkdXBsaWNhdGVQcm9wZXJ0eU5hbWVzKGR1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKCdPYmplY3QgcGF0dGVybiBoYXMgZHVwbGljYXRlIHByb3BlcnR5IG5hbWVzOiAnICsgZHVwbGljYXRlcy5qb2luKCcsICcpKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gY29uc3RydWN0b3JzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGludmFsaWRDb25zdHJ1Y3RvckNhbGwoZ3JhbW1hciwgY3Rvck5hbWUsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdBdHRlbXB0IHRvIGludm9rZSBjb25zdHJ1Y3RvciAnICsgY3Rvck5hbWUgKyAnIHdpdGggaW52YWxpZCBvciB1bmV4cGVjdGVkIGFyZ3VtZW50cycpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBjb252ZW5pZW5jZSAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBtdWx0aXBsZUVycm9ycyhlcnJvcnMpIHtcbiAgY29uc3QgbWVzc2FnZXMgPSBlcnJvcnMubWFwKGUgPT4gZS5tZXNzYWdlKTtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgWydFcnJvcnM6J10uY29uY2F0KG1lc3NhZ2VzKS5qb2luKCdcXG4tICcpLFxuICAgICAgZXJyb3JzWzBdLmludGVydmFsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gc2VtYW50aWMgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gbWlzc2luZ1NlbWFudGljQWN0aW9uKGN0b3JOYW1lLCBuYW1lLCB0eXBlLCBzdGFjaykge1xuICBsZXQgc3RhY2tUcmFjZSA9IHN0YWNrLnNsaWNlKDAsIC0xKS5tYXAoaW5mbyA9PiB7XG4gICAgY29uc3QgYW5zID0gJyAgJyArIGluZm9bMF0ubmFtZSArICcgPiAnICsgaW5mb1sxXTtcbiAgICByZXR1cm4gaW5mby5sZW5ndGggPT09IDNcbiAgICAgICAgPyBhbnMgKyBcIiBmb3IgJ1wiICsgaW5mb1syXSArIFwiJ1wiXG4gICAgICAgIDogYW5zO1xuICB9KS5qb2luKCdcXG4nKTtcbiAgc3RhY2tUcmFjZSArPSAnXFxuICAnICsgbmFtZSArICcgPiAnICsgY3Rvck5hbWU7XG5cbiAgY29uc3Qgd2hlcmUgPSB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICBjb25zdCBtZXNzYWdlID0gXCJNaXNzaW5nIHNlbWFudGljIGFjdGlvbiBmb3IgJ1wiICsgY3Rvck5hbWUgKyBcIicgaW4gXCIgKyB3aGVyZSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnQWN0aW9uIHN0YWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpOlxcbicgKyBzdGFja1RyYWNlO1xuXG4gIGNvbnN0IGUgPSBjcmVhdGVFcnJvcihtZXNzYWdlKTtcbiAgZS5uYW1lID0gJ21pc3NpbmdTZW1hbnRpY0FjdGlvbic7XG4gIHJldHVybiBlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFwcGxpY2F0aW9uT2ZTeW50YWN0aWNSdWxlRnJvbUxleGljYWxDb250ZXh0LFxuICBjYW5ub3RFeHRlbmRVbmRlY2xhcmVkUnVsZSxcbiAgY2Fubm90T3ZlcnJpZGVVbmRlY2xhcmVkUnVsZSxcbiAgZHVwbGljYXRlR3JhbW1hckRlY2xhcmF0aW9uLFxuICBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyxcbiAgZHVwbGljYXRlUHJvcGVydHlOYW1lcyxcbiAgZHVwbGljYXRlUnVsZURlY2xhcmF0aW9uLFxuICBpbmNvbnNpc3RlbnRBcml0eSxcbiAgaW5jb3JyZWN0QXJndW1lbnRUeXBlLFxuICBpbnRlcnZhbFNvdXJjZXNEb250TWF0Y2gsXG4gIGludmFsaWRDb25zdHJ1Y3RvckNhbGwsXG4gIGludmFsaWRQYXJhbWV0ZXIsXG4gIGdyYW1tYXJTeW50YXhFcnJvcixcbiAga2xlZW5lRXhwckhhc051bGxhYmxlT3BlcmFuZCxcbiAgbWlzc2luZ1NlbWFudGljQWN0aW9uLFxuICBtdWx0aXBsZVN1cGVyU3BsaWNlcyxcbiAgdW5kZWNsYXJlZEdyYW1tYXIsXG4gIHVuZGVjbGFyZWRSdWxlLFxuICB3cm9uZ051bWJlck9mQXJndW1lbnRzLFxuICB3cm9uZ051bWJlck9mUGFyYW1ldGVycyxcblxuICB0aHJvd0Vycm9ycyhlcnJvcnMpIHtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgIH1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG11bHRpcGxlRXJyb3JzKGVycm9ycyk7XG4gICAgfVxuICB9XG59O1xuIiwiLyogZ2xvYmFsIGRvY3VtZW50LCBYTUxIdHRwUmVxdWVzdCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBCdWlsZGVyID0gcmVxdWlyZSgnLi9CdWlsZGVyJyk7XG5jb25zdCBHcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyJyk7XG5jb25zdCBOYW1lc3BhY2UgPSByZXF1aXJlKCcuL05hbWVzcGFjZScpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5jb25zdCBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVGhlIG1ldGFncmFtbWFyLCBpLmUuIHRoZSBncmFtbWFyIGZvciBPaG0gZ3JhbW1hcnMuIEluaXRpYWxpemVkIGF0IHRoZVxuLy8gYm90dG9tIG9mIHRoaXMgZmlsZSBiZWNhdXNlIGxvYWRpbmcgdGhlIGdyYW1tYXIgcmVxdWlyZXMgT2htIGl0c2VsZi5cbmxldCBvaG1HcmFtbWFyO1xuXG4vLyBBbiBvYmplY3Qgd2hpY2ggbWFrZXMgaXQgcG9zc2libGUgdG8gc3R1YiBvdXQgdGhlIGRvY3VtZW50IEFQSSBmb3IgdGVzdGluZy5cbmxldCBkb2N1bWVudEludGVyZmFjZSA9IHtcbiAgcXVlcnlTZWxlY3RvcihzZWwpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbChzZWwpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKTsgfVxufTtcblxuY29uc3Qgc3VwZXJTcGxpY2VQbGFjZWhvbGRlciA9IE9iamVjdC5jcmVhdGUocGV4cHJzLlBFeHByLnByb3RvdHlwZSk7XG5cbi8vIENoZWNrIGlmIGBvYmpgIGlzIGEgRE9NIGVsZW1lbnQuXG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby12b2lkXG59XG5cbmNvbnN0IE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG59XG5cbi8vIFRPRE86IGp1c3QgdXNlIHRoZSBqUXVlcnkgdGhpbmdcbmZ1bmN0aW9uIGxvYWQodXJsKSB7XG4gIGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gIHRyeSB7XG4gICAgcmVxLnNlbmQoKTtcbiAgICBpZiAocmVxLnN0YXR1cyA9PT0gMCB8fCByZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJldHVybiByZXEucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cbiAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9hZCB1cmwgJyArIHVybCk7XG59XG5cbi8vIFJldHVybnMgYSBHcmFtbWFyIGluc3RhbmNlIChpLmUuLCBhbiBvYmplY3Qgd2l0aCBhIGBtYXRjaGAgbWV0aG9kKSBmb3Jcbi8vIGB0cmVlYCwgd2hpY2ggaXMgdGhlIGNvbmNyZXRlIHN5bnRheCB0cmVlIG9mIGEgdXNlci13cml0dGVuIGdyYW1tYXIuXG4vLyBUaGUgZ3JhbW1hciB3aWxsIGJlIGFzc2lnbmVkIGludG8gYG5hbWVzcGFjZWAgdW5kZXIgdGhlIG5hbWUgb2YgdGhlIGdyYW1tYXJcbi8vIGFzIHNwZWNpZmllZCBpbiB0aGUgc291cmNlLlxuZnVuY3Rpb24gYnVpbGRHcmFtbWFyKG1hdGNoLCBuYW1lc3BhY2UsIG9wdE9obUdyYW1tYXJGb3JUZXN0aW5nKSB7XG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICBsZXQgZGVjbDtcbiAgbGV0IGN1cnJlbnRSdWxlTmFtZTtcbiAgbGV0IGN1cnJlbnRSdWxlRm9ybWFscztcbiAgbGV0IG92ZXJyaWRpbmcgPSBmYWxzZTtcbiAgY29uc3QgbWV0YUdyYW1tYXIgPSBvcHRPaG1HcmFtbWFyRm9yVGVzdGluZyB8fCBvaG1HcmFtbWFyO1xuXG4gIC8vIEEgdmlzaXRvciB0aGF0IHByb2R1Y2VzIGEgR3JhbW1hciBpbnN0YW5jZSBmcm9tIHRoZSBDU1QuXG4gIGNvbnN0IGhlbHBlcnMgPSBtZXRhR3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKS5hZGRPcGVyYXRpb24oJ3Zpc2l0Jywge1xuICAgIEdyYW1tYXIobiwgcywgb3BlbiwgcnMsIGNsb3NlKSB7XG4gICAgICBjb25zdCBncmFtbWFyTmFtZSA9IG4udmlzaXQoKTtcbiAgICAgIGRlY2wgPSBidWlsZGVyLm5ld0dyYW1tYXIoZ3JhbW1hck5hbWUsIG5hbWVzcGFjZSk7XG4gICAgICBzLnZpc2l0KCk7XG4gICAgICBycy52aXNpdCgpO1xuICAgICAgY29uc3QgZyA9IGRlY2wuYnVpbGQoKTtcbiAgICAgIGcuc291cmNlID0gdGhpcy5zb3VyY2UudHJpbW1lZCgpO1xuICAgICAgaWYgKGdyYW1tYXJOYW1lIGluIG5hbWVzcGFjZSkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuZHVwbGljYXRlR3JhbW1hckRlY2xhcmF0aW9uKGcsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgICBuYW1lc3BhY2VbZ3JhbW1hck5hbWVdID0gZztcbiAgICAgIHJldHVybiBnO1xuICAgIH0sXG5cbiAgICBTdXBlckdyYW1tYXIoXywgbikge1xuICAgICAgY29uc3Qgc3VwZXJHcmFtbWFyTmFtZSA9IG4udmlzaXQoKTtcbiAgICAgIGlmIChzdXBlckdyYW1tYXJOYW1lID09PSAnbnVsbCcpIHtcbiAgICAgICAgZGVjbC53aXRoU3VwZXJHcmFtbWFyKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2UgfHwgIShzdXBlckdyYW1tYXJOYW1lIGluIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcnMudW5kZWNsYXJlZEdyYW1tYXIoc3VwZXJHcmFtbWFyTmFtZSwgbmFtZXNwYWNlLCBuLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjbC53aXRoU3VwZXJHcmFtbWFyKG5hbWVzcGFjZVtzdXBlckdyYW1tYXJOYW1lXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFJ1bGVfZGVmaW5lKG4sIGZzLCBkLCBfLCBiKSB7XG4gICAgICBjdXJyZW50UnVsZU5hbWUgPSBuLnZpc2l0KCk7XG4gICAgICBjdXJyZW50UnVsZUZvcm1hbHMgPSBmcy52aXNpdCgpWzBdIHx8IFtdO1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGVmYXVsdCBzdGFydCBydWxlIHlldCwgc2V0IGl0IG5vdy4gVGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHZpc2l0aW5nXG4gICAgICAvLyB0aGUgYm9keSwgYmVjYXVzZSBpdCBtaWdodCBjb250YWluIGFuIGlubGluZSBydWxlIGRlZmluaXRpb24uXG4gICAgICBpZiAoIWRlY2wuZGVmYXVsdFN0YXJ0UnVsZSAmJiBkZWNsLmVuc3VyZVN1cGVyR3JhbW1hcigpICE9PSBHcmFtbWFyLlByb3RvQnVpbHRJblJ1bGVzKSB7XG4gICAgICAgIGRlY2wud2l0aERlZmF1bHRTdGFydFJ1bGUoY3VycmVudFJ1bGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBiLnZpc2l0KCk7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGQudmlzaXQoKVswXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLnRyaW1tZWQoKTtcbiAgICAgIHJldHVybiBkZWNsLmRlZmluZShjdXJyZW50UnVsZU5hbWUsIGN1cnJlbnRSdWxlRm9ybWFscywgYm9keSwgZGVzY3JpcHRpb24sIHNvdXJjZSk7XG4gICAgfSxcbiAgICBSdWxlX292ZXJyaWRlKG4sIGZzLCBfLCBiKSB7XG4gICAgICBjdXJyZW50UnVsZU5hbWUgPSBuLnZpc2l0KCk7XG4gICAgICBjdXJyZW50UnVsZUZvcm1hbHMgPSBmcy52aXNpdCgpWzBdIHx8IFtdO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICBkZWNsLmVuc3VyZVN1cGVyR3JhbW1hclJ1bGVGb3JPdmVycmlkaW5nKGN1cnJlbnRSdWxlTmFtZSwgc291cmNlKTtcblxuICAgICAgb3ZlcnJpZGluZyA9IHRydWU7XG4gICAgICBjb25zdCBib2R5ID0gYi52aXNpdCgpO1xuICAgICAgb3ZlcnJpZGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGRlY2wub3ZlcnJpZGUoY3VycmVudFJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIG51bGwsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBSdWxlX2V4dGVuZChuLCBmcywgXywgYikge1xuICAgICAgY3VycmVudFJ1bGVOYW1lID0gbi52aXNpdCgpO1xuICAgICAgY3VycmVudFJ1bGVGb3JtYWxzID0gZnMudmlzaXQoKVswXSB8fCBbXTtcbiAgICAgIGNvbnN0IGJvZHkgPSBiLnZpc2l0KCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICByZXR1cm4gZGVjbC5leHRlbmQoY3VycmVudFJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIG51bGwsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBSdWxlQm9keShfLCB0ZXJtcykge1xuICAgICAgY29uc3QgYXJncyA9IHRlcm1zLnZpc2l0KCk7XG4gICAgICByZXR1cm4gYnVpbGRlci5hbHQuYXBwbHkoYnVpbGRlciwgYXJncykud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBPdmVycmlkZVJ1bGVCb2R5KF8sIHRlcm1zKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGVybXMudmlzaXQoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN1cGVyLXNwbGljZSBvcGVyYXRvciAoYC4uLmApIGFwcGVhcnMgaW4gdGhlIHRlcm1zLlxuICAgICAgY29uc3QgZXhwYW5zaW9uUG9zID0gYXJncy5pbmRleE9mKHN1cGVyU3BsaWNlUGxhY2Vob2xkZXIpO1xuICAgICAgaWYgKGV4cGFuc2lvblBvcyA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGJlZm9yZVRlcm1zID0gYXJncy5zbGljZSgwLCBleHBhbnNpb25Qb3MpO1xuICAgICAgICBjb25zdCBhZnRlclRlcm1zID0gYXJncy5zbGljZShleHBhbnNpb25Qb3MgKyAxKTtcblxuICAgICAgICAvLyBFbnN1cmUgaXQgYXBwZWFycyBubyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgYWZ0ZXJUZXJtcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGlmICh0ID09PSBzdXBlclNwbGljZVBsYWNlaG9sZGVyKSB0aHJvdyBlcnJvcnMubXVsdGlwbGVTdXBlclNwbGljZXModCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgcGV4cHJzLlNwbGljZShcbiAgICAgICAgICAgIGRlY2wuc3VwZXJHcmFtbWFyLCBjdXJyZW50UnVsZU5hbWUsIGJlZm9yZVRlcm1zLCBhZnRlclRlcm1zKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmFsdC5hcHBseShidWlsZGVyLCBhcmdzKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEZvcm1hbHMob3BvaW50eSwgZnMsIGNwb2ludHkpIHtcbiAgICAgIHJldHVybiBmcy52aXNpdCgpO1xuICAgIH0sXG5cbiAgICBQYXJhbXMob3BvaW50eSwgcHMsIGNwb2ludHkpIHtcbiAgICAgIHJldHVybiBwcy52aXNpdCgpO1xuICAgIH0sXG5cbiAgICBBbHQoc2Vxcykge1xuICAgICAgY29uc3QgYXJncyA9IHNlcXMudmlzaXQoKTtcbiAgICAgIHJldHVybiBidWlsZGVyLmFsdC5hcHBseShidWlsZGVyLCBhcmdzKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuXG4gICAgVG9wTGV2ZWxUZXJtX2lubGluZShiLCBuKSB7XG4gICAgICBjb25zdCBpbmxpbmVSdWxlTmFtZSA9IGN1cnJlbnRSdWxlTmFtZSArICdfJyArIG4udmlzaXQoKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBiLnZpc2l0KCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICBjb25zdCBpc05ld1J1bGVEZWNsYXJhdGlvbiA9XG4gICAgICAgICAgIShkZWNsLnN1cGVyR3JhbW1hciAmJiBkZWNsLnN1cGVyR3JhbW1hci5ydWxlc1tpbmxpbmVSdWxlTmFtZV0pO1xuICAgICAgaWYgKG92ZXJyaWRpbmcgJiYgIWlzTmV3UnVsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgIGRlY2wub3ZlcnJpZGUoaW5saW5lUnVsZU5hbWUsIGN1cnJlbnRSdWxlRm9ybWFscywgYm9keSwgbnVsbCwgc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuZGVmaW5lKGlubGluZVJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIG51bGwsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJhbXMgPSBjdXJyZW50UnVsZUZvcm1hbHMubWFwKGZvcm1hbCA9PiBidWlsZGVyLmFwcChmb3JtYWwpKTtcbiAgICAgIHJldHVybiBidWlsZGVyLmFwcChpbmxpbmVSdWxlTmFtZSwgcGFyYW1zKS53aXRoU291cmNlKGJvZHkuc291cmNlKTtcbiAgICB9LFxuICAgIE92ZXJyaWRlVG9wTGV2ZWxUZXJtX3N1cGVyU3BsaWNlKF8pIHtcbiAgICAgIHJldHVybiBzdXBlclNwbGljZVBsYWNlaG9sZGVyO1xuICAgIH0sXG5cbiAgICBTZXEoZXhwcikge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuc2VxLmFwcGx5KGJ1aWxkZXIsIGV4cHIudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIEl0ZXJfc3Rhcih4LCBfKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5zdGFyKHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBJdGVyX3BsdXMoeCwgXykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIucGx1cyh4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgSXRlcl9vcHQoeCwgXykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIub3B0KHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIFByZWRfbm90KF8sIHgpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLm5vdCh4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgUHJlZF9sb29rYWhlYWQoXywgeCkge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIubG9va2FoZWFkKHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIExleF9sZXgoXywgeCkge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIubGV4KHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIEJhc2VfYXBwbGljYXRpb24ocnVsZSwgcHMpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLmFwcChydWxlLnZpc2l0KCksIHBzLnZpc2l0KClbMF0gfHwgW10pLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgQmFzZV9yYW5nZShmcm9tLCBfLCB0bykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIucmFuZ2UoZnJvbS52aXNpdCgpLCB0by52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIEJhc2VfdGVybWluYWwoZXhwcikge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIudGVybWluYWwoZXhwci52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIEJhc2VfcGFyZW4ob3BlbiwgeCwgY2xvc2UpIHtcbiAgICAgIHJldHVybiB4LnZpc2l0KCk7XG4gICAgfSxcblxuICAgIHJ1bGVEZXNjcihvcGVuLCB0LCBjbG9zZSkge1xuICAgICAgcmV0dXJuIHQudmlzaXQoKTtcbiAgICB9LFxuICAgIHJ1bGVEZXNjclRleHQoXykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3RyaW5nLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgY2FzZU5hbWUoXywgc3BhY2UxLCBuLCBzcGFjZTIsIGVuZCkge1xuICAgICAgcmV0dXJuIG4udmlzaXQoKTtcbiAgICB9LFxuXG4gICAgbmFtZShmaXJzdCwgcmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3RyaW5nO1xuICAgIH0sXG4gICAgbmFtZUZpcnN0KGV4cHIpIHt9LFxuICAgIG5hbWVSZXN0KGV4cHIpIHt9LFxuXG4gICAgdGVybWluYWwob3BlbiwgY3MsIGNsb3NlKSB7XG4gICAgICByZXR1cm4gY3MudmlzaXQoKS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgb25lQ2hhclRlcm1pbmFsKG9wZW4sIGMsIGNsb3NlKSB7XG4gICAgICByZXR1cm4gYy52aXNpdCgpO1xuICAgIH0sXG5cbiAgICB0ZXJtaW5hbENoYXIoXykge1xuICAgICAgcmV0dXJuIGNvbW1vbi51bmVzY2FwZUNoYXIodGhpcy5zb3VyY2VTdHJpbmcpO1xuICAgIH0sXG5cbiAgICBlc2NhcGVDaGFyKF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVN0cmluZztcbiAgICB9LFxuXG4gICAgTm9uZW1wdHlMaXN0T2YoeCwgXywgeHMpIHtcbiAgICAgIHJldHVybiBbeC52aXNpdCgpXS5jb25jYXQoeHMudmlzaXQoKSk7XG4gICAgfSxcbiAgICBFbXB0eUxpc3RPZigpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgX3Rlcm1pbmFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhlbHBlcnMobWF0Y2gpLnZpc2l0KCk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVBbmRMb2FkKHNvdXJjZSwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IG0gPSBvaG1HcmFtbWFyLm1hdGNoKHNvdXJjZSwgJ0dyYW1tYXJzJyk7XG4gIGlmIChtLmZhaWxlZCgpKSB7XG4gICAgdGhyb3cgZXJyb3JzLmdyYW1tYXJTeW50YXhFcnJvcihtKTtcbiAgfVxuICByZXR1cm4gYnVpbGRHcmFtbWFyKG0sIG5hbWVzcGFjZSk7XG59XG5cbi8vIFJldHVybiB0aGUgY29udGVudHMgb2YgYSBzY3JpcHQgZWxlbWVudCwgZmV0Y2hpbmcgaXQgdmlhIFhIUiBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiBnZXRTY3JpcHRFbGVtZW50Q29udGVudHMoZWwpIHtcbiAgaWYgKCFpc0VsZW1lbnQoZWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBET00gTm9kZSwgZ290ICcgKyBjb21tb24udW5leHBlY3RlZE9ialRvU3RyaW5nKGVsKSk7XG4gIH1cbiAgaWYgKGVsLnR5cGUgIT09ICd0ZXh0L29obS1qcycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc2NyaXB0IHRhZyB3aXRoIHR5cGU9XCJ0ZXh0L29obS1qc1wiLCBnb3QgJyArIGVsKTtcbiAgfVxuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdzcmMnKSA/IGxvYWQoZWwuZ2V0QXR0cmlidXRlKCdzcmMnKSkgOiBlbC5pbm5lckhUTUw7XG59XG5cbmZ1bmN0aW9uIGdyYW1tYXIoc291cmNlLCBvcHROYW1lc3BhY2UpIHtcbiAgY29uc3QgbnMgPSBncmFtbWFycyhzb3VyY2UsIG9wdE5hbWVzcGFjZSk7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHNvdXJjZSBjb250YWluZWQgbm8gbW9yZSB0aGFuIG9uZSBncmFtbWFyIGRlZmluaXRpb24uXG4gIGNvbnN0IGdyYW1tYXJOYW1lcyA9IE9iamVjdC5rZXlzKG5zKTtcbiAgaWYgKGdyYW1tYXJOYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ3JhbW1hciBkZWZpbml0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZ3JhbW1hck5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzZWNvbmRHcmFtbWFyID0gbnNbZ3JhbW1hck5hbWVzWzFdXTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNlY29uZEdyYW1tYXIuc291cmNlO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgdXRpbC5nZXRMaW5lQW5kQ29sdW1uTWVzc2FnZShpbnRlcnZhbC5zb3VyY2VTdHJpbmcsIGludGVydmFsLnN0YXJ0SWR4KSArXG4gICAgICAgICdGb3VuZCBtb3JlIHRoYW4gb25lIGdyYW1tYXIgZGVmaW5pdGlvbiAtLSB1c2Ugb2htLmdyYW1tYXJzKCkgaW5zdGVhZC4nKTtcbiAgfVxuICByZXR1cm4gbnNbZ3JhbW1hck5hbWVzWzBdXTsgLy8gUmV0dXJuIHRoZSBvbmUgYW5kIG9ubHkgZ3JhbW1hci5cbn1cblxuZnVuY3Rpb24gZ3JhbW1hcnMoc291cmNlLCBvcHROYW1lc3BhY2UpIHtcbiAgY29uc3QgbnMgPSBOYW1lc3BhY2UuZXh0ZW5kKE5hbWVzcGFjZS5hc05hbWVzcGFjZShvcHROYW1lc3BhY2UpKTtcbiAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRm9yIGNvbnZlbmllbmNlLCBkZXRlY3QgTm9kZS5qcyBCdWZmZXIgb2JqZWN0cyBhbmQgYXV0b21hdGljYWxseSBjYWxsIHRvU3RyaW5nKCkuXG4gICAgaWYgKGlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCBzdHJpbmcgYXMgZmlyc3QgYXJndW1lbnQsIGdvdCAnICsgY29tbW9uLnVuZXhwZWN0ZWRPYmpUb1N0cmluZyhzb3VyY2UpKTtcbiAgICB9XG4gIH1cbiAgY29tcGlsZUFuZExvYWQoc291cmNlLCBucyk7XG4gIHJldHVybiBucztcbn1cblxuZnVuY3Rpb24gZ3JhbW1hckZyb21TY3JpcHRFbGVtZW50KG9wdE5vZGUpIHtcbiAgbGV0IG5vZGUgPSBvcHROb2RlO1xuICBpZiAoaXNVbmRlZmluZWQobm9kZSkpIHtcbiAgICBjb25zdCBub2RlTGlzdCA9IGRvY3VtZW50SW50ZXJmYWNlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFt0eXBlPVwidGV4dC9vaG0tanNcIl0nKTtcbiAgICBpZiAobm9kZUxpc3QubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGV4YWN0bHkgb25lIHNjcmlwdCB0YWcgd2l0aCB0eXBlPVwidGV4dC9vaG0tanNcIiwgZm91bmQgJyArIG5vZGVMaXN0Lmxlbmd0aCk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlTGlzdFswXTtcbiAgfVxuICByZXR1cm4gZ3JhbW1hcihnZXRTY3JpcHRFbGVtZW50Q29udGVudHMobm9kZSkpO1xufVxuXG5mdW5jdGlvbiBncmFtbWFyc0Zyb21TY3JpcHRFbGVtZW50cyhvcHROb2RlT3JOb2RlTGlzdCkge1xuICAvLyBTaW1wbGUgY2FzZTogdGhlIGFyZ3VtZW50IGlzIGEgRE9NIG5vZGUuXG4gIGlmIChpc0VsZW1lbnQob3B0Tm9kZU9yTm9kZUxpc3QpKSB7XG4gICAgcmV0dXJuIGdyYW1tYXJzKG9wdE5vZGVPck5vZGVMaXN0KTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGl0IG11c3QgYmUgZWl0aGVyIHVuZGVmaW5lZCBvciBhIE5vZGVMaXN0LlxuICBsZXQgbm9kZUxpc3QgPSBvcHROb2RlT3JOb2RlTGlzdDtcbiAgaWYgKGlzVW5kZWZpbmVkKG5vZGVMaXN0KSkge1xuICAgIC8vIEZpbmQgYWxsIHNjcmlwdCBlbGVtZW50cyB3aXRoIHR5cGU9XCJ0ZXh0L29obS1qc1wiLlxuICAgIG5vZGVMaXN0ID0gZG9jdW1lbnRJbnRlcmZhY2UucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W3R5cGU9XCJ0ZXh0L29obS1qc1wiXScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlTGlzdCA9PT0gJ3N0cmluZycgfHwgKCFpc0VsZW1lbnQobm9kZUxpc3QpICYmICFpc0FycmF5TGlrZShub2RlTGlzdCkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBOb2RlLCBOb2RlTGlzdCwgb3IgQXJyYXksIGJ1dCBnb3QgJyArIG5vZGVMaXN0KTtcbiAgfVxuICBjb25zdCBucyA9IE5hbWVzcGFjZS5jcmVhdGVOYW1lc3BhY2UoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIC8vIENvcHkgdGhlIG5ldyBncmFtbWFycyBpbnRvIGBuc2AgdG8ga2VlcCB0aGUgbmFtZXNwYWNlIGZsYXQuXG4gICAgY29tbW9uLmV4dGVuZChucywgZ3JhbW1hcnMoZ2V0U2NyaXB0RWxlbWVudENvbnRlbnRzKG5vZGVMaXN0W2ldKSwgbnMpKTtcbiAgfVxuICByZXR1cm4gbnM7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZWNpcGUocmVjaXBlKSB7XG4gIGlmICh0eXBlb2YgcmVjaXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlY2lwZS5jYWxsKG5ldyBCdWlsZGVyKCkpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgcmVjaXBlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gc3RyaW5naWZpZWQgSlNPTiByZWNpcGVcbiAgICAgIHJlY2lwZSA9IEpTT04ucGFyc2UocmVjaXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZXcgQnVpbGRlcigpKS5mcm9tUmVjaXBlKHJlY2lwZSk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFN0dWZmIHRoYXQgdXNlcnMgc2hvdWxkIGtub3cgYWJvdXRcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVOYW1lc3BhY2U6IE5hbWVzcGFjZS5jcmVhdGVOYW1lc3BhY2UsXG4gIGdyYW1tYXIsXG4gIGdyYW1tYXJzLFxuICBncmFtbWFyRnJvbVNjcmlwdEVsZW1lbnQsXG4gIGdyYW1tYXJzRnJvbVNjcmlwdEVsZW1lbnRzLFxuICBtYWtlUmVjaXBlLFxuICBvaG1HcmFtbWFyOiBudWxsLCAvLyBJbml0aWFsaXplZCBiZWxvdywgYWZ0ZXIgR3JhbW1hci5CdWlsdEluUnVsZXMuXG4gIHBleHBycyxcbiAgdXRpbCxcbiAgZXh0cmFzOiByZXF1aXJlKCcuLi9leHRyYXMnKSxcbiAgdmVyc2lvblxufTtcblxuLy8gU3R1ZmYgZm9yIHRlc3RpbmcsIGV0Yy5cbm1vZHVsZS5leHBvcnRzLl9idWlsZEdyYW1tYXIgPSBidWlsZEdyYW1tYXI7XG5tb2R1bGUuZXhwb3J0cy5fc2V0RG9jdW1lbnRJbnRlcmZhY2VGb3JUZXN0aW5nID0gZnVuY3Rpb24oZG9jKSB7IGRvY3VtZW50SW50ZXJmYWNlID0gZG9jOyB9O1xuXG4vLyBMYXRlIGluaXRpYWxpemF0aW9uIGZvciBzdHVmZiB0aGF0IGlzIGJvb3RzdHJhcHBlZC5cblxuR3JhbW1hci5CdWlsdEluUnVsZXMgPSByZXF1aXJlKCcuLi9kaXN0L2J1aWx0LWluLXJ1bGVzJyk7XG51dGlsLmFubm91bmNlQnVpbHRJblJ1bGVzKEdyYW1tYXIuQnVpbHRJblJ1bGVzKTtcblxubW9kdWxlLmV4cG9ydHMub2htR3JhbW1hciA9IG9obUdyYW1tYXIgPSByZXF1aXJlKCcuLi9kaXN0L29obS1ncmFtbWFyJyk7XG5HcmFtbWFyLmluaXRBcHBsaWNhdGlvblBhcnNlcihvaG1HcmFtbWFyLCBidWlsZEdyYW1tYXIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY2xhc3MgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYW1tYXIsIGN0b3JOYW1lLCBtYXRjaExlbmd0aCkge1xuICAgIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG4gICAgdGhpcy5jdG9yTmFtZSA9IGN0b3JOYW1lO1xuICAgIHRoaXMubWF0Y2hMZW5ndGggPSBtYXRjaExlbmd0aDtcbiAgfVxuXG4gIG51bUNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlbi5sZW5ndGggOiAwO1xuICB9XG5cbiAgY2hpbGRBdChpZHgpIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baWR4XTtcbiAgICB9XG4gIH1cblxuICBpbmRleE9mQ2hpbGQoYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uaW5kZXhPZihhcmcpO1xuICB9XG5cbiAgaGFzQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtQ2hpbGRyZW4oKSA+IDE7XG4gIH1cblxuICBoYXNOb0NoaWxkcmVuKCkge1xuICAgIHJldHVybiAhdGhpcy5oYXNDaGlsZHJlbigpO1xuICB9XG5cbiAgb25seUNoaWxkKCkge1xuICAgIGlmICh0aGlzLm51bUNoaWxkcmVuKCkgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IGdldCBvbmx5IGNoaWxkIG9mIGEgbm9kZSBvZiB0eXBlICcgKyB0aGlzLmN0b3JOYW1lICtcbiAgICAgICAgICAnIChpdCBoYXMgJyArIHRoaXMubnVtQ2hpbGRyZW4oKSArICcgY2hpbGRyZW4pJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpcnN0Q2hpbGQoKTtcbiAgICB9XG4gIH1cblxuICBmaXJzdENoaWxkKCkge1xuICAgIGlmICh0aGlzLmhhc05vQ2hpbGRyZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdjYW5ub3QgZ2V0IGZpcnN0IGNoaWxkIG9mIGEgJyArIHRoaXMuY3Rvck5hbWUgKyAnIG5vZGUsIHdoaWNoIGhhcyBubyBjaGlsZHJlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZEF0KDApO1xuICAgIH1cbiAgfVxuXG4gIGxhc3RDaGlsZCgpIHtcbiAgICBpZiAodGhpcy5oYXNOb0NoaWxkcmVuKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IGdldCBsYXN0IGNoaWxkIG9mIGEgJyArIHRoaXMuY3Rvck5hbWUgKyAnIG5vZGUsIHdoaWNoIGhhcyBubyBjaGlsZHJlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZEF0KHRoaXMubnVtQ2hpbGRyZW4oKSAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIGNoaWxkQmVmb3JlKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRJZHggPSB0aGlzLmluZGV4T2ZDaGlsZChjaGlsZCk7XG4gICAgaWYgKGNoaWxkSWR4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlLmNoaWxkQmVmb3JlKCkgY2FsbGVkIHcvIGFuIGFyZ3VtZW50IHRoYXQgaXMgbm90IGEgY2hpbGQnKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkSWR4ID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgY2hpbGQgYmVmb3JlIGZpcnN0IGNoaWxkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoY2hpbGRJZHggLSAxKTtcbiAgICB9XG4gIH1cblxuICBjaGlsZEFmdGVyKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRJZHggPSB0aGlzLmluZGV4T2ZDaGlsZChjaGlsZCk7XG4gICAgaWYgKGNoaWxkSWR4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlLmNoaWxkQWZ0ZXIoKSBjYWxsZWQgdy8gYW4gYXJndW1lbnQgdGhhdCBpcyBub3QgYSBjaGlsZCcpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRJZHggPT09IHRoaXMubnVtQ2hpbGRyZW4oKSAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBjaGlsZCBhZnRlciBsYXN0IGNoaWxkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoY2hpbGRJZHggKyAxKTtcbiAgICB9XG4gIH1cblxuICBpc1Rlcm1pbmFsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzTm9udGVybWluYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtbdGhpcy5jdG9yTmFtZV06IHRoaXMuY2hpbGRyZW59O1xuICB9XG59XG5cbi8vIFRlcm1pbmFsc1xuXG5jbGFzcyBUZXJtaW5hbE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZ3JhbW1hciwgdmFsdWUpIHtcbiAgICBjb25zdCBtYXRjaExlbmd0aCA9IHZhbHVlID8gdmFsdWUubGVuZ3RoIDogMDtcbiAgICBzdXBlcihncmFtbWFyLCAnX3Rlcm1pbmFsJywgbWF0Y2hMZW5ndGgpO1xuICAgIHRoaXMucHJpbWl0aXZlVmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGlzVGVybWluYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtbdGhpcy5jdG9yTmFtZV06IHRoaXMucHJpbWl0aXZlVmFsdWV9O1xuICB9XG59XG5cbi8vIE5vbnRlcm1pbmFsc1xuXG5jbGFzcyBOb250ZXJtaW5hbE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZ3JhbW1hciwgcnVsZU5hbWUsIGNoaWxkcmVuLCBjaGlsZE9mZnNldHMsIG1hdGNoTGVuZ3RoKSB7XG4gICAgc3VwZXIoZ3JhbW1hciwgcnVsZU5hbWUsIG1hdGNoTGVuZ3RoKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5jaGlsZE9mZnNldHMgPSBjaGlsZE9mZnNldHM7XG4gIH1cblxuICBpc05vbnRlcm1pbmFsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNMZXhpY2FsKCkge1xuICAgIHJldHVybiBjb21tb24uaXNMZXhpY2FsKHRoaXMuY3Rvck5hbWUpO1xuICB9XG5cbiAgaXNTeW50YWN0aWMoKSB7XG4gICAgcmV0dXJuIGNvbW1vbi5pc1N5bnRhY3RpYyh0aGlzLmN0b3JOYW1lKTtcbiAgfVxufVxuXG4vLyBJdGVyYXRpb25zXG5cbmNsYXNzIEl0ZXJhdGlvbk5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZ3JhbW1hciwgY2hpbGRyZW4sIGNoaWxkT2Zmc2V0cywgbWF0Y2hMZW5ndGgsIGlzT3B0aW9uYWwpIHtcbiAgICBzdXBlcihncmFtbWFyLCAnX2l0ZXInLCBtYXRjaExlbmd0aCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2hpbGRPZmZzZXRzID0gY2hpbGRPZmZzZXRzO1xuICAgIHRoaXMub3B0aW9uYWwgPSBpc09wdGlvbmFsO1xuICB9XG5cbiAgaXNJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc09wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTm9kZSxcbiAgVGVybWluYWxOb2RlLFxuICBOb250ZXJtaW5hbE5vZGUsXG4gIEl0ZXJhdGlvbk5vZGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIFJldHVybiB0cnVlIGlmIHdlIHNob3VsZCBza2lwIHNwYWNlcyBwcmVjZWRpbmcgdGhpcyBleHByZXNzaW9uIGluIGEgc3ludGFjdGljIGNvbnRleHQuXG4qL1xucGV4cHJzLlBFeHByLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID0gY29tbW9uLmFic3RyYWN0KFxuICAgICdhbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlJ1xuKTtcblxuLypcbiAgR2VuZXJhbGx5LCB0aGVzZSBhcmUgYWxsIGZpcnN0LW9yZGVyIGV4cHJlc3Npb25zIGFuZCAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIEFwcGx5KVxuICBkaXJlY3RseSByZWFkIGZyb20gdGhlIGlucHV0IHN0cmVhbS5cbiovXG5wZXhwcnMuYW55LmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLmVuZC5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5BcHBseS5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qXG4gIEhpZ2hlci1vcmRlciBleHByZXNzaW9ucyB0aGF0IGRvbid0IGRpcmVjdGx5IGNvbnN1bWUgaW5wdXQuXG4qL1xucGV4cHJzLkFsdC5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuSXRlci5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLlNlcS5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgQnVpbHRJblJ1bGVzO1xuXG51dGlsLmF3YWl0QnVpbHRJblJ1bGVzKGcgPT4geyBCdWlsdEluUnVsZXMgPSBnOyB9KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBsZXhpZnlDb3VudDtcblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGxleGlmeUNvdW50ID0gMDtcbiAgdGhpcy5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xufTtcblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBjb21tb24uYWJzdHJhY3QoXG4gICAgJ19hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCdcbik7XG5cbnBleHBycy5hbnkuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5lbmQuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgLy8gbm8tb3Bcbn07XG5cbnBleHBycy5MZXgucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGxleGlmeUNvdW50Kys7XG4gIHRoaXMuZXhwci5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xuICBsZXhpZnlDb3VudC0tO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy50ZXJtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy50ZXJtc1tpZHhdLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG4gIH1cbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuZmFjdG9ycy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy5mYWN0b3JzW2lkeF0uX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbiAgfVxufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgdGhpcy5leHByLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGNvbnN0IHJ1bGVJbmZvID0gZ3JhbW1hci5ydWxlc1t0aGlzLnJ1bGVOYW1lXTtcblxuICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcnVsZSBleGlzdHMuLi5cbiAgaWYgKCFydWxlSW5mbykge1xuICAgIHRocm93IGVycm9ycy51bmRlY2xhcmVkUnVsZSh0aGlzLnJ1bGVOYW1lLCBncmFtbWFyLm5hbWUsIHRoaXMuc291cmNlKTtcbiAgfVxuXG4gIC8vIC4uLmFuZCB0aGF0IHRoaXMgYXBwbGljYXRpb24gaXMgYWxsb3dlZFxuICBpZiAoY29tbW9uLmlzU3ludGFjdGljKHRoaXMucnVsZU5hbWUpICYmICghY29tbW9uLmlzU3ludGFjdGljKHJ1bGVOYW1lKSB8fCBsZXhpZnlDb3VudCA+IDApKSB7XG4gICAgdGhyb3cgZXJyb3JzLmFwcGxpY2F0aW9uT2ZTeW50YWN0aWNSdWxlRnJvbUxleGljYWxDb250ZXh0KHRoaXMucnVsZU5hbWUsIHRoaXMpO1xuICB9XG5cbiAgLy8gLi4uYW5kIHRoYXQgdGhpcyBhcHBsaWNhdGlvbiBoYXMgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICBjb25zdCBhY3R1YWwgPSB0aGlzLmFyZ3MubGVuZ3RoO1xuICBjb25zdCBleHBlY3RlZCA9IHJ1bGVJbmZvLmZvcm1hbHMubGVuZ3RoO1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIHRocm93IGVycm9ycy53cm9uZ051bWJlck9mQXJndW1lbnRzKHRoaXMucnVsZU5hbWUsIGV4cGVjdGVkLCBhY3R1YWwsIHRoaXMuc291cmNlKTtcbiAgfVxuXG4gIC8vIC4uLmFuZCB0aGF0IGFsbCBvZiB0aGUgYXJndW1lbnQgZXhwcmVzc2lvbnMgb25seSBoYXZlIHZhbGlkIGFwcGxpY2F0aW9ucyBhbmQgaGF2ZSBhcml0eSAxLlxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5hcmdzLmZvckVhY2goYXJnID0+IHtcbiAgICBhcmcuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbiAgICBpZiAoYXJnLmdldEFyaXR5KCkgIT09IDEpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbnZhbGlkUGFyYW1ldGVyKHNlbGYucnVsZU5hbWUsIGFyZyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBFeHRyYSBjaGVja3MgZm9yIFwic3BlY2lhbFwiIGFwcGxpY2F0aW9uc1xuXG4gIC8vIElmIGl0J3MgYW4gYXBwbGljYXRpb24gb2YgJ2Nhc2VJbnNlbnNpdGl2ZScsIGVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhIFRlcm1pbmFsLlxuICBpZiAoQnVpbHRJblJ1bGVzICYmIHJ1bGVJbmZvID09PSBCdWlsdEluUnVsZXMucnVsZXMuY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgaWYgKCEodGhpcy5hcmdzWzBdIGluc3RhbmNlb2YgcGV4cHJzLlRlcm1pbmFsKSkge1xuICAgICAgdGhyb3cgZXJyb3JzLmluY29ycmVjdEFyZ3VtZW50VHlwZSgnYSBUZXJtaW5hbCAoZS5nLiBcXFwiYWJjXFxcIiknLCB0aGlzLmFyZ3NbMF0pO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBjb21tb24uYWJzdHJhY3QoXG4gICAgJ2Fzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5J1xuKTtcblxucGV4cHJzLmFueS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuZW5kLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5MZXgucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICAvLyBuby1vcFxufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICBpZiAodGhpcy50ZXJtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYXJpdHkgPSB0aGlzLnRlcm1zWzBdLmdldEFyaXR5KCk7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMudGVybXMubGVuZ3RoOyBpZHgrKykge1xuICAgIGNvbnN0IHRlcm0gPSB0aGlzLnRlcm1zW2lkeF07XG4gICAgdGVybS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSgpO1xuICAgIGNvbnN0IG90aGVyQXJpdHkgPSB0ZXJtLmdldEFyaXR5KCk7XG4gICAgaWYgKGFyaXR5ICE9PSBvdGhlckFyaXR5KSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW5jb25zaXN0ZW50QXJpdHkocnVsZU5hbWUsIGFyaXR5LCBvdGhlckFyaXR5LCB0ZXJtKTtcbiAgICB9XG4gIH1cbn07XG5cbnBleHBycy5FeHRlbmQucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgLy8gRXh0ZW5kIGlzIGEgc3BlY2lhbCBjYXNlIG9mIEFsdCB0aGF0J3MgZ3VhcmFudGVlZCB0byBoYXZlIGV4YWN0bHkgdHdvXG4gIC8vIGNhc2VzOiBbZXh0ZW5zaW9ucywgb3JpZ0JvZHldLlxuICBjb25zdCBhY3R1YWxBcml0eSA9IHRoaXMudGVybXNbMF0uZ2V0QXJpdHkoKTtcbiAgY29uc3QgZXhwZWN0ZWRBcml0eSA9IHRoaXMudGVybXNbMV0uZ2V0QXJpdHkoKTtcbiAgaWYgKGFjdHVhbEFyaXR5ICE9PSBleHBlY3RlZEFyaXR5KSB7XG4gICAgdGhyb3cgZXJyb3JzLmluY29uc2lzdGVudEFyaXR5KHJ1bGVOYW1lLCBleHBlY3RlZEFyaXR5LCBhY3R1YWxBcml0eSwgdGhpcy50ZXJtc1swXSk7XG4gIH1cbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLmZhY3RvcnNbaWR4XS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eShydWxlTmFtZSk7XG4gIH1cbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIHRoaXMuZXhwci5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eShydWxlTmFtZSk7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIC8vIG5vLW9wIChub3QgcmVxdWlyZWQgYi9jIHRoZSBuZXN0ZWQgZXhwciBkb2Vzbid0IHNob3cgdXAgaW4gdGhlIENTVClcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgdGhpcy5leHByLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5KHJ1bGVOYW1lKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICAvLyBUaGUgYXJpdGllcyBvZiB0aGUgcGFyYW1ldGVyIGV4cHJlc3Npb25zIGlzIHJlcXVpcmVkIHRvIGJlIDEgYnlcbiAgLy8gYGFzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKClgLlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gY29tbW9uLmFic3RyYWN0KFxuICAgICdhc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUnXG4pO1xuXG5wZXhwcnMuYW55LmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuZW5kLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgLy8gbm8tb3Bcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy50ZXJtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy50ZXJtc1tpZHhdLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbiAgfVxufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXMuZmFjdG9yc1tpZHhdLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbiAgfVxufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgLy8gTm90ZTogdGhpcyBpcyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZm9yIGBTdGFyYCBhbmQgYFBsdXNgIGV4cHJlc3Npb25zLlxuICAvLyBJdCBpcyBvdmVycmlkZGVuIGZvciBgT3B0YCBiZWxvdy5cbiAgdGhpcy5leHByLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbiAgaWYgKHRoaXMuZXhwci5pc051bGxhYmxlKGdyYW1tYXIpKSB7XG4gICAgdGhyb3cgZXJyb3JzLmtsZWVuZUV4cHJIYXNOdWxsYWJsZU9wZXJhbmQodGhpcywgW10pO1xuICB9XG59O1xuXG5wZXhwcnMuT3B0LnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHRoaXMuZXhwci5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUoZ3JhbW1hcik7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgdGhpcy5hcmdzLmZvckVhY2goYXJnID0+IHtcbiAgICBhcmcuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlKGdyYW1tYXIpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3Qgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5jaGVjayA9IGNvbW1vbi5hYnN0cmFjdCgnY2hlY2snKTtcblxucGV4cHJzLmFueS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHMubGVuZ3RoID49IDE7XG59O1xuXG5wZXhwcnMuZW5kLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgIHZhbHNbMF0uaXNUZXJtaW5hbCgpICYmXG4gICAgICAgICB2YWxzWzBdLnByaW1pdGl2ZVZhbHVlID09PSB1bmRlZmluZWQ7XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgIHZhbHNbMF0uaXNUZXJtaW5hbCgpICYmXG4gICAgICAgICB2YWxzWzBdLnByaW1pdGl2ZVZhbHVlID09PSB0aGlzLm9iajtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB2YWxzWzBdIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSAmJlxuICAgICAgICAgdmFsc1swXS5pc1Rlcm1pbmFsKCkgJiZcbiAgICAgICAgIHR5cGVvZiB2YWxzWzBdLnByaW1pdGl2ZVZhbHVlID09PSB0eXBlb2YgdGhpcy5mcm9tO1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHMubGVuZ3RoID49IDE7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRlcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGVybSA9IHRoaXMudGVybXNbaV07XG4gICAgaWYgKHRlcm0uY2hlY2soZ3JhbW1hciwgdmFscykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gdGhpcy5mYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IuY2hlY2soZ3JhbW1hciwgdmFscy5zbGljZShwb3MpKSkge1xuICAgICAgcG9zICs9IGZhY3Rvci5nZXRBcml0eSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICBjb25zdCBhcml0eSA9IHRoaXMuZ2V0QXJpdHkoKTtcbiAgY29uc3QgY29sdW1ucyA9IHZhbHMuc2xpY2UoMCwgYXJpdHkpO1xuICBpZiAoY29sdW1ucy5sZW5ndGggIT09IGFyaXR5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvd0NvdW50ID0gY29sdW1uc1swXS5sZW5ndGg7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxOyBpIDwgYXJpdHk7IGkrKykge1xuICAgIGlmIChjb2x1bW5zW2ldLmxlbmd0aCAhPT0gcm93Q291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJpdHk7IGorKykge1xuICAgICAgcm93LnB1c2goY29sdW1uc1tqXVtpXSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5leHByLmNoZWNrKGdyYW1tYXIsIHJvdykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmNoZWNrID1cbnBleHBycy5MZXgucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdGhpcy5leHByLmNoZWNrKGdyYW1tYXIsIHZhbHMpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgaWYgKCEodmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgdmFsc1swXS5ncmFtbWFyID09PSBncmFtbWFyICYmXG4gICAgICAgIHZhbHNbMF0uY3Rvck5hbWUgPT09IHRoaXMucnVsZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVE9ETzogdGhpbmsgYWJvdXQgKm5vdCogZG9pbmcgdGhlIGZvbGxvd2luZyBjaGVja3MsIGkuZS4sIHRydXN0aW5nIHRoYXQgdGhlIHJ1bGVcbiAgLy8gd2FzIGNvcnJlY3RseSBjb25zdHJ1Y3RlZC5cbiAgY29uc3QgcnVsZU5vZGUgPSB2YWxzWzBdO1xuICBjb25zdCBib2R5ID0gZ3JhbW1hci5ydWxlc1t0aGlzLnJ1bGVOYW1lXS5ib2R5O1xuICByZXR1cm4gYm9keS5jaGVjayhncmFtbWFyLCBydWxlTm9kZS5jaGlsZHJlbikgJiYgcnVsZU5vZGUubnVtQ2hpbGRyZW4oKSA9PT0gYm9keS5nZXRBcml0eSgpO1xufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHNbMF0gaW5zdGFuY2VvZiBub2Rlcy5Ob2RlICYmXG4gICAgICAgICB2YWxzWzBdLmlzVGVybWluYWwoKSAmJlxuICAgICAgICAgdHlwZW9mIHZhbHNbMF0ucHJpbWl0aXZlVmFsdWUgPT09ICdzdHJpbmcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFRyYWNlID0gcmVxdWlyZSgnLi9UcmFjZScpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbmNvbnN0IFRlcm1pbmFsTm9kZSA9IG5vZGVzLlRlcm1pbmFsTm9kZTtcbmNvbnN0IE5vbnRlcm1pbmFsTm9kZSA9IG5vZGVzLk5vbnRlcm1pbmFsTm9kZTtcbmNvbnN0IEl0ZXJhdGlvbk5vZGUgPSBub2Rlcy5JdGVyYXRpb25Ob2RlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgRXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gYW5kIHJldHVybiBgdHJ1ZWAgaWYgaXQgc3VjY2VlZHMsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGlzIG1ldGhvZCBzaG91bGRcbiAgb25seSBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgYFN0YXRlLnByb3RvdHlwZS5ldmFsKGV4cHIpYCwgd2hpY2ggYWxzbyB1cGRhdGVzIHRoZSBkYXRhIHN0cnVjdHVyZXNcbiAgdGhhdCBhcmUgdXNlZCBmb3IgdHJhY2luZy4gKE1ha2luZyB0aG9zZSB1cGRhdGVzIGluIGEgbWV0aG9kIG9mIGBTdGF0ZWAgZW5hYmxlcyB0aGUgdHJhY2Utc3BlY2lmaWNcbiAgZGF0YSBzdHJ1Y3R1cmVzIHRvIGJlIFwic2VjcmV0c1wiIG9mIHRoYXQgY2xhc3MsIHdoaWNoIGlzIGdvb2QgZm9yIG1vZHVsYXJpdHkuKVxuXG4gIFRoZSBjb250cmFjdCBvZiB0aGlzIG1ldGhvZCBpcyBhcyBmb2xsb3dzOlxuICAqIFdoZW4gdGhlIHJldHVybiB2YWx1ZSBpcyBgdHJ1ZWAsXG4gICAgLSB0aGUgc3RhdGUgb2JqZWN0IHdpbGwgaGF2ZSBgZXhwci5nZXRBcml0eSgpYCBtb3JlIGJpbmRpbmdzIHRoYW4gaXQgZGlkIGJlZm9yZSB0aGUgY2FsbC5cbiAgKiBXaGVuIHRoZSByZXR1cm4gdmFsdWUgaXMgYGZhbHNlYCxcbiAgICAtIHRoZSBzdGF0ZSBvYmplY3QgbWF5IGhhdmUgbW9yZSBiaW5kaW5ncyB0aGFuIGl0IGRpZCBiZWZvcmUgdGhlIGNhbGwsIGFuZFxuICAgIC0gaXRzIGlucHV0IHN0cmVhbSdzIHBvc2l0aW9uIG1heSBiZSBhbnl3aGVyZS5cblxuICBOb3RlIHRoYXQgYFN0YXRlLnByb3RvdHlwZS5ldmFsKGV4cHIpYCwgdW5saWtlIHRoaXMgbWV0aG9kLCBndWFyYW50ZWVzIHRoYXQgbmVpdGhlciB0aGUgc3RhdGVcbiAgb2JqZWN0J3MgYmluZGluZ3Mgbm9yIGl0cyBpbnB1dCBzdHJlYW0ncyBwb3NpdGlvbiB3aWxsIGNoYW5nZSBpZiB0aGUgZXhwcmVzc2lvbiBmYWlscyB0byBtYXRjaC5cbiovXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmV2YWwgPSBjb21tb24uYWJzdHJhY3QoJ2V2YWwnKTsgLy8gZnVuY3Rpb24oc3RhdGUpIHsgLi4uIH1cblxucGV4cHJzLmFueS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3QgY2ggPSBpbnB1dFN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCkge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgY2gpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5lbmQuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGlmIChpbnB1dFN0cmVhbS5hdEVuZCgpKSB7XG4gICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCB1bmRlZmluZWQpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGlmICghaW5wdXRTdHJlYW0ubWF0Y2hTdHJpbmcodGhpcy5vYmopKSB7XG4gICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgdGhpcy5vYmopLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3QgY2ggPSBpbnB1dFN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCAmJiB0aGlzLmZyb20gPD0gY2ggJiYgY2ggPD0gdGhpcy50bykge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgY2gpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5ldmFsKHN0YXRlLmN1cnJlbnRBcHBsaWNhdGlvbigpLmFyZ3NbdGhpcy5pbmRleF0pO1xufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmVudGVyTGV4aWZpZWRDb250ZXh0KCk7XG4gIGNvbnN0IGFucyA9IHN0YXRlLmV2YWwodGhpcy5leHByKTtcbiAgc3RhdGUuZXhpdExleGlmaWVkQ29udGV4dCgpO1xuICByZXR1cm4gYW5zO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMudGVybXMubGVuZ3RoOyBpZHgrKykge1xuICAgIGlmIChzdGF0ZS5ldmFsKHRoaXMudGVybXNbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSB0aGlzLmZhY3RvcnNbaWR4XTtcbiAgICBpZiAoIXN0YXRlLmV2YWwoZmFjdG9yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3QgYXJpdHkgPSB0aGlzLmdldEFyaXR5KCk7XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgY29uc3QgY29sT2Zmc2V0cyA9IFtdO1xuICB3aGlsZSAoY29scy5sZW5ndGggPCBhcml0eSkge1xuICAgIGNvbHMucHVzaChbXSk7XG4gICAgY29sT2Zmc2V0cy5wdXNoKFtdKTtcbiAgfVxuXG4gIGxldCBudW1NYXRjaGVzID0gMDtcbiAgbGV0IHByZXZQb3MgPSBvcmlnUG9zO1xuICBsZXQgaWR4O1xuICB3aGlsZSAobnVtTWF0Y2hlcyA8IHRoaXMubWF4TnVtTWF0Y2hlcyAmJiBzdGF0ZS5ldmFsKHRoaXMuZXhwcikpIHtcbiAgICBpZiAoaW5wdXRTdHJlYW0ucG9zID09PSBwcmV2UG9zKSB7XG4gICAgICB0aHJvdyBlcnJvcnMua2xlZW5lRXhwckhhc051bGxhYmxlT3BlcmFuZCh0aGlzLCBzdGF0ZS5fYXBwbGljYXRpb25TdGFjayk7XG4gICAgfVxuICAgIHByZXZQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gICAgbnVtTWF0Y2hlcysrO1xuICAgIGNvbnN0IHJvdyA9IHN0YXRlLl9iaW5kaW5ncy5zcGxpY2Uoc3RhdGUuX2JpbmRpbmdzLmxlbmd0aCAtIGFyaXR5LCBhcml0eSk7XG4gICAgY29uc3Qgcm93T2Zmc2V0cyA9IHN0YXRlLl9iaW5kaW5nT2Zmc2V0cy5zcGxpY2Uoc3RhdGUuX2JpbmRpbmdPZmZzZXRzLmxlbmd0aCAtIGFyaXR5LCBhcml0eSk7XG4gICAgZm9yIChpZHggPSAwOyBpZHggPCByb3cubGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29sc1tpZHhdLnB1c2gocm93W2lkeF0pO1xuICAgICAgY29sT2Zmc2V0c1tpZHhdLnB1c2gocm93T2Zmc2V0c1tpZHhdKTtcbiAgICB9XG4gIH1cbiAgaWYgKG51bU1hdGNoZXMgPCB0aGlzLm1pbk51bU1hdGNoZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IG9mZnNldCA9IHN0YXRlLnBvc1RvT2Zmc2V0KG9yaWdQb3MpO1xuICBsZXQgbWF0Y2hMZW5ndGggPSAwO1xuICBpZiAobnVtTWF0Y2hlcyA+IDApIHtcbiAgICBjb25zdCBsYXN0Q29sID0gY29sc1thcml0eSAtIDFdO1xuICAgIGNvbnN0IGxhc3RDb2xPZmZzZXRzID0gY29sT2Zmc2V0c1thcml0eSAtIDFdO1xuXG4gICAgY29uc3QgZW5kT2Zmc2V0ID1cbiAgICAgICAgbGFzdENvbE9mZnNldHNbbGFzdENvbE9mZnNldHMubGVuZ3RoIC0gMV0gKyBsYXN0Q29sW2xhc3RDb2wubGVuZ3RoIC0gMV0ubWF0Y2hMZW5ndGg7XG4gICAgb2Zmc2V0ID0gY29sT2Zmc2V0c1swXVswXTtcbiAgICBtYXRjaExlbmd0aCA9IGVuZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuICBjb25zdCBpc09wdGlvbmFsID0gdGhpcyBpbnN0YW5jZW9mIHBleHBycy5PcHQ7XG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgY29scy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgc3RhdGUuX2JpbmRpbmdzLnB1c2goXG4gICAgICAgIG5ldyBJdGVyYXRpb25Ob2RlKHN0YXRlLmdyYW1tYXIsIGNvbHNbaWR4XSwgY29sT2Zmc2V0c1tpZHhdLCBtYXRjaExlbmd0aCwgaXNPcHRpb25hbCkpO1xuICAgIHN0YXRlLl9iaW5kaW5nT2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgLypcbiAgICBUT0RPOlxuICAgIC0gUmlnaHQgbm93IHdlJ3JlIGp1c3QgdGhyb3dpbmcgYXdheSBhbGwgb2YgdGhlIGZhaWx1cmVzIHRoYXQgaGFwcGVuIGluc2lkZSBhIGBub3RgLCBhbmRcbiAgICAgIHJlY29yZGluZyBgdGhpc2AgYXMgYSBmYWlsZWQgZXhwcmVzc2lvbi5cbiAgICAtIERvdWJsZSBuZWdhdGlvbiBzaG91bGQgYmUgZXF1aXZhbGVudCB0byBsb29rYWhlYWQsIGJ1dCB0aGF0J3Mgbm90IHRoZSBjYXNlIHJpZ2h0IG5vdyB3cnRcbiAgICAgIGZhaWx1cmVzLiBFLmcuLCB+fidmb28nIHByb2R1Y2VzIGEgZmFpbHVyZSBmb3Igfn4nZm9vJywgYnV0IG1heWJlIGl0IHNob3VsZCBwcm9kdWNlXG4gICAgICBhIGZhaWx1cmUgZm9yICdmb28nIGluc3RlYWQuXG4gICovXG5cbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgc3RhdGUucHVzaEZhaWx1cmVzSW5mbygpO1xuXG4gIGNvbnN0IGFucyA9IHN0YXRlLmV2YWwodGhpcy5leHByKTtcblxuICBzdGF0ZS5wb3BGYWlsdXJlc0luZm8oKTtcbiAgaWYgKGFucykge1xuICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3M7XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGlmIChzdGF0ZS5ldmFsKHRoaXMuZXhwcikpIHtcbiAgICBpbnB1dFN0cmVhbS5wb3MgPSBvcmlnUG9zO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgY2FsbGVyID0gc3RhdGUuY3VycmVudEFwcGxpY2F0aW9uKCk7XG4gIGNvbnN0IGFjdHVhbHMgPSBjYWxsZXIgPyBjYWxsZXIuYXJncyA6IFtdO1xuICBjb25zdCBhcHAgPSB0aGlzLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscyk7XG5cbiAgY29uc3QgcG9zSW5mbyA9IHN0YXRlLmdldEN1cnJlbnRQb3NJbmZvKCk7XG4gIGlmIChwb3NJbmZvLmlzQWN0aXZlKGFwcCkpIHtcbiAgICAvLyBUaGlzIHJ1bGUgaXMgYWxyZWFkeSBhY3RpdmUgYXQgdGhpcyBwb3NpdGlvbiwgaS5lLiwgaXQgaXMgbGVmdC1yZWN1cnNpdmUuXG4gICAgcmV0dXJuIGFwcC5oYW5kbGVDeWNsZShzdGF0ZSk7XG4gIH1cblxuICBjb25zdCBtZW1vS2V5ID0gYXBwLnRvTWVtb0tleSgpO1xuICBjb25zdCBtZW1vUmVjID0gcG9zSW5mby5tZW1vW21lbW9LZXldO1xuXG4gIGlmIChtZW1vUmVjICYmIHBvc0luZm8uc2hvdWxkVXNlTWVtb2l6ZWRSZXN1bHQobWVtb1JlYykpIHtcbiAgICBpZiAoc3RhdGUuaGFzTmVjZXNzYXJ5SW5mbyhtZW1vUmVjKSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnVzZU1lbW9pemVkUmVzdWx0KHN0YXRlLmlucHV0U3RyZWFtLnBvcywgbWVtb1JlYyk7XG4gICAgfVxuICAgIGRlbGV0ZSBwb3NJbmZvLm1lbW9bbWVtb0tleV07XG4gIH1cbiAgcmV0dXJuIGFwcC5yZWFsbHlFdmFsKHN0YXRlKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuaGFuZGxlQ3ljbGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBwb3NJbmZvID0gc3RhdGUuZ2V0Q3VycmVudFBvc0luZm8oKTtcbiAgY29uc3QgY3VycmVudExlZnRSZWN1cnNpb24gPSBwb3NJbmZvLmN1cnJlbnRMZWZ0UmVjdXJzaW9uO1xuICBjb25zdCBtZW1vS2V5ID0gdGhpcy50b01lbW9LZXkoKTtcbiAgbGV0IG1lbW9SZWMgPSBwb3NJbmZvLm1lbW9bbWVtb0tleV07XG5cbiAgaWYgKGN1cnJlbnRMZWZ0UmVjdXJzaW9uICYmIGN1cnJlbnRMZWZ0UmVjdXJzaW9uLmhlYWRBcHBsaWNhdGlvbi50b01lbW9LZXkoKSA9PT0gbWVtb0tleSkge1xuICAgIC8vIFdlIGFscmVhZHkga25vdyBhYm91dCB0aGlzIGxlZnQgcmVjdXJzaW9uLCBidXQgaXQncyBwb3NzaWJsZSB0aGVyZSBhcmUgXCJpbnZvbHZlZFxuICAgIC8vIGFwcGxpY2F0aW9uc1wiIHRoYXQgd2UgZG9uJ3QgYWxyZWFkeSBrbm93IGFib3V0LCBzby4uLlxuICAgIG1lbW9SZWMudXBkYXRlSW52b2x2ZWRBcHBsaWNhdGlvbk1lbW9LZXlzKCk7XG4gIH0gZWxzZSBpZiAoIW1lbW9SZWMpIHtcbiAgICAvLyBOZXcgbGVmdCByZWN1cnNpb24gZGV0ZWN0ZWQhIE1lbW9pemUgYSBmYWlsdXJlIHRvIHRyeSB0byBnZXQgYSBzZWVkIHBhcnNlLlxuICAgIG1lbW9SZWMgPSBwb3NJbmZvLm1lbW9pemUoXG4gICAgICAgIG1lbW9LZXksXG4gICAgICAgIHttYXRjaExlbmd0aDogMCwgZXhhbWluZWRMZW5ndGg6IDAsIHZhbHVlOiBmYWxzZSwgcmlnaHRtb3N0RmFpbHVyZU9mZnNldDogLTF9KTtcbiAgICBwb3NJbmZvLnN0YXJ0TGVmdFJlY3Vyc2lvbih0aGlzLCBtZW1vUmVjKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudXNlTWVtb2l6ZWRSZXN1bHQoc3RhdGUuaW5wdXRTdHJlYW0ucG9zLCBtZW1vUmVjKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUucmVhbGx5RXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGNvbnN0IG9yaWdQb3NJbmZvID0gc3RhdGUuZ2V0Q3VycmVudFBvc0luZm8oKTtcbiAgY29uc3QgcnVsZUluZm8gPSBzdGF0ZS5ncmFtbWFyLnJ1bGVzW3RoaXMucnVsZU5hbWVdO1xuICBjb25zdCBib2R5ID0gcnVsZUluZm8uYm9keTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBydWxlSW5mby5kZXNjcmlwdGlvbjtcblxuICBzdGF0ZS5lbnRlckFwcGxpY2F0aW9uKG9yaWdQb3NJbmZvLCB0aGlzKTtcblxuICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICBzdGF0ZS5wdXNoRmFpbHVyZXNJbmZvKCk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgaW5wdXQgc3RyZWFtJ3MgZXhhbWluZWRMZW5ndGggcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gdHJhY2tcbiAgLy8gdGhlIGV4YW1pbmVkIGxlbmd0aCBvZiB0aGlzIHBhcnRpY3VsYXIgYXBwbGljYXRpb24uXG4gIGNvbnN0IG9yaWdJbnB1dFN0cmVhbUV4YW1pbmVkTGVuZ3RoID0gaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGg7XG4gIGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoID0gMDtcblxuICBsZXQgdmFsdWUgPSB0aGlzLmV2YWxPbmNlKGJvZHksIHN0YXRlKTtcbiAgY29uc3QgY3VycmVudExSID0gb3JpZ1Bvc0luZm8uY3VycmVudExlZnRSZWN1cnNpb247XG4gIGNvbnN0IG1lbW9LZXkgPSB0aGlzLnRvTWVtb0tleSgpO1xuICBjb25zdCBpc0hlYWRPZkxlZnRSZWN1cnNpb24gPSBjdXJyZW50TFIgJiYgY3VycmVudExSLmhlYWRBcHBsaWNhdGlvbi50b01lbW9LZXkoKSA9PT0gbWVtb0tleTtcbiAgbGV0IG1lbW9SZWM7XG5cbiAgaWYgKGlzSGVhZE9mTGVmdFJlY3Vyc2lvbikge1xuICAgIHZhbHVlID0gdGhpcy5ncm93U2VlZFJlc3VsdChib2R5LCBzdGF0ZSwgb3JpZ1BvcywgY3VycmVudExSLCB2YWx1ZSk7XG4gICAgb3JpZ1Bvc0luZm8uZW5kTGVmdFJlY3Vyc2lvbigpO1xuICAgIG1lbW9SZWMgPSBjdXJyZW50TFI7XG4gICAgbWVtb1JlYy5leGFtaW5lZExlbmd0aCA9IGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoIC0gb3JpZ1BvcztcbiAgICBtZW1vUmVjLnJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPSBzdGF0ZS5fZ2V0UmlnaHRtb3N0RmFpbHVyZU9mZnNldCgpO1xuICAgIG9yaWdQb3NJbmZvLm1lbW9pemUobWVtb0tleSwgbWVtb1JlYyk7IC8vIHVwZGF0ZXMgb3JpZ1Bvc0luZm8ncyBtYXhFeGFtaW5lZExlbmd0aFxuICB9IGVsc2UgaWYgKCFjdXJyZW50TFIgfHwgIWN1cnJlbnRMUi5pc0ludm9sdmVkKG1lbW9LZXkpKSB7XG4gICAgLy8gVGhpcyBhcHBsaWNhdGlvbiBpcyBub3QgaW52b2x2ZWQgaW4gbGVmdCByZWN1cnNpb24sIHNvIGl0J3Mgb2sgdG8gbWVtb2l6ZSBpdC5cbiAgICBtZW1vUmVjID0gb3JpZ1Bvc0luZm8ubWVtb2l6ZShtZW1vS2V5LCB7XG4gICAgICBtYXRjaExlbmd0aDogaW5wdXRTdHJlYW0ucG9zIC0gb3JpZ1BvcyxcbiAgICAgIGV4YW1pbmVkTGVuZ3RoOiBpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCAtIG9yaWdQb3MsXG4gICAgICB2YWx1ZSxcbiAgICAgIGZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbjogc3RhdGUuY2xvbmVSZWNvcmRlZEZhaWx1cmVzKCksXG4gICAgICByaWdodG1vc3RGYWlsdXJlT2Zmc2V0OiBzdGF0ZS5fZ2V0UmlnaHRtb3N0RmFpbHVyZU9mZnNldCgpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc3VjY2VlZGVkID0gISF2YWx1ZTtcblxuICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICBzdGF0ZS5wb3BGYWlsdXJlc0luZm8oKTtcbiAgICBpZiAoIXN1Y2NlZWRlZCkge1xuICAgICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZW1vUmVjKSB7XG4gICAgICBtZW1vUmVjLmZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbiA9IHN0YXRlLmNsb25lUmVjb3JkZWRGYWlsdXJlcygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlY29yZCB0cmFjZSBpbmZvcm1hdGlvbiBpbiB0aGUgbWVtbyB0YWJsZSwgc28gdGhhdCBpdCBpcyBhdmFpbGFibGUgaWYgdGhlIG1lbW9pemVkIHJlc3VsdFxuICAvLyBpcyB1c2VkIGxhdGVyLlxuICBpZiAoc3RhdGUuaXNUcmFjaW5nKCkgJiYgbWVtb1JlYykge1xuICAgIGNvbnN0IGVudHJ5ID0gc3RhdGUuZ2V0VHJhY2VFbnRyeShvcmlnUG9zLCB0aGlzLCBzdWNjZWVkZWQsIHN1Y2NlZWRlZCA/IFt2YWx1ZV0gOiBbXSk7XG4gICAgaWYgKGlzSGVhZE9mTGVmdFJlY3Vyc2lvbikge1xuICAgICAgY29tbW9uLmFzc2VydChlbnRyeS50ZXJtaW5hdGluZ0xSRW50cnkgIT0gbnVsbCB8fCAhc3VjY2VlZGVkKTtcbiAgICAgIGVudHJ5LmlzSGVhZE9mTGVmdFJlY3Vyc2lvbiA9IHRydWU7XG4gICAgfVxuICAgIG1lbW9SZWMudHJhY2VFbnRyeSA9IGVudHJ5O1xuICB9XG5cbiAgLy8gRml4IHRoZSBpbnB1dCBzdHJlYW0ncyBleGFtaW5lZExlbmd0aCAtLSBpdCBzaG91bGQgYmUgdGhlIG1heGltdW0gZXhhbWluZWQgbGVuZ3RoXG4gIC8vIGFjcm9zcyBhbGwgYXBwbGljYXRpb25zLCBub3QganVzdCB0aGlzIG9uZS5cbiAgaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGggPSBNYXRoLm1heChpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCwgb3JpZ0lucHV0U3RyZWFtRXhhbWluZWRMZW5ndGgpO1xuXG4gIHN0YXRlLmV4aXRBcHBsaWNhdGlvbihvcmlnUG9zSW5mbywgdmFsdWUpO1xuXG4gIHJldHVybiBzdWNjZWVkZWQ7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmV2YWxPbmNlID0gZnVuY3Rpb24oZXhwciwgc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcblxuICBpZiAoc3RhdGUuZXZhbChleHByKSkge1xuICAgIGNvbnN0IGFyaXR5ID0gZXhwci5nZXRBcml0eSgpO1xuICAgIGNvbnN0IGJpbmRpbmdzID0gc3RhdGUuX2JpbmRpbmdzLnNwbGljZShzdGF0ZS5fYmluZGluZ3MubGVuZ3RoIC0gYXJpdHksIGFyaXR5KTtcbiAgICBjb25zdCBvZmZzZXRzID0gc3RhdGUuX2JpbmRpbmdPZmZzZXRzLnNwbGljZShzdGF0ZS5fYmluZGluZ09mZnNldHMubGVuZ3RoIC0gYXJpdHksIGFyaXR5KTtcbiAgICByZXR1cm4gbmV3IE5vbnRlcm1pbmFsTm9kZShcbiAgICAgICAgc3RhdGUuZ3JhbW1hciwgdGhpcy5ydWxlTmFtZSwgYmluZGluZ3MsIG9mZnNldHMsIGlucHV0U3RyZWFtLnBvcyAtIG9yaWdQb3MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5ncm93U2VlZFJlc3VsdCA9IGZ1bmN0aW9uKGJvZHksIHN0YXRlLCBvcmlnUG9zLCBsck1lbW9SZWMsIG5ld1ZhbHVlKSB7XG4gIGlmICghbmV3VmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbHJNZW1vUmVjLm1hdGNoTGVuZ3RoID0gaW5wdXRTdHJlYW0ucG9zIC0gb3JpZ1BvcztcbiAgICBsck1lbW9SZWMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBsck1lbW9SZWMuZmFpbHVyZXNBdFJpZ2h0bW9zdFBvc2l0aW9uID0gc3RhdGUuY2xvbmVSZWNvcmRlZEZhaWx1cmVzKCk7XG5cbiAgICBpZiAoc3RhdGUuaXNUcmFjaW5nKCkpIHtcbiAgICAgIC8vIEJlZm9yZSBldmFsdWF0aW5nIHRoZSBib2R5IGFnYWluLCBhZGQgYSB0cmFjZSBub2RlIGZvciB0aGlzIGFwcGxpY2F0aW9uIHRvIHRoZSBtZW1vIGVudHJ5LlxuICAgICAgLy8gSXRzIG9ubHkgY2hpbGQgaXMgYSBjb3B5IG9mIHRoZSB0cmFjZSBub2RlIGZyb20gYG5ld1ZhbHVlYCwgd2hpY2ggd2lsbCBhbHdheXMgYmUgdGhlIGxhc3RcbiAgICAgIC8vIGVsZW1lbnQgaW4gYHN0YXRlLnRyYWNlYC5cbiAgICAgIGNvbnN0IHNlZWRUcmFjZSA9IHN0YXRlLnRyYWNlW3N0YXRlLnRyYWNlLmxlbmd0aCAtIDFdO1xuICAgICAgbHJNZW1vUmVjLnRyYWNlRW50cnkgPSBuZXcgVHJhY2UoXG4gICAgICAgICAgc3RhdGUuaW5wdXQsIG9yaWdQb3MsIGlucHV0U3RyZWFtLnBvcywgdGhpcywgdHJ1ZSwgW25ld1ZhbHVlXSwgW3NlZWRUcmFjZS5jbG9uZSgpXSk7XG4gICAgfVxuICAgIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3M7XG4gICAgbmV3VmFsdWUgPSB0aGlzLmV2YWxPbmNlKGJvZHksIHN0YXRlKTtcbiAgICBpZiAoaW5wdXRTdHJlYW0ucG9zIC0gb3JpZ1BvcyA8PSBsck1lbW9SZWMubWF0Y2hMZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaXNUcmFjaW5nKCkpIHtcbiAgICAgIHN0YXRlLnRyYWNlLnNwbGljZSgtMiwgMSk7IC8vIERyb3AgdGhlIHRyYWNlIGZvciB0aGUgb2xkIHNlZWQuXG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5pc1RyYWNpbmcoKSkge1xuICAgIC8vIFRoZSBsYXN0IGVudHJ5IGlzIGZvciBhbiB1bnVzZWQgcmVzdWx0IC0tIHBvcCBpdCBhbmQgc2F2ZSBpdCBpbiB0aGUgXCJyZWFsXCIgZW50cnkuXG4gICAgbHJNZW1vUmVjLnRyYWNlRW50cnkucmVjb3JkTFJUZXJtaW5hdGlvbihzdGF0ZS50cmFjZS5wb3AoKSwgbmV3VmFsdWUpO1xuICB9XG4gIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3MgKyBsck1lbW9SZWMubWF0Y2hMZW5ndGg7XG4gIHJldHVybiBsck1lbW9SZWMudmFsdWU7XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBjb25zdCBjaCA9IGlucHV0U3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoICYmIHRoaXMucGF0dGVybi50ZXN0KGNoKSkge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgY2gpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGZsYXR0ZW4obGlzdE9mTGlzdHMpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGxpc3RPZkxpc3RzKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gY29tbW9uLmFic3RyYWN0KCdnZW5lcmF0ZUV4YW1wbGUnKTtcblxuZnVuY3Rpb24gY2F0ZWdvcml6ZUV4YW1wbGVzKGV4YW1wbGVzKSB7XG4gIC8vIEEgbGlzdCBvZiBydWxlcyB0aGF0IHRoZSBzeXN0ZW0gbmVlZHMgZXhhbXBsZXMgb2YsIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIGV4YW1wbGVcbiAgLy8gICBmb3IgdGhlIGN1cnJlbnQgcnVsZVxuICBsZXQgZXhhbXBsZXNOZWVkZWQgPSBleGFtcGxlcy5maWx0ZXIoZXhhbXBsZSA9PiBleGFtcGxlLmhhc093blByb3BlcnR5KCdleGFtcGxlc05lZWRlZCcpKVxuICAgICAgLm1hcChleGFtcGxlID0+IGV4YW1wbGUuZXhhbXBsZXNOZWVkZWQpO1xuXG4gIGV4YW1wbGVzTmVlZGVkID0gZmxhdHRlbihleGFtcGxlc05lZWRlZCk7XG5cbiAgY29uc3QgdW5pcXVlRXhhbXBsZXNOZWVkZWQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGFtcGxlc05lZWRlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRFeGFtcGxlTmVlZGVkID0gZXhhbXBsZXNOZWVkZWRbaV07XG4gICAgdW5pcXVlRXhhbXBsZXNOZWVkZWRbY3VycmVudEV4YW1wbGVOZWVkZWRdID0gdHJ1ZTtcbiAgfVxuICBleGFtcGxlc05lZWRlZCA9IE9iamVjdC5rZXlzKHVuaXF1ZUV4YW1wbGVzTmVlZGVkKTtcblxuICAvLyBBIGxpc3Qgb2Ygc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCBleGFtcGxlc1xuICBjb25zdCBzdWNjZXNzZnVsRXhhbXBsZXMgPSBleGFtcGxlcy5maWx0ZXIoZXhhbXBsZSA9PiBleGFtcGxlLmhhc093blByb3BlcnR5KCd2YWx1ZScpKVxuICAgICAgLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuXG4gIC8vIFRoaXMgZmxhZyByZXR1cm5zIHRydWUgaWYgdGhlIHN5c3RlbSBjYW5ub3QgZ2VuZXJhdGUgdGhlIHJ1bGUgaXQgaXMgY3VycmVudGx5XG4gIC8vICAgYXR0ZW1wdGluZyB0byBnZW5lcmF0ZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCBpdCBoYXMgdGhlIGV4YW1wbGVzIGl0IG5lZWRzLlxuICAvLyAgIEN1cnJlbnRseSwgdGhpcyBpcyBvbmx5IHVzZWQgaW4gb3ZlcnJpZGluZyBnZW5lcmF0b3JzIHRvIHByZXZlbnQgdGhlIHN5c3RlbSBmcm9tXG4gIC8vICAgZ2VuZXJhdGluZyBleGFtcGxlcyBmb3IgY2VydGFpbiBydWxlcyAoZS5nLiAnaWRlbnQnKS5cbiAgY29uc3QgbmVlZEhlbHAgPSBleGFtcGxlcy5zb21lKGl0ZW0gPT4gaXRlbS5uZWVkSGVscCk7XG5cbiAgcmV0dXJuIHtcbiAgICBleGFtcGxlc05lZWRlZCxcbiAgICBzdWNjZXNzZnVsRXhhbXBsZXMsXG4gICAgbmVlZEhlbHBcbiAgfTtcbn1cblxucGV4cHJzLmFueS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIHJldHVybiB7dmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KSl9O1xufTtcblxuLy8gQXNzdW1lcyB0aGF0IHRlcm1pbmFsJ3Mgb2JqZWN0IGlzIGFsd2F5cyBhIHN0cmluZ1xucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0KSB7XG4gIHJldHVybiB7dmFsdWU6IHRoaXMub2JqfTtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCkge1xuICBjb25zdCByYW5nZVNpemUgPSB0aGlzLnRvLmNoYXJDb2RlQXQoMCkgLSB0aGlzLmZyb20uY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIHt2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgIHRoaXMuZnJvbS5jaGFyQ29kZUF0KDApICsgTWF0aC5mbG9vcihyYW5nZVNpemUgKiBNYXRoLnJhbmRvbSgpKVxuICApfTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICByZXR1cm4gYWN0dWFsc1t0aGlzLmluZGV4XS5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscyk7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIC8vIGl0ZW1zIC0+IHRlcm1FeGFtcGxlc1xuICBjb25zdCB0ZXJtRXhhbXBsZXMgPSB0aGlzLnRlcm1zLm1hcCh0ZXJtID0+IHtcbiAgICByZXR1cm4gdGVybS5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscyk7XG4gIH0pO1xuXG4gIGNvbnN0IGNhdGVnb3JpemVkRXhhbXBsZXMgPSBjYXRlZ29yaXplRXhhbXBsZXModGVybUV4YW1wbGVzKTtcblxuICBjb25zdCBleGFtcGxlc05lZWRlZCA9IGNhdGVnb3JpemVkRXhhbXBsZXMuZXhhbXBsZXNOZWVkZWQ7XG4gIGNvbnN0IHN1Y2Nlc3NmdWxFeGFtcGxlcyA9IGNhdGVnb3JpemVkRXhhbXBsZXMuc3VjY2Vzc2Z1bEV4YW1wbGVzO1xuICBjb25zdCBuZWVkSGVscCA9IGNhdGVnb3JpemVkRXhhbXBsZXMubmVlZEhlbHA7XG5cbiAgY29uc3QgYW5zID0ge307XG5cbiAgLy8gQWx0IGNhbiBjb250YWluIGJvdGggYW4gZXhhbXBsZSBhbmQgYSByZXF1ZXN0IGZvciBleGFtcGxlc1xuICBpZiAoc3VjY2Vzc2Z1bEV4YW1wbGVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc3VjY2Vzc2Z1bEV4YW1wbGVzLmxlbmd0aCk7XG4gICAgYW5zLnZhbHVlID0gc3VjY2Vzc2Z1bEV4YW1wbGVzW2ldO1xuICB9XG4gIGlmIChleGFtcGxlc05lZWRlZC5sZW5ndGggPiAwKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gZXhhbXBsZXNOZWVkZWQ7XG4gIH1cbiAgYW5zLm5lZWRIZWxwID0gbmVlZEhlbHA7XG5cbiAgcmV0dXJuIGFucztcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgY29uc3QgZmFjdG9yRXhhbXBsZXMgPSB0aGlzLmZhY3RvcnMubWFwKGZhY3RvciA9PiB7XG4gICAgcmV0dXJuIGZhY3Rvci5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscyk7XG4gIH0pO1xuICBjb25zdCBjYXRlZ29yaXplZEV4YW1wbGVzID0gY2F0ZWdvcml6ZUV4YW1wbGVzKGZhY3RvckV4YW1wbGVzKTtcblxuICBjb25zdCBleGFtcGxlc05lZWRlZCA9IGNhdGVnb3JpemVkRXhhbXBsZXMuZXhhbXBsZXNOZWVkZWQ7XG4gIGNvbnN0IHN1Y2Nlc3NmdWxFeGFtcGxlcyA9IGNhdGVnb3JpemVkRXhhbXBsZXMuc3VjY2Vzc2Z1bEV4YW1wbGVzO1xuICBjb25zdCBuZWVkSGVscCA9IGNhdGVnb3JpemVkRXhhbXBsZXMubmVlZEhlbHA7XG5cbiAgY29uc3QgYW5zID0ge307XG5cbiAgLy8gSW4gYSBTZXEsIGFsbCBwaWVjZXMgbXVzdCBzdWNjZWVkIGluIG9yZGVyIHRvIGhhdmUgYSBzdWNjZXNzZnVsIGV4YW1wbGUuXG4gIGlmIChleGFtcGxlc05lZWRlZC5sZW5ndGggPiAwIHx8IG5lZWRIZWxwKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gZXhhbXBsZXNOZWVkZWQ7XG4gICAgYW5zLm5lZWRIZWxwID0gbmVlZEhlbHA7XG4gIH0gZWxzZSB7XG4gICAgYW5zLnZhbHVlID0gc3VjY2Vzc2Z1bEV4YW1wbGVzLmpvaW4oaW5TeW50YWN0aWNDb250ZXh0ID8gJyAnIDogJycpO1xuICB9XG5cbiAgcmV0dXJuIGFucztcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIGNvbnN0IHJhbmdlVGltZXMgPSBNYXRoLm1pbih0aGlzLm1heE51bU1hdGNoZXMgLSB0aGlzLm1pbk51bU1hdGNoZXMsIDMpO1xuICBjb25zdCBudW1UaW1lcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChyYW5nZVRpbWVzICsgMSkgKyB0aGlzLm1pbk51bU1hdGNoZXMpO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXM7IGkrKykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5leHByLmdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSk7XG4gIH1cblxuICBjb25zdCBjYXRlZ29yaXplZEV4YW1wbGVzID0gY2F0ZWdvcml6ZUV4YW1wbGVzKGl0ZW1zKTtcblxuICBjb25zdCBleGFtcGxlc05lZWRlZCA9IGNhdGVnb3JpemVkRXhhbXBsZXMuZXhhbXBsZXNOZWVkZWQ7XG4gIGNvbnN0IHN1Y2Nlc3NmdWxFeGFtcGxlcyA9IGNhdGVnb3JpemVkRXhhbXBsZXMuc3VjY2Vzc2Z1bEV4YW1wbGVzO1xuXG4gIGNvbnN0IGFucyA9IHt9O1xuXG4gIC8vIEl0J3MgYWx3YXlzIGVpdGhlciBvbmUgb3IgdGhlIG90aGVyLlxuICAvLyBUT0RPOiBpbnN0ZWFkIG9mICcgJywgY2FsbCAnc3BhY2VzLmdlbmVyYXRlRXhhbXBsZSgpJ1xuICBhbnMudmFsdWUgPSBzdWNjZXNzZnVsRXhhbXBsZXMuam9pbihpblN5bnRhY3RpY0NvbnRleHQgPyAnICcgOiAnJyk7XG4gIGlmIChleGFtcGxlc05lZWRlZC5sZW5ndGggPiAwKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gZXhhbXBsZXNOZWVkZWQ7XG4gIH1cblxuICByZXR1cm4gYW5zO1xufTtcblxuLy8gUmlnaHQgbm93LCAnTm90JyBhbmQgJ0xvb2thaGVhZCcgZ2VuZXJhdGUgbm90aGluZyBhbmQgYXNzdW1lIHRoYXQgd2hhdGV2ZXIgZm9sbG93cyB3aWxsXG4vLyAgIHdvcmsgYWNjb3JkaW5nIHRvIHRoZSBlbmNvZGVkIGNvbnN0cmFpbnRzLlxucGV4cHJzLk5vdC5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCkge1xuICByZXR1cm4ge3ZhbHVlOiAnJ307XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0KSB7XG4gIHJldHVybiB7dmFsdWU6ICcnfTtcbn07XG5cbnBleHBycy5MZXgucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgcmV0dXJuIHRoaXMuZXhwci5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGZhbHNlLCBhY3R1YWxzKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICBjb25zdCBhbnMgPSB7fTtcblxuICBjb25zdCBydWxlTmFtZSA9IHRoaXMuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKS50b1N0cmluZygpO1xuXG4gIGlmICghZXhhbXBsZXMuaGFzT3duUHJvcGVydHkocnVsZU5hbWUpKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gW3J1bGVOYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWxldmFudEV4YW1wbGVzID0gZXhhbXBsZXNbcnVsZU5hbWVdO1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZWxldmFudEV4YW1wbGVzLmxlbmd0aCk7XG4gICAgYW5zLnZhbHVlID0gcmVsZXZhbnRFeGFtcGxlc1tpXTtcbiAgfVxuXG4gIHJldHVybiBhbnM7XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKFxuICAgIGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgbGV0IGNoYXI7XG4gIHN3aXRjaCAodGhpcy5jYXRlZ29yeSkge1xuICAgIGNhc2UgJ0x1JzogY2hhciA9ICfDgSc7IGJyZWFrO1xuICAgIGNhc2UgJ0xsJzogY2hhciA9ICfFjyc7IGJyZWFrO1xuICAgIGNhc2UgJ0x0JzogY2hhciA9ICfHhSc7IGJyZWFrO1xuICAgIGNhc2UgJ0xtJzogY2hhciA9ICfLric7IGJyZWFrO1xuICAgIGNhc2UgJ0xvJzogY2hhciA9ICfGuyc7IGJyZWFrO1xuXG4gICAgY2FzZSAnTmwnOiBjaGFyID0gJ+KGgic7IGJyZWFrO1xuICAgIGNhc2UgJ05kJzogY2hhciA9ICfCvSc7IGJyZWFrO1xuXG4gICAgY2FzZSAnTW4nOiBjaGFyID0gJ1xcdTA0ODcnOyBicmVhaztcbiAgICBjYXNlICdNYyc6IGNoYXIgPSAn4KS/JzsgYnJlYWs7XG5cbiAgICBjYXNlICdQYyc6IGNoYXIgPSAn4oGAJzsgYnJlYWs7XG5cbiAgICBjYXNlICdacyc6IGNoYXIgPSAnXFx1MjAwMSc7IGJyZWFrO1xuXG4gICAgY2FzZSAnTCc6IGNoYXIgPSAnw4EnOyBicmVhaztcbiAgICBjYXNlICdMdG1vJzogY2hhciA9ICfHhSc7IGJyZWFrO1xuICB9XG4gIHJldHVybiB7dmFsdWU6IGNoYXJ9OyAvLyDwn5KpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmdldEFyaXR5ID0gY29tbW9uLmFic3RyYWN0KCdnZXRBcml0eScpO1xuXG5wZXhwcnMuYW55LmdldEFyaXR5ID1cbnBleHBycy5lbmQuZ2V0QXJpdHkgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5nZXRBcml0eSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmdldEFyaXR5ID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuZ2V0QXJpdHkgPVxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5nZXRBcml0eSA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgLy8gVGhpcyBpcyBvayBiL2MgYWxsIHRlcm1zIG11c3QgaGF2ZSB0aGUgc2FtZSBhcml0eSAtLSB0aGlzIHByb3BlcnR5IGlzXG4gIC8vIGNoZWNrZWQgYnkgdGhlIEdyYW1tYXIgY29uc3RydWN0b3IuXG4gIHJldHVybiB0aGlzLnRlcm1zLmxlbmd0aCA9PT0gMCA/IDAgOiB0aGlzLnRlcm1zWzBdLmdldEFyaXR5KCk7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5nZXRBcml0eSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgYXJpdHkgPSAwO1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpZHgrKykge1xuICAgIGFyaXR5ICs9IHRoaXMuZmFjdG9yc1tpZHhdLmdldEFyaXR5KCk7XG4gIH1cbiAgcmV0dXJuIGFyaXR5O1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmV4cHIuZ2V0QXJpdHkoKTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuZ2V0QXJpdHkgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZXhwci5nZXRBcml0eSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgQ2FsbGVkIGF0IGdyYW1tYXIgY3JlYXRpb24gdGltZSB0byByZXdyaXRlIGEgcnVsZSBib2R5LCByZXBsYWNpbmcgZWFjaCByZWZlcmVuY2UgdG8gYSBmb3JtYWxcbiAgcGFyYW1ldGVyIHdpdGggYSBgUGFyYW1gIG5vZGUuIFJldHVybnMgYSBQRXhwciAtLSBlaXRoZXIgYSBuZXcgb25lLCBvciB0aGUgb3JpZ2luYWwgb25lIGlmXG4gIGl0IHdhcyBtb2RpZmllZCBpbiBwbGFjZS5cbiovXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGNvbW1vbi5hYnN0cmFjdCgnaW50cm9kdWNlUGFyYW1zJyk7XG5cbnBleHBycy5hbnkuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5lbmQuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID0gZnVuY3Rpb24oZm9ybWFscykge1xuICByZXR1cm4gdGhpcztcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGZ1bmN0aW9uKGZvcm1hbHMpIHtcbiAgdGhpcy50ZXJtcy5mb3JFYWNoKCh0ZXJtLCBpZHgsIHRlcm1zKSA9PiB7XG4gICAgdGVybXNbaWR4XSA9IHRlcm0uaW50cm9kdWNlUGFyYW1zKGZvcm1hbHMpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIHRoaXMuZmFjdG9ycy5mb3JFYWNoKChmYWN0b3IsIGlkeCwgZmFjdG9ycykgPT4ge1xuICAgIGZhY3RvcnNbaWR4XSA9IGZhY3Rvci5pbnRyb2R1Y2VQYXJhbXMoZm9ybWFscyk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIHRoaXMuZXhwciA9IHRoaXMuZXhwci5pbnRyb2R1Y2VQYXJhbXMoZm9ybWFscyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIGNvbnN0IGluZGV4ID0gZm9ybWFscy5pbmRleE9mKHRoaXMucnVsZU5hbWUpO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIGlmICh0aGlzLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYmUgc3VwcG9ydGVkPyBTZWUgaXNzdWUgIzY0LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJpemVkIHJ1bGVzIGNhbm5vdCBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIGFub3RoZXIgcnVsZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuUGFyYW0oaW5kZXgpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXJncy5mb3JFYWNoKChhcmcsIGlkeCwgYXJncykgPT4ge1xuICAgICAgYXJnc1tpZHhdID0gYXJnLmludHJvZHVjZVBhcmFtcyhmb3JtYWxzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBwYXJzaW5nIGV4cHJlc3Npb24gbWF5IGFjY2VwdCB3aXRob3V0IGNvbnN1bWluZyBhbnkgaW5wdXQuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmlzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiB0aGlzLl9pc051bGxhYmxlKGdyYW1tYXIsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufTtcblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGNvbW1vbi5hYnN0cmFjdCgnX2lzTnVsbGFibGUnKTtcblxucGV4cHJzLmFueS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLlBsdXMucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnBleHBycy5lbmQuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzLm9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUaGlzIGlzIGFuIG92ZXItc2ltcGxpZmljYXRpb246IGl0J3Mgb25seSBjb3JyZWN0IGlmIHRoZSBpbnB1dCBpcyBhIHN0cmluZy4gSWYgaXQncyBhbiBhcnJheVxuICAgIC8vIG9yIGFuIG9iamVjdCwgdGhlbiB0aGUgZW1wdHkgc3RyaW5nIHBhcnNpbmcgZXhwcmVzc2lvbiBpcyBub3QgbnVsbGFibGUuXG4gICAgcmV0dXJuIHRoaXMub2JqID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICByZXR1cm4gdGhpcy50ZXJtcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIHRoaXMudGVybXMuc29tZSh0ZXJtID0+IHRlcm0uX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbykpO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0aGlzLmZhY3RvcnMuZXZlcnkoZmFjdG9yID0+IGZhY3Rvci5faXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKSk7XG59O1xuXG5wZXhwcnMuU3Rhci5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLk9wdC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0aGlzLmV4cHIuX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbyk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICBjb25zdCBrZXkgPSB0aGlzLnRvTWVtb0tleSgpO1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZW1vLCBrZXkpKSB7XG4gICAgY29uc3QgYm9keSA9IGdyYW1tYXIucnVsZXNbdGhpcy5ydWxlTmFtZV0uYm9keTtcbiAgICBjb25zdCBpbmxpbmVkID0gYm9keS5zdWJzdGl0dXRlUGFyYW1zKHRoaXMuYXJncyk7XG4gICAgbWVtb1trZXldID0gZmFsc2U7IC8vIFByZXZlbnQgaW5maW5pdGUgcmVjdXJzaW9uIGZvciByZWN1cnNpdmUgcnVsZXMuXG4gICAgbWVtb1trZXldID0gaW5saW5lZC5faXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKTtcbiAgfVxuICByZXR1cm4gbWVtb1trZXldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZ2V0TWV0YUluZm8oZXhwciwgZ3JhbW1hckludGVydmFsKSB7XG4gIGNvbnN0IG1ldGFJbmZvID0ge307XG4gIGlmIChleHByLnNvdXJjZSAmJiBncmFtbWFySW50ZXJ2YWwpIHtcbiAgICBjb25zdCBhZGp1c3RlZCA9IGV4cHIuc291cmNlLnJlbGF0aXZlVG8oZ3JhbW1hckludGVydmFsKTtcbiAgICBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbCA9IFthZGp1c3RlZC5zdGFydElkeCwgYWRqdXN0ZWQuZW5kSWR4XTtcbiAgfVxuICByZXR1cm4gbWV0YUluZm87XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGNvbW1vbi5hYnN0cmFjdCgnb3V0cHV0UmVjaXBlJyk7XG5cbnBleHBycy5hbnkub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbJ2FueScsIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCldO1xufTtcblxucGV4cHJzLmVuZC5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFsnZW5kJywgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKV07XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICd0ZXJtaW5hbCcsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLm9ialxuICBdO1xufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAncmFuZ2UnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgdGhpcy5mcm9tLFxuICAgIHRoaXMudG9cbiAgXTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ3BhcmFtJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMuaW5kZXhcbiAgXTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICdhbHQnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbClcbiAgXS5jb25jYXQodGhpcy50ZXJtcy5tYXAodGVybSA9PiB0ZXJtLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpKSk7XG59O1xuXG5wZXhwcnMuRXh0ZW5kLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy50ZXJtc1swXTsgLy8gW2V4dGVuc2lvbiwgb3JpZ2luYWxdXG4gIHJldHVybiBleHRlbnNpb24ub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCk7XG59O1xuXG5wZXhwcnMuU3BsaWNlLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgY29uc3QgYmVmb3JlVGVybXMgPSB0aGlzLnRlcm1zLnNsaWNlKDAsIHRoaXMuZXhwYW5zaW9uUG9zKTtcbiAgY29uc3QgYWZ0ZXJUZXJtcyA9IHRoaXMudGVybXMuc2xpY2UodGhpcy5leHBhbnNpb25Qb3MgKyAxKTtcbiAgcmV0dXJuIFtcbiAgICAnc3BsaWNlJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIGJlZm9yZVRlcm1zLm1hcCh0ZXJtID0+IHRlcm0ub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkpLFxuICAgIGFmdGVyVGVybXMubWFwKHRlcm0gPT4gdGVybS5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKSlcbiAgXTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICdzZXEnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbClcbiAgXS5jb25jYXQodGhpcy5mYWN0b3JzLm1hcChmYWN0b3IgPT4gZmFjdG9yLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpKSk7XG59O1xuXG5wZXhwcnMuU3Rhci5wcm90b3R5cGUub3V0cHV0UmVjaXBlID1cbnBleHBycy5QbHVzLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPVxucGV4cHJzLk9wdC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID1cbnBleHBycy5Ob3QucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPVxucGV4cHJzLkxleC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLmV4cHIub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbClcbiAgXTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ2FwcCcsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLnJ1bGVOYW1lLFxuICAgIHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKSlcbiAgXTtcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ3VuaWNvZGVDaGFyJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMuY2F0ZWdvcnlcbiAgXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIFJldHVybnMgYSBQRXhwciB0aGF0IHJlc3VsdHMgZnJvbSByZWN1cnNpdmVseSByZXBsYWNpbmcgZXZlcnkgZm9ybWFsIHBhcmFtZXRlciAoaS5lLiwgaW5zdGFuY2VcbiAgb2YgYFBhcmFtYCkgaW5zaWRlIHRoaXMgUEV4cHIgd2l0aCBpdHMgYWN0dWFsIHZhbHVlIGZyb20gYGFjdHVhbHNgIChhbiBBcnJheSkuXG5cbiAgVGhlIHJlY2VpdmVyIG11c3Qgbm90IGJlIG1vZGlmaWVkOyBhIG5ldyBQRXhwciBtdXN0IGJlIHJldHVybmVkIGlmIGFueSByZXBsYWNlbWVudCBpcyBuZWNlc3NhcnkuXG4qL1xuLy8gZnVuY3Rpb24oYWN0dWFscykgeyAuLi4gfVxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gY29tbW9uLmFic3RyYWN0KCdzdWJzdGl0dXRlUGFyYW1zJyk7XG5cbnBleHBycy5hbnkuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuZW5kLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICByZXR1cm4gYWN0dWFsc1t0aGlzLmluZGV4XTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiBuZXcgcGV4cHJzLkFsdChcbiAgICAgIHRoaXMudGVybXMubWFwKHRlcm0gPT4gdGVybS5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpKSk7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICByZXR1cm4gbmV3IHBleHBycy5TZXEoXG4gICAgICB0aGlzLmZhY3RvcnMubWFwKGZhY3RvciA9PiBmYWN0b3Iuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSkpO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5MZXgucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmV4cHIuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIGlmICh0aGlzLmFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQXZvaWQgbWFraW5nIGEgY29weSBvZiB0aGlzIGFwcGxpY2F0aW9uLCBhcyBhbiBvcHRpbWl6YXRpb25cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdzLm1hcChhcmcgPT4gYXJnLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykpO1xuICAgIHJldHVybiBuZXcgcGV4cHJzLkFwcGx5KHRoaXMucnVsZU5hbWUsIGFyZ3MpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbmNvbnN0IHtjb3B5V2l0aG91dER1cGxpY2F0ZXN9ID0gY29tbW9uO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaXNSZXN0cmljdGVkSlNJZGVudGlmaWVyKHN0cikge1xuICByZXR1cm4gL15bYS16QS1aXyRdWzAtOWEtekEtWl8kXSokLy50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEdXBsaWNhdGVkTmFtZXMoYXJndW1lbnROYW1lTGlzdCkge1xuICAvLyBgY291bnRgIGlzIHVzZWQgdG8gcmVjb3JkIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBhcmd1bWVudCBuYW1lIG9jY3VycyBpbiB0aGUgbGlzdCxcbiAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIGNoZWNraW5nIGR1cGxpY2F0ZWQgYXJndW1lbnQgbmFtZS4gSXQgbWFwcyBhcmd1bWVudCBuYW1lcyB0byBpbnRzLlxuICBjb25zdCBjb3VudCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGFyZ3VtZW50TmFtZUxpc3QuZm9yRWFjaChhcmdOYW1lID0+IHtcbiAgICBjb3VudFthcmdOYW1lXSA9IChjb3VudFthcmdOYW1lXSB8fCAwKSArIDE7XG4gIH0pO1xuXG4gIC8vIEFwcGVuZCBzdWJzY3JpcHRzICgnXzEnLCAnXzInLCAuLi4pIHRvIGR1cGxpY2F0ZSBhcmd1bWVudCBuYW1lcy5cbiAgT2JqZWN0LmtleXMoY291bnQpLmZvckVhY2goZHVwQXJnTmFtZSA9PiB7XG4gICAgaWYgKGNvdW50W2R1cEFyZ05hbWVdIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIG5hbWUgc2hvd3MgdXAgbW9yZSB0aGFuIG9uY2UsIHNvIGFkZCBzdWJzY3JpcHRzLlxuICAgIGxldCBzdWJzY3JpcHQgPSAxO1xuICAgIGFyZ3VtZW50TmFtZUxpc3QuZm9yRWFjaCgoYXJnTmFtZSwgaWR4KSA9PiB7XG4gICAgICBpZiAoYXJnTmFtZSA9PT0gZHVwQXJnTmFtZSkge1xuICAgICAgICBhcmd1bWVudE5hbWVMaXN0W2lkeF0gPSBhcmdOYW1lICsgJ18nICsgc3Vic2NyaXB0Kys7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgUmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgZGVmYXVsdCBhcmd1bWVudCBuYW1lcyBmb3IgaXRzIHJlY2VpdmVyXG4gIChhIHBleHByKSBpbiBhIHNlbWFudGljIGFjdGlvbi4gVGhpcyBpcyB1c2VkIGV4Y2x1c2l2ZWx5IGJ5IHRoZSBTZW1hbnRpY3MgRWRpdG9yLlxuXG4gIGBmaXJzdEFyZ0luZGV4YCBpcyB0aGUgMS1iYXNlZCBpbmRleCBvZiB0aGUgZmlyc3QgYXJndW1lbnQgbmFtZSB0aGF0IHdpbGwgYmUgZ2VuZXJhdGVkIGZvciB0aGlzXG4gIHBleHByLiBJdCBlbmFibGVzIHVzIHRvIG5hbWUgYXJndW1lbnRzIHBvc2l0aW9uYWxseSwgZS5nLiwgaWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhXG4gIG5vbi1hbHBoYW51bWVyaWMgdGVybWluYWwgbGlrZSBcIitcIiwgaXQgd2lsbCBiZSBuYW1lZCAnJDInLlxuXG4gIGBub0R1cENoZWNrYCBpcyB0cnVlIGlmIHRoZSBjYWxsZXIgb2YgYHRvQXJndW1lbnROYW1lTGlzdGAgaXMgbm90IGEgdG9wIGxldmVsIGNhbGxlci4gSXQgZW5hYmxlc1xuICB1cyB0byBhdm9pZCBuZXN0ZWQgZHVwbGljYXRpb24gc3Vic2NyaXB0cyBhcHBlbmRpbmcsIGUuZy4sICdfMV8xJywgJ18xXzInLCBieSBvbmx5IGNoZWNraW5nXG4gIGR1cGxpY2F0ZXMgYXQgdGhlIHRvcCBsZXZlbC5cblxuICBIZXJlIGlzIGEgbW9yZSBlbGFib3JhdGUgZXhhbXBsZSB0aGF0IGlsbHVzdHJhdGVzIGhvdyB0aGlzIG1ldGhvZCB3b3JrczpcbiAgYChhIFwiK1wiIGIpLnRvQXJndW1lbnROYW1lTGlzdCgxKWAgZXZhbHVhdGVzIHRvIGBbJ2EnLCAnJDInLCAnYiddYCB3aXRoIHRoZSBmb2xsb3dpbmcgcmVjdXJzaXZlXG4gIGNhbGxzOlxuXG4gICAgKGEpLnRvQXJndW1lbnROYW1lTGlzdCgxKSAtPiBbJ2EnXSxcbiAgICAoXCIrXCIpLnRvQXJndW1lbnROYW1lTGlzdCgyKSAtPiBbJyQyJ10sXG4gICAgKGIpLnRvQXJndW1lbnROYW1lTGlzdCgzKSAtPiBbJ2InXVxuXG4gIE5vdGVzOlxuICAqIFRoaXMgbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgb24gd2VsbC1mb3JtZWQgZXhwcmVzc2lvbnMsIGUuZy4sIHRoZSByZWNlaXZlciBtdXN0XG4gICAgbm90IGhhdmUgYW55IEFsdCBzdWItZXhwcmVzc2lvbnMgd2l0aCBpbmNvbnNpc3RlbnQgYXJpdGllcy5cbiAgKiBlLmdldEFyaXR5KCkgPT09IGUudG9Bcmd1bWVudE5hbWVMaXN0KDEpLmxlbmd0aFxuKi9cbi8vIGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHsgLi4uIH1cbnBleHBycy5QRXhwci5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gY29tbW9uLmFic3RyYWN0KCd0b0FyZ3VtZW50TmFtZUxpc3QnKTtcblxucGV4cHJzLmFueS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbJ2FueSddO1xufTtcblxucGV4cHJzLmVuZC50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbJ2VuZCddO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5vYmogPT09ICdzdHJpbmcnICYmIC9eW19hLXpBLVowLTldKyQvLnRlc3QodGhpcy5vYmopKSB7XG4gICAgLy8gSWYgdGhpcyB0ZXJtaW5hbCBpcyBhIHZhbGlkIHN1ZmZpeCBmb3IgYSBKUyBpZGVudGlmaWVyLCBqdXN0IHByZXBlbmQgaXQgd2l0aCAnXydcbiAgICByZXR1cm4gWydfJyArIHRoaXMub2JqXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIG5hbWUgaXQgcG9zaXRpb25hbGx5LlxuICAgIHJldHVybiBbJyQnICsgZmlyc3RBcmdJbmRleF07XG4gIH1cbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICBsZXQgYXJnTmFtZSA9IHRoaXMuZnJvbSArICdfdG9fJyArIHRoaXMudG87XG4gIC8vIElmIHRoZSBgYXJnTmFtZWAgaXMgbm90IHZhbGlkIHRoZW4gdHJ5IHRvIHByZXBlbmQgYSBgX2AuXG4gIGlmICghaXNSZXN0cmljdGVkSlNJZGVudGlmaWVyKGFyZ05hbWUpKSB7XG4gICAgYXJnTmFtZSA9ICdfJyArIGFyZ05hbWU7XG4gIH1cbiAgLy8gSWYgdGhlIGBhcmdOYW1lYCBzdGlsbCBub3QgdmFsaWQgYWZ0ZXIgcHJlcGVuZGluZyBhIGBfYCwgdGhlbiBuYW1lIGl0IHBvc2l0aW9uYWxseS5cbiAgaWYgKCFpc1Jlc3RyaWN0ZWRKU0lkZW50aWZpZXIoYXJnTmFtZSkpIHtcbiAgICBhcmdOYW1lID0gJyQnICsgZmlyc3RBcmdJbmRleDtcbiAgfVxuICByZXR1cm4gW2FyZ05hbWVdO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICAvLyBgdGVybUFyZ05hbWVMaXN0c2AgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIHdoZXJlIGVhY2ggcm93IGlzIHRoZVxuICAvLyBhcmd1bWVudCBuYW1lIGxpc3QgdGhhdCBjb3JyZXNwb25kcyB0byBhIHRlcm0gaW4gdGhpcyBhbHRlcm5hdGlvbi5cbiAgY29uc3QgdGVybUFyZ05hbWVMaXN0cyA9IHRoaXMudGVybXMubWFwKHRlcm0gPT4gdGVybS50b0FyZ3VtZW50TmFtZUxpc3QoZmlyc3RBcmdJbmRleCwgdHJ1ZSkpO1xuXG4gIGNvbnN0IGFyZ3VtZW50TmFtZUxpc3QgPSBbXTtcbiAgY29uc3QgbnVtQXJncyA9IHRlcm1BcmdOYW1lTGlzdHNbMF0ubGVuZ3RoO1xuICBmb3IgKGxldCBjb2xJZHggPSAwOyBjb2xJZHggPCBudW1BcmdzOyBjb2xJZHgrKykge1xuICAgIGNvbnN0IGNvbCA9IFtdO1xuICAgIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRoaXMudGVybXMubGVuZ3RoOyByb3dJZHgrKykge1xuICAgICAgY29sLnB1c2godGVybUFyZ05hbWVMaXN0c1tyb3dJZHhdW2NvbElkeF0pO1xuICAgIH1cbiAgICBjb25zdCB1bmlxdWVOYW1lcyA9IGNvcHlXaXRob3V0RHVwbGljYXRlcyhjb2wpO1xuICAgIGFyZ3VtZW50TmFtZUxpc3QucHVzaCh1bmlxdWVOYW1lcy5qb2luKCdfb3JfJykpO1xuICB9XG5cbiAgaWYgKCFub0R1cENoZWNrKSB7XG4gICAgcmVzb2x2ZUR1cGxpY2F0ZWROYW1lcyhhcmd1bWVudE5hbWVMaXN0KTtcbiAgfVxuICByZXR1cm4gYXJndW1lbnROYW1lTGlzdDtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgLy8gR2VuZXJhdGUgdGhlIGFyZ3VtZW50IG5hbWUgbGlzdCwgd2l0aG91dCB3b3JyeWluZyBhYm91dCBkdXBsaWNhdGVzLlxuICBsZXQgYXJndW1lbnROYW1lTGlzdCA9IFtdO1xuICB0aGlzLmZhY3RvcnMuZm9yRWFjaChmYWN0b3IgPT4ge1xuICAgIGNvbnN0IGZhY3RvckFyZ3VtZW50TmFtZUxpc3QgPSBmYWN0b3IudG9Bcmd1bWVudE5hbWVMaXN0KGZpcnN0QXJnSW5kZXgsIHRydWUpO1xuICAgIGFyZ3VtZW50TmFtZUxpc3QgPSBhcmd1bWVudE5hbWVMaXN0LmNvbmNhdChmYWN0b3JBcmd1bWVudE5hbWVMaXN0KTtcblxuICAgIC8vIFNoaWZ0IHRoZSBmaXJzdEFyZ0luZGV4IHRvIHRha2UgdGhpcyBmYWN0b3IncyBhcmd1bWVudCBuYW1lcyBpbnRvIGFjY291bnQuXG4gICAgZmlyc3RBcmdJbmRleCArPSBmYWN0b3JBcmd1bWVudE5hbWVMaXN0Lmxlbmd0aDtcbiAgfSk7XG4gIGlmICghbm9EdXBDaGVjaykge1xuICAgIHJlc29sdmVEdXBsaWNhdGVkTmFtZXMoYXJndW1lbnROYW1lTGlzdCk7XG4gIH1cbiAgcmV0dXJuIGFyZ3VtZW50TmFtZUxpc3Q7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICBjb25zdCBhcmd1bWVudE5hbWVMaXN0ID0gdGhpcy5leHByLnRvQXJndW1lbnROYW1lTGlzdChmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKVxuICAgICAgLm1hcChleHByQXJndW1lbnRTdHJpbmcgPT4gZXhwckFyZ3VtZW50U3RyaW5nW2V4cHJBcmd1bWVudFN0cmluZy5sZW5ndGggLSAxXSA9PT0gJ3MnID9cbiAgICAgICAgICBleHByQXJndW1lbnRTdHJpbmcgKyAnZXMnIDpcbiAgICAgICAgICBleHByQXJndW1lbnRTdHJpbmcgKyAncycpO1xuICBpZiAoIW5vRHVwQ2hlY2spIHtcbiAgICByZXNvbHZlRHVwbGljYXRlZE5hbWVzKGFyZ3VtZW50TmFtZUxpc3QpO1xuICB9XG4gIHJldHVybiBhcmd1bWVudE5hbWVMaXN0O1xufTtcblxucGV4cHJzLk9wdC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gdGhpcy5leHByLnRvQXJndW1lbnROYW1lTGlzdChmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKS5tYXAoYXJnTmFtZSA9PiB7XG4gICAgcmV0dXJuICdvcHQnICsgYXJnTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgYXJnTmFtZS5zbGljZSgxKTtcbiAgfSk7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbXTtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiB0aGlzLmV4cHIudG9Bcmd1bWVudE5hbWVMaXN0KGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbdGhpcy5ydWxlTmFtZV07XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIFsnJCcgKyBmaXJzdEFyZ0luZGV4XTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gWydwYXJhbScgKyB0aGlzLmluZGV4XTtcbn07XG5cbi8vIFwiVmFsdWUgcGV4cHJzXCIgKFZhbHVlLCBTdHIsIEFyciwgT2JqKSBhcmUgZ29pbmcgYXdheSBzb29uLCBzbyB3ZSBkb24ndCB3b3JyeSBhYm91dCB0aGVtIGhlcmUuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBQRXhwciwgZm9yIHVzZSBhcyBhIFVJIGxhYmVsLCBldGMuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGNvbW1vbi5hYnN0cmFjdCgndG9EaXNwbGF5U3RyaW5nJyk7XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuU2VxLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnRyaW1tZWQoKS5jb250ZW50cztcbiAgfVxuICByZXR1cm4gJ1snICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJ10nO1xufTtcblxucGV4cHJzLmFueS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLmVuZC50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLkl0ZXIucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5MZXgucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcHMgPSB0aGlzLmFyZ3MubWFwKGFyZyA9PiBhcmcudG9EaXNwbGF5U3RyaW5nKCkpO1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lICsgJzwnICsgcHMuam9pbignLCcpICsgJz4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICB9XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ1VuaWNvZGUgWycgKyB0aGlzLmNhdGVnb3J5ICsgJ10gY2hhcmFjdGVyJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBGYWlsdXJlID0gcmVxdWlyZSgnLi9GYWlsdXJlJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUudG9GYWlsdXJlID0gY29tbW9uLmFic3RyYWN0KCd0b0ZhaWx1cmUnKTtcblxucGV4cHJzLmFueS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCAnYW55IG9iamVjdCcsICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLmVuZC50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCAnZW5kIG9mIGlucHV0JywgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIHRoaXMub2JqLCAnc3RyaW5nJyk7XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgLy8gVE9ETzogY29tZSB1cCB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIEpTT04uc3RyaW5naWZ5KHRoaXMuZnJvbSkgKyAnLi4nICsgSlNPTi5zdHJpbmdpZnkodGhpcy50byksICdjb2RlJyk7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5leHByID09PSBwZXhwcnMuYW55ID9cbiAgICAgICdub3RoaW5nJyA6XG4gICAgICAnbm90ICcgKyB0aGlzLmV4cHIudG9GYWlsdXJlKGdyYW1tYXIpO1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgZGVzY3JpcHRpb24sICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gdGhpcy5leHByLnRvRmFpbHVyZShncmFtbWFyKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBsZXQgZGVzY3JpcHRpb24gPSBncmFtbWFyLnJ1bGVzW3RoaXMucnVsZU5hbWVdLmRlc2NyaXB0aW9uO1xuICBpZiAoIWRlc2NyaXB0aW9uKSB7XG4gICAgY29uc3QgYXJ0aWNsZSA9ICgvXlthZWlvdUFFSU9VXS8udGVzdCh0aGlzLnJ1bGVOYW1lKSA/ICdhbicgOiAnYScpO1xuICAgIGRlc2NyaXB0aW9uID0gYXJ0aWNsZSArICcgJyArIHRoaXMucnVsZU5hbWU7XG4gIH1cbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIGRlc2NyaXB0aW9uLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgJ2EgVW5pY29kZSBbJyArIHRoaXMuY2F0ZWdvcnkgKyAnXSBjaGFyYWN0ZXInLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgY29uc3QgZnMgPSB0aGlzLnRlcm1zLm1hcCh0ID0+IHQudG9GYWlsdXJlKGdyYW1tYXIpKTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSAnKCcgKyBmcy5qb2luKCcgb3IgJykgKyAnKSc7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBkZXNjcmlwdGlvbiwgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGNvbnN0IGZzID0gdGhpcy5mYWN0b3JzLm1hcChmID0+IGYudG9GYWlsdXJlKGdyYW1tYXIpKTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSAnKCcgKyBmcy5qb2luKCcgJykgKyAnKSc7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBkZXNjcmlwdGlvbiwgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9ICcoJyArIHRoaXMuZXhwci50b0ZhaWx1cmUoZ3JhbW1hcikgKyB0aGlzLm9wZXJhdG9yICsgJyknO1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgZGVzY3JpcHRpb24sICdkZXNjcmlwdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgZTEudG9TdHJpbmcoKSA9PT0gZTIudG9TdHJpbmcoKSA9PT4gZTEgYW5kIGUyIGFyZSBzZW1hbnRpY2FsbHkgZXF1aXZhbGVudC5cbiAgTm90ZSB0aGF0IHRoaXMgaXMgbm90IGFuIGlmZiAoPD09Pik6IGUuZy4sXG4gICh+XCJiXCIgXCJhXCIpLnRvU3RyaW5nKCkgIT09IChcImFcIikudG9TdHJpbmcoKSwgZXZlbiB0aG91Z2hcbiAgflwiYlwiIFwiYVwiIGFuZCBcImFcIiBhcmUgaW50ZXJjaGFuZ2VhYmxlIGluIGFueSBncmFtbWFyLFxuICBib3RoIGluIHRlcm1zIG9mIHRoZSBsYW5ndWFnZXMgdGhleSBhY2NlcHQgYW5kIHRoZWlyIGFyaXRpZXMuXG4qL1xucGV4cHJzLlBFeHByLnByb3RvdHlwZS50b1N0cmluZyA9IGNvbW1vbi5hYnN0cmFjdCgndG9TdHJpbmcnKTtcblxucGV4cHJzLmFueS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ2FueSc7XG59O1xuXG5wZXhwcnMuZW5kLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnZW5kJztcbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMub2JqKTtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZnJvbSkgKyAnLi4nICsgSlNPTi5zdHJpbmdpZnkodGhpcy50byk7XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJCcgKyB0aGlzLmluZGV4O1xufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcjKCcgKyB0aGlzLmV4cHIudG9TdHJpbmcoKSArICcpJztcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRlcm1zLmxlbmd0aCA9PT0gMSA/XG4gICAgdGhpcy50ZXJtc1swXS50b1N0cmluZygpIDpcbiAgICAnKCcgKyB0aGlzLnRlcm1zLm1hcCh0ZXJtID0+IHRlcm0udG9TdHJpbmcoKSkuam9pbignIHwgJykgKyAnKSc7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5mYWN0b3JzLmxlbmd0aCA9PT0gMSA/XG4gICAgdGhpcy5mYWN0b3JzWzBdLnRvU3RyaW5nKCkgOlxuICAgICcoJyArIHRoaXMuZmFjdG9ycy5tYXAoZmFjdG9yID0+IGZhY3Rvci50b1N0cmluZygpKS5qb2luKCcgJykgKyAnKSc7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZXhwciArIHRoaXMub3BlcmF0b3I7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ34nICsgdGhpcy5leHByO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcmJyArIHRoaXMuZXhwcjtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcHMgPSB0aGlzLmFyZ3MubWFwKGFyZyA9PiBhcmcudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWUgKyAnPCcgKyBwcy5qb2luKCcsJykgKyAnPic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWU7XG4gIH1cbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdcXFxccHsnICsgdGhpcy5jYXRlZ29yeSArICd9Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBVbmljb2RlQ2F0ZWdvcmllcyA9IHJlcXVpcmUoJy4uL3RoaXJkX3BhcnR5L1VuaWNvZGVDYXRlZ29yaWVzJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gR2VuZXJhbCBzdHVmZlxuXG5jbGFzcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBQRXhwcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEV4cHIgY2Fubm90IGJlIGluc3RhbnRpYXRlZCAtLSBpdCdzIGFic3RyYWN0XCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gdGhlIGludGVydmFsIGNvbnRhaW5pbmcgdGhlIHNvdXJjZSBmb3IgdGhpcyBleHByZXNzaW9uLlxuICB3aXRoU291cmNlKGludGVydmFsKSB7XG4gICAgaWYgKGludGVydmFsKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IGludGVydmFsLnRyaW1tZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLy8gQW55XG5cbmNvbnN0IGFueSA9IE9iamVjdC5jcmVhdGUoUEV4cHIucHJvdG90eXBlKTtcblxuLy8gRW5kXG5cbmNvbnN0IGVuZCA9IE9iamVjdC5jcmVhdGUoUEV4cHIucHJvdG90eXBlKTtcblxuLy8gVGVybWluYWxzXG5cbmNsYXNzIFRlcm1pbmFsIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JqID0gb2JqO1xuICB9XG59XG5cbi8vIFJhbmdlc1xuXG5jbGFzcyBSYW5nZSBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy50byA9IHRvO1xuICB9XG59XG5cbi8vIFBhcmFtZXRlcnNcblxuY2xhc3MgUGFyYW0gZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGluZGV4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cblxuLy8gQWx0ZXJuYXRpb25cblxuY2xhc3MgQWx0IGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3Rvcih0ZXJtcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZXJtcyA9IHRlcm1zO1xuICB9XG59XG5cbi8vIEV4dGVuZCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgcnVsZSBleHRlbnNpb25cblxuY2xhc3MgRXh0ZW5kIGV4dGVuZHMgQWx0IHtcbiAgY29uc3RydWN0b3Ioc3VwZXJHcmFtbWFyLCBuYW1lLCBib2R5KSB7XG4gICAgY29uc3Qgb3JpZ0JvZHkgPSBzdXBlckdyYW1tYXIucnVsZXNbbmFtZV0uYm9keTtcbiAgICBzdXBlcihbYm9keSwgb3JpZ0JvZHldKTtcblxuICAgIHRoaXMuc3VwZXJHcmFtbWFyID0gc3VwZXJHcmFtbWFyO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgfVxufVxuXG4vLyBTcGxpY2UgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIHJ1bGUgb3ZlcnJpZGluZyB3aXRoIHRoZSBgLi4uYCBvcGVyYXRvci5cbmNsYXNzIFNwbGljZSBleHRlbmRzIEFsdCB7XG4gIGNvbnN0cnVjdG9yKHN1cGVyR3JhbW1hciwgcnVsZU5hbWUsIGJlZm9yZVRlcm1zLCBhZnRlclRlcm1zKSB7XG4gICAgY29uc3Qgb3JpZ0JvZHkgPSBzdXBlckdyYW1tYXIucnVsZXNbcnVsZU5hbWVdLmJvZHk7XG4gICAgc3VwZXIoWy4uLmJlZm9yZVRlcm1zLCBvcmlnQm9keSwgLi4uYWZ0ZXJUZXJtc10pO1xuXG4gICAgdGhpcy5zdXBlckdyYW1tYXIgPSBzdXBlckdyYW1tYXI7XG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICAgIHRoaXMuZXhwYW5zaW9uUG9zID0gYmVmb3JlVGVybXMubGVuZ3RoO1xuICB9XG59XG5cbi8vIFNlcXVlbmNlc1xuXG5jbGFzcyBTZXEgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZmFjdG9ycyA9IGZhY3RvcnM7XG4gIH1cbn1cblxuLy8gSXRlcmF0b3JzIGFuZCBvcHRpb25hbHNcblxuY2xhc3MgSXRlciBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZXhwcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgfVxufVxuXG5jbGFzcyBTdGFyIGV4dGVuZHMgSXRlciB7fVxuY2xhc3MgUGx1cyBleHRlbmRzIEl0ZXIge31cbmNsYXNzIE9wdCBleHRlbmRzIEl0ZXIge31cblxuU3Rhci5wcm90b3R5cGUub3BlcmF0b3IgPSAnKic7XG5QbHVzLnByb3RvdHlwZS5vcGVyYXRvciA9ICcrJztcbk9wdC5wcm90b3R5cGUub3BlcmF0b3IgPSAnPyc7XG5cblN0YXIucHJvdG90eXBlLm1pbk51bU1hdGNoZXMgPSAwO1xuUGx1cy5wcm90b3R5cGUubWluTnVtTWF0Y2hlcyA9IDE7XG5PcHQucHJvdG90eXBlLm1pbk51bU1hdGNoZXMgPSAwO1xuXG5TdGFyLnByb3RvdHlwZS5tYXhOdW1NYXRjaGVzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuUGx1cy5wcm90b3R5cGUubWF4TnVtTWF0Y2hlcyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbk9wdC5wcm90b3R5cGUubWF4TnVtTWF0Y2hlcyA9IDE7XG5cbi8vIFByZWRpY2F0ZXNcblxuY2xhc3MgTm90IGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihleHByKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICB9XG59XG5cbmNsYXNzIExvb2thaGVhZCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZXhwcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgfVxufVxuXG4vLyBcIkxleGlmaWNhdGlvblwiXG5cbmNsYXNzIExleCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZXhwcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgfVxufVxuXG4vLyBSdWxlIGFwcGxpY2F0aW9uXG5cbmNsYXNzIEFwcGx5IGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihydWxlTmFtZSwgYXJncz1bXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICBpc1N5bnRhY3RpYygpIHtcbiAgICByZXR1cm4gY29tbW9uLmlzU3ludGFjdGljKHRoaXMucnVsZU5hbWUpO1xuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QganVzdCBjYWNoZXMgdGhlIHJlc3VsdCBvZiBgdGhpcy50b1N0cmluZygpYCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICB0b01lbW9LZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9tZW1vS2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19tZW1vS2V5Jywge3ZhbHVlOiB0aGlzLnRvU3RyaW5nKCl9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21lbW9LZXk7XG4gIH1cbn1cblxuLy8gVW5pY29kZSBjaGFyYWN0ZXJcblxuY2xhc3MgVW5pY29kZUNoYXIgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGNhdGVnb3J5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgdGhpcy5wYXR0ZXJuID0gVW5pY29kZUNhdGVnb3JpZXNbY2F0ZWdvcnldO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLlBFeHByID0gUEV4cHI7XG5leHBvcnRzLmFueSA9IGFueTtcbmV4cG9ydHMuZW5kID0gZW5kO1xuZXhwb3J0cy5UZXJtaW5hbCA9IFRlcm1pbmFsO1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZXhwb3J0cy5QYXJhbSA9IFBhcmFtO1xuZXhwb3J0cy5BbHQgPSBBbHQ7XG5leHBvcnRzLkV4dGVuZCA9IEV4dGVuZDtcbmV4cG9ydHMuU3BsaWNlID0gU3BsaWNlO1xuZXhwb3J0cy5TZXEgPSBTZXE7XG5leHBvcnRzLkl0ZXIgPSBJdGVyO1xuZXhwb3J0cy5TdGFyID0gU3RhcjtcbmV4cG9ydHMuUGx1cyA9IFBsdXM7XG5leHBvcnRzLk9wdCA9IE9wdDtcbmV4cG9ydHMuTm90ID0gTm90O1xuZXhwb3J0cy5Mb29rYWhlYWQgPSBMb29rYWhlYWQ7XG5leHBvcnRzLkxleCA9IExleDtcbmV4cG9ydHMuQXBwbHkgPSBBcHBseTtcbmV4cG9ydHMuVW5pY29kZUNoYXIgPSBVbmljb2RlQ2hhcjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuc2lvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnJlcXVpcmUoJy4vcGV4cHJzLWFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWFzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkJyk7XG5yZXF1aXJlKCcuL3BleHBycy1hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eScpO1xucmVxdWlyZSgnLi9wZXhwcnMtYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlJyk7XG5yZXF1aXJlKCcuL3BleHBycy1jaGVjaycpO1xucmVxdWlyZSgnLi9wZXhwcnMtZXZhbCcpO1xucmVxdWlyZSgnLi9wZXhwcnMtZ2V0QXJpdHknKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWdlbmVyYXRlRXhhbXBsZScpO1xucmVxdWlyZSgnLi9wZXhwcnMtb3V0cHV0UmVjaXBlJyk7XG5yZXF1aXJlKCcuL3BleHBycy1pbnRyb2R1Y2VQYXJhbXMnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWlzTnVsbGFibGUnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXN1YnN0aXR1dGVQYXJhbXMnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXRvRGlzcGxheVN0cmluZycpO1xucmVxdWlyZSgnLi9wZXhwcnMtdG9Bcmd1bWVudE5hbWVMaXN0Jyk7XG5yZXF1aXJlKCcuL3BleHBycy10b0ZhaWx1cmUnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXRvU3RyaW5nJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycyBgYXJyYCwgcmV0dXJuIGFuIGFycmF5IG9mIHRoZSBudW1iZXJzIGFzIHN0cmluZ3MsXG4vLyByaWdodC1qdXN0aWZpZWQgYW5kIHBhZGRlZCB0byB0aGUgc2FtZSBsZW5ndGguXG5mdW5jdGlvbiBwYWROdW1iZXJzVG9FcXVhbExlbmd0aChhcnIpIHtcbiAgbGV0IG1heExlbiA9IDA7XG4gIGNvbnN0IHN0cmluZ3MgPSBhcnIubWFwKG4gPT4ge1xuICAgIGNvbnN0IHN0ciA9IG4udG9TdHJpbmcoKTtcbiAgICBtYXhMZW4gPSBNYXRoLm1heChtYXhMZW4sIHN0ci5sZW5ndGgpO1xuICAgIHJldHVybiBzdHI7XG4gIH0pO1xuICByZXR1cm4gc3RyaW5ncy5tYXAocyA9PiBjb21tb24ucGFkTGVmdChzLCBtYXhMZW4pKTtcbn1cblxuLy8gUHJvZHVjZSBhIG5ldyBzdHJpbmcgdGhhdCB3b3VsZCBiZSB0aGUgcmVzdWx0IG9mIGNvcHlpbmcgdGhlIGNvbnRlbnRzXG4vLyBvZiB0aGUgc3RyaW5nIGBzcmNgIG9udG8gYGRlc3RgIGF0IG9mZnNldCBgb2ZmZXN0YC5cbmZ1bmN0aW9uIHN0cmNweShkZXN0LCBzcmMsIG9mZnNldCkge1xuICBjb25zdCBvcmlnRGVzdExlbiA9IGRlc3QubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IGRlc3Quc2xpY2UoMCwgb2Zmc2V0KTtcbiAgY29uc3QgZW5kID0gZGVzdC5zbGljZShvZmZzZXQgKyBzcmMubGVuZ3RoKTtcbiAgcmV0dXJuIChzdGFydCArIHNyYyArIGVuZCkuc3Vic3RyKDAsIG9yaWdEZXN0TGVuKTtcbn1cblxuLy8gQ2FzdHMgdGhlIHVuZGVybHlpbmcgbGluZUFuZENvbCBvYmplY3QgdG8gYSBmb3JtYXR0ZWQgbWVzc2FnZSBzdHJpbmcsXG4vLyBoaWdobGlnaHRpbmcgYHJhbmdlc2AuXG5mdW5jdGlvbiBsaW5lQW5kQ29sdW1uVG9NZXNzYWdlKC4uLnJhbmdlcykge1xuICBjb25zdCBsaW5lQW5kQ29sID0gdGhpcztcbiAgY29uc3Qgb2Zmc2V0ID0gbGluZUFuZENvbC5vZmZzZXQ7XG4gIGNvbnN0IHJlcGVhdFN0ciA9IGNvbW1vbi5yZXBlYXRTdHI7XG5cbiAgY29uc3Qgc2IgPSBuZXcgY29tbW9uLlN0cmluZ0J1ZmZlcigpO1xuICBzYi5hcHBlbmQoJ0xpbmUgJyArIGxpbmVBbmRDb2wubGluZU51bSArICcsIGNvbCAnICsgbGluZUFuZENvbC5jb2xOdW0gKyAnOlxcbicpO1xuXG4gIC8vIEFuIGFycmF5IG9mIHRoZSBwcmV2aW91cywgY3VycmVudCwgYW5kIG5leHQgbGluZSBudW1iZXJzIGFzIHN0cmluZ3Mgb2YgZXF1YWwgbGVuZ3RoLlxuICBjb25zdCBsaW5lTnVtYmVycyA9IHBhZE51bWJlcnNUb0VxdWFsTGVuZ3RoKFtcbiAgICBsaW5lQW5kQ29sLnByZXZMaW5lID09IG51bGwgPyAwIDogbGluZUFuZENvbC5saW5lTnVtIC0gMSxcbiAgICBsaW5lQW5kQ29sLmxpbmVOdW0sXG4gICAgbGluZUFuZENvbC5uZXh0TGluZSA9PSBudWxsID8gMCA6IGxpbmVBbmRDb2wubGluZU51bSArIDFcbiAgXSk7XG5cbiAgLy8gSGVscGVyIGZvciBhcHBlbmRpbmcgZm9ybWF0dGluZyBpbnB1dCBsaW5lcyB0byB0aGUgYnVmZmVyLlxuICBjb25zdCBhcHBlbmRMaW5lID0gKG51bSwgY29udGVudCwgcHJlZml4KSA9PiB7XG4gICAgc2IuYXBwZW5kKHByZWZpeCArIGxpbmVOdW1iZXJzW251bV0gKyAnIHwgJyArIGNvbnRlbnQgKyAnXFxuJyk7XG4gIH07XG5cbiAgLy8gSW5jbHVkZSB0aGUgcHJldmlvdXMgbGluZSBmb3IgY29udGV4dCBpZiBwb3NzaWJsZS5cbiAgaWYgKGxpbmVBbmRDb2wucHJldkxpbmUgIT0gbnVsbCkge1xuICAgIGFwcGVuZExpbmUoMCwgbGluZUFuZENvbC5wcmV2TGluZSwgJyAgJyk7XG4gIH1cbiAgLy8gTGluZSB0aGF0IHRoZSBlcnJvciBvY2N1cnJlZCBvbi5cbiAgYXBwZW5kTGluZSgxLCBsaW5lQW5kQ29sLmxpbmUsICc+ICcpO1xuXG4gIC8vIEJ1aWxkIHVwIHRoZSBsaW5lIHRoYXQgcG9pbnRzIHRvIHRoZSBvZmZzZXQgYW5kIHBvc3NpYmxlIGluZGljYXRlcyBvbmUgb3IgbW9yZSByYW5nZXMuXG4gIC8vIFN0YXJ0IHdpdGggYSBibGFuayBsaW5lLCBhbmQgaW5kaWNhdGUgZWFjaCByYW5nZSBieSBvdmVybGF5aW5nIGEgc3RyaW5nIG9mIGB+YCBjaGFycy5cbiAgY29uc3QgbGluZUxlbiA9IGxpbmVBbmRDb2wubGluZS5sZW5ndGg7XG4gIGxldCBpbmRpY2F0aW9uTGluZSA9IHJlcGVhdFN0cignICcsIGxpbmVMZW4gKyAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgc3RhcnRJZHggPSByYW5nZXNbaV1bMF07XG4gICAgbGV0IGVuZElkeCA9IHJhbmdlc1tpXVsxXTtcbiAgICBjb21tb24uYXNzZXJ0KHN0YXJ0SWR4ID49IDAgJiYgc3RhcnRJZHggPD0gZW5kSWR4LCAncmFuZ2Ugc3RhcnQgbXVzdCBiZSA+PSAwIGFuZCA8PSBlbmQnKTtcblxuICAgIGNvbnN0IGxpbmVTdGFydE9mZnNldCA9IG9mZnNldCAtIGxpbmVBbmRDb2wuY29sTnVtICsgMTtcbiAgICBzdGFydElkeCA9IE1hdGgubWF4KDAsIHN0YXJ0SWR4IC0gbGluZVN0YXJ0T2Zmc2V0KTtcbiAgICBlbmRJZHggPSBNYXRoLm1pbihlbmRJZHggLSBsaW5lU3RhcnRPZmZzZXQsIGxpbmVMZW4pO1xuXG4gICAgaW5kaWNhdGlvbkxpbmUgPSBzdHJjcHkoaW5kaWNhdGlvbkxpbmUsIHJlcGVhdFN0cignficsIGVuZElkeCAtIHN0YXJ0SWR4KSwgc3RhcnRJZHgpO1xuICB9XG4gIGNvbnN0IGd1dHRlcldpZHRoID0gMiArIGxpbmVOdW1iZXJzWzFdLmxlbmd0aCArIDM7XG4gIHNiLmFwcGVuZChyZXBlYXRTdHIoJyAnLCBndXR0ZXJXaWR0aCkpO1xuICBpbmRpY2F0aW9uTGluZSA9IHN0cmNweShpbmRpY2F0aW9uTGluZSwgJ14nLCBsaW5lQW5kQ29sLmNvbE51bSAtIDEpO1xuICBzYi5hcHBlbmQoaW5kaWNhdGlvbkxpbmUucmVwbGFjZSgvICskLywgJycpICsgJ1xcbicpO1xuXG4gIC8vIEluY2x1ZGUgdGhlIG5leHQgbGluZSBmb3IgY29udGV4dCBpZiBwb3NzaWJsZS5cbiAgaWYgKGxpbmVBbmRDb2wubmV4dExpbmUgIT0gbnVsbCkge1xuICAgIGFwcGVuZExpbmUoMiwgbGluZUFuZENvbC5uZXh0TGluZSwgJyAgJyk7XG4gIH1cbiAgcmV0dXJuIHNiLmNvbnRlbnRzKCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubGV0IGJ1aWx0SW5SdWxlc0NhbGxiYWNrcyA9IFtdO1xuXG4vLyBTaW5jZSBHcmFtbWFyLkJ1aWx0SW5SdWxlcyBpcyBib290c3RyYXBwZWQsIG1vc3Qgb2YgT2htIGNhbid0IGRpcmVjdGx5IGRlcGVuZCBpdC5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIG1vZHVsZXMgdGhhdCBkbyBkZXBlbmQgb24gdGhlIGJ1aWx0LWluIHJ1bGVzIHRvIHJlZ2lzdGVyIGEgY2FsbGJhY2tcbi8vIHRoYXQgd2lsbCBiZSBjYWxsZWQgbGF0ZXIgaW4gdGhlIGluaXRpYWxpemF0aW9uIHByb2Nlc3MuXG5leHBvcnRzLmF3YWl0QnVpbHRJblJ1bGVzID0gY2IgPT4ge1xuICBidWlsdEluUnVsZXNDYWxsYmFja3MucHVzaChjYik7XG59O1xuXG5leHBvcnRzLmFubm91bmNlQnVpbHRJblJ1bGVzID0gZ3JhbW1hciA9PiB7XG4gIGJ1aWx0SW5SdWxlc0NhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICBjYihncmFtbWFyKTtcbiAgfSk7XG4gIGJ1aWx0SW5SdWxlc0NhbGxiYWNrcyA9IG51bGw7XG59O1xuXG4vLyBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdpdmVuXG4vLyBvZmZzZXQgaW4gYHN0cmAuXG5leHBvcnRzLmdldExpbmVBbmRDb2x1bW4gPSAoc3RyLCBvZmZzZXQpID0+IHtcbiAgbGV0IGxpbmVOdW0gPSAxO1xuICBsZXQgY29sTnVtID0gMTtcblxuICBsZXQgY3Vyck9mZnNldCA9IDA7XG4gIGxldCBsaW5lU3RhcnRPZmZzZXQgPSAwO1xuXG4gIGxldCBuZXh0TGluZSA9IG51bGw7XG4gIGxldCBwcmV2TGluZSA9IG51bGw7XG4gIGxldCBwcmV2TGluZVN0YXJ0T2Zmc2V0ID0gLTE7XG5cbiAgd2hpbGUgKGN1cnJPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICBjb25zdCBjID0gc3RyLmNoYXJBdChjdXJyT2Zmc2V0KyspO1xuICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgbGluZU51bSsrO1xuICAgICAgY29sTnVtID0gMTtcbiAgICAgIHByZXZMaW5lU3RhcnRPZmZzZXQgPSBsaW5lU3RhcnRPZmZzZXQ7XG4gICAgICBsaW5lU3RhcnRPZmZzZXQgPSBjdXJyT2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAoYyAhPT0gJ1xccicpIHtcbiAgICAgIGNvbE51bSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGVuZCBvZiB0aGUgdGFyZ2V0IGxpbmUuXG4gIGxldCBsaW5lRW5kT2Zmc2V0ID0gc3RyLmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydE9mZnNldCk7XG4gIGlmIChsaW5lRW5kT2Zmc2V0ID09PSAtMSkge1xuICAgIGxpbmVFbmRPZmZzZXQgPSBzdHIubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBsaW5lLlxuICAgIGNvbnN0IG5leHRMaW5lRW5kT2Zmc2V0ID0gc3RyLmluZGV4T2YoJ1xcbicsIGxpbmVFbmRPZmZzZXQgKyAxKTtcbiAgICBuZXh0TGluZSA9IG5leHRMaW5lRW5kT2Zmc2V0ID09PSAtMSA/IHN0ci5zbGljZShsaW5lRW5kT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3RyLnNsaWNlKGxpbmVFbmRPZmZzZXQsIG5leHRMaW5lRW5kT2Zmc2V0KTtcbiAgICAvLyBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBFT0wgY2hhcihzKS5cbiAgICBuZXh0TGluZSA9IG5leHRMaW5lLnJlcGxhY2UoL15cXHI/XFxuLywgJycpLnJlcGxhY2UoL1xcciQvLCAnJyk7XG4gIH1cblxuICAvLyBHZXQgdGhlIHByZXZpb3VzIGxpbmUuXG4gIGlmIChwcmV2TGluZVN0YXJ0T2Zmc2V0ID49IDApIHtcbiAgICBwcmV2TGluZSA9IHN0ci5zbGljZShwcmV2TGluZVN0YXJ0T2Zmc2V0LCBsaW5lU3RhcnRPZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKC9cXHI/XFxuJC8sICcnKTsgLy8gU3RyaXAgdHJhaWxpbmcgRU9MIGNoYXIocykuXG4gIH1cblxuICAvLyBHZXQgdGhlIHRhcmdldCBsaW5lLCBzdHJpcHBpbmcgYSB0cmFpbGluZyBjYXJyaWFnZSByZXR1cm4gaWYgbmVjZXNzYXJ5LlxuICBjb25zdCBsaW5lID0gc3RyLnNsaWNlKGxpbmVTdGFydE9mZnNldCwgbGluZUVuZE9mZnNldCkucmVwbGFjZSgvXFxyJC8sICcnKTtcblxuICByZXR1cm4ge1xuICAgIG9mZnNldCxcbiAgICBsaW5lTnVtLFxuICAgIGNvbE51bSxcbiAgICBsaW5lLFxuICAgIHByZXZMaW5lLFxuICAgIG5leHRMaW5lLFxuICAgIHRvU3RyaW5nOiBsaW5lQW5kQ29sdW1uVG9NZXNzYWdlXG4gIH07XG59O1xuXG4vLyBSZXR1cm4gYSBuaWNlbHktZm9ybWF0dGVkIHN0cmluZyBkZXNjcmliaW5nIHRoZSBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoZVxuLy8gZ2l2ZW4gb2Zmc2V0IGluIGBzdHJgIGhpZ2hsaWdodGluZyBgcmFuZ2VzYC5cbmV4cG9ydHMuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UgPSBmdW5jdGlvbihzdHIsIG9mZnNldCwgLi4ucmFuZ2VzKSB7XG4gIHJldHVybiBleHBvcnRzLmdldExpbmVBbmRDb2x1bW4oc3RyLCBvZmZzZXQpLnRvU3RyaW5nKC4uLnJhbmdlcyk7XG59O1xuXG5leHBvcnRzLnVuaXF1ZUlkID0gKCgpID0+IHtcbiAgbGV0IGlkQ291bnRlciA9IDA7XG4gIHJldHVybiBwcmVmaXggPT4gJycgKyBwcmVmaXggKyBpZENvdW50ZXIrKztcbn0pKCk7XG4iLCIvKiBnbG9iYWwgX19HTE9CQUxfT0hNX1ZFUlNJT05fXyAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFdoZW4gcnVubmluZyB1bmRlciBOb2RlLCByZWFkIHRoZSB2ZXJzaW9uIGZyb20gcGFja2FnZS5qc29uLiBGb3IgdGhlIGJyb3dzZXIsXG4vLyB1c2UgYSBzcGVjaWFsIGdsb2JhbCB2YXJpYWJsZSBkZWZpbmVkIGluIHRoZSBidWlsZCBwcm9jZXNzIChzZWUgd2VicGFjay5jb25maWcuanMpLlxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgX19HTE9CQUxfT0hNX1ZFUlNJT05fXyA9PT0gJ3N0cmluZydcbiAgICA/IF9fR0xPQkFMX09ITV9WRVJTSU9OX19cbiAgICA6IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4iLCIvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTkuMC4wLlxuLy8gVGhlc2UgYXJlIGp1c3QgY2F0ZWdvcmllcyB0aGF0IGFyZSB1c2VkIGluIEVTNS9FUzIwMTUuXG4vLyBUaGUgZnVsbCBsaXN0IG9mIFVuaWNvZGUgY2F0ZWdvcmllcyBpcyBoZXJlOiBodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9pbmZvL3VuaWNvZGUvY2F0ZWdvcnkvaW5kZXguaHRtLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIExldHRlcnNcbiAgTHU6IC9bQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE4M1xcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FFXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQV18XFx1RDgwMVtcXHVEQzAwLVxcdURDMjdcXHVEQ0IwLVxcdURDRDNdfFxcdUQ4MDNbXFx1REM4MC1cXHVEQ0IyXXxcXHVEODA2W1xcdURDQTAtXFx1RENCRl18XFx1RDgzNVtcXHVEQzAwLVxcdURDMTlcXHVEQzM0LVxcdURDNERcXHVEQzY4LVxcdURDODFcXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjVcXHVEQ0QwLVxcdURDRTlcXHVERDA0XFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMzhcXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENkMtXFx1REQ4NVxcdUREQTAtXFx1RERCOVxcdURERDQtXFx1RERFRFxcdURFMDgtXFx1REUyMVxcdURFM0MtXFx1REU1NVxcdURFNzAtXFx1REU4OVxcdURFQTgtXFx1REVDMFxcdURFRTItXFx1REVGQVxcdURGMUMtXFx1REYzNFxcdURGNTYtXFx1REY2RVxcdURGOTAtXFx1REZBOFxcdURGQ0FdfFxcdUQ4M0FbXFx1REQwMC1cXHVERDIxXS8sXG4gIExsOiAvW2EtelxceEI1XFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJBRlxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0ItXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxQzgwLVxcdTFDODhcXHUxRDAwLVxcdTFEMkJcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEOUFcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTg0XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdCXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2RlxcdUE3NzEtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI2MC1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBXXxcXHVEODAxW1xcdURDMjgtXFx1REM0RlxcdURDRDgtXFx1RENGQl18XFx1RDgwM1tcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDZbXFx1RENDMC1cXHVEQ0RGXXxcXHVEODM1W1xcdURDMUEtXFx1REMzM1xcdURDNEUtXFx1REM1NFxcdURDNTYtXFx1REM2N1xcdURDODItXFx1REM5QlxcdURDQjYtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdURDQ0ZcXHVEQ0VBLVxcdUREMDNcXHVERDFFLVxcdUREMzdcXHVERDUyLVxcdURENkJcXHVERDg2LVxcdUREOUZcXHVEREJBLVxcdURERDNcXHVEREVFLVxcdURFMDdcXHVERTIyLVxcdURFM0JcXHVERTU2LVxcdURFNkZcXHVERThBLVxcdURFQTVcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRTFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMUJcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNTVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGOEZcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQzlcXHVERkNCXXxcXHVEODNBW1xcdUREMjItXFx1REQ0M10vLFxuICBMdDogL1tcXHUwMUM1XFx1MDFDOFxcdTAxQ0JcXHUwMUYyXFx1MUY4OC1cXHUxRjhGXFx1MUY5OC1cXHUxRjlGXFx1MUZBOC1cXHUxRkFGXFx1MUZCQ1xcdTFGQ0NcXHUxRkZDXS8sXG4gIExtOiAvW1xcdTAyQjAtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3NFxcdTAzN0FcXHUwNTU5XFx1MDY0MFxcdTA2RTVcXHUwNkU2XFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDk3MVxcdTBFNDZcXHUwRUM2XFx1MTBGQ1xcdTE3RDdcXHUxODQzXFx1MUFBN1xcdTFDNzgtXFx1MUM3RFxcdTFEMkMtXFx1MUQ2QVxcdTFENzhcXHUxRDlCLVxcdTFEQkZcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTJDN0NcXHUyQzdEXFx1MkQ2RlxcdTJFMkZcXHUzMDA1XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwOURcXHUzMDlFXFx1MzBGQy1cXHUzMEZFXFx1QTAxNVxcdUE0RjgtXFx1QTRGRFxcdUE2MENcXHVBNjdGXFx1QTY5Q1xcdUE2OURcXHVBNzE3LVxcdUE3MUZcXHVBNzcwXFx1QTc4OFxcdUE3RjhcXHVBN0Y5XFx1QTlDRlxcdUE5RTZcXHVBQTcwXFx1QUFERFxcdUFBRjNcXHVBQUY0XFx1QUI1Qy1cXHVBQjVGXFx1RkY3MFxcdUZGOUVcXHVGRjlGXXxcXHVEODFBW1xcdURGNDAtXFx1REY0M118XFx1RDgxQltcXHVERjkzLVxcdURGOUZcXHVERkUwXS8sXG4gIExvOiAvW1xceEFBXFx4QkFcXHUwMUJCXFx1MDFDMC1cXHUwMUMzXFx1MDI5NFxcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDYzRlxcdTA2NDEtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDgwMC1cXHUwODE1XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcyLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDVcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwRDAtXFx1MTBGQVxcdTEwRkQtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEQ1xcdTE4MjAtXFx1MTg0MlxcdTE4NDQtXFx1MTg3N1xcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3N1xcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MjEzNS1cXHUyMTM4XFx1MkQzMC1cXHUyRDY3XFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTAxNFxcdUEwMTYtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGN1xcdUE1MDAtXFx1QTYwQlxcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY2RVxcdUE2QTAtXFx1QTZFNVxcdUE3OEZcXHVBN0Y3XFx1QTdGQi1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUUwLVxcdUE5RTRcXHVBOUU3LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNkZcXHVBQTcxLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCXFx1QUFEQ1xcdUFBRTAtXFx1QUFFQVxcdUFBRjJcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjY2LVxcdUZGNkZcXHVGRjcxLVxcdUZGOURcXHVGRkEwLVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MDFbXFx1REM1MC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4Rl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuXG4gIC8vIE51bWJlcnNcbiAgTmw6IC9bXFx1MTZFRS1cXHUxNkYwXFx1MjE2MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg4XFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdUE2RTYtXFx1QTZFRl18XFx1RDgwMFtcXHVERDQwLVxcdURENzRcXHVERjQxXFx1REY0QVxcdURGRDEtXFx1REZENV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVdLyxcbiAgTmQ6IC9bMC05XFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEJFNi1cXHUwQkVGXFx1MEM2Ni1cXHUwQzZGXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDZGXFx1MERFNi1cXHUwREVGXFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTdFMC1cXHUxN0U5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOUQ5XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1QTYyMC1cXHVBNjI5XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QTlGMC1cXHVBOUY5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5XXxcXHVEODAxW1xcdURDQTAtXFx1RENBOV18XFx1RDgwNFtcXHVEQzY2LVxcdURDNkZcXHVEQ0YwLVxcdURDRjlcXHVERDM2LVxcdUREM0ZcXHVEREQwLVxcdURERDlcXHVERUYwLVxcdURFRjldfFtcXHVEODA1XFx1RDgwN11bXFx1REM1MC1cXHVEQzU5XFx1RENEMC1cXHVEQ0Q5XFx1REU1MC1cXHVERTU5XFx1REVDMC1cXHVERUM5XFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDRTAtXFx1RENFOV18XFx1RDgxQVtcXHVERTYwLVxcdURFNjlcXHVERjUwLVxcdURGNTldfFxcdUQ4MzVbXFx1REZDRS1cXHVERkZGXXxcXHVEODNBW1xcdURENTAtXFx1REQ1OV0vLFxuXG4gIC8vIE1hcmtzXG4gIE1uOiAvW1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RTJcXHUwOUUzXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBCMDFcXHUwQjNDXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU2XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJDMFxcdTBCQ0RcXHUwQzAwXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRTJcXHUwQ0UzXFx1MEQwMVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDYyXFx1MEQ2M1xcdTBEQ0FcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQjlcXHUwRUJCXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCMDNcXHUxQjM0XFx1MUIzNi1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGNVxcdTFERkItXFx1MURGRlxcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJEXFx1MzA5OVxcdTMwOUFcXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVERENBLVxcdUREQ0NcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQ1xcdURGNDBcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjhGLVxcdURGOTJdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2Ny1cXHVERDY5XFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1REI0MFtcXHVERDAwLVxcdURERUZdLyxcbiAgTWM6IC9bXFx1MDkwMy1cXHUwOTAzXXxbXFx1MDkzRS1cXHUwOTQwXXxbXFx1MDk0OS1cXHUwOTRDXXxbXFx1MDk4Mi1cXHUwOTgzXXxbXFx1MDlCRS1cXHUwOUMwXXxbXFx1MDlDNy1cXHUwOUM4XXxbXFx1MDlDQi1cXHUwOUNDXXxbXFx1MDlENy1cXHUwOUQ3XXxbXFx1MEEzRS1cXHUwQTQwXXxbXFx1MEE4My1cXHUwQTgzXXxbXFx1MEFCRS1cXHUwQUMwXXxbXFx1MEFDOS1cXHUwQUM5XXxbXFx1MEFDQi1cXHUwQUNDXXxbXFx1MEIwMi1cXHUwQjAzXXxbXFx1MEIzRS1cXHUwQjNFXXxbXFx1MEI0MC1cXHUwQjQwXXxbXFx1MEI0Ny1cXHUwQjQ4XXxbXFx1MEI0Qi1cXHUwQjRDXXxbXFx1MEI1Ny1cXHUwQjU3XXxbXFx1MEI4My1cXHUwQjgzXXxbXFx1MEJCRS1cXHUwQkJGXXxbXFx1MEJDMS1cXHUwQkMyXXxbXFx1MEJDNi1cXHUwQkM4XXxbXFx1MEJDQS1cXHUwQkNDXXxbXFx1MEJENy1cXHUwQkQ3XXxbXFx1MEMwMS1cXHUwQzAzXXxbXFx1MEM0MS1cXHUwQzQ0XXxbXFx1MEM4Mi1cXHUwQzgzXXxbXFx1MENCRS1cXHUwQ0JFXXxbXFx1MENDMC1cXHUwQ0M0XXxbXFx1MENDNy1cXHUwQ0M4XXxbXFx1MENDQS1cXHUwQ0NCXXxbXFx1MENENS1cXHUwQ0Q2XXxbXFx1MEQwMi1cXHUwRDAzXXxbXFx1MEQzRS1cXHUwRDQwXXxbXFx1MEQ0Ni1cXHUwRDQ4XXxbXFx1MEQ0QS1cXHUwRDRDXXxbXFx1MEQ1Ny1cXHUwRDU3XXxbXFx1MEYzRS1cXHUwRjNGXXxbXFx1MEY3Ri1cXHUwRjdGXS8sXG5cbiAgLy8gUHVuY3R1YXRpb24sIENvbm5lY3RvclxuICBQYzogL1tfXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRjNGXS8sXG5cbiAgLy8gU2VwYXJhdG9yLCBTcGFjZVxuICBaczogL1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS8sXG5cbiAgLy8gVGhlc2UgdHdvIGFyZSBub3QgcmVhbCBVbmljb2RlIGNhdGVnb3JpZXMsIGJ1dCBvdXIgdXNlZnVsIGZvciBPaG0uXG4gIC8vIEwgaXMgYSBjb21iaW5hdGlvbiBvZiBhbGwgdGhlIGxldHRlciBjYXRlZ29yaWVzLlxuICAvLyBMdG1vIGlzIGEgY29tYmluYXRpb24gb2YgTHQsIExtLCBhbmQgTG8uXG4gIEw6IC9bQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTgzXFx1MjE4NFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDVcXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFNVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXG4gIEx0bW86IC9bXFx1MDFDNVxcdTAxQzhcXHUwMUNCXFx1MDFGMlxcdTFGODgtXFx1MUY4RlxcdTFGOTgtXFx1MUY5RlxcdTFGQTgtXFx1MUZBRlxcdTFGQkNcXHUxRkNDXFx1MUZGQ118W1xcdTAyQjAtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3NFxcdTAzN0FcXHUwNTU5XFx1MDY0MFxcdTA2RTVcXHUwNkU2XFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDk3MVxcdTBFNDZcXHUwRUM2XFx1MTBGQ1xcdTE3RDdcXHUxODQzXFx1MUFBN1xcdTFDNzgtXFx1MUM3RFxcdTFEMkMtXFx1MUQ2QVxcdTFENzhcXHUxRDlCLVxcdTFEQkZcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTJDN0NcXHUyQzdEXFx1MkQ2RlxcdTJFMkZcXHUzMDA1XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwOURcXHUzMDlFXFx1MzBGQy1cXHUzMEZFXFx1QTAxNVxcdUE0RjgtXFx1QTRGRFxcdUE2MENcXHVBNjdGXFx1QTY5Q1xcdUE2OURcXHVBNzE3LVxcdUE3MUZcXHVBNzcwXFx1QTc4OFxcdUE3RjhcXHVBN0Y5XFx1QTlDRlxcdUE5RTZcXHVBQTcwXFx1QUFERFxcdUFBRjNcXHVBQUY0XFx1QUI1Qy1cXHVBQjVGXFx1RkY3MFxcdUZGOUVcXHVGRjlGXXxcXHVEODFBW1xcdURGNDAtXFx1REY0M118XFx1RDgxQltcXHVERjkzLVxcdURGOUZcXHVERkUwXXxbXFx4QUFcXHhCQVxcdTAxQkJcXHUwMUMwLVxcdTAxQzNcXHUwMjk0XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjNGXFx1MDY0MS1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwODAwLVxcdTA4MTVcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzItXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBEMC1cXHUxMEZBXFx1MTBGRC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0RDXFx1MTgyMC1cXHUxODQyXFx1MTg0NC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzc3XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUyMTM1LVxcdTIxMzhcXHUyRDMwLVxcdTJENjdcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA2XFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBMDE0XFx1QTAxNi1cXHVBNDhDXFx1QTREMC1cXHVBNEY3XFx1QTUwMC1cXHVBNjBCXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjZFXFx1QTZBMC1cXHVBNkU1XFx1QTc4RlxcdUE3RjdcXHVBN0ZCLVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5RTAtXFx1QTlFNFxcdUE5RTctXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE2RlxcdUFBNzEtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREJcXHVBQURDXFx1QUFFMC1cXHVBQUVBXFx1QUFGMlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGNjYtXFx1RkY2RlxcdUZGNzEtXFx1RkY5RFxcdUZGQTAtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwMVtcXHVEQzUwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OF18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS9cbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5mdW5jdGlvbiBleHRlbmQob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCB0eXBlb2YgYWRkICE9PSAnb2JqZWN0JykgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn1cbiIsInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcbnZhciB2NCA9IHJlcXVpcmUoJy4vdjQnKTtcblxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW1xuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXG4gIF0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG52YXIgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgdmFyIHNlZWRCeXRlcyA9IHJuZygpO1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbXG4gICAgICAgIHNlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgICAgIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH1cblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgPyBidWYgOiBieXRlc1RvVXVpZChiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2MTtcbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iLCJjb25zdCBtZXJyaWFtID0ge1xuICAgIG5hbWU6IFwiTWVycmlhbUFQSVwiLFxuICAgIGxvYWQ6IGZ1bmN0aW9uKHVybCl7XG4gICAgICAgIHRoaXMuc3JjID0gdXJsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHJlc3BvbnNlOiBudWxsLFxuICAgIGNhY2hlOiBudWxsLFxuICAgIGNhY2hlTmV4dEl0ZW06IG51bGwsXG4gICAgY3VycmVudFJlc3BvbnNlSXRlbUluZGV4OiAtMSxcbiAgICBzcmM6IG51bGwsXG4gICAgZ2V0OiBhc3luYyBmdW5jdGlvbihwcmVyZXF1aXNpdGUsIGFyZyl7XG4gICAgICAgIGlmKGFyZyl7XG4gICAgICAgICAgICBpZighdGhpcy5jYWNoZSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJObyByZXN1bHQgaGFzIGJlZW4gZmV0Y2hlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFyZyA9PSBcIm5leHRcIil7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSB0aGlzLmNhY2hlLnJlc3VsdHM7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzcG9uc2VJdGVtSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleCA+PSByZXN1bHRzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlSXRlbUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMuY2FjaGUucmVzdWx0c1t0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleF07XG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSByZXN1bHQgaW4gdGhlIG5leHQgaXRlbSBjYWNoZVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVOZXh0SXRlbSA9IHRoaXMuY2FjaGUucmVzdWx0c1t0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucmVzcG9uc2UsIG51bGwsICdcXHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlcmUgd2UgYXNzdW1lIHRoYXQgdGhlIGFyZyBpcyBhIGtleSBpbiB0aGUgbmV4dCBpdGVtIGNhY2hlXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5jYWNoZU5leHRJdGVtW2FyZ107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VQcmVyZXF1aXNpdGUocHJlcmVxdWlzaXRlKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgICAgICBcImhlYWRlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJib2R5XCI6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuc3JjLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHsgLy8gaWYgSFRUUC1zdGF0dXMgaXMgMjAwLTI5OVxuICAgICAgICAgICAgLy8gZ2V0IHRoZSByZXNwb25zZSBib2R5ICh0aGUgbWV0aG9kIGV4cGxhaW5lZCBiZWxvdylcbiAgICAgICAgICAgIGxldCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IGpzb247XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0ganNvbjtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJlc3BvbnNlLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSFRUUC1FcnJvcjogXCIgKyByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG5sZXQgcGFyc2VQcmVyZXF1aXNpdGUgPSAocCkgPT4ge1xuICAgIGxldCBwTGlzdCA9IHAuc3BsaXQoXCI7XCIpO1xuICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgcExpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBsZXQga2V5ID0gaXRlbS5zcGxpdChcIjpcIilbMF07XG4gICAgICAgIGxldCB2YWx1ZSA9IGl0ZW0ucmVwbGFjZShgJHtrZXl9OmAsIFwiXCIpO1xuICAgICAgICBzd2l0Y2goa2V5KXtcbiAgICAgICAgY2FzZSBcImZpZWxkc1wiOlxuICAgICAgICAgICAgcGF5bG9hZFtcImZpZWxkc1wiXSA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndlaWdodHNcIjpcbiAgICAgICAgICAgIGxldCB3ZWlnaHRzID0ge307XG4gICAgICAgICAgICB2YWx1ZS5zcGxpdChcIixcIikuZm9yRWFjaCgodykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBbd19uYW1lLCB3X3ZhbHVlXSA9IHcuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgIHdlaWdodHNbd19uYW1lXSA9IE51bWJlcih3X3ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGF5bG9hZFtcIndlaWdodHNcIl0gPSB3ZWlnaHRzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkb2NfaWRzXCI6XG4gICAgICAgICAgICBwYXlsb2FkW1wiZG9jX2lkc1wiXSA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGltaXRcIjpcbiAgICAgICAgICAgIHBheWxvYWRbXCJsaW1pdFwiXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXlsb2FkO1xufVxuXG5cbmV4cG9ydCB7XG4gICAgbWVycmlhbSxcbiAgICBtZXJyaWFtIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgVGVzdCBmcm9tICcuL3Rlc3RBUEkuanMnO1xuaW1wb3J0IE1lcnJpYW0gZnJvbSAnLi9tZXJyaWFtLmpzJztcblxuY29uc3QgcGx1Z2lucyA9IHtcbiAgICBcIk1lcnJpYW1BUElcIjogTWVycmlhbSxcbiAgICBcIlRlc3RBUElcIjogVGVzdFxufVxuXG5leHBvcnQge1xuICAgIHBsdWdpbnMsXG4gICAgcGx1Z2lucyBhcyBkZWZhdWx0XG59XG4iLCJjb25zdCB0ZXN0ID0ge1xuICAgIG5hbWU6IFwiVGVzdEFQSVwiLFxuICAgIGxvYWQ6IGZ1bmN0aW9uKHVybCl7XG4gICAgICAgIHRoaXMuc3JjID0gdXJsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHJlc3BvbnNlOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBnZXQ6IGFzeW5jIGZ1bmN0aW9uKHByZXJlcXVpc2l0ZSwga2V5KXtcbiAgICAgICAgaWYoa2V5KXtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlc3BvbnNlKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vIHJlc3VsdCBoYXMgYmVlbiBmZXRjaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3JjID0gdGhpcy5zcmM7XG4gICAgICAgIGlmKHByZXJlcXVpc2l0ZSl7XG4gICAgICAgICAgICBzcmMgPSBzcmMgKyBcIi9cIiArIHByZXJlcXVpc2l0ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzcmMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHsgLy8gaWYgSFRUUC1zdGF0dXMgaXMgMjAwLTI5OVxuICAgICAgICAgICAgLy8gZ2V0IHRoZSByZXNwb25zZSBib2R5ICh0aGUgbWV0aG9kIGV4cGxhaW5lZCBiZWxvdylcbiAgICAgICAgICAgIGxldCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IGpzb247XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSFRUUC1FcnJvcjogXCIgKyByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQge1xuICAgIHRlc3QsXG4gICAgdGVzdCBhcyBkZWZhdWx0XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==