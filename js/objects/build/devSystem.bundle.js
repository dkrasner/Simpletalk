/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/objects/System.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/objects/ExecutionStack.js":
/*!**************************************!*\
  !*** ./js/objects/ExecutionStack.js ***!
  \**************************************/
/*! exports provided: ExecutionStack, ActivationContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExecutionStack", function() { return ExecutionStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivationContext", function() { return ActivationContext; });
/**
 * ExecutionStack
 * ---------------------------------
 * I am an object that manages a stack of
 * ActivationContext objects.
 * I am designed to be used by System as the
 * global execution stack.
 *
 */

class ExecutionStack {
    constructor(){
        this._stack = [];
        this._globals = {};

        // Bound methods
        this.pop = this.pop.bind(this);
        this.push = this.push.bind(this);
        this.setGlobal = this.setGlobal.bind(this);
        this.getGlobal = this.getGlobal.bind(this);
    }

    pop(){
        if(!this._stack.length){
            return null;
        }
        return this._stack.pop();
    }

    push(anActivation){
        this._stack.push(anActivation);
    }

    setGlobal(varName, value){
        this._globals[varName] = value;
    }

    getGlobal(varName){
        return this._globals[varName];
    }

    get current(){
        if(!this._stack.length){
            return null;
        }
        return this._stack[this._stack.length - 1];
    }

    get previous(){
        if(!this._stack.length >= 2){
            return null;
        }
        return this._stack[this._stack.length - 2];
    }
};

class ActivationContext {
    constructor(messageName, part, incomingMessage, handlerFunction){
        this.part = part;
        this.messageName = messageName;
        this.message = incomingMessage;
        this.handlerFunction = handlerFunction;
        this._locals = {};

        // Bound methods
        this.get = this.get.bind(this);
        this.getLocal = this.getLocal.bind(this);
        this.setLocal = this.setLocal.bind(this);
    }

    get(varName){
        let localValue = this.getLocal(varName);
        if(localValue !== undefined){
            return localValue;
        };
        // otherwise try to return a global
        // variable
        return window.System.executionStack.getGlobal(varName);
    }

    getLocal(varName){
        return this._locals[varName];
    }

    setLocal(varName, value){
        this._locals[varName] = value;
    }
}




/***/ }),

/***/ "./js/objects/System.js":
/*!******************************!*\
  !*** ./js/objects/System.js ***!
  \******************************/
/*! exports provided: System, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return System; });
/* harmony import */ var _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parts/Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parts/Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parts/Button.js */ "./js/objects/parts/Button.js");
/* harmony import */ var _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parts/Field.js */ "./js/objects/parts/Field.js");
/* harmony import */ var _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parts/WorldStack.js */ "./js/objects/parts/WorldStack.js");
/* harmony import */ var _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parts/Window.js */ "./js/objects/parts/Window.js");
/* harmony import */ var _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parts/Drawing.js */ "./js/objects/parts/Drawing.js");
/* harmony import */ var _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parts/Audio.js */ "./js/objects/parts/Audio.js");
/* harmony import */ var _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parts/Browser.js */ "./js/objects/parts/Browser.js");
/* harmony import */ var _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parts/Resource.js */ "./js/objects/parts/Resource.js");
/* harmony import */ var _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parts/Image.js */ "./js/objects/parts/Image.js");
/* harmony import */ var _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parts/Area.js */ "./js/objects/parts/Area.js");
/* harmony import */ var _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./views/WorldView.js */ "./js/objects/views/WorldView.js");
/* harmony import */ var _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./views/StackView.js */ "./js/objects/views/StackView.js");
/* harmony import */ var _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./views/ButtonView.js */ "./js/objects/views/ButtonView.js");
/* harmony import */ var _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./views/CardView.js */ "./js/objects/views/CardView.js");
/* harmony import */ var _views_WindowView__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./views/WindowView */ "./js/objects/views/WindowView.js");
/* harmony import */ var _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./views/FieldView.js */ "./js/objects/views/FieldView.js");
/* harmony import */ var _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./views/drawing/DrawingView.js */ "./js/objects/views/drawing/DrawingView.js");
/* harmony import */ var _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./views/ImageView.js */ "./js/objects/views/ImageView.js");
/* harmony import */ var _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./views/AreaView.js */ "./js/objects/views/AreaView.js");
/* harmony import */ var _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./views/AudioView.js */ "./js/objects/views/AudioView.js");
/* harmony import */ var _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./views/BrowserView.js */ "./js/objects/views/BrowserView.js");
/* harmony import */ var _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./views/ResourceView.js */ "./js/objects/views/ResourceView.js");
/* harmony import */ var _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./views/Halo.js */ "./js/objects/views/Halo.js");
/* harmony import */ var _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./views/navigator/Navigator.js */ "./js/objects/views/navigator/Navigator.js");
/* harmony import */ var _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./views/editors/Editor.js */ "./js/objects/views/editors/Editor.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ohm-js */ "./node_modules/ohm-js/src/main.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(ohm_js__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./utils/clipboard.js */ "./js/objects/utils/clipboard.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./utils/handInterface.js */ "./js/objects/utils/handInterface.js");
/* harmony import */ var _utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./utils/merriamInterface.js */ "./js/objects/utils/merriamInterface.js");
/* harmony import */ var _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./utils/serialization.js */ "./js/objects/utils/serialization.js");
/* harmony import */ var _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../../plugins/plugins.js */ "./plugins/plugins.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * System Object
 * -------------------------------------
 * I am an object representing the "top" of the
 * sytem. I am the point of communication between
 * Models and Views.
 */
















































const DOMparser = new DOMParser();




const System = {
    name: "System",
    id: -1,
    isLoaded: false,
    partsById: {},
    _commandHandlers: {},
    _functionHandlers: {},
    _deserializer: null,

    // A dictionary mapping available ST resource (such as plugin) names
    availableResources: {},

    // A dictionary mapping part types like
    // 'button' to their classes (Button)
    availableParts: {},

    // A dictionary mapping part types like
    // 'button' to their view classes (ButtonView)
    availableViews: {},

    // A registry that keeps all system messages from
    // beginnign of time; TODO in the future we might want
    // to note keep all this in memory
    // each log consists of:
    // [aMessage, (sourceName, sourceId), (targetName, targetId)]
    messageLog: [],

    // Will be called when a page loads.
    // Checks for any view elements in the
    // page and attempts to find serialized
    // model state for each of them. If present,
    // deserializes the model and attaches it
    // to the view.
    initialLoad: function(){
        // load the available resources
        // these might be needed down the line
        this.loadResources();

        // If we have a serialization script tag
        // containing JSON of serialized information,
        // attempt to load from it
        let serializationEl = document.getElementById('serialization');
        if(serializationEl && serializationEl.text != ""){
            this.deserialize()
                .then(() => {
                    this.sendInitialOpenMessages();
                    System.navigator.setModel(
                        System.partsById['world']
                    );

                    // By default, we render the World in the
                    // Comprehensive Editor
                    this.editor.render(this.world);
                });
        } else {
            this.loadFromEmpty();
 
            // By default, we render the World in the
            // Comprehensive Editor
            this.editor.render(this.world);
        }

        // Attach a new clipboard instance
        this.clipboard = new _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__["default"](this);

        // By this point we should have a WorldView with
        // a model attached.
        this.isLoaded = true;
    },

    loadResources: function() {
        Object.keys(_plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"]).forEach((k) => {
            this.availableResources[k] = _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"][k];
        });
    },

    loadFromEmpty: function(){
        let worldModel = new this.availableParts['world']();
        this.partsById[worldModel.id] = worldModel;
        let worldView = document.createElement(
            this.tagNameForViewNamed('world')
        );
        worldView.setModel(worldModel);
        document.body.appendChild(worldView);

        // Create initial stack model
        let initStack = this.newModel('stack', worldModel.id);

        // Create initial card model for that stack
        let initCard = this.newModel('card', initStack.id);

        // Update current stack and card ids 
        worldModel.partProperties.setPropertyNamed(
            worldModel,
            'current',
            initStack.id
        );
        initStack.partProperties.setPropertyNamed(
            initStack,
            'current',
            initCard.id
        );
        // Update serialization
        this.serialize();

        this.sendInitialOpenMessages();
        System.navigator.setModel(
            System.partsById['world']
        );
    },

    sendInitialOpenMessages: function(){
        // Send the openWorld message to the WorldStack
        let world = this.partsById['world'];
        world.sendMessage({
            type: 'command',
            commandName: 'openWorld',
            args: [],
            shouldIgnore: true
        }, world);
        world.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, world.currentStack);
        world.currentStack.sendMessage({
            type: 'command',
            commandName: 'openCard',
            args: [],
            shouldIgnore: true
        }, world.currentStack.currentCard);
    },

    sendMessage: function(aMessage, source, target){
        if(!target || target == undefined){
            throw new Error('Messages must be sent with target receivers specified!');
        }

        // keep track of all sources which pass this message
        if (!("senders" in aMessage)) {
            aMessage["senders"] = [];
        }
        aMessage.senders.push({
            name: source.name,
            id: source.id,
        });

        return target.receiveMessage(aMessage);
    },

    receiveMessage: function(aMessage){
        switch(aMessage.type){
            case 'newView':
                return this.newView(
                    aMessage.viewType,
                    aMessage.modelId
                );
            case 'compile':
                return this.compile(aMessage);
            case 'command':
                return this.receiveCommand(aMessage);
            default:
                return this.doesNotUnderstand(aMessage);
        }
    },

    doesNotUnderstand: function(aMessage){
        // If the message has the shouldIgnore property
        // set to true, it means we should just swallow
        // this message if we don't understand it. This is
        // useful for messages like mouse events on buttons
        // which are not captured by default and would otherwise
        // end up arriving to this System object via the
        // message delegation chain.
        if(aMessage.shouldIgnore){
            return;
        }
        let originalSender = this.partsById[aMessage.senders[0].id];
        let msg = {
            type: "error",
            name: "MessageNotUnderstood",
            message: aMessage
        };
        originalSender.sendMessage(msg, originalSender);
    },

    compile: function(aMessage){
        let targetObject = this.partsById[aMessage.targetId];
        if(!targetObject || targetObject == undefined){
            throw new Error(`System could not compile target object ${aMessage.targetId}`);
        }


        // Attempt to parse the incoming SimpleTalk script string.
        // If there are grammatical errors, report them and bail.
        // Otherwise, create a new semantics on the targetPart, add
        // the required semantic operations, and interpret the top
        // level of the script, which will create the JS handler functions
        let parsedScript = languageGrammar.match(aMessage.codeString);
        if(parsedScript.failed()){
            // consider using the parse data from trace
            // example: let tracedScript = languageGrammar.trace(aMessage.codeString);
            // let tree = tracedScript.toString();
            let msg = {
                type: "error",
                name: "GrammarMatchError",
                parsedScript: parsedScript,
                partId: aMessage.targetId
            };
            targetObject.sendMessage(msg, targetObject);
        } else {
            // First, clear out any currently compiled handlers
            // since the incoming script might get rid of them
            targetObject._commandHandlers = {};

            // Create a semantics object whose partContext
            // attribute is set to be the target object.
            targetObject._semantics = languageGrammar.createSemantics();
            targetObject._semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(targetObject, this)
            );
            targetObject._semantics(parsedScript).interpret();
        }


        // Be sure to then update the
        // serialization for the target
        // part, thus adding the script to
        // its serialization
        if(aMessage.serialize){
            this.serialize();
        }
    },

    receiveCommand: function(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            let boundHandler = handler.bind(this);
            let activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            this.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            this.executionStack.pop();
            return result;
        } else {
            return this.doesNotUnderstand(aMessage);
        }
    },

    newModel: function(kind, ownerId, name, buildView=true){
        // Lookup the instance of the model that
        // matches the owner's id
        let ownerPart = this.partsById[ownerId];
        if(!ownerPart || ownerPart == undefined){
            throw new Error(`System could not locate owner part with id ${ownerId}`);
        }

        // Find the class constructor for the kind of
        // part requested as a new model. If not known,
        // throw an error
        let modelClass = this.availableParts[kind];
        if(!modelClass){
            throw new Error(`Cannot create unknown part type: ${kind}`);
        }
        let model = new modelClass(ownerPart);
        if(name){
            model.partProperties.setPropertyNamed(model, 'name', name);
        }
        this.partsById[model.id] = model;

        // Any created part might initialize its
        // own subparts. We need to let the System know
        // about those too
        model.subparts.forEach(subpart => {
            this.partsById[subpart.id] = subpart;
        });

        // If there is a valid owner part for
        // the newly created part model,
        // add the new model to the owner's
        // subparts list
        if(ownerPart){
            ownerPart.addPart(model);
        }

        // Add the System as a property subscriber to
        // the new model. This will send a message to
        // this System object whenever any of this model's
        // properties have changed
        model.addPropertySubscriber(this);

        if(buildView){
            // See if there is already a view for the model.
            // If not, create and attach it.
            let viewForModel = this.findViewById(model.id);
            if(!viewForModel){
                this.newView(model.type, model.id);
            }
        }

        // Finally if the owner part is either a world or a stack
        // and has only one stack or card child, respectively, set
        // that child to be the current
        if(ownerPart.type == "world" || ownerPart.type == "stack"){
            let currentId = ownerPart.partProperties.getPropertyNamed(ownerPart, "current");
            if(!currentId){
                ownerPart.partProperties.setPropertyNamed(ownerPart, "current", model.id);
            }
        }

        return model;
    },

    newProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find newProperty target!`);
        }

        if(target.partProperties.findPropertyNamed(propName)){
            // TODO this should be a ST error
            throw new Error(`Part ${target.id} already has property "${propName}"`);
        }
        // we only add basic property and the default value is null
        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__["BasicProperty"](propName, null);
        customProp.add(newProp);
    },

    deleteProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find deleteProperty target!`);
        }

        // Note: this will only delete custom properties which is what we want
        let prop = target.partProperties.findPropertyNamed(propName);

        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        customProp.delete(prop);
    },

    setProperty(senders, propName, value, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find setProperty target!`);
        }

        target.partProperties.setPropertyNamed(
            target,
            propName,
            value
        );

        // If the target part is a Stack, we also
        // set this property on all of its Card
        // subparts
        if(target.type == 'stack'){
            target.subparts.filter(subpart => {
                return subpart.type == 'card';
            }).forEach(card => {
                card.partProperties.setPropertyNamed(
                    card,
                    propName,
                    value
                );
            });
        }
    },

    // Remove the model with the given ID from
    // the System's registry, as well as from the subparts
    // array of any owners
    deleteModel: function(modelId){
        let foundModel = this.partsById[modelId];
        if(!foundModel){
            return false;
        }
        // When removing a card or a stack be sure it is not the only one
        // and if it is the current card or stack we should go to the next one
        // before removing it
        if(foundModel.type == "card" || foundModel.type == "stack"){
            let sameTypeSubparts = foundModel._owner.subparts.filter((p) => {return p.type == foundModel.type;});
            if(sameTypeSubparts.length == 1){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the only ${foundModel.type}`);
            } else if(modelId == this.getCurrentStackModel().id  || modelId == this.getCurrentCardModel().id){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the current ${foundModel.type}`);
            }
        }

        // Make sure to stop all stepping
        // on the Part, otherwise stepping
        // intervals will error infinitely
        foundModel.stopStepping();

        // make sure the editor is closed
        foundModel.closeEditorCmdHandler();

        let ownerModel = foundModel._owner;
        if(ownerModel){
            ownerModel.removePart(foundModel);
        }

        delete this.partsById[modelId];
        this.removeViews(modelId);

        // Serialize the state
        this.serialize();
        return true;
    },

    // Remove all views with the corresponding
    // model id from the DOM
    removeViews: function(modelId){
        let views = Array.from(this.findViewsById(modelId));
        views.forEach(view => {
            let parentEl = view.parentElement;
            view.parentElement.removeChild(view);
            // Dispatch a CustomEvent on the parentElement
            // indicating that this part has been removed, and
            // any view utilities that care can be notified.
            let event = new CustomEvent('st-view-removed', {
                detail: {
                    partType: view.model.type,
                    partId: modelId,
                    ownerId: null
                } 
            });
            parentEl.dispatchEvent(event);
        });
        let lenses = this.findLensViewsById(modelId);
        lenses.forEach(lensView => {
            lensView.parentElement.removeChild(lensView);
        });
    },

    newView: function(partName, modelId, parentId){
        let model = this.partsById[modelId];
        if(!model || model == undefined){
            throw new Error(`System does not know part ${partName}[${modelId}]`);
        }
        if(!partName){
            partName = model.type;
        }

        // Find the parent model id. This will
        // help us find the parent view element for
        // appending the new element.
        if (!parentId){
            parentId = model._owner.id;
        }
        let parentElement = this.findViewById(parentId);
        if(!parentElement){
            throw new Error(`Could not find parent element for ${partName}[${modelId}] (model owner id: ${model._owner.id})`);
        }

        // Create the new view instance,
        // append to parent, and set the model
        let newView = document.createElement(
            this.tagNameForViewNamed(partName)
        );
        newView.setModel(model);
        this.sendMessage({
            type: "viewChanged",
            changeName: "subpart-new",
            args: [newView]
        }, model._owner, parentElement);

        // Dispatch a CustomEvent on the parentElement
        // indicating that this part has been created, and
        // any view utilities that care can be notified.
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: model.type,
                partId: model.id,
                ownerId: model._owner.id || null
            } 
        });
        parentElement.dispatchEvent(event);

        // See if there are lens views and update
        // those as well
        let lensViews = this.findLensViewsById(parentId);
        lensViews.forEach(lensView => {
            let newLensView = document.createElement(
                this.tagNameForViewNamed(partName)
            );
            newLensView.setModel(model);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', modelId);
            newLensView.setAttribute('role', 'lens');
            lensView.appendChild(newLensView);
        });

        // TODO do we want to allow the possibiliy of a view on an
        // element but no subpart of that view on the element?

        // For all subparts of this model, call
        // the newView method recursively
        model.subparts.forEach(subpart => {
            this.newView(subpart.type, subpart.id);
        });

        return newView;
    },

    registerPart: function(name, cls){
        this.availableParts[name] = cls;
    },

    registerView: function(name, cls){
        this.availableViews[name] = cls;
    },

    tagNameForViewNamed: function(name){
        return `st-${name}`;
    },

    // Find the first matching view element
    // with the given id
    findViewById: function(id){
        return document.querySelector(`[part-id="${id}"]`);
    },

    findLensViewsById: function(id){
        return Array.from(document.querySelectorAll(`[lens-part-id="${id}"]`));
    },

    // Find all matching view elements with
    // the given part id
    findViewsById: function(id){
        return document.querySelectorAll(`[part-id="${id}"]`);
    },

    // return the model corresponding to the current stack
    getCurrentStackModel: function(){
        let world = this.getWorldStackModel();
        return world.currentStack;
    },

    // return the model corresponding to the current card
    getCurrentCardModel: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.currentCard;
    },

    // return the model corresponding to the world stack
    getWorldStackModel: function(){
        return this.partsById['world'];
    },

    // return the model corresponding script editor st-field
    // Note: we use the window.model.target to locate the corresponding window
    // but return its st-field subpart
    findScriptEditorByTargetId: function(id){
        let scriptEditorField;
        let windows = document.querySelectorAll("st-window");
        windows.forEach((w) => {
            let target = w.model.target;
            if(target && target.id === id){
                scriptEditorField = w.querySelector("st-field");
            }
        });
        return scriptEditorField;
    },

    serialize: function(){
        let world = this.partsById['world'];
        if(!world){
            throw new Error(`No world found!`);
        }
        let serializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STSerializer"](this);
        let serialString = serializer.serialize(this.partsById['world'], true);

        // If there is not a script tag in the
        // body for the serialization, create it
        let serializationScriptEl = document.getElementById('serialization');
        if(!serializationScriptEl){
            serializationScriptEl = document.createElement('script');
            serializationScriptEl.id = 'serialization';
            serializationScriptEl.type = 'application/json';
            document.body.append(serializationScriptEl);
        }
        serializationScriptEl.textContent = serialString;
    },

    deserialize: function(){
        let serializationEl = document.getElementById('serialization');
        if(!serializationEl){
            throw new Error(`No serialization found for this page`);
        }
        this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
        return this._deserializer.deserialize(serializationEl.textContent);
    },

    // Return a *complete* HTML
    // representation of the current application
    // that can later be saved to a file
    getFullHTMLString: function(){
        let clonedDocument = document.cloneNode(true);
        let world = clonedDocument.querySelector('st-world');
        let nav = clonedDocument.querySelector('st-navigator');
        if(world){
            world.remove();
        }
        if(nav){
            nav.remove();
        }

        return clonedDocument.documentElement.outerHTML;
    },


    /** Navigation of Current World **/
    goToNextStack: function(){
        let world = this.partsById['world'];
        return world.goToNextStack();
    },

    goToPrevStack: function(){
        let world = this.partsById['world'];
        return world.goToPrevStack();
    },

    goToStackById: function(stackId){
        let world = this.partsById['world'];
        return world.goToStackById(stackId);
    },

    /** Navigation of Current Stack **/
    goToNextCard: function(){
        let currentStack = this.getCurrentStackModel(); 
        return currentStack.goToNextCard();
    },

    goToPrevCard: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToPrevCard();
    },

    goToCardById: function(cardId){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToCardById(cardId);
    },

    openEditorForPart: function(partId){
        this.editor.render(
            this.partsById[partId]
        );
        this.editor.open();
    },

    closeEditorForPart: function(partId){
        this.editor.close();
    }
};

/** Add Default System Command Handlers **/
//System._commandHandlers['deleteModel'] = System.deleteModel;
System._commandHandlers['deleteModel'] = function(senders, ...rest){
    System.deleteModel(...rest);
};
//System._commandHandlers['newModel'] = System.newModel;
System._commandHandlers['newModel'] = function(senders, ...rest){
    System.newModel(...rest);
    this.serialize();
};
//System._commandHandlers['newView'] = System.newView;
System._commandHandlers['newView'] = function(senders, ...rest){
    System.newView(...rest);
};
System._commandHandlers['newProperty'] = System.newProperty;
System._commandHandlers['setProperty'] = System.setProperty;
System._commandHandlers['deleteProperty'] = System.deleteProperty;

System._commandHandlers['ask'] = function(senders, question){
    // Use the native JS prompt function to ask the question
    // and return its value.
    // By returning here, we expect the implicit variable
    // "it" to be set inside any calling script
    return prompt(question);
};

System._commandHandlers['putInto'] = function(senders, value, variableName, global){
    if(global){
        System.executionStack.setGlobal(variableName, value);
        return;
    }
    // Because we push all handlers onto the execution stack,
    // the putInto handler is currently at the top of the stack.
    // In order to modify the caller's variables, we need to
    // find the context that is one previous on the stack
    if(System.executionStack.previous){
        System.executionStack.previous.setLocal(variableName, value);
    } else {
        throw new Error(`ExecutionStack Error: #putInto on top of empty stack!`);
    }
};

System._commandHandlers['answer'] = function(senders, value){
    alert(value.toString());
};

System._commandHandlers['go to direction'] = function(senders, directive, objectName){
    switch(objectName) {
        case 'card':
            switch(directive){
                case 'next':
                    this.goToNextCard();
                    break;

                case 'previous':
                    this.goToPrevCard();
                    break;
            }
            break;

        case 'stack':
            switch(directive){
                case 'next':
                    this.goToNextStack();
                    break;

                case 'previous':
                    this.goToPrevStack();
                    break;
            }
            break;

        default:
            alert(`"go to" not implemented for ${objectName}`);

    }
};

System._commandHandlers['go to'] = function(senders, id){
    let model = this.partsById[id];
    if(!model){
        alert(`"go to" target not found`);
    }
    switch(model.type) {
    case 'card':
        this.goToCardById(id);
        break;

    case 'stack':
        this.goToStackById(id);
        break;

    default:
        alert(`"go to" not implemented for ${model.type}`);

    }
};

System._commandHandlers['go to website'] = function(senders, url){
    window.location.href = url;
};

//Import a world, i.e. its stacks from another source
System._commandHandlers['importWorld'] = function(sender, sourceUrl){
    if(!sourceUrl){
        sourceUrl = window.prompt("Choose World location");
    }
    fetch(sourceUrl)
        .then(response => {
            let contentType = response.headers.get('content-type');
            if(!contentType.startsWith('text/html')){
                throw new Error(`Invalid content type: ${contentType}`);
            }
            return response.blob().then(blob => {
                let reader = new FileReader();
                reader.readAsText(blob);
                reader.onloadend = () => {
                    let parsedDocument = DOMparser.parseFromString(reader.result, "text/html");
                    // there is no .getElementById() for a node HTML parsed document!
                    let serializationEl = parsedDocument.querySelector('#serialization');
                    if(!serializationEl){
                        console.log(`No serialization found for ${sourceUrl}`);
                        alert(`World "${sourceUrl}" not found`);
                        return;
                    }
                    this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
                    this._deserializer.targetId = 'world'; // We will insert the stacks into the world
                    return this._deserializer.importFromSerialization(
                        serializationEl.textContent,
                        (part) => {
                            // Return only Stacks that are direct subparts
                            // of the world.
                            let isStack = part.type == 'stack';
                            let isWorldSubpart = part._owner && part._owner.type == 'world';
                            return isStack && isWorldSubpart;
                        }
                    );
                };
            });
        })
        .then(() => {
            // Manually set the _src.
            // This ensures that we don't infinitely
            // call the load operation
            this._src = sourceUrl;
            /*
            // Stop and restart hand interface if it's running.
            if (handInterface.handDetectionRunning) {
                handInterface.stop();
                handInterface.start();
            }
            */
        })
        .catch(err => {
            alert("Could not load world");
            console.error(err);
        });
};

System._commandHandlers['openScriptEditor'] = function(senders, targetId){
    let target = this.partsById[targetId];
    let targetName = target.partProperties.getPropertyNamed(target, "name");
    if(targetName){
        targetName = `"${targetName}"`;
    }
    let name = `Script For ${target.name} ${targetName}`;

    // If there is already a dinwo opened with this name, then
    // we return without creating anything new.
    let found = Object.values(System.partsById).filter(part => {
        let partName;
        if(part.type == 'window'){
            partName = part.partProperties.getPropertyNamed(
                part,
                'title'
            );
        }
        return (part.type == 'window' && name == partName);
    });
    if(found.length){
        return;
    }

    let currentCard = this.getCurrentCardModel();
    let window = this.newModel('window', currentCard.id);
    let area = this.newModel('area', window.id);
    let scriptField = this.newModel('field', area.id);
    let saveButton = this.newModel('button', area.id);


    // setup the window and stack properties
    window.setTarget(target);
    window.partProperties.setPropertyNamed(window, "title", name);
    window.partProperties.setPropertyNamed(window, "height", 200);
    window.partProperties.setPropertyNamed(window, "width", 500);
    window.partProperties.setPropertyNamed(window, 'top', 100);
    window.partProperties.setPropertyNamed(window, 'left', 100);

    area.partProperties.setPropertyNamed(area, "layout", "list");
    area.partProperties.setPropertyNamed(area, "list-direction", "column");
    area.partProperties.setPropertyNamed(area, "width", "fill");
    area.partProperties.setPropertyNamed(area, "height", "fill");

    // script field
    let targetScript = target.partProperties.getPropertyNamed(target, "script"); 
    scriptField.partProperties.setPropertyNamed(scriptField, "text", targetScript);
    scriptField.partProperties.setPropertyNamed(scriptField, "height", "fill");
    scriptField.partProperties.setPropertyNamed(scriptField, "width", "fill");

    // Setup syntax highlight
    scriptField.sendMessage({
        type: "command",
        commandName: "highlightSyntax",
        args: []
    }, scriptField);


    // setup up the save button properties
    saveButton.partProperties.setPropertyNamed(saveButton, "name", "Save Script");
    saveButton.partProperties.setPropertyNamed(saveButton, "width", "fill");
    saveButton.partProperties.setPropertyNamed(saveButton, "text-size", 20);
    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);

    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);
    let saveScript = `on click\n\ttell target to set "script" to the "text" of first field\nend click`; 
    saveButton.partProperties.setPropertyNamed(saveButton, "script", saveScript);
};

System._commandHandlers['SimpleTalk'] = function(senders){
    return System.grammar.source.sourceString;
}

System._commandHandlers['openDebugger'] = function(senders, partId){
    let target = this.partsById[partId];
    // Create the Field model and attach to current card
    let currentCard = this.getCurrentCardModel();
    let fieldModel = this.newModel('field', currentCard.id);
    let text = `Available Commands for ${target.name} (id ${target.id})\n\n`;
    Object.keys(target.commandHandlerRegistry).forEach((name) =>{
        let info = target.commandHandlerRegistry[name];
        text += `${name}: ${JSON.stringify(info)}\n`;
    });
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'text',
        text
    );
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'editable',
        false
    );
};

System._commandHandlers['saveHTML'] = function(senders){
    // Stop hand recognition if it's running.
    let handRecognitionOriginallyRunning = _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionRunning;
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
    this.serialize();

    let stamp = Date.now().toString();
    let serializedPage = this.getFullHTMLString();
    let typeInfo = "data:text/plain;charset=utf-8";
    let url = `${typeInfo},${encodeURIComponent(serializedPage)}`;

    let anchor = document.createElement('a');
    anchor.style.display = "none";
    document.body.append(anchor);
    anchor.href = url;
    anchor.download = `SimpleTalkSnapshot_${stamp}.html`;
    anchor.click();
    window.URL.revokeObjectURL(url);
    anchor.parentElement.removeChild(anchor);
    // Start hand recognition if it was running.
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    }
};

System._commandHandlers['tell'] = (senders, targetId, deferredMessage) => {
    let targetPart = System.partsById[targetId];
    if(!targetPart){
        throw new Error(`Attempted to tell part id ${targetId}: no such part!`);
    }
    targetPart.sendMessage(deferredMessage, targetPart);
};

System._commandHandlers['toggleHandDetection'] = () => {
    if (_utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionModel === null) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    } else {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
};

System._commandHandlers['merriam'] = (senders, docId) => {
    const sender = System.partsById[senders[0].id];
    Object(_utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__["default"])(sender, docId);
};

System._commandHandlers['globalInterrupt'] = () => {
    // cycle through all the parts and set the "stepping" property to false
    Object.values(System.partsById).forEach((part) => {
        if(part.isStepping){
            part.partProperties.setPropertyNamed(part, "stepping", false);
        }
    });
};


/** Register the initial set of parts in the system **/
System.registerPart('card', _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
System.registerPart('stack', _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('button', _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
System.registerPart('world', _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
System.registerPart('window', _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('drawing', _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
System.registerPart('image', _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
System.registerPart('area', _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
System.registerPart('audio', _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
System.registerPart('browser', _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
System.registerPart('resource', _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/** Register the initial set of views in the system **/
System.registerView('button', _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
System.registerView('stack', _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
System.registerView('world', _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
System.registerView('card', _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__["default"]);
System.registerView('window', _views_WindowView__WEBPACK_IMPORTED_MODULE_16__["default"]);
System.registerView('field', _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__["default"]);
System.registerView('drawing', _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__["default"]);
System.registerView('image', _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__["default"]);
System.registerView('area', _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__["default"]);
System.registerView('audio', _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__["default"]);
System.registerView('browser', _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__["default"]);
System.registerView('resource', _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__["default"]);


// Convenience method for adding all of the
// available custom elements to the window object's
// customElements registry
System.registerCustomElements = function(){
    Object.keys(System.availableViews).forEach(partName => {
        let viewClass = System.availableViews[partName];
        let elementName = System.tagNameForViewNamed(partName);
        window.customElements.define(elementName, viewClass);
    });
};

// iniitalize the compiler and add it to the system
// Instantiate the grammar.
let languageGrammar;
if (window.grammar){
    // for testing it is sometimes convenient to load the grammar and add to window
    // see ./tests/preload.js for example
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammar(window.grammar);
} else {
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammarFromScriptElement();
}

System.grammar = languageGrammar;

// Set the exection stack on the
// System
System.executionStack = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ExecutionStack"]();

// Add a dynamic getter for the World for convenience
Object.defineProperty(System, 'world', {
    get: function(){
        return this.partsById['world'];
    }
});

document.addEventListener('DOMContentLoaded', () => {
    // Add the System object to window so
    // that it is global on the page. We do this
    // for both debugging and testing.
    window.System = System;
    // Add the possible views as webcomponents
    // in the custom element registry
    System.registerCustomElements();

    // Add any other non-part view CustomElements,
    // like the halo
    window.customElements.define('st-halo', _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__["default"]);
    window.customElements.define('st-navigator', _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__["default"]);
    window.customElements.define('st-editor', _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__["default"]);

    // Add nav
    System.navigator = document.createElement('st-navigator');
    document.body.appendChild(System.navigator);

    // Add comprehensive editor pane
    // if one is not already present in the markup
    let existingEditors = Array.from(document.querySelectorAll('st-editor'));
    existingEditors.forEach(editorEl => {
        editorEl.remove();
    });
    System.editor = document.createElement('st-editor');
    document.body.appendChild(System.editor);

    // Perform the initial setup of
    // the system
    System.initialLoad();
});

// add a message listener on window
// these can include message from a browser part
// for now filter those not coming from the origin
window.addEventListener("message", (event) => {
    if (event.origin !== window.origin)
        return;
    console.log(`Message to browser`);
    // TODO: maybe we need to deal with quote escapes directly
    // in the grammar
    let script = event.data.replaceAll("'", '"');
    // only statements are accepted for now
    let parsedScript = languageGrammar.match(script, "Statement");
    if(parsedScript.failed()){
        // for now just log that it failed
        console.log("failed to parse script for browser");
    } else {
        let semantics = languageGrammar.createSemantics();
        let world = System.partsById["world"];
        semantics.addOperation(
            'interpret',
            Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(world, System)
        );
        let msg = semantics(parsedScript).interpret();
        System.sendMessage(msg, world, System);
    }
});

// global interrupt
document.addEventListener('keydown', (event) => {
    if(event.ctrlKey && event.key == 'c'){
        System.sendMessage({
            type: "command",
            commandName: "globalInterrupt",
            args: []
        }, System, System);
    }
});





/***/ }),

/***/ "./js/objects/parts/Area.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Area.js ***!
  \**********************************/
/*! exports provided: Area, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Area", function() { return Area; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Area; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Area
 * ----------------------------------
 * I am a Area Part.
 * I represent a 'grouping' of subparts within
 * my owner part.
 * I contain the Layout properties set, and therefore
 * can display my contained subparts according to 
 * different layout properties than my ancestor
 * Card.
 *
 */



const sides = ["top", "bottom", "left", "right"];

class Area extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(...args){
        super(...args);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
            "browser",
            "window"
        ];

        // Add style props
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addLayoutStyleProps"])(this);

        // Set default width and height
        // for an empty area
        this.partProperties.setPropertyNamed(
            this,
            'width',
            50
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            50
        );
        this.partProperties.newBasicProp(
            'clipping',
            false
        );
        this.partProperties.newBasicProp(
            'allow-scrolling',
            false
        );
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
    }


    get type(){
        return 'area';
    }
};




/***/ }),

/***/ "./js/objects/parts/Audio.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Audio.js ***!
  \***********************************/
/*! exports provided: Audio, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Audio; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Audio extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadAudioFromSource", this.loadAudioFromSource);
        this.setPrivateCommandHandler("play", () => {this.play(true);});
        this.setPrivateCommandHandler("pause", () => {this.play(false);});
        this.setPrivateCommandHandler("stop", this.stop);

        // Bind component methods
        this.loadAudioFromSource = this.loadAudioFromSource.bind(this);
        this.play = this.play.bind(this);
        this.stop = this.stop.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'audio';
    }

    loadAudioFromSource(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    play(value){
        this.partProperties.setPropertyNamed(this, "play", value);
        this.partProperties.setPropertyNamed(this, "stop", false);
    }

    stop(){
        this.partProperties.setPropertyNamed(this, "play", false);
        this.partProperties.setPropertyNamed(this, "stop", true);
    }
};




/***/ }),

/***/ "./js/objects/parts/Browser.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Browser.js ***!
  \*************************************/
/*! exports provided: Browser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Browser", function() { return Browser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Browser; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Browser extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;
        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("setURLTo", this.setURL);
        this.setPrivateCommandHandler("forward", this.sendMessageToBrowser);

        // Bind component methods
        this.setURL = this.setURL.bind(this);
        this.sendMessageToBrowser = this.sendMessageToBrowser.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                5
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );
    }

    get type(){
        return 'browser';
    }

    setURL(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    sendMessageToBrowser(senders, message){
        let views = window.System.findViewsById(this.id);
        views.forEach((v) => {
            let iframe = v._shadowRoot.querySelector("iframe");
            iframe.contentWindow.postMessage(message, window.origin);
        });
    }
};




/***/ }),

/***/ "./js/objects/parts/Button.js":
/*!************************************!*\
  !*** ./js/objects/parts/Button.js ***!
  \************************************/
/*! exports provided: Button, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Button; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Button
 * ----------------------------------
 * I am a Button Part.
 * My owner is always a Card.
 * I am a clickable point of interaction on a Card,
 * whose functionality can be customized by the author.
 */




class Button extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner){
        super(owner);

        this.isButton = true;

        // Add Button-specific part properties
        this.partProperties.newDynamicProp(
            'selectedText',
            null, // readOnly (for now)
            this.getSelectedText,
            true, // readOnly,
        );

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 234, 149)", // var(--palette-yellow)
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-top-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-bottom-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-left-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-right-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-left',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-top',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );

    }

    get type(){
        return 'button';
    }

    //TODO: implement this property
    // getter for real
    getSelectedText(propName, propVal){
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Card.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Card.js ***!
  \**********************************/
/*! exports provided: Card, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Card", function() { return Card; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Card; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Card
 * --------------------------
 * I am a Card Part.
 * I represent a collection of Parts that is
 * displayed on the screen. My owner is always
 * a Stack Part.
 * I can contain any kind of Part, including
 * buttons and fields.
 */





class Card extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, name){
        super(owner);
        this.stack = this._owner;
        this.acceptedSubpartTypes = [
            "window", "button",
            "field", "field", "area", "drawing",
            "image", "audio", "browser", "resource"
        ];
        this.isCard = true;

        // Add Card-specific part
        // properties
        this.partProperties.newBasicProp(
            'marked',
            false
        );
        this.partProperties.newBasicProp(
            'cantDelete',
            false
        );
        this.partProperties.newBasicProp(
            'dontSearch',
            false
        );
        this.partProperties.newBasicProp(
            'showPict',
            false
        );

        // If we are initializing with a name
        // set the name property
        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addLayoutStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(0, 75, 103)" // palette-blue
        );
    }

    get type(){
        return 'card';
    }
};




/***/ }),

/***/ "./js/objects/parts/Drawing.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Drawing.js ***!
  \*************************************/
/*! exports provided: Drawing, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Drawing", function() { return Drawing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Drawing; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Basic User Drawing Part
 */



const sides = ["top", "bottom", "left", "right"];

class Drawing extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner){
        super(owner);

        // Set new properties for this
        // part type
        this.partProperties.newBasicProp(
            'image',
            null
        );
        this.partProperties.newBasicProp(
            'mode',
            'drawing'
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)", //grey
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            'width',
            300
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            200
        );

        // We are using a distinct show-border
        // property to deal with being able to see
        // a drawing that is empty
        this.partProperties.newBasicProp(
            'show-border',
            true
        );

        // When drawing from a script/commands,
        // we will use this as the open canvas
        // whose image bytes will be set to the
        // image property
        this.activeCanvas = null;

        // Set up the drawing commands
        this.setupDrawingCommands();


        // Bind component methods
        this.setupDrawingCommands = this.setupDrawingCommands.bind(this);
        this.stroke = this.stroke.bind(this);
        this.moveTo = this.moveTo.bind(this);
        this.lineTo = this.lineTo.bind(this);
        this.beginDraw = this.beginDraw.bind(this);
        this.endDraw = this.endDraw.bind(this);
        this.clear = this.clear.bind(this);
        this.coordsFromString = this.coordsFromString.bind(this);
    }

    get type(){
        return 'drawing';
    }

    setupDrawingCommands(){
        this.setPrivateCommandHandler('lineTo', (senders, ...args) => {
            this.lineTo(...args);
        });
        this.setPrivateCommandHandler('moveTo', (senders, ...args) => {
            this.moveTo(...args);
        });
        this.setPrivateCommandHandler('beginDraw', (senders, ...args) => {
            this.beginDraw(...args);
        });
        this.setPrivateCommandHandler('finishDraw', (senders, ...args) => {
            this.endDraw(...args);
        });
        this.setPrivateCommandHandler('stroke', (senders, ...args) => {
            this.stroke(...args);
        });
        this.setPrivateCommandHandler('clear', (senders, ...args) => {
            this.clear(...args);
        });
    }

    /* Scriptable Drawing Commands */
    stroke(){
        if(this.isDrawing){
            // Hard-coded. Get from props
            // and link to views
            this.activeContext.strokeWidth = 10;
            this.activeContext.stroke();
        }
    }
    moveTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.moveTo(
                x,
                y
            );
        }
    }

    lineTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.lineTo(
                x,
                y
            );
        }
    }

    beginDraw(){
        if(this.isDrawing){
            return;
        }
        this.isDrawing = true;
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');

        // If there is currently image data set to the
        // image part property, we need to draw that image
        // onto the canvas first.
        let currentImage = this.partProperties.getPropertyNamed(
            this,
            'image'
        );
        if(currentImage){
            let img = new Image();
            img.onload = () => {
                this.activeContext.drawImage(img, 0, 0);
            };
            img.src = currentImage;
        }

        // Begin a drawing path
        this.activeContext.beginPath();
    }

    endDraw(){
        if(this.isDrawing){
            this.activeContext.closePath();
            this.activeContext.stroke();

            // Update the image property to be the
            // serialized version of the current image.
            // This will update any subscribed views
            this.partProperties.setPropertyNamed(
                this,
                'image',
                this.activeCanvas.toDataURL()
            );
            this.activeCanvas = null;
            this.activeContext = null;
            this.isDrawing = false;
        }
    }

    clear(){
        if(this.isDrawing){
            return;
        }
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');
        this.partProperties.setPropertyNamed(
            this,
            'image',
            this.activeCanvas.toDataURL()
        );
        this.activeCanvas = null;
        this.activeContext = null;
    }

    /* Utility Methods for Scriptable Drawing */
    coordsFromString(coordString){
        let pair = coordString.split(",");
        let x = parseInt(pair[0]);
        let y = parseInt(pair[1]);
        return {x, y};
    }
};




/***/ }),

/***/ "./js/objects/parts/Field.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Field.js ***!
  \***********************************/
/*! exports provided: Field, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return Field; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Field
 * -----------------------------------------
 * I am a Field Part.
 * I am a container that holds text. I also allow
 * a user to edit my text.
 */





const sides = ["top", "bottom", "left", "right"];

class Field extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name){
        super(owner);

        this.acceptedSubpartTypes = ["field"];

        this.isField = true;

        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Set the Field-specific
        // Part Properties
        this.partProperties.newBasicProp(
            'mode',
            'editing' //TODO this should be either "bravo" or "simpletalk"
        );

        this.partProperties.newBasicProp(
            'innerHTML',
            ''
        );

        this.partProperties.newBasicProp(
            'targetRangeId',
            null
        );

        // 'text' is a DynamicProperty configured to also set the innerHTML
        // BasicProperty when changed. The basic idea is that 'text' will be
        // the property that ST will interface with and everytime it
        // is changed the 'innerHTML' property should follow.
        this.partProperties.newDynamicProp(
            'text',
            (owner, prop, value, notify) => {
                prop._value = value;
                if(notify){
                    /*
                    if(!value){
                        value = "<br>";
                    }
                    // replace all newline characters with <br>
                    value = value.replace(/\n/g, "<br>");
                    */
                    owner.partProperties.setPropertyNamed(owner, 'innerHTML', value, notify);
                }
            },
            (owner, prop) => {
                return prop._value;
            },
            false, // not read only
            ''     // default is empty string
        );

        this.partProperties.newBasicProp(
            'editable',
            true
        );


        // A number of the props deal with direct text editing,
        // and so they are like commands. Examples include "undo"
        // "redo" "clear" etc. Here we use dynami props which the
        // view can respond to accordingly, but having these props have
        // no actual 'state'
        /** TODO: these should be private commands
        this.partProperties.newDynamicProp(
            "undo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "redo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "remove-format",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        **/

        // Styling
        // setting width and height to null
        // effectively forces to the default size
        // of the button to fit the button name
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 248, 220)", // var(--palette-cornsik)
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "medium",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-style`,
                "solid",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "black",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "1",
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );

        // Private command handlers

        this.insertRange = this.insertRange.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.setPrivateCommandHandler("insertRange", this.insertRange);
        this.setPrivateCommandHandler("setSelection", this.setSelection);
        this.setPrivateCommandHandler("highlightSyntax", this.highlightSyntax);
        this.setPrivateCommandHandler("unhighlightSyntax", this.unhighlightSyntax);
    }

    insertRange(senders, rangeId, html, css){
        window.System.findViewsById(this.id).forEach((view) => {
            view.insertRange(rangeId, html, css);
        });
    }

    setSelection(senders, propertyName, propertyValue){
        // for now just allow properties of type "text-*" to be set
        if(propertyName.startsWith("text-")){
            window.System.findViewsById(this.id).forEach((view) => {
                view.setSelection(propertyName, propertyValue);
            });
        }
    }

    highlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.highlightSyntax();
        }
    }

    unhighlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.unhighlightSyntax();
        }
    }

    get type(){
        return 'field';
    }
};




/***/ }),

/***/ "./js/objects/parts/Image.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Image.js ***!
  \***********************************/
/*! exports provided: Image, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return Image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Image; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");




class Image extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newDynamicProp(
            "src",
            this.setSource,
            this.getSource
        );

        this._src = src;

        this.partProperties.newBasicProp(
            "mimeType",
            "unknown"
        );

        this.partProperties.newBasicProp(
            "imageData",
            null
        );

        this.partProperties.newBasicProp(
            'draggable',
            false
        );

        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "black"
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadImageFrom", this.loadImageFromSource);
        this.setPrivateCommandHandler("loadImageFromFile", this.loadImageFromFile);

        // Bind component methods
        this.loadImageFromSource = this.loadImageFromSource.bind(this);
        this.loadImageFromFile = this.loadImageFromFile.bind(this);
    }


    loadImageFromSource(senders, sourceUrl){
        fetch(sourceUrl)
            .then(response => {
                let contentType = response.headers.get('content-type');
                if(!contentType.startsWith('image')){
                    throw new Error(`Invalid image mimeType: ${contentType}`);
                }
                this.partProperties.setPropertyNamed(
                    this,
                    "mimeType",
                    contentType
                );
                if(contentType.startsWith("image/svg")){
                    return response.text().then(text => {
                        this.partProperties.setPropertyNamed(
                            this,
                            'imageData',
                            text
                        );
                    });
                } else {
                    return response.blob().then(blob => {
                        let reader = new FileReader();
                        reader.onloadend = () => {
                            this.partProperties.setPropertyNamed(
                                this,
                                'imageData',
                                reader.result // will be the base64 encoded data
                            );
                        };
                        reader.readAsDataURL(blob);
                    });
                }
            })
            .then(() => {
                // Manually set the _src.
                // This ensures that we don't infinitely
                // call the load operation
                this._src = sourceUrl;
            })
            .catch(err => {
                console.error(err);
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    null
                );
            });
    }

    loadImageFromFile(){
        let filePicker = document.createElement('input');
        filePicker.type = 'file';
        filePicker.setAttribute('accept', 'image/*');
        filePicker.style.display = 'none';
        filePicker.addEventListener('change', (event) => {
            // Handle the file here
            let reader = new FileReader();
            reader.onloadend = () => {
                this.partProperties.setPropertyNamed(
                    this,
                    'mimeType',
                    filePicker.files[0].type
                );
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    reader.result
                );
            };
            let imageFile = filePicker.files[0];
            if(imageFile.type.includes('svg')){
                reader.readAsText(imageFile);
            } else {
                reader.readAsDataURL(imageFile);
            }
            filePicker.remove();
        });
        document.body.append(filePicker);
        filePicker.click();
    }

    setSource(owner, property, value){
        owner._src = value;
        if(value){
            owner.loadImageFromSource([this], value);
        }
    }

    getSource(owner, property){
        return owner._src;
    }

    get type(){
        return 'image';
    }

    get isSvg(){
        let mimeType = this.partProperties.getPropertyNamed(
            this,
            "mimeType"
        );
        if(!mimeType){
            return false;
        }

        return mimeType.startsWith('image/svg');
    }
};




/***/ }),

/***/ "./js/objects/parts/Part.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Part.js ***!
  \**********************************/
/*! exports provided: Part, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Part", function() { return Part; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Part; });
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/errorHandler.js */ "./js/objects/utils/errorHandler.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/**
 * Part
 * -------------------------------
 * I represent the prototype object for all
 * SimpleTalk parts.
 */







class Part {
    constructor(anOwnerPart, name, deserializing=false){

        this.name = this.constructor.name;

        // An array of child parts
        this.subparts = [];
        // a list of all accepted subparts by type
        // By default this is null and each Part subclcass should
        // specify if otherwise
        this.acceptedSubpartTypes = [];

        this.partProperties = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["PartProperties"]();
        this._owner = anOwnerPart;
        this._commandHandlers = {};
        this._privateCommandHandlers = {};
        this._functionHandlers = {};
        this._scriptSemantics = {};
        this._propertySubscribers = new Set();
        this._viewSubscribers = new Set();
        this._stepIntervalId = null;

        this.isPart = true;

        // Bind methods
        this.setupProperties = this.setupProperties.bind(this);
        this.setupStyleProperties = this.setupStyleProperties.bind(this);

        this.addPart = this.addPart.bind(this);
        this.removePart = this.removePart.bind(this);
        this.acceptsSubpart = this.acceptsSubpart.bind(this);
        this.setPrivateCommandHandler = this.setPrivateCommandHandler.bind(this);
        this.removePrivateCommandHandler = this.removePrivateCommandHandler.bind(this);
        this.setFuncHandler = this.setFuncHandler.bind(this);
        this.receiveCmd = this.receiveCmd.bind(this);
        this.receiveFunc = this.receiveFunc.bind(this);
        this.receiveError = this.receiveError.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.delegateMessage = this.delegateMessage.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.addPropertySubscriber = this.addPropertySubscriber.bind(this);
        this.removePropertySubscriber = this.removePropertySubscriber.bind(this);
        this.addViewSubscriber = this.addViewSubscriber.bind(this);
        this.removeViewSubscriber = this.removeViewSubscriber.bind(this);
        this.serialize = this.serialize.bind(this);
        this.toJSON = this.toJSON.bind(this);
        this.setPropsFromDeserializer = this.setPropsFromDeserializer.bind(this);
        this.findAncestorOfType = this.findAncestorOfType.bind(this);
        this.openEditorCmdHandler = this.openEditorCmdHandler.bind(this);
        this.closeEditorCmdHandler = this.closeEditorCmdHandler.bind(this);
        this.copyCmdHandler = this.copyCmdHandler.bind(this);
        this.pasteCmdHandler = this.pasteCmdHandler.bind(this);
        this.isSubpartOfCurrentCard = this.isSubpartOfCurrentCard.bind(this);
        this.isSubpartOfCurrentStack = this.isSubpartOfCurrentStack.bind(this);
        this.getOwnerBranch = this.getOwnerBranch.bind(this);
        this.startStepping = this.startStepping.bind(this);
        this.stopStepping = this.stopStepping.bind(this);
        this.setTargetProp = this.setTargetProp.bind(this);
        this.move = this.move.bind(this);
        this.moveSubpartUp = this.moveSubpartUp.bind(this);
        this.moveSubpartDown = this.moveSubpartDown.bind(this);
        this.moveSubpartToFirst = this.moveSubpartToFirst.bind(this);
        this.moveSubpartToLast = this.moveSubpartToLast.bind(this);



        // Finally, we finish initialization
        this.setupProperties();

        // command handlers
        this.setPrivateCommandHandler("openEditor", this.openEditorCmdHandler);
        this.setPrivateCommandHandler("closeEditor", this.closeEditorCmdHandler);
        this.setPrivateCommandHandler("setTargetTo", this.setTargetProp);
        this.setPrivateCommandHandler("copy", this.copyCmdHandler);
        this.setPrivateCommandHandler("paste", this.pasteCmdHandler);
        this.setPrivateCommandHandler("move", this.move);
        this.setPrivateCommandHandler("moveUp", () => {this._owner.moveSubpartUp(this);});
        this.setPrivateCommandHandler("moveDown", () => {this._owner.moveSubpartDown(this);});
        this.setPrivateCommandHandler("moveToFirst", () => {this._owner.moveSubpartToFirst(this);});
        this.setPrivateCommandHandler("moveToLast", () => {this._owner.moveSubpartToLast(this);});
    }

    // Convenience getter to get the id
    // from the partProperties
    get id(){
        return this.partProperties.getPropertyNamed(this, 'id');
    }

    set id(val){
        return this.partProperties.setPropertyNamed(this, 'id', val);
    }


    // Return an array of names of all of my and my ancestors' handlers
    // for the moment this is just names, type, id and whether the handler overrides
    // an owner's, but could be richer info, such as arguments, documentation etc
    get commandHandlerRegistry(){
        let handlersInfo = {};
        let ownerBranch = this.getOwnerBranch();
        for(let i = 1; i <= ownerBranch.length; i++){
            let part = ownerBranch[ownerBranch.length - i];
            let partType = part.type;
            if(part.id === -1){
                partType = "System";
            } else {
                // System doesn't have private command handlers
                Object.keys(part._privateCommandHandlers).forEach((h) => {
                    let override = false;
                    if(handlersInfo[h]){
                        override = true;
                    }
                    handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: true};
                });
            }
            Object.keys(part._commandHandlers).forEach((h) => {
                let override = false;
                if(handlersInfo[h]){
                    override = true;
                }
                handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: false};
            });
        }
        return handlersInfo;
    }

    // returns the this.part -> System branch by part id
    getOwnerBranch(branch){
        if(!branch){
            branch = [this];
        }
        if(this.type === "world"){
            branch.push(window.System);
            return branch;
        } else {
            branch.push(this._owner);
        };
        return this._owner.getOwnerBranch(branch);
    }

    // Configures the specific properties that the
    // given part can expect, along with any default
    // values.
    // Descendant Parts should override this method
    // in their own constructor after calling super,
    // so that they get the parent's general properties
    // too.
    setupProperties(){
        // Here, we set up properties common
        // to ALL Parts in the system.
        let basicProps = [
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'target',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'contents',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'enabled',
                true
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'wants-move',
                false
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'id',
                _utils_id_js__WEBPACK_IMPORTED_MODULE_0__["idMaker"].new()
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'name',
                `New ${this.type}`
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'rectangle',
                "0, 0, 0, 0",
                true,
                ['rect']
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'script',
                null // For now
            ),

            // Styling
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssStyle',
                {},
                false,
            ),
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssTextStyle',
                {},
                false,
            )
        ];
        basicProps.forEach(prop => {
            this.partProperties.addProperty(prop);
        });

        // the index number of the part in part._owner.subpart
        // array. Note: this is 1-indexed
        this.partProperties.newDynamicProp(
            'number',
            null, // no setter
            function(propOwner, propObject){
                if(propOwner.type == "world"){
                    return 1;
                }
                return propOwner._owner.subparts.indexOf(propOwner) + 1;
            },
            true // readonly
        );

        this.partProperties.newDynamicProp(
            'target',
            function(propOwner, propObject, val){
                // check to see if the target is a non-ID
                let id = Object(_utils_id_js__WEBPACK_IMPORTED_MODULE_0__["isValidId"])(val);
                if(id){
                    // if it is an ID insert "part" since our
                    // grammar doesn't handle ID without system object
                    // prefixes
                    propObject._value = `part id ${val}`;
                } else {
                    propObject._value = val;
                }
            },
            function(propOwner, propObject){
                return propObject._value;
            },
            false,
            null,
        ),

        // Custom Properties store props defined within the
        // ST environment
        this.partProperties.newCustomProp(
        ),

        // Stepping related props

        this.partProperties.newDynamicProp(
            // The time in milliseconds between
            // sends of the step command if the
            // stepping property is set to true
            'stepTime',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(propOwner.isStepping){
                    // Interrupt the current interval
                    // and restart with new stepTime
                    propOwner.stopStepping();
                    this._value = value;
                    propOwner.startStepping();
                } else{
                    this._value = value;
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                return this._value;
            },
            false, // can read and write
            500 // Default to half a second
        );

        this.partProperties.newDynamicProp(
            'stepping',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(value === false && propOwner.isStepping){
                    propOwner.stopStepping();
                } else if(value === true && !propOwner.isStepping){
                    propOwner.startStepping();
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                // If the intervalId is set, then
                // the Part is currently stepping
                return propOwner.isStepping;
            },
        );

    }

    // To be called in each sub-class that has StyleProperties
    // called after the style props are configured
    setupStyleProperties(){
        this.partProperties._properties.forEach((prop) => {
            if(prop.constructor.name === "StyleProperty"){
                // setting the value on itself ensures that the cssStyle
                // BasicProperty is updated with the appropriate styler
                // conversion css key-val
                prop.setValue(this, prop._value);
            }
        });
    }

    /** Subpart Access **/
    /**
     * Each subclass will implement its own set of checks,
     * and throw an approprite error if the subpart type is invalid.
     */
    acceptsSubpart(aPartType){
        if (this.acceptedSubpartTypes[0] === "*"){
            return true;
        }
        return this.acceptedSubpartTypes.includes(aPartType.toLowerCase());
    }

    /**
     * Adds a part to this part's subparts
     * collection, if not already present.
     * It will also set the owner of the
     * added part to be this part.
     */
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            this.subparts.push(aPart);
            aPart._owner = this;
        }
    }

    /**
     * Removes the given part from this
     * part's list of subparts (if present).
     * It will also unset the owner of the
     * given part.
     */
    removePart(aPart){
        let partIndex = this.subparts.indexOf(aPart);
        if(partIndex >= 0){
            this.subparts.splice(partIndex, 1);
            aPart._owner = null;
        }
    }

    /** Checks whether the Part instance is a subpart of the current
     * Card.
     */
    isSubpartOfCurrentCard(){
    }

    /** Checks whether the Part instance is a subpart of the current
     * Stack.
     */
    isSubpartOfCurrentStack(){
    }

    /** Logging and Reporting **/
    shouldBeImplemented(functionName){
        let msg = `${this.constructor.name} should implement ${functionName}`;
        throw new Error(msg);
    }

    /** Message Handling and Delegation **/
    delegateMessage(aMessage){
        return this.sendMessage(
            aMessage,
            this._owner
        );
    }

    sendMessage(aMessage, target){
        return window.System.sendMessage(aMessage, this, target);
    }

    receiveMessage(aMessage){
        // By default, Parts will only handle
        // messages of type 'command' and 'function'
        switch(aMessage.type){
            case 'command':
                return this.receiveCmd(aMessage);
                //break;
            case 'function':
                return this.receiveFunc(aMessage);
                //break;
            case 'error':
                return this.receiveError(aMessage);
            default:
                return this.delegateMessage(aMessage);
        }
    }

    receiveError(aMessage){
        return _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].handle(aMessage);
    }

    receiveCmd(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = handler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        let privateHandler = this._privateCommandHandlers[aMessage.commandName];
        if(privateHandler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = privateHandler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        // Otherwise, we have no handler for
        // it. Unless the message indicates shouldNotDelegate
        // we delegate along the
        // message delegation chain. It is up
        // to Parts to properly implement delegation
        // for themselves!
        if(aMessage.shouldNotDelegate){
            return aMessage;
        }
        return this.delegateMessage(aMessage);
    }

    receiveFunc(aMessage){
        let handler = this._functionHandlers[aMessage.functionName];

        if(handler){
            let boundHandler = handler.bind(this);
            return boundHandler();
        } else {
            return this.delegateMessage(aMessage);
        }
    }

    setPrivateCommandHandler(commandName, handler){
        this._privateCommandHandlers[commandName] = handler;
    }

    removePrivateCommandHandler(commandName){
        delete this._privateCommandHandlers[commandName];
    }

    setFuncHandler(funcName, handler){
        this._functionHandlers[funcName] = handler;
    }

    /** Command Handlers
        ----------------
        Command handlers which are invoked at the Part level
        which are not immediately delegaed to the Part._owner
    **/

    openEditorCmdHandler(){
        let editor = document.querySelector('st-editor');
        editor.render(this);
        if(!editor.isOpen){
            editor.open();
        }
    }

    closeEditorCmdHandler(){
        let editor = document.querySelector('st-editor.open');
        if(editor){
            editor.close();
        }
    }

    setTargetProp(senders, ...args){
        let target = args.join(" ");
        this.partProperties.setPropertyNamed(this, "target", target);
    }

    copyCmdHandler(){
        window.System.clipboard.copyPart(this);
    }

    pasteCmdHandler(){
        if(!window.System.clipboard.isEmpty){
            let item = window.System.clipboard.contents[0];
            if(item.type == 'simpletalk/json' && this.acceptsSubpart(item.partType)){
                window.System.clipboard.pasteContentsInto(this);
            }
        }
    }

    move(senders, movementX, movementY){
        if(!this.partProperties.getPropertyNamed(this, "wants-move")){
            throw Error(`Part ${this.id} trying to move with 'wants-move' property false`);
        }
        let top = this.partProperties.getPropertyNamed(this, "top");
        top += movementY;
        this.partProperties.setPropertyNamed(this, "top", top);
        let left = this.partProperties.getPropertyNamed(this, "left");
        left += movementX;
        this.partProperties.setPropertyNamed(this, "left", left);
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex < this.subparts.length - 1){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex > 0){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    // Note: moveSubpartToFirst means move to first in the view
    // i.e. last as a subaprt
    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, 0);
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, this.subparts.length - 1);
    }

    /** Property Subscribers
        ------------------------
        Objects added as property subscribers
        will be 'notified' whenever one of this
        Part's properties changes
    **/
    addPropertySubscriber(anObject){
        this._propertySubscribers.add(anObject);
    }

    removePropertySubscriber(anObject){
        this._propertySubscribers.delete(anObject);
    }

    propertyChanged(propertyName, newValue){
        let message = {
            type: 'propertyChanged',
            propertyName: propertyName,
            value: newValue,
            partId: this.id
        };
        this._propertySubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    /** View Subscribers
        ------------------------
        Objects added as view subscribers
        will be 'notified' whenever this Part
        incurrs a view change (add, delete subparts, reorder etc)
    **/
    addViewSubscriber(anObject){
        this._viewSubscribers.add(anObject);
    }

    removeViewSubscriber(anObject){
        this._viewSubscribers.delete(anObject);
    }

    viewChanged(changeName, ...args){
        let message = {
            type: 'viewChanged',
            changeName: changeName,
            partId: this.id,
            args: args
        };
        this._viewSubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpart = this.subparts.splice(currentIndex, 1)[0];
        this.subparts.splice(newIndex, 0, subpart);
        this.viewChanged("subpart-order", id, currentIndex, newIndex);
    }

    startStepping(){
        if(this._stepIntervalId){
            this.stopStepping();
        }
        let stepTime = this.partProperties.getPropertyNamed(
            this,
            'stepTime'
        );
        if(stepTime > 0){
            this._stepIntervalId = setInterval(() => {
                this.sendMessage({
                    type: 'command',
                    commandName: 'step',
                    args: []
                }, this);
            }, stepTime);
        }
    }

    stopStepping(){
        clearInterval(this._stepIntervalId);
        this._stepIntervalId = null;
    }

    get isStepping(){
        // We know the Part is currently stepping
        // of the stored intervalId is set to
        // something besides null
        return this._stepIntervalId !== null;
    }

    /**
     * Serialize this Part's state as JSON.
     * By default, we do not serialize specific
     * PartCollection information (recursively),
     * and only include basics including the current
     * state of all properties.
     */
    serialize(){
        let ownerId = null;
        if(this._owner){
            ownerId = this._owner.id;
        }
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: ownerId
        };
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    /**
     * Set the properties and other
     * attributes of this Part model
     * from a deserialized JSON object.
     */
    setPropsFromDeserializer(incomingProps, deserializer){
        Object.keys(incomingProps).forEach(propName => {
            let property = this.partProperties.findPropertyNamed(propName);
            if(!property){
                // If some old or invalid property is
                // present in the deserialization, simply provide
                // a warning and then skip this one.
                console.warn(`Deserialized property "${propName}" is not a valid property name for ${this.type} (id ${this.id}) and will be ignored`);
            } else if(propName == "custom-properties"){
                // custom properties are serialized as an object like other props
                // and we need to create properties from these and set their respective
                // values. Then we need to set the value of "custom-properties" prop
                // itself to be the object containing all of these
                let customPropsData = incomingProps[propName];
                let newCustomPropsObject = {};
                Object.values(customPropsData).forEach((propData) => {
                    let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](propData.name, null);
                    newProp.setValue(this, propData._value, false); // no need to notify
                    newCustomPropsObject[propData.name] = newProp;
                });
                property.setValue(this, newCustomPropsObject, false); // no need to notify
            } else if(!property.readOnly){
                // Last arg is false, which tells the property
                // not to notify its owner's subscribers of
                // property changes. We don't need that when
                // deserializing
                property.setValue(this, incomingProps[propName], false);
            }
        });
    }

    toJSON(){
        return this.serialize();
    }

    findAncestorOfType(aPartType){
        let owner = this._owner;
        while(owner){
            if(owner.type == aPartType){
                return owner;
            }
            owner = owner._owner;
        }
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Resource.js":
/*!**************************************!*\
  !*** ./js/objects/parts/Resource.js ***!
  \**************************************/
/*! exports provided: Resource, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return Resource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Resource; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Resource extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);
        this.resource = null;

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "notReady"
        );

        this.partProperties.newBasicProp(
            "prerequisite",
            null
        );

        this.partProperties.newBasicProp(
            "resourceName",
            null
        );

        this.partProperties.newBasicProp(
            "response",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadResource", this.loadResource);
        this.setPrivateCommandHandler("setSourceTo", this.setSourceTo);
        this.setPrivateCommandHandler("get", this.get);

        // Bind component methods
        this.loadResource = this.loadResource.bind(this);
        this.get = this.get.bind(this);
        this.reset = this.reset.bind(this);

        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'resource';
    }

    loadResource(senders, resourceName){
        if(!window.System.availableResources || !window.System.availableResources[resourceName]){
            // TODO this should be a ST error
            throw Error(`resource ${resourceName} not found`);
        }
        this.resource = window.System.availableResources[resourceName];
        this.partProperties.setPropertyNamed(this, "resourceName", resourceName);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();
    }

    setSourceTo(senders, sourceUrl){
        if(!this.resource){
            // TODO this should be a ST error
            throw Error(`no resource loaded for resource part id ${this.id}`);
        }
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
        this.resource.load(sourceUrl);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();

    }

    get(senders, ...args){
        this.partProperties.setPropertyNamed(this, "readyState", "fetching");
        let prerequisite = this.partProperties.getPropertyNamed(this, "prerequisite");
        this.resource.get(prerequisite, ...args).then((response) => {
            this.partProperties.setPropertyNamed(this, "response", response);
            this.partProperties.setPropertyNamed(this, "readyState", "ready");
            this.sendMessage({
                type: "command",
                commandName: "responded",
                args: [this.id, this.resource.name],
                shouldIgnore: true
            }, this);
        }, (error) => {
            this.partProperties.setPropertyNamed(this, "readyState", "error");
            this.partProperties.setPropertyNamed(this, "response", null);
            this.sendMessage({
                type: "command",
                commandName: "errored",
                args: [this.id, this.resource.name, error.message],
                shouldIgnore: true
            }, this);
        });
    }

    reset(){
        this.partProperties.setPropertyNamed(this, "readyState", "notReady");
        this.partProperties.setPropertyNamed(this, "response", null);
    }
};




/***/ }),

/***/ "./js/objects/parts/Stack.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Stack.js ***!
  \***********************************/
/*! exports provided: Stack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Card_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/**
 * Stack
 * ----------------------------
 * I am the Stack Part.
 * I represent a collection of Card parts,
 * along with some extra configurability.
 */




class Stack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, deserializing=false){
        super(owner);
        this.acceptedSubpartTypes = [
            "card", "window", "button", "area", "field",
            "drawing", "image", "audio", "browser"
        ];

        // Set up Stack specific
        // PartProperties
        this.partProperties.newBasicProp(
            'cantPeek',
            false
        );
        this.partProperties.newBasicProp(
            'resizable',
            false
        );


        // Will hold the card-based index,
        // which here is zero-indexed, of the
        // card that is the current card for this
        // Stack.
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Bind general methods
        this.sendOpenCardTo = this.sendOpenCardTo.bind(this);
        this.sendCloseCardTo = this.sendCloseCardTo.bind(this);

        // Bind stack navigation methods
        this.goToNextCard = this.goToNextCard.bind(this);
        this.goToPrevCard = this.goToPrevCard.bind(this);
        this.goToCardById = this.goToCardById.bind(this);
        this.goToNthCard = this.goToNthCard.bind(this);
    }

    goToNextCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= cards.length){
            nextIdx = (nextIdx % cards.length);
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToCardById(anId){
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let cards = Object.values(window.System.partsById).filter((part) => {
            return part.type == "card";
        });
        let nextCard = cards.find(card => {
            return card.id == anId;
        });
        if(!nextCard){
            throw new Error(`The card id: ${anId} cant be found stack`);
        }
        // if the card is not on this stack we should go to the corresponding stack
        if(nextCard._owner != this){
            this._owner.goToStackById(nextCard._owner.id);
        }
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToPrevCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);

        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = cards.length + nextIdx;
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToNthCard(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(trueIndex < 0 || trueIndex > cards.length -1){
            console.warn(`Cannot navigate to card number ${anIndex} -- out of bounds`);
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let nextCard = cards[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
           nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    sendCloseCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    sendOpenCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    get type(){
        return 'stack';
    }

    get currentCardId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentCard(){
        return window.System.partsById[this.currentCardId];
    }

    // override the base class methods
    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a card then append after the last card
            if(aPart.type == "card"){
                let allCards = this.subparts.filter((part) => {
                    return part.type == "card";
                });
                this.subparts.splice(allCards.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }
};




/***/ }),

/***/ "./js/objects/parts/Window.js":
/*!************************************!*\
  !*** ./js/objects/parts/Window.js ***!
  \************************************/
/*! exports provided: Window, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Window", function() { return Window; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Window; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Window Part
 * ------------------------
 * A Window is a Part that wraps another
 * Part of type Card, Stack, or WorldStack
 * in a moveable window.
 * I can also optionally hold a reference
 * to a target Part that I do not own. I call
 * this JS property target and I store the
 * target part's id as a HyperTalk property
 * called targetId.
 * When my owner part is the current view, I
 * will be visible on top of everything else.
 */




class Window extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, target, deserializing=false){
        super(owner, name);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
        ];

        // If we pass in a target,
        // set it.
        if(target){
            this.setTarget(target);
        }

        // Set up Window specific
        // part ptoperties
        this.partProperties.newBasicProp(
            'targetId',
            null
        );

        this.partProperties.newBasicProp(
            'title',
            "New Window Title"
        );

        this.partProperties.newBasicProp(
            'isResizable',
            true
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );

        // Bind methods
        this.setTarget = this.setTarget.bind(this);
        this.onWindowClose = this.onWindowClose.bind(this);

        // Add private handlers
        this.setPrivateCommandHandler('windowClose', this.onWindowClose);
    }

    setTarget(aPart){
        this.target = aPart;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            this.target.id
        );
    }

    unsetTarget(){
        this.target = null;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            null
        );
    }

    /**
     * Override
     * Unlike other kinds of Parts, a window
     * has only one subpart, which should be
     * Card, Stack, or WorldStack.
     */
    addPart(aPart){
        let isValid = this.acceptsSubpart(aPart.type);
        if(!isValid){
            // Consider replacing this generic exception
            // with a message based approach that sends
            // these sorts of non-fatal errors to System
            // as a kind of message. This way we can display
            // errors in SimpltTalk objects.
            throw new Error(`Windows cannot wrap parts of type ${aPart.type}`);
        }
        this.subparts.forEach(subpart => {
            this.removePart(subpart);
        });
        this.subparts.push(aPart);
        aPart._owner = this;
    }

    onWindowClose(senders, ...args){
        // Default behavior is to delete
        // the window model from the System.
        // Scripts can override this handler
        this.sendMessage(
            {
                type: 'command',
                commandName: 'deleteModel',
                args: [ this.id ]
            },
            window.System
        );
    }

    get type(){
        return 'window';
    }
}




/***/ }),

/***/ "./js/objects/parts/WorldStack.js":
/*!****************************************!*\
  !*** ./js/objects/parts/WorldStack.js ***!
  \****************************************/
/*! exports provided: WorldStack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldStack", function() { return WorldStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldStack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/**
 * WorldStack
 * ---------------------------------------------------
 * I am a Stack part that represents the root of a
 * hierarchy of parts. I am the end of the ownership
 * chain for any given configuration of Parts.
 * I am also the final resolver of all unhandled
 * messages sent along the delegation chain for parts.
 * All parts can eventually resolve to me via the delegation
 * chain or ownership hierarchy.
 * There should only be one instance of me in any given
 * SimpleTalk environment.
 */



class WorldStack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super(null);

        this.acceptedSubpartTypes = ["stack", "image"];

        this.isWorld = true;

        // This property specifies the stack
        // id of the current stack
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Set the id property to always
        // be 'world'
        this.id = 'world';

        // Bind general methods
        this.sendOpenStackTo = this.sendOpenStackTo.bind(this);
        this.sendCloseStackTo = this.sendCloseStackTo.bind(this);

        // Bind navigation methods
        this.goToNextStack = this.goToNextStack.bind(this);
        this.goToPrevStack = this.goToPrevStack.bind(this);
        this.goToNthStack = this.goToNthStack.bind(this);
        this.goToStackById = this.goToStackById.bind(this);

        // remove command handlers which are not needed for world
        this.removePrivateCommandHandler("moveUp");
        this.removePrivateCommandHandler("moveDown");
        this.removePrivateCommandHandler("moveToFirst");
        this.removePrivateCommandHandler("moveToLast");
    }

    goToNextStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= stacks.length){
            nextIdx = (nextIdx % stacks.length);
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToStackById(anId){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        let nextStack = stacks.find(stack => {
            return stack.id == anId;
        });
        if(!nextStack){
            throw new Error(`The stack id: ${anId} cant be found on this stack`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToPrevStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = stacks.length + nextIdx;
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToNthStack(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(trueIndex < 0 || trueIndex > stacks.length -1){
            throw new Error(`Cannot navigate to stack number ${anIndex} -- out of bounds`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let nextStack = stacks[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    sendCloseStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'closeStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    sendOpenStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command', 
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    get type(){
        return 'world';
    }

    get loadedStacks(){
        return this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
    }

    // Override normal Part serialization.
    // Here we need to also include an array of ids of
    // loaded stacks and the id of the current stack
    serialize(){
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: null,
            loadedStacks: (this.loadedStacks.map(stack => {
                return stack.id;
            })),
        };

        // Serialize current part properties
        // values
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    // Override for delegation.
    // We send any messages that should be delegated
    // to the global System object, which has any
    // 'handlers of last resort'
    delegateMessage(aMessage){
        return this.sendMessage(aMessage, window.System);
    }

    get currentStackId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentStack(){
        return window.System.partsById[this.currentStackId];
    }

    // override the base class methods
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a stack then append after the last stack
            if(aPart.type == "stack"){
                let allStacks = this.subparts.filter((part) => {
                    return part.type == "stack";
                });
                this.subparts.splice(allStacks.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

};




/***/ }),

/***/ "./js/objects/properties/PartProperties.js":
/*!*************************************************!*\
  !*** ./js/objects/properties/PartProperties.js ***!
  \*************************************************/
/*! exports provided: PartProperties, BasicProperty, CustomProperty, DynamicProperty, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartProperties", function() { return PartProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicProperty", function() { return BasicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomProperty", function() { return CustomProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicProperty", function() { return DynamicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartProperties; });
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");


/**
 * PartProperties
 * ------------------------------------
 * I am an object representing the base
 * Part Properties for all Parts.
 * I also include some convenience methods
 * on my prototype that should be used by
 * other Parts when they inherit from me.
 * For now, we use Object.create() for inheritance.
 */

class BasicProperty {
    constructor(name, defaultValue, readOnly=false, aliases=[]){
        this.name = name;
        this._value = defaultValue;
        this.readOnly = readOnly;
        this.aliases = aliases;

        // Bound methods
        this.getValue = this.getValue.bind(this);
        this.setValue = this.setValue.bind(this);
        this.hasAlias = this.hasAlias.bind(this);
        this.matches = this.matches.bind(this);
        this.matchesNameOrAlias = this.matchesNameOrAlias.bind(this);
    }

    // For basic properties, we return
    // the set/stored value
    getValue(owner){
        return this._value;
    }

    // For the basic properties, we set
    // based on the incoming desired value
    // alone (nothing is computed)
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }

    // Returns true if this property
    // goes by the given alias
    hasAlias(anAlias){
        return this.aliases.includes(anAlias);
    }

    // Returns true if the given name is
    // either an alias or the exact name
    // for this property
    matchesNameOrAlias(aNameOrAlias){
        if(this.hasAlias(aNameOrAlias)){
            return true;
        } else if(aNameOrAlias == this.name){
            return true;
        }
        return false;
    }

    // Returns true if the incoming Property
    // has the same name and/or one of the same
    // aliases as this Property
    matches(aProperty){
        if(aProperty.name == this.name){
            return true;
        } else {
            for(let i = 0; i < this.aliases.length; i++){
                let myAlias = this.aliases[i];
                if(aProperty.hasAlias(myAlias)){
                    return true;
                }
            }
        }
        return false;
    }
};


/** Custom Properties are similar to dynamic props, except that
  * under the hood they store an object of properties
  * storing props defined within the ST environment. The find()
  * add() delete() methods find, add, or remove properties from the
  * this.customProperties object.
 **/
class CustomProperty extends BasicProperty {
    constructor(name="custom-properties", defaultValue={}, readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly=false, aliases);
    }

    find(name){
        let prop = this._value[name];
        if(prop){
            return prop;
        }
        return null;
    }

    add(aProperty){
        // NOTE: aliases are completed ignored for now
        if(!this.find(aProperty.name)){
            this._value[aProperty.name] = aProperty;
        }
    }

    delete(aProperty){
        delete this._value[aProperty.name];
    }



};

class DynamicProperty extends BasicProperty {
    constructor(name, setter, getter, readOnly=false, defaultValue=null, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.valueSetter = setter;
        this.valueGetter = getter;
    }

    // In this override, we use the getter
    // if available, to dynamically get the
    // incoming value.
    getValue(owner){
        return this.valueGetter(owner, this);
    }

    // In this override, we use the setter
    // if available, to dynamically set the
    // incoming value
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this.valueSetter(owner, this, val, notify);
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};


/** I am a special property which handles interfacing with the
  * the cssStyle basic property. Whenever I am updated I make
  * sure to update the cssStyle property via the styler utility
  * function. I can be used to create different and indepent
  * styling options.
  **/
class StyleProperty extends BasicProperty {
    constructor(name, defaultValue,  propName='cssStyle', styler=_utils_styler_js__WEBPACK_IMPORTED_MODULE_0__["default"], readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.propName = propName;
        this.styler = styler;
    }

    // In this override, we update the cssStyle property
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            let styleProperty = owner.partProperties.findPropertyNamed(this.propName);
            let style = styleProperty.getValue(owner);
            let newStyle = this.styler(style, this.name, val);
            styleProperty.setValue(owner, newStyle, notify);

            // set my value as well
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};

class PartProperties {
    constructor(){
        this._properties = [];

        // Bound methods
        this.hasProperty = this.hasProperty.bind(this);
        this.addProperty = this.addProperty.bind(this);
        this.removeProperty = this.removeProperty.bind(this);
        this.findPropertyNamed = this.findPropertyNamed.bind(this);
        this.setPropertyNamed = this.setPropertyNamed.bind(this);
        this.getPropertyNamed = this.getPropertyNamed.bind(this);
        this.newBasicProp = this.newBasicProp.bind(this);
        this.newStyleProp = this.newStyleProp.bind(this);
        this.newDynamicProp = this.newDynamicProp.bind(this);
        this._indexOfProperty = this._indexOfProperty.bind(this);
    }

    get all(){
        return this._properties;
    }

    // This collection 'has' a property if it contains
    // a Property object with matching name or alias
    // of the incoming property.
    hasProperty(aProperty){
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return true;
            }
        }
        return false;
    }

    // Find one of my Properties by
    // a name or alias. Returns null
    // if no match found. Perhaps we should
    // throw an error
    findPropertyNamed(aName){
        let found = null;
        let customPropertiesProp;
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(prop.matchesNameOrAlias(aName)){
                found = prop;
            }
            // grab the custom properties prop, as we might need it
            // for later
            if(prop.matchesNameOrAlias("custom-properties")){
                customPropertiesProp = prop;
            }
        }
        // see if the property is custom
        if(!found && customPropertiesProp){
            found = customPropertiesProp.find(aName);
        }
        return found;
    }

    // Attempts to get the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    getPropertyNamed(owner, aName){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.getValue(owner);
    }

    // Attempts to set the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    setPropertyNamed(owner, aName, aValue, notify=true){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.setValue(owner, aValue, notify);
    }

    // If you add a property with a name or alias
    // that is already present in the collection,
    // then we 'overwrite' it by removing the exising
    // property and replacing it with the incoming one.
    // Otherwise, we just add the property
    addProperty(aProperty){
        if(this.hasProperty(aProperty)){
            this.removeProperty(aProperty);
        }
        this._properties.push(aProperty);
    }

    // Removing a property here means removing
    // it from the stored array. If the property
    // is not in the array, we do NOT throw an error.
    // We just go on with our lives, because who cares?
    removeProperty(aProperty){
        let propIndex = this._indexOfProperty(aProperty);
        if(propIndex >= 0){
            this._properties.splice(propIndex, 1);
        }
    }

    // Convenience method for creating a new basic
    // property.
    newBasicProp(...args){
        let newProp = new BasicProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new custom
    // property.
    newCustomProp(...args){
        let newProp = new CustomProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new style
    // property.
    newStyleProp(...args){
        let newProp = new StyleProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new
    // dynamic prop
    newDynamicProp(...args){
        let newProp = new DynamicProperty(...args);
        this.addProperty(newProp);
    }

    // Private method. Finds the first occurring
    // index of the given Property in the array
    // of properties in this collection. Returns
    // -1 if not found, per JS implementation.
    _indexOfProperty(aProperty){
        for(let i = 0; this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return i;
            }
        }
        return -1;
    }
};




/***/ }),

/***/ "./js/objects/utils/AltSyntaxHighlighter.js":
/*!**************************************************!*\
  !*** ./js/objects/utils/AltSyntaxHighlighter.js ***!
  \**************************************************/
/*! exports provided: createHighlighter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHighlighter", function() { return createHighlighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createHighlighter; });
/** Second pass at syntax highlighter semantics **/
const syntaxSpan = (ruleName) => {
    let span = document.createElement('span');
    span.classList.add('st-syntax');
    span.setAttribute('data-st-rule', ruleName);
    return span;
}

const createHighlighter = (fieldElement) => {
    return {
        MessageHandlerOpen: function(literalOn, messageName, optionalParamList){
            let span = syntaxSpan("MessageHandlerOpen");
            let onSpan = syntaxSpan("keyword");
            onSpan.append("on ");
            span.append(onSpan);

            // Append sub-rules
            span.append(messageName.highlightSyntax());
            span.append(...optionalParamList.highlightSyntax());

            return span;
        },

        MessageHandlerClose(literalEnd, messageName){
            let span = syntaxSpan("MessageHandlerClose");
            let endSpan = syntaxSpan("keyword");
            endSpan.append("end ");
            span.append(endSpan);

            // Add the parts
            span.append(messageName.highlightSyntax());

            return span;
        },

        ParameterList: function(paramString){
            let outer = syntaxSpan("ParameterList");
            let innerItems = paramString.asIteration().children.map(paramName => {
                let span = syntaxSpan("ParameterList-item");
                span.append(paramName.sourceString);
                return span.outerHTML;
            });
            outer.innerHTML = innerItems.join(", ");
            return outer;
            
        },

        messageName: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'messageName');
            span.append(string.sourceString + " ");
            return span;
        },

        keyword: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'keyword');
            span.append(string.sourceString);
            return span;
        }
    };
};




/***/ }),

/***/ "./js/objects/utils/clipboard.js":
/*!***************************************!*\
  !*** ./js/objects/utils/clipboard.js ***!
  \***************************************/
/*! exports provided: STClipboard, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STClipboard", function() { return STClipboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STClipboard; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _serialization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serialization.js */ "./js/objects/utils/serialization.js");
/**
 * Utilities for Clipboard Functionality
 * ------------------------------------------
 * For the moment we use a very primitive stand-in
 * since the Clipboard API is not standardized across
 * browser implementations.
 **/



class STClipboard {
    constructor(aSystem){
        this.system = aSystem;
        this.contents = [];

        // Bound methods
        this.copyPart = this.copyPart.bind(this);
        this.pasteContentsInto = this.pasteContentsInto.bind(this);
        this._createLensedChildren = this._createLensedChildren.bind(this);
    }

    copyPart(aPart){
        let serializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STSerializer"](this.system);
        let rootSerialization = serializer.serialize(aPart, false);
        let item = new STClipboardItem(
            'simpletalk/json',
            rootSerialization,
            aPart.type
        );
        this.contents = [item];
    }

    pasteContentsInto(aTargetPart){
        let promises = this.contents.map(clipboardContent => {
            let serializedContent = clipboardContent.data;
            let deserializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STDeserializer"](this.system);
            deserializer.targetId = aTargetPart.id;
            return deserializer.deserialize(serializedContent)
                .then(() => {
                    // Reset the top and left values to that
                    // the pasted part doesn't run outside of the new
                    // relative bounds in which it has been pasted
                    let newPart = deserializer.rootParts[0];
                    let hasTop = newPart.partProperties.findPropertyNamed('top');
                    let hasLeft = newPart.partProperties.findPropertyNamed('left');
                    if(hasTop){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'top',
                            10
                        );
                    }
                    if(hasLeft){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'left',
                            10
                        );
                    }
                    
                    // Open Halo on the new view
                    deserializer.rootViews[0].openHalo();

                    // Dispatch the CustomEvent that notifies listeners
                    // that a new view was added (used by Nav etc)
                    let event = new CustomEvent('st-view-added', {
                        detail: {
                            partType: newPart.type,
                            partId: newPart.id,
                            ownerId: newPart._owner.id
                        }
                    });
                    deserializer.rootViews[0].dispatchEvent(event);

                    // Add any lensed views that might be needed
                    let rootLensViews = this.system.findLensViewsById(newPart._owner.id);
                    rootLensViews.forEach(lensView => {
                        let newLensView = document.createElement(
                            this.system.tagNameForViewNamed(newPart.type)
                        );
                        newLensView.setModel(newPart);
                        newLensView.removeAttribute('part-id');
                        newLensView.setAttribute('lens-part-id', newPart.id);
                        newLensView.setAttribute('role', 'lens');
                        lensView.appendChild(newLensView);
                        this._createLensedChildren(newLensView, newPart.subparts);
                    });
                    
                    return;
                })
                .catch(err => {
                    throw err;
                });
        });
        return Promise.all(promises);
    }

    _createLensedChildren(aLensView, subparts){
        subparts.forEach(subpart => {
            let newLensView = document.createElement(
                this.system.tagNameForViewNamed(subpart.type)
            );
            newLensView.setModel(subpart);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', subpart.id);
            newLensView.setAttribute('role', 'lens');
            aLensView.appendChild(newLensView);
            this._createLensedChildren(newLensView, subpart.subparts);
        });
    }
    
    get isEmpty(){
        return this.contents.length <= 0;
    }
}

class STClipboardItem {
    constructor(mimeType, data, partType){
        if(mimeType){
            this.type = mimeType;
        }
        if(partType){
            this._partType = partType;
        }
        if(data){
            this.data = data;
        }
    }

    get partType(){
        if(this.type == 'simpletalk/json'){
            return this._partType;
        }
        return null;
    }

    set partType(val){
        this._partType = val;
    }
};




/***/ }),

/***/ "./js/objects/utils/errorHandler.js":
/*!******************************************!*\
  !*** ./js/objects/utils/errorHandler.js ***!
  \******************************************/
/*! exports provided: errorHandler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorHandler", function() { return errorHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return errorHandler; });
/**
 * Error Handler
 * ------------------------------------
 * I am responsible for handler all
 * System-wide errors
 */

const errorHandler = {

    handle: function(aMessage){
        switch(aMessage.name){
            case 'GrammarMatchError':
                return this.handleGrammarMatchError(aMessage);
            case 'MessageNotUnderstood':
                return this.handleMessageNotUnderstood(aMessage);
            default:
                // if I don't know what to do with this message
                // I send it along to the System
                return window.System.receiveMessage(aMessage);
        }
    },

    handleGrammarMatchError: function(aMessage){
        // TODO is there a more structured way to get this out of ohm?
        let regex = /Line (?<line>\d), col (?<column>\d)/;
        let match = aMessage.parsedScript.message.match(regex);
        let errorLineNum = parseInt(match.groups["line"]) - 1; // ohm lines start with 1 
        // see if the grammar rule has been identified
        let ruleName;
        let rightMostFailures = aMessage.parsedScript.getRightmostFailures();
        if(rightMostFailures[1]){
            ruleName = rightMostFailures[1].pexpr.ruleName;
        }
        // get some more info about what the parser expected
        let expectedText = aMessage.parsedScript.getExpectedText();
        // get the original script
        let text = aMessage.parsedScript.input;
        let textLines = text.split("\n");
        // replace said text line with an error marker
        textLines[errorLineNum] += ` --<<<[Expected:${expectedText}; ruleName: "${ruleName}"]`;
        text = textLines.join("\n");
        // if the first message in the parsed script is "doIt" then the statementLines are
        // located in the corresponding field text, not the script, property and
        // we want the error to be marked up in the field textarea
        if(aMessage.parsedScript.input.startsWith("on doIt")){
            let originalSenderModel = window.System.partsById[aMessage.partId];
            // we need to get the original text so as not to completely replace it
            // then insert the markup in the appropriate line
            let fieldText = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, "text");
            let script = aMessage.parsedScript.input;
            script = this._cleanDoItSCript(script);
            // we don't want the "doIt" handler inserted back in, since it's just a hidden wrapper for the
            // statement lines
            text = this._cleanDoItSCript(text);
            fieldText = fieldText.replace(script, text);
            originalSenderModel.partProperties.setPropertyNamed(originalSenderModel, "text", fieldText);
        } else {
            // first locate the script editor in question
            let scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            if(!scriptEditor){
                this._openScriptEditor(aMessage.partId);
                scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            }
            scriptEditor.model.partProperties.setPropertyNamed(scriptEditor.model, "text", text);
        }
        // open the grammar if there is not one open already
        let currentCard = window.System.getCurrentCardModel();
        let grammar = currentCard.subparts.filter((part) => {
            return (part.type == "field") && (part.partProperties.getPropertyNamed(part, "name") == "SimpleTalk");
        });
        if(grammar.length == 0){
            this._openGrammar(aMessage.partId, ruleName);
        }
    },

    handleMessageNotUnderstood(aMessage){
        let offendingMessage = aMessage.message;
        let originalSender = offendingMessage.senders[0];
        // Are we ever going to have MNU errors on messages that
        // are not type: command?
        if(offendingMessage.type === "command"){
            let commandName = offendingMessage.commandName;
            let originalSenderModel = window.System.partsById[originalSender.id];
            let regex = new RegExp(`\\s*${commandName}(\s|\n|$)`, 'g');
            let text;
            let target;
            let executionStack = window.System.executionStack._stack;
            // if the first message in the execution stack is "doIt" then the statementLines are
            // located in the corresponding field text, not the script, property and
            // we want the error to be marked up in the field textarea
            if(executionStack[0] && executionStack[0].messageName == "doIt"){
                target = executionStack[0].part;
                text = target.partProperties.getPropertyNamed(originalSenderModel, 'text');
            } else {
                text = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, 'script');
                let scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                if(!scriptEditor){
                    this._openScriptEditor(originalSender.id);
                    scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                }
                if(scriptEditor){
                    target = scriptEditor.model;
                }
            }
            // TODO Sort this out
            if(target){
                let textLines = text.split("\n");
                // offending command text line with an error marker
                for(let i = 0; i < textLines.length; i++){
                    let line = textLines[i];
                    if(line.match(regex)){
                        textLines[i] = line += ` --<<<[MessageNotUnderstood: command; commandName: "${commandName}"]`;
                    }
                }
                text = textLines.join("\n");
                target.partProperties.setPropertyNamed(target, "text", text);

            }
            // finally open the debugger (or current version thereof)
            // NOTE: this is a bit dangerous, b/c if the System doesn't
            // handle the `openDebugger` command anywhere it will throw
            // a MNU error, which will then invoke this handler cuasing
            // an infinite loop!
            this._openDebugger(originalSender.id);
        }
    },

    _cleanDoItSCript(script){
        // clean up the DoIt script by removing the handler
        // newlines, tabs and spaces
        script = script.replace("on doIt", "");
        script = script.replace("end doIt", "");
        script = script.replace(/^[\n\t ]+/, "");
        script = script.replace(/[\n\t ]+$/, "");
        return script;
    },

    _openScriptEditor: function(partId){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openScriptEditor",
            args: [partId]
        };
        target.sendMessage(msg, target);
    },

    _openGrammar: function(partId, ruleName){
        let target = window.System.partsById[partId];
        let statementLines = [
            'if there is not a field "SimpleTalk" of current card',
            'then',
            'add field "SimpleTalk" to current card',
            'tell field "SimpleTalk" of current card to set "editable" to false',
            'SimpleTalk',
            'tell field "SimpleTalk"of current card to set "text" to it',
            'end if'
        ];
        let script = `on doIt\n   ${statementLines.join('\n')}\nend doIt`;
        target.sendMessage(
            {
                type: "compile",
                codeString: script,
                targetId: target.id
            },
            target
        );
        target.sendMessage(
            {
                type: "command",
                commandName: "doIt",
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            },
            target
        );
    },

    // At the moment this simply opens a st-window st-field with
    // information about the available commands for said parts
    _openDebugger: function(partId){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openDebugger",
            args: [partId]
        };
        target.sendMessage(msg, target);
    }
};




/***/ }),

/***/ "./js/objects/utils/handInterface.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/handInterface.js ***!
  \*******************************************/
/*! exports provided: Testables, handInterface, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Testables", function() { return Testables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handInterface", function() { return handInterface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return handInterface; });
const video = document.createElement('video');
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

const scaleDim = (dim) => {
    const scale = 0.7;
    const stride = 16;
    const evenRes = dim * scale - 1;
    return evenRes - (evenRes % stride) + 1;
};

const detectHands = async () => {
    if (!handInterface.handDetectionRunning) {
        return;
    }
    const scaledWidth = scaleDim(canvas.width);
    const scaledHeight = scaleDim(canvas.height);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const image = tf.tidy(() => {
        return tf.fromPixels(canvas).resizeBilinear([scaledHeight, scaledWidth]).expandDims(0);
    });
    const [scores, tboxes] = await handInterface.handDetectionModel.executeAsync(image);
    image.dispose();
    const handsDetected = tf.tidy(() => {
        const indices = tf.image.nonMaxSuppression(
            tboxes.reshape([tboxes.shape[1], tboxes.shape[3]]),
            scores.reshape([scores.shape[1]]),
            20,
            0.5,
            0.85).dataSync();
        var boxes = [];
        var idx;
        for (let i = 0; i < indices.length; i++) {
            idx = indices[i];
            var score = scores.get(0, idx, 0);
            // Original order is [minY, minX, maxY, maxX] so we reorder.
            var box = {
                upperLeft: [tboxes.get(0, idx, 0, 1), tboxes.get(0, idx, 0, 0)],
                lowerRight: [tboxes.get(0, idx, 0, 3), tboxes.get(0, idx, 0, 2)]
            };
            boxes.push({score: score, box: box});
        }
        return {boxes: boxes, timestamp: Date.now()};
    });
    scores.dispose();
    tboxes.dispose();
    if (handsDetected.boxes.length !== 1) {
        if (handInterface.handDetectionRunning) {
            window.requestAnimationFrame(detectHands);
        }
        return;
    }
    const box = handsDetected.boxes[0].box;
    const [x1, y1] = box.upperLeft;
    const [x2, y2] = box.lowerRight;
    const area = {area: (x2 - x1) * (y2 - y1), timestamp: Date.now()};
    handInterface.handDetectionAreas = [].concat(handInterface.handDetectionAreas.slice(-2), [area]);
    // Update hand location
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
    const p = [0.5 * (x1 + x2) * vw, 0.5 * (y1 + y2) * vh];
    handInterface.positions = [].concat(handInterface.positions.slice(-2), [p]);
    var target = handInterface.targetElement;
    if (target === null) {
        target = handInterface.leninHand;
    }
    // Compute average position
    const [p1, p2, p3] = handInterface.positions;
    const [ap1, ap2] = [(1/3)*(p1[0] + p2[0] + p3[0]), (1/3)*(p1[1] + p2[1] + p3[1])];
    target.partProperties.setPropertyNamed(target, "left", ap1);
    target.partProperties.setPropertyNamed(target, "top", ap2);
    // Extract area information without any timestamps
    var justAreas = [];
    for (var i = 0; i < handInterface.handDetectionAreas.length; ++i) {
        justAreas.push(handInterface.handDetectionAreas[i].area);
    }
    var justAreas = [].concat(Array(3 - justAreas.length).fill(0), justAreas);
    // Check if hand is pushing in
    const [a1, a2, a3] = justAreas;
    const aveArea = (1/3) * (a1 + a2 + a3);
    if (aveArea > 0.25) {
        if (!handInterface.handMasked) {
            handInterface.handMasked = true;
            setTimeout(() => { handInterface.handMasked = false; }, 3000);
            if (handInterface.targetElement === null) {
                let closestView = findClosestView([p1, p2]);
                if (closestView !== null) {
                    handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", true);
                    handInterface.targetElement = closestView.model;
                }
            } else {
                handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", false);
                handInterface.targetElement = null;
            }
        }
    }
    if (handInterface.handDetectionRunning) {
        window.requestAnimationFrame(detectHands);
    }
};

const findClosestView = (point) => {
    let views = [];
    window.System.getCurrentCardModel().subparts.forEach((part) => {
        let partViews = window.System.findViewsById(part.id);
        partViews.forEach((view) => {
            views.push(view);
        })
    });
    var [closestDist, closestView] = [Infinity, null];
    views.forEach((view) => {
        let viewDist = dist(point, getVertices(view));
        if (viewDist < closestDist) {
            closestDist = viewDist;
            closestView = view;
        }
    });
    return closestView;
}

// https://aaronsmith.online/easily-load-an-external-script-using-javascript/
const loadScript = src => {
    return new Promise((resolve, reject) => {
        if (typeof window.tf !== 'undefined') {
            console.log("tensorflowjs already loaded");
            resolve();
            return;
        }
        console.log("loading tensorflowjs");
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.onload = resolve;
        script.onerror = reject;
        script.src = src;
        document.head.append(script);
    });
};

const loadHandDetectionModel = () => {
    handInterface.handDetectionAreas = [];
    loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.5/dist/tf.js").then(() => {
        window.tf.loadFrozenModel(
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/tensorflowjs_model.pb",
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/weights_manifest.json"
        ).then(model => {
            console.log("hand detection model loaded");
            handInterface.handDetectionModel = model;
        }).then(() => {
            return navigator.mediaDevices.getUserMedia({ video: true });
        }).then(stream => {
            video.srcObject = stream;
            return video.play();
        }).then(() => {
            console.log("video started");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0); // Mirror incoming video
            handInterface.handDetectionRunning = true;
            handInterface.leninHand = window.System.newModel('image', window.System.getWorldStackModel().id, "/images/leninHand.png");
            handInterface.targetElement = null;
            window.requestAnimationFrame(detectHands);
        }).catch(err => {
            console.log("error loading hand detection model");
            console.log(err);
        });
    });
}

const unloadHandDetectionModel = () => {
    handInterface.handDetectionRunning = false;
    window.System.deleteModel(handInterface.leninHand.id)
    handInterface.leninHand = null;
    video.pause();
    const tracks = video.srcObject.getTracks();
    for (var i = 0; i < tracks.length; i++) {
        tracks[i].stop();
    }
    video.srcObject = null;
    console.log("video stopped");
    handInterface.handDetectionModel = null;
    console.log("unloading hand detection model");
}

const getVertices = (element) => {
    const rect = element.getBoundingClientRect();
    const upperLeft = [rect.x, rect.y];
    const upperRight = [rect.x + rect.width, rect.y];
    const lowerLeft = [rect.x, rect.y + rect.height];
    const lowerRight = [rect.x + rect.width, rect.y + rect.height];
    return {
        upperLeft: upperLeft,
        upperRight: upperRight,
        lowerLeft: lowerLeft,
        lowerRight: lowerRight
    };
}

const dist = (point, vertices) => {
    const [p1, p2] = point;
    const [ul1, ul2] = vertices.upperLeft;
    const [ll1, ll2] = vertices.lowerLeft;
    const [ur1, ur2] = vertices.upperRight;
    const [lr1, lr2] = vertices.lowerRight;
    // First check if the point is inside the rectangle
    // Next we compute the vector pointing from the point to the closest point
    // on the rectangle. There are 9 cases. The first is when the poinst is
    // inside the rectangle. The next four cases are if the point in one of
    // the four corners and the final four cases are when the point is on one
    // of the four sides.
    var [v1, v2] = [null, null];
    if ((ul1 <= p1) && (p1 <= lr1) && (ul2 <= p2) && (p2 <= lr2)) {
        // Case 0: inside the rectangle
        [v1, v2] = [0, 0];
    } else if ((p1 <= ul1) && (p2 <= ul2)) {
        // Case 1: upper left
        [v1, v2] = [ul1 - p1, ul2 - p2];
    } else if ((p1 >= ur1) && (p2 <= ur2)) {
        // Case 2: upper right
        [v1, v2] = [ur1 - p1, ur2 - p2];
    } else if ((p1 <= ll1) && (p2 >= ll2)) {
        // Case 3: lower left
        [v1, v2] = [ll1 - p1, ll2 - p2];
    } else if ((p1 >= lr1) && (p2 >= lr2)) {
        // Case 4: lower right
        [v1, v2] = [lr1 - p1, lr2 - p2];
    } else if (p1 <= ul1) {
        // Case 5: side left
        [v1, v2] = [ul1 - p1, 0];
    } else if (p1 >= lr1) {
        // Case 6: side right
        [v1, v2] = [lr1 - p1, 0];
    } else if (p2 <= ul2) {
        // Case 7: side top
        [v1, v2] = [0, ul2 - p2];
    } else if (p2 >= lr2) {
        // Case 8: side bottom
        [v1, v2] = [0, lr2 - p2];
    } else {
        // Case 9: inside
        [v1, v2] = [0, 0];
    }
    return Math.sqrt(v1*v1 + v2*v2);
}

class HandInterface {
    constructor() {
        this.handDetectionModel = null;
        this.handDetectionRunning = false;
        this.leninHand = null;
        this.handMasked = false;
        this.targetElement = null;
        this.handDetectionAreas = [];
        this.positions = [[0, 0], [0, 0], [0, 0]];
        // XXX - Only here to ignore the tensorflow warnings
        console.warn = () => {};
    }

    start() {
        loadHandDetectionModel();
    }

    stop() {
        unloadHandDetectionModel();
    }
}

const Testables = {
    dist: dist
}

const handInterface = new HandInterface();




/***/ }),

/***/ "./js/objects/utils/icons.js":
/*!***********************************!*\
  !*** ./js/objects/utils/icons.js ***!
  \***********************************/
/*! exports provided: partIcons, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partIcons", function() { return partIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return partIcons; });
let partIcons = {};

partIcons.world = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-world" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <line x1="3.6" y1="9" x2="20.4" y2="9" />
  <line x1="3.6" y1="15" x2="20.4" y2="15" />
  <path d="M11.5 3a17 17 0 0 0 0 18" />
  <path d="M12.5 3a17 17 0 0 1 0 18" />
</svg>
`;

partIcons.stack = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="12 4 4 8 12 12 20 8 12 4" />
  <polyline points="4 12 12 16 20 12" />
  <polyline points="4 16 12 20 20 16" />
</svg>
`;

partIcons.card = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>
`;

partIcons.button = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hand-finger" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M8 13v-8.5a1.5 1.5 0 0 1 3 0v7.5" />
  <path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0v2.5" />
  <path d="M14 10.5a1.5 1.5 0 0 1 3 0v1.5" />
  <path d="M17 11.5a1.5 1.5 0 0 1 3 0v4.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" />
</svg>
`;

partIcons.window = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-window" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3c-3.866 0 -7 3.272 -7 7v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1 -1v-10c0 -3.728 -3.134 -7 -7 -7z" />
  <line x1="5" y1="13" x2="19" y2="13" />
  <line x1="12" y1="3" x2="12" y2="21" />
</svg>
`;

partIcons.area = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-shape" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="5" cy="5" r="2" />
  <circle cx="19" cy="5" r="2" />
  <circle cx="5" cy="19" r="2" />
  <circle cx="19" cy="19" r="2" />
  <line x1="5" y1="7" x2="5" y2="17" />
  <line x1="7" y1="5" x2="17" y2="5" />
  <line x1="7" y1="19" x2="17" y2="19" />
  <line x1="19" y1="7" x2="19" y2="17" />
</svg>
`;

partIcons.field = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-forms" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3a3 3 0 0 0 -3 3v12a3 3 0 0 0 3 3" />
  <path d="M6 3a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3" />
  <path d="M13 7h7a1 1 0 0 1 1 1v8a1 1 0 0 1 -1 1h-7" />
  <path d="M5 7h-1a1 1 0 0 0 -1 1v8a1 1 0 0 0 1 1h1" />
  <path d="M17 12h.01" />
  <path d="M13 12h.01" />
</svg>
`;

partIcons.drawing = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-palette" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 21a9 9 0 1 1 0 -18a9 8 0 0 1 9 8a4.5 4 0 0 1 -4.5 4h-2.5a2 2 0 0 0 -1 3.75a1.3 1.3 0 0 1 -1 2.25" />
  <circle cx="7.5" cy="10.5" r=".5" fill="currentColor" />
  <circle cx="12" cy="7.5" r=".5" fill="currentColor" />
  <circle cx="16.5" cy="10.5" r=".5" fill="currentColor" />
</svg>
`;

partIcons.image = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="15" y1="8" x2="15.01" y2="8" />
  <rect x="4" y="4" width="16" height="16" rx="3" />
  <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5" />
  <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2" />
</svg>
`;

partIcons.generic = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-puzzle" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 7h3a1 1 0 0 0 1 -1v-1a2 2 0 0 1 4 0v1a1 1 0 0 0 1 1h3a1 1 0 0 1 1 1v3a1 1 0 0 0 1 1h1a2 2 0 0 1 0 4h-1a1 1 0 0 0 -1 1v3a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-1a2 2 0 0 0 -4 0v1a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1h1a2 2 0 0 0 0 -4h-1a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1" />
</svg>
`;




/***/ }),

/***/ "./js/objects/utils/id.js":
/*!********************************!*\
  !*** ./js/objects/utils/id.js ***!
  \********************************/
/*! exports provided: idMaker, isValidId, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idMaker", function() { return idMaker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidId", function() { return isValidId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return idMaker; });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_0__);
// ID related utilities



/**
 * ID Maker
 * ------------------------------------
 * I am responsible for creating globally
 * unique ID values for Parts in the SimpleTalk
 * world.
 * HC requires that all Parts have unique ids and
 * that these should not be repeated in any given
 * "application" instance.
 * We need to determine what an "application" is
 * in our context, but regardless we can use this
 * module as a drop in replacement, implementing
 * UUIDs or URLs or whatever we want.
 * For now we just increment an integer.
 */
const idMaker = {
    new: function(){
        let id = Object(uuid__WEBPACK_IMPORTED_MODULE_0__["v4"])();
        return id.replace(/-/g, '');
    }
};

/* ID checker
 * --------------------------------------
 * I am responsible for checking whether an id is
 * is valid and returning it if so
 */
const isValidId = function(id) {
    if(id === null || id === undefined || id === ""){
        return false;
    }
    if(id.length != 32 || id.match('[a-z0-9]*')[0].length != 32) {
        return false;
    }
    return id;
};




/***/ }),

/***/ "./js/objects/utils/merriamInterface.js":
/*!**********************************************!*\
  !*** ./js/objects/utils/merriamInterface.js ***!
  \**********************************************/
/*! exports provided: merriamSimScore, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriamSimScore", function() { return merriamSimScore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriamSimScore; });
const merriamSimScore = async (sender, docId) => {
    const url = "https://patents.merriamtech.com/_api/merriam/"
    const payload = {
        "fields": [
            "title",
            "date_publ"
        ],
        "weights": {
            "merriam":0.7,
            "date":0.3,
            "hierarchy":0.1
        },
        "doc_ids": [
            docId
        ],
        "limit": 5}
    const params = {
        "method": "POST",
        "headers": {
            "content-type": "application/json"
        },
        "body": JSON.stringify(payload)
    }
    fetch(url, params).then(data => {
        return data.json();
    }).then(json => {
        const msg = {
            type: 'command',
            commandName: 'merriamresult',
            args: [
                JSON.stringify(json)
            ]
        };
        sender.sendMessage(msg, sender);
    });
}




/***/ }),

/***/ "./js/objects/utils/serialization.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/serialization.js ***!
  \*******************************************/
/*! exports provided: STSerializer, STDeserializer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STSerializer", function() { return STSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STDeserializer", function() { return STDeserializer; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/**
 * Serialization and Deserialization Utility Classes
 */


const version = "0.0.2";

class STDeserializer {
    constructor(aSystem){
        this.system = aSystem;

        // These caches are used during the process
        // as optimizations
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];

        // The targetId is the id of
        // the Part that we wish to append any
        // deserialized subpart tree into.
        // By default we assume the whole system,
        // ie full deserialization.
        this.targetId = 'system';
        // the root id is the id of the root part instance
        // being attached
        this.rootId = null;

        // Bound methods
        this.deserialize = this.deserialize.bind(this);
        this.deserializeData = this.deserializeData.bind(this);
        this.deserializePart = this.deserializePart.bind(this);
        this.attachSubparts = this.attachSubparts.bind(this);
        this.setProperties = this.setProperties.bind(this);
        this.createView = this.createView.bind(this);
        this.attachView = this.attachView.bind(this);
        this.setViewModel = this.setViewModel.bind(this);
        this.compilePartScript = this.compilePartScript.bind(this);
        this.refreshWorld = this.refreshWorld.bind(this);
        this.appendWorld = this.appendWorld.bind(this);
        this.addPartsToSystem = this.addPartsToSystem.bind(this);
        this.compileScripts = this.compileScripts.bind(this);
        this.getFlattenedPartTree = this.getFlattenedPartTree.bind(this);
        this.getModelClass = this.getModelClass.bind(this);
        this.handleId = this.handleId.bind(this);
        this.throwError = this.throwError.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
        this.dispatchViewAdded = this.dispatchViewAdded.bind(this);
    }

    deserialize(aJSONString){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        return this.deserializeData()
            .then(() => {
                // Add all deserialized Parts to the System dict,
                // including the new World.
                this.addPartsToSystem(this._instanceCache);
            })
            .then(() => {
                // Compile the scripts on *all* deserialized
                // parts
                this.compileScripts(this._instanceCache);
            })
            .then(() => {
                // Insert the root Part into whatever
                // target it should go into.
                let rootPart = this.rootParts[0];
                let rootView = this.rootViews[0];
                if(this.targetId == 'system'){
                    this.refreshWorld();
                } else {
                    target.addPart(rootPart);
                }

                // Finally, append the PartView root node
                // where it should go in the view tree.
                if(this.targetId == 'system'){
                    this.appendWorld();
                } else {
                    let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
                    targetView.appendChild(rootView);
                    this.dispatchViewAdded(rootView);
                }
                return this;
            });
    }

    deserializeData(){
        return new Promise((resolve, reject) => {
            this.flushCaches();
            // First, we ensure that the target we
            // should be deserializing into actually exists
            let target = this.system.partsById[this.targetId];
            if(!target && this.targetId != 'system'){
                this.throwError(`Target id ${this.targetId} does not exist in System`);
            }

            // Second, we create instances of all models in the serialization
            // but we do not yet attach their subparts.
            Object.values(this.data.parts).forEach(partData => {
                this.deserializePart(Object.assign({}, partData));
            });

            // Translate targets
            for (let modelId in this._propsCache) {
                let props = this._propsCache[modelId];
                if (props.target !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        if (props.target === 'part id ' + oldId) {
                            props.target = 'part id ' + newId;
                            break;
                        }
                    }
                }
            }
            // Translate scripts
            for (let modelId in this._scriptCache) {
                let script = this._scriptCache[modelId];
                if (script !== null && script.match('part id') !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        let oldRe = 'part id ' + oldId;
                        let newRe = 'part id ' + newId;
                        if (this._scriptCache[modelId].match(oldRe) !== null) {
                            console.log(modelId);
                            let re = new RegExp(oldRe, "g");
                            this._scriptCache[modelId] = script.replace(re, newRe);
                        }
                    }
                }
            }

            // Third, we go through each created Part instance
            // and add any subparts to it. Note that this is not
            // recursive
            this._instanceCache.forEach(partInstance => {
                this.attachSubparts(partInstance);
            });

            // Forth and fifth. Create and attach views
            // Note this is recursive to preserve the subpart + view children order
            let root = this._instanceCache.filter((part) => {
                return part.partProperties.getPropertyNamed(part, "id") == this.rootId;
            })[0];
            this.createAndAttachViews(root);

            // Sixth, we set all properties on each created
            // Part model from the deserialized data.
            // We do this using a visitor method on the instances
            // themselves.
            // This gives the in-memory views the ability to
            // react to any initial changes to their models.
            this._instanceCache.forEach(partInstance => {
                this.setProperties(partInstance);
                // We need to translate new ids to old ones
                if (partInstance.name == "WorldStack") {
                    let world = partInstance;
                    world.partProperties.setPropertyNamed(
                        world,
                        "current",
                        this._idCache[world.currentStackId]
                    );
                }
                if (partInstance.name == "Stack") {
                    let stack = partInstance;
                    stack.partProperties.setPropertyNamed(
                        stack,
                        "current",
                        this._idCache[stack.currentCardId]
                    );
                }
                this.setViewModel(partInstance);
            });

            // We determine which of the instances is a "root",
            // meaning that it has, at this point, no owner in
            // the deserialized data. There can be multiple roots
            // (and therefore multiple trees) in a single deserialization
            this._rootsCache = this._instanceCache.filter(instance => {
                return instance._owner == null || instance._owner == undefined;
            });

            // Insertion should be handled by composed
            // promises elsewhere (see imports and deserialize()
            // for examples)

            return resolve(this);
        });
    }

    createAndAttachViews(partInstance){
        this.createView(partInstance);
        this.attachView(partInstance);
        if(partInstance.subparts.length){
            partInstance.subparts.forEach((subpartInstance) => {
                this.createAndAttachViews(subpartInstance);
            });
        }
    }

    importFromSerialization(aJSONString, filterFunction){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
        return this.deserializeData()
            .then(() => {
                // The caller will provide a filter function over
                // all deserialized part instances, returning only
                // those that should be inserted into the target.
                // For example, all Stacks in the WorldStack.
                return this._instanceCache.filter(filterFunction);
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.addPartsToSystem(allTreeParts);
                });
                return rootParts;

            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.compileScripts(allTreeParts);
                });
                return rootParts;
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let view = this._viewsCache[rootPart.id];
                    target.addPart(rootPart);
                    targetView.appendChild(view);
                    this.dispatchViewAdded(view);
                });
            });
    }

    deserializePart(partData){
        let partClass = this.getModelClass(partData.type);
        let instance = new partClass();

        // We create a new ID for this part, since we cannot
        // guarantee ID clashes with the existing System.
        // Exception is if the useOriginalids flag is set,
        // such as at load time
        let {newId, oldId} = this.handleId(instance, partData);
        instance.id = newId;
        // cache the new root ID if this is a root instance
        if(this.data.rootId == oldId){
            this.rootId = newId;
        }

        // Add to our caches and also to the System
        this._idCache[oldId] = newId;
        this._scriptCache[newId] = partData.properties.script;
        this._propsCache[newId] = partData.properties;
        this._modelCache[newId] = instance;
        this._subpartMapCache[newId] = partData.subparts;
        this._instanceCache.push(instance);
    }

    handleId(aPart, partData){
        let newId, oldId;
        oldId = partData.id;
        newId = aPart.id;
        if(aPart.type !== 'world'){
            newId = _id_js__WEBPACK_IMPORTED_MODULE_0__["default"].new();
        }
        return {
            newId,
            oldId
        };
    }

    addPartsToSystem(aListOfParts){
        aListOfParts.forEach(part => {
            this.system.partsById[part.id] = part;
        });
    }

    compileScripts(aListOfParts){
        aListOfParts.forEach(part => {
            this.compilePartScript(part);
        });
    }

    attachSubparts(aPart){
        // At this point, the _subpartMapCache should
        // have an entry mapping from this aPart's (new)
        // id to an array of ids of also-initialized
        // subpart models
        let subpartIds = this._subpartMapCache[aPart.id];
        subpartIds.forEach(subpartId => {
            let newId = this._idCache[subpartId];
            let subpartModel = this._modelCache[newId];
            if(!subpartModel){
                debugger;
            }
            aPart.addPart(subpartModel);
        });
    }

    setProperties(aPart){
        let props = this._propsCache[aPart.id];
        delete props['id'];
        aPart.setPropsFromDeserializer(props, this);
    }

    createView(aPart){
        let newView = document.createElement(
            this.system.tagNameForViewNamed(aPart.type)
        );
        // we need to set the part-id attribute since these
        // are used for queries needed for things like
        // current stack and card
        newView.setAttribute("part-id", aPart.id);
        this._viewsCache[aPart.id] = newView;
    }

    setViewModel(aPart){
        let view = this._viewsCache[aPart.id];
        view.setModel(aPart);
    }
    
    attachView(aPart){
        let owner = aPart._owner;
        if(owner){
            let ownerView = this._viewsCache[owner.id];
            let partView = this._viewsCache[aPart.id];
            owner.sendMessage({
                type: "viewChanged",
                changeName: "subpart-new",
                args: [partView]
            }, ownerView);
        }
    }

    compilePartScript(aPart){
        let scriptString = this._scriptCache[aPart.id];
        if(scriptString && scriptString != ""){
            this.system.compile({
                type: 'compile',
                targetId: aPart.id,
                codeString: scriptString,
                serialize: false
            });
        }
    }

    refreshWorld(){
        // We assume a single root part was deserialized and
        // attach it as the World accordingly
        let newWorld = this.rootParts[0];
        if(newWorld.type !== 'world'){
            this.throwError(`Found ${this.rootParts.length} roots, but no world!`);
        }
        this.system.partsById['world'] = this.rootParts[0];
    }

    appendWorld(){
        // We assume a single root view that is an st-world.
        let found = document.querySelector('st-world');
        if(found){
            document.body.replaceChild(this.rootViews[0], found);
        } else {
            document.body.prepend(this.rootViews[0]);
        }
        this.dispatchViewAdded(document.querySelector('st-world'));
    }

    getFlattenedPartTree(aPart, list=[]){
        list.push(aPart);
        aPart.subparts.forEach(subpart => {
            this.getFlattenedPartTree(subpart, list);
        });
        return list;
    }

    throwError(message){
        throw new Error(`Deserialization Error: ${message}`);
    }

    getModelClass(aPartTypeStr){
        let cls = this.system.availableParts[aPartTypeStr];
        if(!cls){
            this.throwError(`Part type "${aPartTypeStr}" does not exist in system`);
        }
        return cls;
    }

    flushCaches(){
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];
    }

    dispatchViewAdded(aView){
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: aView.model.type,
                partId: aView.model.id,
                //ownerId: aView.model._owner.id || null
            } 
        });
        aView.parentElement.dispatchEvent(event);
    }

    get rootParts(){
        return this._rootsCache;
    }

    get rootViews(){
        return this.rootParts.map(part => {
            return this._viewsCache[part.id];
        });
    }
}


class STSerializer {
    constructor(aSystem){
        this.system = aSystem;
        this._objectCache = {};

        // Bound methods
        this.serializePart = this.serializePart.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
    }

    serialize(aRootPart, pretty=true){
        this.flushCaches();
        let result = {
            version: version,
            rootId: aRootPart.id,
            type: aRootPart.type,
            id: aRootPart.id
        };

        // Recursively serialize Parts and
        // store in flat list
        this.serializePart(aRootPart);

        // We set the result objects parts
        // dict to be the same as the cache
        result.parts = this._objectCache;

        // Finally, we convert to a string and
        // return
        if(pretty){
            return JSON.stringify(result, null, 4);
        } else {
            return JSON.stringify(result);
        }
    }

    serializePart(aPart){
        // We use the serialize method available on
        // base Parts, passing in this serializer instance
        // as the sole arg
        this._objectCache[aPart.id] = aPart.serialize(this);
        aPart.subparts.forEach(subpart => {
            this.serializePart(subpart);
        });
    }

    flushCaches(){
        this._objectCache = {};
    }
}




/***/ }),

/***/ "./js/objects/utils/styleProperties.js":
/*!*********************************************!*\
  !*** ./js/objects/utils/styleProperties.js ***!
  \*********************************************/
/*! exports provided: addBasicStyleProps, addPositioningStyleProps, addTextStyleProps, addLayoutStyleProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addBasicStyleProps", function() { return addBasicStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPositioningStyleProps", function() { return addPositioningStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTextStyleProps", function() { return addTextStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLayoutStyleProps", function() { return addLayoutStyleProps; });
/**
 * Helpers for setting up various
 * style properties
 */


/**
 * Basic style properties are those
 * common to all (visual) Parts
 */
const sides = ["top", "bottom", "left", "right"];

const addBasicStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'background-transparency',
        1,
    );
    target.partProperties.newStyleProp(
        'background-color',
        "rgb(255, 255, 255)", // white 
    );
    target.partProperties.newStyleProp(
        'transparency',
        1.0,
    );
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-style`,
            'solid'
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-width`,
            0,
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-color`,
            "rgb(0, 0, 0)", // black
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-transparency`,
            1
        );
    });
    target.partProperties.newStyleProp(
        'shadow-left',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-top',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-blur',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-spread',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-color',
        "rgb(238, 238, 238)", // grey
    );
    target.partProperties.newStyleProp(
        'shadow-transparency',
        1
    );
    target.partProperties.newStyleProp(
        'corner-top-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-top-right-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-right-round',
        0
    );
};

/**
 * Style properties for Parts that can
 * be moved and that can have explicit
 * dimensions. Examples: buttons, fields.
 * Examples of those that can't: Cards, Stacks
 */
const addPositioningStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'hide',
        false,
    );
    // setting width and height to null
    // effectively forces to the default size
    // of the button to fit the button name
    target.partProperties.newStyleProp(
        'width',
        100,
    );
    target.partProperties.newStyleProp(
        'height',
        null,
    );
    target.partProperties.newStyleProp(
        'top',
        0,
    );
    target.partProperties.newStyleProp(
        'left',
        0,
    );
    target.partProperties.newStyleProp(
        'rotate',
        null,
    );

    // horizontal-resizing specifies a strategy
    // for how this Part should adjust its
    // horizontal axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // horizontal axis in the parent Part.
    target.partProperties.newStyleProp(
        'horizontal-resizing',
        'rigid'
    );

    // vertical-resizing specifies a strategy
    // for how this Part should adjust its
    // vertical axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // vertical axis in the parent Part.
    target.partProperties.newStyleProp(
        'vertical-resizing',
        'rigid'
    );

    // Margin specifies some space between the
    // target Part and any other Parts that might
    // be adjacent to it in a common Owner. It will
    // not be in effect when the owner is using a
    // strict layout.
    target.partProperties.newStyleProp(
        'top-margin',
        null
    );
    target.partProperties.newStyleProp(
        'right-margin',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-margin',
        null
    );
    target.partProperties.newStyleProp(
        'left-margin',
        null
    );

    // Pinning specifies whether or not
    // a given part should "stick" to a
    // particular side of its owner Part.
    // Pinning properties only have effect
    // inside of Parts with a strict layout
    target.partProperties.newDynamicProp(
        'pinning-top',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-left',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-bottom',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        'pinning-right',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        // Possible values for the compound
        // 'pinning' property are:
        // *"none" or null
        // *top
        // *top-right
        // *top-left
        // *bottom
        // *bottom-right
        // *bottom-left
        // *left
        // *right
        'pinning',
        // Setter
        function(propOwner, propObject, value){
            if(!value || value == "none"){
                ['top', 'left', 'right', 'bottom'].forEach(side => {
                    let pin = `pinning-${side}`;
                    propOwner.partProperties.setPropertyNamed(
                        propOwner,
                        pin,
                        false
                    );
                });
                return;
            }
            pinningAdjust(propOwner, value);
        },

        // Getter
        function(propOwner, propObject){
            let top = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-top'
            );
            let bottom = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-bottom'
            );
            let left = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-left'
            );
            let right = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-right'
            );
            let result = [];
            if(top){
                result.push('top');
            } else if(bottom){
                result.push('bottom');
            }
            if(left){
                result.push('left');
            } else if(right){
                result.push('right');
            }

            return result.join('-');
        }
    );
};

/**
 * Style properties for Parts that display
 * text
 */
const addTextStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'text-align',
        'left',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-font',
        'default',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-color',
        "rgb(0, 0, 0)", // black
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-transparency',
        1,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-style',
        'plain',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-bold',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-italic',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-size',
        15,
        'cssTextStyle'
    );
};

/**
 * Basic layout styles are those pertaining
 * to the positioning and resizing of subparts.
 * Examples include Cards and Area
 */
const addLayoutStyleProps = (target) => {
    // The 'layout' property is
    // one of two strings:
    // strict - Equivalent to the absolute
    // layout based strictly on coordinates
    // list - Will force items into either a row
    // or column list, based on the pairing with
    // the 'listDirection' property
    target.partProperties.newBasicProp(
        'layout',
        'strict'
    );

    // list-direction specifies row or column
    // and will only have an effect whent the
    // layout property is set to 'list'
    target.partProperties.newBasicProp(
        'list-direction',
        'row'
    );

    // Wrapping specifies whether a list should
    // wrap along its dominant dimension (row or column)
    target.partProperties.newBasicProp(
        'list-wrapping',
        false
    );

    // Padding specifies some space from the
    // border of the target Part to the beginning
    // of the layout of any subparts.
    target.partProperties.newStyleProp(
        'top-padding',
        null
    );
    target.partProperties.newStyleProp(
        'right-padding',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-padding',
        null
    );
    target.partProperties.newStyleProp(
        'left-padding',
        null
    );

    // List alignment describes how elements in
    // a list layout should align themselves along
    // the dominant dimension (row or column)
    // They are essentially proxies for align-items
    target.partProperties.newBasicProp(
        'list-alignment',
        null
    );

    // List distribution describes how elements
    // in a list layout should distribute themselves
    // across or along the dominant dimension
    // (row or column)
    // This is essentially a wrapper for justify-content
    target.partProperties.newBasicProp(
        'list-distribution',
        null
    );
};

/**
  * HELPERS
 **/

const pinningSetter = (propOwner, propObject, value) => {
    let side = propObject.name.split("-")[1];
    let topLeft;
    switch (side){
    case "right":
        topLeft = "left";
        break;
    case "bottom":
        topLeft = "top";
        break;
    default:
        topLeft = side;
    }
    // we'll need to fix and un-fix the corresponding top or left property depending
    // on whether value is true of false, respectively
    let prop = propOwner.partProperties.findPropertyNamed(
        topLeft 
    );
    let oppositeSide;
    switch (side){
    case "left":
        oppositeSide = "right";
        break;
    case "right":
        oppositeSide = "left";
        break;
    case "top":
        oppositeSide = "bottom";
        break;
    case "bottom":
        oppositeSide = "top";
        break;
    }
    if(value){
        // first make sure that pinning-bottom is false
        propOwner.partProperties.setPropertyNamed(
            propOwner,
            `pinning-${oppositeSide}`,
            false
        );
        prop.readOnly = true;
    } else {
        // reset the value back to trigger a notification
        prop.setValue(propOwner, prop._value);
        prop.readOnly = false;
    }
    propObject._value = value;
};

const pinningAdjust = (owner, value) => {
    let sides = ['top', 'left', 'right', 'bottom'];
    sides.forEach(side => {
        if(value.startsWith(side)){
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                true
            );
        } else {
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                false
            );
        }
    });

    if(value.includes("-")){
        if(value.endsWith('left')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                true
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                false
            );
        } else if(value.endsWith('right')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                false
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                true
            );
        }
    }
};




/***/ }),

/***/ "./js/objects/utils/styler.js":
/*!************************************!*\
  !*** ./js/objects/utils/styler.js ***!
  \************************************/
/*! exports provided: cssStyler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssStyler", function() { return cssStyler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cssStyler; });
/**
 * Styler
 * ------------------------------------
 * I am responsible for converting
 * SimpleTalk visual styling to a dict
 * Object of CSS JavaScript type key-value pairs
 */

/** I style the styleObj
 * styleObj: css JavaScript key:value pairs
 * propertyName: (SimpleTalk) styling property name
 * propertyValue: (SimpleTalk) styling property value
 */

const cssStyler = (styleObj, propertyName, propertyValue) => {
    switch(propertyName){

    case "background-color":
        _setOrNot(styleObj, "backgroundColor",  _colorToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "background-transparency":
        // here we set the Alpha value of the current styleObj["backgroundColor"] rgba
        _setOrNot(styleObj, "backgroundColor",  _colorTransparencyToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "border-top-style":
    case "border-bottom-style":
    case "border-left-style":
    case "border-right-style": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-style`,  propertyValue);
        break;
    }

    case "border-top-width":
    case "border-bottom-width":
    case "border-left-width":
    case "border-right-width": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-width`,  _intToPx(propertyValue));
        break;
    }

    case "border-top-color":
    case "border-bottom-color":
    case "border-top-color":
    case "border-right-color": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "border-top-transparency":
    case "border-bottom-transparency":
    case "border-left-transparency":
    case "border-right-transparency": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorTransparencyToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "corner-top-left-round":
    case "corner-top-right-round":
    case "corner-bottom-left-round":
    case "corner-bottom-right-round":{
        let c1 = propertyName.split("-")[1];
        let c2 = propertyName.split("-")[2];
        _setOrNot(styleObj, `border-${c1}-${c2}-radius`,  _intToPx(propertyValue));
        break;
    }

    case "shadow-left":
    case "shadow-top":
    case "shadow-blur":
    case "shadow-spread":
    case "shadow-color":
    case "shadow-transparency":
        let shadowProp = propertyName.split("-")[1];
        let [left, top, blur, spread, color] = _cssBoxShadow(styleObj["box-shadow"]);
        switch(shadowProp){
        case "color":
            color = _colorToRGBA(color, propertyValue);
            break;
        case "transparency":
            color = _colorTransparencyToRGBA(color, propertyValue);
            break;
        case "left":
            left = _intToPx(propertyValue);
            break;
        case "top":
            top = _intToPx(propertyValue);
            break;
        case "blur":
            blur = _intToPx(propertyValue);
            break;
        case "spread":
            spread = _intToPx(propertyValue);
            break;
        }
        _setOrNot(styleObj, "box-shadow", `${left} ${top} ${blur} ${spread} ${color}`);
        break;

    case "text-color":
        _setOrNot(styleObj, "color",  _colorToRGBA(styleObj["color"], propertyValue));
        break;

    case "text-font":
        _setOrNot(styleObj, "fontFamily",  propertyValue);
        break;

    case "text-size":
        _setOrNot(styleObj, "fontSize", propertyValue);
        break;

    case "text-align":
        _setOrNot(styleObj, "textAlign",  propertyValue);
        break;

    case "text-bold":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-weight",  "bold");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-weight",  "normal");
        }
        break;

    case "text-italic":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-style",  "italic");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-style",  "normal");
        }
        break;

    case "text-underline":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "underline");
        }
        break;

    case "text-strikethrough":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "line-through");
        }
        break;

    case "text-transparency":
        // here we set the Alpha value of the current styleObj["color"] rgba
        _setOrNot(styleObj, "color",  _colorTransparencyToRGBA(styleObj["color"], propertyValue));
        break;

    case "top":
        _setOrNot(styleObj, "top",  _intToPx(propertyValue));
        break;

    case "left":
        _setOrNot(styleObj, "left",  _intToPx(propertyValue));
        break;

    case "width":
        _setOrNot(styleObj, "width",  _intToPx(propertyValue));
        break;

    case "height":
        _setOrNot(styleObj, "height",  _intToPx(propertyValue));
        break;

    case "left-margin":
    case "right-margin":
    case "bottom-margin":
    case "top-margin":
        let marginSide = propertyName.split("-")[0];
        marginSide = `${marginSide[0].toUpperCase()}${marginSide.slice(1)}`;
        _setOrNot(styleObj, `margin${marginSide}`, _intToPx(propertyValue));
        break;

    case "left-padding":
    case "right-padding":
    case "bottom-padding":
    case "top-padding":
        let paddingSide = propertyName.split("-")[0];
        paddingSide = `${paddingSide[0].toUpperCase()}${paddingSide.slice(1)}`;
        _setOrNot(styleObj, `padding${paddingSide}`, _intToPx(propertyValue));
        break;

    case "text-style":
        _setOrNot(styleObj, "textStyle",  propertyValue);
        break;

    case "rotate":
        _setOrNot(styleObj, "transform",  _intToRotateDeg(propertyValue));
        break;

    case "transparency":
        _setOrNot(styleObj, "opacity",  propertyValue);
        break;

    case "hide":
        if(propertyValue === true){
            styleObj["display"] = "none";
        } else if(propertyValue === false){
            styleObj["display"] = null;
        }
        break;


    default:
        // for the default we simply allow ST style names to map 1-1
        // to CSS/JS style names. This is only somewhat safe, since the DOM
        // will simply ignore nonsense names without throwing an error. But it
        // does allow us to avoid writing a rule for every term (example: width,
        // height, top, left etc)
        _setOrNot(styleObj, propertyName,  propertyValue);
    }
    return styleObj;

};

// In order to avoid clashing with views interacting
// the style attribute directly we ignore everything that
// is either null or undefined
// TODO review this decision!
const _setOrNot = (styleObj, name, value) => {
    if(value !== null && value !== undefined){
        styleObj[name] = value;
    }
};

const _intToRotateDeg = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            n = n.split("deg")[0];
        }
        return `rotate(${n}deg)`;
    }
};


const _intToPx = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            if(n == "fill"){
                return "100%";
            } else if(["thin", "medium", "thick"].indexOf(n) > -1){
                return n;
            }
            n = n.split("px")[0];
        }
        return `${n}px`;
    }
};

// Convert colors to rgba
// change a css color RGB values, preserving the A(lpha) value
const _colorToRGBA = (cssColor, STColor) => {
    if(!STColor){
        return;
    }
    let r, g, b, a, _;
    // ST colors are RGB
    if(STColor.startsWith("rgb")){
        [r, g, b] = STColor.match(/\d+/g);
    } else {
        let colorInfo = basicCSSColors[STColor];
        if(colorInfo){
            r = colorInfo["r"];
            g = colorInfo["g"];
            b = colorInfo["b"];
        } else {
            return;
        }
    }
    if(cssColor){
        [_, _, _, a] = cssColor.match(/[\d\.]+/g);
        // if Alpha is not defined then we set it to 1
        // default for browsers
    }
    if(!a){
        a = 1;
    }
    return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// change the A(alpha) value, preserving the RGB values
const _colorTransparencyToRGBA = (cssColor, tValue) => {
    if(!cssColor){
        return;
    }

    let r, g, b;
    let mappedColor = basicCSSColors[cssColor];
    if(mappedColor){
        r = mappedColor.r;
        g = mappedColor.g;
        b = mappedColor.b;
    } else {
        [r, g, b] = cssColor.match(/\d+/g);
    }
    
    return `rgba(${r}, ${g}, ${b}, ${tValue})`;
}

// Add more colors as needed
const basicCSSColors = {
    black: {hex: "#000000", r: 0, g: 0, b: 0},
		silver: {hex: "#C0C0C0", r: 192, g: 192, b: 192},
		gray: {hex: "#808080", r: 128, g: 128, b: 128},
		white: {hex: "#FFFFFF", r: 255, g: 255, b: 255},
		maroon: {hex: "#800000", r: 128, g: 0, b: 0},
		red: {hex: "#FF0000", r: 255, g: 0, b: 0},
		purple: {hex: "#800080", r: 128, g: 0, b: 128},
		fuchsia: {hex: "#FF00FF", r: 255, g: 0, b: 255},
		green: {hex: "#008000", r: 0, g: 128, b: 0},
		lime: {hex: "#00FF00", r: 0, g: 255, b: 0},
		olive: {hex: "#808000", r: 128, g: 128, b: 0},
		yellow: {hex: "#FFFF00", r: 255, g: 255, b: 0},
		navy: {hex: "#000080", r: 0, g: 0, b: 128},
		blue: {hex: "#0000FF", r: 0, g: 0, b: 255},
		teal: {hex: "#008080", r: 0, g: 128, b: 128},
		aqua: {hex: "#00FFFF", r: 0, g: 255, b: 255},
};

// take the css box-shadow property and return its
// components (offset-y, offset-x, blur, spread and color)
// if the value is not defined return a default
const _cssBoxShadow = (cssPropValue) =>{
    if(!cssPropValue){
        return ["0px", "0px", "0px", "0px", "rgba(0, 0, 0, 1)"];
    }
    let [intValues, rgba] = cssPropValue.split(" rgba");
    let [left, top, blur, spread] = intValues.split(" ");
    return [left, top, blur, spread, `rgba${rgba}`];
}




/***/ }),

/***/ "./js/objects/views/AreaView.js":
/*!**************************************!*\
  !*** ./js/objects/views/AreaView.js ***!
  \**************************************/
/*! exports provided: AreaView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaView", function() { return AreaView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AreaView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * AreaView
 * -------------------------------
 * I am a webcomponent representation
 * of an Area, which is a grouping of
 * Parts that have some kind of layout
 * specified
 */


const templateString = `
                <style>
                #area-wrapper {
                    display: inherit;
                    flex-direction: inherit;
                    flex-wrap: inherit;
                    align-items: inherit;
                    align-content: inherit;
                    justify-content: inherit;
                    position: relative; 
                    width: 100%;
                    height: 100%;
                    border-radius: inherit;
                }
                .clip {
                    overflow: hidden;  
                }
                .allow-scroll {
                    overflow: auto;
                }
                </style>
                <div id="area-wrapper">
                <slot></slot>
                </div>
`;

class AreaView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.clippingChanged = this.clippingChanged.bind(this);
        this.allowScrollingChanged = this.allowScrollingChanged.bind(this);

        // Prop change handlers
        this.onPropChange('clipping', this.clippingChanged);
        this.onPropChange('allow-scrolling', this.allowScrollingChanged);
    }

    afterModelSet(){
        let clipping = this.model.partProperties.getPropertyNamed(
            this.model,
            "clipping"
        );
        let allowScrolling = this.model.partProperties.getPropertyNamed(
            this.model,
            "allow-scrolling"
        );
        this.clippingChanged(clipping, this.model.id);
        if(clipping && allowScrolling){
            this.allowScrollingChanged(allowScrolling, this.model.id);
        }
    }

    clippingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('allow-scroll');
            wrapper.classList.add('clip');
        } else {
            wrapper.classList.remove('clip');
        }
    }

    allowScrollingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('clip');
            wrapper.classList.add('allow-scroll');
        } else {
            wrapper.classList.remove('allow-scroll');
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        let layout = this.model.partProperties.getPropertyNamed(
            this.model,
            'layout'
        );
        let direction = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-direction'
        );
        if(layout != 'list'){
            contextMenu.addListItem(
                "Set Layout to List",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'list'
                    );
                }
            );
        } else {
            contextMenu.addListItem(
                "Set Layout to Strict",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'strict'
                    );
                }
            );
            if(direction == 'row'){
                contextMenu.addListItem(
                    "Set List Direction to Column",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'column'
                        );
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Set List Direction to Column",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'row'
                        );
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/AudioView.js":
/*!***************************************!*\
  !*** ./js/objects/views/AudioView.js ***!
  \***************************************/
/*! exports provided: AudioView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioView", function() { return AudioView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AudioView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <audio></audio>
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-music" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="6" cy="17" r="3"></circle>
    <circle cx="16" cy="17" r="3"></circle>
    <polyline points="9 17 9 4 19 4 19 17"></polyline>
    <line x1="9" y1="8" x2="19" y2="8"></line>
    </svg>
</div>
`;

// HTMLMediaElementStates copied from
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
const mediaStates = {
    0: "HAVE_NOTHING",
    1: "HAVE_METADATA",
    2: "HAVE_CURRENT_DATA",
    3: "HAVE_FUTURE_DATA",
    4: "HAVE_ENOUGH_DATA"
};

class AudioView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateAudioLink = this.updateAudioLink.bind(this);
        this.play = this.play.bind(this);
        this.pause = this.pause.bind(this);
    }

    afterConnected(){
        let audio = this._shadowRoot.querySelector("audio");
        audio.addEventListener('loadeddata', () => {
            let stateCode = audio.readyState;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "readyState",
                mediaStates[stateCode]
            );
        });

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        this.model.partProperties.setPropertyNamed(
            this.model,
            "readyState",
           "HAVE_NOTHING"
        );
        let audio = this._shadowRoot.querySelector("audio");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            audio.src = src;
        }
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", (value) => {
            let borderColor = "red";
            if(value == "HAVE_FUTURE_DATA" || value == "HAVE_ENOUGH_DATA"){
                borderColor = "green";
            };
            ["right", "left", "top", "bottom"].forEach((side) => {
                this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
            });
        });
        this.onPropChange("play", (value) => {
            if(value === true){
                this.play();
            } else if (value === false){
                this.pause();
            }
        });
        this.onPropChange("stop", (value) => {
            if(value === true){
                audio.currentTime = 0;
            }
        });
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <audio> element
                audio.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "audio",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    play(){
        // first make sure that the resource is ready
        let audio = this._shadowRoot.querySelector("audio");
        let readyState = this.model.partProperties.getPropertyNamed(this.model, "readyState");
        if(readyState == "HAVE_FUTURE_DATA" || readyState == "HAVE_ENOUGH_DATA"){
            audio.play();
        } else {
            alert(`audio is not ready; current state: ${readyState}`);
        }
    }

    pause(){
        this._shadowRoot.querySelector("audio").pause();
    }

    // re-loads the media, setting it back to the beggning
    stop(){
        this._shadowRoot.querySelector("audio").load();
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-audio-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for audio source');
        this.haloButton.addEventListener('click', this.updateAudioLink);
    }

    updateAudioLink(event){
        // Tells the model to update its
        // src link for the audio
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for audio:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadAudioFromSource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/BrowserView.js":
/*!*****************************************!*\
  !*** ./js/objects/views/BrowserView.js ***!
  \*****************************************/
/*! exports provided: BrowserView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserView", function() { return BrowserView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BrowserView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}
iframe {
    width: 100%;
    height: 100%;
}
</style>
<iframe frameborder="0" allowfullscreen></iframe>
`;

class BrowserView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateBrowserLink = this.updateBrowserLink.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let iframe = this._shadowRoot.querySelector("iframe");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            iframe.src = src;
        }
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <browser> element
                iframe.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "browser",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-browser-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for browser source');
        this.haloButton.addEventListener('click', this.updateBrowserLink);
    }

    updateBrowserLink(event){
        // Tells the model to update its
        // src link for the browser
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for browser:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'setURLTo',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/ButtonView.js":
/*!****************************************!*\
  !*** ./js/objects/views/ButtonView.js ***!
  \****************************************/
/*! exports provided: ButtonView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonView", function() { return ButtonView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ButtonView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * ButtonView
 * ---------------------------------------------------
 * I am a webcomponent representing a Button.
 */


const templateString = `
                <style>
                 .st-button-label {
                     user-select: none;
                     pointer-events: none;
                     text-overflow: ellipsis;
                     overflow: hidden;
                     max-width: 95%;
                     white-space: nowrap;
                 }
                </style>
                <span class="st-button-label">
                    <slot></slot><!-- Text of the Name -->
                </span>
`;

class ButtonView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bound methods
        this.setupPropHandlers = this.setupPropHandlers.bind(this);

        // Setup prop change handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('name', (value, partId) => {
            this.innerText = value;
        });
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let buttonName = this.model.partProperties.getPropertyNamed(this, "name");
        if(buttonName){
            this.innerText = buttonName;
        };
    }

    // override the base class implementation
    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }
};




/***/ }),

/***/ "./js/objects/views/CardView.js":
/*!**************************************!*\
  !*** ./js/objects/views/CardView.js ***!
  \**************************************/
/*! exports provided: CardView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardView", function() { return CardView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * CardView
 * --------------------------------------------------
 * I am a webcomponent representation of a Card.
 */



const templateString = `
                <style>
                </style>
                <slot></slot>
`;

class CardView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Bind component methods
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    // override the default class method
    onClick(event){
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            event.stopPropagation();
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        // Toolbox toggle hide/unhide
        let currentStack = window.System.getCurrentStackModel();
        let toolbox = currentStack.subparts.filter((part) => {
            let name = part.partProperties.getPropertyNamed(part, "name");
            return name == "Toolbox";
        })[0];
        // if there is no toolbox at all, that's weird but don't do anything
        if(toolbox){
            let hidden = toolbox.partProperties.getPropertyNamed(toolbox, "hide");
            if(hidden){
                contextMenu.addListItem(
                    "Unhide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", false);
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Hide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", true);
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/FieldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/FieldView.js ***!
  \***************************************/
/*! exports provided: FieldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldView", function() { return FieldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FieldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");
/* harmony import */ var _drawing_ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing/ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * FieldView
 * ---------------------------------
 * I am the view of an Field part.
 * I am an "interim" view intended to display
 * and edit plain text on a Card.
 * I should be replaced with a more comprehensive
 * implementation of Field/FieldView in the future.
 */






const haloEditButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tools" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M3 21h4l13 -13a1.5 1.5 0 0 0 -4 -4l-13 13v4" />
  <line x1="14.5" y1="5.5" x2="18.5" y2="9.5" />
  <polyline points="12 8 7 3 3 7 8 12" />
  <line x1="7" y1="8" x2="5.5" y2="9.5" />
  <polyline points="16 12 21 17 17 21 12 16" />
  <line x1="16" y1="17" x2="14.5" y2="18.5" />
</svg>
`;

const haloLockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-4a4 4 0 0 1 8 0v4"></path>
</svg>
`;

const haloUnlockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock-open" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-5a4 4 0 0 1 8 0"></path>
</svg>
`;

const fieldTemplateString = `
      <style>
        .field {
            display: flex;
            align-items: center;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: auto;
        }

        .field color-wheel {
            position: absolute;
        }

        .field-textarea {
            width: calc(100% - 5px);
            height: 100%;
            width: 100%;
            white-space: pre-wrap;
            overflow-wrap: anywhere;
        }

        /* Syntax Highlighting
 *---------------------------------------------------*/
span[data-st-rule="messageName"]{
    text-decoration: underline;
}

span[data-st-rule="keyword"]{
    font-weight: bold;
}

span[data-st-rule="ParameterList-item"]{
    font-style: italic;
    color: grey;
}


    </style>
    <div class="field">
        <div class="field-textarea" spellcheck="false"></div>
    </div>`;


function formatDoc(sCmd, sValue) {
  document.execCommand(sCmd, false, sValue); oDoc.focus();
}

class FieldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // this.editorCompleter = this.simpleTalkCompleter;
        this.textStyler = _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__["default"];  // we might want to consider a more programmatic way to set this
        this.editorCompleter = null;
        this.contextMenuOpen = false;
        this.haloLockUnlockButton = null;
        this.selectionRanges = {};
        this.wantsContextMenu = false;

        // Presets for syntax highlighting.
        // When highlighting is enabled, we will check
        // each line of the text for the following
        // grammatical rules:
        this._syntaxRules = [
            "MessageHandlerOpen",
            "MessageHandlerClose"
        ];

        this.template = document.createElement('template');
        this.template.innerHTML = fieldTemplateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onInput = this.onInput.bind(this);
        this.onBeforeInput = this.onBeforeInput.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onKeydown = this.onKeydown.bind(this);
        this.onMousedown = this.onMousedown.bind(this);
        this.openContextMenu = this.openContextMenu.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);
        this.doIt = this.doIt.bind(this);
        this.handleSelection = this.handleSelection.bind(this);
        this.openField = this.openField.bind(this);
        this.textToHtml = this.textToHtml.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.simpleTalkCompleter = this.simpleTalkCompleter.bind(this);
        this.initCustomHaloButtons = this.initCustomHaloButtons.bind(this);
        this.insertRange = this.insertRange.bind(this);
        this.setRangeInTarget = this.setRangeInTarget.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.highlightSyntax = this.highlightSyntax.bind(this);
        this.unhighlightSyntax = this.unhighlightSyntax.bind(this);

        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('editable', (value, id) => {
            this.textarea.setAttribute('contenteditable', value);
            if(value === true){
                this.haloLockUnlockButton = this.haloLockButton;
                this.classList.add("editable");
            } else if (value === false){
                this.haloLockUnlockButton = this.haloUnlockButton;
                this.classList.remove("editable");
            }
        });
        // 'text' is a DynamicProp whose setter will set the corresponding
        // value for `innerHTML`. This way we can have programmatic content
        // setting and still allow to not loose markup.
        // 'innerHTML' is a BasicProp. See how these are set, without
        // notification in this.onInput()
        this.onPropChange('innerHTML', (value, id) => {
            this.textarea.innerHTML = value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "text",
                this.textarea.innerText,
                false // do not notify, to avoid an infinite loop
            );
        });
    }

    afterConnected(){
        // The events here are added via the .addEventListener() API which is
        // distinct from the this.eventRespond() which uses the DOM element
        // element.onEvent API. This allows us to distnguish between "core"
        // system-web events that we don't want meddled with at the moment, like
        // entering text in a field, and ones exposed in the environemnt for scripting
        this.textarea = this._shadowRoot.querySelector('.field-textarea');

        this.textarea.addEventListener('input', this.onInput);
        //this.textarea.addEventListener('beforeinput', this.onBeforeInput);
        this.textarea.addEventListener('keydown', this.onKeydown);
        this.textarea.addEventListener('mousedown', this.onMousedown);
        // No need to add a click listener as the base PartView class does that

        // in order to deal with range insertions (for styling text fragments within
        // the textarea), we need to have the default paragraph tag = </br>. Otherwise
        // the insert new line is of the form <div></br><div> which causes the appearance
        // of newlines when nodes are inserted into a range
        //document.execCommand("defaultParagraphSeparator", false, "st-line");
    }

    afterDisconnected(){
        this.textarea.removeEventListener('input', this.onInput);
        //this.textarea.removeEventListener('beforeinput', this.onBeforeInput);
        this.textarea.removeEventListener('keydown', this.onKeydown);
        this.textarea.removeEventListener('mousedown', this.onMousedown);
    }

    afterModelSet(){
        this.textarea = this._shadowRoot.querySelector('.field-textarea');
        // If we have a model, set the value of the textarea
        // to the current html of the field model
        let innerHTML = this.model.partProperties.getPropertyNamed(
            this.model,
            'innerHTML'
        );
        this.textarea.innerHTML = innerHTML;

        let isEditable = this.model.partProperties.getPropertyNamed(this.model, "editable");
        this.textarea.setAttribute('contenteditable', isEditable);

        // setup the lock/unlock halo button
        this.initCustomHaloButtons();
        let editable = this.model.partProperties.getPropertyNamed(
            this.model,
            'editable'
        );
        if(editable === true){
            this.haloLockUnlockButton = this.haloLockButton;
            this.classList.add("editable");
        } else if (editable === false){
            this.haloLockUnlockButton = this.haloUnlockButton;
            this.classList.remove("editable");
        }
    }

    simpleTalkCompleter(element){
        let textContent = this.htmlToText(element);
        let startOfHandlerRegex = /^on\s(\w+)(\s|\n)+$/;
        let match = textContent.match(startOfHandlerRegex);
        if(match){
            let messageName = match[1];
            // if input break is a new line then an extra
            // <div></br></div> has beed added into the elemen already
            let tabLine = "\t\n";
            if(match[2] === "\n"){
                tabLine= "";
            }
            textContent = `${tabLine}end ${messageName}`;
            let innerHTML = this.textToHtml(textContent);
            element.insertAdjacentHTML("beforeend", innerHTML);
        }
        return element.innerHTML;
    }

    /*
     * I override my base-class's implementation to handle target related functionality
     */
    styleTextCSS(){
        let textarea = this._shadowRoot.querySelector('.field-textarea');
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            textarea.style[key] = value;
        });
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, this.textarea.innerHTML, cssStyle);
        }
    }

    /*
     * set a text-* property on selection to style the selected text
     * Note: this is done for every current selection, i.e. everthing
     * in this.selectionRanges
     */
    setSelection(propName, value){
        Object.values(this.selectionRanges).forEach((range) => {
            let currentStyle = {};
            // // if the document fragment has one child node and it's a span
            // // we should style that directly. This avoids unncessary DOM elements
            // // being created to wrap the contents, such as when styling is continually
            // // applied ot the same selection
            // let span;
            // if(docFragment.childNodes.length == 1 && docFragment.childNodes[0].nodeName == "SPAN"){
            //     span = docFragment.childNodes[0];
            //     // Note the use of Obejct.values here for the DOM style attribute object
            //     // that's weird
            //     Object.values(span.style).forEach((key) => {
            //         currentStyle[key] = span.style[key];
            //     });
            // } else {
            //     // we need to create a span element to wrap the contents in style
            //     span = document.createElement('span');
            //     // While tempting to use range.surroundContents() avoid this
            //     // since it will fail with a non-informative error if the range
            //     // includes partial nodes (ex text across various nodes)
            //     while (docFragment.childNodes.length){
            //         span.appendChild(docFragment.childNodes[0]);
            //     }
            // }
            let span = document.createElement('span');
            let cssObject = this.textStyler(currentStyle, propName, value);
            Object.keys(cssObject).forEach((key) => {
                span.style[key] = cssObject[key];
            });

            span.append(range.extractContents());
            range.insertNode(span);
            
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
            // if there is a target and range set then send the target an update message
            let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
            if(target){
                this.setRangeInTarget(target, this.textarea.innerHTML);
            }
        });
    }

    onBeforeInput(event){
        let selection = document.getSelection();
        let selectedRange = selection.getRangeAt(0);
        let range = selectedRange.cloneRange();

        let innerHTML = event.target.innerHTML;
        if(!innerHTML.endsWith("<div><br></div>")){
            innerHTML += "<div><br></div>";
            event.target.innerHTML = innerHTML;
        }
        
        if(event.inputType == "insertParagraph"){
            //event.stopPropagation();
            event.preventDefault();

            let br = document.createElement('br');
            let br2 = document.createElement('br');
            range.insertNode(br);
            range.collapse(false);
            range.insertNode(br2);
            range.setStartAfter(br2);
            range.setEndAfter(br2);
        }
    }

    onInput(event){
        let innerHTML = event.target.innerHTML;
        /*
        if(!innerHTML.endsWith("<br>")){
            innerHTML += "<br>";
            event.target.innerHTML = innerHTML;
        }
        */

        if(this.editorCompleter){
            // TODO sort out how this would work
            let innerHTML = event.target.innerHTML;
            innerHTML = this.editorCompleter(event.target);
        }

        this.model.partProperties.setPropertyNamed(
            this.model,
            'text',
            event.target.innerText,
            false // do not notify, to preserve contenteditable context
        );
        this.model.partProperties.setPropertyNamed(
            this.model,
            'innerHTML',
            event.target.innerHTML,
            false // do not notify
        );
        // Since we update the 'text' property without notification, the part/model
        // is not sent the "propertyChanged" message so we do so manually
        this.model.propertyChanged("text", event.target.innerText);
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, event.target.innerHTML);
        }
    }

    onKeydown(event){
        // prevent the default tab key to leave focus on the field
        if(event.key==="Tab"){
            event.preventDefault();
            //document.execCommand('insertHTML', false, '&#x9');
            let sel = document.getSelection();
            let range = sel.getRangeAt(0);

            let tabNodeValue = '\t';
            let tabNode = document.createTextNode(tabNodeValue);

            range.insertNode(tabNode);

            range.setStartAfter(tabNode);
            range.setEndAfter(tabNode);
        };
    }

    onMousedown(event){
        // clear all selections
        this.selectionRanges = {};
    }
    onClick(event){
        event.preventDefault();
        event.stopPropagation();
        if(event.button == 0){
            // if the shift key is pressed we toggle the halo
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else{
                let text = window.getSelection().toString();
                // if no text is selected we do nothing
                if(text){
                    // if the altKey is pressed we open the context ("do it") menu
                    if(event.altKey){
                        if(!this.contextMenuOpen){
                            this.openContextMenu();
                        }
                    } else {
                        this.handleSelection(event.metaKey);
                    }
                } else {
                    // make sure no context menu is open
                    if(this.contextMenuOpen){
                        this.closeContextMenu();
                    }
                    // clear all the selections
                    this.selectionRanges = {};
                }
            }
        }
    }

    /* I handle selected text, creating a new field model/view
     * for every range in the selection, keeping track of every range
     * in this.selection Object/dict so that modification can be inserted
     * back into the corresponding ranges.
     */
    handleSelection(openNewField){
        let selection = window.getSelection();
        for(let i=0; i < selection.rangeCount; i++){
            // make sure this is not a continuing selection
            // and that the range is not already registered
            let range = selection.getRangeAt(i);
            let currentRanges = Object.values(this.selectionRanges);
            if(currentRanges.indexOf(range) >= 0){
                continue;
            }
            // we generate our own range ids, since we want this to correspond to
            // selection order which is not respected by the browser selection object
            // to ensure we don't hit on other views' ranges by accident we need unique id's
            let rangeId = Date.now(); //TODO we need a better random id
            this.selectionRanges[rangeId] = range;
            if(openNewField){
                // open a field for each new selection and populate it with the range html
                this.openField(range, rangeId);
            }
        }
    }

    openField(range, rangeId){
        // create an HTML document fragment from the range to avoid dealing wiht start/end
        // and offset calculations
        // fragments don't have the full html DOM element API so we need to create one
        let span = document.createElement('span');
        span.appendChild(range.cloneContents());

        // TODO these should all be messages and correspnding command handler definitions
        // should be part of the field's own script
        let fieldModel = window.System.newModel("field", this.model._owner.id, `selection ${rangeId}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "innerHTML", span.innerHTML);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "target", `field id ${this.model.id}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "targetRangeId", rangeId);
    }

    /**
      * Given a tagrget specifier and html
      * I first look up to make sure that the target has the corresponding
      * range (coming from the targetRangeId property), and then set it with my
      * innerHTML. Note, since the target property value is an object specifier I
      * create a semantics objects and interpret the value resulting in a valid
      * part id.
      */
    setRangeInTarget(targetSpecifier, html, css){
        let targetRangeId = this.model.partProperties.getPropertyNamed(this.model, 'targetRangeId');
        let match = window.System.grammar.match(targetSpecifier, "ObjectSpecifier");
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation('interpret', Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this.model, window.System));
        let targetId = semantics(match).interpret();

        this.model.sendMessage({
            type: "command",
            commandName: "insertRange",
            args: [targetRangeId, html, css]
        }, window.System.partsById[targetId]);
    }

    /*
     * I insert the html (string) into the specified range (by id)
     */
    insertRange(rangeId, html, cssObj){
        let range = this.selectionRanges[rangeId];
        if(range){
            let span = document.createElement('span');
            span.innerHTML = html;
            if(cssObj){
                Object.keys(cssObj).forEach((key) => {
                    let value = cssObj[key];
                    span.style[key] = value;
                });
            }
            range.deleteContents();
            range.insertNode(span);
            // update the text and innerHTML properties without notification
            // to prevent unnecessary setting of the text/html
            this.model.partProperties.setPropertyNamed(
                this.model,
                'text',
                this.textarea.innerText,
                false // do not notify, to preserve contenteditable context
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
        }
    }

    openContextMenu(){
        let text = document.getSelection().toString();
        let focusNode = document.getSelection().focusNode;
        let button = document.createElement("button");
        button.id = "doIt";
        button.style.marginLeft = "10px";
        button.style.backgroundColor = "var(--palette-green)";
        button.textContent = "Do it!";
        button.addEventListener("click", this.doIt);
        focusNode.after(button);
        this.contextMenuOpen = true;
    };

    closeContextMenu(){
        let button = this._shadowRoot.querySelector('#doIt');
        if(button){
            button.remove();
        }
        // clear the selection and set the context menu to closed
        document.getSelection().removeAllRanges();
        this.contextMenuOpen = false;
    }

    doIt(event){
        event.stopPropagation();
        let text = document.getSelection().toString();
        // clean up the text to make sure no newlines or spaces made it in
        text = text.replace(/^[\t\n ]+/, "");
        text = text.replace(/[\t\n ]+$/, "");
        this.closeContextMenu();
        // send message to compile the prepped script
        let script = `on doIt\n   ${text}\nend doIt`;
        // send these messages from the model (not the view)
        // since if there is an error the original sender will
        // have an id
        this.model.sendMessage(
            {
                type: "compile",
                codeString: script,
                targetId: this.model.id
            },
            this.model
        );
        this.model.sendMessage(
            {
                type: "command",
                commandName: "doIt",
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            },
            this.model
        );
    }

    initCustomHaloButtons(){
        this.haloLockButton = document.createElement('div');
        this.haloLockButton.id = "halo-field-lock-editor";
        this.haloLockButton.classList.add('halo-button');
        this.haloLockButton.innerHTML = haloLockButtonSVG;
        this.haloLockButton.style.marginRight = "6px";
        this.haloLockButton.setAttribute('slot', 'bottom-row');
        this.haloLockButton.setAttribute('title', 'Lock Editing');
        this.haloLockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", false],
            }, this.model);
            this.closeHalo();
            this.openHalo();
            // close/open the halo to update the editing state toggle button
        });
        this.haloUnlockButton = document.createElement('div');
        this.haloUnlockButton.id = "halo-field-unlock-editor";
        this.haloUnlockButton.classList.add('halo-button');
        this.haloUnlockButton.innerHTML = haloUnlockButtonSVG;
        this.haloUnlockButton.style.marginRight = "6px";
        this.haloUnlockButton.setAttribute('slot', 'bottom-row');
        this.haloUnlockButton.setAttribute('title', 'Unlock Editing');
        this.haloUnlockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", true],
            }, this.model);
            // close/open the halo to update the editing state toogle button
            this.closeHalo();
            this.openHalo();
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloLockUnlockButton);
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }


    /*
     * I convert raw text to html respecting the Firefox
     * contenteditable attribute guidelnes.
     * This means that single lins of text are left as is;
     * multiline text, i.e. text which includes "\n", is
     * wrapped in <div></div> for every line; and the last
     * line gets a <br> tag inserted before the </div> to reflect
     * the "on-enter-key" behavior.
     */
    textToHtml(text){
        if(text){
            let textLines = text.split("\n");
            if(textLines.length > 1){
                let html = "";
                textLines.forEach((line) => {
                    if(line){
                        html += `<div>${line}</div>`;
                    } else {
                        html += "<div><br></div>";
                    }
                });
                return  `<div>${html}<br></div>`;
            } else {
                return text;
            }
        } else {
            return "";
        }
    }

    htmlToText(element){
        // TODO this is very naive and ignores most possible structure
        if(element.innerHTML){
            // first replace all the "</div><div>" with line breaks
            let cleanHTML =  element.innerHTML.replace(/<\/div><div>/g, "\n");
            // then remove all html
            let tempElement = document.createElement("div");
            tempElement.innerHTML = cleanHTML;
            let cleanText = tempElement.textContent;
            tempElement.remove();
            return cleanText;
        } else {
            return "";
        }
    }

    highlightSyntax(){
        let current = this.getAttribute("syntax");
        if(current && current !== "false"){
            this.unhighlightSyntax();
        }
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation(
            "highlightSyntax",
            Object(_utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
        );
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let newHTML = text.split("\n").map(line => {
            // Loop through each rule and try to match
            for(let i = 0; i < this._syntaxRules.length; i++){
                let rule = this._syntaxRules[i];
                let match = window.System.grammar.match(line, rule);
                if(match.succeeded()){
                    return semantics(match).highlightSyntax().outerHTML;
                }
            }
            return line;
        }).join("\n");

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", true);
    }

    unhighlightSyntax(){
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let plainElements = text.split("\n").map(line => {
            let div = document.createElement("div");
            div.innerText = line;
            return div;
        });
        let finalLine = document.createElement("div");
        finalLine.append(document.createElement("br"));
        plainElements.push(finalLine);

        let newHTML = "";
        plainElements.forEach(element => {
            newHTML += element.outerHTML;
        });

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", false);
    }
};




/***/ }),

/***/ "./js/objects/views/Halo.js":
/*!**********************************!*\
  !*** ./js/objects/views/Halo.js ***!
  \**********************************/
/*! exports provided: Halo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Halo", function() { return Halo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Halo; });
/**
 * New Halo
 */

/** Note: Icons are from 
*** https://tablericons.com/
**/
const deleteIcon =`
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-trash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="4" y1="7" x2="20" y2="7" />
  <line x1="10" y1="11" x2="10" y2="17" />
  <line x1="14" y1="11" x2="14" y2="17" />
  <path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" />
  <path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" />
</svg>
`;
const editIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-edit" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 7h-3a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-3" />
  <path d="M9 15h3l8.5 -8.5a1.5 1.5 0 0 0 -3 -3l-8.5 8.5v3" />
  <line x1="16" y1="5" x2="19" y2="8" />
</svg>
`;
const growIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrows-diagonal-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="16 20 20 20 20 16" />
  <line x1="14" y1="14" x2="20" y2="20" />
  <polyline points="8 4 4 4 4 8" />
  <line x1="4" y1="4" x2="10" y2="10" />
</svg>
`;

const copyIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="8" y="8" width="12" height="12" rx="2"></rect>
   <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path>
</svg>
`;

const pasteIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2"></path>
   <rect x="9" y="3" width="6" height="4" rx="2"></rect>
   <path d="M9 14l2 2l4 -4"></path>
</svg>
`;

const targetIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-focus" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <circle cx="12" cy="12" r=".5" fill="currentColor"></circle>
   <circle cx="12" cy="12" r="9"></circle>
</svg>
`;

const settingsIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-settings" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z" />
  <circle cx="12" cy="12" r="3" />
</svg>
`;

const rotateIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rotate-clockwise" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M4.05 11a8 8 0 1 1 .5 4m-.5 5v-5h5"></path>
</svg>
`;

const templateString = `
<style>
 :host {
     --halo-button-height: 25px;
     --halo-button-width: 25px;
     --halo-rim-margin: 10px;
     --halo-button-width-padded: calc(var(--halo-button-width) + var(--halo-rim-margin));
     --halo-button-height-padded: calc(var(--halo-button-height) + var(--halo-rim-margin));
     position: absolute;
     box-sizing: border-box;
     top: calc(-1 * var(--halo-button-height-padded));
     left: calc(-1 * var(--halo-button-width-padded));
     width: calc(100% + (2 * var(--halo-button-width-padded)));
     height: calc(100% + (2 * var(--halo-button-height-padded)));
     color: initial;
     z-index: 10;
 }


 .halo-row,
 .halo-column {
     display: flex;
     position: absolute;
 }

 .halo-column {
     flex-direction: column;
 }

 #halo-top-row,
 #halo-bottom-row {
     width: calc(100% - var(--halo-button-width-padded));
     height: var(--halo-button-height-padded);
 }

 #halo-top-row {
     left: 0;
     top: 0;
 }

 #halo-bottom-row {
     right: 0;
     bottom: 0;
     flex-direction: row-reverse;
     align-items: flex-end;
 }

 #halo-right-column,
 #halo-left-column {
     height: calc(100% - var(--halo-button-height-padded));
     width: var(--halo-button-width-padded);
 }

 #halo-right-column {
     right: 0;
     top: 0;
     align-items: flex-end;
 }

 #halo-left-column {
     left: 0;
     top: var(--halo-button-height-padded);
 }

 .halo-button,
 ::slotted(*) {
     display: block;
     border: 1px solid rgba(100, 100, 100, 0.8);
     width: var(--halo-button-width);
     height: var(--halo-button-height);
     background-color: rgb(220, 220, 220);
 }

 .halo-button:hover
 ::slotted(*).halo-button:hover {
     cursor: pointer;
 }

 .halo-button:active
 ::slotted(*).halo-button:active {
     border: 1px solid black;
 }

 .halo-button.hidden
 ::slotted(*).halo-button.hidden {
     display: none;
 }

</style>

<div id="halo-top-row" class="halo-row">
    <div id="halo-delete" class="halo-button" title="Delete this part">
        ${deleteIcon}
    </div>
    <slot name="top-row"></slot>
</div>

<div id="halo-bottom-row" class="halo-row">
    <div id="halo-resize" class="halo-button" title="Resize this part">
        ${growIcon}
    </div>
    <div id="halo-script-edit" class="halo-button" title="Edit this part's script">
        ${editIcon}
    </div>
    <div id="halo-edit" class="halo-button" title="Edit this part">
        ${settingsIcon}
    </div>
    <slot name="bottom-row"></slot>
</div>

<div id="halo-left-column" class="halo-column">
    <div id="halo-copy" class="halo-button" title="Copy this Part">
        ${copyIcon}
    </div>
    <div id="halo-paste" class="halo-button" title="Paste the contents of clipboard into this Part">
        ${pasteIcon}
    </div>
    <div id="halo-target" class="halo-button" title="Select this Part's target">
        ${targetIcon}
    </div>
    <slot name="left-column"></slot>
</div>

<div id="halo-right-column" class="halo-column">
    <div id="halo-rotate" class="halo-button" title="Rotate this part">
        ${rotateIcon}
    </div>
    <slot name="right-column"></slot>
</div>

`;

class Halo extends HTMLElement {
    constructor(){
        super();

        // Configure the Shadow DOM and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind component methods


        // Bind event listeners
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onResizeMouseDown = this.onResizeMouseDown.bind(this);
        this.onResizeMouseUp = this.onResizeMouseUp.bind(this);
        this.onResizeMouseMove = this.onResizeMouseMove.bind(this);
        this.onRotateMouseDown = this.onRotateMouseDown.bind(this);
        this.onRotateMouseUp = this.onRotateMouseUp.bind(this);
        this.onRotateMouseMove = this.onRotateMouseMove.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.targetElement = this.getRootNode().host;
            this.targetElement.classList.add('editing');
            this.targetElement.hasOpenHalo = true;

            // Add event listeners
            this.addEventListener('mousedown', this.onMouseDown);

            // Resize button
            this.resizer = this.shadowRoot.getElementById('halo-resize');
            this.resizer.addEventListener('mousedown', this.onResizeMouseDown);
            if(!this.targetElement.wantsHaloResize){
                this.resizer.style.visibility = 'hidden';
            }

            // Rotate button
            this.rotater = this.shadowRoot.getElementById('halo-rotate');
            this.rotater.addEventListener('mousedown', this.onRotateMouseDown);
            if(!this.targetElement.wantsHaloRotate){
                this.rotater.style.visibility = 'hidden';
            }
            // Delete button
            this.deleter = this.shadowRoot.getElementById('halo-delete');
            this.deleter.addEventListener('click', this.targetElement.onHaloDelete);
            if(!this.targetElement.wantsHaloDelete){
                this.deleter.style.visibility = 'hidden';
            }

            // Edit button
            this.scriptEditor = this.shadowRoot.getElementById('halo-script-edit');
            this.scriptEditor.addEventListener('click', this.targetElement.onHaloOpenScriptEditor);
            if(!this.targetElement.wantsHaloScriptEdit){
                this.scriptEditor.style.visibility = 'hidden';
            }

            // Comprehensive editor button
            this.editor = this.shadowRoot.getElementById('halo-edit');
            this.editor.addEventListener('click', this.targetElement.onHaloOpenEditor);
            if(!this.targetElement.wantsHaloEdit){
                this.editor.style.visibility = 'hidden';
            }

            // Copy button
            this.copier = this.shadowRoot.getElementById('halo-copy');
            this.copier.addEventListener('click', this.targetElement.onHaloCopy);


            // Paste button
            this.paster = this.shadowRoot.getElementById('halo-paste');
            this.paster.addEventListener('click', this.targetElement.onHaloPaste);

            // Target button
            this.targeter = this.shadowRoot.getElementById('halo-target');
            this.targeter.addEventListener('click', this.targetElement.onHaloTarget);
            this.targeter.addEventListener('mouseenter', this.targetElement.onHaloTargetButtonMouseEnter);
            this.targeter.addEventListener('mouseleave', this.targetElement.onHaloTargetButtonMouseLeave);
        }
    }

    disconnectedCallback(){
        this.targetElement.classList.remove('editing');
        this.targetElement.hasOpenHalo = false;

        // Remove event listeners
        this.removeEventListener('mousedown', this.onMouseDown);
        this.resizer.removeEventListener('mousedown', this.onResizeMouseDown);
    }


    /* Event Handling */
    onMouseDown(event){
        if(event.button == 0 && this.targetElement.wantsHaloMove){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        let currentTop = parseInt(this.targetElement.style.top);
        let currentLeft = parseInt(this.targetElement.style.left);
        let newTop = event.movementY + currentTop;
        let newLeft = event.movementX + currentLeft;

        let model = this.targetElement.model;
        model.partProperties.setPropertyNamed(model, "top", newTop);
        model.partProperties.setPropertyNamed(model, "left", newLeft);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    onResizeMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onResizeMouseMove);
        document.addEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseUp(event){
        document.removeEventListener('mousemove', this.onResizeMouseMove);
        document.removeEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseMove(event){
        this.targetElement.onHaloResize(
            event.movementX,
            event.movementY
        );
    }

    onRotateMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onRotateMouseMove);
        document.addEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseUp(event){
        document.removeEventListener('mousemove', this.onRotateMouseMove);
        document.removeEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseMove(event){
        this.targetElement.onHaloRotate(
            event.movementX,
            event.movementY
        );
    }
};




/***/ }),

/***/ "./js/objects/views/ImageView.js":
/*!***************************************!*\
  !*** ./js/objects/views/ImageView.js ***!
  \***************************************/
/*! exports provided: ImageView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageView", function() { return ImageView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const pictureIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <line x1="15" y1="8" x2="15.01" y2="8"></line>
   <rect x="4" y="4" width="16" height="16" rx="3"></rect>
   <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5"></path>
   <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2"></path>
</svg>
`;

const templateString = `
<img id="wrapped-image" class="hidden" />
<svg class="hidden" id="wrapped-svg" xmlns="http://www.w3.org/2000/svg">
</svg>
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    user-select: none;
}

.hidden {
    display: none;
}
img {
    width: 100%;
    height: auto;
    display: block;
}

.currently-wrapped {
    width: 100%;
    height: 100%;
}
</style>
`;

class ImageView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.updateImageData = this.updateImageData.bind(this);
        this.updateSvgImage = this.updateSvgImage.bind(this);
        this.updateBinaryImage = this.updateBinaryImage.bind(this);
        this.setDefaultImage = this.setDefaultImage.bind(this);
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateImageLink = this.updateImageLink.bind(this);
        this.updateSizingForViewport = this.updateSizingForViewport.bind(this);
    }

    afterModelSet(){
        // prop changes
        this.onPropChange("imageData", (imageData) => {
            if(!imageData){
                this.setDefaultImage();
            }
            this.updateImageData(imageData);
        });

        // Make sure we have imageData. If not, try
        // to load from a src.
        let currentImageData = this.model.partProperties.getPropertyNamed(
            this.model,
            "imageData"
        );
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            "src"
        );
        if(!currentImageData){
            if(currentSrc){
                let msg = {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ currentSrc ]
                };
                this.model.sendMessage(msg, this.model);
            } else {
                this.setDefaultImage();
            }
        } else {
            this.updateImageData(currentImageData);
        }
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    setDefaultImage(){
        this.model.partProperties.setPropertyNamed(this.model, "imageData", pictureIcon);
        this.model.partProperties.setPropertyNamed(this.model, "mimeType", "image/svg");
        this.model.partProperties.setPropertyNamed(this.model, "src", "");
        this.updateImageData(pictureIcon);
    }

    updateImageData(imageData){
        if(this.model.isSvg){
            this.updateSvgImage(imageData);
        } else {
            this.updateBinaryImage(imageData);
        }
    }

    updateBinaryImage(imageData){
        // In this case, the imageData is
        // a base64 encoded data url describing
        // the bits of the image.
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let svgEl = this._shadowRoot.getElementById('wrapped-svg');
        svgEl.classList.add('hidden');
        svgEl.classList.remove('currently-wrapped');
        imgEl.classList.add('currently-wrapped');
        imgEl.src = imageData;
        imgEl.onload = () => {
            //this.updateSizingForViewport();
        };
        this.preserveAspectOnResize = true;
        imgEl.classList.remove('hidden');
    }

    updateSvgImage(imageData){
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let currentSvgEl = this._shadowRoot.getElementById('wrapped-svg');
        let parser = new DOMParser();
        let xmlDocument = parser.parseFromString(imageData, 'application/xml');
        let newSvgEl = xmlDocument.documentElement;

        // Ensure that the SVG has some width and height attributes
        // set so we have initial dimensions to display. If not present,
        // pull from viewbox.
        if(!newSvgEl.hasAttribute('width') || !newSvgEl.hasAttribute('height')){
            let viewBox = newSvgEl.getAttribute('viewBox');
            if(viewBox){
                viewBox = viewBox.split(" ");
                let viewBoxWidth = parseInt(viewBox[2]);
                let viewBoxHeight = parseInt(viewBox[3]);
                newSvgEl.setAttribute('height', viewBoxHeight);
                newSvgEl.setAttribute('width', viewBoxWidth);
            }
        } 
        newSvgEl.id = 'wrapped-svg';
        newSvgEl.classList.add('currently-wrapped');
        imgEl.classList.add('hidden');
        imgEl.classList.remove('currently-wrapped');
        currentSvgEl.remove();
        this._shadowRoot.appendChild(newSvgEl);
        this.updateSizingForViewport();
        this.preserveAspectOnResize = false;
    }

    updateImageLink(event){
        // Tells the model to update its
        // src link for the image
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for image:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ result ]
                },
                this.model
            );
        }
    }

    updateSizingForViewport(){
        // Ensure that this component does not display larger
        // than the current remaining subrectangle of its origin
        // and the corner of the viewport
        let padding = 40;
        // First, we need to find the absolute top corner
        // locations for the element
        let el = this._shadowRoot.querySelector('.currently-wrapped');
        let top = 0;
        let left = 0;
        while(el){
            top += el.offsetTop;
            left += el.offsetLeft;
            el = el.offsetParent;
        }

        let rect = this.getBoundingClientRect();
        let heightLimit = document.documentElement.clientHeight - padding;
        if((rect.height + top) > heightLimit){
            let ratio = (heightLimit - top) / rect.height;
            // this.style.height = `${rect.height * ratio}px`;
            // this.style.width = `${rect.width * ratio}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                (rect.width * ratio)
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                (rect.height * ratio)
            );
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    onHaloResize(movementX, movementY){
        // Override default behavior.
        // We resize the wrapped svg or img instead
        // and have the outer component simply react to
        // the change.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let wrappedImage = this._shadowRoot.querySelector('.currently-wrapped');
        let rect = wrappedImage.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let maxWidth = rect.width + movementX;
            let maxHeight = rect.height + movementY;
            let ratio = Math.min(maxWidth / rect.width, maxHeight / rect.height);
            newHeight = rect.height * ratio;
            newWidth = rect.width * ratio;
        } else {
            newWidth = rect.width + movementX;
            newHeight = rect.height + movementY;
        }

        if(newWidth && newHeight){
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight
            );
        }
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-image-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for image file');
        this.haloButton.addEventListener('click', this.updateImageLink);
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        contextMenu.addListItem(
            'Edit Image URL',
            this.updateImageLink
        );
    }
};




/***/ }),

/***/ "./js/objects/views/PartView.js":
/*!**************************************!*\
  !*** ./js/objects/views/PartView.js ***!
  \**************************************/
/*! exports provided: PartView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartView", function() { return PartView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartView; });
/* harmony import */ var _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contextmenu/ContextMenu.js */ "./js/objects/views/contextmenu/ContextMenu.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/**
 * PartView
 * ----------------------------------------
 * I am an *abstract* webcompoent CustomElement
 * that serves as the generic view for any Part
 * models.
 * I should not be instantiated directly, nor should
 * I be added to any web page's registry of CustomElements.
 * I am indended to be extended (subclassed) by the actual
 * views for each Part kind, and therefore I contain all
 * of the common behavior, including lifecycle methods,
 * for these.
 */



window.customElements.define('st-context-menu', _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

class PartView extends HTMLElement {
    constructor(){
        super();
        this.model = null;
        this.isPartView = true;
        this.isLensed = false;
        this.name = this.constructor.name;
        this.propChangeHandlers = {};
        this.setupBasePropHandlers();
        this.viewChangeHandlers = {};
        this.setupBaseViewChangeHandlers();

        // Halo settings. All are on by default
        this.wantsHaloResize = true;
        this.wantsHaloRotate = true;
        this.wantsHaloScriptEdit = true;
        this.wantsHaloEdit = true;
        this.wantsHaloDelete = true;
        this.wantsHalo = true;
        // Note: see getter for wantsHaloMove

        // Context menu settings
        this.wantsContextMenu = true;

        // Bind component methods
        this.setModel = this.setModel.bind(this);
        this.unsetModel = this.unsetModel.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.setupBasePropHandlers = this.setupBasePropHandlers.bind(this);
        this.setupBaseViewChangeHandlers = this.setupBaseViewChangeHandlers.bind(this);
        this.initLayout = this.initLayout.bind(this);

        // Bind initial property method
        this.styleCSS = this.styleCSS.bind(this);
        this.styleTextCSS = this.styleTextCSS.bind(this);

        // Bind property change reaction methods
        this.primHandlePropChange = this.primHandlePropChange.bind(this);
        this.onPropChange = this.onPropChange.bind(this);
        this.primHandleViewChange = this.primHandleViewChange.bind(this);
        this.onViewChange = this.onViewChange.bind(this);
        this.scriptChanged = this.scriptChanged.bind(this);
        this.layoutChanged = this.layoutChanged.bind(this);
        this.listDirectionChanged = this.listDirectionChanged.bind(this);
        this.listWrappingChanged = this.listWrappingChanged.bind(this);
        this.vResizingChanged = this.vResizingChanged.bind(this);
        this.hResizingChanged = this.hResizingChanged.bind(this);
        this.pinningLeftChanged = this.pinningLeftChanged.bind(this);
        this.pinningTopChanged = this.pinningTopChanged.bind(this);
        this.pinningBottomChanged = this.pinningBottomChanged.bind(this);
        this.pinningRightChanged = this.pinningRightChanged.bind(this);
        this.listAlignmentChanged = this.listAlignmentChanged.bind(this);
        this.listDistributionChanged = this.listDistributionChanged.bind(this);

        // Bind view change reaction methods
        this.subpartOrderChanged = this.subpartOrderChanged.bind(this);
        this.newSubpartView = this.newSubpartView.bind(this);

        // Bind Halo related methods
        this.openHalo = this.openHalo.bind(this);
        this.closeHalo = this.closeHalo.bind(this);
        this.onHaloDelete = this.onHaloDelete.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onHaloOpenScriptEditor = this.onHaloOpenScriptEditor.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.onHaloRotate = this.onHaloRotate.bind(this);
        this.onHaloPaste = this.onHaloPaste.bind(this);
        this.onHaloCopy = this.onHaloCopy.bind(this);
        this.onHaloTarget = this.onHaloTarget.bind(this);
        this.endHaloTarget = this.endHaloTarget.bind(this);
        this.onHaloTargetButtonMouseEnter = this.onHaloTargetButtonMouseEnter.bind(this);
        this.onHaloTargetButtonMouseLeave = this.onHaloTargetButtonMouseLeave.bind(this);
        this.onHaloActivationClick = this.onHaloActivationClick.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onAuxClick = this.onAuxClick.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onContextMenuClick = this.onContextMenuClick.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.handleTargetKey = this.handleTargetKey.bind(this);
        this.handleTargetMouseClick = this.handleTargetMouseClick.bind(this);
        this.handleTargetMouseOver = this.handleTargetMouseOver.bind(this);
        this.handleTargetMouseOut = this.handleTargetMouseLeave.bind(this);
        this.addContextMenuItems = this.addContextMenuItems.bind(this);
        this.getCurrentTargetViews = this.getCurrentTargetViews.bind(this);

        // Bind editor related methods
        this.openEditor = this.openEditor.bind(this);
        this.closeEditor = this.closeEditor.bind(this);

        // Context menu
        this.openContextMenuAt = this.openContextMenuAt.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);

        // misc
        this.highlight = this.highlight.bind(this);
        this.unhighlight = this.unhighlight.bind(this);

        // Bind lifecycle methods
        this.afterModelSet = this.afterModelSet.bind(this);
        this.afterModelUnset = this.afterModelUnset.bind(this);
        this.afterConnected = this.afterConnected.bind(this);
        this.afterDisconnected = this.afterDisconnected.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Do some universal PartView configuration
            // when attached to a parent element, like
            // registering event listeners etc

            // Register middle mouse button click
            // to toggle the halo
            this.addEventListener('auxclick', this.onAuxClick);

            // Register default event handlers manually]
            this.addEventListener('click', this.onClick);
            this.addEventListener('contextmenu', this.onContextMenuClick);

            // Call the lifecycle method when done
            // with the above
            this.afterConnected();
        }
    }

    disconnectedCallback(){
        this.removeEventListener('auxclick', this.onAuxClick);
        this.removeEventListener('click', this.onClick);
        this.removeEventListener('contextmenu', this.onContextMenuClick);
        this.afterDisconnected();
    }

    setModel(aModel){
        this.unsetModel();
        this.model = aModel;
        aModel.addPropertySubscriber(this);
        aModel.addViewSubscriber(this);
        if(this.isLensed){
            this.removeAttribute('part-id');
            this.setAttribute('lens-part-id', aModel.id);
        } else {
            this.removeAttribute('lens-part-id');
            this.setAttribute('part-id', aModel.id);
        }

        // load all the initial styling
        this.styleCSS();
        this.styleTextCSS();
        this.initLayout();
        this.afterModelSet();
    }

    unsetModel(){
        if(this.model){
            let removedModel = this.model;
            this.model.removePropertySubscriber(this);
            this.model = null;
            this.setAttribute('part-id', "");
            this.afterModelUnset(removedModel);
        }
    }

    setupBasePropHandlers(){
        // This is where we should setup any
        // prop change handlers that are universal
        // to all PartViews. We would do this via
        // the #onPropChange method, which registers
        // a handler function.
        // Do not override this method
        // TODO: Implement the universals
        this.onPropChange('script', this.scriptChanged);
        this.onPropChange('number', this.numberChanged);
        this.onPropChange('cssStyle', this.styleCSS);
        this.onPropChange('cssTextStyle', this.styleTextCSS);
        this.onPropChange('layout', this.layoutChanged);
        this.onPropChange('list-direction', this.listDirectionChanged);
        this.onPropChange('list-wrapping', this.listWrappingChanged);
        this.onPropChange('list-alignment', this.listAlignmentChanged);
        this.onPropChange('list-distribution', this.listDistributionChanged);
        this.onPropChange('horizontal-resizing', this.hResizingChanged);
        this.onPropChange('vertical-resizing', this.vResizingChanged);
        this.onPropChange('pinning-top', this.pinningTopChanged);
        this.onPropChange('pinning-right', this.pinningRightChanged);
        this.onPropChange('pinning-left', this.pinningLeftChanged);
        this.onPropChange('pinning-bottom', this.pinningBottomChanged);
        this.onPropChange('wants-move', (value) => {
            if(value){
                this.addEventListener('mousedown', this.onMouseDown);
            } else {
                this.removeEventListener('mousedown', this.onMouseDown);
            }
        });
    }

    setupBaseViewChangeHandlers(){
        // This is where we should setup any
        // view change handlers that are universal
        // to all PartViews. We would do this via
        // the #onViewChange method, which registers
        // a handler function.
        // Do not override this method
        this.onViewChange('subpart-order', this.subpartOrderChanged);
        this.onViewChange('subpart-new', this.newSubpartView);
    }

    initLayout(){
        // Not all Part/PartView pairs have the layout
        // properties. Ensure they exist first
        let hasLayout = this.model.partProperties.findPropertyNamed('layout');
        let hasBoxResizing = this.model.partProperties.findPropertyNamed('vertical-resizing');
        let hasPinning = this.model.partProperties.findPropertyNamed('pinning');
        if(hasLayout){
            let initialLayout = this.model.partProperties.getPropertyNamed(
                this.model,
                'layout'
            );
            let initialListDirection = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-direction'
            );
            let initialListWrapping = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-wrapping'
            );
            this.layoutChanged(initialLayout);
            this.listDirectionChanged(initialListDirection);
            this.listWrappingChanged(initialListWrapping);
            this.listAlignmentChanged();
            this.listDistributionChanged();
        }

        if(hasBoxResizing){
            let initialVResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'vertical-resizing'
            );
            let initialHResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'horizontal-resizing'
            );
            this.vResizingChanged(initialVResizing);
            this.hResizingChanged(initialHResizing);
        }

        if(hasPinning){
            this.pinningTopChanged();
            this.pinningBottomChanged();
            this.pinningLeftChanged();
            this.pinningRightChanged();
        }
    }

    styleCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    styleTextCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    sendMessage(aMessage, target){
        if(!this.isLensed){
            // Lensed views should not send messages
            window.System.sendMessage(aMessage, this, target);
        }
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            this.primHandlePropChange(
                aMessage.propertyName,
                aMessage.value,
                aMessage.partId
            );
            break;
        case 'viewChanged':
            this.primHandleViewChange(
                aMessage.changeName,
                ...aMessage.args
            );
            break;
        }
    }

    primHandlePropChange(name, value, partId){
        // We notify the model that the property change so that
        // on propertyChanged command handlers could be invoked
        // but we make sure that this stops at the said model and
        // does not go up the delegation chain
        let commandMessage = {
            type: 'command',
            commandName: 'propertyChanged',
            args: [name, value],
            shouldNotDelegate:true, // do not send this up the delegation chain
            shouldIgnore: true
        };
        this.sendMessage(commandMessage, this.model);
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.propChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(value, partId);
    }


    onPropChange(name, func){
        this.propChangeHandlers[name] = func;
    }

    primHandleViewChange(name, ...args){
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.viewChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(...args);
    }

    onViewChange(name, func){
        this.viewChangeHandlers[name] = func;
    }

    scriptChanged(value, partId){
        this.model.sendMessage({
            type: 'compile',
            codeString: value,
            targetId: partId
        }, window.System);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        // there is no need to do anything for the wrapped views
        // CardRow and StackRow will handle the updates
        if(this.name == "WrappedView"){
            return;
        }
        let subpartNode = this.childNodes[currentIndex];
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
    }

    newSubpartView(newView){
        this.appendChild(newView);
    }

    layoutChanged(value, partId){
        if(value == 'list'){
            this.classList.add('list-layout');
        } else {
            this.classList.remove('list-layout');
        }
    }

    listDirectionChanged(value, partId){
        // Row is the default configuration
        // for a list layout, so only one extra
        // CSS class needs to be toggled
        if(value == 'row'){
            this.classList.remove('list-column');
        } else if(value == 'column'){
            this.classList.add('list-column');
        }
    }

    listWrappingChanged(value, partId){
        if(value == true){
            this.classList.add('wrap-list');
        } else {
            this.classList.remove('wrap-list');
        }
    }

    hResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('h-space-fill');
            this.classList.remove(
                'h-rigid',
                'h-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('h-shrink-wrap');
            this.classList.remove(
                'h-rigid',
                'h-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('h-rigid');
            this.classList.remove(
                'h-space-fill',
                'h-shrink-wrap'
            );
        }
    }

    vResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('v-space-fill');
            this.classList.remove(
                'v-rigid',
                'v-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('v-shrink-wrap');
            this.classList.remove(
                'v-rigid',
                'v-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('v-rigid');
            this.classList.remove(
                'v-space-fill',
                'v-shrink-wrap'
            );
        }
    }

    pinningTopChanged(){
        let top = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-top'
        );
        if(top){
            this.classList.add('pin-top');
        } else {
            this.classList.remove('pin-top');
        }
    }

    pinningLeftChanged(){
        let left = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-left'
        );
        if(left){
            this.classList.add('pin-left');
        } else {
            this.classList.remove('pin-left');
        }
    }

    pinningRightChanged(){
        let right = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-right'
        );
        if(right){
            this.classList.add('pin-right');
        } else {
            this.classList.remove('pin-right');
        }
    }

    pinningBottomChanged(){
        let bottom = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-bottom'
        );
        if(bottom){
            this.classList.add('pin-bottom');
        } else {
            this.classList.remove('pin-bottom');
        }
    }

    listAlignmentChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-alignment'
        );
        let valid = [
            'top',
            'bottom',
            'left',
            'right',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-align-${side}`);
            });
            this.classList.add(`list-align-${value}`);
        }
    }

    listDistributionChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-distribution'
        );
        let valid = [
            'start',
            'end',
            'space-between',
            'space-around',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-distribution-${side}`);
            });
            this.classList.add(`list-distribution-${value}`);
        }
    }

    /* Lifecycle Method Defaults */
    afterModelSet(){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterModelUnset(removedModel){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterConnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    afterDisconnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    /* Halo Related Methods */

    openHalo(){
        // Check to see if there's a halo in
        // the component's shadow root already
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            let newHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(newHalo);
        }
    }

    closeHalo(){
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(foundHalo){
            foundHalo.remove();
        }
    }

    toggleAntsBorder(){
        if(this.classList.contains('marching-ants')){
            this.classList.remove('marching-ants');
        } else {
            this.classList.add('marching-ants');
        }
    }

    onHaloDelete(){
        // What to do when the user clicks the
        // delete button on a halo for this partview.
        // The default implementation is to send a message
        // to the System to delete the corresponding
        // model and *all* views referencing that
        // model.
        this.sendMessage({
            type: 'command',
            commandName: 'deleteModel',
            args: [this.model.id]
        }, window.System);
    }

    onHaloOpenScriptEditor(){
        // Send the message to open a script editor
        // with this view's model as the target
        this.model.sendMessage({
            type: 'command',
            commandName: 'openScriptEditor',
            args: [this.model.id]
        }, this.model);
    }

    onHaloOpenEditor(){
        window.System.editor.render(this.model);
        window.System.editor.open();
    }

    onHaloResize(movementX, movementY){
        // Default implementation on what to do during
        // halo button resize opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // width and height style properties directly.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let rect = this.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let ratio = rect.width / rect.height;
            let hyp = Math.sqrt((movementX**2) + (movementY**2));
            if(movementX < 0 || movementY < 0){
                hyp = hyp * -1;
            }
            newHeight = rect.height + hyp;
            newWidth = rect.width + hyp;
        } else {
            newWidth = movementX + rect.width;
            newHeight = movementY + rect.height;
        }
        this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
        this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    onHaloRotate(movementX, movementY){
        // Default implementation on what to do during
        // halo button rotate opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // rotate style property directly.
        if(movementX || movementY){
            let currentAngle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
            let rect = this.getBoundingClientRect();
            if(!currentAngle){
                currentAngle = 0;
            }
            let theta1 = Math.atan((rect.height/2)/(rect.width/2));
            let theta2 = Math.atan((rect.height/2 + movementY)/(rect.width/2 + movementX));
            let changeAngle = Math.abs((theta2 - theta1)*180/Math.PI);
            let newAngle = (currentAngle + changeAngle) % 360;
            if(newAngle < 0){
                newAngle = 360 + newAngle;
            }
            if(newAngle){
                this.model.partProperties.setPropertyNamed(this.model, "rotate", newAngle);
            }
        }
    }

    onHaloCopy(){
        window.System.clipboard.copyPart(this.model);
    }

    onHaloPaste(){
        window.System.clipboard.pasteContentsInto(this.model);
        this.closeHalo();
    }

    onHaloTarget(event){
        // Add targeting receive listeners to all PartViews
        // on the current card.
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.addEventListener('keydown', this.handleTargetKey);
            partView.addEventListener('mouseover', this.handleTargetMouseOver);
            partView.addEventListener('mouseout', this.handleTargetMouseOut);
            partView.addEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.add('targeting-mode');
        event.stopPropagation();
    }

    onHaloTargetButtonMouseEnter(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); //green
        });
    }

    onHaloTargetButtonMouseLeave(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.unhighlight();
        });
    }

    highlight(color){
        if(this.name != "StackView" && this.name != "WorldView"){
            this._tempBackgroundColor = this.model.partProperties.getPropertyNamed(this.model, "background-color");
            this.model.partProperties.setPropertyNamed(this.model, "background-color", color);
            this._tempBackgroundTransparency = this.model.partProperties.getPropertyNamed(this.model, "background-transparency");
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", 1);
        }

    }

    unhighlight(){
        if(this.name != "StackView" && this.name != "WorldView"){
            this.model.partProperties.setPropertyNamed(this.model, "background-color", this._tempBackgroundColor);
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", this._tempBackgroundTransparency);
        }
    }

    endHaloTarget(){
        // Remove all targeting related event listeners
        // that were added during the onHaloTarget
        // handler
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('mouseover', this.handleTargetMouseOver);
            partView.removeEventListener('mouseout', this.handleTargetMouseOut);
            partView.removeEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.remove('targeting-mode');
    }

    handleTargetKey(event){
        if(event.key == 'Escape'){
            this.endHaloTarget();
        }
    }

    handleTargetMouseOver(event){
        if(!event.target.classList.contains('targeting')){
            event.target.classList.add('targeting');
            event.target.highlight("rgb(234, 55, 55)");
            event.target.removeEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseLeave(event){
        if(event.target.classList.contains('targeting')){
            event.target.classList.remove('targeting');
            event.target.unhighlight();
            event.target.addEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseClick(event){
        event.preventDefault();
        if(event.button == 0 && event.shiftKey){
            this.onHaloActivationClick(event);
            return;
        }
        event.target.classList.remove('targeting');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'target',
            event.target.model.id
        );
        this.endHaloTarget();
        event.stopImmediatePropagation();
        event.target.unhighlight();
        event.target.addEventListener('click', event.target.onClick);
    }

    getCurrentTargetViews(){
        // clean up the current target
        let currentTarget = this.model.partProperties.getPropertyNamed(this.model, "target");
        if(currentTarget){
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this.model, window.System)
            );
            let m = window.System.grammar.match(currentTarget, "ObjectSpecifier");
            let targetId = semantics(m).interpret();
            return window.System.findViewsById(targetId);
        }
        return [];
    }

    onContextMenuClick(event){
        if(this.wantsContextMenu){
            event.preventDefault();
            event.stopPropagation();
            if(this.contextMenuIsOpen){
                this.closeContextMenu();
            } else {
                this.openContextMenuAt(
                    event.clientX,
                    event.clientY
                );
            }
        } else {
            event.stopPropagation();
        }
    }

    onAuxClick(event){
        // Should only open halo when middle
        // mouse button is clicked
        if(event.button == 1){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onClick(event){
        if(this.contextMenuIsOpen){
            this.closeContextMenu();
        }
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onHaloActivationClick(event){
        if(this.wantsHalo){
            if(this.hasOpenHalo){
                this.closeHalo();
            } else {
                event.stopPropagation();
                // Find any other open Halos
                // and automatically close them
                let exSelector = `.editing:not([part-id="${this.model.id}"])`;
                Array.from(document.querySelectorAll(exSelector)).forEach(openHaloEl => {
                    openHaloEl.closeHalo();
                });

                // Finally, open on this view
                this.openHalo();
            }
        }
    }

    onMouseDown(event){
        if(event.button == 0 && !event.shiftKey){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        this.sendMessage({
            type: 'command',
            commandName: 'move',
            args: [event.movementX, event.movementY]
        }, this.model);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    openContextMenuAt(x, y){
        let menuEl = document.createElement('st-context-menu');
        let worldView = document.querySelector('[part-id="world"]');
        menuEl.render(this.model);
        menuEl.style.left = `${x}px`;
        menuEl.style.top = `${y}px`;
        worldView.append(menuEl);
    }

    closeContextMenu(){
        let found = document.querySelector('st-context-menu');
        if(found){
            found.remove();
        }
    }

    addContextMenuItems(contextMenu){
        // The default implementation is to
        // do nothins.
        // Subclasses should override and use the
        // passed-in contextMenu object to construct
        // list items that are specific to their needs
        return;
    }

    get wantsHaloMove(){
        if(!this.parentElement || !this.isConnected){
            return false;
        }
        let parentModel = this.parentElement.model;
        if(!parentModel){
            return true;
        }

        let hasLayout = parentModel.partProperties.findPropertyNamed(
            parentModel,
            'layout'
        );

        if(!hasLayout){
            return true;
        }

        let parentLayout = parentModel.partProperties.getPropertyNamed(
            parentModel,
            'layout'
        );
        if(parentLayout === 'strict' | !parentLayout || parentLayout == ""){
            return true;
        }

        return false;
    }

    get contextMenuIsOpen(){
        let found = document.querySelector('st-context-menu');
        if(found){
            return true;
        }
        return false;
    }

    /* Editor related methods */
    openEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    closeEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }
};




/***/ }),

/***/ "./js/objects/views/ResourceView.js":
/*!******************************************!*\
  !*** ./js/objects/views/ResourceView.js ***!
  \******************************************/
/*! exports provided: ResourceView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceView", function() { return ResourceView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResourceView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-building-bridge-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <path d="M6 7h12a2 2 0 0 1 2 2v9a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-2a4 4 0 0 0 -8 0v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-9a2 2 0 0 1 2 -2"></path>
    </svg>
</div>
`;

class ResourceView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateResourceLink = this.updateResourceLink.bind(this);
        this.indicateReadyState = this.indicateReadyState.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        // if the resourceName property is set then make sure it is loaded
        // TODO: i don't like this view asking the model to load!
        let resourceName = this.model.partProperties.getPropertyNamed(this.model, "resourceName");
        if(resourceName){
            this.model.loadResource([this], resourceName);
        }
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            this.model.setSourceTo([this], src);
        }
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        let state = this.model.partProperties.getPropertyNamed(
            this.model,
            "readyState",
        );
        this.indicateReadyState(state);
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", this.indicateReadyState);
        this.onPropChange("src", (url) => {
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    indicateReadyState(value){
        let borderColor = "red";
        if(value == "fetching"){
            borderColor = "yellow";
        } else if(value == "ready"){
            borderColor = "green";
        };
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-resource-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for resource');
        this.haloButton.addEventListener('click', this.updateResourceLink);
    }

    updateResourceLink(event){
        // Tells the model to update its
        // src link for the resource
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for resource:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadResource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/StackView.js":
/*!***************************************!*\
  !*** ./js/objects/views/StackView.js ***!
  \***************************************/
/*! exports provided: StackView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackView", function() { return StackView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Stack.js */ "./js/objects/parts/Stack.js");
/**
 * StackView
 * ----------------------------------------------
 * I am a Webcomponent (custom element) representing
 * the view of a Stack.
 * I take up the full width of the current viewport
 * when I am being displayed.
 * My child elements are BackgroundView and CardView
 */




// by default, stacks are hidden unless they're
// the current stack, or else they have the class
// window-stack (suggesting there's window part
// who wishes to display it)
const templateString = `<slot></slot>`;

class StackView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup templating and shadow dom
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Handle current-ness prop change
        this.onPropChange('current', this.handleCurrentChange);

        // Bind methods
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
    }

    afterModelSet(){
        // Do an initial setting of the
        // current card
        this.handleCurrentChange();
    }

    handleCurrentChange(){
        // The value of the current prop is the card ID
        // of the child Card that should be the
        // current one. We remove the current-card class from
        // the previous current card and add it to the new one.
        let currentCard = this.querySelector('.current-card');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let shouldNotify = false;
        let selector = `:scope > st-card[part-id="${nextCurrentId}"]`;
        if(this.isLensed){
            selector = `:scope > st-card[lens-part-id="${nextCurrentId}"]`;
            shouldNotify = true;
        }
        let nextCurrentCard = this.querySelector(selector);
        // if there is no currentCard and no next currentCard we set it to be the first
        // card child (this can happen when new ids are created on deserialization and so
        // the current property stored id is no longer relevant)
        if(!nextCurrentCard && !currentCard){
            nextCurrentCard = this.querySelector(`:scope > st-card`);
            // if there are no cards at all, this must be a brand new stack
            if(!nextCurrentCard){
                return;
            }
            this.model.partProperties.setPropertyNamed(
                this.model,
                "current",
                nextCurrentCard.id,
                shouldNotify
            );
        }
        if(nextCurrentCard){
            nextCurrentCard.classList.add('current-card');
        } else {
            return;
        }
        if(currentCard && currentCard != nextCurrentCard){
            currentCard.classList.remove('current-card');
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "CardView"){
            let lastCardNode;
            this.childNodes.forEach((child) => {
                if(child.name == "CardView"){
                    lastCardNode = child;
                }
            });
            if(lastCardNode){
                // insert after the last card
                lastCardNode.after(newView);
            } else {
                // since there are no cards
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/WindowView.js":
/*!****************************************!*\
  !*** ./js/objects/views/WindowView.js ***!
  \****************************************/
/*! exports provided: WindowView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindowView", function() { return WindowView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WindowView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WindowView
 * -------------------------------
 * I am the view of a Window Part.
 * Windows are wrappers for Stacks/StackViews that
 * appear as the subparts of other Stacks or Cards.
 * They are examples of how we can use stack and card
 * composition to create more complex UIs.
 */


const template = document.createElement('template');
template.innerHTML = `
<style>
 * {
     box-sizing: border-box;
 }

 .st-window-bar {
     display: flex;
     flex-direction: row;
     width: 100%;
     min-height: 25px;
     background-color: rgb(218, 218, 218);
     padding-left: 8px;
     padding-right: 8px;
     align-items: center;
 }
 .st-window-button {
     display: block;
     width: 12px;
     height: 12px;
     border-radius: 100%;
     background-color: rgba(255, 150, 150);
     margin-right: 4px;
 }
 .close-button {
     background-color: rgba(255, 50, 50, 0.4);
 }
 .shade-button {
     background-color: rgba(255, 255, 0. 0.4);
 }
 .expand-button {
     background-color: rgba(150, 255, 0, 0.8);
 }
 .st-window-pane {
     display: block;
     position: relative;
     min-height: 50px;
     flex: 1;
 }
 .st-window-pane.shaded {
     display: none;
 }
 .st-window-gripper {
     display: block;
     position: absolute;
     top: calc(100% - 15px);
     width: 30px;
     height: 30px;
 }
 .st-window-title {
     user-select: none;
     text-overflow: ellipsis;
     overflow: hidden;
     white-space: nowrap;
     max-width: 70%;
 }
 .right-gripper {
     left: calc(100% - 15px);
 }
 .right-gripper:hover {
     cursor: nwse-resize;
 }
 .left-gripper {
     right: calc(100% - 15px);
 }
 .left-gripper:hover {
     cursor: nesw-resize;
 }
</style>
<div class="st-window-bar">
    <div class="st-window-button close-button"></div>
    <div class="st-window-button shade-button"></div>
    <div class="st-window-button expand-button"></div>
    <div class="st-window-title">
        <span></span>
    </div>
</div>
<div class="st-window-pane">
    <slot></slot>
</div>
<div class="st-window-gripper right-gripper" data-grip-end="right"></div>
`;

class WindowView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        var templateContent = template.content.cloneNode(true);
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(templateContent);

        this.mouseDownInBar = false;
        this.isShaded = false;
        this.isExpanded = false;
        this.expandCache = {};

        // Whether or not we are gripping the
        // bottom right corner for a resize
        this.isGripping = false;

        // Bound methods
        this.setupClickAndDrag = this.setupClickAndDrag.bind(this);
        this.setupBarButtons = this.setupBarButtons.bind(this);
        this.setupExpanderAreas = this.setupExpanderAreas.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.onMouseMoveInBar = this.onMouseMoveInBar.bind(this);
        this.onMouseDownInBar = this.onMouseDownInBar.bind(this);
        this.onMouseUpAfterDrag = this.onMouseUpAfterDrag.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onShade = this.onShade.bind(this);
        this.onExpand = this.onExpand.bind(this);
        this.onGripDown = this.onGripDown.bind(this);
        this.onGripUp = this.onGripUp.bind(this);
        this.onGripMove = this.onGripMove.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('title', this.setTitle);
    }

    afterConnected(){
        this.setupClickAndDrag();
        this.setupBarButtons();
        this.setupExpanderAreas();
    }

    afterModelSet(){
        this.setTitle(
            this.model.partProperties.getPropertyNamed(
                this.model,
                'title'
            )
        );
    }

    setupClickAndDrag(){
        let bar = this._shadowRoot.querySelector('.st-window-bar');
        bar.addEventListener('mousedown', this.onMouseDownInBar);
    }

    setupBarButtons(){
        let closeButton = this._shadowRoot.querySelector('.close-button');
        let shadeButton = this._shadowRoot.querySelector('.shade-button');
        let expandButton = this._shadowRoot.querySelector('.expand-button');

        closeButton.addEventListener('click', this.onClose);
        shadeButton.addEventListener('click', this.onShade);
        expandButton.addEventListener('click', this.onExpand);
    }

    setupExpanderAreas(){
        let lowerRight = this._shadowRoot.querySelector('.right-gripper');
        lowerRight.addEventListener('mousedown', this.onGripDown);
    }

    onExpand(event){
        if(this.isExpanded){
            this.style.width = this.expandCache.width;
            this.style.height = this.expandCache.height;
            this.style.top = this.expandCache.top;
            this.style.left = this.expandCache.left;
            this.isExpanded = false;
        } else {
            this.expandCache = {
                width: this.style.width,
                height: this.style.height,
                top: this.style.top,
                left: this.style.left
            };
            // Set new values based on window size
            this.style.top = "0px";
            this.style.left = "0px";
            this.style.width = "100vw";
            this.style.height = "100vh";
            this.isExpanded = true;
        }
    }

    onShade(event){
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        if(this.isShaded){
            pane.classList.remove('shaded');
            this.isShaded = false;
        } else {
            pane.classList.add('shaded');
            this.isShaded = true;
        }
    }

    onClose(event){
        let msg = {
            type: 'command',
            commandName: 'windowClose',
            args: []
        };
        this.model.sendMessage(msg, this.model);
    }

    onMouseDownInBar(event){
        this.mouseDownInBar = true;
        let bar = event.target;
        document.addEventListener('mousemove', this.onMouseMoveInBar);
        document.addEventListener('mouseup', this.onMouseUpAfterDrag);
    }

    onMouseUpAfterDrag(event){
        this.mouseDownInBar = false;
        let bar = event.target;
        document.removeEventListener('mouseup', this.onMouseUpAfterDrag);
        document.removeEventListener('mousemove', this.onMouseMoveInBar);
    }

    onMouseMoveInBar(event){
        let currentTop = parseInt(this.style.top);
        let currentLeft = parseInt(this.style.left);
        // let newTop = `${currentTop + event.movementY}px`;
        // let newLeft = `${currentLeft + event.movementX}px`;
        let newTop = currentTop + event.movementY;
        let newLeft = currentLeft + event.movementX;
        this.model.partProperties.setPropertyNamed(this.model, "top", newTop);
        this.model.partProperties.setPropertyNamed(this.model, "left", newLeft);
    }

    onGripUp(event){
        this.isGripping = false;
        document.removeEventListener('mousemove', this.onGripMove);
        document.removeEventListener('mouseup', this.onGripUp);
    }

    onGripDown(event){
        this.isGripping = true;
        document.addEventListener('mousemove', this.onGripMove);
        document.addEventListener('mouseup', this.onGripUp);
    }

    onGripMove(event){
        if(this.isGripping){
            // Figure out the current width and height.
            // and set the property to the new one
            let box = this.getBoundingClientRect();
            let newWidth = Math.floor(box.width) + event.movementX;
            if(newWidth){
                this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
            }
            let newHeight = Math.floor(box.height) + event.movementY;
            if(newHeight){
                this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
            }
        }
    }

    setTitle(aString){
        let titleArea = this._shadowRoot.querySelector(
            '.st-window-title > span'
        );
        titleArea.innerText = aString;
    }

    // override subclass methods
    newSubpartView(newView){
        // slot the new view into the window pane
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        pane.append(newView);
        this.appendChild(newView);
    }


};




/***/ }),

/***/ "./js/objects/views/WorldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/WorldView.js ***!
  \***************************************/
/*! exports provided: WorldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldView", function() { return WorldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WorldView
 * ---------------------------------------------
 * I am a Webcomponent (custom element) that represents
 * a view of a WorldStack model.
 * My element children should contain a single StackView representing
 * the current displayed stack (this comes from the model).
 * I am the root-level element for the SimpleTalk system in a web
 * page. There should only be one of me on any given HTML page.
 */


const templateString = `<slot></slot>`;

class WorldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Set up templating and shadow dom
        // TODO: Put the template definition in this
        // module as formatted text
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // The world never wants a halo
        this.wantsHalo = false;

        // Bound methods
        this.updateCurrentStack = this.updateCurrentStack.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('current', this.updateCurrentStack);
    }

    afterConnected(){
        document.addEventListener('keydown', this.handleKeyDown);
    }

    afterDisconnected(){
        document.removeEventListener('keydown', this.handleKeyDown);
    }

    afterModelSet(){
        // Do an initial update to display
        // the model's current stack
        this.updateCurrentStack();
    }

    updateCurrentStack(){
        // The value of the current prop is the stack ID
        // of the child Stack that should be the
        // current one. We remove the current-stack class from
        // the previous current stack and add it to the new one.
        let currentStack = this.querySelector('.current-stack');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let nextCurrentStack = this.querySelector(`:scope > st-stack[part-id="${nextCurrentId}"]`);
        if(nextCurrentStack){
            nextCurrentStack.classList.add('current-stack');
        } else {
            return;
        }
        // To prevent the setting of the same id as the current stack make sure
        // next and current are not the same
        if(currentStack && currentStack != nextCurrentStack){
            currentStack.classList.remove('current-stack');
        }
    }

    handleKeyDown(event){
        if(event.altKey && event.ctrlKey && event.code == "Space"){
            let navigator = document.querySelector('st-navigator');
            navigator.toggle();
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "StackView"){
            let lastStackNode;
            this.childNodes.forEach((child) => {
                if(child.name == "StackView"){
                    lastStackNode = child;
                }
            });
            if(lastStackNode){
                // insert after the last stack
                lastStackNode.after(newView);
            } else {
                // since there are no stacks
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenu.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenu.js ***!
  \*****************************************************/
/*! exports provided: ContextMenu, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenu", function() { return ContextMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenu; });
/* harmony import */ var _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContextMenuItem.js */ "./js/objects/views/contextmenu/ContextMenuItem.js");
// PREAMBLE


window.customElements.define('st-context-menu-item', _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        border: 1px solid black;
        background-color: white;
        box-shadow: 1px 2px 10px rgba(50, 50, 50, 0.7);
        z-index: 10000;
        padding-bottom: 8px;
        min-width: 200px;
        font-family: 'Helvetica', sans-serif;
    }

    :host-context(li) {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host-context(li):hover {
        display: flex;
    }

    header {
        position: relative;
        display: flex;
        border-bottom: 1px solid rgba(150, 150, 150, 0.5);
        padding-right: 16px;
        padding-left: 16px;
        padding-top: 8px;
        padding-bottom: 8px;
    }

    header > h4 {
        padding: 0;
        margin:0;
    }

    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        font-size: 0.8rem;
    }

</style>
<header>
    <h4></h4>
</header>
<ul id="list-items">
    <slot></slot>
</ul>
`;

class ContextMenu extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.addHaloToggleItem = this.addHaloToggleItem.bind(this);
        this.addCopyAndPasteItems = this.addCopyAndPasteItems.bind(this);
        this.addOpenEditorItem = this.addOpenEditorItem.bind(this);
        this.addScriptEditItem = this.addScriptEditItem.bind(this);
        this.addMovementItems = this.addMovementItems.bind(this);
        this.addPartSubmenu = this.addPartSubmenu.bind(this);
        this.addListItem = this.addListItem.bind(this);
        this.addSpacer = this.addSpacer.bind(this);
        this.hideHeader = this.hideHeader.bind(this);
    }

    render(aModel){
        this.innerHTML = "";
        this.model = aModel;
        let headerEl = this._shadowRoot.querySelector('header > h4');
        let headerText = `${this.model.type[0].toUpperCase()}${this.model.type.slice(1)}`;
        headerText = `a ${headerText}`;
        headerEl.textContent = headerText;

        // Render the default menu items
        this.addHaloToggleItem();
        this.addCopyAndPasteItems();
        this.addOpenEditorItem();
        this.addPartSubmenu();
        this.addScriptEditItem();
        this.addMovementItems();

        // Add View-specific items
        let view = document.querySelector(`[part-id="${this.model.id}"]`);
        view.addContextMenuItems(this);
    }

    addListItem(label, callback, submenu=null){
        let itemEl = document.createElement('st-context-menu-item');
        itemEl.textContent = label;
        itemEl.classList.add('context-menu-item');
        itemEl.addEventListener('click', callback);
        if(submenu){             
            submenu.classList.add('context-submenu', 'submenu-hidden');
            submenu.setAttribute('slot', 'submenu');
            itemEl.append(submenu);
            itemEl.showCaret();
        }
        this.append(itemEl);
    }

    addHaloToggleItem(){
        let target = window.System.findViewById(this.model.id);
        // don't add halo option to cards, since you can't see those
        if(target.name != "CardView"){
            if(target.classList.contains('editing')){
                this.addListItem(
                    'Close Halo',
                    (event) => {
                        target.closeHalo();
                    }
                );
            } else {
                this.addListItem(
                    'Open Halo',
                    (event) => {
                        target.openHalo();
                    }
                );
            }
        }
    }

    addCopyAndPasteItems(){
        // Add copy item
        this.addListItem(
            'Copy',
            (event) => {
                window.System.clipboard.copyPart(this.model);
            }
        );

        // Add paste but only if:
        // 1. There is clipboard contents;
        // 2. The part type in the clipboard is
        //    one that is accepted by this model's part
        if(window.System.clipboard.contents.length){
            let partType = window.System.clipboard.contents[0].partType;
            if(this.model.acceptsSubpart(partType)){
                let label = `Paste (a ${partType[0].toUpperCase()}${partType.slice(1)})`;
                this.addListItem(label, (event) => {
                    window.System.clipboard.pasteContentsInto(this.model);
                });
            }
        }
    }

    addOpenEditorItem(){
        this.addListItem(
            'Open Editor',
            (event) => {
                window.System.openEditorForPart(this.model.id);
            }
        );
    }

    addScriptEditItem(){
        this.addListItem(
            'Edit Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: [this.model.id]
                }, this.model);
            }
        );

        this.addListItem(
            'Edit World Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: ['world']
                }, this.model);
            }
        );

        let windowAncestor = this.model.findAncestorOfType('window');
        if(this.model.type != 'window' && windowAncestor !== null){
            this.addListItem(
                'Edit Owning Window Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [windowAncestor.id]
                    }, this.model);
                }
            );
        }
        
        let cardAncestor = this.model.findAncestorOfType('card');
        if(this.model.type != 'card' && cardAncestor){
            this.addListItem(
                'Edit Owning Card Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [cardAncestor.id]
                    }, this.model);
                }
            );
        }

        let stackAncestor = this.model.findAncestorOfType('stack');
        if(this.model.type != 'stack' && stackAncestor){
            this.addListItem(
                'Edit Owning Stack Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [stackAncestor.id]
                    }, this.model);
                }
            );
        }
    }

    addPartSubmenu(){
        // First, we need to get a list of names
        // of subparts that this model accepts
        let subpartNames;
        if(this.model.acceptedSubpartTypes[0] == "*"){
            // This model accepts all subpart types.
            // We need to get the names for these subparts,
            // which are registered at the System level.
            subpartNames = Object.keys(window.System.availableViews);
        } else {
            subpartNames = this.model.acceptedSubpartTypes;
        }

        // If there are no subpart names (meaning
        // the given part, like a button, doesn't
        // accept any subparts), then we do nothing.
        if(subpartNames.length == 0){
            return;
        }

        // Now we construct the submenu for adding parts
        // of the given type
        let submenu = document.createElement('st-context-menu');
        submenu.hideHeader();
        subpartNames.forEach(subpartName => {
            submenu.addListItem(
                subpartName[0].toUpperCase() + subpartName.slice(1),
                () => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'newModel',
                        args: [
                            subpartName,
                            this.model.id
                        ]
                    }, this.model);
                }
            );
        });

        // Now add the list item that will "reveal"
        // the submenu
        this.addListItem(
            'Add a new part',
            null,
            submenu
        );
        
    }

    addMovementItems(){
        let index = this.model._owner.subparts.indexOf(this.model);
        let ownerLength = this.model._owner.subparts.length;
        if(ownerLength && index < ownerLength - 1){
            // Create the moveDown option
            this.addListItem(
                'Move Down',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveDown',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to Last',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToLast',
                        args: []
                    }, this.model);
                }
            );
        }
        if(index > 0){
            // Create the moveUp option
            this.addListItem(
                'Move Up',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveUp',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to First',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToFirst',
                        args: []
                    }, this.model);
                }
            );
        }
    }

    addSpacer(){
        let item = document.createElement('li');
        item.classList.add('context-menu-spacer');
        this.append(item);
    }

    hideHeader(){
        let headerEl = this._shadowRoot.querySelector('header');
        headerEl.style.display = "none";
    }
};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenuItem.js":
/*!*********************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenuItem.js ***!
  \*********************************************************/
/*! exports provided: ContextMenuItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenuItem", function() { return ContextMenuItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenuItem; });
const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
    }
    .submenu-area {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host(:hover) .submenu-area {
        display: flex;
    }

    .label-area {
        display: flex;
        align-items: center;
    }

    .caret.hidden {
        display: none;
    }
    .caret {
        display: block;
        margin-left: auto;
        font-size: 1.1em;
    }
</style>
<div class="label-area">
    <span class="label"><slot></slot></span>
    <div class="caret hidden">→</div>
</div>
<div class="submenu-area">
    <slot name="submenu"></slot>
</div>
`;

class ContextMenuItem extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.append(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.showCaret = this.showCaret.bind(this);
    }

    showCaret(){
        let caretEl = this._shadowRoot.querySelector('.caret');
        caretEl.classList.remove('hidden');
        
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/ColorPickerTool.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/drawing/ColorPickerTool.js ***!
  \*****************************************************/
/*! exports provided: ColorPickerTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPickerTool", function() { return ColorPickerTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorPickerTool; });
/* harmony import */ var _ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/**
 * ColorPickerTool
 * I provide a color choorser capability
 * for the shadow canvas of my parent element.
 * Brushes on my parent Drawing canvas will use
 * whatever color I have currently selected.
 * I am explicitly designed for use with
 * DrawingView*/

const colorPickerSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-color-swatch" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 3h-4a2 2 0 0 0 -2 2v12a4 4 0 0 0 8 0v-12a2 2 0 0 0 -2 -2" />
  <path d="M13 7.35l-2 -2a2 2 0 0 0 -2.828 0l-2.828 2.828a2 2 0 0 0 0 2.828l9 9" />
  <path d="M7.3 13h-2.3a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h12" />
  <line x1="17" y1="17" x2="17" y2="17.01" />
</svg>
`;

const colorPickerTemplateString = `
<style>
    :host {
        display: block;
        position: relative;
        margin-bottom: 6px;
    }

    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        position: relative;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
        width: 24px;
        height: 24px;
    }

    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    color-wheel {
        display: none;
        position: absolute;
    }

    :host([active="true"]) > color-wheel {
        display: flex;
    }
</style>
<div id="tool-button">
${colorPickerSVG}
</div>
<color-wheel></color-wheel>
`;


class ColorPickerTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can be
        // toggled within its parent DrawingView.
        this.template = document.createElement('template');
        this.template.innerHTML = colorPickerTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool
        // is connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.onColorSelected = this.onColorSelected.bind(this);
        this.onTransparencyChanged = this.onTransparencyChanged.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('current-color')){
                this.setAttribute('current-color', 'rgba(0, 0, 0, 0)');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.colorWheel = this.shadowRoot.querySelector('color-wheel');
            this.colorWheel.addEventListener('color-selected', this.onColorSelected);
            this.colorWheel.addEventListener('transparency-changed', this.onTransparencyChanged);
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.colorWheel.removeEventListener('color-selected', this.onColorSelected);
        this.colorWheel.removeEventListener('transparency-changed', this.onTransparencyChanged);
    }

    start(x, y){
        // Does nothing in this tool
    }

    end(x, y){
        // Does nothing in this tool
    }

    onMove(x, y){
        // Does nothing in this tool
    }

    setContextFromAttributes(){
        // Does nothing in this tool
    }

    onColorSelected(event){
        let colorInfo = event.detail;
        let colorStr = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
        this.ctx.strokeStyle = colorStr;
        this.ctx.fillStyle = colorStr;
    }

    onTransparencyChanged(event){
        this.parentElement.model.sendMessage({
            type: "command",
            commandName: "setProperty",
            args: ["transparency", event.detail]
        }, this.parentElement.model);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};



window.customElements.define('color-picker-tool', ColorPickerTool);




/***/ }),

/***/ "./js/objects/views/drawing/ColorWheelWidget.js":
/*!******************************************************!*\
  !*** ./js/objects/views/drawing/ColorWheelWidget.js ***!
  \******************************************************/
/*! exports provided: ColorWheelWidget, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorWheelWidget", function() { return ColorWheelWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorWheelWidget; });
/**
 * ColorWheelWidget
 * I am a *generic use* webcomponent representing
 * a ColorWheel selection widget.
 * I operate as a floating modal window with a
 * circular color wheel as well as a list of
 * recently selected colors.
 * I am designed to be used by any parent element.
 * I will trigger an event called 'color-change' whenever
 * a new color has been selected from within me
 */

const colorWheelTemplate = `
<style>
  :host {
    display: initial !important;
    visibility: visible !important;
    position: relative;
    flex-direction: column;
    align-items: center;
    box-sizing: border-box;
    background-color: white;
    border: 1px solid black;
  }

  #palette-bar {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    height: 20px;
    background-color: rgba(200, 200, 200);
    width: 100%;
    box-sizing: border-box;
  }

  #palette-title {
    width: 100%;
    text-align: center;
  }

  #close-button {
    display: block;
    width: 12px;
    height: 12px;
    margin-left: 8px;
    background-color: white;
    border: 1px solid black;
    text-align: center;
    font-size: 12px;
  }

  #palette-content {
    flex: 1;
    display: block;
    position: relative;
  }
  #hover-color {
    display: block;
    width: 100%;
    height: 25px;
  }
  #options {
    display: flex;
    width: 100%;
    height: 25px;
    margin-top: 5px;
    justify-content: center;
  }

  #options > label{
    font-size: .8rem;
    display: flex;
    align-items: center;
  }

  #recent-colors {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    padding-left: 15px;
    padding-right: 15px;
    box-sizing: border-box;
    list-style: none;
  }
  .recent-color-item {
    display: block;
    width: 26px;
    height: 26px;
    box-sizing: border-box;
    border: 1px solid rgba(200, 200, 200, 0.8);
  }

  .recent-color-item.selected {
    border: 2px solid black;
  }

</style>
<div id="palette-wrapper">
  <div id="palette-bar"><div id="close-button">x</div><span id="palette-title"></span></div>
  <div id="palette-content">
    <div id="options">
      <input type="range" id="transparency" name="transparency" min="0" max="1" step="0.1" value="1">
      <!-- <label for="transparency">Transparency</label>-->
    </div>
    <ul id="recent-colors">
      <li class="recent-color-item selected"></li>
      <li class="recent-color-item"></li>
      <li class="recent-color-item"></li>
    </ul>
    <canvas id="color-wheel" width="150" height="150"></canvas>
    <div id="hover-color"></div>
  </div>
</div>
`;

class ColorWheelWidget extends HTMLElement {
    constructor(name){
        super();

        this.name = name;

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = colorWheelTemplate;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind local methods
        this.onWheelMouseEnter = this.onWheelMouseEnter.bind(this);
        this.onWheelMouseLeave = this.onWheelMouseLeave.bind(this);
        this.onWheelMouseMove = this.onWheelMouseMove.bind(this);
        this.onWheelClick = this.onWheelClick.bind(this);
        this.onItemClick = this.onItemClick.bind(this);
        this.onBarMouseDown = this.onBarMouseDown.bind(this);
        this.onBarMouseUp = this.onBarMouseUp.bind(this);
        this.onBarMouseMove = this.onBarMouseMove.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onTransparencyChange = this.onTransparencyChange.bind(this);
        this._drawWheel = this._drawWheel.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.canvas = this.shadowRoot.querySelector('canvas');
            this.bar = this.shadowRoot.getElementById('palette-bar');
            // give the widget a title if provided
            if(this.name){
                this.shadowRoot.getElementById('palette-title').innerText = this.name;
            }

            // Set events
            this.canvas.addEventListener('click', this.onWheelClick);
            this.canvas.addEventListener('mouseenter', this.onWheelMouseEnter);
            this.bar.addEventListener('mousedown', this.onBarMouseDown);
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item')).forEach(el => {
                el.addEventListener('click', this.onItemClick);
            });
            this.transparencySlider = this.shadowRoot.getElementById('transparency');
            this.transparencySlider.addEventListener("input", this.onTransparencyChange);

            // Draw the color wheel to the canvas
            this._drawWheel();
        }
    }

    disconnectedCallback(){
        this.canvas.removeEventListener('click', this.onWheelClick);
        this.canvas.removeEventListener('mouseenter', this.onWheelMouseEnter);
        this.bar.removeEventListener('mousedown', this.onBarMouseDown);
        Array.from(this.shadowRoot.querySelector('.recent-color-item')).forEach(el => {
            el.removeEventListener('click', this.onItemClick);
        });
        this.transparencySlider.removeEventListener("change", this.onTransparencyChange);
    }


    onWheelMouseEnter(event){
        // Cache the image data for the whole canvas
        let ctx = this.canvas.getContext('2d');
        this._cachedImageData = ctx.getImageData(
            0,
            0,
            this.canvas.width,
            this.canvas.height
        );
        // Bind subsequent events
        this.canvas.addEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.addEventListener('mouseleave', this.onWheelMouseLeave);
    }

    onWheelMouseLeave(event){
        this.canvas.removeEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.removeEventListener('mouseleave', this.onWheelMouseLeave);
        this._cachedImageData = null;
    }

    onWheelMouseMove(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let hoverColorArea = this.shadowRoot.getElementById('hover-color');
        let newStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;
        hoverColorArea.style.backgroundColor = newStyle;
    }

    onWheelClick(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let colorInfo = {
            r: rgb[0],
            g: rgb[1],
            b: rgb[2],
            alpha: rgb[3]
        };
        let newEvent = new CustomEvent('color-selected', {
            detail: colorInfo
        });
        this.selectedColor = colorInfo;
        this.dispatchEvent(newEvent);

        // Update the recent color swatches
        let currentSwatchSelection = this.shadowRoot.querySelector('.recent-color-item.selected');
        if(currentSwatchSelection){
            currentSwatchSelection.style.backgroundColor = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
            currentSwatchSelection.selectedColor = colorInfo;
        }
    }

    onTransparencyChange(event){
        let command = this.getAttribute("selector-command");
        // update the corresponding transparency - text or background
        // depending on what this color wheel is setup to update
        let propName = "background-transparency";
        if(command === "text-color"){
            propName = "text-transparency";
        }
        let eventDetail = {propName: propName, value: event.target.value};
        let newEvent = new CustomEvent('transparency-changed', {
            detail: eventDetail,
        });
        this.dispatchEvent(newEvent);
    }

    onItemClick(event){
        // If this element is not the currently
        // selected recent item, find the one that is
        // and toggle the selection class, then toggle
        // this item's selection class.
        if(!event.target.classList.contains('selected')){
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item.selected')).forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        if(event.target.selectedColor){
            let newEvent = new CustomEvent('color-selected', {
                detail: event.target.selectedColor
            });
            this.dispatchEvent(newEvent);
        }
    }

    onBarMouseDown(event){
        document.addEventListener('mousemove', this.onBarMouseMove);
        document.addEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseUp(event){
        document.removeEventListener('mousemove', this.onBarMouseMove);
        document.removeEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseMove(event){
        let newTop = this.offsetTop + event.movementY;
        let newLeft = this.offsetLeft + event.movementX;
        this.style.top = `${newTop}px`;
        this.style.left = `${newLeft}px`;
    }

    onClose(event){
        this.remove();
    }

    _drawWheel(){
        let ctx = this.canvas.getContext('2d');
        drawCircle(ctx, this.canvas.width / 2);
    }
};

window.customElements.define('color-wheel', ColorWheelWidget);

/** Utility Functions **/

// This function is adapted from
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const drawCircle = (ctx, radius) => {
    let image = ctx.createImageData(2*radius, 2*radius);
    let data = image.data;

    for (let x = -radius; x < radius; x++) {
        for (let y = -radius; y < radius; y++) {

            let [r, phi] = xy2polar(x, y);

            if (r > radius) {
                // skip all (x,y) coordinates that are outside of the circle
                continue;
            }

            let deg = rad2deg(phi);

            // Figure out the starting index of this pixel in the image data array.
            let rowLength = 2*radius;
            let adjustedX = x + radius; // convert x from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let adjustedY = y + radius; // convert y from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let pixelWidth = 4; // each pixel requires 4 slots in the data array
            let index = (adjustedX + (adjustedY * rowLength)) * pixelWidth;

            let hue = deg;
            let saturation = r / radius;
            let value = 1.0;

            let [red, green, blue] = hsv2rgb(hue, saturation, value);
            let alpha = 255;

            data[index] = red;
            data[index+1] = green;
            data[index+2] = blue;
            data[index+3] = alpha;
        }
    }

    ctx.putImageData(image, 0, 0);
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const xy2polar = (x, y) => {
    let r = Math.sqrt(x*x + y*y);
    let phi = Math.atan2(y, x);
    return [r, phi];
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43s
const rad2deg = (rad) => {
    return ((rad + Math.PI) / (2 * Math.PI)) * 360;
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const hsv2rgb = (hue, saturation, value) => {
    let chroma = value * saturation;
    let hue1 = hue / 60;
    let x = chroma * (1- Math.abs((hue1 % 2) - 1));
    let r1, g1, b1;
    if (hue1 >= 0 && hue1 <= 1) {
        ([r1, g1, b1] = [chroma, x, 0]);
    } else if (hue1 >= 1 && hue1 <= 2) {
        ([r1, g1, b1] = [x, chroma, 0]);
    } else if (hue1 >= 2 && hue1 <= 3) {
        ([r1, g1, b1] = [0, chroma, x]);
    } else if (hue1 >= 3 && hue1 <= 4) {
        ([r1, g1, b1] = [0, x, chroma]);
    } else if (hue1 >= 4 && hue1 <= 5) {
        ([r1, g1, b1] = [x, 0, chroma]);
    } else if (hue1 >= 5 && hue1 <= 6) {
        ([r1, g1, b1] = [chroma, 0, x]);
    }

    let m = value - chroma;
    let [r,g,b] = [r1+m, g1+m, b1+m];

    // Change r,g,b values from [0,1] to [0,255]
    return [255*r,255*g,255*b];
};

const getPositionFromEvent = (event) => {
    let target = event.target;
    let offsetX = target.offsetLeft;
    let offsetY = target.offsetTop;
    let check = target.offsetParent;
    while(check){
        offsetX += check.offsetLeft;
        offsetY += check.offsetTop;
        check = check.offsetParent;
    }
    let result = {
        x: event.clientX - offsetX,
        y: event.clientY - offsetY
    };
    return result;
};

const getRGBFromImageData = (x, y, width, data) => {
    let index = (y * width + x) * 4;
    return [
        data[index], // r
        data[index + 1], // g
        data[index + 2], // b
        data[index + 3] // alpha
    ];
};




/***/ }),

/***/ "./js/objects/views/drawing/DrawingView.js":
/*!*************************************************!*\
  !*** ./js/objects/views/drawing/DrawingView.js ***!
  \*************************************************/
/*! exports provided: DrawingView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawingView", function() { return DrawingView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DrawingView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _PencilTool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PencilTool.js */ "./js/objects/views/drawing/PencilTool.js");
/* harmony import */ var _EraserTool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EraserTool.js */ "./js/objects/views/drawing/EraserTool.js");
/* harmony import */ var _ColorPickerTool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ColorPickerTool.js */ "./js/objects/views/drawing/ColorPickerTool.js");
/**
 * DrawingView
 * Experimental.
 * This is still a pure webcomponent and is not
 * linked at all to SimpleTalk yet.
 *
 */





const haloButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tool" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 10h3v-3l-3.5 -3.5a6 6 0 0 1 8 8l6 6a2 2 0 0 1 -3 3l-6-6a6 6 0 0 1 -8 -8l3.5 3.5" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: inline-block;
        position: relative;
        box-sizing: border-box;
    }
    #tool-buttons {
        position: absolute;
        left: calc(100% + 5px);
        top: 0px;
        display: flex;
        flex-direction: column;
    }
    :host(.show-border){
        border: 1px solid black;
    }
    :host(:not([mode="drawing"])) > #tool-buttons {
        display: none;
    }
</style>
<canvas></canvas >
<div id="tool-buttons">
<slot></slot>
</div>
`;

class DrawingView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["PartView"] {
    constructor(){
        super();

        // Setup shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        this.colorPickerTool = null;

        this.isCurrentlyDrawing = false;

        // Bind component methods
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.toggleMode = this.toggleMode.bind(this);
        this.afterDrawAction = this.afterDrawAction.bind(this);
        this.restoreImageFromModel = this.restoreImageFromModel.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.modeChanged = this.modeChanged.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('mode', this.modeChanged);
        this.onPropChange('image', () => {
            let imageBits = this.model.partProperties.getPropertyNamed(
                this.model,
                'image'
            );
            this.restoreImageFromModel(imageBits);
        });
        this.onPropChange('show-border', (val) => {
            if(val){
                this.classList.add('show-border');
            } else {
                this.classList.remove('show-border');
            }
        });
        this.onPropChange('width', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("width", cssStyle.width);
        });
        this.onPropChange('height', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("height", cssStyle.height);
        });
    }

    modeChanged(value){
        this.setAttribute('mode', value);
    }

    afterConnected(){
        this.canvas = this.shadow.querySelector('canvas');
        this.canvas.addEventListener('mouseup', this.onMouseUp);
        this.canvas.addEventListener('mousedown', this.onMouseDown);

        // Set and store the drawing context
        this.drawingContext = this.canvas.getContext('2d');

        // If I don't have the default tools, add
        // them as real dom children now
        let pencilChild = this.querySelector('pencil-tool');
        if(!pencilChild){
            let newPencil = document.createElement('pencil-tool');
            this.append(newPencil);
        }
        let eraserChild = this.querySelector('eraser-tool');
        if(!eraserChild){
            let newEraser = document.createElement('eraser-tool');
            this.append(newEraser);
        }

        let colorPickerChild = this.querySelector('color-picker-tool');
        if(!colorPickerChild){
            let newColorPicker = document.createElement('color-picker-tool');
            // TODO this is a total hack since drawing does not work well with styles at the moment
            this.append(newColorPicker);
            newColorPicker.colorWheel.shadowRoot.querySelector('div#options').style.display = "none";
            this.colorPickerTool = newColorPicker;
        }

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
        this.canvas.removeEventListener('mouseup', this.onMouseUp);
        this.canvas.removeEventListener('mousedown', this.onMouseDown);
    }

    afterModelSet(){
        // setup the canvas height and width
        // Note: what we want is the calculated CSS, not the ST part property value
        let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
        let canvas = this.shadow.querySelector('canvas');
        canvas.setAttribute("height", cssStyle.height);
        canvas.setAttribute("width", cssStyle.width);
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        if(currentImage){
            this.restoreImageFromModel(currentImage);
        }

        let initialShowBorder = this.model.partProperties.getPropertyNamed(
            this.model,
            'show-border'
        );
        if(initialShowBorder){
            this.classList.add('show-border');
        }
    }

    onMouseDown(event){
        if(event.shiftKey){
            return;
        } else if(!this.inDrawingMode) {
            // Send the mouseUp command message to self
            this.model.sendMessage({
                type: 'command',
                commandName: 'mouseUp',
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            }, this.model);
        }
        this.activeTool = this.querySelector('[role="tool"][active="true"]');
        if(!this.activeTool){
            return;
        }
        this.isCurrentlyDrawing = true;
        let canvas = this.shadow.querySelector('canvas');
        canvas.addEventListener('mousemove', this.onMouseMove);
        canvas.addEventListener('mouseleave', this.onMouseLeave);
        this.activeTool.start(event.offsetX, event.offsetY);
    }

    onMouseMove(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode){
            this.activeTool.onMove(
                event.offsetX,
                event.offsetY
            );
        } else if(this.model.partProperties.getPropertyNamed(this.model, "wants-move")){
            this.sendMessage({
                type: 'command',
                commandName: 'move',
                args: [event.movementX, event.movementY]
            }, this.model);
        }
    }

    onMouseUp(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode && this.isCurrentlyDrawing){
            this.activeTool.end(event.offsetX, event.offsetY);
            this.afterDrawAction();
        }
        this.isCurrentlyDrawing = false;
        let canvas = this.shadow.querySelector('canvas');
        canvas.removeEventListener('mousemove', this.onMouseMove);
        canvas.removeEventListener('mouseleave', this.onMouseLeave);
    }


    onMouseLeave(event){
        // If this is triggered, we left the area
        // while drawing. So call the activeTool's
        // end method
        this.activeTool.end(
            event.offsetX,
            event.offsetY
        );
        this.isCurrentlyDrawing = false;
        this.afterDrawAction();
        this.canvas.removeEventListener('mouseleave', this.onMouseLeave);
        this.canvas.removeEventListener('mousemove', this.onMouseMove);
    }

    onHaloResize(movementX, movementY){
        let canvas = this.shadowRoot.querySelector('canvas');
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        // canvas.width = canvas.width + movementX;
        // canvas.height = canvas.height + movementY;
        let newWidth = canvas.width + movementX;
        let newHeight = canvas.height + movementY;
        if(newWidth && newHeight){
            // this.style.width = `${newWidth}px`;
            // this.style.height = `${newHeight}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth,
                true
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight,
                true
            );
        }
        this.restoreImageFromModel(currentImage);
    }

    afterDrawAction(){
        // Encode canvas contents as base64 png
        // and set to model's image property
        let canvas = this.shadowRoot.querySelector('canvas');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'image',
            canvas.toDataURL()
        );
        //this.setAttribute("mode", "");
    }

    restoreImageFromModel(base64ImageData){
        // Clear and draw the image to restore to
        // the canvas
        if(base64ImageData){
            let canvas = this.shadowRoot.querySelector('canvas');
            let context = canvas.getContext('2d');
            let img = new Image();
            img.onload = function(){
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(img, 0, 0);
            };
            img.src = base64ImageData;

            // Set the border to hide
            this.model.partProperties.setPropertyNamed(
                this.model,
                'show-border',
                false
            );
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = "halo-drawing-toggle-mode";
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = haloButtonSVG;
        this.haloButton.style.marginRight = "6px";
        this.haloButton.setAttribute('slot', 'bottom-row');
        this.haloButton.setAttribute('title', 'Toggle drawing tools');
        this.haloButton.addEventListener('click', this.toggleMode);
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    toggleMode(){
        let currentMode = this.getAttribute('mode');
        let nextMode = 'viewing'; // By default, set to viewing
        let isEmpty = (!currentMode || currentMode == undefined || currentMode == "");
        if(currentMode == 'viewing' || isEmpty){
            nextMode = 'drawing';
        }
        this.model.partProperties.setPropertyNamed(
            this.model,
            'mode',
            nextMode
        );
    }

    get inDrawingMode(){
        if(!this.model){
            return false;
        }
        let mode = this.getAttribute('mode');
        if(mode == 'drawing'){
            return true;
        }
        return false;
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/EraserTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/EraserTool.js ***!
  \************************************************/
/*! exports provided: EraserTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EraserTool", function() { return EraserTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EraserTool; });
/**
 * EraserTool
 * -----------------------------------
 * I provide eraser-like functionality on
 * my parent element's shadow canvas.
 * I am specifically designed for use as a
 * child of DrawingView
 */
const eraserSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-eraser" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 19h-11l-4 -4a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9 9" />
  <line x1="18" y1="12.3" x2="11.7" y2="6" />
</svg>
`;

const eraserToolTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${eraserSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class EraserTool extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = eraserToolTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool is
        // connected to a parent element that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
                this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.cachedStrokeStyle = this.ctx.strokeStyle;
        this.ctx.strokeStyle = 'red';
        this.ctx.globalCompositeOperation = 'destination-out';
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.strokeStyle = this.cachedStrokeStyle;
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};
window.customElements.define('eraser-tool', EraserTool);




/***/ }),

/***/ "./js/objects/views/drawing/PencilTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/PencilTool.js ***!
  \************************************************/
/*! exports provided: PencilTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PencilTool", function() { return PencilTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PencilTool; });
/**
 * PencilTool
 * --------------------------
 * I provide pencil-like drawing capability
 * on the shadow canvas of my parent element.
 * I am explicitly designed for use with
 * DrawingView
 */
const pencilSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
  <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
</svg>
`;

const pencilTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${pencilSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class PencilTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = pencilTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context
        // is null. This will be set
        // if and when this tool is
        // connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
            this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};

window.customElements.define('pencil-tool', PencilTool);




/***/ }),

/***/ "./js/objects/views/editors/Editor.js":
/*!********************************************!*\
  !*** ./js/objects/views/editors/Editor.js ***!
  \********************************************/
/*! exports provided: Editor, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Editor; });
/* harmony import */ var _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorTab.js */ "./js/objects/views/editors/EditorTab.js");
/* harmony import */ var _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditorPropList.js */ "./js/objects/views/editors/EditorPropList.js");
/* harmony import */ var _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditorMessenger.js */ "./js/objects/views/editors/EditorMessenger.js");
/* harmony import */ var _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditorCustomList.js */ "./js/objects/views/editors/EditorCustomList.js");
/* harmony import */ var _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditorSubpartsPane.js */ "./js/objects/views/editors/EditorSubpartsPane.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");






// PREAMBLE

// Add editor tab element
window.customElements.define('editor-tab', _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
window.customElements.define('editor-props-list', _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
window.customElements.define('editor-custom-list', _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('editor-messenger', _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('editor-subparts', _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

const closeButton = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
</svg>
`;

const scriptIcon = `
<svg id='script' xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-file-code" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M14 3v4a1 1 0 0 0 1 1h4" />
    <path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" />
    <path d="M10 13l-1 2l1 2" />
    <path d="M14 13l1 2l-1 2" />
</svg>`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        transform: translateX(-105%);
        transition: transform 150ms linear;
        width: 400px;
        height: 100%;
        background-color: white;
        padding: 8px;
        border-right: 1px solid rgba(0, 0, 0, 0.5);
        box-shadow: 0px 1px 10px 2px rgba(0, 0, 0, 0.3);
    }
    
    :host(.open){
        transform: translateX(0%);
        transition: transform 150ms linear;
        z-index: 100;
    }

    :host(::after) {
        content: " ";
        height: 100%;
        width: 5px;
        background-color: black;
        display: block;
        position: absolute;
        top: 0;
        right: -10;
        box-shadow: 0px 0px 3px 10px rgba(100, 100, 100, 0.6);
    }

    ::slotted(editor-props-list:not(.show-pane)),
    ::slotted(editor-messenger:not(.show-pane)),
    ::slotted(editor-custom-list:not(.show-pane)),
    ::slotted(editor-subparts:not(.show-pane)){
        display: none;
    }

    #tab-area {
        display: inline-flex;
        align-items: center;
        justify-content: space-around;
        width: 100%;
    }
    
    #pane-area {
        display: block;
        flex: 1;
        margin-top: 20px;
        overflow: hidden;
    }

    #header-area {
        display: flex;
        font-family: 'Helvetica', sans-serif;
        margin-bottom: 20px;
    }

    .header-side {
        flex: 1;
        margin-top: 20px;
    }

    #display-area {
        display: flex;
        align-items: center;
        margin-bottom: 30px;
    }

    #header-area h3 {
        display: inline-block;
        margin: 0;
        margin-right: 8px;
        margin-left: 5px;
        font-size: 1.7rem;
    }

    #header-left > input {
        display: inline-block;
        padding: 4px;
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.8);
        font-size: 1.1rem;
    }

    #header-right > button {
        width: 100%;
        background-color: transparent;
        border: 1px solid transparent;
        outline: none;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        font-size: 0.85em;
    }

    #header-right > button:hover {
        cursor: pointer;
        border: 1px solid rgba(150, 150, 150, 0.3);
    }

    #header-right > button:active {
        border: 1px solid rgba(150, 150, 150, 0.8);
        background-color: rgba(220, 220, 220);
    }

    #header-right > button > svg {
        height: 1.3em;
        width: auto;
        margin-right: 8px;
    }

    #header-left {
        max-width: 80%;
    }

    #header-left span {
        font-family: monospace;
        font-size: 1.1rem;
        color: rgba(0, 0, 0, 0.5);
        text-overflow: ellipsis;
        overflow: hidden;
    }

    #icon-display-area {
        width: 1.7rem;
        height: 1.7rem;
        margin-bottom: 5px;
    }
    #icon-display-area > svg {
        width: 100%;
        height: 100%;
    }

    #close-button {
        display: block;
        position: absolute;
        top: 5;
        right: 5;
    }
    #close-button:hover {
        cursor: pointer;
    }
</style>
<div id="close-button">${closeButton}</div>
<div id="header-area">
    <div id="header-left" class="header-side">
        <div id="display-area">
            <div id="icon-display-area"></div>
            <h3></h3><span></span>
        </div>
        <input type="text" id="part-name-input"/>
    </div>
    <div id="header-right" class="header-side">
        <button id="edit-script-button">
            ${scriptIcon}
            <span>Edit Script</span>
        </button>
    </div>
</div>
<div id="tab-area">
    <editor-tab active="true" name="properties">Properties</editor-tab>
    <editor-tab name="custom">Custom</editor-tab>
    <editor-tab name="messenger">Messenger</editor-tab>
    <editor-tab name="subparts">Subparts</editor-tab>
</div>
<div id="pane-area">
    <slot></slot>
</div>
`;

class Editor extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.render = this.render.bind(this);
        this.centerOnElement = this.centerOnElement.bind(this);
        this.undoCenterOnElement = this.undoCenterOnElement.bind(this);
        this.updateHeader = this.updateHeader.bind(this);
        this.checkForNavigation = this.checkForNavigation.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.onTabActivated = this.onTabActivated.bind(this);
        this.onNameInputChange = this.onNameInputChange.bind(this);
        this.onEditScriptClick = this.onEditScriptClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this._shadowRoot.addEventListener('tab-activated', this.onTabActivated);
            this._shadowRoot.getElementById('close-button').addEventListener(
                'click',
                this.close
            );

            // Events
            let nameInput = this._shadowRoot.getElementById('part-name-input');
            nameInput.addEventListener('change', this.onNameInputChange);

            let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
            editScriptButton.addEventListener('click', this.onEditScriptClick);
        }
    }

    disconnectedCallback(){
        this._shadowRoot.removeEventListener('tab-activated', this.onTabActivated);
        this._shadowRoot.getElementById('close-button').removeEventListener(
            'click',
            this.close
        );
        
        // Events
        let nameInput = this._shadowRoot.getElementById('part-name-input');
        nameInput.removeEventListener('change', this.onNameInputChange);

        let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
        editScriptButton.removeEventListener('click', this.onEditScriptClick);
    }

    toggle(){
        if(this.isOpen){
            this.close();
        } else {
            this.open();
        }
    }

    open(){
        this.classList.add('open');
        this.centerOnElement();
    }

    close(){
        this.classList.remove('open');
        this.undoCenterOnElement();
    }

    render(aModel){
        if(this.model){
            this.model.removePropertySubscriber(this);
        }
        this.model = aModel;
        this.model.addPropertySubscriber(this);

        // If the incoming model is a Card or
        // Stack that is not the current one,
        // we navigate to it
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.checkForNavigation();
        }

        // Close any open Halos.
        // If the new model wants a Halo,
        // open it on the View for that Model.
        Array.from(document.querySelectorAll(`.editing`)).forEach(el => {
            el.closeHalo();
        });
        let targetView = document.querySelector(`[part-id="${this.model.id}"]`);
        if(targetView && targetView.wantsHalo){
            targetView.openHalo();
        }
        
        this.updateHeader();

        // Clear slotted inner DOM
        this.innerHTML = "";

        // Add panes
        let propsPane = document.createElement('editor-props-list');
        propsPane.setAttribute('tab-name', 'properties');
        this.appendChild(propsPane);
        propsPane.render(this.model);

        let messengerPane = document.createElement('editor-messenger');
        messengerPane.setAttribute('tab-name', 'messenger');
        this.appendChild(messengerPane);
        messengerPane.render(this.model);

        let customPane = document.createElement('editor-custom-list');
        customPane.setAttribute('tab-name', 'custom');
        this.appendChild(customPane);
        customPane.render(this.model);

        let subpartsPane = document.createElement('editor-subparts');
        subpartsPane.setAttribute('tab-name', 'subparts');
        this.appendChild(subpartsPane);
        subpartsPane.render(this.model);

        // Find the active tab and show its corresponding pane
        let activeTab = this._shadowRoot.querySelector(`editor-tab[active="true"]`);
        if(activeTab){
            let activeName = activeTab.getAttribute('name');
            Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
                let name = pane.getAttribute('tab-name');
                if(name == activeName){
                    pane.classList.add('show-pane');
                } else {
                    pane.classList.remove('show-pane');
                }
            });
        }

        // If this pane is already open, then center
        // on the primary view element for the model
        if(this.isOpen){
            this.centerOnElement();
        }
    }

    centerOnElement(){
        // Use CSS transforms of the whole World to center on
        // the primary view element of the Part being edited,
        // if set. If not set, do nothing.
        if(this.model){
            // If we are editing a Card, Stack, or World, then
            // we uncenter and return
            let isCardStackOrWorld = ['card', 'stack', 'world'].includes(this.model.type);
            if(isCardStackOrWorld){
                return this.undoCenterOnElement();
            }
            
            let partView = window.System.findViewById(this.model.id);
            let worldView = window.System.findViewById('world');
            let current = worldView.getAttribute('centered-on');
            if(current == this.model.id.toString()){
                return;
            }

            let menuRect = this.getBoundingClientRect();
            let partRect = partView.getBoundingClientRect();

            // Get the actual viewable width, plus the editor menu
            let viewWidth = window.innerWidth + menuRect.width;
            let viewHeight = window.innerWidth - menuRect.height;

            // Calculate X translation
            let targetX = (viewWidth - partRect.width) / 2;
            let newX;
            if(targetX < partRect.left){
                newX = (partRect.left - targetX) * -1;
            } else {
                newX = targetX - partRect.left;
            }

            // Calculate Y translation
            let targetY = (viewHeight - partRect.height) / 2;
            let newY;
            if(targetY < partRect.top){
                newY = (partRect.top - targetY) * -1;
            } else {
                newY = targetY - partRect.top;
            }

            worldView.setAttribute('centered-on', this.model.id);
            
            // Set transform and transition
            worldView.style.transition = "transform 0.3s ease-out";
            worldView.style.transform = `translate(${newX}px, ${newY}px)`;
        }
    }

    undoCenterOnElement(){
        let worldView = window.System.findViewById('world');
        worldView.removeAttribute('centered-on');
        worldView.style.removeProperty('transform');
    }

    updateHeader(){
        let nameInput = this._shadowRoot.querySelector('#header-left > input');
        let typeDisplay = this._shadowRoot.querySelector('#display-area > h3');
        let idDisplay = this._shadowRoot.querySelector('#display-area > span');
        let iconDisplay = this._shadowRoot.getElementById('icon-display-area');

        let partName = this.model.partProperties.getPropertyNamed(
            this.model,
            'name'
        );

        if(partName && partName !== ""){
            nameInput.value = partName;
        } else {
            nameInput.value = "(Unnamed)";
        }

        typeDisplay.textContent = this.model.type.charAt(0).toUpperCase() + this.model.type.slice(1);
        idDisplay.textContent = `id=${this.model.id}`;
        idDisplay.title = this.model.id;

        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"]).includes(this.model.type)){
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"][this.model.type];
        } else {
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"].generic;
        }
    }

    checkForNavigation(){
        // If the model is a Card or Stack that
        // is not the current (ie, not being displayed
        // in the main window), then we should navigate
        // to it
        let currentStack = window.System.world.currentStack;
        let currentCard = currentStack.currentCard;
        if(this.model.type == 'card' && this.model.id != currentCard.id){
            currentStack.goToCardById(this.model.id);
        } else if(this.model.type == 'stack' && this.model.id != currentStack.id){
            window.System.world.goToStackById(this.model.id);
        }
        
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            // Find any nested editor-prop-item elements
            // and re-render, so they display the correct
            // values in the editor
            let queryString = `editor-prop-item[name="${aMessage.propertyName}"][owner-id="${aMessage.partId}"]`;
            Array.from(this.querySelectorAll(queryString)).forEach(el => {
                if(el.property.value !== aMessage.value){
                    el.render();
                }
            });
            break;
        }
    }

    onTabActivated(event){
        Array.from(this._shadowRoot.querySelectorAll('editor-tab'))
            .filter(tabEl => {
                return tabEl !== event.target;
            }).forEach(tabEl => {
                tabEl.removeAttribute('active');
            });

        // Get the name of the activated tab
        let targetName = event.target.getAttribute('name');
        Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
            let name = pane.getAttribute('tab-name');
            if(name == targetName){
                pane.classList.add('show-pane');
            } else {
                pane.classList.remove('show-pane');
            }
        });
    }

    onNameInputChange(event){
        if(this.model){
            let newName = event.target.value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'name',
                newName
            );
        }
    }

    onEditScriptClick(event){
        if(this.model){
            this.model.sendMessage({
                type: 'command',
                commandName: 'openScriptEditor',
                args: [
                    this.model.id
                ]
            }, this.model);
            this.close();
        }
    }

    get isOpen(){
        return this.classList.contains('open');
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorCustomList.js":
/*!******************************************************!*\
  !*** ./js/objects/views/editors/EditorCustomList.js ***!
  \******************************************************/
/*! exports provided: EditorCustomList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorCustomList", function() { return EditorCustomList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorCustomList; });


// PREAMBLE

const caretDownIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(180 12 12)" />
</svg>
`;

const caretRightIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(90 12 12)" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
    
    #new-prop-area {
        display: flex;
        flex-direction: column;
        width: 100%;
    }

    #new-prop-area.open > #new-prop-form {
        display:flex;
    }

    #new-prop-form {
        display: none;
        flex-direction: column;
        width: 100%;
    }

    .row {
        display: flex;
        flex-direction: row;
        width: 100%;
        align-items: center;
        margin-bottom: 1em;
    }

    h3 {
        padding: 0px;
        margin-bottom: 1em;
    }

    #new-prop-form > .row > * {
        margin-right: 16px;
        padding-left: 8px;
        padding-right: 8px;
    }
    #new-prop-form input {
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.7);
        font-family: monospace;
        padding: 6px;
    }

    #new-prop-name:invalid {
        border-bottom: 1px solid red;
    }
    
    select {
        font-size: 1em;
    }
    #add-prop-dropdown-control {
        align-items: center;
        user-select: none;
    }

    #add-prop-dropdown-control:hover,
    #add-prop-dropdown-control label {
        cursor: pointer;
    }

    #caret-button {
        position: relative;
        width: 1.5em;
        height: 1.5em;
        transform: rotate(0deg);
        transition: transform 0.1s linear;
    }

    #caret-button > svg {
        width: 100%;
        height: 100%;
    }
    #new-prop-area.open #caret-button {
        transform: rotate(90deg);
        transition: transform 0.1s linear;
    }

</style>
<div id="new-prop-area">
    <div class="row" id="add-prop-dropdown-control">
        <h3><label for="caret-button">Add New Property</label></h3>
        <div id="caret-button">${caretRightIcon}</div>
    </div>
    <div id="new-prop-form">
        <div class="row">
            <label for="new-prop-name">Property Name </label>
            <input type="text" id="new-prop-name" placeholder="property-name" pattern="[a-z\\-]{3,64}"/>
        </div>
        <div class="row">
            <label for="default-val-select">Default value type</label>
            <select id="default-val-select">
                <option value="" selected>None</option>
                <option value="string">Text</option>
                <option value="number">Number</option>
                <option value="boolean">True or False</option>
            </select>
        </div>
        <div class="row">
            <label for="default-value">Default value </label>
            <input type="text" id="default-value" placeholder="Default value" disabled/>
        </div>
        <div class="row" id="submit-control">
            <button id="submit-prop">Create</button>
        </div>
    </div>
</div>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

class EditorCustomList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.resetForm = this.resetForm.bind(this);
        this.onDefaultNewTypeChange = this.onDefaultNewTypeChange.bind(this);
        this.onCaretClick = this.onCaretClick.bind(this);
        this.onCreateSubmit = this.onCreateSubmit.bind(this);
        this.onFilterInput = this.onFilterInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.newPropTypeSelect = this._shadowRoot.getElementById('default-val-select');
            this.newPropNameInput = this._shadowRoot.getElementById('new-prop-name');
            this.newPropDefaultValue = this._shadowRoot.getElementById('default-value');
            this.addPropControl = this._shadowRoot.getElementById('add-prop-dropdown-control');
            this.newPropForm = this._shadowRoot.getElementById('new-prop-form');
            this.createButton = this._shadowRoot.getElementById('submit-prop');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.filterInput = this._shadowRoot.getElementById('filter-input');
            
            // Add listeners
            this.addPropControl.addEventListener('click', this.onCaretClick);
            this.createButton.addEventListener('click', this.onCreateSubmit);
            this.filterInput.addEventListener('input', this.onFilterInput);
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any main dom children
        this.innerHTML = "";

        // Create a sorted copy of the property
        // objects
        let customProps = this.model.partProperties.getPropertyNamed(
            this.model,
            'custom-properties'
        );

        // Create a sorted list of the custom properties
        // available
        this.propList = Object.values(customProps)
            .sort((first, second) => {
                return first.name.localeCompare(second.name);
            });

        // Render the property items and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });

        // Set up event listeners
        this.newPropTypeSelect.removeEventListener('change', this.onDefaultNewTypeChange);
        this.newPropTypeSelect.addEventListener('change', this.onDefaultNewTypeChange);
    }

    onDefaultNewTypeChange(event){
        let option = event.target.selectedOptions[0];
        switch(option.value){
        case 'string':
            this.newPropDefaultValue.setAttribute('type', 'text');
            this.newPropDefaultValue.setAttribute('value', "");
            break;
        case 'number':
            this.newPropDefaultValue.setAttribute('type', 'number');
            this.newPropDefaultValue.setAttribute('value', 0);
            break;
        case 'boolean':
            this.newPropDefaultValue.setAttribute('type', 'checkbox');
            break;
        default:
            this.newPropDefaultValue.setAttribute('type', 'text');
        }

        if(option.value == ""){
            this.newPropDefaultValue.setAttribute('disabled', true);
        } else {
            this.newPropDefaultValue.removeAttribute('disabled');
        }
    }

    onCaretClick(event){
        let newPropArea = this._shadowRoot.getElementById('new-prop-area');
        newPropArea.classList.toggle('open');
    }

    onCreateSubmit(event){
        if(this.model){
            let propName = this.newPropNameInput.value;
            let defaultValue = this.newPropDefaultValue.value;
            if(this.newPropDefaultValue.type == 'checkbox'){
                defaultValue = this.newPropDefaultValue.checked;
            } else if(this.newPropDefaultValue.type == 'number'){
                defaultValue = parseFloat(this.newPropDefaultValue.value);
            }

            // Send the property create message
            this.model.sendMessage({
                type: 'command',
                commandName: 'newProperty',
                args: [
                    propName,
                    this.model.id
                ]
            }, this.model);

            // Set the created prop to the default
            // value
            this.model.partProperties.setPropertyNamed(
                this.model,
                propName,
                defaultValue
            );

            // Re-render this pane
            this.resetForm();
            this.render(this.model);
        }
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onFilterInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInput.value = "";
        this.filterBy("");
    }

    resetForm(){
        this.newPropNameInput.value = null;
        this.newPropDefaultValue.value = null;
        if(this.newPropDefaultValue.type == 'checked'){
            this.newPropDefaultValue.checked = false;
        }
        this.newPropDefaultValue.type = 'text';
        this.newPropDefaultValue.setAttribute('disabled', true);
        this.newPropTypeSelect.selectedIndex = 0;
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorLocationInfo.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorLocationInfo.js ***!
  \********************************************************/
/*! exports provided: EditorLocationInfo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorLocationInfo", function() { return EditorLocationInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorLocationInfo; });
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");



// PREAMBLE
const arrowLeftIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrow-narrow-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12" />
  <line x1="5" y1="12" x2="9" y2="16" />
  <line x1="5" y1="12" x2="9" y2="8" />
</svg>
`;

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host(.hidden){
        display: none;
    }
    .button-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .button-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .button-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .button-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
</style>
<p class="part-info">
    My <button id="owner-link" class="button-link" title=""><span></span>${arrowLeftIcon}</button> is named <span class="part-name"></span> and is located at <button id="location-link" class="button-link" title="Copy location"><span></span>${clipboardIcon}</button> <button id="id-link" class="button-link" title="Copy id"><span>Copy id</span>${clipboardIcon}</button>
</p>
`;

class EditorLocationInfo extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Accepted values for the kind attribute
        this.allowedKinds = ['stack', 'card', 'owner'];

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.handleStackKind = this.handleStackKind.bind(this);
        this.handleCardKind = this.handleCardKind.bind(this);
        this.updateInfo = this.updateInfo.bind(this);
        this.getAncestorOfTypeFor = this.getAncestorOfTypeFor.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
        this.onLinkClick = this.onLinkClick.bind(this);
        this.onMouseEnter = this.onMouseEnter.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
    }

    connectedCallback(){
        // Events
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        ownerLinkButton.addEventListener('click', this.onLinkClick);
        locationLinkButton.addEventListener('click', this.onLocationClick);
        idLinkButton.addEventListener('click', this.onLocationClick);
        locationLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.addEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.addEventListener('mouseleave', this.onMouseLeave);
    }

    disconnectedCallback(){
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        locationLinkButton.removeEventListener('click', this.onLocationClick);
        idLinkButton.removeEventListener('click', this.onLocationClick);
        ownerLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
    }

    render(aModel){
        this.model = aModel;
        let kind = this.getAttribute('kind');
        if(!kind || !this.allowedKinds.includes(kind)){
            this.classList.add('hidden');
            return;
        }
        if(this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }

        this.classList.remove('hidden');

        // Update element references
        this.ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        this.ownerLinkTypeSpan = this.ownerLinkButton.querySelector('span');
        this.locationLinkButton = this._shadowRoot.getElementById('location-link');
        this.locationLinkSpan = this.locationLinkButton.querySelector('span');
        this.idLinkButton = this._shadowRoot.getElementById('id-link');
        this.idLinkSpan = this.idLinkButton.querySelector('span');
        this.nameSpan = this._shadowRoot.querySelector('p .part-name');

        if(kind == 'stack'){
            this.handleStackKind();
        } else if(kind =='card'){
            this.handleCardKind();
        } else {
            this.updateInfo();
        }
    }

    updateInfo(){
        let kind = this.getAttribute('kind');
        let ancestor = this.model._owner;
        if(kind == 'stack' || kind == 'card'){
            ancestor = this.getAncestorOfTypeFor(this.model, kind);
        }

        // If we cannot find an ancestor of the given
        // kind, then we hide this field
        if(!ancestor){
            this.classList.add('hidden');
            return;
        }

        // Update name span
        let ancestorName = ancestor.partProperties.getPropertyNamed(
            ancestor,
            'name'
        );
        if(!ancestorName){
            ancestorName = '(unnamed)';
        } else {
            ancestorName = `"${ancestorName}"`;
        }
        this.nameSpan.textContent = ancestorName;

        // Update kind span
        let kindLabel = kind[0].toUpperCase() + kind.slice(1);
        this.ownerLinkTypeSpan.textContent = kindLabel;

        // Update location link span
        this.locationLinkSpan.textContent = this.getLocationStringFor(ancestor);

        // Update button titles
        let editTitle = `Edit owning ${kindLabel}`;
        if(kind == 'owner'){
            editTitle = 'Edit Owner';
        }
        this.ownerLinkButton.setAttribute(
            'title',
            editTitle
        );

        // Add the ref-id attribute
        this.setAttribute('ref-id', ancestor.id);
    }

    handleStackKind(){
        if(this.model.type == 'stack' || this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    handleCardKind(){
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    getAncestorOfTypeFor(aPart, aType){
        let result;
        let currentOwner = aPart._owner;
        while(currentOwner){
            if(currentOwner.type == aType){
                result = currentOwner;
                break;
            }
            currentOwner = currentOwner._owner;
        }
        return result;
    }

    onLinkClick(event){
        let id = this.getAttribute('ref-id');
        if(id && this.model){
            // Re-render the editor on the Part
            // referenced by the found id
            let target = window.System.partsById[id];
            window.System.editor.render(target);
        }
    }

    onMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    getLocationViews(event){
        let targetId;
        let span = event.currentTarget.querySelector('span');
        if(span.parentElement.id == 'id-link'){
            targetId = this.getAttribute('ref-id');
        } else {
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.System.partsById['world'], window.System)
            );
            let m = window.System.grammar.match(span.textContent, "ObjectSpecifier");
            try{
                targetId = semantics(m).interpret();
            } catch(e){
                console.log(`cannot locate ${span.textContent}`);
            }
        }
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorMessenger.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/editors/EditorMessenger.js ***!
  \*****************************************************/
/*! exports provided: EditorMessenger, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorMessenger", function() { return EditorMessenger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorMessenger; });


// PREAMBLE
const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }
   
    textarea {
        resize: none;
        flex: 0.25;
    }
</style>
<h3>Send this <span></span> a Message:</h3>
<textarea placeholder="Type your Simpletalk message here..."></textarea>
<button>Send</button>
`;

class EditorMessenger extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onMessageFieldInput = this.onMessageFieldInput.bind(this);
        this.sendMessageFromText = this.sendMessageFromText.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.sendButton = this._shadowRoot.querySelector('button');
            this.sendButton.addEventListener('click', this.sendMessageFromText);
        
            this.messageField = this._shadowRoot.querySelector('textarea');
            this.messageField.addEventListener('input', this.onMessageFieldInput);
        }
    }

    disconnectedCallback(){
        this.messageField.removeEventListener('input', this.onMessageFieldInput);
        this.sendButton.removeEventListener('click', this.sendMessageFromText);
    }

    render(aModel){
        this.model = aModel;
        
        let partTypeLabel = this._shadowRoot.querySelector('h3 > span');
        partTypeLabel.textContent = this.model.type;
    }

    onMessageFieldInput(event){

    }

    sendMessageFromText(){
        let text = this.messageField.value;
        let script = `on doIt\n\t${text}\nend doIt`;
        this.model.sendMessage({
            type: 'compile',
            codeString: script,
            targetId: this.model.id
        }, this.model);
        this.model.sendMessage({
            type: 'command',
            commandName: 'doIt',
            args: [],
            shouldIgnore: true
        }, this.model);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropItem.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropItem.js ***!
  \****************************************************/
/*! exports provided: EditorPropItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropItem", function() { return EditorPropItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropItem; });
// PREAMBLE

const checkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>
`;

const cancelIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#ff2825" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M10 10l4 4m0 -4l-4 4" />
</svg>
`;

const templateString = `
<style>
    li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px;
        padding-left: 8px;
        padding-right: 8px;
        margin-top: 6px;
    }
   
    li > label {
        flex: 1;
    }

    :host {
        width: 100%;
    }

    :host(.item-hidden) {
        display:none;
    }

    button {
        outline: none;
        border: 1px solid transparent;
        background-color: transparent;
        opacity: 1.0;
        transition: opacity 0.1s linear;
    }

    button:disabled {
        opacity: 0.05;
        transition: opacity: 0.1s linear;
    }

    button:hover {
        cursor: pointer;
    }

    button.button-hidden {
        display: none;
    }

    label {
        font-family: monospace;
    }

    input {
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.5);
        outline: none;
    }
    
    input:focus {
        border: 1px solid rgba(100, 100, 100, 0.8);
    }
</style>
<li>
    <label for="prop-value"></label>
    <input id="prop-value" name="prop-value"/>
    <button id="accept" disabled>${checkIcon}</button>
    <button id="cancel" disabled>${cancelIcon}</button>
</li>
`;

class EditorPropItem extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // By default, there is no property
        this.property = null;
        this.owner = null;

        // Bound methods
        this.render = this.render.bind(this);
        this.onInputChange = this.onInputChange.bind(this);
        this.onInputInput = this.onInputInput.bind(this);
        this.onAcceptClick = this.onAcceptClick.bind(this);
        this.onCancelClick = this.onCancelClick.bind(this);
        this.onEnterKey = this.onEnterKey.bind(this);
        this.setupNumericInput = this.setupNumericInput.bind(this);
        this.enableButtons = this.enableButtons.bind(this);
        this.disableButtons = this.disableButtons.bind(this);
    }

    setProperty(aProperty, anOwner){
        // Remove any existing event handlers
        // TODO
        this.property = aProperty;
        this.owner = anOwner;

        // Update the element attributes
        this.setAttribute('name', this.property.name);
        this.setAttribute('owner-id', this.owner.id);

        // Add new event handlers

        // Render
        this.render();
        
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('keypress', this.onEnterKey);
        }
    }

    disconnectedCallback(){
        this.removeEventListener('keypress', this.onEnterKey);
    }

    render(){
        this.labelElement = this._shadowRoot.querySelector('label');
        this.inputElement = this._shadowRoot.querySelector('input');
        this.acceptButton = this._shadowRoot.getElementById('accept');
        this.cancelButton = this._shadowRoot.getElementById('cancel');

        // Remove any hide classes
        this.acceptButton.classList.remove('button-hidden');
        this.cancelButton.classList.remove('button-hidden');
        
        // Remove any bound events
        this.inputElement.removeEventListener('input', this.onInputInput);
        this.inputElement.removeEventListener('change', this.onInputChange);
        this.acceptButton.removeEventListener('click', this.onAcceptClick);
        this.cancelButton.removeEventListener('click', this.onCancelClick);

        // Add new events
        this.inputElement.addEventListener('input', this.onInputInput);
        this.inputElement.addEventListener('change', this.onInputChange);
        this.acceptButton.addEventListener('click', this.onAcceptClick);
        this.cancelButton.addEventListener('click', this.onCancelClick);
        
        this.labelElement.textContent = `${this.property.name}:`;
        let currentVal = this.property.getValue(this.owner);
        if(currentVal == null || currentVal == undefined){
            // Do something different here
        } else if(typeof(currentVal) == 'number'){
            this.setupNumericInput();
        } else if(typeof(currentVal) == 'boolean'){
            this.inputElement.setAttribute('type', 'checkbox');
            this.inputElement.checked = currentVal;
            this.acceptButton.classList.add('button-hidden');
            this.cancelButton.classList.add('button-hidden');
        } else {
            this.inputElement.setAttribute('type', 'text');
        }

        this.inputElement.setAttribute('placeholder', currentVal);
        this.inputElement.value = currentVal;
    }

    setupNumericInput(){
        if(this.property.name.endsWith('-transparency')){
            this.inputElement.setAttribute('type', 'range');
            this.inputElement.setAttribute('step', '0.05');
            this.inputElement.setAttribute('min', '0.0');
            this.inputElement.setAttribute('max', '1.0');
        } else {
            this.inputElement.setAttribute('type', 'number');
        }
    }

    onInputChange(event){
        if(event.target.type == "checkbox"){
            this.owner.partProperties.setPropertyNamed(
                this.owner,
                this.property.name,
                event.target.checked
            );
        }
    }

    onInputInput(event){
        let inputType = event.target.getAttribute('type');
        if(inputType == 'range'){
            return this.onAcceptClick();
        }
        if(event.target.value !== this.property.getValue(this.owner)){
            this.enableButtons();
        } else {
            this.disableButtons();
        }
    }

    onEnterKey(event){
        if(event.key == 'Enter'){
            this.onAcceptClick();
        }
    }

    enableButtons(){
        this.acceptButton.removeAttribute('disabled');
        this.cancelButton.removeAttribute('disabled');
    }

    disableButtons(){
        this.acceptButton.setAttribute('disabled', true);
        this.cancelButton.setAttribute('disabled', true);
    }

    onAcceptClick(event){
        let value = this.inputElement.value;
        if(this.inputElement.type == 'number'){
            value = parseFloat(value);
            if(isNaN(value)){
                // if we can't parse the value just let it go through
                // as it might be a prop style keyword such as "fill"
                // TODO: we might want to limit this to a set of prop keywords
                value = this.inputElement.value;
            }
        } else if(this.inputElement.type == 'range'){
            value = parseFloat(value);
        } else if(this.inputElement.type == 'checkbox'){
            value = this.inputElement.checked;
        }
        this.owner.partProperties.setPropertyNamed(
            this.owner,
            this.property.name,
            value
        );
        this.disableButtons();
    }

    onCancelClick(event){
        this.inputElement.value = this.owner.partProperties.getPropertyNamed(
            this.owner,
            this.property.name
        );
        this.disableButtons();
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropList.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropList.js ***!
  \****************************************************/
/*! exports provided: EditorPropList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropList", function() { return EditorPropList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropList; });
/* harmony import */ var _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorPropItem.js */ "./js/objects/views/editors/EditorPropItem.js");


// PREAMBLE
window.customElements.define('editor-prop-item', _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
</style>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

const specialProps = [
    'cssStyle',
    'cssTextStyle',
    'id',
    'name',
    'target',
    'events',
    'current',
    'script',
    'custom-properties'
];

class EditorPropList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onInput = this.onInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.filterInputElement = this._shadowRoot.getElementById('filter-input');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any existing main DOM children
        this.innerHTML = "";
        let inputEl = this._shadowRoot.getElementById('filter-input');
        inputEl.removeEventListener('input', this.onInput);
        inputEl.addEventListener('input', this.onInput);

        // Create a sorted copy of the property objects
        this.propList = this.model.partProperties.all.slice().filter(prop => {
                return !specialProps.includes(prop.name);
            });
        this.propList
            .sort((first, second) => {
            return first.name.localeCompare(second.name);
        });

        // Render the list item elements and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInputElement.value = "";
        this.filterBy("");
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorSubpartsPane.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorSubpartsPane.js ***!
  \********************************************************/
/*! exports provided: EditorSubpartsPane, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorSubpartsPane", function() { return EditorSubpartsPane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorSubpartsPane; });
/* harmony import */ var _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorLocationInfo.js */ "./js/objects/views/editors/EditorLocationInfo.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");
// PREAMBLE




window.customElements.define('editor-location-info', _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    :host() > li {
        background-color: red;
    }

    .id-link,
    .location-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .id-link:hover,
    .location-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .id-link > svg,
    .location-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .id-link:hover > svg,
    .location-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    section {
        display: flex;
        flex-direction: column;
        margin: 6px;
    }

    #button-area {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;'
    }

    #subparts-list-wrapper {
        flex: 1;
        overflow-y: hidden;
    }

    .hidden {
        display: none;
    }

    #subparts-area {
        flex: 1;
        list-style: none;
        font-family: 'Helvetica', sans-serif;
        padding: 0;
        margin: 0;
        margin-left: 32px;
        overflow-y: auto;
    }
</style>
<section id="button-area">
    <slot name="button"></slot>
</section>
<section id="location-area">
    <h3>Part Location and Owners</h3>
    <p class="part-info">
        I am located at <button class="location-link"><span></span>${clipboardIcon}</button>
        and my id is <button class="id-link"><span></span>${clipboardIcon}</button>
    </p>
    <slot name="ancestor-info"></slot>
</section>
<section id="subparts-list-wrapper">
    <h3>Subparts</h3>
    <ol id="subparts-area">
        <slot></slot>
    </ol>
</section>
`;

class EditorSubpartsPane extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.onAddSubpart = this.onAddSubpart.bind(this);
        this.onSubpartItemClick = this.onSubpartItemClick.bind(this);
        this.onSubpartItemMouseEnter = this.onSubpartItemMouseEnter.bind(this);
        this.onSubpartItemMouseLeave = this.onSubpartItemMouseLeave.bind(this);
        this.createAddPartButton = this.createAddPartButton.bind(this);
        this.createSubpartComponent = this.createSubpartComponent.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.headerEl = this._shadowRoot.getElementById('location-area');
            this.myLocationArea = this.headerEl.querySelector('p');
            this.myLocationButton = this.myLocationArea.querySelector('.location-link');
            this.myIdButton = this.myLocationArea.querySelector('.id-link');

            // Add event listener to buttons
            this.myLocationButton.addEventListener('click', this.onLocationLinkClick);
            this.myIdButton.addEventListener('click', this.onLocationLinkClick);
        }
    }

    disconnectedCallback(){
        this.myLocationButton.removeEventListener('click', this.onLocationLinkClick);
        this.myIdButton.removeEventListener('click', this.onLocationLinkClick);
    }

    render(aModel){
        this.model = aModel;
        this.headerEl = this._shadowRoot.getElementById('location-area');

        // Clear any DOM children
        this.innerHTML = "";


        // Create location link elements
        // and also the self-location element
        let myLocationText = this.getLocationStringFor(this.model);
        this.myLocationButton.querySelector('span').textContent = myLocationText;
        this.myIdButton.querySelector('span').textContent = this.model.id.toString();
        if(this.model.type == 'world'){
            this.headerEl.classList.add('hidden');
        } else {
            this.headerEl.classList.remove('hidden');

            // Create the info elements
            ['stack', 'card', 'owner'].forEach(kind => {
                let infoEl = document.createElement('editor-location-info');
                infoEl.setAttribute('slot', 'ancestor-info');
                infoEl.setAttribute('kind', kind);
                infoEl.render(this.model);
                this.appendChild(infoEl);
            });
        }

        // Create the "add subpart" buttons for parts that are accepted by the
        // current Model part.
        this.model.acceptedSubpartTypes.forEach(partType => {
            let element = this.createAddPartButton(partType);
            this.appendChild(element);
        });

        let labelHeader = this._shadowRoot.querySelector('#subparts-list-wrapper > h3');
        if(this.model.subparts.length){
            labelHeader.textContent = "Current Subparts";
        } else {
            labelHeader.textContent = "There are no subparts";
        }

        this.model.subparts.forEach(subpart => {
            let element = this.createSubpartComponent(subpart);
            this.appendChild(element);
        });
    }

    createSubpartComponent(aPart){
        let wrapper = document.createElement('li');
        wrapper.classList.add('subpart-item');
        wrapper.setAttribute('ref-id', aPart.id);
        wrapper.addEventListener('click', this.onSubpartItemClick);
        wrapper.addEventListener('mouseenter', this.onSubpartItemMouseEnter);
        wrapper.addEventListener('mouseleave', this.onSubpartItemMouseLeave);

        // Add icon area an SVG for Part
        let iconArea = document.createElement('div');
        iconArea.classList.add('icon-display-area');
        let iconImage;
        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"]).includes(aPart.type)){
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPart.type];
        } else {
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        iconArea.innerHTML = iconImage;
        wrapper.append(iconArea);

        // Add label, name, and id info
        let labelArea = document.createElement('h3');
        labelArea.textContent = `a ${aPart.type[0].toUpperCase()}${aPart.type.slice(1)}`;
        wrapper.append(labelArea);
        let name = aPart.partProperties.getPropertyNamed(
            aPart,
            'name'
        );
        if(name && name != ""){
            let nameArea = document.createElement('span');
            nameArea.classList.add('name-span');
            nameArea.textContent = `"${name}"`;
            wrapper.append(nameArea);
        }

        let idArea = document.createElement('span');
        idArea.classList.add('id-span');
        idArea.textContent = `(${aPart.id})`;
        wrapper.append(idArea);

        return wrapper;
    }

    createAddPartButton(aPartName){
        let button = document.createElement('button');
        let icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPartName];
        if(!icon){
            icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        button.setAttribute('slot', 'button');
        button.setAttribute('data-type', aPartName);
        button.setAttribute('title', `Add a ${aPartName} to this ${this.model.type}`);
        button.classList.add('add-part-button');
        button.addEventListener('click', this.onAddSubpart);
        button.innerHTML = icon;
        return button;
    }

    onSubpartItemClick(event){
        let id = event.currentTarget.getAttribute('ref-id');
        let targetPart = window.System.partsById[id];
        if(targetPart){
            window.System.editor.render(targetPart);
        }
    }

    onSubpartItemMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onSubpartItemMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    onAddSubpart(event){
        let type = event.currentTarget.getAttribute('data-type');
        if(type){
            this.model.sendMessage({
                type: 'command',
                commandName: 'newModel',
                args: [
                    type,
                    this.model.id
                ]
            }, this.model);
        }
        this.render(this.model);
    }

    getLocationViews(event){
        let targetId = event.currentTarget.getAttribute('ref-id');
        let span = event.currentTarget.querySelector('span');
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorTab.js":
/*!***********************************************!*\
  !*** ./js/objects/views/editors/EditorTab.js ***!
  \***********************************************/
/*! exports provided: EditorTab, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorTab", function() { return EditorTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorTab; });
// PREAMBLE

const templateString = `
<style>
    :host {
        display: flex;
        flex: 1;
        align-items: center;
        justify-content: center;
        padding: 6px;
        opacity: 0.5;
        border-bottom: 2px solid rgba(100, 100, 100, 0.7);
        transition: border 0.2s linear, opacity 0.2s linear;
        user-select: none;
    }

    :host([active="true"]){
        border-bottom: 2px solid rgba(200, 0, 0, 0.9);
        opacity: 1.0;
        transition: border 0.2s linear, opacity 0.2s linear;
    }

    :host(:hover){
        cursor: pointer;
    }
</style>
<span id="label">
    <slot></slot>
</span>
`;

class EditorTab extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.onClick = this.onClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('click', this.onClick);

            // If the tab is currently activated, emit
            // the tab-activaed message
            if(this.getAttribute('active') == "true"){
                let event = new CustomEvent("tab-activated", {
                    bubbles: true
                });
                this.dispatchEvent(event);
            }
        }
    }

    disconnectedCallback(){
        this.removeEventListener('click', this.onClick);
    }

    onClick(event){
        let isActive = (this.getAttribute('active') == "true");
        if(!isActive){
            this.setAttribute('active', 'true');
            let event = new CustomEvent("tab-activated", {
                bubbles: true
            });
            this.dispatchEvent(event);
        }
    }
};




/***/ }),

/***/ "./js/objects/views/editors/utils/subparts.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/utils/subparts.js ***!
  \****************************************************/
/*! exports provided: getLocationStringFor, onLocationLinkClick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocationStringFor", function() { return getLocationStringFor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onLocationLinkClick", function() { return onLocationLinkClick; });
 const getLocationStringFor = (aPart) => {
        let result = "";
        let currentPart = aPart;
        let currentOwner = aPart._owner;
        while(currentOwner){
            let indexInParent = currentOwner.subparts.filter((subpart) => {
                return subpart.type == currentPart.type;
            }).indexOf(currentPart) + 1;
            result += `${currentPart.type} ${indexInParent} of `;
            currentPart = currentPart._owner;
            currentOwner = currentOwner._owner;
        }
        result += 'this world';
        return result;
}


const onLocationLinkClick = (event) => {
        let text = event.currentTarget.querySelector('span').textContent;
        let input = document.createElement('input');
        input.style.position = 'absolute';
        input.style.opacity = 0;
        document.body.append(input);
        let currentFocus = document.activeElement;
        input.focus();
        input.value = text;
        console.log(input.value);
        input.select();
        document.execCommand('copy');
        input.remove();
        currentFocus.focus();
}




/***/ }),

/***/ "./js/objects/views/navigator/CardRow.js":
/*!***********************************************!*\
  !*** ./js/objects/views/navigator/CardRow.js ***!
  \***********************************************/
/*! exports provided: CardRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardRow", function() { return CardRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Card Row
 * --------------------------------------------
 * I am a view on a given Stack that shows each
 * subpart card item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="cards"></slot>
`;

class CardRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedCard = this.addWrappedCard.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('card-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the Stack Model's main view element.
        // We add the st-view-added/removed CustomEvent listeners
        // here so we can react only to direct stack additions
        // to the Stack (and not, say, to Windows or other nested kinds)
        let stackView = window.System.findViewById(this.model.id);
        stackView.addEventListener('st-view-added', this.handlePartAdded);
        stackView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(removedModel){
        let stackView = window.System.findViewById(removedModel.id);
        stackView.removeEventListener('st-view-added', this.handlePartAdded);
        stackView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        if(!this.model.currentCard){
            return;
        }
        let wrappers = Array.from(this.querySelectorAll('wrapped-view'));
        wrappers.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentCard.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'card'){
            let cardPart = window.System.partsById[event.detail.partId];
            this.addWrappedCard(cardPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'card'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update number display of all wrapped views in the row
            Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToCardById(event.target.getAttribute('wrapped-id'));
        }
    }

    initView(){
        // First, we clear out any existing children
        this.innerHTML = "";

        // We iterate over each card of the stack and:
        // * Create a clone of the card view element;
        // * Attach the correct model;
        // * Set it to be a lensed view;
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'card';
        }).forEach(cardPart => {
            this.addWrappedCard(cardPart);
        });

        // Update setting the current
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedCard(aCard){
        // Insert the lensed CardView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute('slot', 'cards');
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aCard);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a card and hence not
            // displayed in the CardRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

};




/***/ }),

/***/ "./js/objects/views/navigator/Navigator.js":
/*!*************************************************!*\
  !*** ./js/objects/views/navigator/Navigator.js ***!
  \*************************************************/
/*! exports provided: STNavigator, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STNavigator", function() { return STNavigator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STNavigator; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WrappedView.js */ "./js/objects/views/navigator/WrappedView.js");
/* harmony import */ var _StackRow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StackRow.js */ "./js/objects/views/navigator/StackRow.js");
/* harmony import */ var _CardRow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CardRow.js */ "./js/objects/views/navigator/CardRow.js");
/**
 * SimpleTalk Navigator Webcomponent
 * ------------------------------------------
 * This is a standalone component that allows
 * authors to navigate the WorldStack and individual
 * Stacks therein using a convenient pop-out tray from
 * the bottom of the screen.
 **/





// Add any needed customElements
window.customElements.define('nav-stack-row', _StackRow_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('nav-card-row', _CardRow_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('wrapped-view', _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

const stackIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="50" height="50" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <polyline points="12 4 4 8 12 12 20 8 12 4"></polyline>
   <polyline points="4 12 12 16 20 12"></polyline>
   <polyline points="4 16 12 20 20 16"></polyline>
</svg>
`;

const cardIcon = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   class="icon icon-tabler icon-tabler-stack"
   width="50"
   height="20.833309"
   viewBox="0 0 24 9.9999884"
   stroke-width="2"
   stroke="currentColor"
   fill="none"
   stroke-linecap="round"
   stroke-linejoin="round"
   version="1.1"
   id="svg893">
  <metadata
     id="metadata899">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs897" />
  <path
     stroke="none"
     d="M -2.7669151,-1.2564948 H 21.233085 V 22.743505 H -2.7669151 Z"
     fill="none"
     id="path885" />
  <polyline
     points="12 4 4 8 12 12 20 8 12 4"
     id="polyline887"
     transform="translate(0,-3)" />
</svg>
`;

const templateString = `
<style>
    :host {
        box-sizing: border-box;
        position: absolute;
        width: 100%;
        bottom: 0;
        min-height: 271px;
        background-color: white;
        backdrop-filter: blur(4px);
        transition: transform 0.2s ease-out;
        padding: 20px;
        transform: translateY(100%);
        border-top: 1px solid rgba(50, 50, 50, 0.4);
        overflow-y: hidden;
        overflow-x: auto;
        z-index: 1000;
    }

    .nav-display-row {
        box-sizing: border-box;
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        margin-bottom: 15px;
    }
    .nav-icon {
        color: gray;
        margin-right: 30px;
    }
</style>
<div id="stacks-display" class="nav-display-row">
    <div id="stack-icon" class="nav-icon">${stackIcon}</div>
    <slot name="stack-row"></slot>
</div>
<div id="cards-display" class="nav-display-row">
    <div id="card-icon" class="nav-icon">${cardIcon}</div>
    <slot name="card-row"></slot>
</div>
`;

class STNavigator extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.initialized = false;
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.createCardRowFor = this.createCardRowFor.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterDisconnected(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelSet(){
        this.removeAttribute('part-id');

        // Respond to the System part-added CustomEvent
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);

        // Add a StackRow view.
        this.stackRowEl = this.querySelector(':scope > nav-stack-row');
        if(!this.stackRowEl){
            this.stackRowEl = document.createElement('nav-stack-row');
            this.stackRowEl.setAttribute('slot', 'stack-row');
            this.appendChild(this.stackRowEl);
        }
        this.stackRowEl.setModel(this.model);

        // Create any needed CardRow views for all stacks
        // currently in the world
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.createCardRowFor(stackPart);
        });

        // Init the StackRow
        this.stackRowEl.initView();
        
        // Update the current card/stack values
        this.handleCurrentChange();

        // Respond to eventual current-ness prop
        // changes from the WorldStack.
        this.onPropChange('current', this.handleCurrentChange);
    }

    handleCurrentChange(){
        // If we get here, this means that the current *stack* has changed.
        // So we need to find the correct CardRow for it and set it
        // to be the slotted one in the shadow DOM
        let currentStackId = this.model.currentStack.id.toString();
        Array.from(this.querySelectorAll('nav-card-row')).forEach(cardRow => {
            let rowId = cardRow.getAttribute('stack-id');
            cardRow.removeAttribute('slot');
            if(currentStackId == rowId){
                cardRow.setAttribute('slot', 'card-row');
                Array.from(cardRow.querySelectorAll('wrapped-view')).forEach(wrapper => {
                    wrapper.updateScaling();
                });
            }
        });
    }

    handlePartAdded(event){
        // If a new stack is added, we need to create
        // a new CardRow for it.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.createCardRowFor(stackPart);
        }
    }

    handlePartRemoved(event){
        // If a stack has been removed, we need to
        // remove the corresponding CardRow
        if(event.detail.partType == 'stack'){
            let cardRow = this.querySelector(`[stack-id="${event.detail.partId}"]`);
            if(cardRow){
                cardRow.remove();
            }
        }
    }

    createCardRowFor(aStack){
        let cardRow = document.createElement('nav-card-row');
        cardRow.setAttribute('stack-id', aStack.id);
        cardRow.setModel(aStack);
        this.appendChild(cardRow);
        cardRow.initView();
    }

    toggle(){
        this.classList.toggle('open');
        if(this.classList.contains('open')){
            this.open();
        } else {
            this.close();
        }
    }

    open(){
        this.style.transform = "translateY(0)";
    }

    close(){
        this.style.transform = "translateY(100%)";
    }

    
};




/***/ }),

/***/ "./js/objects/views/navigator/StackRow.js":
/*!************************************************!*\
  !*** ./js/objects/views/navigator/StackRow.js ***!
  \************************************************/
/*! exports provided: StackRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackRow", function() { return StackRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Stack Row
 * --------------------------------------------
 * I am a view on the WorldStack that shows each
 * subpart stack item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="stacks"></slot>
`;

class StackRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedStack = this.addWrappedStack.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }


    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('stack-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the World Model's main view element.
        // We add the st-view-added CustomEvent listener
        // here so we can react only to direct stack additions
        // to the WorldStack (and not, say, to Windows or other nested kinds)
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        let currentId = this.model.currentStack.id;
        let wrappedViews = Array.from(
            this.querySelectorAll('wrapped-view')
        );
        wrappedViews.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentStack.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.addWrappedStack(stackPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'stack'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update numbers of remaining wrapped views in this StackRow
            Array.from(this.querySelectorAll('wrapped-view')).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToStackById(
                event.target.getAttribute('wrapped-id')
            );
        }
    }

    initView(){
        // Remove any existing wrapped views
        this.innerHTML = "";

        // We iterate over each corresponding Stack and:
        // * Create a clone of its view node;
        // * Attach the correct model;
        // * Set it to be a lensed view
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.addWrappedStack(stackPart);
        });

        // Setup the initial current-ness display
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedStack(aStack){  
        // Insert the lensed StackView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute("slot", "stacks");
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aStack);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a stack and hence not
            // displayed in the StackRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }
};




/***/ }),

/***/ "./js/objects/views/navigator/WrappedView.js":
/*!***************************************************!*\
  !*** ./js/objects/views/navigator/WrappedView.js ***!
  \***************************************************/
/*! exports provided: WrappedView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrappedView", function() { return WrappedView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WrappedView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * WrappedView Component
 * ---------------------------------------
 * I am a plain Webcomponent whose purpose is to
 * wrap a visual copy of an actual SimpleTalk View
 * element and display it in a scaled down format.
 * I make a cloned copy of the underlying view and
 * attach it to the same model as the original.
 **/


const templateString = `
<style>
    #number-display {
        opacity: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 100%;
        transition: opacity 0.2s ease-in;
        font-size: 2.2rem;
    }

    #number-display > span {
        transform: translateY(-10px);
        transition: transform 0.2s linear;
        pointer-events: none;
    }

    :host(:not(.current)) > #number-display {
        opacity: 0.8;
        background-color: rgba(200, 200, 200, 0.5);
        transition: opacity 0.2s ease-out;
        z-index: 1000;
    }

    :host(:not(.current)) > #number-display > span {
        transform: translateY(0px);
        transition: transform 0.2s linear;
    }
</style>
<div id="number-display">
    <span></span>
</div>
<slot name="wrapped-view"></slot>
`;


class WrappedView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template and shadowDom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onChildSlotted = this.onChildSlotted.bind(this);
        this.updateScaling = this.updateScaling.bind(this);
        this.handleNumberChange = this.handleNumberChange.bind(this);
        this.addWrappedView = this.addWrappedView.bind(this);
        this._recursivelyUpdateLensViews = this._recursivelyUpdateLensViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Bind a listener for the slot change.
            // This will be triggered whenever any
            // underlying element is slotted, so we
            // know to recompute the appropriate sizing
            // and styling
            let slotEl = this._shadowRoot.querySelector('slot');
            slotEl.addEventListener('slotchange', this.onChildSlotted);

            // we don't want the context menu to open in the nav since
            // it doens't make sense atm and will error
            this.removeEventListener('contextmenu', this.onContextMenuClick);
        }
    }

    disconnectedCallback(){
        let slotEl = this._shadowRoot.querySelector('slot');
        slotEl.removeEventListener('slotchange', this.onChildSlotted);
    }

    onChildSlotted(event){
        //this.updateScaling();
        //this.updateNumberDisplay();
    }

    afterModelSet(){
        this.onPropChange('number', this.handleNumberChange);
        this.removeAttribute('part-id');
        this.addWrappedView(this.model);
        this.updateNumberDisplay();
    }

    updateScaling(){
        let firstChild = this.children[0];
        // We need to find the element corresponding to the
        // actual view for the lens-ed part, in order to get
        // its current dimensions.
        let partId = firstChild.getAttribute('lens-part-id');
        let refElement = document.querySelector(`st-world`);
        let wrapBox = this.getBoundingClientRect();
        let innerBox = document.querySelector(`st-world`).getBoundingClientRect();
        let scalingX = (wrapBox.width / innerBox.width);
        let refElementBox = refElement.getBoundingClientRect();
        firstChild.style.width = `${refElementBox.width}px`;
        firstChild.style.height = `${refElementBox.height}px`;
        firstChild.style.transform = `scale(${scalingX})`;
        firstChild.style.transformOrigin = "0px 0px";
    }

    updateNumberDisplay(){
        let firstChild = this.children[0];
        let model = firstChild.model;
        // we only want to look at subparts of the same type (stack or card)
        let subparts = model._owner.subparts.filter((part) => {
            return model.type == part.type;
        });
        let numDisplay = this._shadowRoot.querySelector('#number-display > span');
        numDisplay.innerText = subparts.indexOf(model) + 1;
    }

    handleNumberChange(){
        // Update number display of all wrapped views in the row
        Array.from(this.parentNode.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

    addWrappedView(aPartModel){
        // First, clear out any existing
        // child elements
        this.innerHTML = "";

        // Create a lensed copy of the given
        // view and update key attributes on it
        let originalView = document.querySelector(`[part-id="${aPartModel.id}"]`);
        let lensedView = originalView.cloneNode(true);
        lensedView.setAttribute('lens-part-id', aPartModel.id);
        lensedView.setAttribute('slot', 'wrapped-view');
        lensedView.style.pointerEvents = "none";
        lensedView.wantsHalo = false;

        // Inline the initial scaling style properties.
        // We begin with an extremely small amount which will
        // be adjusted later during updateScaling();
        lensedView.style.transform = `scale(${0.001})`;
        lensedView.style.transformOrigin = "0px 0px";
        
        // Recursively create lens views of all subpart children
        // and append them in the correct places
        lensedView.isLensed = true;
        lensedView.setModel(aPartModel);
        lensedView.removeAttribute('part-id');
        if(lensedView.handleCurrentChange){
            lensedView.handleCurrentChange();
        }
        this._recursivelyUpdateLensViews(lensedView, aPartModel.id);

        // Insert the root lensed view into the wrapper
        this.setAttribute('wrapped-id', aPartModel.id);
        this.appendChild(lensedView);
        this.updateScaling();
    }

    _recursivelyUpdateLensViews(lensedView, anId){
        let subViews = Array.from(lensedView.children).filter(child => {
            return child.isPartView;
        });
        subViews.forEach(subView => {
            subView.isLensed = true;
            subView.wantsHalo = false;
            let subId = subView.getAttribute('part-id');
            subView.setAttribute('lens-part-id', subId);
            let model = window.System.partsById[subId];
            subView.setModel(model);
            subView.removeAttribute('part-id');
            this._recursivelyUpdateLensViews(subView, subId);
        });
    }

    /** PartView Overrides **/
    styleCSS(){
        // Do nothing
    }

    styleTextCSS(){
        // Do nothing
    }

    layoutChanged(){
        // Do nothing
    }
};




/***/ }),

/***/ "./js/ohm/interpreter-semantics.js":
/*!*****************************************!*\
  !*** ./js/ohm/interpreter-semantics.js ***!
  \*****************************************/
/*! exports provided: createInterpreterSemantics, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createInterpreterSemantics", function() { return createInterpreterSemantics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createInterpreterSemantics; });
/* harmony import */ var _objects_ExecutionStack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/ExecutionStack.js */ "./js/objects/ExecutionStack.js");


// Helpers
function findNearestParentOfKind(aPart, aPartType){
    let owner = aPart._owner;
    while(owner){
        if(owner.type == aPartType){
            return owner;
        }
        owner = owner._owner;
    }
    throw new Error(`'this' is a ${aPart.type}, not a ${aPartType} or does not have a parent of a ${aPartType}!`);
}

// check for possibleAncestor.acceptsSubpart(aPart.type)
// and if not go to owner and check again
function findFirstPossibleAncestor(aPart, aPartType){
    if(_subpartCheck(aPart, aPartType)){
        return aPart;
    } else {
        let owner = aPart._owner;
        while(owner){
            if(_subpartCheck(owner, aPartType)){
                return owner;
            }
            owner = owner._owner;
        }
    }
    throw new Error(`a ${aPart.type}, does not accept nor has any ancestors which accept part type ${aPartType}`);
}

function _subpartCheck(aPart, aPartType){
    if(aPartType == 'part'){
        return aPart.acceptedSubpartTypes.length > 0;
    }
    return aPart.acceptsSubpart(aPartType);
}

class STVariableReferenceError extends Error {
    constructor(...args){
        super(...args);
    }
};
Object.defineProperty(
    STVariableReferenceError.prototype,
    'name',
    {
        value: 'STVariableReferenceError'
    }
);

const createInterpreterSemantics = (partContext, systemContext) => {
    return {
        Script: function(scriptParts, _){
            return scriptParts.interpret();
        },
        MessageHandler: function(handlerOpen, lineTerm, optionalStatementList, handlerClose){
            let {messageName, parameters} = handlerOpen.interpret();
            let handlerFunction = function(senders, ...args){

                // In the grammar, the StatementList is
                // an optional rule, meaning the result of the rule
                // is an empty array (no statementlist) or a single
                // item array (the statementlist)
                if(optionalStatementList.children.length == 0){
                    return;
                }
                let statementList = optionalStatementList.children[0];

                // Next, we initialize a new ActivationContext
                // that will hold all variable information for
                // the execution of this handler.
                // We push it to the top of the current execution stack
                // and set the argument variables to locals
                args.forEach((argValue, index) => {
                    let argName = parameters[index];
                    systemContext.executionStack.current.setLocal(
                        argName,
                        argValue
                    );
                });

                // Because StatementList is both optional *and* made up
                // of iterable StatementLine rules (ie, 'StatementLine+' in grammar),
                // we need to "unwrap" these nodes without calling interpret() on them.
                // This ensures that expressions within the statements, like variable lookups,
                // are not called before any preceding statements have been interpreted and
                // the corresponding messages have already been sent. For example, statement 1 might
                // set a variable that statement 2 needs to lookup and use, so we want the lookup to
                // occur after statement 1 has been interpreted and the message for it has
                // been sent.
                statementList.children.forEach(statementLines => {
                    statementLines.children.forEach(statementLine => {
                        let message = statementLine.interpret();
                    });
                });
            };

            partContext._commandHandlers[messageName] = handlerFunction;
        },

        MessageHandlerOpen: function(literalOn, messageName, optionalParameterList){
            // Because the ParameterList here is optional, if
            // it is set it will be in the form of a size 1 array.
            // This single array item will itself be an array of the
            // parameter variable names.
            // Otherwise, an empty array indicates no params
            // are passed in for this handler
            let params = optionalParameterList.interpret();
            if(params.length > 0){
                params = params[0];
            }
            return {
                messageName: messageName.sourceString,
                parameters: params
            };
        },

        ParameterList: function(parameterString){
            return parameterString.asIteration().children.map(child => {
                return child.sourceString;
            });
        },


        InClause: function(inLiteral, objectSpecifier){
            return objectSpecifier.interpret();
        },

        Command_answer: function(answer, expression){
            let msg = {
                type: "command",
                commandName: "answer",
                args: [
                    expression.interpret()
                ]
            };
            return msg;
        },

        Command_goToDirection: function(goToLiteral, nextPrevious, systemObject){
            let args = [];
            args.push(nextPrevious.sourceString);
            if (systemObject.sourceString){
                args.push(systemObject.sourceString);
            }

            let msg = {
                type: "command",
                commandName: "go to direction",
                args: args
            };
            return msg;
        },

        Command_goToWebsite: function(goToLiteral, websiteLiteral, url){
            let args = [
                url.interpret()
            ];

            let msg = {
                type: "command",
                commandName: "go to website",
                args: args
            };
            return msg;
        },

        Command_goToBySpecifier: function(goToLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            if(!targetId){
                return null;
            }
            let targetPart = systemContext.partsById[targetId];
            if(targetPart.type == "card" || targetPart.type == "stack"){
                return {
                    type: "command",
                    commandName: "go to reference",
                    args: [
                        targetPart.type,
                        targetId
                    ]
                };
            }

            // If the specified part is neither a Card nor
            // a Stack, we don't go to it. Instead, we do
            // nothing.
            return null;
        },

        Command_addProperty: function(addLiteral, propertyLiteral, propNameAsLiteral, toLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "newProperty",
                args: args
            };
            return msg;
        },

        Command_addModel: function(addLiteral, newPartType, optionalPartName){
            // here no owner has been provided so we assume it is the first possible one
            let parent = findFirstPossibleAncestor(partContext, newPartType.sourceString);
            let args = [
                newPartType.sourceString,
                parent.id
            ];
            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_addModelTo: function(addLiteral, newPartType, optionalPartName, toLiteral, objectSpecifier){
            let args = [
                newPartType.sourceString, // The kind of part to add
                objectSpecifier.interpret() // id of the parent model part
            ];

            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_putVariable: function(putLiteral, value, intoLiteral, globalLiteral, destination){
            let global = false;
            if(globalLiteral.sourceString){
                global = true;
            };
            let args = [
                value.interpret(),
                destination.sourceString,
                global
            ];
            let msg = {
                type: "command",
                commandName: 'putInto',
                args
            };
            return msg;
        },

        Command_deleteProperty: function(deleteLiteral, propertyLiteral, propNameAsLiteral, fromLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "deleteProperty",
                args: args
            };
            return msg;
        },

        Command_deleteModel: function(deleteLiteral, objectSpecifier){
            let args = [
                objectSpecifier.interpret() // id of the object
            ];

            let msg = {
                type: "command",
                commandName: "deleteModel",
                args: args
            };
            return msg;
        },

        Command_setProperty: function(setLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setProperty",
                args: args
            };
            return msg;
        },

        Command_setSelection: function(setLiteral, selectionLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setSelection",
                args: args
            };
            return msg;
        },

        Command_ask: function(askLiteral, question){
            return {
                type: "command",
                commandName: "ask",
                args: [ question.interpret() ]
            };
        },

        Command_tellCommand: function(tellLiteral, objectSpecifier, toLiteral, command){
            return {
                type: 'command',
                commandName: 'tell',
                args: [
                    objectSpecifier.interpret(),
                    command.interpret()
                ]
            };
        },

        Command_arbitraryCommand: function(commandName, optionalArgumentList){
            // Because the argument list is optional here, it will
            // be either an empty array (no arguments) or a size 1
            // array (which itself will contain an array of the arguments)
            let optionalArguments = optionalArgumentList.interpret();
            if(optionalArguments.length > 0){
                optionalArguments = optionalArguments[0];
            }

            return {
                type: "command",
                commandName: commandName.sourceString,
                args: optionalArguments
            };
        },

        CommandArgumentList: function(list){
            return list.asIteration().interpret();
        },

        StatementLine: function(statement, newline){
            let message = statement.interpret();

            // Some statements, like if-then controls
            // and repeat controls, do not result in
            // messages but return null.
            // We ignore these.
            if(message && typeof(message) !== 'string'){
                let commandResult = partContext.sendMessage(message, partContext);
                systemContext.executionStack.current.setLocal('it', commandResult);
                return null;
            } else {
                return message;
            }
        },

        Statement: function(actualStatement, optionalComment){
            return actualStatement.interpret();
        },

        Expression_addExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first + second;
        },

        Expression_minusExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first - second;
        },

        Expression_divideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first / second;
        },

        Expression_moduloDivideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first % second;
        },

        Expression_timesExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first * second;
        },

        Expression_stringConcatExpr: function(firstExpression, operation, secondExpression){
            // When we encounter the "&" operator, we coerce both expressions into
            // a string
            let first = firstExpression.interpret().toString();
            let second = secondExpression.interpret().toString();
            return `${first}${second}`;
        },

        Factor_parenFactor: function(leftParen, expression, rightParen){
            return expression.interpret();
        },

        Factor_notFactor: function(notLiteral, expression){
            return !expression.interpret();
        },

        EqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first === second;
        },

        NonEqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first !== second;
        },

        Conditional_gtComparison: function(expr1, gtLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first > second;
        },

        Conditional_ltComparison: function(expr1, ltLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first < second;
        },

        Conditional_gteComparison: function(expr1, gteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first >= second;
        },

        Conditional_lteComparison: function(expr1, lteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first <= second;
        },

        ThereIsAnObjectConditional: function(thereLiteral, isLiteral, aOrAnLiteral, objectSpecifier){
            try{
                objectSpecifier.interpret();
                return true;
            } catch(e){
                return false;
            };
        },

        ThereIsNotAnObjectConditional: function(thereLiteral, isLiteral, notLiteral, aOrAnLiteral, inClause){
            try{
                objectSpecifier.interpret();
                return false;
            } catch(e){
                return true;
            };
        },

        ThereIsAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsNotAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        ThereIsNotAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        IfThenInline: function(ifLiteral, conditional, thenLiteral, statement, optionalComment){
            let shouldEvaluate = conditional.interpret();
            if(shouldEvaluate){
                return statement.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withoutElse: function(ifLine, lineTerm1, thenLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withElse: function(ifLine, lineTerm1, thenLine, lineTerm2, elseLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return elseLine.interpret();
            }
        },

        IfThenMultiline_withElse: function(ifLine, lineTerm, multiThen, multiElse, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            } else {
                return multiElse.interpret();
            }
        },

        IfThenMultiline_withoutElse: function(ifLine, lineTerm, multiThen, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            }
            return null;
        },

        IfLine: function(ifLiteral, conditional, optionalComment){
            return conditional.interpret();
        },

        ThenLine: function(thenLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ElseLine: function(elseLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ControlStatementLine: function(statementLine){
            return statementLine.interpret();
        },

        MultiThen: function(thenLiteral, optionalComment, lintTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        MultiElse: function(elseLiteral, optionalComment, lineTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        KindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return false;
        },

        NotKindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return true;
        },

        RepeatControlForm_forNumTimes: function(repeatLit, optionalForLit, intOrVar, timesLit){
            return {
                repeatType: 'forNumTimes',
                numTimes: intOrVar.interpret()
            };
        },

        RepeatControlForm_untilCondition: function(repeatLit, untilLit, conditional){
            return {
                repeatType: 'untilCondition',
                condition: conditional
            };
        },

        RepeatControlForm_whileCondition: function(repeatLit, whileLit, conditional){
            return {
                repeatType: 'whileCondition',
                condition: conditional
            };
        },

        RepeatControlForm_withStartFinish: function(repeatLit, withLit, varName, eqLit, firstVal, toLit, secondVal){
            return {
                repeatType: 'withStartFinish',
                varName: varName.sourceString,
                start: firstVal.interpret(),
                finish: secondVal.interpret()
            };
        },

        RepeatAdjust_exit: function(_){
            return 'exit repeat';
        },

        RepeatAdjust_next: function(_){
            return 'next repeat';
        },

        RepeatBlock: function(repeatControl, lineTerm, statementLineOrRepAdjustPlus, endLiteral){
            let repeatInfo = repeatControl.interpret();
            let statementLines = statementLineOrRepAdjustPlus.children;
            switch(repeatInfo.repeatType){
            case 'forNumTimes':
                for(let i = 1; i <= repeatInfo.numTimes; i++){
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == 'next repeat'){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the main for loop
                    }
                }
                break; // Break out of the switch
            case 'untilCondition':
                let untilTestCondition = repeatInfo.condition.interpret();
                while(!untilTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result){
                            if(result == 'exit repeat'){
                                shouldBreak = true;
                                break;
                            } else if(result == 'next repeat'){
                                break;
                            }
                        }
                    }
                    if(shouldBreak){
                        break; // break out of the outer while loop
                    }
                    untilTestCondition = repeatInfo.condition.interpret();
                }
                break; // Break out of the switch case
            case 'whileCondition':
                let whileTestCondition = repeatInfo.condition.interpret();
                while(whileTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldBreak){
                        break; // break out of outer while loop (end repeat)
                    }
                    whileTestCondition = repeatInfo.condition.interpret();
                }
                break; // break out of switch case
            case 'withStartFinish':
                // For now, we assume that start is less than
                // finish. We should probably throw an error if
                // otherwise
                if(repeatInfo.start > repeatInfo.finish){
                    throw new Error(`Repeat error: start greater than finish`);
                }

                for(let i = repeatInfo.start; i <= repeatInfo.finish; i++){
                    systemContext.executionStack.current.setLocal(repeatInfo.varName, i);
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == "exit repeat"){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the outer (repeat) loop
                    }
                }
            }
            return null;
        },

        PropertyValue_withSpecifier: function(theLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            return target.partProperties.getPropertyNamed(
                target,
                propName.interpret()
            );
        },

        PropertyValue_withoutSpecifier: function(theLiteral, propName){
            return partContext.partProperties.getPropertyNamed(
                partContext,
                propName.interpret()
            );
        },

        /** Object Specifiers **/


        /**
         * The partByTarget Partial Specifier
         * refers to partials that specify a part
         * specified in the "target" PartProperty
         * of the context part. The value of the
         * target property is any valid ObjectSpecifier
         * string.
         */
        PartialSpecifier_partByTarget(targetLiteral){
            return (context) => {
                let targetPropValue = context.partProperties.getPropertyNamed(context, "target");
                // use the partContext since the context object might not have any semantics set on it
                // For example, a context object/part which does not have a script which has been
                // compiled will not have had context._semantics set.
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return systemContext.partsById[targetId];
            };
        },

        /**
         * The currentCard Partial Specifier
         * refers to partials that specify the current card
         * depending on the stack context.
         */
        PartialSpecifier_currentCard: function(currentLiteral, cardLiteral){
            return function(contextPart){
                return contextPart.currentCard;
            };
        },

        /**
         * The partByIndex Partial Specifier
         * refers to partials that specify a part
         * type and an integer literal, for ex:
         *     field 3
         * The above example refers to the third
         * field part in its owner/parent part.
         */
        PartialSpecifier_partByIndex: function(objectType, integerLiteral){
            let index = integerLiteral.interpret();
            if(index < 1){
                throw new Error(`Part indices must be 1 or greater`);
            }
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    return contextPart.subparts[index-1];
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    return partsOfType[index-1];
                }
            };
        },

        /**
         * The partByNumericalIndex Partial Specifier
         * refers to partial that specify a part
         * type preceded by the English word for the
         * number. For the moment we accept first - tenth
         * Example:
         *     sixth button
         */
        PartialSpecifier_partByNumericalIndex: function(numericalKeyword, objectType){
            let index = numericalKeyword.interpret();
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return contextPart.subparts[contextPart.subparts.length - 1];
                    } else {
                        return contextPart.subparts[index-1];
                    }
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return partsOfType[partsOfType.length - 1];
                    } else {
                        return partsOfType[index-1];
                    }
                }
            };
        },

        /**
         * The partByName Partial Specifier
         * refers to a partial that specifies a part
         * by its name property. Example:
         *     card "My Custom Card"
         */
        PartialSpecifier_partByName: function(objectType, stringLiteral){
            let name = stringLiteral.interpret();
            if(objectType.sourceString == 'part'){
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return name == foundName;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part named "${name}"`);
                };
            } else {
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    }).filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return foundName == name;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} named "${name}"`);
                };
            }
        },

        /**
         * The 'this' specifier is a terminal (final)
         * specifier that refers to one of three things:
         * 1. the type of the current part executing the script,
         *    example: this button
         * 2. Card, which refers to the card that owns the
         *    part that is currently executing the script, ex:
         *    this card
         * 3. Stack, which refers to the stack that owns the
         *    part that is currently executing the script, ex:
         *    this stack
         */
        TerminalSpecifier_thisSystemObject: function(thisLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == partContext.type){
                    return partContext;
                } else {
                    return findNearestParentOfKind(partContext, targetType);
                }
            };
        },

        /**
         * The 'current' specifier is a terminal (final)
         * specifier that refers to either the current card or stack
         * being displayed to the user.
         * There are only two possible valid options:
         *     `current card`
         *     `current stack`
         */
        TerminalSpecifier_currentSystemObject: function(currentLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == 'stack'){
                    return systemContext.getCurrentStackModel();
                } else if(targetType == 'card'){
                    return systemContext.getCurrentCardModel();
                } else {
                    throw new Error(`${targetType} cannot be a 'current' system object`);
                }
            };
        },

        /**
         * The partById specifier is a terminal (final)
         * specifier that refers to a given part type
         * by its unique system id. For any kind of part,
         * we use `part id <objectId>`
         * Examples: `card id 266` `part id 5`
         */
        TerminalSpecifier_partById: function(objectType, idLiteral, objectId){
            let id = objectId.sourceString;
            let found = systemContext.partsById[id];
            if(!found){
                throw new Error(`Cannot find ${objectType.sourceString} with id ${objectId}`);
            }
            return function(context){
                return found;
            };
        },

        /**
         * A "prefixed" queried specifier is just
         * a PartialSpecifier with "of" in front of it, indicating
         * that a different partial will precede it be queried inside of it.
         * Example `of button "My Button"`
         */
        QueriedSpecifier_prefixed: function(partialSpecifier, ofLiteral){
            return partialSpecifier.interpret();
        },

        /**
         * A nested queried specifier is one that has two
         * or more prefixed specifiers. The simplest would be
         * something like:
         *     `of card "My Card" of stack "Another named stack"`
         */
        QueriedSpecifier_nested: function(firstQuery, secondQuery){
            return function(contextPart){
                let inner = secondQuery.interpret()(contextPart);
                let outer = firstQuery.interpret()(inner);
                return outer;
            };
        },

        /**
         * An ObjectSpecifier without an annotated
         * rule means it was interpreted as just
         * a TerminalSpecifier of some sort.
         * However, we need to extract the id
         * and return that result, since that is what is
         * expected of all interpreted ObjectSpecifiers
         */
        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let found = terminalSpecifier.interpret()();
            return found.id;
        },

        /**
         * A Compound with terminal specifier is a QueriedSpecifier
         * that finishes with a Terminal specifier.
         * Example: `of button 3 of card "Some named card" of current stack`
         */
        ObjectSpecifier_compoundQueryWithTerminal: function(queriedSpecifier, terminalSpecifier){
            // The terminal here is the ultimate part context
            let finalPart = terminalSpecifier.interpret()();
            let result = queriedSpecifier.interpret()(finalPart);
            return result.id;
        },

        /**
         * A Compound without terminal specifier is a QueriedSpecifier
         * that finishes with a Partial specifier.
         * Example: `of button 3 of first card` (which can continue `..of current stack` etc)
         * `first button of first area of stack 3`
         * `first button of area two of stack 3`
         */
        ObjectSpecifier_compoundQueryWithoutTerminal: function(queriedSpecifier, partialSpecifier){
            // if the partialSpecfier refers to either area, card or stack
            // then go to its owner for the context
            // if it refers to the current card then find the owner for the context
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                systemObjectString = "card";
            } else {
                children.forEach((child) => {
                    if(child.ctorName == "systemObject"){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let finalPartial = partialSpecifier.interpret()(finalPart);
            let result = queriedSpecifier.interpret()(finalPartial);
            return result.id;
        },

        /**
         * A single non-terminal ObjectSpecifier is just a Partial
         * specifier by itself. When present outside of a QueriedSpecifier,
         * it will be interpreted in the current context and treated
         * as terminal/final. For example:
         *     button 4
         * by itself as a whole specifier will be interpreted as
         * `button 4 of this card`
         */
        ObjectSpecifier_singleNonTerminal: function(partialSpecifier){
            // A single non-terminal object specifier is one
            // whose terminal object is implicitly assumed to
            // be the card or the stack in which the current context part
            // exists.
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                return systemContext.getCurrentCardModel().id;
            } else {
                children.forEach((child) => {
                    if(child.sourceString == "part" || child.sourceString == "target" || child.ctorName == 'systemObject'){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            // the systemObject is the target (defined in it's "target" part property), then we need to
            // first get the target property value (string) and interpret that
            if(systemObjectString == "target"){
                let targetPropValue = partContext.partProperties.getPropertyNamed(partContext, "target");
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return targetId;
            } else if(systemObjectString == "current card"){
                systemObjectString = "card";
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let result = partialSpecifier.interpret()(finalPart);
            return result.id;
        },

        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let result = terminalSpecifier.interpret()(partContext);
            return result.id;
        },

        anyLiteral: function(theLiteral){
            return theLiteral.interpret();
        },

        stringLiteral: function(openQuote, text, closeQuote){
            return text.sourceString;
        },

        booleanLiteral: function(text){
            if(text.sourceString == 'true'){
                return true;
            }
            if(text.sourceString == 'false'){
                return false;
            }
            throw new Error(`Invalid boolean literal: ${text}`);
        },

        integerLiteral: function(negativeSign, integer){
            let int = parseInt(integer.sourceString);
            let hasNegative = (negativeSign.sourceString == "-");
            if(hasNegative){
                return -1 * int;
            }
            return int; 
        },

        floatLiteral: function(negativeSign, onesPlace, decimal, restPlace){
            let floatString = `${onesPlace.sourceString}.${restPlace.sourceString}`;
            let hasNegative = (negativeSign.sourceString == "-");
            let result = parseFloat(floatString);
            if(hasNegative){
                return -1 * result;
            }
            return result;
        },

        numericalKeyword: function(numeralName){
            switch(numeralName.sourceString){
            case 'first':
                return 1;
            case 'second':
                return 2;
            case 'third':
                return 3;
            case 'fourth':
                return 4;
            case 'fifth':
                return 5;
            case 'sixth':
                return 6;
            case 'seventh':
                return 7;
            case 'eighth':
                return 8;
            case 'ninth':
                return 9;
            case 'tenth':
                return 10;
            }

            return -1;
        },

        variableName: function(letterPlus, optionalDigits){
            // Lookup the variable in the part's
            // current execution context
            // If the variable is not a key on the object,
            // we throw an error: this means the variable has not yet
            // been defined but is being looked up.
            let value = systemContext.executionStack.current.get(this.sourceString);
            if(value == undefined){
                throw new STVariableReferenceError(
                    `Variable ${this.sourceString} has not been defined`);
            }
            return value;
        },

        comment: function(dashesLiteral, nonLineTerminatorChars){
            // Interpret doesn't do anything
            // with comments.
            return null;
        },

        _terminal(){

        }
    };
};





/***/ }),

/***/ "./node_modules/ohm-js/dist/built-in-rules.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/dist/built-in-rules.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = \"0\"..\"9\"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | \"a\"..\"f\"\n    | \"A\"..\"F\"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n}"},"BuiltInRules",null,null,{"alnum":["define",{"sourceInterval":[18,78]},"an alpha-numeric character",[],["alt",{"sourceInterval":[60,78]},["app",{"sourceInterval":[60,66]},"letter",[]],["app",{"sourceInterval":[73,78]},"digit",[]]]],"letter":["define",{"sourceInterval":[82,142]},"a letter",[],["alt",{"sourceInterval":[107,142]},["app",{"sourceInterval":[107,112]},"lower",[]],["app",{"sourceInterval":[119,124]},"upper",[]],["app",{"sourceInterval":[131,142]},"unicodeLtmo",[]]]],"digit":["define",{"sourceInterval":[146,177]},"a digit",[],["range",{"sourceInterval":[169,177]},"0","9"]],"hexDigit":["define",{"sourceInterval":[181,254]},"a hexadecimal digit",[],["alt",{"sourceInterval":[219,254]},["app",{"sourceInterval":[219,224]},"digit",[]],["range",{"sourceInterval":[231,239]},"a","f"],["range",{"sourceInterval":[246,254]},"A","F"]]],"ListOf":["define",{"sourceInterval":[258,336]},null,["elem","sep"],["alt",{"sourceInterval":[282,336]},["app",{"sourceInterval":[282,307]},"NonemptyListOf",[["param",{"sourceInterval":[297,301]},0],["param",{"sourceInterval":[303,306]},1]]],["app",{"sourceInterval":[314,336]},"EmptyListOf",[["param",{"sourceInterval":[326,330]},0],["param",{"sourceInterval":[332,335]},1]]]]],"NonemptyListOf":["define",{"sourceInterval":[340,388]},null,["elem","sep"],["seq",{"sourceInterval":[372,388]},["param",{"sourceInterval":[372,376]},0],["star",{"sourceInterval":[377,388]},["seq",{"sourceInterval":[378,386]},["param",{"sourceInterval":[378,381]},1],["param",{"sourceInterval":[382,386]},0]]]]],"EmptyListOf":["define",{"sourceInterval":[392,434]},null,["elem","sep"],["seq",{"sourceInterval":[438,438]}]],"listOf":["define",{"sourceInterval":[438,516]},null,["elem","sep"],["alt",{"sourceInterval":[462,516]},["app",{"sourceInterval":[462,487]},"nonemptyListOf",[["param",{"sourceInterval":[477,481]},0],["param",{"sourceInterval":[483,486]},1]]],["app",{"sourceInterval":[494,516]},"emptyListOf",[["param",{"sourceInterval":[506,510]},0],["param",{"sourceInterval":[512,515]},1]]]]],"nonemptyListOf":["define",{"sourceInterval":[520,568]},null,["elem","sep"],["seq",{"sourceInterval":[552,568]},["param",{"sourceInterval":[552,556]},0],["star",{"sourceInterval":[557,568]},["seq",{"sourceInterval":[558,566]},["param",{"sourceInterval":[558,561]},1],["param",{"sourceInterval":[562,566]},0]]]]],"emptyListOf":["define",{"sourceInterval":[572,614]},null,["elem","sep"],["seq",{"sourceInterval":[616,616]}]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/ohm-grammar.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/dist/ohm-grammar.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"Ohm {\n\n  Grammars\n    = Grammar*\n\n  Grammar\n    = ident SuperGrammar? \"{\" Rule* \"}\"\n\n  SuperGrammar\n    = \"<:\" ident\n\n  Rule\n    = ident Formals? ruleDescr? \"=\"  RuleBody  -- define\n    | ident Formals?            \":=\" OverrideRuleBody  -- override\n    | ident Formals?            \"+=\" RuleBody  -- extend\n\n  RuleBody\n    = \"|\"? NonemptyListOf<TopLevelTerm, \"|\">\n\n  TopLevelTerm\n    = Seq caseName  -- inline\n    | Seq\n\n  OverrideRuleBody\n    = \"|\"? NonemptyListOf<OverrideTopLevelTerm, \"|\">\n\n  OverrideTopLevelTerm\n    = \"...\"  -- superSplice\n    | TopLevelTerm\n\n  Formals\n    = \"<\" ListOf<ident, \",\"> \">\"\n\n  Params\n    = \"<\" ListOf<Seq, \",\"> \">\"\n\n  Alt\n    = NonemptyListOf<Seq, \"|\">\n\n  Seq\n    = Iter*\n\n  Iter\n    = Pred \"*\"  -- star\n    | Pred \"+\"  -- plus\n    | Pred \"?\"  -- opt\n    | Pred\n\n  Pred\n    = \"~\" Lex  -- not\n    | \"&\" Lex  -- lookahead\n    | Lex\n\n  Lex\n    = \"#\" Base  -- lex\n    | Base\n\n  Base\n    = ident Params? ~(ruleDescr? \"=\" | \":=\" | \"+=\")  -- application\n    | oneCharTerminal \"..\" oneCharTerminal           -- range\n    | terminal                                       -- terminal\n    | \"(\" Alt \")\"                                    -- paren\n\n  ruleDescr  (a rule description)\n    = \"(\" ruleDescrText \")\"\n\n  ruleDescrText\n    = (~\")\" any)*\n\n  caseName\n    = \"--\" (~\"\\n\" space)* name (~\"\\n\" space)* (\"\\n\" | &\"}\")\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n  ident  (an identifier)\n    = name\n\n  terminal\n    = \"\\\"\" terminalChar* \"\\\"\"\n\n  oneCharTerminal\n    = \"\\\"\" terminalChar \"\\\"\"\n\n  terminalChar\n    = escapeChar\n    | ~\"\\\\\" ~\"\\\"\" ~\"\\n\" any\n\n  escapeChar  (an escape sequence)\n    = \"\\\\\\\\\"                                     -- backslash\n    | \"\\\\\\\"\"                                     -- doubleQuote\n    | \"\\\\\\'\"                                     -- singleQuote\n    | \"\\\\b\"                                      -- backspace\n    | \"\\\\n\"                                      -- lineFeed\n    | \"\\\\r\"                                      -- carriageReturn\n    | \"\\\\t\"                                      -- tab\n    | \"\\\\u\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\n    | \"\\\\x\" hexDigit hexDigit                    -- hexEscape\n\n  space\n   += comment\n\n  comment\n    = \"//\" (~\"\\n\" any)* &(\"\\n\" | end)  -- singleLine\n    | \"/*\" (~\"*/\" any)* \"*/\"  -- multiLine\n\n  tokens = token*\n\n  token = caseName | comment | ident | operator | punctuation | terminal | any\n\n  operator = \"<:\" | \"=\" | \":=\" | \"+=\" | \"*\" | \"+\" | \"?\" | \"~\" | \"&\"\n\n  punctuation = \"<\" | \">\" | \",\" | \"--\"\n}"},"Ohm",null,"Grammars",{"Grammars":["define",{"sourceInterval":[9,32]},null,[],["star",{"sourceInterval":[24,32]},["app",{"sourceInterval":[24,31]},"Grammar",[]]]],"Grammar":["define",{"sourceInterval":[36,83]},null,[],["seq",{"sourceInterval":[50,83]},["app",{"sourceInterval":[50,55]},"ident",[]],["opt",{"sourceInterval":[56,69]},["app",{"sourceInterval":[56,68]},"SuperGrammar",[]]],["terminal",{"sourceInterval":[70,73]},"{"],["star",{"sourceInterval":[74,79]},["app",{"sourceInterval":[74,78]},"Rule",[]]],["terminal",{"sourceInterval":[80,83]},"}"]]],"SuperGrammar":["define",{"sourceInterval":[87,116]},null,[],["seq",{"sourceInterval":[106,116]},["terminal",{"sourceInterval":[106,110]},"<:"],["app",{"sourceInterval":[111,116]},"ident",[]]]],"Rule_define":["define",{"sourceInterval":[131,181]},null,[],["seq",{"sourceInterval":[131,170]},["app",{"sourceInterval":[131,136]},"ident",[]],["opt",{"sourceInterval":[137,145]},["app",{"sourceInterval":[137,144]},"Formals",[]]],["opt",{"sourceInterval":[146,156]},["app",{"sourceInterval":[146,155]},"ruleDescr",[]]],["terminal",{"sourceInterval":[157,160]},"="],["app",{"sourceInterval":[162,170]},"RuleBody",[]]]],"Rule_override":["define",{"sourceInterval":[188,248]},null,[],["seq",{"sourceInterval":[188,235]},["app",{"sourceInterval":[188,193]},"ident",[]],["opt",{"sourceInterval":[194,202]},["app",{"sourceInterval":[194,201]},"Formals",[]]],["terminal",{"sourceInterval":[214,218]},":="],["app",{"sourceInterval":[219,235]},"OverrideRuleBody",[]]]],"Rule_extend":["define",{"sourceInterval":[255,305]},null,[],["seq",{"sourceInterval":[255,294]},["app",{"sourceInterval":[255,260]},"ident",[]],["opt",{"sourceInterval":[261,269]},["app",{"sourceInterval":[261,268]},"Formals",[]]],["terminal",{"sourceInterval":[281,285]},"+="],["app",{"sourceInterval":[286,294]},"RuleBody",[]]]],"Rule":["define",{"sourceInterval":[120,305]},null,[],["alt",{"sourceInterval":[131,305]},["app",{"sourceInterval":[131,170]},"Rule_define",[]],["app",{"sourceInterval":[188,235]},"Rule_override",[]],["app",{"sourceInterval":[255,294]},"Rule_extend",[]]]],"RuleBody":["define",{"sourceInterval":[309,362]},null,[],["seq",{"sourceInterval":[324,362]},["opt",{"sourceInterval":[324,328]},["terminal",{"sourceInterval":[324,327]},"|"]],["app",{"sourceInterval":[329,362]},"NonemptyListOf",[["app",{"sourceInterval":[344,356]},"TopLevelTerm",[]],["terminal",{"sourceInterval":[358,361]},"|"]]]]],"TopLevelTerm_inline":["define",{"sourceInterval":[385,408]},null,[],["seq",{"sourceInterval":[385,397]},["app",{"sourceInterval":[385,388]},"Seq",[]],["app",{"sourceInterval":[389,397]},"caseName",[]]]],"TopLevelTerm":["define",{"sourceInterval":[366,418]},null,[],["alt",{"sourceInterval":[385,418]},["app",{"sourceInterval":[385,397]},"TopLevelTerm_inline",[]],["app",{"sourceInterval":[415,418]},"Seq",[]]]],"OverrideRuleBody":["define",{"sourceInterval":[422,491]},null,[],["seq",{"sourceInterval":[445,491]},["opt",{"sourceInterval":[445,449]},["terminal",{"sourceInterval":[445,448]},"|"]],["app",{"sourceInterval":[450,491]},"NonemptyListOf",[["app",{"sourceInterval":[465,485]},"OverrideTopLevelTerm",[]],["terminal",{"sourceInterval":[487,490]},"|"]]]]],"OverrideTopLevelTerm_superSplice":["define",{"sourceInterval":[522,543]},null,[],["terminal",{"sourceInterval":[522,527]},"..."]],"OverrideTopLevelTerm":["define",{"sourceInterval":[495,562]},null,[],["alt",{"sourceInterval":[522,562]},["app",{"sourceInterval":[522,527]},"OverrideTopLevelTerm_superSplice",[]],["app",{"sourceInterval":[550,562]},"TopLevelTerm",[]]]],"Formals":["define",{"sourceInterval":[566,606]},null,[],["seq",{"sourceInterval":[580,606]},["terminal",{"sourceInterval":[580,583]},"<"],["app",{"sourceInterval":[584,602]},"ListOf",[["app",{"sourceInterval":[591,596]},"ident",[]],["terminal",{"sourceInterval":[598,601]},","]]],["terminal",{"sourceInterval":[603,606]},">"]]],"Params":["define",{"sourceInterval":[610,647]},null,[],["seq",{"sourceInterval":[623,647]},["terminal",{"sourceInterval":[623,626]},"<"],["app",{"sourceInterval":[627,643]},"ListOf",[["app",{"sourceInterval":[634,637]},"Seq",[]],["terminal",{"sourceInterval":[639,642]},","]]],["terminal",{"sourceInterval":[644,647]},">"]]],"Alt":["define",{"sourceInterval":[651,685]},null,[],["app",{"sourceInterval":[661,685]},"NonemptyListOf",[["app",{"sourceInterval":[676,679]},"Seq",[]],["terminal",{"sourceInterval":[681,684]},"|"]]]],"Seq":["define",{"sourceInterval":[689,704]},null,[],["star",{"sourceInterval":[699,704]},["app",{"sourceInterval":[699,703]},"Iter",[]]]],"Iter_star":["define",{"sourceInterval":[719,736]},null,[],["seq",{"sourceInterval":[719,727]},["app",{"sourceInterval":[719,723]},"Pred",[]],["terminal",{"sourceInterval":[724,727]},"*"]]],"Iter_plus":["define",{"sourceInterval":[743,760]},null,[],["seq",{"sourceInterval":[743,751]},["app",{"sourceInterval":[743,747]},"Pred",[]],["terminal",{"sourceInterval":[748,751]},"+"]]],"Iter_opt":["define",{"sourceInterval":[767,783]},null,[],["seq",{"sourceInterval":[767,775]},["app",{"sourceInterval":[767,771]},"Pred",[]],["terminal",{"sourceInterval":[772,775]},"?"]]],"Iter":["define",{"sourceInterval":[708,794]},null,[],["alt",{"sourceInterval":[719,794]},["app",{"sourceInterval":[719,727]},"Iter_star",[]],["app",{"sourceInterval":[743,751]},"Iter_plus",[]],["app",{"sourceInterval":[767,775]},"Iter_opt",[]],["app",{"sourceInterval":[790,794]},"Pred",[]]]],"Pred_not":["define",{"sourceInterval":[809,824]},null,[],["seq",{"sourceInterval":[809,816]},["terminal",{"sourceInterval":[809,812]},"~"],["app",{"sourceInterval":[813,816]},"Lex",[]]]],"Pred_lookahead":["define",{"sourceInterval":[831,852]},null,[],["seq",{"sourceInterval":[831,838]},["terminal",{"sourceInterval":[831,834]},"&"],["app",{"sourceInterval":[835,838]},"Lex",[]]]],"Pred":["define",{"sourceInterval":[798,862]},null,[],["alt",{"sourceInterval":[809,862]},["app",{"sourceInterval":[809,816]},"Pred_not",[]],["app",{"sourceInterval":[831,838]},"Pred_lookahead",[]],["app",{"sourceInterval":[859,862]},"Lex",[]]]],"Lex_lex":["define",{"sourceInterval":[876,892]},null,[],["seq",{"sourceInterval":[876,884]},["terminal",{"sourceInterval":[876,879]},"#"],["app",{"sourceInterval":[880,884]},"Base",[]]]],"Lex":["define",{"sourceInterval":[866,903]},null,[],["alt",{"sourceInterval":[876,903]},["app",{"sourceInterval":[876,884]},"Lex_lex",[]],["app",{"sourceInterval":[899,903]},"Base",[]]]],"Base_application":["define",{"sourceInterval":[918,979]},null,[],["seq",{"sourceInterval":[918,963]},["app",{"sourceInterval":[918,923]},"ident",[]],["opt",{"sourceInterval":[924,931]},["app",{"sourceInterval":[924,930]},"Params",[]]],["not",{"sourceInterval":[932,963]},["alt",{"sourceInterval":[934,962]},["seq",{"sourceInterval":[934,948]},["opt",{"sourceInterval":[934,944]},["app",{"sourceInterval":[934,943]},"ruleDescr",[]]],["terminal",{"sourceInterval":[945,948]},"="]],["terminal",{"sourceInterval":[951,955]},":="],["terminal",{"sourceInterval":[958,962]},"+="]]]]],"Base_range":["define",{"sourceInterval":[986,1041]},null,[],["seq",{"sourceInterval":[986,1022]},["app",{"sourceInterval":[986,1001]},"oneCharTerminal",[]],["terminal",{"sourceInterval":[1002,1006]},".."],["app",{"sourceInterval":[1007,1022]},"oneCharTerminal",[]]]],"Base_terminal":["define",{"sourceInterval":[1048,1106]},null,[],["app",{"sourceInterval":[1048,1056]},"terminal",[]]],"Base_paren":["define",{"sourceInterval":[1113,1168]},null,[],["seq",{"sourceInterval":[1113,1124]},["terminal",{"sourceInterval":[1113,1116]},"("],["app",{"sourceInterval":[1117,1120]},"Alt",[]],["terminal",{"sourceInterval":[1121,1124]},")"]]],"Base":["define",{"sourceInterval":[907,1168]},null,[],["alt",{"sourceInterval":[918,1168]},["app",{"sourceInterval":[918,963]},"Base_application",[]],["app",{"sourceInterval":[986,1022]},"Base_range",[]],["app",{"sourceInterval":[1048,1056]},"Base_terminal",[]],["app",{"sourceInterval":[1113,1124]},"Base_paren",[]]]],"ruleDescr":["define",{"sourceInterval":[1172,1231]},"a rule description",[],["seq",{"sourceInterval":[1210,1231]},["terminal",{"sourceInterval":[1210,1213]},"("],["app",{"sourceInterval":[1214,1227]},"ruleDescrText",[]],["terminal",{"sourceInterval":[1228,1231]},")"]]],"ruleDescrText":["define",{"sourceInterval":[1235,1266]},null,[],["star",{"sourceInterval":[1255,1266]},["seq",{"sourceInterval":[1256,1264]},["not",{"sourceInterval":[1256,1260]},["terminal",{"sourceInterval":[1257,1260]},")"]],["app",{"sourceInterval":[1261,1264]},"any",[]]]]],"caseName":["define",{"sourceInterval":[1270,1338]},null,[],["seq",{"sourceInterval":[1285,1338]},["terminal",{"sourceInterval":[1285,1289]},"--"],["star",{"sourceInterval":[1290,1304]},["seq",{"sourceInterval":[1291,1302]},["not",{"sourceInterval":[1291,1296]},["terminal",{"sourceInterval":[1292,1296]},"\n"]],["app",{"sourceInterval":[1297,1302]},"space",[]]]],["app",{"sourceInterval":[1305,1309]},"name",[]],["star",{"sourceInterval":[1310,1324]},["seq",{"sourceInterval":[1311,1322]},["not",{"sourceInterval":[1311,1316]},["terminal",{"sourceInterval":[1312,1316]},"\n"]],["app",{"sourceInterval":[1317,1322]},"space",[]]]],["alt",{"sourceInterval":[1326,1337]},["terminal",{"sourceInterval":[1326,1330]},"\n"],["lookahead",{"sourceInterval":[1333,1337]},["terminal",{"sourceInterval":[1334,1337]},"}"]]]]],"name":["define",{"sourceInterval":[1342,1382]},"a name",[],["seq",{"sourceInterval":[1363,1382]},["app",{"sourceInterval":[1363,1372]},"nameFirst",[]],["star",{"sourceInterval":[1373,1382]},["app",{"sourceInterval":[1373,1381]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[1386,1418]},null,[],["alt",{"sourceInterval":[1402,1418]},["terminal",{"sourceInterval":[1402,1405]},"_"],["app",{"sourceInterval":[1412,1418]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[1422,1452]},null,[],["alt",{"sourceInterval":[1437,1452]},["terminal",{"sourceInterval":[1437,1440]},"_"],["app",{"sourceInterval":[1447,1452]},"alnum",[]]]],"ident":["define",{"sourceInterval":[1456,1489]},"an identifier",[],["app",{"sourceInterval":[1485,1489]},"name",[]]],"terminal":["define",{"sourceInterval":[1493,1531]},null,[],["seq",{"sourceInterval":[1508,1531]},["terminal",{"sourceInterval":[1508,1512]},"\""],["star",{"sourceInterval":[1513,1526]},["app",{"sourceInterval":[1513,1525]},"terminalChar",[]]],["terminal",{"sourceInterval":[1527,1531]},"\""]]],"oneCharTerminal":["define",{"sourceInterval":[1535,1579]},null,[],["seq",{"sourceInterval":[1557,1579]},["terminal",{"sourceInterval":[1557,1561]},"\""],["app",{"sourceInterval":[1562,1574]},"terminalChar",[]],["terminal",{"sourceInterval":[1575,1579]},"\""]]],"terminalChar":["define",{"sourceInterval":[1583,1640]},null,[],["alt",{"sourceInterval":[1602,1640]},["app",{"sourceInterval":[1602,1612]},"escapeChar",[]],["seq",{"sourceInterval":[1619,1640]},["not",{"sourceInterval":[1619,1624]},["terminal",{"sourceInterval":[1620,1624]},"\\"]],["not",{"sourceInterval":[1625,1630]},["terminal",{"sourceInterval":[1626,1630]},"\""]],["not",{"sourceInterval":[1631,1636]},["terminal",{"sourceInterval":[1632,1636]},"\n"]],["app",{"sourceInterval":[1637,1640]},"any",[]]]]],"escapeChar_backslash":["define",{"sourceInterval":[1683,1738]},null,[],["terminal",{"sourceInterval":[1683,1689]},"\\\\"]],"escapeChar_doubleQuote":["define",{"sourceInterval":[1745,1802]},null,[],["terminal",{"sourceInterval":[1745,1751]},"\\\""]],"escapeChar_singleQuote":["define",{"sourceInterval":[1809,1866]},null,[],["terminal",{"sourceInterval":[1809,1815]},"\\'"]],"escapeChar_backspace":["define",{"sourceInterval":[1873,1928]},null,[],["terminal",{"sourceInterval":[1873,1878]},"\\b"]],"escapeChar_lineFeed":["define",{"sourceInterval":[1935,1989]},null,[],["terminal",{"sourceInterval":[1935,1940]},"\\n"]],"escapeChar_carriageReturn":["define",{"sourceInterval":[1996,2056]},null,[],["terminal",{"sourceInterval":[1996,2001]},"\\r"]],"escapeChar_tab":["define",{"sourceInterval":[2063,2112]},null,[],["terminal",{"sourceInterval":[2063,2068]},"\\t"]],"escapeChar_unicodeEscape":["define",{"sourceInterval":[2119,2178]},null,[],["seq",{"sourceInterval":[2119,2160]},["terminal",{"sourceInterval":[2119,2124]},"\\u"],["app",{"sourceInterval":[2125,2133]},"hexDigit",[]],["app",{"sourceInterval":[2134,2142]},"hexDigit",[]],["app",{"sourceInterval":[2143,2151]},"hexDigit",[]],["app",{"sourceInterval":[2152,2160]},"hexDigit",[]]]],"escapeChar_hexEscape":["define",{"sourceInterval":[2185,2240]},null,[],["seq",{"sourceInterval":[2185,2208]},["terminal",{"sourceInterval":[2185,2190]},"\\x"],["app",{"sourceInterval":[2191,2199]},"hexDigit",[]],["app",{"sourceInterval":[2200,2208]},"hexDigit",[]]]],"escapeChar":["define",{"sourceInterval":[1644,2240]},"an escape sequence",[],["alt",{"sourceInterval":[1683,2240]},["app",{"sourceInterval":[1683,1689]},"escapeChar_backslash",[]],["app",{"sourceInterval":[1745,1751]},"escapeChar_doubleQuote",[]],["app",{"sourceInterval":[1809,1815]},"escapeChar_singleQuote",[]],["app",{"sourceInterval":[1873,1878]},"escapeChar_backspace",[]],["app",{"sourceInterval":[1935,1940]},"escapeChar_lineFeed",[]],["app",{"sourceInterval":[1996,2001]},"escapeChar_carriageReturn",[]],["app",{"sourceInterval":[2063,2068]},"escapeChar_tab",[]],["app",{"sourceInterval":[2119,2160]},"escapeChar_unicodeEscape",[]],["app",{"sourceInterval":[2185,2208]},"escapeChar_hexEscape",[]]]],"space":["extend",{"sourceInterval":[2244,2263]},null,[],["app",{"sourceInterval":[2256,2263]},"comment",[]]],"comment_singleLine":["define",{"sourceInterval":[2281,2327]},null,[],["seq",{"sourceInterval":[2281,2312]},["terminal",{"sourceInterval":[2281,2285]},"//"],["star",{"sourceInterval":[2286,2298]},["seq",{"sourceInterval":[2287,2296]},["not",{"sourceInterval":[2287,2292]},["terminal",{"sourceInterval":[2288,2292]},"\n"]],["app",{"sourceInterval":[2293,2296]},"any",[]]]],["lookahead",{"sourceInterval":[2299,2312]},["alt",{"sourceInterval":[2301,2311]},["terminal",{"sourceInterval":[2301,2305]},"\n"],["app",{"sourceInterval":[2308,2311]},"end",[]]]]]],"comment_multiLine":["define",{"sourceInterval":[2334,2370]},null,[],["seq",{"sourceInterval":[2334,2356]},["terminal",{"sourceInterval":[2334,2338]},"/*"],["star",{"sourceInterval":[2339,2351]},["seq",{"sourceInterval":[2340,2349]},["not",{"sourceInterval":[2340,2345]},["terminal",{"sourceInterval":[2341,2345]},"*/"]],["app",{"sourceInterval":[2346,2349]},"any",[]]]],["terminal",{"sourceInterval":[2352,2356]},"*/"]]],"comment":["define",{"sourceInterval":[2267,2370]},null,[],["alt",{"sourceInterval":[2281,2370]},["app",{"sourceInterval":[2281,2312]},"comment_singleLine",[]],["app",{"sourceInterval":[2334,2356]},"comment_multiLine",[]]]],"tokens":["define",{"sourceInterval":[2374,2389]},null,[],["star",{"sourceInterval":[2383,2389]},["app",{"sourceInterval":[2383,2388]},"token",[]]]],"token":["define",{"sourceInterval":[2393,2469]},null,[],["alt",{"sourceInterval":[2401,2469]},["app",{"sourceInterval":[2401,2409]},"caseName",[]],["app",{"sourceInterval":[2412,2419]},"comment",[]],["app",{"sourceInterval":[2422,2427]},"ident",[]],["app",{"sourceInterval":[2430,2438]},"operator",[]],["app",{"sourceInterval":[2441,2452]},"punctuation",[]],["app",{"sourceInterval":[2455,2463]},"terminal",[]],["app",{"sourceInterval":[2466,2469]},"any",[]]]],"operator":["define",{"sourceInterval":[2473,2538]},null,[],["alt",{"sourceInterval":[2484,2538]},["terminal",{"sourceInterval":[2484,2488]},"<:"],["terminal",{"sourceInterval":[2491,2494]},"="],["terminal",{"sourceInterval":[2497,2501]},":="],["terminal",{"sourceInterval":[2504,2508]},"+="],["terminal",{"sourceInterval":[2511,2514]},"*"],["terminal",{"sourceInterval":[2517,2520]},"+"],["terminal",{"sourceInterval":[2523,2526]},"?"],["terminal",{"sourceInterval":[2529,2532]},"~"],["terminal",{"sourceInterval":[2535,2538]},"&"]]],"punctuation":["define",{"sourceInterval":[2542,2578]},null,[],["alt",{"sourceInterval":[2556,2578]},["terminal",{"sourceInterval":[2556,2559]},"<"],["terminal",{"sourceInterval":[2562,2565]},">"],["terminal",{"sourceInterval":[2568,2571]},","],["terminal",{"sourceInterval":[2574,2578]},"--"]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/operations-and-attributes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ohm-js/dist/operations-and-attributes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = \"(\" ListOf<name, \",\"> \")\"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n}"},"OperationsAndAttributes",null,"AttributeSignature",{"AttributeSignature":["define",{"sourceInterval":[29,58]},null,[],["app",{"sourceInterval":[54,58]},"name",[]]],"OperationSignature":["define",{"sourceInterval":[62,100]},null,[],["seq",{"sourceInterval":[87,100]},["app",{"sourceInterval":[87,91]},"name",[]],["opt",{"sourceInterval":[92,100]},["app",{"sourceInterval":[92,99]},"Formals",[]]]]],"Formals":["define",{"sourceInterval":[104,143]},null,[],["seq",{"sourceInterval":[118,143]},["terminal",{"sourceInterval":[118,121]},"("],["app",{"sourceInterval":[122,139]},"ListOf",[["app",{"sourceInterval":[129,133]},"name",[]],["terminal",{"sourceInterval":[135,138]},","]]],["terminal",{"sourceInterval":[140,143]},")"]]],"name":["define",{"sourceInterval":[147,187]},"a name",[],["seq",{"sourceInterval":[168,187]},["app",{"sourceInterval":[168,177]},"nameFirst",[]],["star",{"sourceInterval":[178,187]},["app",{"sourceInterval":[178,186]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[191,223]},null,[],["alt",{"sourceInterval":[207,223]},["terminal",{"sourceInterval":[207,210]},"_"],["app",{"sourceInterval":[217,223]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[227,257]},null,[],["alt",{"sourceInterval":[242,257]},["terminal",{"sourceInterval":[242,245]},"_"],["app",{"sourceInterval":[252,257]},"alnum",[]]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/extras/VisitorFamily.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/extras/VisitorFamily.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ../src/common */ "./node_modules/ohm-js/src/common.js").assert;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Helpers

function getProp(name, thing, fn) {
  return fn(thing[name]);
}

function mapProp(name, thing, fn) {
  return thing[name].map(fn);
}

// Returns a function that will walk a single property of a node.
// `descriptor` is a string indicating the property name, optionally ending
// with '[]' (e.g., 'children[]').
function getPropWalkFn(descriptor) {
  const parts = descriptor.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor);
}

function getProps(walkFns, thing, fn) {
  return walkFns.map(walkFn => walkFn(thing, fn));
}

function getWalkFn(shape) {
  if (typeof shape === 'string') {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === 'function', 'Expected a string, Array, or function');
    assert(shape.length === 2, 'Expected a function of arity 2, got ' + shape.length);
    return shape;
  }
}

function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}

function trim(s) {
  return s.trim();
}

function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === '') {
    const name = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(',').map(trim);
    }
    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {
      return {name, formals: params};
    }
  }
  throw new Error('Invalid operation signature: ' + sig);
}

/*
  A VisitorFamily contains a set of recursive operations that are defined over some kind of
  tree structure. The `config` parameter specifies how to walk the tree:
  - 'getTag' is function which, given a node in the tree, returns the node's 'tag' (type)
  - 'shapes' an object that maps from a tag to a value that describes how to recursively
    evaluate the operation for nodes of that type. The value can be:
    * a string indicating the property name that holds that node's only child
    * an Array of property names (or an empty array indicating a leaf type), or
    * a function taking two arguments (node, fn), and returning an Array which is the result
      of apply `fn` to each of the node's children.
 */
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;

  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error('heeey!');
  };
  this.operations = {};

  this._arities = Object.create(null);
  this._getChildren = Object.create(null);

  const self = this;
  Object.keys(this._shapes).forEach(k => {
    const shape = self._shapes[k];
    self._getChildren[k] = getWalkFn(shape);

    // A function means the arity isn't fixed, so don't put an entry in the arity map.
    if (typeof shape !== 'function') {
      self._arities[k] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = function(thing) { return new self.Adapter(thing, self); };
}

VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};

VisitorFamily.prototype._checkActionDict = function(dict) {
  const self = this;
  Object.keys(dict).forEach(k => {
    assert(k in self._getChildren, "Unrecognized action name '" + k + "'");
    const action = dict[k];
    assert(typeof action === 'function', "Key '" + k + "': expected function, got " + action);
    if (k in self._arities) {
      const expected = self._arities[k];
      const actual = dict[k].length;
      assert(actual === expected,
          "Action '" + k + "' has the wrong arity: expected " + expected + ', got ' + actual);
    }
  });
};

VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const name = sig.name;
  this._checkActionDict(actions);
  this.operations[name] = {
    name,
    formals: sig.formals,
    actions
  };

  const family = this;
  this.Adapter.prototype[name] = function() {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name + "'");

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let i = 0; i < arguments.length; i++) {
      args[sig.formals[i]] = arguments[i];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = actions[tag].apply(this, family._getChildren[tag](this._adaptee, family._wrap));
    this.args = oldArgs;
    return ans;
  };
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = VisitorFamily;


/***/ }),

/***/ "./node_modules/ohm-js/extras/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/extras/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  VisitorFamily: __webpack_require__(/*! ./VisitorFamily */ "./node_modules/ohm-js/extras/VisitorFamily.js"),
  semanticsForToAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").semantics,
  toAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").helper
};


/***/ }),

/***/ "./node_modules/ohm-js/extras/semantics-toAST.js":
/*!*******************************************************!*\
  !*** ./node_modules/ohm-js/extras/semantics-toAST.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ../src/pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const MatchResult = __webpack_require__(/*! ../src/MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const Grammar = __webpack_require__(/*! ../src/Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

const defaultOperation = {
  _terminal() {
    return this.primitiveValue;
  },

  _nonterminal(children) {
    const ctorName = this._node.ctorName;
    const mapping = this.args.mapping;

    // without customization
    if (!mapping.hasOwnProperty(ctorName)) {
      // intermediate node
      if (this._node instanceof pexprs.Alt || this._node instanceof pexprs.Apply) {
        return children[0].toAST(mapping);
      }

      // lexical rule
      if (this.isLexical()) {
        return this.sourceString;
      }

      // singular node (e.g. only surrounded by literals or lookaheads)
      const realChildren = children.filter(child => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }

      // rest: terms with multiple children
    }

    // direct forward
    if (typeof mapping[ctorName] === 'number') {
      return children[mapping[ctorName]].toAST(mapping);
    }

    // named/mapped children or unnamed children ('0', '1', '2', ...)
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === 'number') {
        // direct forward
        node[prop] = children[mappedProp].toAST(mapping);
      } else if ((typeof mappedProp === 'string') || (typeof mappedProp === 'boolean') ||
          (mappedProp === null)) {
        // primitive value
        node[prop] = mappedProp;
      } else if ((typeof mappedProp === 'object') && (mappedProp instanceof Number)) {
        // primitive number (must be unboxed)
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === 'function') {
        // computed value
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === undefined) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          // delete predefined 'type' properties, like 'type', if explicitely removed
          delete node[prop];
        }
      }
    }
    return node;
  },

  _iter(children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }

    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },

  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },

  EmptyListOf() {
    return [];
  }
};

// Returns a plain JavaScript object that includes an abstract syntax tree (AST)
// for the given match result `res` containg a concrete syntax tree (CST) and grammar.
// The optional `mapping` parameter can be used to customize how the nodes of the CST
// are mapped to the AST (see /doc/extras.md#toastmatchresult-mapping).
function toAST(res, mapping) {
  if (!(res instanceof MatchResult) || res.failed()) {
    throw new Error('toAST() expects a succesfull MatchResult as first parameter');
  }

  mapping = extend({}, mapping);
  const operation = extend({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === 'function') {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g = res._cst.grammar;
  const s = g.createSemantics().addOperation('toAST(mapping)', operation);
  return s(res).toAST(mapping);
}

// Returns a semantics containg the toAST(mapping) operation for the given grammar g.
function semanticsForToAST(g) {
  if (!(g instanceof Grammar)) {
    throw new Error('semanticsToAST() expects a Grammar as parameter');
  }

  return g.createSemantics().addOperation('toAST(mapping)', defaultOperation);
}

module.exports = {
  helper: toAST,
  semantics: semanticsForToAST
};


/***/ }),

/***/ "./node_modules/ohm-js/node_modules/is-buffer/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ohm-js/node_modules/is-buffer/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "./node_modules/ohm-js/package.json":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/package.json ***!
  \******************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bin, bugs, contributors, dependencies, description, devDependencies, engines, homepage, keywords, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_args\":[[\"ohm-js@15.4.1\",\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\"]],\"_from\":\"ohm-js@15.4.1\",\"_id\":\"ohm-js@15.4.1\",\"_inBundle\":false,\"_integrity\":\"sha512-ob5b6hnlg6tR73Zxd8ON/MQND36SgEDbKQYrzdDVVyTNa3d3aJ/YyobB7mItJ8YXNTZGgZ/eUiLtfo2CU0uREA==\",\"_location\":\"/ohm-js\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"ohm-js@15.4.1\",\"name\":\"ohm-js\",\"escapedName\":\"ohm-js\",\"rawSpec\":\"15.4.1\",\"saveSpec\":null,\"fetchSpec\":\"15.4.1\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/ohm-js/-/ohm-js-15.4.1.tgz\",\"_spec\":\"15.4.1\",\"_where\":\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\",\"author\":{\"name\":\"Alex Warth\",\"email\":\"alexwarth@gmail.com\",\"url\":\"http://tinlizzie.org/~awarth\"},\"bin\":{\"ohm-js\":\"src/ohm-cmd.js\"},\"bugs\":{\"url\":\"https://github.com/harc/ohm/issues\"},\"contributors\":[{\"name\":\"Patrick Dubroy\",\"email\":\"pdubroy@gmail.com\"},{\"name\":\"Meixian Li\",\"email\":\"lmeixian@gmail.com\"},{\"name\":\"Marko Röder\",\"email\":\"m.roeder@photon-software.de\"},{\"name\":\"Tony Garnock-Jones\",\"email\":\"tonygarnockjones@gmail.com\"},{\"name\":\"Saketh Kasibatla\",\"email\":\"sake.kasi@gmail.com\"},{\"name\":\"Lionel Landwerlin\",\"email\":\"llandwerlin@gmail.com\"},{\"name\":\"Jason Merrill\",\"email\":\"jwmerrill@gmail.com\"},{\"name\":\"Ray Toal\",\"email\":\"rtoal@lmu.edu\"},{\"name\":\"Yoshiki Ohshima\",\"email\":\"Yoshiki.Ohshima@acm.org\"},{\"name\":\"stagas\",\"email\":\"gstagas@gmail.com\"},{\"name\":\"Jonathan Edwards\",\"email\":\"JonathanMEdwards@gmail.com\"},{\"name\":\"Neil Jewers\",\"email\":\"njjewers@uwaterloo.ca\"},{\"name\":\"Mike Niebling\",\"email\":\"(none)\",\"url\":\"none\"},{\"name\":\"Arthur Carabott\",\"email\":\"arthurc@gmail.com\"},{\"name\":\"AngryPowman\",\"email\":\"angrypowman@qq.com\"},{\"name\":\"Luca Guzzon\",\"email\":\"luca.guzzon@gmail.com\"},{\"name\":\"Leslie Ying\",\"email\":\"acetophore@users.noreply.github.com\"},{\"name\":\"Stan Rozenraukh\",\"email\":\"stan@stanistan.com\"},{\"name\":\"Stephan Seidt\",\"email\":\"stephan.seidt@gmail.com\"},{\"name\":\"Thomas Nyberg\",\"email\":\"tomnyberg@gmail.com\"},{\"name\":\"Justin Chase\",\"email\":\"justin.m.chase@gmail.com\"},{\"name\":\"Vse Mozhet Byt\",\"email\":\"vsemozhetbyt@gmail.com\"},{\"name\":\"Wil Chung\",\"email\":\"10446+iamwilhelm@users.noreply.github.com\"},{\"name\":\"Daniel Tomlinson\",\"email\":\"DanielTomlinson@me.com\"},{\"name\":\"abego\",\"email\":\"ub@abego-software.de\"},{\"name\":\"acslk\",\"email\":\"d_vd415@hotmail.com\"},{\"name\":\"codeZeilen\",\"email\":\"codeZeilen@users.noreply.github.com\"},{\"name\":\"owch\",\"email\":\"bowenrainyday@gmail.com\"},{\"name\":\"sfinnie\",\"email\":\"scott.finnie@gmail.com\"},{\"name\":\"Milan Lajtoš\",\"email\":\"milan.lajtos@me.com\"}],\"dependencies\":{\"is-buffer\":\"^2.0.4\",\"util-extend\":\"^1.0.3\"},\"description\":\"An object-oriented language for parsing and pattern matching\",\"devDependencies\":{\"@types/tape\":\"^4.13.0\",\"eslint\":\"^7.9.0\",\"eslint-config-google\":\"^0.14.0\",\"eslint-plugin-camelcase-ohm\":\"^0.2.1\",\"eslint-plugin-no-extension-in-require\":\"^0.2.0\",\"eslint-plugin-tape\":\"^1.1.0\",\"husky\":\"^4.2.5\",\"jsdom\":\"^9.9.1\",\"json\":\"^9.0.6\",\"markscript\":\"^0.5.0\",\"node-static\":\"^0.7.11\",\"nodemon\":\"^2.0.4\",\"ohm-grammar-ecmascript\":\"^0.5.0\",\"tap-spec\":\"^5.0.0\",\"tape\":\"^5.0.1\",\"tape-catch\":\"^1.0.6\",\"ts-loader\":\"^8.0.4\",\"ts-node\":\"^9.0.0\",\"typescript\":\"^4.0.3\",\"walk-sync\":\"^2.2.0\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^3.3.12\"},\"engines\":{\"node\":\">=0.12.1\"},\"homepage\":\"https://ohmlang.github.io/\",\"keywords\":[\"parser\",\"compiler\",\"pattern matching\",\"pattern-matching\",\"ometa\",\"ometa/js\",\"ometa-js\",\"ometajs\",\"rapid\",\"prototyping\"],\"license\":\"MIT\",\"main\":\"src/main.js\",\"name\":\"ohm-js\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/harc/ohm.git\"},\"scripts\":{\"bootstrap\":\"bash bin/bootstrap --test || (echo 'Bootstrap failed.' && mv -v dist/ohm-grammar.js.old dist/ohm-grammar.js && mv -v dist/built-in-rules.js.old dist/built-in-rules.js && mv -v dist/operations-and-attributes.js.old dist/operations-and-attributes.js)\",\"build\":\"yarn build-debug && webpack --mode=production\",\"build-debug\":\"webpack --mode=development\",\"clean\":\"rm -f dist/ohm.js dist/ohm.min.js\",\"lint\":\"eslint . --ignore-path ../.eslintignore\",\"postinstall\":\"node bin/dev-setup.js\",\"postpublish\":\"rm README.md\",\"pre-commit\":\"yarn run lint && yarn run build && yarn run test\",\"prebootstrap\":\"bash bin/prebootstrap\",\"prebuild-debug\":\"bash ../bin/update-env.sh\",\"prepublishOnly\":\"cp ../README.md .\",\"pretest\":\"bash ../bin/update-env.sh\",\"test\":\"(tape 'test/**/*.js' | tap-spec) && ts-node test/test-typings.ts\",\"test-watch\":\"bash bin/test-watch\",\"unsafe-bootstrap\":\"bash bin/bootstrap\",\"version-package\":\"bash bin/version\",\"watch\":\"webpack --mode=development --watch\"},\"types\":\"index.d.ts\",\"version\":\"15.4.1\"}");

/***/ }),

/***/ "./node_modules/ohm-js/src/Builder.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Builder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const GrammarDecl = __webpack_require__(/*! ./GrammarDecl */ "./node_modules/ohm-js/src/GrammarDecl.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Builder() {}

Builder.prototype = {
  currentDecl: null,
  currentRuleName: null,

  newGrammar(name) {
    return new GrammarDecl(name);
  },

  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name);
    if (superGrammar) {
      gDecl.withSuperGrammar(this.fromRecipe(superGrammar));
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }

    this.currentDecl = gDecl;
    Object.keys(rules).forEach(ruleName => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];

      const action = ruleRecipe[0]; // define/extend/override
      const metaInfo = ruleRecipe[1];
      const description = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);

      let source;
      if (gDecl.source && metaInfo && metaInfo.sourceInterval) {
        source = gDecl.source.subInterval(
            metaInfo.sourceInterval[0],
            metaInfo.sourceInterval[1] - metaInfo.sourceInterval[0]);
      }
      gDecl[action](ruleName, formals, body, description, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },

  terminal(x) {
    return new pexprs.Terminal(x);
  },

  range(from, to) {
    return new pexprs.Range(from, to);
  },

  param(index) {
    return new pexprs.Param(index);
  },

  alt(/* term1, term2, ... */) {
    let terms = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs.Alt(terms);
  },

  seq(/* factor1, factor2, ... */) {
    let factors = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs.Seq(factors);
  },

  star(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Star(expr);
  },

  plus(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Plus(expr);
  },

  opt(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Opt(expr);
  },

  not(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Not(expr);
  },

  la(expr) {
    // TODO: temporary to still be able to read old recipes
    return this.lookahead(expr);
  },

  lookahead(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lookahead(expr);
  },

  lex(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lex(expr);
  },

  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs.PExpr ? param :
          this.fromRecipe(param);
      }, this);
    }
    return new pexprs.Apply(ruleName, optParams);
  },

  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs.Splice(
        this.currentDecl.superGrammar,
        this.currentRuleName,
        beforeTerms.map(term => this.fromRecipe(term)),
        afterTerms.map(term => this.fromRecipe(term)));
  },

  fromRecipe(recipe) {
    // the meta-info of 'grammar' is processed in Builder.grammar
    const result = this[recipe[0]].apply(this,
      recipe[0] === 'grammar' ? recipe.slice(1) : recipe.slice(2));

    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(
            this.currentDecl.sourceInterval.apply(this.currentDecl, metaInfo.sourceInterval)
        );
      }
    }
    return result;
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Builder;


/***/ }),

/***/ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/CaseInsensitiveTerminal.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const TerminalNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").TerminalNode;
const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const {PExpr, Terminal} = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

class CaseInsensitiveTerminal extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }

  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert(terminal instanceof Terminal, 'expected a Terminal expression');
    return terminal.obj;
  }

  // Implementation of the PExpr API

  allowsSkippingPrecedingSpace() {
    return true;
  }

  eval(state) {
    const inputStream = state.inputStream;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(state.grammar, matchStr), origPos);
      return true;
    }
  }

  generateExample(grammar, examples, inSyntacticContext, actuals) {
    // Start with a example generated from the Terminal...
    const str = this.obj.generateExample(grammar, examples, inSyntacticContext, actuals).value;

    // ...and randomly switch characters to uppercase/lowercase.
    let value = '';
    for (let i = 0; i < str.length; ++i) {
      value += Math.random() < 0.5 ? str[i].toLocaleLowerCase() : str[i].toLocaleUpperCase();
    }
    return {value};
  }

  getArity() {
    return 1;
  }

  substituteParams(actuals) {
    return new CaseInsensitiveTerminal(this.obj.substituteParams(actuals));
  }

  toDisplayString() {
    return this.obj.toDisplayString() + ' (case-insensitive)';
  }

  toFailure(grammar) {
    return new Failure(this, this.obj.toFailure(grammar) + ' (case-insensitive)', 'description');
  }

  _isNullable(grammar, memo) {
    return this.obj._isNullable(grammar, memo);
  }
}

module.exports = CaseInsensitiveTerminal;


/***/ }),

/***/ "./node_modules/ohm-js/src/Failure.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Failure.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

/*
  `Failure`s represent expressions that weren't matched while parsing. They are used to generate
  error messages automatically. The interface of `Failure`s includes the collowing methods:

  - getText() : String
  - getType() : String  (one of {"description", "string", "code"})
  - isDescription() : bool
  - isStringTerminal() : bool
  - isCode() : bool
  - isFluffy() : bool
  - makeFluffy() : void
  - subsumes(Failure) : bool
*/

function isValidType(type) {
  return type === 'description' || type === 'string' || type === 'code';
}

function Failure(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error('invalid Failure type: ' + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}

Failure.prototype.getPExpr = function() {
  return this.pexpr;
};

Failure.prototype.getText = function() {
  return this.text;
};

Failure.prototype.getType = function() {
  return this.type;
};

Failure.prototype.isDescription = function() {
  return this.type === 'description';
};

Failure.prototype.isStringTerminal = function() {
  return this.type === 'string';
};

Failure.prototype.isCode = function() {
  return this.type === 'code';
};

Failure.prototype.isFluffy = function() {
  return this.fluffy;
};

Failure.prototype.makeFluffy = function() {
  this.fluffy = true;
};

Failure.prototype.clearFluffy = function() {
  this.fluffy = false;
};

Failure.prototype.subsumes = function(that) {
  return this.getText() === that.getText() &&
      this.type === that.type &&
      (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};

Failure.prototype.toString = function() {
  return this.type === 'string' ?
    JSON.stringify(this.getText()) :
    this.getText();
};

Failure.prototype.clone = function() {
  const failure = new Failure(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};

Failure.prototype.toKey = function() {
  return this.toString() + '#' + this.type;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Failure;


/***/ }),

/***/ "./node_modules/ohm-js/src/Grammar.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Grammar.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const CaseInsensitiveTerminal = __webpack_require__(/*! ./CaseInsensitiveTerminal */ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js");
const Matcher = __webpack_require__(/*! ./Matcher */ "./node_modules/ohm-js/src/Matcher.js");
const Semantics = __webpack_require__(/*! ./Semantics */ "./node_modules/ohm-js/src/Semantics.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getSortedRuleValues(grammar) {
  return Object.keys(grammar.rules).sort().map(name => grammar.rules[name]);
}

function Grammar(
    name,
    superGrammar,
    rules,
    optDefaultStartRule) {
  this.name = name;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error("Invalid start rule: '" + optDefaultStartRule +
                      "' is not a rule in grammar '" + name + "'");
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}

let ohmGrammar;
let buildGrammar;

// This method is called from main.js once Ohm has loaded.
Grammar.initApplicationParser = function(grammar, builderFn) {
  ohmGrammar = grammar;
  buildGrammar = builderFn;
};

Grammar.prototype = {
  matcher() {
    return new Matcher(this);
  },

  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;
  },

  equals(g) {
    if (this === g) {
      return true;
    }
    // Do the cheapest comparisons first.
    if (g == null ||
        this.name !== g.name ||
        this.defaultStartRule !== g.defaultStartRule ||
        !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description &&
             rule.formals.join(',') === otherRules[i].formals.join(',') &&
             rule.body.toString() === otherRules[i].body.toString();
    });
  },

  match(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.match(optStartApplication);
  },

  trace(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.trace(optStartApplication);
  },

  semantics() {
    // TODO: Remove this eventually! Deprecated in v0.12.
    throw new Error('semantics() is deprecated -- use createSemantics() instead.');
  },

  createSemantics() {
    return Semantics.createSemantics(this);
  },

  extendSemantics(superSemantics) {
    return Semantics.createSemantics(this, superSemantics._getSemantics());
  },

  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name, actionDict) {
    function isSpecialAction(a) {
      return a === '_iter' || a === '_terminal' || a === '_nonterminal' || a === '_default';
    }

    const problems = [];
    for (const k in actionDict) {
      const v = actionDict[k];
      if (!isSpecialAction(k) && !(k in this.rules)) {
        problems.push("'" + k + "' is not a valid semantic action for '" + this.name + "'");
      } else if (typeof v !== 'function') {
        problems.push(
            "'" + k + "' must be a function in an action dictionary for '" + this.name + "'");
      } else {
        const actual = v.length;
        const expected = this._topDownActionArity(k);
        if (actual !== expected) {
          problems.push(
              "Semantic action '" + k + "' has the wrong arity: " +
              'expected ' + expected + ', got ' + actual);
        }
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map(problem => '- ' + problem);
      const error = new Error(
          "Found errors in the action dictionary of the '" + name + "' " + what + ':\n' +
          prettyProblems.join('\n'));
      error.problems = problems;
      throw error;
    }
  },

  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    if (actionName === '_iter' || actionName === '_nonterminal' || actionName === '_default') {
      return 1;
    } else if (actionName === '_terminal') {
      return 0;
    }
    return this.rules[actionName].body.getArity();
  },

  _inheritsFrom(grammar) {
    let g = this.superGrammar;
    while (g) {
      if (g.equals(grammar, true)) {
        return true;
      }
      g = g.superGrammar;
    }
    return false;
  },

  toRecipe(optVarName) {
    const metaInfo = {};
    // Include the grammar source if it is available.
    if (this.source) {
      metaInfo.source = this.source.contents;
    }

    let superGrammar = null;
    if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammar = JSON.parse(this.superGrammar.toRecipe());
    }

    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }

    const rules = {};
    const self = this;
    Object.keys(this.rules).forEach(ruleName => {
      const ruleInfo = self.rules[ruleName];
      const body = ruleInfo.body;
      const isDefinition = !self.superGrammar || !self.superGrammar.rules[ruleName];

      let operation;
      if (isDefinition) {
        operation = 'define';
      } else {
        operation = body instanceof pexprs.Extend ? 'extend' : 'override';
      }

      const metaInfo = {};
      if (ruleInfo.source && self.source) {
        const adjusted = ruleInfo.source.relativeTo(self.source);
        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }

      const description = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, self.source);

      rules[ruleName] = [
        operation, // "define"/"extend"/"override"
        metaInfo,
        description,
        ruleInfo.formals,
        bodyRecipe
      ];
    });

    return JSON.stringify([
      'grammar',
      metaInfo,
      this.name,
      superGrammar,
      startRule,
      rules
    ]);
  },

  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },

  _toOperationOrAttributeActionDictionaryTemplate() {
    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus
    // should appear next to other cases of AddExpr.

    const sb = new common.StringBuffer();
    sb.append('{');

    let first = true;
    for (const ruleName in this.rules) {
      const body = this.rules[ruleName].body;
      if (first) {
        first = false;
      } else {
        sb.append(',');
      }
      sb.append('\n');
      sb.append('  ');
      this.addSemanticActionTemplate(ruleName, body, sb);
    }

    sb.append('\n}');
    return sb.contents();
  },

  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(': function(');
    const arity = this._topDownActionArity(ruleName);
    sb.append(common.repeat('_', arity).join(', '));
    sb.append(') {\n');
    sb.append('  }');
  },

  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf('<') === -1) {
      // simple application
      app = new pexprs.Apply(str);
    } else {
      // parameterized application
      const cst = ohmGrammar.match(str, 'Base_application');
      app = buildGrammar(cst, {});
    }

    // Ensure that the application is valid.
    if (!(app.ruleName in this.rules)) {
      throw errors.undeclaredRule(app.ruleName, this.name);
    }
    const formals = this.rules[app.ruleName].formals;
    if (formals.length !== app.args.length) {
      const source = this.rules[app.ruleName].source;
      throw errors.wrongNumberOfParameters(app.ruleName, formals.length, app.args.length, source);
    }
    return app;
  }
};

// The following grammar contains a few rules that couldn't be written  in "userland".
// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called
// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and
// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar
// isn't specified.
Grammar.ProtoBuiltInRules = new Grammar(
    'ProtoBuiltInRules', // name
    undefined, // supergrammar
    {
      any: {
        body: pexprs.any,
        formals: [],
        description: 'any character',
        primitive: true
      },
      end: {
        body: pexprs.end,
        formals: [],
        description: 'end of input',
        primitive: true
      },

      caseInsensitive: {
        body: new CaseInsensitiveTerminal(new pexprs.Param(0)),
        formals: ['str'],
        primitive: true
      },
      lower: {
        body: new pexprs.UnicodeChar('Ll'),
        formals: [],
        description: 'a lowercase letter',
        primitive: true
      },
      upper: {
        body: new pexprs.UnicodeChar('Lu'),
        formals: [],
        description: 'an uppercase letter',
        primitive: true
      },
      // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
      unicodeLtmo: {
        body: new pexprs.UnicodeChar('Ltmo'),
        formals: [],
        description: 'a Unicode character in Lt, Lm, or Lo',
        primitive: true
      },

      // These rules are not truly primitive (they could be written in userland) but are defined
      // here for bootstrapping purposes.
      spaces: {
        body: new pexprs.Star(new pexprs.Apply('space')),
        formals: []
      },
      space: {
        body: new pexprs.Range('\x00', ' '),
        formals: [],
        description: 'a space'
      }
    }
);

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Grammar;


/***/ }),

/***/ "./node_modules/ohm-js/src/GrammarDecl.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/GrammarDecl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Constructors

function GrammarDecl(name) {
  this.name = name;
}

// Helpers

GrammarDecl.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};

GrammarDecl.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
        // TODO: The conditional expression below is an ugly hack. It's kind of ok because
        // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
        // we should try to find a better way to do this.
        this.name === 'BuiltInRules' ?
            Grammar.ProtoBuiltInRules :
            Grammar.BuiltInRules);
  }
  return this.superGrammar;
};

GrammarDecl.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
  }
  return ruleInfo;
};

GrammarDecl.prototype.installOverriddenOrExtendedRule = function(name, formals, body, source) {
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
  }
  return this.install(name, formals, body, ruleInfo.description, source);
};

GrammarDecl.prototype.install = function(name, formals, body, description, source) {
  this.rules[name] = {
    body: body.introduceParams(formals),
    formals,
    description,
    source
  };
  return this;
};

// Stuff that you should only do once

GrammarDecl.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error('the super grammar of a GrammarDecl cannot be set more than once');
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);

  // Grammars with an explicit supergrammar inherit a default start rule.
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};

GrammarDecl.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};

GrammarDecl.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};

// Creates a Grammar instance, and if it passes the sanity checks, returns it.
GrammarDecl.prototype.build = function() {
  const grammar = new Grammar(
      this.name,
      this.ensureSuperGrammar(),
      this.rules,
      this.defaultStartRule);

  // TODO: change the pexpr.prototype.assert... methods to make them add
  // exceptions to an array that's provided as an arg. Then we'll be able to
  // show more than one error of the same type at a time.
  // TODO: include the offending pexpr in the errors, that way we can show
  // the part of the source that caused it.
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar.rules).forEach(ruleName => {
    const body = grammar.rules[ruleName].body;
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    // The following check can only be done if the grammar has no invalid applications.
    Object.keys(grammar.rules).forEach(ruleName => {
      const body = grammar.rules[ruleName].body;
      try {
        body.assertIteratedExprsAreNotNullable(grammar, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar.source = this.source;
  }

  return grammar;
};

// Rule declarations

GrammarDecl.prototype.define = function(name, formals, body, description, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
  } else if (this.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.name, source);
  }
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  return this.install(name, formals, body, description, source);
};

GrammarDecl.prototype.override = function(name, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name, source);
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

GrammarDecl.prototype.extend = function(name, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
  }
  const body = new pexprs.Extend(this.superGrammar, name, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = GrammarDecl;


/***/ }),

/***/ "./node_modules/ohm-js/src/InputStream.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/InputStream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function InputStream(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}

InputStream.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },

  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },

  matchString(s, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      /*
        Case-insensitive comparison is a tricky business. Some notable gotchas include the
        "Turkish I" problem (http://www.i18nguy.com/unicode/turkish-i18n.html) and the fact
        that the German Esszet (ß) turns into "SS" in upper case.

        This is intended to be a locale-invariant comparison, which means it may not obey
        locale-specific expectations (e.g. "i" => "İ").
       */
      for (idx = 0; idx < s.length; idx++) {
        const actual = this.next();
        const expected = s[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    // Default is case-sensitive comparison.
    for (idx = 0; idx < s.length; idx++) {
      if (this.next() !== s[idx]) { return false; }
    }
    return true;
  },

  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },

  interval(startIdx, optEndIdx) {
    return new Interval(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = InputStream;


/***/ }),

/***/ "./node_modules/ohm-js/src/Interval.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/src/Interval.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Interval(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}

Interval.coverage = function(/* interval1, interval2, ... */) {
  const sourceString = arguments[0].sourceString;
  let startIdx = arguments[0].startIdx;
  let endIdx = arguments[0].endIdx;
  for (let idx = 1; idx < arguments.length; idx++) {
    const interval = arguments[idx];
    if (interval.sourceString !== sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, arguments[idx].startIdx);
      endIdx = Math.max(endIdx, arguments[idx].endIdx);
    }
  }
  return new Interval(sourceString, startIdx, endIdx);
};

Interval.prototype = {
  coverageWith(/* interval1, interval2, ... */) {
    const intervals = Array.prototype.slice.call(arguments);
    intervals.push(this);
    return Interval.coverage.apply(undefined, intervals);
  },

  collapsedLeft() {
    return new Interval(this.sourceString, this.startIdx, this.startIdx);
  },

  collapsedRight() {
    return new Interval(this.sourceString, this.endIdx, this.endIdx);
  },

  getLineAndColumn() {
    return util.getLineAndColumn(this.sourceString, this.startIdx);
  },

  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },

  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      // `this` and `that` are the same interval!
      return [
      ];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      // `that` splits `this` into two intervals
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx),
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      // `that` contains a prefix of `this`
      return [
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      // `that` contains a suffix of `this`
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx)
      ];
    } else {
      // `that` and `this` do not overlap
      return [
        this
      ];
    }
  },

  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    }
    assert(this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
        'other interval does not cover this one');
    return new Interval(this.sourceString,
        this.startIdx - that.startIdx,
        this.endIdx - that.startIdx);
  },

  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends. (This only makes sense when
  // the input stream is a string.)
  trimmed() {
    const contents = this.contents;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval(this.sourceString, startIdx, endIdx);
  },

  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval(this.sourceString, newStartIdx, newStartIdx + len);
  }
};

Object.defineProperties(Interval.prototype, {
  contents: {
    get() {
      if (this._contents === undefined) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() { return this.endIdx - this.startIdx; },
    enumerable: true
  }
});

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Interval;



/***/ }),

/***/ "./node_modules/ohm-js/src/MatchResult.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/MatchResult.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function MatchResult(
    matcher,
    input,
    startExpr,
    cst,
    cstOffset,
    rightmostFailurePosition,
    optRecordedFailures) {

  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;

  if (this.failed()) {
    common.defineLazyProperty(this, 'message', function() {
      const detail = 'Expected ' + this.getExpectedText();
      return util.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common.defineLazyProperty(this, 'shortMessage', function() {
      const detail = 'expected ' + this.getExpectedText();
      const errorInfo = util.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;
    });
  }
}

MatchResult.prototype.succeeded = function() {
  return !!this._cst;
};

MatchResult.prototype.failed = function() {
  return !this.succeeded();
};

MatchResult.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};

MatchResult.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures =
        this.matcher._match(this.startExpr, false, this.getRightmostFailurePosition());
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};

MatchResult.prototype.toString = function() {
  return this.succeeded() ?
      '[match succeeded]' :
      '[match failed at position ' + this.getRightmostFailurePosition() + ']';
};

// Return a string summarizing the expected contents of the input stream when
// the match failure occurred.
MatchResult.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error('cannot get expected text of a successful MatchResult');
  }

  const sb = new common.StringBuffer();
  let failures = this.getRightmostFailures();

  // Filter out the fluffy failures to make the default error messages more useful
  failures = failures.filter(failure => !failure.isFluffy());

  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ', or ' : ' or ');
      } else {
        sb.append(', ');
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};

MatchResult.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchResult;


/***/ }),

/***/ "./node_modules/ohm-js/src/MatchState.js":
/*!***********************************************!*\
  !*** ./node_modules/ohm-js/src/MatchState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const PosInfo = __webpack_require__(/*! ./PosInfo */ "./node_modules/ohm-js/src/PosInfo.js");
const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const applySpaces = new pexprs.Apply('spaces');

function MatchState(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;

  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream(matcher.input);
  this.memoTable = matcher.memoTable;

  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];

  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];

  if (optPositionToRecordFailures !== undefined) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = Object.create(null);
  }
}

MatchState.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },

  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },

  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();

    this.rightmostFailurePosition = Math.max(
        this.rightmostFailurePosition,
        this._rightmostFailurePositionStack.pop());

    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },

  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },

  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },

  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },

  inSyntacticContext() {
    if (typeof this.inputStream.source !== 'string') {
      return false;
    }
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      // The top-level context is syntactic if the start application is.
      return this.startExpr.factors[0].isSyntactic();
    }
  },

  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },

  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },

  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ?
        this.skipSpaces() :
        this.inputStream.pos;
  },

  maybeSkipSpacesBefore(expr) {
    if (expr instanceof pexprs.Apply && expr.isSyntactic()) {
      return this.skipSpaces();
    } else if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },

  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },

  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },

  numBindings() {
    return this._bindings.length;
  },

  truncateBindings(newLength) {
    // Yes, this is this really faster than setting the `length` property (tested with
    // bin/es5bench on Node v6.1.0).
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },

  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },

  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },

  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);

    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        // Substitute parameters with the actual pexprs that were passed to
        // the current rule.
        expr = expr.substituteParams(app.args);
      } else {
        // This branch is only reached for the "end-check" that is
        // performed after the top-level application. In that case,
        // expr === pexprs.end so there is no need to substitute
        // parameters.
      }

      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },

  recordFailure(failure, shouldCloneIfNew) {
    const key = failure.toKey();
    if (!this.recordedFailures[key]) {
      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key].clearFluffy();
    }
  },

  recordFailures(failures, shouldCloneIfNew) {
    const self = this;
    Object.keys(failures).forEach(key => {
      self.recordFailure(failures[key], shouldCloneIfNew);
    });
  },

  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return undefined;
    }

    const ans = Object.create(null);
    const self = this;
    Object.keys(this.recordedFailures).forEach(key => {
      ans[key] = self.recordedFailures[key].clone();
    });
    return ans;
  },

  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },

  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ?
        this.posToOffset(this.rightmostFailurePosition) :
        -1;
  },

  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr.ruleName) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },

  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) ||
           new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },

  isTracing() {
    return !!this.trace;
  },

  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }

    if (this.recordedFailures &&
        this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }

    return true;
  },


  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }

    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition =
        Math.max(this.rightmostFailurePosition, memoRecRightmostFailurePosition);
    if (this.recordedFailures &&
        this.positionToRecordFailures === memoRecRightmostFailurePosition &&
        memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }

    this.inputStream.examinedLength =
        Math.max(this.inputStream.examinedLength, memoRec.examinedLength + origPos);

    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },

  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const inputStream = this.inputStream;
    const origNumBindings = this._bindings.length;

    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = Object.create(null);
    }

    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);

    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }

    // Do the actual evaluation.
    const ans = expr.eval(this);

    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }

    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        const self = this;
        Object.keys(this.recordedFailures).forEach(key => {
          self.recordedFailures[key].makeFluffy();
        });
      }
    } else {
      // Reset the position and the bindings.
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }

    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }

    return ans;
  },

  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      const self = this;
      rightmostFailures = Object.keys(this.recordedFailures).map(key => self.recordedFailures[key]);
    }
    return new MatchResult(
        this.matcher,
        this.input,
        this.startExpr,
        this._bindings[0],
        this._bindingOffsets[0],
        this.rightmostFailurePosition,
        rightmostFailures);
  },

  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();

    // The trace node for the start rule is always the last entry. If it is a syntactic rule,
    // the first entry is for an application of 'spaces'.
    // TODO(pdubroy): Clean this up by introducing a special `Match<startAppl>` rule, which will
    // ensure that there is always a single root trace node.
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },

  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },

  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchState;


/***/ }),

/***/ "./node_modules/ohm-js/src/Matcher.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Matcher.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const MatchState = __webpack_require__(/*! ./MatchState */ "./node_modules/ohm-js/src/MatchState.js");

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Matcher(grammar) {
  this.grammar = grammar;
  this.memoTable = [];
  this.input = '';
}

Matcher.prototype.getInput = function() {
  return this.input;
};

Matcher.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};

Matcher.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length ||
      endIdx < 0 || endIdx > currentInput.length ||
      startIdx > endIdx) {
    throw new Error('Invalid indices: ' + startIdx + ' and ' + endIdx);
  }

  // update input
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);

  // update memo table (similar to the above)
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(undefined);
  }
  restOfMemoTable.forEach(
      function(posInfo) { this.memoTable.push(posInfo); },
      this);

  // Invalidate memoRecs
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }

  return this;
};

Matcher.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};

Matcher.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};

Matcher.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};

/*
  Returns the starting expression for this Matcher's associated grammar. If `optStartApplicationStr`
  is specified, it is a string expressing a rule application in the grammar. If not specified, the
  grammar's default start rule will be used.
*/
Matcher.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error('Missing start rule argument -- the grammar has no default start rule.');
  }

  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs.Seq([startApp, pexprs.end]);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Matcher;


/***/ }),

/***/ "./node_modules/ohm-js/src/Namespace.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Namespace.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Namespace() {
}
Namespace.prototype = Object.create(null);

Namespace.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace) {
    return objOrNamespace;
  }
  return Namespace.createNamespace(objOrNamespace);
};

// Create a new namespace. If `optProps` is specified, all of its properties
// will be copied to the new namespace.
Namespace.createNamespace = function(optProps) {
  return Namespace.extend(Namespace.prototype, optProps);
};

// Create a new namespace which extends another namespace. If `optProps` is
// specified, all of its properties will be copied to the new namespace.
Namespace.extend = function(namespace, optProps) {
  if (namespace !== Namespace.prototype && !(namespace instanceof Namespace)) {
    throw new TypeError('not a Namespace object: ' + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return extend(ns, optProps);
};

// TODO: Should this be a regular method?
Namespace.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Namespace;


/***/ }),

/***/ "./node_modules/ohm-js/src/PosInfo.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/PosInfo.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function PosInfo() {
  this.applicationMemoKeyStack = []; // active applications at this position
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = undefined;
}

PosInfo.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },

  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },

  exit() {
    this.applicationMemoKeyStack.pop();
  },

  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;

    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    const indexOfFirstInvolvedRule =
        applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(indexOfFirstInvolvedRule);

    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };

    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },

  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },

  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },

  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset =
        Math.max(this.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
    return memoRec;
  },

  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      // Optimization: none of the rule applications that were memoized here examined the
      // interval of the input that changed, so nothing has to be invalidated.
      return;
    }

    const memo = this.memo;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    const self = this;
    Object.keys(memo).forEach(k => {
      const memoRec = memo[k];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k];
      } else {
        self.maxExaminedLength = Math.max(self.maxExaminedLength, memoRec.examinedLength);
        self.maxRightmostFailureOffset =
            Math.max(self.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
      }
    });
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = PosInfo;


/***/ }),

/***/ "./node_modules/ohm-js/src/Semantics.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Semantics.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const IterationNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").IterationNode;
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const globalActionStack = [];
let prototypeGrammar;
let prototypeGrammarSemantics;

// JSON is not a valid subset of JavaScript because there are two possible line terminators,
// U+2028 (line separator) and U+2029 (paragraph separator) that are allowed in JSON strings
// but not in JavaScript strings.
// jsonToJS() properly encodes those two characters in JSON so that it can seamlessly be
// inserted into JavaScript code (plus the encoded version is still valid JSON)
function jsonToJS(str) {
  const output = str.replace(/[\u2028\u2029]/g, (char, pos, str) => {
    const hex = char.codePointAt(0).toString(16);
    return '\\u' + '0000'.slice(hex.length) + hex;
  });
  return output;
}

// ----------------- Wrappers -----------------

// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)
// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A
// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and
// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is
// used to cache the wrapper instances that are created for its child nodes. Setting these instance
// variables is the responsibility of the constructor of each Semantics-specific subclass of
// `Wrapper`.
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;

    // The interval that the childOffsets of `node` are relative to. It should be the source
    // of the closest Nonterminal node.
    this._baseInterval = baseInterval;

    if (node.isNonterminal()) {
      common.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }

  toString() {
    return '[semantics wrapper for ' + this._node.grammar.name + ']';
  };

  // This is used by ohm editor to display a node wrapper appropriately.
  toJSON() {
    return this.toString();
  }

  _forgetMemoizedResultFor(attributeName) {
    // Remove the memoized attribute from the cstNode and all its children.
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach(child => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }

  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      // TODO: Consider throwing an exception here.
      return undefined;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];

      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
    }
    return childWrapper;
  }

  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    // Force the creation of all child wrappers
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }

  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }

  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }

  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }

  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];

    const childNodes = childWrappers.map(c => c._node);
    const iter = new IterationNode(this._node.grammar, childNodes, [], -1, false);

    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }

  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }

  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }

  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error('The `interval` property is deprecated -- use `source` instead');
  }

  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }

  // Returns the primitive value of this CST node, if it's a terminal node. Otherwise,
  // throws an exception.
  get primitiveValue() {
    if (this.isTerminal()) {
      return this._node.primitiveValue;
    }
    throw new TypeError(
        "tried to access the 'primitiveValue' attribute of a non-terminal CST node");
  }

  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}

// ----------------- Semantics -----------------

// A Semantics is a container for a family of Operations and Attributes for a given grammar.
// Semantics enable modularity (different clients of a grammar can create their set of operations
// and attributes in isolation) and extensibility even when operations and attributes are mutually-
// recursive. This constructor should not be called directly except from
// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are
// `g.createSemantics()` and `g.extendSemantics(parentSemantics)`.
function Semantics(grammar, superSemantics) {
  const self = this;
  this.grammar = grammar;
  this.checkedActionDicts = false;

  // Constructor for wrapper instances, which are passed as the arguments to the semantic actions
  // of an operation or attribute. Operations and attributes require double dispatch: the semantic
  // action is chosen based on both the node's type and the semantics. Wrappers ensure that
  // the `execute` method is called with the correct (most specific) semantics object as an
  // argument.
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self.checkActionDictsIfHaventAlready();
      this._semantics = self;
    }
  };

  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) {
      throw new Error(
          "Cannot extend a semantics for grammar '" + this.super.grammar.name +
          "' for use with grammar '" + grammar.name + "' (not a sub-grammar)");
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = Object.create(null);

    // Assign unique symbols for each of the attributes inherited from the super-semantics so that
    // they are memoized independently.
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = Object.create(null);
    this.attributes = Object.create(null);
    this.attributeKeys = Object.create(null);
  }
}

Semantics.prototype.toString = function() {
  return '[semantics for ' + this.grammar.name + ']';
};

Semantics.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};

// Checks that the action dictionaries for all operations and attributes in this semantics,
// including the ones that were inherited from the super-semantics, agree with the grammar.
// Throws an exception if one or more of them doesn't.
Semantics.prototype.checkActionDicts = function() {
  let name;
  for (name in this.operations) {
    this.operations[name].checkActionDict(this.grammar);
  }
  for (name in this.attributes) {
    this.attributes[name].checkActionDict(this.grammar);
  }
};

Semantics.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s) {
    return s.super !== Semantics.BuiltInSemantics._getSemantics();
  }

  let str = '(function(g) {\n';
  if (hasSuperSemantics(this)) {
    str += '  var semantics = ' + this.super.toRecipe(true) + '(g';

    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += '.superGrammar';
      relatedGrammar = relatedGrammar.superGrammar;
    }

    str += ');\n';
    str += '  return g.extendSemantics(semantics)';
  } else {
    str += '  return g.createSemantics()';
  }
  ['Operation', 'Attribute'].forEach(type => {
    const semanticOperations = this[type.toLowerCase() + 's'];
    Object.keys(semanticOperations).forEach(name => {
      const {actionDict, formals, builtInDefault} = semanticOperations[name];

      let signature = name;
      if (formals.length > 0) {
        signature += '(' + formals.join(', ') + ')';
      }

      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + 's'][name]) {
        method = 'extend' + type;
      } else {
        method = 'add' + type;
      }
      str += '\n    .' + method + '(' + JSON.stringify(signature) + ', {';

      const srcArray = [];
      Object.keys(actionDict).forEach(actionName => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();

          // Convert method shorthand to plain old function syntax.
          // https://github.com/harc/ohm/issues/263
          source = source.replace(/^.*\(/, 'function(');

          srcArray.push('\n      ' + JSON.stringify(actionName) + ': ' + source);
        }
      });
      str += srcArray.join(',') + '\n    })';
    });
  });
  str += ';\n  })';

  if (!semanticsOnly) {
    str =
      '(function() {\n' +
      '  var grammar = this.fromRecipe(' + jsonToJS(this.grammar.toRecipe()) + ');\n' +
      '  var semantics = ' + str + '(grammar);\n' +
      '  return semantics;\n' +
      '});\n';
  }

  return str;
};

function parseSignature(signature, type) {
  if (!prototypeGrammar) {
    // The Operations and Attributes grammar won't be available while Ohm is loading,
    // but we can get away the following simplification b/c none of the operations
    // that are used while loading take arguments.
    common.assert(signature.indexOf('(') === -1);
    return {
      name: signature,
      formals: []
    };
  }

  const r = prototypeGrammar.match(
      signature,
      type === 'operation' ? 'OperationSignature' : 'AttributeSignature');
  if (r.failed()) {
    throw new Error(r.message);
  }

  return prototypeGrammarSemantics(r).parse();
}

function newDefaultAction(type, name, doIt) {
  return function(children) {
    const self = this;
    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
    const args = thisThing.formals.map(formal => self.args[formal]);

    if (this.isIteration()) {
      // This CST node corresponds to an iteration expression in the grammar (*, +, or ?). The
      // default behavior is to map this operation or attribute over all of its child nodes.
      return children.map(child => doIt.apply(child, args));
    }

    // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that
    // we got here means that this action dictionary doesn't have an action for this particular
    // non-terminal or a generic `_nonterminal` action.
    if (children.length === 1) {
      // As a convenience, if this node only has one child, we just return the result of
      // applying this operation / attribute to the child node.
      return doIt.apply(children[0], args);
    } else {
      // Otherwise, we throw an exception to let the programmer know that we don't know what
      // to do with this node.
      throw errors.missingSemanticAction(this.ctorName, name, type, globalActionStack);
    }
  };
}

Semantics.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + 's';

  const parsedNameAndFormalArgs = parseSignature(signature, type);
  const name = parsedNameAndFormalArgs.name;
  const formals = parsedNameAndFormalArgs.formals;

  // TODO: check that there are no duplicate formal arguments

  this.assertNewName(name, type);

  // Create the action dictionary for this operation / attribute that contains a `_default` action
  // which defines the default behavior of iteration, terminal, and non-terminal nodes...
  const builtInDefault = newDefaultAction(type, name, doIt);
  const realActionDict = {_default: builtInDefault};
  // ... and add in the actions supplied by the programmer, which may override some or all of the
  // default ones.
  Object.keys(actionDict).forEach(name => {
    realActionDict[name] = actionDict[name];
  });

  const entry = type === 'operation' ?
      new Operation(name, formals, realActionDict, builtInDefault) :
      new Attribute(name, realActionDict, builtInDefault);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  entry.checkActionDict(this.grammar);

  this[typePlural][name] = entry;

  function doIt() {
    // Dispatch to most specific version of this operation / attribute -- it may have been
    // overridden by a sub-semantics.
    const thisThing = this._semantics[typePlural][name];

    // Check that the caller passed the correct number of arguments.
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
          'Invalid number of arguments passed to ' + name + ' ' + type + ' (expected ' +
          thisThing.formals.length + ', got ' + arguments.length + ')');
    }

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let idx = 0; idx < arguments.length; idx++) {
      const formal = thisThing.formals[idx];
      args[formal] = arguments[idx];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }

  if (type === 'operation') {
    this.Wrapper.prototype[name] = doIt;
    this.Wrapper.prototype[name].toString = function() {
      return '[' + name + ' operation]';
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name, {
      get: doIt,
      configurable: true // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name, {
      value: util.uniqueId(name)
    });
  }
};

Semantics.prototype.extendOperationOrAttribute = function(type, name, actionDict) {
  const typePlural = type + 's';

  // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.
  parseSignature(name, 'attribute');

  if (!(this.super && name in this.super[typePlural])) {
    throw new Error('Cannot extend ' + type + " '" + name +
        "': did not inherit an " + type + ' with that name');
  }
  if (Object.prototype.hasOwnProperty.call(this[typePlural], name)) {
    throw new Error('Cannot extend ' + type + " '" + name + "' again");
  }

  // Create a new operation / attribute whose actionDict delegates to the super operation /
  // attribute's actionDict, and which has all the keys from `inheritedActionDict`.
  const inheritedFormals = this[typePlural][name].formals;
  const inheritedActionDict = this[typePlural][name].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach(name => {
    newActionDict[name] = actionDict[name];
  });

  this[typePlural][name] = type === 'operation' ?
      new Operation(name, inheritedFormals, newActionDict) :
      new Attribute(name, newActionDict);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  this[typePlural][name].checkActionDict(this.grammar);
};

Semantics.prototype.assertNewName = function(name, type) {
  if (Wrapper.prototype.hasOwnProperty(name)) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': that's a reserved name");
  }
  if (name in this.operations) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an operation with that name already exists");
  }
  if (name in this.attributes) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an attribute with that name already exists");
  }
};

// Returns a wrapper for the given CST `node` in this semantics.
// If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?
Semantics.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};

// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from
// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new
// Semantics instance. When that function is invoked with a CST node as an argument, it returns
// a wrapper for that node which gives access to the operations and attributes provided by this
// semantics.
Semantics.createSemantics = function(grammar, optSuperSemantics) {
  const s = new Semantics(
      grammar,
      optSuperSemantics !== undefined ?
          optSuperSemantics :
          Semantics.BuiltInSemantics._getSemantics());

  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy
  // for `s`, which is the real `Semantics` instance.
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
          'Semantics expected a MatchResult, but got ' + common.unexpectedObjToString(matchResult));
    }
    if (matchResult.failed()) {
      throw new TypeError('cannot apply Semantics to ' + matchResult.toString());
    }

    const cst = matchResult._cst;
    if (cst.grammar !== grammar) {
      throw new Error(
          "Cannot use a MatchResult from grammar '" + cst.grammar.name +
          "' with a semantics for '" + grammar.name + "'");
    }
    const inputStream = new InputStream(matchResult.input);
    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };

  // Forward public methods from the proxy to the semantics instance.
  proxy.addOperation = function(signature, actionDict) {
    s.addOperationOrAttribute('operation', signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name, actionDict) {
    s.extendOperationOrAttribute('operation', name, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name, actionDict) {
    s.addOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name, actionDict) {
    s.extendOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error('"' + operationOrAttributeName + '" is not a valid operation or attribute ' +
        'name in this semantics for "' + grammar.name + '"');
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s.operations) {
      semantic = s.operations[operationOrAttributeName];
      delete s.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s.attributes) {
      semantic = s.attributes[operationOrAttributeName];
      delete s.attributes[operationOrAttributeName];
    }
    delete s.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s.attributes);
  };
  proxy.getGrammar = function() {
    return s.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s.toRecipe(semanticsOnly);
  };

  // Make the proxy's toString() work.
  proxy.toString = s.toString.bind(s);

  // Returns the semantics for the proxy.
  proxy._getSemantics = function() {
    return s;
  };

  return proxy;
};

// ----------------- Operation -----------------

// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very
// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by
// recursively walking the CST, and at each node, invoking the matching semantic action from
// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic
// action is found.
class Operation {
  constructor(name, formals, actionDict, builtInDefault) {
    this.name = name;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }

  checkActionDict(grammar) {
    grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }

  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      // Look for a semantic action whose name matches the node's constructor name, which is either
      // the name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an
      // iteration node). In the latter case, the action function receives a single argument, which
      // is an array containing all of the children of the CST node.
      const ctorName = nodeWrapper._node.ctorName;
      let actionFn = this.actionDict[ctorName];
      let ans;
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        ans = this.doAction(semantics, nodeWrapper, actionFn, nodeWrapper.isIteration());
        return ans;
      }

      // The action dictionary does not contain a semantic action for this specific type of node.
      // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic
      // action, we invoke it:
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, '_nonterminal', ctorName]);
          ans = this.doAction(semantics, nodeWrapper, actionFn, true);
          return ans;
        }
      }

      // Otherwise, we invoke the '_default' semantic action.
      globalActionStack.push([this, 'default action', ctorName]);
      ans = this.doAction(semantics, nodeWrapper, this.actionDict._default, true);
      return ans;
    } finally {
      globalActionStack.pop();
    }
  }

  // Invoke `actionFn` on the CST node that corresponds to `nodeWrapper`, in the context of
  // `semantics`. If `optPassChildrenAsArray` is truthy, `actionFn` will be called with a single
  // argument, which is an array of wrappers. Otherwise, the number of arguments to `actionFn` will
  // be equal to the number of children in the CST node.
  doAction(semantics, nodeWrapper, actionFn, optPassChildrenAsArray) {
    return optPassChildrenAsArray ?
        actionFn.call(nodeWrapper, nodeWrapper._children()) :
        actionFn.apply(nodeWrapper, nodeWrapper._children());
  }
}

Operation.prototype.typeName = 'operation';

// ----------------- Attribute -----------------

// Attributes are Operations whose results are memoized. This means that, for any given semantics,
// the semantic action for a CST node will be invoked no more than once.
class Attribute extends Operation {
  constructor(name, actionDict, builtInDefault) {
    super(name, [], actionDict, builtInDefault);
  }

  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key = semantics.attributeKeys[this.name];
    if (!node.hasOwnProperty(key)) {
      // The following is a super-send -- isn't JS beautiful? :/
      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key];
  }
}

Attribute.prototype.typeName = 'attribute';


// ----------------- Deferred initialization -----------------

util.awaitBuiltInRules(builtInRules => {
  const operationsAndAttributesGrammar = __webpack_require__(/*! ../dist/operations-and-attributes */ "./node_modules/ohm-js/dist/operations-and-attributes.js");
  initBuiltInSemantics(builtInRules);
  initPrototypeParser(operationsAndAttributesGrammar); // requires BuiltInSemantics
});

function initBuiltInSemantics(builtInRules) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };

  Semantics.BuiltInSemantics = Semantics
      .createSemantics(builtInRules, null)
      .addOperation('asIteration', {
        emptyListOf: actions.empty,
        nonemptyListOf: actions.nonEmpty,
        EmptyListOf: actions.empty,
        NonemptyListOf: actions.nonEmpty
      });
}

function initPrototypeParser(grammar) {
  prototypeGrammarSemantics = grammar.createSemantics().addOperation('parse', {
    AttributeSignature(name) {
      return {
        name: name.parse(),
        formals: []
      };
    },
    OperationSignature(name, optFormals) {
      return {
        name: name.parse(),
        formals: optFormals.parse()[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().parse();
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  prototypeGrammar = grammar;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Semantics;


/***/ }),

/***/ "./node_modules/ohm-js/src/Trace.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/Trace.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Unicode characters that are used in the `toString` output.
const BALLOT_X = '\u2717';
const CHECK_MARK = '\u2713';
const DOT_OPERATOR = '\u22C5';
const RIGHTWARDS_DOUBLE_ARROW = '\u21D2';
const SYMBOL_FOR_HORIZONTAL_TABULATION = '\u2409';
const SYMBOL_FOR_LINE_FEED = '\u240A';
const SYMBOL_FOR_CARRIAGE_RETURN = '\u240D';

const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};

function spaces(n) {
  return common.repeat(' ', n).join('');
}

// Return a string representation of a portion of `input` at offset `pos`.
// The result will contain exactly `len` characters.
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));

  // Pad the output if necessary.
  if (excerpt.length < len) {
    return excerpt + common.repeat(' ', len - excerpt.length).join('');
  }
  return excerpt;
}

function asEscapedString(obj) {
  if (typeof obj === 'string') {
    // Replace non-printable characters with visible symbols.
    return obj
        .replace(/ /g, DOT_OPERATOR)
        .replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)
        .replace(/\n/g, SYMBOL_FOR_LINE_FEED)
        .replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}

// ----------------- Trace -----------------

function Trace(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;

  this._flags = succeeded ? Flags.succeeded : 0;
}

// A value that can be returned from visitor functions to indicate that a
// node should not be recursed into.
Trace.prototype.SKIP = {};

Object.defineProperty(Trace.prototype, 'displayString', {
  get() { return this.expr.toDisplayString(); }
});

// For convenience, create a getter and setter for the boolean flags in `Flags`.
Object.keys(Flags).forEach(name => {
  const mask = Flags[name];
  Object.defineProperty(Trace.prototype, name, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});

Trace.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};

Trace.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace(
      this.input, this.pos, this.pos2, expr, this.succeeded, this.bindings, this.children);

  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};

// Record the trace information for the terminating condition of the LR loop.
Trace.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry =
      new Trace(this.input, this.pos, this.pos2, this.expr, false, [value], [ruleBodyTrace]);
  this.terminatingLREntry.terminatesLR = true;
};

// Recursively traverse this trace node and all its descendents, calling a visitor function
// for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property
// is a function to call before visiting the children of a node, and its 'exit' property is
// a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'
// function.
//
// The functions are called with three arguments: the Trace node, its parent Trace, and a number
// representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if
// specified, is the value to use for `this` when executing the visitor functions.
Trace.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === 'function') {
    visitor = {enter: visitor};
  }

  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach(child => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    // Don't visit the root node itself, only its children.
    this.children.forEach(c => { _walk(c, null, 0); });
  } else {
    _walk(this, null, 0);
  }
};

// Return a string representation of the trace.
// Sample:
//     12⋅+⋅2⋅*⋅3 ✓ exp ⇒  "12"
//     12⋅+⋅2⋅*⋅3   ✓ addExp (LR) ⇒  "12"
//     12⋅+⋅2⋅*⋅3       ✗ addExp_plus
Trace.prototype.toString = function() {
  const sb = new common.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    // Don't print anything for Alt nodes.
    if (ctorName === 'Alt') {
      return; // eslint-disable-line consistent-return
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(' (LR)');
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');
      sb.append(typeof contents === 'string' ? '"' + contents + '"' : contents);
    }
    sb.append('\n');
  });
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Trace;


/***/ }),

/***/ "./node_modules/ohm-js/src/common.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/common.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Helpers

const escapeStringFor = {};
for (let c = 0; c < 128; c++) {
  escapeStringFor[c] = String.fromCharCode(c);
}
escapeStringFor["'".charCodeAt(0)] = "\\'";
escapeStringFor['"'.charCodeAt(0)] = '\\"';
escapeStringFor['\\'.charCodeAt(0)] = '\\\\';
escapeStringFor['\b'.charCodeAt(0)] = '\\b';
escapeStringFor['\f'.charCodeAt(0)] = '\\f';
escapeStringFor['\n'.charCodeAt(0)] = '\\n';
escapeStringFor['\r'.charCodeAt(0)] = '\\r';
escapeStringFor['\t'.charCodeAt(0)] = '\\t';
escapeStringFor['\u000b'.charCodeAt(0)] = '\\v';

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.abstract = function(optMethodName) {
  const methodName = optMethodName || '';
  return function() {
    throw new Error(
        'this method ' + methodName + ' is abstract! ' +
      '(it has no implementation in class ' + this.constructor.name + ')');
  };
};

exports.assert = function(cond, message) {
  if (!cond) {
    throw new Error(message);
  }
};

// Define a lazily-computed, non-enumerable property named `propName`
// on the object `obj`. `getterFn` will be called to compute the value the
// first time the property is accessed.
exports.defineLazyProperty = function(obj, propName, getterFn) {
  let memo;
  Object.defineProperty(obj, propName, {
    get() {
      if (!memo) {
        memo = getterFn.call(this);
      }
      return memo;
    }
  });
};

exports.clone = function(obj) {
  if (obj) {
    return extend({}, obj);
  }
  return obj;
};

exports.extend = extend;

exports.repeatFn = function(fn, n) {
  const arr = [];
  while (n-- > 0) {
    arr.push(fn());
  }
  return arr;
};

exports.repeatStr = function(str, n) {
  return new Array(n + 1).join(str);
};

exports.repeat = function(x, n) {
  return exports.repeatFn(() => x, n);
};

exports.getDuplicates = function(array) {
  const duplicates = [];
  for (let idx = 0; idx < array.length; idx++) {
    const x = array[idx];
    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {
      duplicates.push(x);
    }
  }
  return duplicates;
};

exports.copyWithoutDuplicates = function(array) {
  const noDuplicates = [];
  array.forEach(entry => {
    if (noDuplicates.indexOf(entry) < 0) {
      noDuplicates.push(entry);
    }
  });
  return noDuplicates;
};

exports.isSyntactic = function(ruleName) {
  const firstChar = ruleName[0];
  return firstChar === firstChar.toUpperCase();
};

exports.isLexical = function(ruleName) {
  return !exports.isSyntactic(ruleName);
};

exports.padLeft = function(str, len, optChar) {
  const ch = optChar || ' ';
  if (str.length < len) {
    return exports.repeatStr(ch, len - str.length) + str;
  }
  return str;
};

// StringBuffer

exports.StringBuffer = function() {
  this.strings = [];
};

exports.StringBuffer.prototype.append = function(str) {
  this.strings.push(str);
};

exports.StringBuffer.prototype.contents = function() {
  return this.strings.join('');
};

// Character escaping and unescaping

exports.escapeChar = function(c, optDelim) {
  const charCode = c.charCodeAt(0);
  if ((c === '"' || c === "'") && optDelim && c !== optDelim) {
    return c;
  } else if (charCode < 128) {
    return escapeStringFor[charCode];
  } else if (128 <= charCode && charCode < 256) {
    return '\\x' + exports.padLeft(charCode.toString(16), 2, '0');
  } else {
    return '\\u' + exports.padLeft(charCode.toString(16), 4, '0');
  }
};

exports.unescapeChar = function(s) {
  if (s.charAt(0) === '\\') {
    switch (s.charAt(1)) {
      case 'b': return '\b';
      case 'f': return '\f';
      case 'n': return '\n';
      case 'r': return '\r';
      case 't': return '\t';
      case 'v': return '\v';
      case 'x': return String.fromCharCode(parseInt(s.substring(2, 4), 16));
      case 'u': return String.fromCharCode(parseInt(s.substring(2, 6), 16));
      default: return s.charAt(1);
    }
  } else {
    return s;
  }
};

// Helper for producing a description of an unknown object in a safe way.
// Especially useful for error messages where an unexpected type of object was encountered.
exports.unexpectedObjToString = function(obj) {
  if (obj == null) {
    return String(obj);
  }
  const baseToString = Object.prototype.toString.call(obj);
  try {
    let typeName;
    if (obj.constructor && obj.constructor.name) {
      typeName = obj.constructor.name;
    } else if (baseToString.indexOf('[object ') === 0) {
      typeName = baseToString.slice(8, -1); // Extract e.g. "Array" from "[object Array]".
    } else {
      typeName = typeof obj;
    }
    return typeName + ': ' + JSON.stringify(String(obj));
  } catch (e) {
    return baseToString;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/errors.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/errors.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}

// ----------------- errors about intervals -----------------

function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}

// ----------------- errors about grammars -----------------

// Grammar syntax error

function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, 'message', {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, 'shortMessage', {
    enumerable: true,
    get() {
      return 'Expected ' + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}

// Undeclared grammar

function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ?
      'Grammar ' + grammarName + ' is not declared in namespace ' + Namespace.toString(namespace) :
      'Undeclared grammar ' + grammarName;
  return createError(message, interval);
}

// Duplicate grammar declaration

function duplicateGrammarDeclaration(grammar, namespace) {
  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');
}

// ----------------- rules -----------------

// Undeclared rule

function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,
      optInterval);
}

// Cannot override undeclared rule

function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Cannot extend undeclared rule

function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Duplicate rule declaration

function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName +
      "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}

// Wrong number of parameters

function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
      'Wrong number of parameters for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      source);
}

// Wrong number of arguments

function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
      'Wrong number of arguments for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// Duplicate parameter names

function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(', '),
      source);
}

// Invalid parameter expression

function invalidParameter(ruleName, expr) {
  return createError(
      'Invalid parameter to rule ' + ruleName + ': ' + expr + ' has arity ' + expr.getArity() +
         ', but parameter expressions must have arity 1',
      expr.source);
}

// Application of syntactic rule from lexical rule

function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',
      applyExpr.source);
}

// Incorrect argument type

function incorrectArgumentType(expectedType, expr) {
  return createError('Incorrect argument type: expected ' + expectedType, expr.source);
}

// Multiple instances of the super-splice operator (`...`) in the rule body.

function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}

// ----------------- Kleene operators -----------------

function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ?
    applicationStack[applicationStack.length - 1].args :
    [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message =
    'Nullable expression ' + expr + " is not allowed inside '" +
    kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack
        .map(app => new pexprs.Apply(app.ruleName, app.args))
        .join('\n');
    message += '\nApplication stack (most recent application last):\n' + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}

// ----------------- arity -----------------

function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
      'Rule ' + ruleName + ' involves an alternation which has inconsistent arity ' +
          '(expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// ----------------- properties -----------------

function duplicatePropertyNames(duplicates) {
  return createError('Object pattern has duplicate property names: ' + duplicates.join(', '));
}

// ----------------- constructors -----------------

function invalidConstructorCall(grammar, ctorName, children) {
  return createError(
      'Attempt to invoke constructor ' + ctorName + ' with invalid or unexpected arguments');
}

// ----------------- convenience -----------------

function multipleErrors(errors) {
  const messages = errors.map(e => e.message);
  return createError(
      ['Errors:'].concat(messages).join('\n- '),
      errors[0].interval);
}

// ----------------- semantic -----------------

function missingSemanticAction(ctorName, name, type, stack) {
  let stackTrace = stack.slice(0, -1).map(info => {
    const ans = '  ' + info[0].name + ' > ' + info[1];
    return info.length === 3
        ? ans + " for '" + info[2] + "'"
        : ans;
  }).join('\n');
  stackTrace += '\n  ' + name + ' > ' + ctorName;

  const where = type + " '" + name + "'";
  const message = "Missing semantic action for '" + ctorName + "' in " + where + '\n' +
                'Action stack (most recent call last):\n' + stackTrace;

  const e = createError(message);
  e.name = 'missingSemanticAction';
  return e;
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  applicationOfSyntacticRuleFromLexicalContext,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  wrongNumberOfArguments,
  wrongNumberOfParameters,

  throwErrors(errors) {
    if (errors.length === 1) {
      throw errors[0];
    }
    if (errors.length > 1) {
      throw multipleErrors(errors);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/main.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/main.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global document, XMLHttpRequest */



// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Builder = __webpack_require__(/*! ./Builder */ "./node_modules/ohm-js/src/Builder.js");
const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const version = __webpack_require__(/*! ./version */ "./node_modules/ohm-js/src/version.js");

const isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/ohm-js/node_modules/is-buffer/index.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// The metagrammar, i.e. the grammar for Ohm grammars. Initialized at the
// bottom of this file because loading the grammar requires Ohm itself.
let ohmGrammar;

// An object which makes it possible to stub out the document API for testing.
let documentInterface = {
  querySelector(sel) { return document.querySelector(sel); },
  querySelectorAll(sel) { return document.querySelectorAll(sel); }
};

const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);

// Check if `obj` is a DOM element.
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

function isUndefined(obj) {
  return obj === void 0; // eslint-disable-line no-void
}

const MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

function isArrayLike(obj) {
  if (obj == null) {
    return false;
  }
  const length = obj.length;
  return typeof length === 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
}

// TODO: just use the jQuery thing
function load(url) {
  const req = new XMLHttpRequest();
  req.open('GET', url, false);
  try {
    req.send();
    if (req.status === 0 || req.status === 200) {
      return req.responseText;
    }
  } catch (e) {}
  throw new Error('unable to load url ' + url);
}

// Returns a Grammar instance (i.e., an object with a `match` method) for
// `tree`, which is the concrete syntax tree of a user-written grammar.
// The grammar will be assigned into `namespace` under the name of the grammar
// as specified in the source.
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;

  // A visitor that produces a Grammar instance from the CST.
  const helpers = metaGrammar.createSemantics().addOperation('visit', {
    Grammar(n, s, open, rs, close) {
      const grammarName = n.visit();
      decl = builder.newGrammar(grammarName, namespace);
      s.visit();
      rs.visit();
      const g = decl.build();
      g.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors.duplicateGrammarDeclaration(g, namespace);
      }
      namespace[grammarName] = g;
      return g;
    },

    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === 'null') {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },

    Rule_define(n, fs, d, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      // If there is no default start rule yet, set it now. This must be done before visiting
      // the body, because it might contain an inline rule definition.
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b.visit();
      const description = d.visit()[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description, source);
    },
    Rule_override(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];

      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);

      overriding = true;
      const body = b.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      const body = b.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      const args = terms.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();

      // Check if the super-splice operator (`...`) appears in the terms.
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);

        // Ensure it appears no more than once.
        afterTerms.forEach(t => {
          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);
        });

        return new pexprs.Splice(
            decl.superGrammar, currentRuleName, beforeTerms, afterTerms).withSource(this.source);
      } else {
        return builder.alt.apply(builder, args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },

    Params(opointy, ps, cpointy) {
      return ps.visit();
    },

    Alt(seqs) {
      const args = seqs.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },

    TopLevelTerm_inline(b, n) {
      const inlineRuleName = currentRuleName + '_' + n.visit();
      const body = b.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration =
          !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map(formal => builder.app(formal));
      return builder.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },

    Seq(expr) {
      return builder.seq.apply(builder, expr.visit()).withSource(this.source);
    },

    Iter_star(x, _) {
      return builder.star(x.visit()).withSource(this.source);
    },
    Iter_plus(x, _) {
      return builder.plus(x.visit()).withSource(this.source);
    },
    Iter_opt(x, _) {
      return builder.opt(x.visit()).withSource(this.source);
    },

    Pred_not(_, x) {
      return builder.not(x.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x) {
      return builder.lookahead(x.visit()).withSource(this.source);
    },

    Lex_lex(_, x) {
      return builder.lex(x.visit()).withSource(this.source);
    },

    Base_application(rule, ps) {
      return builder.app(rule.visit(), ps.visit()[0] || []).withSource(this.source);
    },
    Base_range(from, _, to) {
      return builder.range(from.visit(), to.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x, close) {
      return x.visit();
    },

    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },

    caseName(_, space1, n, space2, end) {
      return n.visit();
    },

    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {},
    nameRest(expr) {},

    terminal(open, cs, close) {
      return cs.visit().join('');
    },

    oneCharTerminal(open, c, close) {
      return c.visit();
    },

    terminalChar(_) {
      return common.unescapeChar(this.sourceString);
    },

    escapeChar(_) {
      return this.sourceString;
    },

    NonemptyListOf(x, _, xs) {
      return [x.visit()].concat(xs.visit());
    },
    EmptyListOf() {
      return [];
    },

    _terminal() {
      return this.primitiveValue;
    }
  });
  return helpers(match).visit();
}

function compileAndLoad(source, namespace) {
  const m = ohmGrammar.match(source, 'Grammars');
  if (m.failed()) {
    throw errors.grammarSyntaxError(m);
  }
  return buildGrammar(m, namespace);
}

// Return the contents of a script element, fetching it via XHR if necessary.
function getScriptElementContents(el) {
  if (!isElement(el)) {
    throw new TypeError('Expected a DOM Node, got ' + common.unexpectedObjToString(el));
  }
  if (el.type !== 'text/ohm-js') {
    throw new Error('Expected a script tag with type="text/ohm-js", got ' + el);
  }
  return el.getAttribute('src') ? load(el.getAttribute('src')) : el.innerHTML;
}

function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);

  // Ensure that the source contained no more than one grammar definition.
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error('Missing grammar definition');
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
        util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) +
        'Found more than one grammar definition -- use ohm.grammars() instead.');
  }
  return ns[grammarNames[0]]; // Return the one and only grammar.
}

function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== 'string') {
    // For convenience, detect Node.js Buffer objects and automatically call toString().
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
          'Expected string as first argument, got ' + common.unexpectedObjToString(source));
    }
  }
  compileAndLoad(source, ns);
  return ns;
}

function grammarFromScriptElement(optNode) {
  let node = optNode;
  if (isUndefined(node)) {
    const nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
    if (nodeList.length !== 1) {
      throw new Error(
          'Expected exactly one script tag with type="text/ohm-js", found ' + nodeList.length);
    }
    node = nodeList[0];
  }
  return grammar(getScriptElementContents(node));
}

function grammarsFromScriptElements(optNodeOrNodeList) {
  // Simple case: the argument is a DOM node.
  if (isElement(optNodeOrNodeList)) {
    return grammars(optNodeOrNodeList);
  }
  // Otherwise, it must be either undefined or a NodeList.
  let nodeList = optNodeOrNodeList;
  if (isUndefined(nodeList)) {
    // Find all script elements with type="text/ohm-js".
    nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
  } else if (typeof nodeList === 'string' || (!isElement(nodeList) && !isArrayLike(nodeList))) {
    throw new TypeError('Expected a Node, NodeList, or Array, but got ' + nodeList);
  }
  const ns = Namespace.createNamespace();
  for (let i = 0; i < nodeList.length; ++i) {
    // Copy the new grammars into `ns` to keep the namespace flat.
    common.extend(ns, grammars(getScriptElementContents(nodeList[i]), ns));
  }
  return ns;
}

function makeRecipe(recipe) {
  if (typeof recipe === 'function') {
    return recipe.call(new Builder());
  } else {
    if (typeof recipe === 'string') {
      // stringified JSON recipe
      recipe = JSON.parse(recipe);
    }
    return (new Builder()).fromRecipe(recipe);
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

// Stuff that users should know about
module.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null, // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util,
  extras: __webpack_require__(/*! ../extras */ "./node_modules/ohm-js/extras/index.js"),
  version
};

// Stuff for testing, etc.
module.exports._buildGrammar = buildGrammar;
module.exports._setDocumentInterfaceForTesting = function(doc) { documentInterface = doc; };

// Late initialization for stuff that is bootstrapped.

Grammar.BuiltInRules = __webpack_require__(/*! ../dist/built-in-rules */ "./node_modules/ohm-js/dist/built-in-rules.js");
util.announceBuiltInRules(Grammar.BuiltInRules);

module.exports.ohmGrammar = ohmGrammar = __webpack_require__(/*! ../dist/ohm-grammar */ "./node_modules/ohm-js/dist/ohm-grammar.js");
Grammar.initApplicationParser(ohmGrammar, buildGrammar);


/***/ }),

/***/ "./node_modules/ohm-js/src/nodes.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/nodes.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

class Node {
  constructor(grammar, ctorName, matchLength) {
    this.grammar = grammar;
    this.ctorName = ctorName;
    this.matchLength = matchLength;
  }

  numChildren() {
    return this.children ? this.children.length : 0;
  }

  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }

  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }

  hasChildren() {
    return this.numChildren() > 1;
  }

  hasNoChildren() {
    return !this.hasChildren();
  }

  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
          'cannot get only child of a node of type ' + this.ctorName +
          ' (it has ' + this.numChildren() + ' children)');
    } else {
      return this.firstChild();
    }
  }

  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get first child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(0);
    }
  }

  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get last child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }

  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childBefore() called w/ an argument that is not a child');
    } else if (childIdx === 0) {
      throw new Error('cannot get child before first child');
    } else {
      return this.childAt(childIdx - 1);
    }
  }

  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childAfter() called w/ an argument that is not a child');
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error('cannot get child after last child');
    } else {
      return this.childAt(childIdx + 1);
    }
  }

  isTerminal() {
    return false;
  }

  isNonterminal() {
    return false;
  }

  isIteration() {
    return false;
  }

  isOptional() {
    return false;
  }

  toJSON() {
    return {[this.ctorName]: this.children};
  }
}

// Terminals

class TerminalNode extends Node {
  constructor(grammar, value) {
    const matchLength = value ? value.length : 0;
    super(grammar, '_terminal', matchLength);
    this.primitiveValue = value;
  }

  isTerminal() {
    return true;
  }

  toJSON() {
    return {[this.ctorName]: this.primitiveValue};
  }
}

// Nonterminals

class NonterminalNode extends Node {
  constructor(grammar, ruleName, children, childOffsets, matchLength) {
    super(grammar, ruleName, matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
  }

  isNonterminal() {
    return true;
  }

  isLexical() {
    return common.isLexical(this.ctorName);
  }

  isSyntactic() {
    return common.isSyntactic(this.ctorName);
  }
}

// Iterations

class IterationNode extends Node {
  constructor(grammar, children, childOffsets, matchLength, isOptional) {
    super(grammar, '_iter', matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }

  isIteration() {
    return true;
  }

  isOptional() {
    return this.optional;
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  Node,
  TerminalNode,
  NonterminalNode,
  IterationNode
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js":
/*!************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Return true if we should skip spaces preceding this expression in a syntactic context.
*/
pexprs.PExpr.prototype.allowsSkippingPrecedingSpace = common.abstract(
    'allowsSkippingPrecedingSpace'
);

/*
  Generally, these are all first-order expressions and (with the exception of Apply)
  directly read from the input stream.
*/
pexprs.any.allowsSkippingPrecedingSpace =
pexprs.end.allowsSkippingPrecedingSpace =
pexprs.Apply.prototype.allowsSkippingPrecedingSpace =
pexprs.Terminal.prototype.allowsSkippingPrecedingSpace =
pexprs.Range.prototype.allowsSkippingPrecedingSpace =
pexprs.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};

/*
  Higher-order expressions that don't directly consume input.
*/
pexprs.Alt.prototype.allowsSkippingPrecedingSpace =
pexprs.Iter.prototype.allowsSkippingPrecedingSpace =
pexprs.Lex.prototype.allowsSkippingPrecedingSpace =
pexprs.Lookahead.prototype.allowsSkippingPrecedingSpace =
pexprs.Not.prototype.allowsSkippingPrecedingSpace =
pexprs.Param.prototype.allowsSkippingPrecedingSpace =
pexprs.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

let BuiltInRules;

util.awaitBuiltInRules(g => { BuiltInRules = g; });

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

let lexifyCount;

pexprs.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.PExpr.prototype._assertAllApplicationsAreValid = common.abstract(
    '_assertAllApplicationsAreValid'
);

pexprs.any._assertAllApplicationsAreValid =
pexprs.end._assertAllApplicationsAreValid =
pexprs.Terminal.prototype._assertAllApplicationsAreValid =
pexprs.Range.prototype._assertAllApplicationsAreValid =
pexprs.Param.prototype._assertAllApplicationsAreValid =
pexprs.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  // no-op
};

pexprs.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
  lexifyCount--;
};

pexprs.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Iter.prototype._assertAllApplicationsAreValid =
pexprs.Not.prototype._assertAllApplicationsAreValid =
pexprs.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  const ruleInfo = grammar.rules[this.ruleName];

  // Make sure that the rule exists...
  if (!ruleInfo) {
    throw errors.undeclaredRule(this.ruleName, grammar.name, this.source);
  }

  // ...and that this application is allowed
  if (common.isSyntactic(this.ruleName) && (!common.isSyntactic(ruleName) || lexifyCount > 0)) {
    throw errors.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }

  // ...and that this application has the correct number of arguments
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }

  // ...and that all of the argument expressions only have valid applications and have arity 1.
  const self = this;
  this.args.forEach(arg => {
    arg._assertAllApplicationsAreValid(ruleName, grammar);
    if (arg.getArity() !== 1) {
      throw errors.invalidParameter(self.ruleName, arg);
    }
  });

  // Extra checks for "special" applications

  // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.
  if (BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive) {
    if (!(this.args[0] instanceof pexprs.Terminal)) {
      throw errors.incorrectArgumentType('a Terminal (e.g. \"abc\")', this.args[0]);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertChoicesHaveUniformArity = common.abstract(
    'assertChoicesHaveUniformArity'
);

pexprs.any.assertChoicesHaveUniformArity =
pexprs.end.assertChoicesHaveUniformArity =
pexprs.Terminal.prototype.assertChoicesHaveUniformArity =
pexprs.Range.prototype.assertChoicesHaveUniformArity =
pexprs.Param.prototype.assertChoicesHaveUniformArity =
pexprs.Lex.prototype.assertChoicesHaveUniformArity =
pexprs.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op
};

pexprs.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};

pexprs.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // Extend is a special case of Alt that's guaranteed to have exactly two
  // cases: [extensions, origBody].
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};

pexprs.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};

pexprs.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op (not required b/c the nested expr doesn't show up in the CST)
};

pexprs.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // The arities of the parameter expressions is required to be 1 by
  // `assertAllApplicationsAreValid()`.
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertIteratedExprsAreNotNullable = common.abstract(
    'assertIteratedExprsAreNotNullable'
);

pexprs.any.assertIteratedExprsAreNotNullable =
pexprs.end.assertIteratedExprsAreNotNullable =
pexprs.Terminal.prototype.assertIteratedExprsAreNotNullable =
pexprs.Range.prototype.assertIteratedExprsAreNotNullable =
pexprs.Param.prototype.assertIteratedExprsAreNotNullable =
pexprs.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // no-op
};

pexprs.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // Note: this is the implementation of this method for `Star` and `Plus` expressions.
  // It is overridden for `Opt` below.
  this.expr.assertIteratedExprsAreNotNullable(grammar);
  if (this.expr.isNullable(grammar)) {
    throw errors.kleeneExprHasNullableOperand(this, []);
  }
};

pexprs.Opt.prototype.assertIteratedExprsAreNotNullable =
pexprs.Not.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lookahead.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.expr.assertIteratedExprsAreNotNullable(grammar);
};

pexprs.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.args.forEach(arg => {
    arg.assertIteratedExprsAreNotNullable(grammar);
  });
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-check.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-check.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.check = common.abstract('check');

pexprs.any.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.end.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === undefined;
};

pexprs.Terminal.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === this.obj;
};

pexprs.Range.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === typeof this.from;
};

pexprs.Param.prototype.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.Alt.prototype.check = function(grammar, vals) {
  for (let i = 0; i < this.terms.length; i++) {
    const term = this.terms[i];
    if (term.check(grammar, vals)) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.check = function(grammar, vals) {
  let pos = 0;
  for (let i = 0; i < this.factors.length; i++) {
    const factor = this.factors[i];
    if (factor.check(grammar, vals.slice(pos))) {
      pos += factor.getArity();
    } else {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.check = function(grammar, vals) {
  const arity = this.getArity();
  const columns = vals.slice(0, arity);
  if (columns.length !== arity) {
    return false;
  }
  const rowCount = columns[0].length;
  let i;
  for (i = 1; i < arity; i++) {
    if (columns[i].length !== rowCount) {
      return false;
    }
  }

  for (i = 0; i < rowCount; i++) {
    const row = [];
    for (let j = 0; j < arity; j++) {
      row.push(columns[j][i]);
    }
    if (!this.expr.check(grammar, row)) {
      return false;
    }
  }

  return true;
};

pexprs.Not.prototype.check = function(grammar, vals) {
  return true;
};

pexprs.Lookahead.prototype.check =
pexprs.Lex.prototype.check = function(grammar, vals) {
  return this.expr.check(grammar, vals);
};

pexprs.Apply.prototype.check = function(grammar, vals) {
  if (!(vals[0] instanceof nodes.Node &&
        vals[0].grammar === grammar &&
        vals[0].ctorName === this.ruleName)) {
    return false;
  }

  // TODO: think about *not* doing the following checks, i.e., trusting that the rule
  // was correctly constructed.
  const ruleNode = vals[0];
  const body = grammar.rules[this.ruleName].body;
  return body.check(grammar, ruleNode.children) && ruleNode.numChildren() === body.getArity();
};

pexprs.UnicodeChar.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === 'string';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-eval.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-eval.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const TerminalNode = nodes.TerminalNode;
const NonterminalNode = nodes.NonterminalNode;
const IterationNode = nodes.IterationNode;

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should
  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures
  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific
  data structures to be "secrets" of that class, which is good for modularity.)

  The contract of this method is as follows:
  * When the return value is `true`,
    - the state object will have `expr.getArity()` more bindings than it did before the call.
  * When the return value is `false`,
    - the state object may have more bindings than it did before the call, and
    - its input stream's position may be anywhere.

  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state
  object's bindings nor its input stream's position will change if the expression fails to match.
*/
pexprs.PExpr.prototype.eval = common.abstract('eval'); // function(state) { ... }

pexprs.any.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.end.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode(state.grammar, undefined), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Terminal.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode(state.grammar, this.obj), origPos);
    return true;
  }
};

pexprs.Range.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.from <= ch && ch <= this.to) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};

pexprs.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};

pexprs.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }

  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];

    const endOffset =
        lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
        new IterationNode(state.grammar, cols[idx], colOffsets[idx], matchLength, isOptional));
    state._bindingOffsets.push(offset);
  }
  return true;
};

pexprs.Not.prototype.eval = function(state) {
  /*
    TODO:
    - Right now we're just throwing away all of the failures that happen inside a `not`, and
      recording `this` as a failed expression.
    - Double negation should be equivalent to lookahead, but that's not the case right now wrt
      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce
      a failure for 'foo' instead.
  */

  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();

  const ans = state.eval(this.expr);

  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }

  inputStream.pos = origPos;
  return true;
};

pexprs.Lookahead.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};

pexprs.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);

  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    // This rule is already active at this position, i.e., it is left-recursive.
    return app.handleCycle(state);
  }

  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];

  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};

pexprs.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const currentLeftRecursion = posInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];

  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    // We already know about this left recursion, but it's possible there are "involved
    // applications" that we don't already know about, so...
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    // New left recursion detected! Memoize a failure to try to get a seed parse.
    memoRec = posInfo.memoize(
        memoKey,
        {matchLength: 0, examinedLength: 0, value: false, rightmostFailureOffset: -1});
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};

pexprs.Apply.prototype.reallyEval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const body = ruleInfo.body;
  const description = ruleInfo.description;

  state.enterApplication(origPosInfo, this);

  if (description) {
    state.pushFailuresInfo();
  }

  // Reset the input stream's examinedLength property so that we can track
  // the examined length of this particular application.
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;

  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;

  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec); // updates origPosInfo's maxExaminedLength
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    // This application is not involved in left recursion, so it's ok to memoize it.
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;

  if (description) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }

  // Record trace information in the memo table, so that it is available if the memoized result
  // is used later.
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }

  // Fix the input stream's examinedLength -- it should be the maximum examined length
  // across all applications, not just this one.
  inputStream.examinedLength = Math.max(inputStream.examinedLength, origInputStreamExaminedLength);

  state.exitApplication(origPosInfo, value);

  return succeeded;
};

pexprs.Apply.prototype.evalOnce = function(expr, state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;

  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    return new NonterminalNode(
        state.grammar, this.ruleName, bindings, offsets, inputStream.pos - origPos);
  } else {
    return false;
  }
};

pexprs.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }

  const inputStream = state.inputStream;

  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();

    if (state.isTracing()) {
      // Before evaluating the body again, add a trace node for this application to the memo entry.
      // Its only child is a copy of the trace node from `newValue`, which will always be the last
      // element in `state.trace`.
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace(
          state.input, origPos, inputStream.pos, this, true, [newValue], [seedTrace.clone()]);
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1); // Drop the trace for the old seed.
    }
  }
  if (state.isTracing()) {
    // The last entry is for an unused result -- pop it and save it in the "real" entry.
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};

pexprs.UnicodeChar.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-generateExample.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-generateExample.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Helpers
// --------------------------------------------------------------------

function flatten(listOfLists) {
  return Array.prototype.concat.apply([], listOfLists);
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.generateExample = common.abstract('generateExample');

function categorizeExamples(examples) {
  // A list of rules that the system needs examples of, in order to generate an example
  //   for the current rule
  let examplesNeeded = examples.filter(example => example.hasOwnProperty('examplesNeeded'))
      .map(example => example.examplesNeeded);

  examplesNeeded = flatten(examplesNeeded);

  const uniqueExamplesNeeded = {};
  for (let i = 0; i < examplesNeeded.length; i++) {
    const currentExampleNeeded = examplesNeeded[i];
    uniqueExamplesNeeded[currentExampleNeeded] = true;
  }
  examplesNeeded = Object.keys(uniqueExamplesNeeded);

  // A list of successfully generated examples
  const successfulExamples = examples.filter(example => example.hasOwnProperty('value'))
      .map(item => item.value);

  // This flag returns true if the system cannot generate the rule it is currently
  //   attempting to generate, regardless of whether or not it has the examples it needs.
  //   Currently, this is only used in overriding generators to prevent the system from
  //   generating examples for certain rules (e.g. 'ident').
  const needHelp = examples.some(item => item.needHelp);

  return {
    examplesNeeded,
    successfulExamples,
    needHelp
  };
}

pexprs.any.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return {value: String.fromCharCode(Math.floor(Math.random() * 255))};
};

// Assumes that terminal's object is always a string
pexprs.Terminal.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: this.obj};
};

pexprs.Range.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  const rangeSize = this.to.charCodeAt(0) - this.from.charCodeAt(0);
  return {value: String.fromCharCode(
      this.from.charCodeAt(0) + Math.floor(rangeSize * Math.random())
  )};
};

pexprs.Param.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return actuals[this.index].generateExample(grammar, examples, inSyntacticContext, actuals);
};

pexprs.Alt.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  // items -> termExamples
  const termExamples = this.terms.map(term => {
    return term.generateExample(grammar, examples, inSyntacticContext, actuals);
  });

  const categorizedExamples = categorizeExamples(termExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // Alt can contain both an example and a request for examples
  if (successfulExamples.length > 0) {
    const i = Math.floor(Math.random() * successfulExamples.length);
    ans.value = successfulExamples[i];
  }
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }
  ans.needHelp = needHelp;

  return ans;
};

pexprs.Seq.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const factorExamples = this.factors.map(factor => {
    return factor.generateExample(grammar, examples, inSyntacticContext, actuals);
  });
  const categorizedExamples = categorizeExamples(factorExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // In a Seq, all pieces must succeed in order to have a successful example.
  if (examplesNeeded.length > 0 || needHelp) {
    ans.examplesNeeded = examplesNeeded;
    ans.needHelp = needHelp;
  } else {
    ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  }

  return ans;
};

pexprs.Iter.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const rangeTimes = Math.min(this.maxNumMatches - this.minNumMatches, 3);
  const numTimes = Math.floor(Math.random() * (rangeTimes + 1) + this.minNumMatches);
  const items = [];

  for (let i = 0; i < numTimes; i++) {
    items.push(this.expr.generateExample(grammar, examples, inSyntacticContext, actuals));
  }

  const categorizedExamples = categorizeExamples(items);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;

  const ans = {};

  // It's always either one or the other.
  // TODO: instead of ' ', call 'spaces.generateExample()'
  ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }

  return ans;
};

// Right now, 'Not' and 'Lookahead' generate nothing and assume that whatever follows will
//   work according to the encoded constraints.
pexprs.Not.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lookahead.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lex.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return this.expr.generateExample(grammar, examples, false, actuals);
};

pexprs.Apply.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const ans = {};

  const ruleName = this.substituteParams(actuals).toString();

  if (!examples.hasOwnProperty(ruleName)) {
    ans.examplesNeeded = [ruleName];
  } else {
    const relevantExamples = examples[ruleName];
    const i = Math.floor(Math.random() * relevantExamples.length);
    ans.value = relevantExamples[i];
  }

  return ans;
};

pexprs.UnicodeChar.prototype.generateExample = function(
    grammar, examples, inSyntacticContext, actuals) {
  let char;
  switch (this.category) {
    case 'Lu': char = 'Á'; break;
    case 'Ll': char = 'ŏ'; break;
    case 'Lt': char = 'ǅ'; break;
    case 'Lm': char = 'ˮ'; break;
    case 'Lo': char = 'ƻ'; break;

    case 'Nl': char = 'ↂ'; break;
    case 'Nd': char = '½'; break;

    case 'Mn': char = '\u0487'; break;
    case 'Mc': char = 'ि'; break;

    case 'Pc': char = '⁀'; break;

    case 'Zs': char = '\u2001'; break;

    case 'L': char = 'Á'; break;
    case 'Ltmo': char = 'ǅ'; break;
  }
  return {value: char}; // 💩
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-getArity.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-getArity.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.getArity = common.abstract('getArity');

pexprs.any.getArity =
pexprs.end.getArity =
pexprs.Terminal.prototype.getArity =
pexprs.Range.prototype.getArity =
pexprs.Param.prototype.getArity =
pexprs.Apply.prototype.getArity =
pexprs.UnicodeChar.prototype.getArity = function() {
  return 1;
};

pexprs.Alt.prototype.getArity = function() {
  // This is ok b/c all terms must have the same arity -- this property is
  // checked by the Grammar constructor.
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};

pexprs.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};

pexprs.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};

pexprs.Not.prototype.getArity = function() {
  return 0;
};

pexprs.Lookahead.prototype.getArity =
pexprs.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-introduceParams.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-introduceParams.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Called at grammar creation time to rewrite a rule body, replacing each reference to a formal
  parameter with a `Param` node. Returns a PExpr -- either a new one, or the original one if
  it was modified in place.
*/
pexprs.PExpr.prototype.introduceParams = common.abstract('introduceParams');

pexprs.any.introduceParams =
pexprs.end.introduceParams =
pexprs.Terminal.prototype.introduceParams =
pexprs.Range.prototype.introduceParams =
pexprs.Param.prototype.introduceParams =
pexprs.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};

pexprs.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};

pexprs.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};

pexprs.Iter.prototype.introduceParams =
pexprs.Not.prototype.introduceParams =
pexprs.Lookahead.prototype.introduceParams =
pexprs.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};

pexprs.Apply.prototype.introduceParams = function(formals) {
  const index = formals.indexOf(this.ruleName);
  if (index >= 0) {
    if (this.args.length > 0) {
      // TODO: Should this be supported? See issue #64.
      throw new Error('Parameterized rules cannot be passed as arguments to another rule.');
    }
    return new pexprs.Param(index).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-isNullable.js":
/*!******************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-isNullable.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns `true` if this parsing expression may accept without consuming any input.
pexprs.PExpr.prototype.isNullable = function(grammar) {
  return this._isNullable(grammar, Object.create(null));
};

pexprs.PExpr.prototype._isNullable = common.abstract('_isNullable');

pexprs.any._isNullable =
pexprs.Range.prototype._isNullable =
pexprs.Param.prototype._isNullable =
pexprs.Plus.prototype._isNullable =
pexprs.UnicodeChar.prototype._isNullable = function(grammar, memo) {
  return false;
};

pexprs.end._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Terminal.prototype._isNullable = function(grammar, memo) {
  if (typeof this.obj === 'string') {
    // This is an over-simplification: it's only correct if the input is a string. If it's an array
    // or an object, then the empty string parsing expression is not nullable.
    return this.obj === '';
  } else {
    return false;
  }
};

pexprs.Alt.prototype._isNullable = function(grammar, memo) {
  return this.terms.length === 0 ||
      this.terms.some(term => term._isNullable(grammar, memo));
};

pexprs.Seq.prototype._isNullable = function(grammar, memo) {
  return this.factors.every(factor => factor._isNullable(grammar, memo));
};

pexprs.Star.prototype._isNullable =
pexprs.Opt.prototype._isNullable =
pexprs.Not.prototype._isNullable =
pexprs.Lookahead.prototype._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Lex.prototype._isNullable = function(grammar, memo) {
  return this.expr._isNullable(grammar, memo);
};

pexprs.Apply.prototype._isNullable = function(grammar, memo) {
  const key = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key)) {
    const body = grammar.rules[this.ruleName].body;
    const inlined = body.substituteParams(this.args);
    memo[key] = false; // Prevent infinite recursion for recursive rules.
    memo[key] = inlined._isNullable(grammar, memo);
  }
  return memo[key];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-outputRecipe.js":
/*!********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-outputRecipe.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.outputRecipe = common.abstract('outputRecipe');

pexprs.any.outputRecipe = function(formals, grammarInterval) {
  return ['any', getMetaInfo(this, grammarInterval)];
};

pexprs.end.outputRecipe = function(formals, grammarInterval) {
  return ['end', getMetaInfo(this, grammarInterval)];
};

pexprs.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'terminal',
    getMetaInfo(this, grammarInterval),
    this.obj
  ];
};

pexprs.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'range',
    getMetaInfo(this, grammarInterval),
    this.from,
    this.to
  ];
};

pexprs.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'param',
    getMetaInfo(this, grammarInterval),
    this.index
  ];
};

pexprs.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'alt',
    getMetaInfo(this, grammarInterval)
  ].concat(this.terms.map(term => term.outputRecipe(formals, grammarInterval)));
};

pexprs.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0]; // [extension, original]
  return extension.outputRecipe(formals, grammarInterval);
};

pexprs.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    'splice',
    getMetaInfo(this, grammarInterval),
    beforeTerms.map(term => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map(term => term.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'seq',
    getMetaInfo(this, grammarInterval)
  ].concat(this.factors.map(factor => factor.outputRecipe(formals, grammarInterval)));
};

pexprs.Star.prototype.outputRecipe =
pexprs.Plus.prototype.outputRecipe =
pexprs.Opt.prototype.outputRecipe =
pexprs.Not.prototype.outputRecipe =
pexprs.Lookahead.prototype.outputRecipe =
pexprs.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};

pexprs.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'app',
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map(arg => arg.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'unicodeChar',
    getMetaInfo(this, grammarInterval),
    this.category
  ];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-substituteParams.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-substituteParams.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a PExpr that results from recursively replacing every formal parameter (i.e., instance
  of `Param`) inside this PExpr with its actual value from `actuals` (an Array).

  The receiver must not be modified; a new PExpr must be returned if any replacement is necessary.
*/
// function(actuals) { ... }
pexprs.PExpr.prototype.substituteParams = common.abstract('substituteParams');

pexprs.any.substituteParams =
pexprs.end.substituteParams =
pexprs.Terminal.prototype.substituteParams =
pexprs.Range.prototype.substituteParams =
pexprs.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};

pexprs.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};

pexprs.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs.Alt(
      this.terms.map(term => term.substituteParams(actuals)));
};

pexprs.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs.Seq(
      this.factors.map(factor => factor.substituteParams(actuals)));
};

pexprs.Iter.prototype.substituteParams =
pexprs.Not.prototype.substituteParams =
pexprs.Lookahead.prototype.substituteParams =
pexprs.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};

pexprs.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    // Avoid making a copy of this application, as an optimization
    return this;
  } else {
    const args = this.args.map(arg => arg.substituteParams(actuals));
    return new pexprs.Apply(this.ruleName, args);
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toArgumentNameList.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const {copyWithoutDuplicates} = common;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}

function resolveDuplicatedNames(argumentNameList) {
  // `count` is used to record the number of times each argument name occurs in the list,
  // this is useful for checking duplicated argument name. It maps argument names to ints.
  const count = Object.create(null);
  argumentNameList.forEach(argName => {
    count[argName] = (count[argName] || 0) + 1;
  });

  // Append subscripts ('_1', '_2', ...) to duplicate argument names.
  Object.keys(count).forEach(dupArgName => {
    if (count[dupArgName] <= 1) {
      return;
    }

    // This name shows up more than once, so add subscripts.
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + '_' + subscript++;
      }
    });
  });
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a list of strings that will be used as the default argument names for its receiver
  (a pexpr) in a semantic action. This is used exclusively by the Semantics Editor.

  `firstArgIndex` is the 1-based index of the first argument name that will be generated for this
  pexpr. It enables us to name arguments positionally, e.g., if the second argument is a
  non-alphanumeric terminal like "+", it will be named '$2'.

  `noDupCheck` is true if the caller of `toArgumentNameList` is not a top level caller. It enables
  us to avoid nested duplication subscripts appending, e.g., '_1_1', '_1_2', by only checking
  duplicates at the top level.

  Here is a more elaborate example that illustrates how this method works:
  `(a "+" b).toArgumentNameList(1)` evaluates to `['a', '$2', 'b']` with the following recursive
  calls:

    (a).toArgumentNameList(1) -> ['a'],
    ("+").toArgumentNameList(2) -> ['$2'],
    (b).toArgumentNameList(3) -> ['b']

  Notes:
  * This method must only be called on well-formed expressions, e.g., the receiver must
    not have any Alt sub-expressions with inconsistent arities.
  * e.getArity() === e.toArgumentNameList(1).length
*/
// function(firstArgIndex, noDupCheck) { ... }
pexprs.PExpr.prototype.toArgumentNameList = common.abstract('toArgumentNameList');

pexprs.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['any'];
};

pexprs.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['end'];
};

pexprs.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === 'string' && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    // If this terminal is a valid suffix for a JS identifier, just prepend it with '_'
    return ['_' + this.obj];
  } else {
    // Otherwise, name it positionally.
    return ['$' + firstArgIndex];
  }
};

pexprs.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + '_to_' + this.to;
  // If the `argName` is not valid then try to prepend a `_`.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '_' + argName;
  }
  // If the `argName` still not valid after prepending a `_`, then name it positionally.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '$' + firstArgIndex;
  }
  return [argName];
};

pexprs.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // `termArgNameLists` is an array of arrays where each row is the
  // argument name list that corresponds to a term in this alternation.
  const termArgNameLists = this.terms.map(term => term.toArgumentNameList(firstArgIndex, true));

  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join('_or_'));
  }

  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // Generate the argument name list, without worrying about duplicates.
  let argumentNameList = [];
  this.factors.forEach(factor => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);

    // Shift the firstArgIndex to take this factor's argument names into account.
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck)
      .map(exprArgumentString => exprArgumentString[exprArgumentString.length - 1] === 's' ?
          exprArgumentString + 'es' :
          exprArgumentString + 's');
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(argName => {
    return 'opt' + argName[0].toUpperCase() + argName.slice(1);
  });
};

pexprs.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};

pexprs.Lookahead.prototype.toArgumentNameList =
pexprs.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};

pexprs.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};

pexprs.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['$' + firstArgIndex];
};

pexprs.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['param' + this.index];
};

// "Value pexprs" (Value, Str, Arr, Obj) are going away soon, so we don't worry about them here.


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toDisplayString.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toDisplayString.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns a string representing the PExpr, for use as a UI label, etc.
pexprs.PExpr.prototype.toDisplayString = common.abstract('toDisplayString');

pexprs.Alt.prototype.toDisplayString =
pexprs.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return '[' + this.constructor.name + ']';
};

pexprs.any.toDisplayString =
pexprs.end.toDisplayString =
pexprs.Iter.prototype.toDisplayString =
pexprs.Not.prototype.toDisplayString =
pexprs.Lookahead.prototype.toDisplayString =
pexprs.Lex.prototype.toDisplayString =
pexprs.Terminal.prototype.toDisplayString =
pexprs.Range.prototype.toDisplayString =
pexprs.Param.prototype.toDisplayString = function() {
  return this.toString();
};

pexprs.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toDisplayString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toDisplayString = function() {
  return 'Unicode [' + this.category + '] character';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toFailure.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toFailure.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.toFailure = common.abstract('toFailure');

pexprs.any.toFailure = function(grammar) {
  return new Failure(this, 'any object', 'description');
};

pexprs.end.toFailure = function(grammar) {
  return new Failure(this, 'end of input', 'description');
};

pexprs.Terminal.prototype.toFailure = function(grammar) {
  return new Failure(this, this.obj, 'string');
};

pexprs.Range.prototype.toFailure = function(grammar) {
  // TODO: come up with something better
  return new Failure(this, JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');
};

pexprs.Not.prototype.toFailure = function(grammar) {
  const description = this.expr === pexprs.any ?
      'nothing' :
      'not ' + this.expr.toFailure(grammar);
  return new Failure(this, description, 'description');
};

pexprs.Lookahead.prototype.toFailure = function(grammar) {
  return this.expr.toFailure(grammar);
};

pexprs.Apply.prototype.toFailure = function(grammar) {
  let description = grammar.rules[this.ruleName].description;
  if (!description) {
    const article = (/^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a');
    description = article + ' ' + this.ruleName;
  }
  return new Failure(this, description, 'description');
};

pexprs.UnicodeChar.prototype.toFailure = function(grammar) {
  return new Failure(this, 'a Unicode [' + this.category + '] character', 'description');
};

pexprs.Alt.prototype.toFailure = function(grammar) {
  const fs = this.terms.map(t => t.toFailure(grammar));
  const description = '(' + fs.join(' or ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Seq.prototype.toFailure = function(grammar) {
  const fs = this.factors.map(f => f.toFailure(grammar));
  const description = '(' + fs.join(' ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Iter.prototype.toFailure = function(grammar) {
  const description = '(' + this.expr.toFailure(grammar) + this.operator + ')';
  return new Failure(this, description, 'description');
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toString.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toString.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.
  Note that this is not an iff (<==>): e.g.,
  (~"b" "a").toString() !== ("a").toString(), even though
  ~"b" "a" and "a" are interchangeable in any grammar,
  both in terms of the languages they accept and their arities.
*/
pexprs.PExpr.prototype.toString = common.abstract('toString');

pexprs.any.toString = function() {
  return 'any';
};

pexprs.end.toString = function() {
  return 'end';
};

pexprs.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};

pexprs.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);
};

pexprs.Param.prototype.toString = function() {
  return '$' + this.index;
};

pexprs.Lex.prototype.toString = function() {
  return '#(' + this.expr.toString() + ')';
};

pexprs.Alt.prototype.toString = function() {
  return this.terms.length === 1 ?
    this.terms[0].toString() :
    '(' + this.terms.map(term => term.toString()).join(' | ') + ')';
};

pexprs.Seq.prototype.toString = function() {
  return this.factors.length === 1 ?
    this.factors[0].toString() :
    '(' + this.factors.map(factor => factor.toString()).join(' ') + ')';
};

pexprs.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};

pexprs.Not.prototype.toString = function() {
  return '~' + this.expr;
};

pexprs.Lookahead.prototype.toString = function() {
  return '&' + this.expr;
};

pexprs.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toString = function() {
  return '\\p{' + this.category + '}';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const UnicodeCategories = __webpack_require__(/*! ../third_party/UnicodeCategories */ "./node_modules/ohm-js/third_party/UnicodeCategories.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// General stuff

class PExpr {
  constructor() {
    if (this.constructor === PExpr) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }

  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}

// Any

const any = Object.create(PExpr.prototype);

// End

const end = Object.create(PExpr.prototype);

// Terminals

class Terminal extends PExpr {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}

// Ranges

class Range extends PExpr {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
  }
}

// Parameters

class Param extends PExpr {
  constructor(index) {
    super();
    this.index = index;
  }
}

// Alternation

class Alt extends PExpr {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}

// Extend is an implementation detail of rule extension

class Extend extends Alt {
  constructor(superGrammar, name, body) {
    const origBody = superGrammar.rules[name].body;
    super([body, origBody]);

    this.superGrammar = superGrammar;
    this.name = name;
    this.body = body;
  }
}

// Splice is an implementation detail of rule overriding with the `...` operator.
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);

    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}

// Sequences

class Seq extends PExpr {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}

// Iterators and optionals

class Iter extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Star extends Iter {}
class Plus extends Iter {}
class Opt extends Iter {}

Star.prototype.operator = '*';
Plus.prototype.operator = '+';
Opt.prototype.operator = '?';

Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;

Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;

// Predicates

class Not extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Lookahead extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// "Lexification"

class Lex extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// Rule application

class Apply extends PExpr {
  constructor(ruleName, args=[]) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }

  isSyntactic() {
    return common.isSyntactic(this.ruleName);
  }

  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, '_memoKey', {value: this.toString()});
    }
    return this._memoKey;
  }
}

// Unicode character

class UnicodeChar extends PExpr {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.PExpr = PExpr;
exports.any = any;
exports.end = end;
exports.Terminal = Terminal;
exports.Range = Range;
exports.Param = Param;
exports.Alt = Alt;
exports.Extend = Extend;
exports.Splice = Splice;
exports.Seq = Seq;
exports.Iter = Iter;
exports.Star = Star;
exports.Plus = Plus;
exports.Opt = Opt;
exports.Not = Not;
exports.Lookahead = Lookahead;
exports.Lex = Lex;
exports.Apply = Apply;
exports.UnicodeChar = UnicodeChar;

// --------------------------------------------------------------------
// Extensions
// --------------------------------------------------------------------

__webpack_require__(/*! ./pexprs-allowsSkippingPrecedingSpace */ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js");
__webpack_require__(/*! ./pexprs-assertAllApplicationsAreValid */ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js");
__webpack_require__(/*! ./pexprs-assertChoicesHaveUniformArity */ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js");
__webpack_require__(/*! ./pexprs-assertIteratedExprsAreNotNullable */ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js");
__webpack_require__(/*! ./pexprs-check */ "./node_modules/ohm-js/src/pexprs-check.js");
__webpack_require__(/*! ./pexprs-eval */ "./node_modules/ohm-js/src/pexprs-eval.js");
__webpack_require__(/*! ./pexprs-getArity */ "./node_modules/ohm-js/src/pexprs-getArity.js");
__webpack_require__(/*! ./pexprs-generateExample */ "./node_modules/ohm-js/src/pexprs-generateExample.js");
__webpack_require__(/*! ./pexprs-outputRecipe */ "./node_modules/ohm-js/src/pexprs-outputRecipe.js");
__webpack_require__(/*! ./pexprs-introduceParams */ "./node_modules/ohm-js/src/pexprs-introduceParams.js");
__webpack_require__(/*! ./pexprs-isNullable */ "./node_modules/ohm-js/src/pexprs-isNullable.js");
__webpack_require__(/*! ./pexprs-substituteParams */ "./node_modules/ohm-js/src/pexprs-substituteParams.js");
__webpack_require__(/*! ./pexprs-toDisplayString */ "./node_modules/ohm-js/src/pexprs-toDisplayString.js");
__webpack_require__(/*! ./pexprs-toArgumentNameList */ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js");
__webpack_require__(/*! ./pexprs-toFailure */ "./node_modules/ohm-js/src/pexprs-toFailure.js");
__webpack_require__(/*! ./pexprs-toString */ "./node_modules/ohm-js/src/pexprs-toString.js");


/***/ }),

/***/ "./node_modules/ohm-js/src/util.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/util.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Given an array of numbers `arr`, return an array of the numbers as strings,
// right-justified and padded to the same length.
function padNumbersToEqualLength(arr) {
  let maxLen = 0;
  const strings = arr.map(n => {
    const str = n.toString();
    maxLen = Math.max(maxLen, str.length);
    return str;
  });
  return strings.map(s => common.padLeft(s, maxLen));
}

// Produce a new string that would be the result of copying the contents
// of the string `src` onto `dest` at offset `offest`.
function strcpy(dest, src, offset) {
  const origDestLen = dest.length;
  const start = dest.slice(0, offset);
  const end = dest.slice(offset + src.length);
  return (start + src + end).substr(0, origDestLen);
}

// Casts the underlying lineAndCol object to a formatted message string,
// highlighting `ranges`.
function lineAndColumnToMessage(...ranges) {
  const lineAndCol = this;
  const offset = lineAndCol.offset;
  const repeatStr = common.repeatStr;

  const sb = new common.StringBuffer();
  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\n');

  // An array of the previous, current, and next line numbers as strings of equal length.
  const lineNumbers = padNumbersToEqualLength([
    lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
    lineAndCol.lineNum,
    lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
  ]);

  // Helper for appending formatting input lines to the buffer.
  const appendLine = (num, content, prefix) => {
    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\n');
  };

  // Include the previous line for context if possible.
  if (lineAndCol.prevLine != null) {
    appendLine(0, lineAndCol.prevLine, '  ');
  }
  // Line that the error occurred on.
  appendLine(1, lineAndCol.line, '> ');

  // Build up the line that points to the offset and possible indicates one or more ranges.
  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.
  const lineLen = lineAndCol.line.length;
  let indicationLine = repeatStr(' ', lineLen + 1);
  for (let i = 0; i < ranges.length; ++i) {
    let startIdx = ranges[i][0];
    let endIdx = ranges[i][1];
    common.assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');

    const lineStartOffset = offset - lineAndCol.colNum + 1;
    startIdx = Math.max(0, startIdx - lineStartOffset);
    endIdx = Math.min(endIdx - lineStartOffset, lineLen);

    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);
  }
  const gutterWidth = 2 + lineNumbers[1].length + 3;
  sb.append(repeatStr(' ', gutterWidth));
  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);
  sb.append(indicationLine.replace(/ +$/, '') + '\n');

  // Include the next line for context if possible.
  if (lineAndCol.nextLine != null) {
    appendLine(2, lineAndCol.nextLine, '  ');
  }
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

let builtInRulesCallbacks = [];

// Since Grammar.BuiltInRules is bootstrapped, most of Ohm can't directly depend it.
// This function allows modules that do depend on the built-in rules to register a callback
// that will be called later in the initialization process.
exports.awaitBuiltInRules = cb => {
  builtInRulesCallbacks.push(cb);
};

exports.announceBuiltInRules = grammar => {
  builtInRulesCallbacks.forEach(cb => {
    cb(grammar);
  });
  builtInRulesCallbacks = null;
};

// Return an object with the line and column information for the given
// offset in `str`.
exports.getLineAndColumn = (str, offset) => {
  let lineNum = 1;
  let colNum = 1;

  let currOffset = 0;
  let lineStartOffset = 0;

  let nextLine = null;
  let prevLine = null;
  let prevLineStartOffset = -1;

  while (currOffset < offset) {
    const c = str.charAt(currOffset++);
    if (c === '\n') {
      lineNum++;
      colNum = 1;
      prevLineStartOffset = lineStartOffset;
      lineStartOffset = currOffset;
    } else if (c !== '\r') {
      colNum++;
    }
  }

  // Find the end of the target line.
  let lineEndOffset = str.indexOf('\n', lineStartOffset);
  if (lineEndOffset === -1) {
    lineEndOffset = str.length;
  } else {
    // Get the next line.
    const nextLineEndOffset = str.indexOf('\n', lineEndOffset + 1);
    nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset)
                                        : str.slice(lineEndOffset, nextLineEndOffset);
    // Strip leading and trailing EOL char(s).
    nextLine = nextLine.replace(/^\r?\n/, '').replace(/\r$/, '');
  }

  // Get the previous line.
  if (prevLineStartOffset >= 0) {
    prevLine = str.slice(prevLineStartOffset, lineStartOffset)
        .replace(/\r?\n$/, ''); // Strip trailing EOL char(s).
  }

  // Get the target line, stripping a trailing carriage return if necessary.
  const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, '');

  return {
    offset,
    lineNum,
    colNum,
    line,
    prevLine,
    nextLine,
    toString: lineAndColumnToMessage
  };
};

// Return a nicely-formatted string describing the line and column for the
// given offset in `str` highlighting `ranges`.
exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
  return exports.getLineAndColumn(str, offset).toString(...ranges);
};

exports.uniqueId = (() => {
  let idCounter = 0;
  return prefix => '' + prefix + idCounter++;
})();


/***/ }),

/***/ "./node_modules/ohm-js/src/version.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/version.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global __GLOBAL_OHM_VERSION__ */



// When running under Node, read the version from package.json. For the browser,
// use a special global variable defined in the build process (see webpack.config.js).
module.exports = typeof __GLOBAL_OHM_VERSION__ === 'string'
    ? __GLOBAL_OHM_VERSION__
    : __webpack_require__(/*! ../package.json */ "./node_modules/ohm-js/package.json").version;


/***/ }),

/***/ "./node_modules/ohm-js/third_party/UnicodeCategories.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/third_party/UnicodeCategories.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Based on https://github.com/mathiasbynens/unicode-9.0.0.
// These are just categories that are used in ES5/ES2015.
// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.
module.exports = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,

  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,

  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,

  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,

  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,

  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};


/***/ }),

/***/ "./node_modules/util-extend/extend.js":
/*!********************************************!*\
  !*** ./node_modules/util-extend/extend.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = extend;
function extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || typeof add !== 'object') return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}


/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./plugins/merriam.js":
/*!****************************!*\
  !*** ./plugins/merriam.js ***!
  \****************************/
/*! exports provided: merriam, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriam", function() { return merriam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriam; });
const merriam = {
    name: "MerriamAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    cache: null,
    cacheNextItem: null,
    currentResponseItemIndex: -1,
    src: null,
    get: async function(prerequisite, arg){
        if(arg){
            if(!this.cache){
                throw Error("No result has been fetched");
            }
            if(arg == "next"){
                let results = this.cache.results;
                this.currentResponseItemIndex += 1;
                if(this.currentResponseItemIndex >= results.length){
                    this.currentResponseItemIndex = 0;
                }
                this.response = this.cache.results[this.currentResponseItemIndex];
                // put the result in the next item cache
                this.cacheNextItem = this.cache.results[this.currentResponseItemIndex];
                return JSON.stringify(this.response, null, '\t');
            }
            // here we assume that the arg is a key in the next item cache
            this.response = this.cacheNextItem[arg];
            return this.response;
        }
        const payload = parsePrerequisite(prerequisite);
        const params = {
            "method": "POST",
            "headers": {
                "content-type": "application/json"
            },
            "body": JSON.stringify(payload)
        };
        let response = await fetch(this.src, params);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            this.cache = json;
            return JSON.stringify(this.response, null, '\t');
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    }
}


let parsePrerequisite = (p) => {
    let pList = p.split(";");
    let payload = {};
    pList.forEach((item) => {
        let key = item.split(":")[0];
        let value = item.replace(`${key}:`, "");
        switch(key){
        case "fields":
            payload["fields"] = value.split(',');
            break;
        case "weights":
            let weights = {};
            value.split(",").forEach((w) => {
                let [w_name, w_value] = w.split(":");
                weights[w_name] = Number(w_value);
            });
            payload["weights"] = weights;
            break;
        case "doc_ids":
            payload["doc_ids"] = value.split(",");
            break;
        case "limit":
            payload["limit"] = Number(value);
            break;
        }
    });
    return payload;
}





/***/ }),

/***/ "./plugins/plugins.js":
/*!****************************!*\
  !*** ./plugins/plugins.js ***!
  \****************************/
/*! exports provided: plugins, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugins", function() { return plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return plugins; });
/* harmony import */ var _testAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./testAPI.js */ "./plugins/testAPI.js");
/* harmony import */ var _merriam_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./merriam.js */ "./plugins/merriam.js");



const plugins = {
    "MerriamAPI": _merriam_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    "TestAPI": _testAPI_js__WEBPACK_IMPORTED_MODULE_0__["default"]
}




/***/ }),

/***/ "./plugins/testAPI.js":
/*!****************************!*\
  !*** ./plugins/testAPI.js ***!
  \****************************/
/*! exports provided: test, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test", function() { return test; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return test; });
const test = {
    name: "TestAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    src: null,
    get: async function(prerequisite, key){
        if(key){
            if(!this.response){
                throw Error("No result has been fetched");
            }
            return this.response[key];
        }
        let src = this.src;
        if(prerequisite){
            src = src + "/" + prerequisite;
        }
        let response = await fetch(src);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            return JSON.stringify(json);
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    },
};




/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9FeGVjdXRpb25TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9BdWRpby5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9DYXJkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvRHJhd2luZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0ZpZWxkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9QYXJ0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dvcmxkU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9jbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9lcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9oYW5kSW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3V0aWxzL21lcnJpYW1JbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9zZXJpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVyLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvQXJlYVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9BdWRpb1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Ccm93c2VyVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0J1dHRvblZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9DYXJkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0ZpZWxkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0hhbG8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9JbWFnZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9QYXJ0Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1Jlc291cmNlVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1N0YWNrVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1dpbmRvd1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Xb3JsZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9jb250ZXh0bWVudS9Db250ZXh0TWVudS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2NvbnRleHRtZW51L0NvbnRleHRNZW51SXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvQ29sb3JQaWNrZXJUb29sLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9Db2xvcldoZWVsV2lkZ2V0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9EcmF3aW5nVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvRXJhc2VyVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvUGVuY2lsVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JDdXN0b21MaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JMb2NhdGlvbkluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvck1lc3Nlbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yUHJvcEl0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclByb3BMaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JTdWJwYXJ0c1BhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclRhYi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvdXRpbHMvc3VicGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvQ2FyZFJvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL25hdmlnYXRvci9OYXZpZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvU3RhY2tSb3cuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvV3JhcHBlZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL2Rpc3QvYnVpbHQtaW4tcnVsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9kaXN0L29obS1ncmFtbWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZGlzdC9vcGVyYXRpb25zLWFuZC1hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZXh0cmFzL1Zpc2l0b3JGYW1pbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvc2VtYW50aWNzLXRvQVNULmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0Nhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0ZhaWx1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9HcmFtbWFyRGVjbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnB1dFN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL01hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvTmFtZXNwYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1Bvc0luZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvU2VtYW50aWNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1RyYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9ub2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWNoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1ldmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1nZW5lcmF0ZUV4YW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWdldEFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1pbnRyb2R1Y2VQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWlzTnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLW91dHB1dFJlY2lwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtc3Vic3RpdHV0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9Bcmd1bWVudE5hbWVMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy10b0Rpc3BsYXlTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLXRvRmFpbHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3RoaXJkX3BhcnR5L1VuaWNvZGVDYXRlZ29yaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsLWV4dGVuZC9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL21lcnJpYW0uanMiLCJ3ZWJwYWNrOi8vLy4vcGx1Z2lucy9wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL3BsdWdpbnMvdGVzdEFQSS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUVBQWM7QUFDL0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELFdBQVc7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxXQUFXOztBQUV4RDtBQUNBOztBQUVB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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixVQUFVLG9DQUFvQyxXQUFXO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN0UkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QjtBQUNFO0FBS007O0FBRXJDLHFCQUFxQixnREFBSTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRkFBa0I7QUFDMUIsUUFBUSwwRkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQzs7Ozs7Ozs7Ozs7OztBQzVJRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZCOzs7QUFHN0IseUJBQXlCLGdEQUFJO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsb0NBQW9DLFdBQVc7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JVRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx3REFBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2hKRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWMsY0FBYyxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBLHFGQUFxRixpQkFBaUIsWUFBWTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDbE1GO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdEQUF3RCxjQUFjO0FBQ3RFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQU1FOzs7Ozs7Ozs7Ozs7O0FDcFJGO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN4R0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFNO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1FOzs7Ozs7Ozs7Ozs7O0FDN0NGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNwZUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9FOzs7Ozs7Ozs7Ozs7O0FDOWZGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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QVkscUNBQXFDO0FBQ2pELFVBQVUsbUNBQW1DO0FBQzdDLFNBQVMsbUNBQW1DO0FBQzVDLFVBQVUscUNBQXFDO0FBQy9DLFdBQVcscUNBQXFDO0FBQ2hELFNBQVMsbUNBQW1DO0FBQzVDLFNBQVMsbUNBQW1DO0FBQzVDLFNBQVMscUNBQXFDO0FBQzlDLFNBQVMscUNBQXFDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDbFZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9EQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBLDBCQUEwQix3REFBUyxDQUFDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsTUFBTSxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDaFhGO0FBQUE7QUFBQTtBQUFBO0FBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0RBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNwVEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ2U7O0FBRXRFLGdEQUFnRCxtRUFBVzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pELGFBQWE7QUFDYiw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRSxhQUFhO0FBQ2Isb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsb0NBQW9DO0FBQ3ZHLGtFQUFrRSxnREFBZ0Q7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsb0NBQW9DO0FBQ3ZHLGtFQUFrRSxnREFBZ0Q7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZFQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN4OEJGO0FBQUE7QUFBQTtBQUFBO0FBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG9EQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEtBQUs7QUFDbEYsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDL0tGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9EQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDdEhGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG9EQUFRO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDdFdGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2xFRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTBCLHFEQUFRO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3pXRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDdlBGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDclBGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF1QztBQUNVO0FBQ0U7QUFDRTtBQUNJO0FBQ1o7QUFDN0M7O0FBRUE7QUFDQSwyQ0FBMkMscURBQVM7QUFDcEQsa0RBQWtELDBEQUFjO0FBQ2hFLG1EQUFtRCw0REFBZ0I7QUFDbkUsaURBQWlELDJEQUFlO0FBQ2hFLGdEQUFnRCw4REFBa0I7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxLQUFLLE1BQU0sS0FBSztBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDs7QUFFQSx1QkFBdUIsdURBQVM7QUFDaEMsb0NBQW9DLHVEQUFTO0FBQzdDLFNBQVM7QUFDVCxvQ0FBb0MsdURBQVM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0JBQXNCLGVBQWUsZ0JBQWdCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNnQkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csS0FBSztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3hGRjtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QyxtQ0FBbUMsV0FBVztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN6UUY7QUFBQTtBQUFBO0FBQUE7QUFBaUQ7O0FBRWpEO0FBQ0EsaURBQWlELDBEQUFjOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNqSkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDeUQ7QUFDWjtBQUNpQzs7QUFFOUUscURBQXFELDhEQUFrQjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3BMRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDSztBQUNOO0FBQ0Y7O0FBRW5DO0FBQ0EsOENBQThDLG9EQUFRO0FBQ3RELDZDQUE2QyxtREFBTztBQUNwRCw2Q0FBNkMsdURBQVc7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLG9EQUFRO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUM5UEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvREFBUTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZFQUE2RSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JMRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLEVBQUUsT0FBTztBQUNyQyxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVMsSUFBSSxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVMsSUFBSSxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBDQUEwQztBQUMxQyxLQUFLO0FBQ0wsR0FBRztBQUNILFdBQVcsS0FBSzs7QUFFaEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixrRkFBa0Y7QUFDbEYsOENBQThDO0FBQzlDLDBCQUEwQjtBQUMxQixRQUFRLEVBQUU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVB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QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6UUE7O0FBRWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDJEQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMscURBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxpREFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBVzs7QUFFbkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVc7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0MsRUFBRTtBQUM1RCx5QkFBeUIsdUNBQXVDO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCO0FBQ3RCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRFQUE0RTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7Ozs7Ozs7Ozs7Ozs7QUNqRmE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixtQkFBTyxDQUFDLGdHQUFrQztBQUNwRSxlQUFlLG1CQUFPLENBQUMscURBQVU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBS0UiLCJmaWxlIjoiZGV2U3lzdGVtLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vanMvb2JqZWN0cy9TeXN0ZW0uanNcIik7XG4iLCIvKipcbiAqIEV4ZWN1dGlvblN0YWNrXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBhIHN0YWNrIG9mXG4gKiBBY3RpdmF0aW9uQ29udGV4dCBvYmplY3RzLlxuICogSSBhbSBkZXNpZ25lZCB0byBiZSB1c2VkIGJ5IFN5c3RlbSBhcyB0aGVcbiAqIGdsb2JhbCBleGVjdXRpb24gc3RhY2suXG4gKlxuICovXG5cbmNsYXNzIEV4ZWN1dGlvblN0YWNrIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9nbG9iYWxzID0ge307XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnBvcCA9IHRoaXMucG9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHVzaCA9IHRoaXMucHVzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEdsb2JhbCA9IHRoaXMuc2V0R2xvYmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0R2xvYmFsID0gdGhpcy5nZXRHbG9iYWwuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBwb3AoKXtcbiAgICAgICAgaWYoIXRoaXMuX3N0YWNrLmxlbmd0aCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2sucG9wKCk7XG4gICAgfVxuXG4gICAgcHVzaChhbkFjdGl2YXRpb24pe1xuICAgICAgICB0aGlzLl9zdGFjay5wdXNoKGFuQWN0aXZhdGlvbik7XG4gICAgfVxuXG4gICAgc2V0R2xvYmFsKHZhck5hbWUsIHZhbHVlKXtcbiAgICAgICAgdGhpcy5fZ2xvYmFsc1t2YXJOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldEdsb2JhbCh2YXJOYW1lKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsb2JhbHNbdmFyTmFtZV07XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnQoKXtcbiAgICAgICAgaWYoIXRoaXMuX3N0YWNrLmxlbmd0aCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgZ2V0IHByZXZpb3VzKCl7XG4gICAgICAgIGlmKCF0aGlzLl9zdGFjay5sZW5ndGggPj0gMil7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMl07XG4gICAgfVxufTtcblxuY2xhc3MgQWN0aXZhdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VOYW1lLCBwYXJ0LCBpbmNvbWluZ01lc3NhZ2UsIGhhbmRsZXJGdW5jdGlvbil7XG4gICAgICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgICAgIHRoaXMubWVzc2FnZU5hbWUgPSBtZXNzYWdlTmFtZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gaW5jb21pbmdNZXNzYWdlO1xuICAgICAgICB0aGlzLmhhbmRsZXJGdW5jdGlvbiA9IGhhbmRsZXJGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5fbG9jYWxzID0ge307XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0TG9jYWwgPSB0aGlzLmdldExvY2FsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0TG9jYWwgPSB0aGlzLnNldExvY2FsLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0KHZhck5hbWUpe1xuICAgICAgICBsZXQgbG9jYWxWYWx1ZSA9IHRoaXMuZ2V0TG9jYWwodmFyTmFtZSk7XG4gICAgICAgIGlmKGxvY2FsVmFsdWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRyeSB0byByZXR1cm4gYSBnbG9iYWxcbiAgICAgICAgLy8gdmFyaWFibGVcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2suZ2V0R2xvYmFsKHZhck5hbWUpO1xuICAgIH1cblxuICAgIGdldExvY2FsKHZhck5hbWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxzW3Zhck5hbWVdO1xuICAgIH1cblxuICAgIHNldExvY2FsKHZhck5hbWUsIHZhbHVlKXtcbiAgICAgICAgdGhpcy5fbG9jYWxzW3Zhck5hbWVdID0gdmFsdWU7XG4gICAgfVxufVxuXG5leHBvcnQge1xuICAgIEV4ZWN1dGlvblN0YWNrLFxuICAgIEFjdGl2YXRpb25Db250ZXh0XG59O1xuIiwiLyoqXG4gKiBTeXN0ZW0gT2JqZWN0XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIFwidG9wXCIgb2YgdGhlXG4gKiBzeXRlbS4gSSBhbSB0aGUgcG9pbnQgb2YgY29tbXVuaWNhdGlvbiBiZXR3ZWVuXG4gKiBNb2RlbHMgYW5kIFZpZXdzLlxuICovXG5pbXBvcnQgQ2FyZCBmcm9tICcuL3BhcnRzL0NhcmQuanMnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4vcGFydHMvU3RhY2suanMnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuL3BhcnRzL0J1dHRvbi5qcyc7XG5pbXBvcnQgRmllbGQgZnJvbSAnLi9wYXJ0cy9GaWVsZC5qcyc7XG5pbXBvcnQgV29ybGRTdGFjayBmcm9tICcuL3BhcnRzL1dvcmxkU3RhY2suanMnO1xuaW1wb3J0IFdpbmRvdyBmcm9tICcuL3BhcnRzL1dpbmRvdy5qcyc7XG5pbXBvcnQgRHJhd2luZyBmcm9tICcuL3BhcnRzL0RyYXdpbmcuanMnO1xuaW1wb3J0IEF1ZGlvIGZyb20gJy4vcGFydHMvQXVkaW8uanMnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi9wYXJ0cy9Ccm93c2VyLmpzJztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL3BhcnRzL1Jlc291cmNlLmpzJztcbmltcG9ydCBJbWFnZSBmcm9tICcuL3BhcnRzL0ltYWdlLmpzJztcbmltcG9ydCBBcmVhIGZyb20gJy4vcGFydHMvQXJlYS5qcyc7XG5cbmltcG9ydCBXb3JsZFZpZXcgZnJvbSAnLi92aWV3cy9Xb3JsZFZpZXcuanMnO1xuaW1wb3J0IFN0YWNrVmlldyBmcm9tICcuL3ZpZXdzL1N0YWNrVmlldy5qcyc7XG5pbXBvcnQgQnV0dG9uVmlldyBmcm9tICcuL3ZpZXdzL0J1dHRvblZpZXcuanMnO1xuXG5pbXBvcnQgQ2FyZFZpZXcgZnJvbSAnLi92aWV3cy9DYXJkVmlldy5qcyc7XG5pbXBvcnQgV2luZG93VmlldyBmcm9tICcuL3ZpZXdzL1dpbmRvd1ZpZXcnO1xuaW1wb3J0IEZpZWxkVmlldyBmcm9tICcuL3ZpZXdzL0ZpZWxkVmlldy5qcyc7XG5pbXBvcnQgRHJhd2luZ1ZpZXcgZnJvbSAnLi92aWV3cy9kcmF3aW5nL0RyYXdpbmdWaWV3LmpzJztcbmltcG9ydCBJbWFnZVZpZXcgZnJvbSAnLi92aWV3cy9JbWFnZVZpZXcuanMnO1xuaW1wb3J0IEFyZWFWaWV3IGZyb20gJy4vdmlld3MvQXJlYVZpZXcuanMnO1xuaW1wb3J0IEF1ZGlvVmlldyBmcm9tICcuL3ZpZXdzL0F1ZGlvVmlldy5qcyc7XG5pbXBvcnQgQnJvd3NlclZpZXcgZnJvbSAnLi92aWV3cy9Ccm93c2VyVmlldy5qcyc7XG5pbXBvcnQgUmVzb3VyY2VWaWV3IGZyb20gJy4vdmlld3MvUmVzb3VyY2VWaWV3LmpzJztcblxuXG5pbXBvcnQgSGFsbyBmcm9tICcuL3ZpZXdzL0hhbG8uanMnO1xuaW1wb3J0IFNUTmF2aWdhdG9yIGZyb20gJy4vdmlld3MvbmF2aWdhdG9yL05hdmlnYXRvci5qcyc7XG5pbXBvcnQgRWRpdG9yIGZyb20gJy4vdmlld3MvZWRpdG9ycy9FZGl0b3IuanMnO1xuXG5pbXBvcnQgb2htIGZyb20gJ29obS1qcyc7XG5pbXBvcnQgaW50ZXJwcmV0ZXJTZW1hbnRpY3MgZnJvbSAnLi4vb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyc7XG5pbXBvcnQge0V4ZWN1dGlvblN0YWNrLCBBY3RpdmF0aW9uQ29udGV4dH0gZnJvbSAnLi9FeGVjdXRpb25TdGFjay5qcyc7XG5cbmltcG9ydCBpZE1ha2VyIGZyb20gJy4vdXRpbHMvaWQuanMnO1xuaW1wb3J0IFNUQ2xpcGJvYXJkIGZyb20gJy4vdXRpbHMvY2xpcGJvYXJkLmpzJztcblxuaW1wb3J0IHtCYXNpY1Byb3BlcnR5fSBmcm9tICcuL3Byb3BlcnRpZXMvUGFydFByb3BlcnRpZXMuanMnO1xuXG5pbXBvcnQgaGFuZEludGVyZmFjZSBmcm9tICcuL3V0aWxzL2hhbmRJbnRlcmZhY2UuanMnO1xuaW1wb3J0IG1lcnJpYW1TaW1TY29yZSBmcm9tICcuL3V0aWxzL21lcnJpYW1JbnRlcmZhY2UuanMnO1xuXG5pbXBvcnQge1NURGVzZXJpYWxpemVyLCBTVFNlcmlhbGl6ZXJ9IGZyb20gJy4vdXRpbHMvc2VyaWFsaXphdGlvbi5qcyc7XG5cbmltcG9ydCBwbHVnaW5zIGZyb20gJy4uLy4uL3BsdWdpbnMvcGx1Z2lucy5qcyc7XG5cbmNvbnN0IERPTXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuaW1wb3J0IGNyZWF0ZUhpZ2hsaWdodGVyIGZyb20gJy4vdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMnO1xuXG5cbmNvbnN0IFN5c3RlbSA9IHtcbiAgICBuYW1lOiBcIlN5c3RlbVwiLFxuICAgIGlkOiAtMSxcbiAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgcGFydHNCeUlkOiB7fSxcbiAgICBfY29tbWFuZEhhbmRsZXJzOiB7fSxcbiAgICBfZnVuY3Rpb25IYW5kbGVyczoge30sXG4gICAgX2Rlc2VyaWFsaXplcjogbnVsbCxcblxuICAgIC8vIEEgZGljdGlvbmFyeSBtYXBwaW5nIGF2YWlsYWJsZSBTVCByZXNvdXJjZSAoc3VjaCBhcyBwbHVnaW4pIG5hbWVzXG4gICAgYXZhaWxhYmxlUmVzb3VyY2VzOiB7fSxcblxuICAgIC8vIEEgZGljdGlvbmFyeSBtYXBwaW5nIHBhcnQgdHlwZXMgbGlrZVxuICAgIC8vICdidXR0b24nIHRvIHRoZWlyIGNsYXNzZXMgKEJ1dHRvbilcbiAgICBhdmFpbGFibGVQYXJ0czoge30sXG5cbiAgICAvLyBBIGRpY3Rpb25hcnkgbWFwcGluZyBwYXJ0IHR5cGVzIGxpa2VcbiAgICAvLyAnYnV0dG9uJyB0byB0aGVpciB2aWV3IGNsYXNzZXMgKEJ1dHRvblZpZXcpXG4gICAgYXZhaWxhYmxlVmlld3M6IHt9LFxuXG4gICAgLy8gQSByZWdpc3RyeSB0aGF0IGtlZXBzIGFsbCBzeXN0ZW0gbWVzc2FnZXMgZnJvbVxuICAgIC8vIGJlZ2lubmlnbiBvZiB0aW1lOyBUT0RPIGluIHRoZSBmdXR1cmUgd2UgbWlnaHQgd2FudFxuICAgIC8vIHRvIG5vdGUga2VlcCBhbGwgdGhpcyBpbiBtZW1vcnlcbiAgICAvLyBlYWNoIGxvZyBjb25zaXN0cyBvZjpcbiAgICAvLyBbYU1lc3NhZ2UsIChzb3VyY2VOYW1lLCBzb3VyY2VJZCksICh0YXJnZXROYW1lLCB0YXJnZXRJZCldXG4gICAgbWVzc2FnZUxvZzogW10sXG5cbiAgICAvLyBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgcGFnZSBsb2Fkcy5cbiAgICAvLyBDaGVja3MgZm9yIGFueSB2aWV3IGVsZW1lbnRzIGluIHRoZVxuICAgIC8vIHBhZ2UgYW5kIGF0dGVtcHRzIHRvIGZpbmQgc2VyaWFsaXplZFxuICAgIC8vIG1vZGVsIHN0YXRlIGZvciBlYWNoIG9mIHRoZW0uIElmIHByZXNlbnQsXG4gICAgLy8gZGVzZXJpYWxpemVzIHRoZSBtb2RlbCBhbmQgYXR0YWNoZXMgaXRcbiAgICAvLyB0byB0aGUgdmlldy5cbiAgICBpbml0aWFsTG9hZDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gbG9hZCB0aGUgYXZhaWxhYmxlIHJlc291cmNlc1xuICAgICAgICAvLyB0aGVzZSBtaWdodCBiZSBuZWVkZWQgZG93biB0aGUgbGluZVxuICAgICAgICB0aGlzLmxvYWRSZXNvdXJjZXMoKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgc2VyaWFsaXphdGlvbiBzY3JpcHQgdGFnXG4gICAgICAgIC8vIGNvbnRhaW5pbmcgSlNPTiBvZiBzZXJpYWxpemVkIGluZm9ybWF0aW9uLFxuICAgICAgICAvLyBhdHRlbXB0IHRvIGxvYWQgZnJvbSBpdFxuICAgICAgICBsZXQgc2VyaWFsaXphdGlvbkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgaWYoc2VyaWFsaXphdGlvbkVsICYmIHNlcmlhbGl6YXRpb25FbC50ZXh0ICE9IFwiXCIpe1xuICAgICAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRJbml0aWFsT3Blbk1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5uYXZpZ2F0b3Iuc2V0TW9kZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2UgcmVuZGVyIHRoZSBXb3JsZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJlaGVuc2l2ZSBFZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyKHRoaXMud29ybGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2FkRnJvbUVtcHR5KCk7XG4gXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB3ZSByZW5kZXIgdGhlIFdvcmxkIGluIHRoZVxuICAgICAgICAgICAgLy8gQ29tcHJlaGVuc2l2ZSBFZGl0b3JcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcih0aGlzLndvcmxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBhIG5ldyBjbGlwYm9hcmQgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQgPSBuZXcgU1RDbGlwYm9hcmQodGhpcyk7XG5cbiAgICAgICAgLy8gQnkgdGhpcyBwb2ludCB3ZSBzaG91bGQgaGF2ZSBhIFdvcmxkVmlldyB3aXRoXG4gICAgICAgIC8vIGEgbW9kZWwgYXR0YWNoZWQuXG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBsb2FkUmVzb3VyY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVSZXNvdXJjZXNba10gPSBwbHVnaW5zW2tdO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbG9hZEZyb21FbXB0eTogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHdvcmxkTW9kZWwgPSBuZXcgdGhpcy5hdmFpbGFibGVQYXJ0c1snd29ybGQnXSgpO1xuICAgICAgICB0aGlzLnBhcnRzQnlJZFt3b3JsZE1vZGVsLmlkXSA9IHdvcmxkTW9kZWw7XG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgdGhpcy50YWdOYW1lRm9yVmlld05hbWVkKCd3b3JsZCcpXG4gICAgICAgICk7XG4gICAgICAgIHdvcmxkVmlldy5zZXRNb2RlbCh3b3JsZE1vZGVsKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh3b3JsZFZpZXcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIHN0YWNrIG1vZGVsXG4gICAgICAgIGxldCBpbml0U3RhY2sgPSB0aGlzLm5ld01vZGVsKCdzdGFjaycsIHdvcmxkTW9kZWwuaWQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIGNhcmQgbW9kZWwgZm9yIHRoYXQgc3RhY2tcbiAgICAgICAgbGV0IGluaXRDYXJkID0gdGhpcy5uZXdNb2RlbCgnY2FyZCcsIGluaXRTdGFjay5pZCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgc3RhY2sgYW5kIGNhcmQgaWRzIFxuICAgICAgICB3b3JsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB3b3JsZE1vZGVsLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgaW5pdFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGluaXRTdGFjay5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgaW5pdFN0YWNrLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgaW5pdENhcmQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgLy8gVXBkYXRlIHNlcmlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5zZXJpYWxpemUoKTtcblxuICAgICAgICB0aGlzLnNlbmRJbml0aWFsT3Blbk1lc3NhZ2VzKCk7XG4gICAgICAgIFN5c3RlbS5uYXZpZ2F0b3Iuc2V0TW9kZWwoXG4gICAgICAgICAgICBTeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHNlbmRJbml0aWFsT3Blbk1lc3NhZ2VzOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBTZW5kIHRoZSBvcGVuV29ybGQgbWVzc2FnZSB0byB0aGUgV29ybGRTdGFja1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICAgICAgd29ybGQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuV29ybGQnLFxuICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgfSwgd29ybGQpO1xuICAgICAgICB3b3JsZC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TdGFjaycsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB3b3JsZC5jdXJyZW50U3RhY2spO1xuICAgICAgICB3b3JsZC5jdXJyZW50U3RhY2suc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuQ2FyZCcsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB3b3JsZC5jdXJyZW50U3RhY2suY3VycmVudENhcmQpO1xuICAgIH0sXG5cbiAgICBzZW5kTWVzc2FnZTogZnVuY3Rpb24oYU1lc3NhZ2UsIHNvdXJjZSwgdGFyZ2V0KXtcbiAgICAgICAgaWYoIXRhcmdldCB8fCB0YXJnZXQgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZXMgbXVzdCBiZSBzZW50IHdpdGggdGFyZ2V0IHJlY2VpdmVycyBzcGVjaWZpZWQhJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFsbCBzb3VyY2VzIHdoaWNoIHBhc3MgdGhpcyBtZXNzYWdlXG4gICAgICAgIGlmICghKFwic2VuZGVyc1wiIGluIGFNZXNzYWdlKSkge1xuICAgICAgICAgICAgYU1lc3NhZ2VbXCJzZW5kZXJzXCJdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYU1lc3NhZ2Uuc2VuZGVycy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHNvdXJjZS5uYW1lLFxuICAgICAgICAgICAgaWQ6IHNvdXJjZS5pZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5yZWNlaXZlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgfSxcblxuICAgIHJlY2VpdmVNZXNzYWdlOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIHN3aXRjaChhTWVzc2FnZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ25ld1ZpZXcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld1ZpZXcoXG4gICAgICAgICAgICAgICAgICAgIGFNZXNzYWdlLnZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBhTWVzc2FnZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBpbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGUoYU1lc3NhZ2UpO1xuICAgICAgICAgICAgY2FzZSAnY29tbWFuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbW1hbmQoYU1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2VzTm90VW5kZXJzdGFuZChhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZG9lc05vdFVuZGVyc3RhbmQ6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgaGFzIHRoZSBzaG91bGRJZ25vcmUgcHJvcGVydHlcbiAgICAgICAgLy8gc2V0IHRvIHRydWUsIGl0IG1lYW5zIHdlIHNob3VsZCBqdXN0IHN3YWxsb3dcbiAgICAgICAgLy8gdGhpcyBtZXNzYWdlIGlmIHdlIGRvbid0IHVuZGVyc3RhbmQgaXQuIFRoaXMgaXNcbiAgICAgICAgLy8gdXNlZnVsIGZvciBtZXNzYWdlcyBsaWtlIG1vdXNlIGV2ZW50cyBvbiBidXR0b25zXG4gICAgICAgIC8vIHdoaWNoIGFyZSBub3QgY2FwdHVyZWQgYnkgZGVmYXVsdCBhbmQgd291bGQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGVuZCB1cCBhcnJpdmluZyB0byB0aGlzIFN5c3RlbSBvYmplY3QgdmlhIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGRlbGVnYXRpb24gY2hhaW4uXG4gICAgICAgIGlmKGFNZXNzYWdlLnNob3VsZElnbm9yZSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gdGhpcy5wYXJ0c0J5SWRbYU1lc3NhZ2Uuc2VuZGVyc1swXS5pZF07XG4gICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBuYW1lOiBcIk1lc3NhZ2VOb3RVbmRlcnN0b29kXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBhTWVzc2FnZVxuICAgICAgICB9O1xuICAgICAgICBvcmlnaW5hbFNlbmRlci5zZW5kTWVzc2FnZShtc2csIG9yaWdpbmFsU2VuZGVyKTtcbiAgICB9LFxuXG4gICAgY29tcGlsZTogZnVuY3Rpb24oYU1lc3NhZ2Upe1xuICAgICAgICBsZXQgdGFyZ2V0T2JqZWN0ID0gdGhpcy5wYXJ0c0J5SWRbYU1lc3NhZ2UudGFyZ2V0SWRdO1xuICAgICAgICBpZighdGFyZ2V0T2JqZWN0IHx8IHRhcmdldE9iamVjdCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTeXN0ZW0gY291bGQgbm90IGNvbXBpbGUgdGFyZ2V0IG9iamVjdCAke2FNZXNzYWdlLnRhcmdldElkfWApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBpbmNvbWluZyBTaW1wbGVUYWxrIHNjcmlwdCBzdHJpbmcuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBncmFtbWF0aWNhbCBlcnJvcnMsIHJlcG9ydCB0aGVtIGFuZCBiYWlsLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBzZW1hbnRpY3Mgb24gdGhlIHRhcmdldFBhcnQsIGFkZFxuICAgICAgICAvLyB0aGUgcmVxdWlyZWQgc2VtYW50aWMgb3BlcmF0aW9ucywgYW5kIGludGVycHJldCB0aGUgdG9wXG4gICAgICAgIC8vIGxldmVsIG9mIHRoZSBzY3JpcHQsIHdoaWNoIHdpbGwgY3JlYXRlIHRoZSBKUyBoYW5kbGVyIGZ1bmN0aW9uc1xuICAgICAgICBsZXQgcGFyc2VkU2NyaXB0ID0gbGFuZ3VhZ2VHcmFtbWFyLm1hdGNoKGFNZXNzYWdlLmNvZGVTdHJpbmcpO1xuICAgICAgICBpZihwYXJzZWRTY3JpcHQuZmFpbGVkKCkpe1xuICAgICAgICAgICAgLy8gY29uc2lkZXIgdXNpbmcgdGhlIHBhcnNlIGRhdGEgZnJvbSB0cmFjZVxuICAgICAgICAgICAgLy8gZXhhbXBsZTogbGV0IHRyYWNlZFNjcmlwdCA9IGxhbmd1YWdlR3JhbW1hci50cmFjZShhTWVzc2FnZS5jb2RlU3RyaW5nKTtcbiAgICAgICAgICAgIC8vIGxldCB0cmVlID0gdHJhY2VkU2NyaXB0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkdyYW1tYXJNYXRjaEVycm9yXCIsXG4gICAgICAgICAgICAgICAgcGFyc2VkU2NyaXB0OiBwYXJzZWRTY3JpcHQsXG4gICAgICAgICAgICAgICAgcGFydElkOiBhTWVzc2FnZS50YXJnZXRJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5zZW5kTWVzc2FnZShtc2csIHRhcmdldE9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgY2xlYXIgb3V0IGFueSBjdXJyZW50bHkgY29tcGlsZWQgaGFuZGxlcnNcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBpbmNvbWluZyBzY3JpcHQgbWlnaHQgZ2V0IHJpZCBvZiB0aGVtXG4gICAgICAgICAgICB0YXJnZXRPYmplY3QuX2NvbW1hbmRIYW5kbGVycyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZW1hbnRpY3Mgb2JqZWN0IHdob3NlIHBhcnRDb250ZXh0XG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGJlIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0Ll9zZW1hbnRpY3MgPSBsYW5ndWFnZUdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgICAgICB0YXJnZXRPYmplY3QuX3NlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJTZW1hbnRpY3ModGFyZ2V0T2JqZWN0LCB0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5fc2VtYW50aWNzKHBhcnNlZFNjcmlwdCkuaW50ZXJwcmV0KCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEJlIHN1cmUgdG8gdGhlbiB1cGRhdGUgdGhlXG4gICAgICAgIC8vIHNlcmlhbGl6YXRpb24gZm9yIHRoZSB0YXJnZXRcbiAgICAgICAgLy8gcGFydCwgdGh1cyBhZGRpbmcgdGhlIHNjcmlwdCB0b1xuICAgICAgICAvLyBpdHMgc2VyaWFsaXphdGlvblxuICAgICAgICBpZihhTWVzc2FnZS5zZXJpYWxpemUpe1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWNlaXZlQ29tbWFuZDogZnVuY3Rpb24oYU1lc3NhZ2Upe1xuICAgICAgICBsZXQgaGFuZGxlciA9IHRoaXMuX2NvbW1hbmRIYW5kbGVyc1thTWVzc2FnZS5jb21tYW5kTmFtZV07XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGxldCBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9lc05vdFVuZGVyc3RhbmQoYU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5ld01vZGVsOiBmdW5jdGlvbihraW5kLCBvd25lcklkLCBuYW1lLCBidWlsZFZpZXc9dHJ1ZSl7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1vZGVsIHRoYXRcbiAgICAgICAgLy8gbWF0Y2hlcyB0aGUgb3duZXIncyBpZFxuICAgICAgICBsZXQgb3duZXJQYXJ0ID0gdGhpcy5wYXJ0c0J5SWRbb3duZXJJZF07XG4gICAgICAgIGlmKCFvd25lclBhcnQgfHwgb3duZXJQYXJ0ID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5c3RlbSBjb3VsZCBub3QgbG9jYXRlIG93bmVyIHBhcnQgd2l0aCBpZCAke293bmVySWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBjbGFzcyBjb25zdHJ1Y3RvciBmb3IgdGhlIGtpbmQgb2ZcbiAgICAgICAgLy8gcGFydCByZXF1ZXN0ZWQgYXMgYSBuZXcgbW9kZWwuIElmIG5vdCBrbm93bixcbiAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgbGV0IG1vZGVsQ2xhc3MgPSB0aGlzLmF2YWlsYWJsZVBhcnRzW2tpbmRdO1xuICAgICAgICBpZighbW9kZWxDbGFzcyl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgdW5rbm93biBwYXJ0IHR5cGU6ICR7a2luZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kZWwgPSBuZXcgbW9kZWxDbGFzcyhvd25lclBhcnQpO1xuICAgICAgICBpZihuYW1lKXtcbiAgICAgICAgICAgIG1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQobW9kZWwsICduYW1lJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0c0J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG5cbiAgICAgICAgLy8gQW55IGNyZWF0ZWQgcGFydCBtaWdodCBpbml0aWFsaXplIGl0c1xuICAgICAgICAvLyBvd24gc3VicGFydHMuIFdlIG5lZWQgdG8gbGV0IHRoZSBTeXN0ZW0ga25vd1xuICAgICAgICAvLyBhYm91dCB0aG9zZSB0b29cbiAgICAgICAgbW9kZWwuc3VicGFydHMuZm9yRWFjaChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydHNCeUlkW3N1YnBhcnQuaWRdID0gc3VicGFydDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2YWxpZCBvd25lciBwYXJ0IGZvclxuICAgICAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBwYXJ0IG1vZGVsLFxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBtb2RlbCB0byB0aGUgb3duZXInc1xuICAgICAgICAvLyBzdWJwYXJ0cyBsaXN0XG4gICAgICAgIGlmKG93bmVyUGFydCl7XG4gICAgICAgICAgICBvd25lclBhcnQuYWRkUGFydChtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlIFN5c3RlbSBhcyBhIHByb3BlcnR5IHN1YnNjcmliZXIgdG9cbiAgICAgICAgLy8gdGhlIG5ldyBtb2RlbC4gVGhpcyB3aWxsIHNlbmQgYSBtZXNzYWdlIHRvXG4gICAgICAgIC8vIHRoaXMgU3lzdGVtIG9iamVjdCB3aGVuZXZlciBhbnkgb2YgdGhpcyBtb2RlbCdzXG4gICAgICAgIC8vIHByb3BlcnRpZXMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIG1vZGVsLmFkZFByb3BlcnR5U3Vic2NyaWJlcih0aGlzKTtcblxuICAgICAgICBpZihidWlsZFZpZXcpe1xuICAgICAgICAgICAgLy8gU2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSB2aWV3IGZvciB0aGUgbW9kZWwuXG4gICAgICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBhbmQgYXR0YWNoIGl0LlxuICAgICAgICAgICAgbGV0IHZpZXdGb3JNb2RlbCA9IHRoaXMuZmluZFZpZXdCeUlkKG1vZGVsLmlkKTtcbiAgICAgICAgICAgIGlmKCF2aWV3Rm9yTW9kZWwpe1xuICAgICAgICAgICAgICAgIHRoaXMubmV3Vmlldyhtb2RlbC50eXBlLCBtb2RlbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5IGlmIHRoZSBvd25lciBwYXJ0IGlzIGVpdGhlciBhIHdvcmxkIG9yIGEgc3RhY2tcbiAgICAgICAgLy8gYW5kIGhhcyBvbmx5IG9uZSBzdGFjayBvciBjYXJkIGNoaWxkLCByZXNwZWN0aXZlbHksIHNldFxuICAgICAgICAvLyB0aGF0IGNoaWxkIHRvIGJlIHRoZSBjdXJyZW50XG4gICAgICAgIGlmKG93bmVyUGFydC50eXBlID09IFwid29ybGRcIiB8fCBvd25lclBhcnQudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJZCA9IG93bmVyUGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKG93bmVyUGFydCwgXCJjdXJyZW50XCIpO1xuICAgICAgICAgICAgaWYoIWN1cnJlbnRJZCl7XG4gICAgICAgICAgICAgICAgb3duZXJQYXJ0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQob3duZXJQYXJ0LCBcImN1cnJlbnRcIiwgbW9kZWwuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICBuZXdQcm9wZXJ0eShzZW5kZXJzLCBwcm9wTmFtZSwgb2JqZWN0SWQpe1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBsZXQgb3JpZ2luYWxTZW5kZXIgPSBzZW5kZXJzWzBdLmlkO1xuXG4gICAgICAgIGlmKG9iamVjdElkKXtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgYW4gb2JqZWN0SWQsIHdlIGFyZVxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgcHJvcGVydHkgb2YgYSBzcGVjaWZpYyBwYXJ0IGJ5XG4gICAgICAgICAgICAvLyBpZFxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb2JqZWN0SWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvbiB0aGUgcGFydFxuICAgICAgICAgICAgLy8gdGhhdCBvcmlnaW5hbGx5IHNlbnQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29yaWdpbmFsU2VuZGVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBuZXdQcm9wZXJ0eSB0YXJnZXQhYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUpKXtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgYSBTVCBlcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJ0ICR7dGFyZ2V0LmlkfSBhbHJlYWR5IGhhcyBwcm9wZXJ0eSBcIiR7cHJvcE5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBvbmx5IGFkZCBiYXNpYyBwcm9wZXJ0eSBhbmQgdGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbFxuICAgICAgICBsZXQgY3VzdG9tUHJvcCA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChcImN1c3RvbS1wcm9wZXJ0aWVzXCIpO1xuICAgICAgICBsZXQgbmV3UHJvcCA9IG5ldyBCYXNpY1Byb3BlcnR5KHByb3BOYW1lLCBudWxsKTtcbiAgICAgICAgY3VzdG9tUHJvcC5hZGQobmV3UHJvcCk7XG4gICAgfSxcblxuICAgIGRlbGV0ZVByb3BlcnR5KHNlbmRlcnMsIHByb3BOYW1lLCBvYmplY3RJZCl7XG4gICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgIGxldCBvcmlnaW5hbFNlbmRlciA9IHNlbmRlcnNbMF0uaWQ7XG5cbiAgICAgICAgaWYob2JqZWN0SWQpe1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhbiBvYmplY3RJZCwgd2UgYXJlXG4gICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvZiBhIHNwZWNpZmljIHBhcnQgYnlcbiAgICAgICAgICAgIC8vIGlkXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvYmplY3RJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHNldHRpbmcgdGhlIHByb3BlcnR5IG9uIHRoZSBwYXJ0XG4gICAgICAgICAgICAvLyB0aGF0IG9yaWdpbmFsbHkgc2VudCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb3JpZ2luYWxTZW5kZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGRlbGV0ZVByb3BlcnR5IHRhcmdldCFgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgd2lsbCBvbmx5IGRlbGV0ZSBjdXN0b20gcHJvcGVydGllcyB3aGljaCBpcyB3aGF0IHdlIHdhbnRcbiAgICAgICAgbGV0IHByb3AgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUpO1xuXG4gICAgICAgIGxldCBjdXN0b21Qcm9wID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKFwiY3VzdG9tLXByb3BlcnRpZXNcIik7XG4gICAgICAgIGN1c3RvbVByb3AuZGVsZXRlKHByb3ApO1xuICAgIH0sXG5cbiAgICBzZXRQcm9wZXJ0eShzZW5kZXJzLCBwcm9wTmFtZSwgdmFsdWUsIG9iamVjdElkKXtcbiAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gc2VuZGVyc1swXS5pZDtcblxuICAgICAgICBpZihvYmplY3RJZCl7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIGFuIG9iamVjdElkLCB3ZSBhcmVcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHByb3BlcnR5IG9mIGEgc3BlY2lmaWMgcGFydCBieVxuICAgICAgICAgICAgLy8gaWRcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29iamVjdElkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBhcmUgc2V0dGluZyB0aGUgcHJvcGVydHkgb24gdGhlIHBhcnRcbiAgICAgICAgICAgIC8vIHRoYXQgb3JpZ2luYWxseSBzZW50IHRoZSBtZXNzYWdlXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvcmlnaW5hbFNlbmRlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc2V0UHJvcGVydHkgdGFyZ2V0IWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBwYXJ0IGlzIGEgU3RhY2ssIHdlIGFsc29cbiAgICAgICAgLy8gc2V0IHRoaXMgcHJvcGVydHkgb24gYWxsIG9mIGl0cyBDYXJkXG4gICAgICAgIC8vIHN1YnBhcnRzXG4gICAgICAgIGlmKHRhcmdldC50eXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgdGFyZ2V0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdjYXJkJztcbiAgICAgICAgICAgIH0pLmZvckVhY2goY2FyZCA9PiB7XG4gICAgICAgICAgICAgICAgY2FyZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICBjYXJkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBJRCBmcm9tXG4gICAgLy8gdGhlIFN5c3RlbSdzIHJlZ2lzdHJ5LCBhcyB3ZWxsIGFzIGZyb20gdGhlIHN1YnBhcnRzXG4gICAgLy8gYXJyYXkgb2YgYW55IG93bmVyc1xuICAgIGRlbGV0ZU1vZGVsOiBmdW5jdGlvbihtb2RlbElkKXtcbiAgICAgICAgbGV0IGZvdW5kTW9kZWwgPSB0aGlzLnBhcnRzQnlJZFttb2RlbElkXTtcbiAgICAgICAgaWYoIWZvdW5kTW9kZWwpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gcmVtb3ZpbmcgYSBjYXJkIG9yIGEgc3RhY2sgYmUgc3VyZSBpdCBpcyBub3QgdGhlIG9ubHkgb25lXG4gICAgICAgIC8vIGFuZCBpZiBpdCBpcyB0aGUgY3VycmVudCBjYXJkIG9yIHN0YWNrIHdlIHNob3VsZCBnbyB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgLy8gYmVmb3JlIHJlbW92aW5nIGl0XG4gICAgICAgIGlmKGZvdW5kTW9kZWwudHlwZSA9PSBcImNhcmRcIiB8fCBmb3VuZE1vZGVsLnR5cGUgPT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBzYW1lVHlwZVN1YnBhcnRzID0gZm91bmRNb2RlbC5fb3duZXIuc3VicGFydHMuZmlsdGVyKChwKSA9PiB7cmV0dXJuIHAudHlwZSA9PSBmb3VuZE1vZGVsLnR5cGU7fSk7XG4gICAgICAgICAgICBpZihzYW1lVHlwZVN1YnBhcnRzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGJlIGEgU1QgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgdGhlIG9ubHkgJHtmb3VuZE1vZGVsLnR5cGV9YCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYobW9kZWxJZCA9PSB0aGlzLmdldEN1cnJlbnRTdGFja01vZGVsKCkuaWQgIHx8IG1vZGVsSWQgPT0gdGhpcy5nZXRDdXJyZW50Q2FyZE1vZGVsKCkuaWQpe1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgYSBTVCBlcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSB0aGUgY3VycmVudCAke2ZvdW5kTW9kZWwudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0byBzdG9wIGFsbCBzdGVwcGluZ1xuICAgICAgICAvLyBvbiB0aGUgUGFydCwgb3RoZXJ3aXNlIHN0ZXBwaW5nXG4gICAgICAgIC8vIGludGVydmFscyB3aWxsIGVycm9yIGluZmluaXRlbHlcbiAgICAgICAgZm91bmRNb2RlbC5zdG9wU3RlcHBpbmcoKTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGVkaXRvciBpcyBjbG9zZWRcbiAgICAgICAgZm91bmRNb2RlbC5jbG9zZUVkaXRvckNtZEhhbmRsZXIoKTtcblxuICAgICAgICBsZXQgb3duZXJNb2RlbCA9IGZvdW5kTW9kZWwuX293bmVyO1xuICAgICAgICBpZihvd25lck1vZGVsKXtcbiAgICAgICAgICAgIG93bmVyTW9kZWwucmVtb3ZlUGFydChmb3VuZE1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcnRzQnlJZFttb2RlbElkXTtcbiAgICAgICAgdGhpcy5yZW1vdmVWaWV3cyhtb2RlbElkKTtcblxuICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgICAgIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYWxsIHZpZXdzIHdpdGggdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAvLyBtb2RlbCBpZCBmcm9tIHRoZSBET01cbiAgICByZW1vdmVWaWV3czogZnVuY3Rpb24obW9kZWxJZCl7XG4gICAgICAgIGxldCB2aWV3cyA9IEFycmF5LmZyb20odGhpcy5maW5kVmlld3NCeUlkKG1vZGVsSWQpKTtcbiAgICAgICAgdmlld3MuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFbCA9IHZpZXcucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZpZXcucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh2aWV3KTtcbiAgICAgICAgICAgIC8vIERpc3BhdGNoIGEgQ3VzdG9tRXZlbnQgb24gdGhlIHBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgIC8vIGluZGljYXRpbmcgdGhhdCB0aGlzIHBhcnQgaGFzIGJlZW4gcmVtb3ZlZCwgYW5kXG4gICAgICAgICAgICAvLyBhbnkgdmlldyB1dGlsaXRpZXMgdGhhdCBjYXJlIGNhbiBiZSBub3RpZmllZC5cbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc3Qtdmlldy1yZW1vdmVkJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0VHlwZTogdmlldy5tb2RlbC50eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IG1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIG93bmVySWQ6IG51bGxcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRFbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsZW5zZXMgPSB0aGlzLmZpbmRMZW5zVmlld3NCeUlkKG1vZGVsSWQpO1xuICAgICAgICBsZW5zZXMuZm9yRWFjaChsZW5zVmlldyA9PiB7XG4gICAgICAgICAgICBsZW5zVmlldy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGxlbnNWaWV3KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG5ld1ZpZXc6IGZ1bmN0aW9uKHBhcnROYW1lLCBtb2RlbElkLCBwYXJlbnRJZCl7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMucGFydHNCeUlkW21vZGVsSWRdO1xuICAgICAgICBpZighbW9kZWwgfHwgbW9kZWwgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3lzdGVtIGRvZXMgbm90IGtub3cgcGFydCAke3BhcnROYW1lfVske21vZGVsSWR9XWApO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFwYXJ0TmFtZSl7XG4gICAgICAgICAgICBwYXJ0TmFtZSA9IG1vZGVsLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgaWQuIFRoaXMgd2lsbFxuICAgICAgICAvLyBoZWxwIHVzIGZpbmQgdGhlIHBhcmVudCB2aWV3IGVsZW1lbnQgZm9yXG4gICAgICAgIC8vIGFwcGVuZGluZyB0aGUgbmV3IGVsZW1lbnQuXG4gICAgICAgIGlmICghcGFyZW50SWQpe1xuICAgICAgICAgICAgcGFyZW50SWQgPSBtb2RlbC5fb3duZXIuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSB0aGlzLmZpbmRWaWV3QnlJZChwYXJlbnRJZCk7XG4gICAgICAgIGlmKCFwYXJlbnRFbGVtZW50KXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcGFyZW50IGVsZW1lbnQgZm9yICR7cGFydE5hbWV9WyR7bW9kZWxJZH1dIChtb2RlbCBvd25lciBpZDogJHttb2RlbC5fb3duZXIuaWR9KWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgdmlldyBpbnN0YW5jZSxcbiAgICAgICAgLy8gYXBwZW5kIHRvIHBhcmVudCwgYW5kIHNldCB0aGUgbW9kZWxcbiAgICAgICAgbGV0IG5ld1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgdGhpcy50YWdOYW1lRm9yVmlld05hbWVkKHBhcnROYW1lKVxuICAgICAgICApO1xuICAgICAgICBuZXdWaWV3LnNldE1vZGVsKG1vZGVsKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcInZpZXdDaGFuZ2VkXCIsXG4gICAgICAgICAgICBjaGFuZ2VOYW1lOiBcInN1YnBhcnQtbmV3XCIsXG4gICAgICAgICAgICBhcmdzOiBbbmV3Vmlld11cbiAgICAgICAgfSwgbW9kZWwuX293bmVyLCBwYXJlbnRFbGVtZW50KTtcblxuICAgICAgICAvLyBEaXNwYXRjaCBhIEN1c3RvbUV2ZW50IG9uIHRoZSBwYXJlbnRFbGVtZW50XG4gICAgICAgIC8vIGluZGljYXRpbmcgdGhhdCB0aGlzIHBhcnQgaGFzIGJlZW4gY3JlYXRlZCwgYW5kXG4gICAgICAgIC8vIGFueSB2aWV3IHV0aWxpdGllcyB0aGF0IGNhcmUgY2FuIGJlIG5vdGlmaWVkLlxuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3N0LXZpZXctYWRkZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBwYXJ0VHlwZTogbW9kZWwudHlwZSxcbiAgICAgICAgICAgICAgICBwYXJ0SWQ6IG1vZGVsLmlkLFxuICAgICAgICAgICAgICAgIG93bmVySWQ6IG1vZGVsLl9vd25lci5pZCB8fCBudWxsXG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgICAgICAvLyBTZWUgaWYgdGhlcmUgYXJlIGxlbnMgdmlld3MgYW5kIHVwZGF0ZVxuICAgICAgICAvLyB0aG9zZSBhcyB3ZWxsXG4gICAgICAgIGxldCBsZW5zVmlld3MgPSB0aGlzLmZpbmRMZW5zVmlld3NCeUlkKHBhcmVudElkKTtcbiAgICAgICAgbGVuc1ZpZXdzLmZvckVhY2gobGVuc1ZpZXcgPT4ge1xuICAgICAgICAgICAgbGV0IG5ld0xlbnNWaWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWVGb3JWaWV3TmFtZWQocGFydE5hbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIG1vZGVsSWQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgIGxlbnNWaWV3LmFwcGVuZENoaWxkKG5ld0xlbnNWaWV3KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETyBkbyB3ZSB3YW50IHRvIGFsbG93IHRoZSBwb3NzaWJpbGl5IG9mIGEgdmlldyBvbiBhblxuICAgICAgICAvLyBlbGVtZW50IGJ1dCBubyBzdWJwYXJ0IG9mIHRoYXQgdmlldyBvbiB0aGUgZWxlbWVudD9cblxuICAgICAgICAvLyBGb3IgYWxsIHN1YnBhcnRzIG9mIHRoaXMgbW9kZWwsIGNhbGxcbiAgICAgICAgLy8gdGhlIG5ld1ZpZXcgbWV0aG9kIHJlY3Vyc2l2ZWx5XG4gICAgICAgIG1vZGVsLnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLm5ld1ZpZXcoc3VicGFydC50eXBlLCBzdWJwYXJ0LmlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1ZpZXc7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyUGFydDogZnVuY3Rpb24obmFtZSwgY2xzKXtcbiAgICAgICAgdGhpcy5hdmFpbGFibGVQYXJ0c1tuYW1lXSA9IGNscztcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJWaWV3OiBmdW5jdGlvbihuYW1lLCBjbHMpe1xuICAgICAgICB0aGlzLmF2YWlsYWJsZVZpZXdzW25hbWVdID0gY2xzO1xuICAgIH0sXG5cbiAgICB0YWdOYW1lRm9yVmlld05hbWVkOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgcmV0dXJuIGBzdC0ke25hbWV9YDtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgdmlldyBlbGVtZW50XG4gICAgLy8gd2l0aCB0aGUgZ2l2ZW4gaWRcbiAgICBmaW5kVmlld0J5SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHtpZH1cIl1gKTtcbiAgICB9LFxuXG4gICAgZmluZExlbnNWaWV3c0J5SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2xlbnMtcGFydC1pZD1cIiR7aWR9XCJdYCkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCBtYXRjaGluZyB2aWV3IGVsZW1lbnRzIHdpdGhcbiAgICAvLyB0aGUgZ2l2ZW4gcGFydCBpZFxuICAgIGZpbmRWaWV3c0J5SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtwYXJ0LWlkPVwiJHtpZH1cIl1gKTtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRoZSBtb2RlbCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgZ2V0Q3VycmVudFN0YWNrTW9kZWw6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMuZ2V0V29ybGRTdGFja01vZGVsKCk7XG4gICAgICAgIHJldHVybiB3b3JsZC5jdXJyZW50U3RhY2s7XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgbW9kZWwgY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBjYXJkXG4gICAgZ2V0Q3VycmVudENhcmRNb2RlbDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZDtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRoZSBtb2RlbCBjb3JyZXNwb25kaW5nIHRvIHRoZSB3b3JsZCBzdGFja1xuICAgIGdldFdvcmxkU3RhY2tNb2RlbDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdGhlIG1vZGVsIGNvcnJlc3BvbmRpbmcgc2NyaXB0IGVkaXRvciBzdC1maWVsZFxuICAgIC8vIE5vdGU6IHdlIHVzZSB0aGUgd2luZG93Lm1vZGVsLnRhcmdldCB0byBsb2NhdGUgdGhlIGNvcnJlc3BvbmRpbmcgd2luZG93XG4gICAgLy8gYnV0IHJldHVybiBpdHMgc3QtZmllbGQgc3VicGFydFxuICAgIGZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkOiBmdW5jdGlvbihpZCl7XG4gICAgICAgIGxldCBzY3JpcHRFZGl0b3JGaWVsZDtcbiAgICAgICAgbGV0IHdpbmRvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3Qtd2luZG93XCIpO1xuICAgICAgICB3aW5kb3dzLmZvckVhY2goKHcpID0+IHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB3Lm1vZGVsLnRhcmdldDtcbiAgICAgICAgICAgIGlmKHRhcmdldCAmJiB0YXJnZXQuaWQgPT09IGlkKXtcbiAgICAgICAgICAgICAgICBzY3JpcHRFZGl0b3JGaWVsZCA9IHcucXVlcnlTZWxlY3RvcihcInN0LWZpZWxkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdEVkaXRvckZpZWxkO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICBpZighd29ybGQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB3b3JsZCBmb3VuZCFgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VyaWFsaXplciA9IG5ldyBTVFNlcmlhbGl6ZXIodGhpcyk7XG4gICAgICAgIGxldCBzZXJpYWxTdHJpbmcgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLnBhcnRzQnlJZFsnd29ybGQnXSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGEgc2NyaXB0IHRhZyBpbiB0aGVcbiAgICAgICAgLy8gYm9keSBmb3IgdGhlIHNlcmlhbGl6YXRpb24sIGNyZWF0ZSBpdFxuICAgICAgICBsZXQgc2VyaWFsaXphdGlvblNjcmlwdEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgaWYoIXNlcmlhbGl6YXRpb25TY3JpcHRFbCl7XG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uU2NyaXB0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25TY3JpcHRFbC5pZCA9ICdzZXJpYWxpemF0aW9uJztcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25TY3JpcHRFbC50eXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoc2VyaWFsaXphdGlvblNjcmlwdEVsKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemF0aW9uU2NyaXB0RWwudGV4dENvbnRlbnQgPSBzZXJpYWxTdHJpbmc7XG4gICAgfSxcblxuICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgc2VyaWFsaXphdGlvbkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgaWYoIXNlcmlhbGl6YXRpb25FbCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlcmlhbGl6YXRpb24gZm91bmQgZm9yIHRoaXMgcGFnZWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rlc2VyaWFsaXplciA9IG5ldyBTVERlc2VyaWFsaXplcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uRWwudGV4dENvbnRlbnQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYSAqY29tcGxldGUqIEhUTUxcbiAgICAvLyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBhcHBsaWNhdGlvblxuICAgIC8vIHRoYXQgY2FuIGxhdGVyIGJlIHNhdmVkIHRvIGEgZmlsZVxuICAgIGdldEZ1bGxIVE1MU3RyaW5nOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgY2xvbmVkRG9jdW1lbnQgPSBkb2N1bWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGxldCB3b3JsZCA9IGNsb25lZERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIGxldCBuYXYgPSBjbG9uZWREb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1uYXZpZ2F0b3InKTtcbiAgICAgICAgaWYod29ybGQpe1xuICAgICAgICAgICAgd29ybGQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYobmF2KXtcbiAgICAgICAgICAgIG5hdi5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZWREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgIH0sXG5cblxuICAgIC8qKiBOYXZpZ2F0aW9uIG9mIEN1cnJlbnQgV29ybGQgKiovXG4gICAgZ29Ub05leHRTdGFjazogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgICAgIHJldHVybiB3b3JsZC5nb1RvTmV4dFN0YWNrKCk7XG4gICAgfSxcblxuICAgIGdvVG9QcmV2U3RhY2s6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICByZXR1cm4gd29ybGQuZ29Ub1ByZXZTdGFjaygpO1xuICAgIH0sXG5cbiAgICBnb1RvU3RhY2tCeUlkOiBmdW5jdGlvbihzdGFja0lkKXtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgICAgIHJldHVybiB3b3JsZC5nb1RvU3RhY2tCeUlkKHN0YWNrSWQpO1xuICAgIH0sXG5cbiAgICAvKiogTmF2aWdhdGlvbiBvZiBDdXJyZW50IFN0YWNrICoqL1xuICAgIGdvVG9OZXh0Q2FyZDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTsgXG4gICAgICAgIHJldHVybiBjdXJyZW50U3RhY2suZ29Ub05leHRDYXJkKCk7XG4gICAgfSxcblxuICAgIGdvVG9QcmV2Q2FyZDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGFjay5nb1RvUHJldkNhcmQoKTtcbiAgICB9LFxuXG4gICAgZ29Ub0NhcmRCeUlkOiBmdW5jdGlvbihjYXJkSWQpe1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5nZXRDdXJyZW50U3RhY2tNb2RlbCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFN0YWNrLmdvVG9DYXJkQnlJZChjYXJkSWQpO1xuICAgIH0sXG5cbiAgICBvcGVuRWRpdG9yRm9yUGFydDogZnVuY3Rpb24ocGFydElkKXtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyKFxuICAgICAgICAgICAgdGhpcy5wYXJ0c0J5SWRbcGFydElkXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVkaXRvci5vcGVuKCk7XG4gICAgfSxcblxuICAgIGNsb3NlRWRpdG9yRm9yUGFydDogZnVuY3Rpb24ocGFydElkKXtcbiAgICAgICAgdGhpcy5lZGl0b3IuY2xvc2UoKTtcbiAgICB9XG59O1xuXG4vKiogQWRkIERlZmF1bHQgU3lzdGVtIENvbW1hbmQgSGFuZGxlcnMgKiovXG4vL1N5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydkZWxldGVNb2RlbCddID0gU3lzdGVtLmRlbGV0ZU1vZGVsO1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2RlbGV0ZU1vZGVsJ10gPSBmdW5jdGlvbihzZW5kZXJzLCAuLi5yZXN0KXtcbiAgICBTeXN0ZW0uZGVsZXRlTW9kZWwoLi4ucmVzdCk7XG59O1xuLy9TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3TW9kZWwnXSA9IFN5c3RlbS5uZXdNb2RlbDtcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyduZXdNb2RlbCddID0gZnVuY3Rpb24oc2VuZGVycywgLi4ucmVzdCl7XG4gICAgU3lzdGVtLm5ld01vZGVsKC4uLnJlc3QpO1xuICAgIHRoaXMuc2VyaWFsaXplKCk7XG59O1xuLy9TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3VmlldyddID0gU3lzdGVtLm5ld1ZpZXc7XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3VmlldyddID0gZnVuY3Rpb24oc2VuZGVycywgLi4ucmVzdCl7XG4gICAgU3lzdGVtLm5ld1ZpZXcoLi4ucmVzdCk7XG59O1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ25ld1Byb3BlcnR5J10gPSBTeXN0ZW0ubmV3UHJvcGVydHk7XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snc2V0UHJvcGVydHknXSA9IFN5c3RlbS5zZXRQcm9wZXJ0eTtcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydkZWxldGVQcm9wZXJ0eSddID0gU3lzdGVtLmRlbGV0ZVByb3BlcnR5O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snYXNrJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBxdWVzdGlvbil7XG4gICAgLy8gVXNlIHRoZSBuYXRpdmUgSlMgcHJvbXB0IGZ1bmN0aW9uIHRvIGFzayB0aGUgcXVlc3Rpb25cbiAgICAvLyBhbmQgcmV0dXJuIGl0cyB2YWx1ZS5cbiAgICAvLyBCeSByZXR1cm5pbmcgaGVyZSwgd2UgZXhwZWN0IHRoZSBpbXBsaWNpdCB2YXJpYWJsZVxuICAgIC8vIFwiaXRcIiB0byBiZSBzZXQgaW5zaWRlIGFueSBjYWxsaW5nIHNjcmlwdFxuICAgIHJldHVybiBwcm9tcHQocXVlc3Rpb24pO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ3B1dEludG8nXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHZhbHVlLCB2YXJpYWJsZU5hbWUsIGdsb2JhbCl7XG4gICAgaWYoZ2xvYmFsKXtcbiAgICAgICAgU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnNldEdsb2JhbCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIHdlIHB1c2ggYWxsIGhhbmRsZXJzIG9udG8gdGhlIGV4ZWN1dGlvbiBzdGFjayxcbiAgICAvLyB0aGUgcHV0SW50byBoYW5kbGVyIGlzIGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjay5cbiAgICAvLyBJbiBvcmRlciB0byBtb2RpZnkgdGhlIGNhbGxlcidzIHZhcmlhYmxlcywgd2UgbmVlZCB0b1xuICAgIC8vIGZpbmQgdGhlIGNvbnRleHQgdGhhdCBpcyBvbmUgcHJldmlvdXMgb24gdGhlIHN0YWNrXG4gICAgaWYoU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnByZXZpb3VzKXtcbiAgICAgICAgU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnByZXZpb3VzLnNldExvY2FsKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhlY3V0aW9uU3RhY2sgRXJyb3I6ICNwdXRJbnRvIG9uIHRvcCBvZiBlbXB0eSBzdGFjayFgKTtcbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snYW5zd2VyJ10gPSBmdW5jdGlvbihzZW5kZXJzLCB2YWx1ZSl7XG4gICAgYWxlcnQodmFsdWUudG9TdHJpbmcoKSk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZ28gdG8gZGlyZWN0aW9uJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBkaXJlY3RpdmUsIG9iamVjdE5hbWUpe1xuICAgIHN3aXRjaChvYmplY3ROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2NhcmQnOlxuICAgICAgICAgICAgc3dpdGNoKGRpcmVjdGl2ZSl7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub05leHRDYXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9QcmV2Q2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YWNrJzpcbiAgICAgICAgICAgIHN3aXRjaChkaXJlY3RpdmUpe1xuICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9OZXh0U3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub1ByZXZTdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhbGVydChgXCJnbyB0b1wiIG5vdCBpbXBsZW1lbnRlZCBmb3IgJHtvYmplY3ROYW1lfWApO1xuXG4gICAgfVxufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2dvIHRvJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBpZCl7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5wYXJ0c0J5SWRbaWRdO1xuICAgIGlmKCFtb2RlbCl7XG4gICAgICAgIGFsZXJ0KGBcImdvIHRvXCIgdGFyZ2V0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBzd2l0Y2gobW9kZWwudHlwZSkge1xuICAgIGNhc2UgJ2NhcmQnOlxuICAgICAgICB0aGlzLmdvVG9DYXJkQnlJZChpZCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3RhY2snOlxuICAgICAgICB0aGlzLmdvVG9TdGFja0J5SWQoaWQpO1xuICAgICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAgIGFsZXJ0KGBcImdvIHRvXCIgbm90IGltcGxlbWVudGVkIGZvciAke21vZGVsLnR5cGV9YCk7XG5cbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZ28gdG8gd2Vic2l0ZSddID0gZnVuY3Rpb24oc2VuZGVycywgdXJsKXtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn07XG5cbi8vSW1wb3J0IGEgd29ybGQsIGkuZS4gaXRzIHN0YWNrcyBmcm9tIGFub3RoZXIgc291cmNlXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snaW1wb3J0V29ybGQnXSA9IGZ1bmN0aW9uKHNlbmRlciwgc291cmNlVXJsKXtcbiAgICBpZighc291cmNlVXJsKXtcbiAgICAgICAgc291cmNlVXJsID0gd2luZG93LnByb21wdChcIkNob29zZSBXb3JsZCBsb2NhdGlvblwiKTtcbiAgICB9XG4gICAgZmV0Y2goc291cmNlVXJsKVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICBpZighY29udGVudFR5cGUuc3RhcnRzV2l0aCgndGV4dC9odG1sJykpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZW50IHR5cGU6ICR7Y29udGVudFR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpLnRoZW4oYmxvYiA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZERvY3VtZW50ID0gRE9NcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhyZWFkZXIucmVzdWx0LCBcInRleHQvaHRtbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gLmdldEVsZW1lbnRCeUlkKCkgZm9yIGEgbm9kZSBIVE1MIHBhcnNlZCBkb2N1bWVudCFcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb25FbCA9IHBhcnNlZERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZXJpYWxpemF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFzZXJpYWxpemF0aW9uRWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE5vIHNlcmlhbGl6YXRpb24gZm91bmQgZm9yICR7c291cmNlVXJsfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoYFdvcmxkIFwiJHtzb3VyY2VVcmx9XCIgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemVyID0gbmV3IFNURGVzZXJpYWxpemVyKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZXIudGFyZ2V0SWQgPSAnd29ybGQnOyAvLyBXZSB3aWxsIGluc2VydCB0aGUgc3RhY2tzIGludG8gdGhlIHdvcmxkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZXIuaW1wb3J0RnJvbVNlcmlhbGl6YXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uRWwudGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBvbmx5IFN0YWNrcyB0aGF0IGFyZSBkaXJlY3Qgc3VicGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgd29ybGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzU3RhY2sgPSBwYXJ0LnR5cGUgPT0gJ3N0YWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNXb3JsZFN1YnBhcnQgPSBwYXJ0Ll9vd25lciAmJiBwYXJ0Ll9vd25lci50eXBlID09ICd3b3JsZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RhY2sgJiYgaXNXb3JsZFN1YnBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzZXQgdGhlIF9zcmMuXG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBpbmZpbml0ZWx5XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBsb2FkIG9wZXJhdGlvblxuICAgICAgICAgICAgdGhpcy5fc3JjID0gc291cmNlVXJsO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vIFN0b3AgYW5kIHJlc3RhcnQgaGFuZCBpbnRlcmZhY2UgaWYgaXQncyBydW5uaW5nLlxuICAgICAgICAgICAgaWYgKGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGFsZXJ0KFwiQ291bGQgbm90IGxvYWQgd29ybGRcIik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH0pO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ29wZW5TY3JpcHRFZGl0b3InXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHRhcmdldElkKXtcbiAgICBsZXQgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgIGxldCB0YXJnZXROYW1lID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcIm5hbWVcIik7XG4gICAgaWYodGFyZ2V0TmFtZSl7XG4gICAgICAgIHRhcmdldE5hbWUgPSBgXCIke3RhcmdldE5hbWV9XCJgO1xuICAgIH1cbiAgICBsZXQgbmFtZSA9IGBTY3JpcHQgRm9yICR7dGFyZ2V0Lm5hbWV9ICR7dGFyZ2V0TmFtZX1gO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGRpbndvIG9wZW5lZCB3aXRoIHRoaXMgbmFtZSwgdGhlblxuICAgIC8vIHdlIHJldHVybiB3aXRob3V0IGNyZWF0aW5nIGFueXRoaW5nIG5ldy5cbiAgICBsZXQgZm91bmQgPSBPYmplY3QudmFsdWVzKFN5c3RlbS5wYXJ0c0J5SWQpLmZpbHRlcihwYXJ0ID0+IHtcbiAgICAgICAgbGV0IHBhcnROYW1lO1xuICAgICAgICBpZihwYXJ0LnR5cGUgPT0gJ3dpbmRvdycpe1xuICAgICAgICAgICAgcGFydE5hbWUgPSBwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAndGl0bGUnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocGFydC50eXBlID09ICd3aW5kb3cnICYmIG5hbWUgPT0gcGFydE5hbWUpO1xuICAgIH0pO1xuICAgIGlmKGZvdW5kLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudENhcmQgPSB0aGlzLmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICBsZXQgd2luZG93ID0gdGhpcy5uZXdNb2RlbCgnd2luZG93JywgY3VycmVudENhcmQuaWQpO1xuICAgIGxldCBhcmVhID0gdGhpcy5uZXdNb2RlbCgnYXJlYScsIHdpbmRvdy5pZCk7XG4gICAgbGV0IHNjcmlwdEZpZWxkID0gdGhpcy5uZXdNb2RlbCgnZmllbGQnLCBhcmVhLmlkKTtcbiAgICBsZXQgc2F2ZUJ1dHRvbiA9IHRoaXMubmV3TW9kZWwoJ2J1dHRvbicsIGFyZWEuaWQpO1xuXG5cbiAgICAvLyBzZXR1cCB0aGUgd2luZG93IGFuZCBzdGFjayBwcm9wZXJ0aWVzXG4gICAgd2luZG93LnNldFRhcmdldCh0YXJnZXQpO1xuICAgIHdpbmRvdy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHdpbmRvdywgXCJ0aXRsZVwiLCBuYW1lKTtcbiAgICB3aW5kb3cucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh3aW5kb3csIFwiaGVpZ2h0XCIsIDIwMCk7XG4gICAgd2luZG93LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQod2luZG93LCBcIndpZHRoXCIsIDUwMCk7XG4gICAgd2luZG93LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQod2luZG93LCAndG9wJywgMTAwKTtcbiAgICB3aW5kb3cucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh3aW5kb3csICdsZWZ0JywgMTAwKTtcblxuICAgIGFyZWEucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChhcmVhLCBcImxheW91dFwiLCBcImxpc3RcIik7XG4gICAgYXJlYS5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGFyZWEsIFwibGlzdC1kaXJlY3Rpb25cIiwgXCJjb2x1bW5cIik7XG4gICAgYXJlYS5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGFyZWEsIFwid2lkdGhcIiwgXCJmaWxsXCIpO1xuICAgIGFyZWEucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChhcmVhLCBcImhlaWdodFwiLCBcImZpbGxcIik7XG5cbiAgICAvLyBzY3JpcHQgZmllbGRcbiAgICBsZXQgdGFyZ2V0U2NyaXB0ID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcInNjcmlwdFwiKTsgXG4gICAgc2NyaXB0RmllbGQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzY3JpcHRGaWVsZCwgXCJ0ZXh0XCIsIHRhcmdldFNjcmlwdCk7XG4gICAgc2NyaXB0RmllbGQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzY3JpcHRGaWVsZCwgXCJoZWlnaHRcIiwgXCJmaWxsXCIpO1xuICAgIHNjcmlwdEZpZWxkLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2NyaXB0RmllbGQsIFwid2lkdGhcIiwgXCJmaWxsXCIpO1xuXG4gICAgLy8gU2V0dXAgc3ludGF4IGhpZ2hsaWdodFxuICAgIHNjcmlwdEZpZWxkLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgIGNvbW1hbmROYW1lOiBcImhpZ2hsaWdodFN5bnRheFwiLFxuICAgICAgICBhcmdzOiBbXVxuICAgIH0sIHNjcmlwdEZpZWxkKTtcblxuXG4gICAgLy8gc2V0dXAgdXAgdGhlIHNhdmUgYnV0dG9uIHByb3BlcnRpZXNcbiAgICBzYXZlQnV0dG9uLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2F2ZUJ1dHRvbiwgXCJuYW1lXCIsIFwiU2F2ZSBTY3JpcHRcIik7XG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwid2lkdGhcIiwgXCJmaWxsXCIpO1xuICAgIHNhdmVCdXR0b24ucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzYXZlQnV0dG9uLCBcInRleHQtc2l6ZVwiLCAyMCk7XG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwidGFyZ2V0XCIsIGBwYXJ0IGlkICR7dGFyZ2V0LmlkfWApO1xuXG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwidGFyZ2V0XCIsIGBwYXJ0IGlkICR7dGFyZ2V0LmlkfWApO1xuICAgIGxldCBzYXZlU2NyaXB0ID0gYG9uIGNsaWNrXFxuXFx0dGVsbCB0YXJnZXQgdG8gc2V0IFwic2NyaXB0XCIgdG8gdGhlIFwidGV4dFwiIG9mIGZpcnN0IGZpZWxkXFxuZW5kIGNsaWNrYDsgXG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwic2NyaXB0XCIsIHNhdmVTY3JpcHQpO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ1NpbXBsZVRhbGsnXSA9IGZ1bmN0aW9uKHNlbmRlcnMpe1xuICAgIHJldHVybiBTeXN0ZW0uZ3JhbW1hci5zb3VyY2Uuc291cmNlU3RyaW5nO1xufVxuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snb3BlbkRlYnVnZ2VyJ10gPSBmdW5jdGlvbihzZW5kZXJzLCBwYXJ0SWQpe1xuICAgIGxldCB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtwYXJ0SWRdO1xuICAgIC8vIENyZWF0ZSB0aGUgRmllbGQgbW9kZWwgYW5kIGF0dGFjaCB0byBjdXJyZW50IGNhcmRcbiAgICBsZXQgY3VycmVudENhcmQgPSB0aGlzLmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICBsZXQgZmllbGRNb2RlbCA9IHRoaXMubmV3TW9kZWwoJ2ZpZWxkJywgY3VycmVudENhcmQuaWQpO1xuICAgIGxldCB0ZXh0ID0gYEF2YWlsYWJsZSBDb21tYW5kcyBmb3IgJHt0YXJnZXQubmFtZX0gKGlkICR7dGFyZ2V0LmlkfSlcXG5cXG5gO1xuICAgIE9iamVjdC5rZXlzKHRhcmdldC5jb21tYW5kSGFuZGxlclJlZ2lzdHJ5KS5mb3JFYWNoKChuYW1lKSA9PntcbiAgICAgICAgbGV0IGluZm8gPSB0YXJnZXQuY29tbWFuZEhhbmRsZXJSZWdpc3RyeVtuYW1lXTtcbiAgICAgICAgdGV4dCArPSBgJHtuYW1lfTogJHtKU09OLnN0cmluZ2lmeShpbmZvKX1cXG5gO1xuICAgIH0pO1xuICAgIGZpZWxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgZmllbGRNb2RlbCxcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICB0ZXh0XG4gICAgKTtcbiAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIGZpZWxkTW9kZWwsXG4gICAgICAgICdlZGl0YWJsZScsXG4gICAgICAgIGZhbHNlXG4gICAgKTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydzYXZlSFRNTCddID0gZnVuY3Rpb24oc2VuZGVycyl7XG4gICAgLy8gU3RvcCBoYW5kIHJlY29nbml0aW9uIGlmIGl0J3MgcnVubmluZy5cbiAgICBsZXQgaGFuZFJlY29nbml0aW9uT3JpZ2luYWxseVJ1bm5pbmcgPSBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nO1xuICAgIGlmIChoYW5kUmVjb2duaXRpb25PcmlnaW5hbGx5UnVubmluZykge1xuICAgICAgICBoYW5kSW50ZXJmYWNlLnN0b3AoKTtcbiAgICB9XG4gICAgdGhpcy5zZXJpYWxpemUoKTtcblxuICAgIGxldCBzdGFtcCA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcbiAgICBsZXQgc2VyaWFsaXplZFBhZ2UgPSB0aGlzLmdldEZ1bGxIVE1MU3RyaW5nKCk7XG4gICAgbGV0IHR5cGVJbmZvID0gXCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD11dGYtOFwiO1xuICAgIGxldCB1cmwgPSBgJHt0eXBlSW5mb30sJHtlbmNvZGVVUklDb21wb25lbnQoc2VyaWFsaXplZFBhZ2UpfWA7XG5cbiAgICBsZXQgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGFuY2hvci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoYW5jaG9yKTtcbiAgICBhbmNob3IuaHJlZiA9IHVybDtcbiAgICBhbmNob3IuZG93bmxvYWQgPSBgU2ltcGxlVGFsa1NuYXBzaG90XyR7c3RhbXB9Lmh0bWxgO1xuICAgIGFuY2hvci5jbGljaygpO1xuICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgYW5jaG9yLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoYW5jaG9yKTtcbiAgICAvLyBTdGFydCBoYW5kIHJlY29nbml0aW9uIGlmIGl0IHdhcyBydW5uaW5nLlxuICAgIGlmIChoYW5kUmVjb2duaXRpb25PcmlnaW5hbGx5UnVubmluZykge1xuICAgICAgICBoYW5kSW50ZXJmYWNlLnN0YXJ0KCk7XG4gICAgfVxufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ3RlbGwnXSA9IChzZW5kZXJzLCB0YXJnZXRJZCwgZGVmZXJyZWRNZXNzYWdlKSA9PiB7XG4gICAgbGV0IHRhcmdldFBhcnQgPSBTeXN0ZW0ucGFydHNCeUlkW3RhcmdldElkXTtcbiAgICBpZighdGFyZ2V0UGFydCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIHRlbGwgcGFydCBpZCAke3RhcmdldElkfTogbm8gc3VjaCBwYXJ0IWApO1xuICAgIH1cbiAgICB0YXJnZXRQYXJ0LnNlbmRNZXNzYWdlKGRlZmVycmVkTWVzc2FnZSwgdGFyZ2V0UGFydCk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1sndG9nZ2xlSGFuZERldGVjdGlvbiddID0gKCkgPT4ge1xuICAgIGlmIChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25Nb2RlbCA9PT0gbnVsbCkge1xuICAgICAgICBoYW5kSW50ZXJmYWNlLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZEludGVyZmFjZS5zdG9wKCk7XG4gICAgfVxufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ21lcnJpYW0nXSA9IChzZW5kZXJzLCBkb2NJZCkgPT4ge1xuICAgIGNvbnN0IHNlbmRlciA9IFN5c3RlbS5wYXJ0c0J5SWRbc2VuZGVyc1swXS5pZF07XG4gICAgbWVycmlhbVNpbVNjb3JlKHNlbmRlciwgZG9jSWQpO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2dsb2JhbEludGVycnVwdCddID0gKCkgPT4ge1xuICAgIC8vIGN5Y2xlIHRocm91Z2ggYWxsIHRoZSBwYXJ0cyBhbmQgc2V0IHRoZSBcInN0ZXBwaW5nXCIgcHJvcGVydHkgdG8gZmFsc2VcbiAgICBPYmplY3QudmFsdWVzKFN5c3RlbS5wYXJ0c0J5SWQpLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgaWYocGFydC5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgIHBhcnQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChwYXJ0LCBcInN0ZXBwaW5nXCIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKiogUmVnaXN0ZXIgdGhlIGluaXRpYWwgc2V0IG9mIHBhcnRzIGluIHRoZSBzeXN0ZW0gKiovXG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdjYXJkJywgQ2FyZCk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdzdGFjaycsIFN0YWNrKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2ZpZWxkJywgRmllbGQpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnYnV0dG9uJywgQnV0dG9uKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ3dvcmxkJywgV29ybGRTdGFjayk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCd3aW5kb3cnLCBXaW5kb3cpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnZmllbGQnLCBGaWVsZCk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdkcmF3aW5nJywgRHJhd2luZyk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdpbWFnZScsIEltYWdlKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2FyZWEnLCBBcmVhKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2F1ZGlvJywgQXVkaW8pO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnYnJvd3NlcicsIEJyb3dzZXIpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgncmVzb3VyY2UnLCBSZXNvdXJjZSk7XG5cbi8qKiBSZWdpc3RlciB0aGUgaW5pdGlhbCBzZXQgb2Ygdmlld3MgaW4gdGhlIHN5c3RlbSAqKi9cblN5c3RlbS5yZWdpc3RlclZpZXcoJ2J1dHRvbicsIEJ1dHRvblZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnc3RhY2snLCBTdGFja1ZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnd29ybGQnLCBXb3JsZFZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnY2FyZCcsIENhcmRWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ3dpbmRvdycsIFdpbmRvd1ZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnZmllbGQnLCBGaWVsZFZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnZHJhd2luZycsIERyYXdpbmdWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2ltYWdlJywgSW1hZ2VWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2FyZWEnLCBBcmVhVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdhdWRpbycsIEF1ZGlvVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdicm93c2VyJywgQnJvd3NlclZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygncmVzb3VyY2UnLCBSZXNvdXJjZVZpZXcpO1xuXG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgYWRkaW5nIGFsbCBvZiB0aGVcbi8vIGF2YWlsYWJsZSBjdXN0b20gZWxlbWVudHMgdG8gdGhlIHdpbmRvdyBvYmplY3Qnc1xuLy8gY3VzdG9tRWxlbWVudHMgcmVnaXN0cnlcblN5c3RlbS5yZWdpc3RlckN1c3RvbUVsZW1lbnRzID0gZnVuY3Rpb24oKXtcbiAgICBPYmplY3Qua2V5cyhTeXN0ZW0uYXZhaWxhYmxlVmlld3MpLmZvckVhY2gocGFydE5hbWUgPT4ge1xuICAgICAgICBsZXQgdmlld0NsYXNzID0gU3lzdGVtLmF2YWlsYWJsZVZpZXdzW3BhcnROYW1lXTtcbiAgICAgICAgbGV0IGVsZW1lbnROYW1lID0gU3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQocGFydE5hbWUpO1xuICAgICAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKGVsZW1lbnROYW1lLCB2aWV3Q2xhc3MpO1xuICAgIH0pO1xufTtcblxuLy8gaW5paXRhbGl6ZSB0aGUgY29tcGlsZXIgYW5kIGFkZCBpdCB0byB0aGUgc3lzdGVtXG4vLyBJbnN0YW50aWF0ZSB0aGUgZ3JhbW1hci5cbmxldCBsYW5ndWFnZUdyYW1tYXI7XG5pZiAod2luZG93LmdyYW1tYXIpe1xuICAgIC8vIGZvciB0ZXN0aW5nIGl0IGlzIHNvbWV0aW1lcyBjb252ZW5pZW50IHRvIGxvYWQgdGhlIGdyYW1tYXIgYW5kIGFkZCB0byB3aW5kb3dcbiAgICAvLyBzZWUgLi90ZXN0cy9wcmVsb2FkLmpzIGZvciBleGFtcGxlXG4gICAgbGFuZ3VhZ2VHcmFtbWFyID0gb2htLmdyYW1tYXIod2luZG93LmdyYW1tYXIpO1xufSBlbHNlIHtcbiAgICBsYW5ndWFnZUdyYW1tYXIgPSBvaG0uZ3JhbW1hckZyb21TY3JpcHRFbGVtZW50KCk7XG59XG5cblN5c3RlbS5ncmFtbWFyID0gbGFuZ3VhZ2VHcmFtbWFyO1xuXG4vLyBTZXQgdGhlIGV4ZWN0aW9uIHN0YWNrIG9uIHRoZVxuLy8gU3lzdGVtXG5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sgPSBuZXcgRXhlY3V0aW9uU3RhY2soKTtcblxuLy8gQWRkIGEgZHluYW1pYyBnZXR0ZXIgZm9yIHRoZSBXb3JsZCBmb3IgY29udmVuaWVuY2Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeXN0ZW0sICd3b3JsZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICB9XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAvLyBBZGQgdGhlIFN5c3RlbSBvYmplY3QgdG8gd2luZG93IHNvXG4gICAgLy8gdGhhdCBpdCBpcyBnbG9iYWwgb24gdGhlIHBhZ2UuIFdlIGRvIHRoaXNcbiAgICAvLyBmb3IgYm90aCBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmcuXG4gICAgd2luZG93LlN5c3RlbSA9IFN5c3RlbTtcbiAgICAvLyBBZGQgdGhlIHBvc3NpYmxlIHZpZXdzIGFzIHdlYmNvbXBvbmVudHNcbiAgICAvLyBpbiB0aGUgY3VzdG9tIGVsZW1lbnQgcmVnaXN0cnlcbiAgICBTeXN0ZW0ucmVnaXN0ZXJDdXN0b21FbGVtZW50cygpO1xuXG4gICAgLy8gQWRkIGFueSBvdGhlciBub24tcGFydCB2aWV3IEN1c3RvbUVsZW1lbnRzLFxuICAgIC8vIGxpa2UgdGhlIGhhbG9cbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdC1oYWxvJywgSGFsbyk7XG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3QtbmF2aWdhdG9yJywgU1ROYXZpZ2F0b3IpO1xuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0LWVkaXRvcicsIEVkaXRvcik7XG5cbiAgICAvLyBBZGQgbmF2XG4gICAgU3lzdGVtLm5hdmlnYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LW5hdmlnYXRvcicpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoU3lzdGVtLm5hdmlnYXRvcik7XG5cbiAgICAvLyBBZGQgY29tcHJlaGVuc2l2ZSBlZGl0b3IgcGFuZVxuICAgIC8vIGlmIG9uZSBpcyBub3QgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBtYXJrdXBcbiAgICBsZXQgZXhpc3RpbmdFZGl0b3JzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdC1lZGl0b3InKSk7XG4gICAgZXhpc3RpbmdFZGl0b3JzLmZvckVhY2goZWRpdG9yRWwgPT4ge1xuICAgICAgICBlZGl0b3JFbC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgICBTeXN0ZW0uZWRpdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtZWRpdG9yJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChTeXN0ZW0uZWRpdG9yKTtcblxuICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgc2V0dXAgb2ZcbiAgICAvLyB0aGUgc3lzdGVtXG4gICAgU3lzdGVtLmluaXRpYWxMb2FkKCk7XG59KTtcblxuLy8gYWRkIGEgbWVzc2FnZSBsaXN0ZW5lciBvbiB3aW5kb3dcbi8vIHRoZXNlIGNhbiBpbmNsdWRlIG1lc3NhZ2UgZnJvbSBhIGJyb3dzZXIgcGFydFxuLy8gZm9yIG5vdyBmaWx0ZXIgdGhvc2Ugbm90IGNvbWluZyBmcm9tIHRoZSBvcmlnaW5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB3aW5kb3cub3JpZ2luKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc29sZS5sb2coYE1lc3NhZ2UgdG8gYnJvd3NlcmApO1xuICAgIC8vIFRPRE86IG1heWJlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIHF1b3RlIGVzY2FwZXMgZGlyZWN0bHlcbiAgICAvLyBpbiB0aGUgZ3JhbW1hclxuICAgIGxldCBzY3JpcHQgPSBldmVudC5kYXRhLnJlcGxhY2VBbGwoXCInXCIsICdcIicpO1xuICAgIC8vIG9ubHkgc3RhdGVtZW50cyBhcmUgYWNjZXB0ZWQgZm9yIG5vd1xuICAgIGxldCBwYXJzZWRTY3JpcHQgPSBsYW5ndWFnZUdyYW1tYXIubWF0Y2goc2NyaXB0LCBcIlN0YXRlbWVudFwiKTtcbiAgICBpZihwYXJzZWRTY3JpcHQuZmFpbGVkKCkpe1xuICAgICAgICAvLyBmb3Igbm93IGp1c3QgbG9nIHRoYXQgaXQgZmFpbGVkXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIHNjcmlwdCBmb3IgYnJvd3NlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc2VtYW50aWNzID0gbGFuZ3VhZ2VHcmFtbWFyLmNyZWF0ZVNlbWFudGljcygpO1xuICAgICAgICBsZXQgd29ybGQgPSBTeXN0ZW0ucGFydHNCeUlkW1wid29ybGRcIl07XG4gICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICAnaW50ZXJwcmV0JyxcbiAgICAgICAgICAgIGludGVycHJldGVyU2VtYW50aWNzKHdvcmxkLCBTeXN0ZW0pXG4gICAgICAgICk7XG4gICAgICAgIGxldCBtc2cgPSBzZW1hbnRpY3MocGFyc2VkU2NyaXB0KS5pbnRlcnByZXQoKTtcbiAgICAgICAgU3lzdGVtLnNlbmRNZXNzYWdlKG1zZywgd29ybGQsIFN5c3RlbSk7XG4gICAgfVxufSk7XG5cbi8vIGdsb2JhbCBpbnRlcnJ1cHRcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICBpZihldmVudC5jdHJsS2V5ICYmIGV2ZW50LmtleSA9PSAnYycpe1xuICAgICAgICBTeXN0ZW0uc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogXCJnbG9iYWxJbnRlcnJ1cHRcIixcbiAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgIH0sIFN5c3RlbSwgU3lzdGVtKTtcbiAgICB9XG59KTtcblxuXG5leHBvcnQge1xuICAgIFN5c3RlbSxcbiAgICBTeXN0ZW0gYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQXJlYVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIEFyZWEgUGFydC5cbiAqIEkgcmVwcmVzZW50IGEgJ2dyb3VwaW5nJyBvZiBzdWJwYXJ0cyB3aXRoaW5cbiAqIG15IG93bmVyIHBhcnQuXG4gKiBJIGNvbnRhaW4gdGhlIExheW91dCBwcm9wZXJ0aWVzIHNldCwgYW5kIHRoZXJlZm9yZVxuICogY2FuIGRpc3BsYXkgbXkgY29udGFpbmVkIHN1YnBhcnRzIGFjY29yZGluZyB0byBcbiAqIGRpZmZlcmVudCBsYXlvdXQgcHJvcGVydGllcyB0aGFuIG15IGFuY2VzdG9yXG4gKiBDYXJkLlxuICpcbiAqL1xuaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZExheW91dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY29uc3Qgc2lkZXMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5cbmNsYXNzIEFyZWEgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgICAgdGhpcy5hY2NlcHRlZFN1YnBhcnRUeXBlcyA9IFtcbiAgICAgICAgICAgIFwiYXJlYVwiLFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIFwiZmllbGRcIixcbiAgICAgICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAgICAgIFwiYXVkaW9cIixcbiAgICAgICAgICAgIFwicmVzb3VyY2VcIixcbiAgICAgICAgICAgIFwiZHJhd2luZ1wiLFxuICAgICAgICAgICAgXCJicm93c2VyXCIsXG4gICAgICAgICAgICBcIndpbmRvd1wiXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gQWRkIHN0eWxlIHByb3BzXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRMYXlvdXRTdHlsZVByb3BzKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldCBkZWZhdWx0IHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgLy8gZm9yIGFuIGVtcHR5IGFyZWFcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICA1MFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICA1MFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdjbGlwcGluZycsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdhbGxvdy1zY3JvbGxpbmcnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICAvLyBwYXJ0IHNwZWNpZmljIGRlZmF1bHQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LXdpZHRoYCxcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS1jb2xvcmAsXG4gICAgICAgICAgICAgICAgXCJyZ2IoMjM4LCAyMzgsIDIzOClcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tdHJhbnNwYXJlbmN5YCxcbiAgICAgICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnYXJlYSc7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBBcmVhLFxuICAgIEFyZWEgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCB7UGFydH0gZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRUZXh0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBBdWRpbyBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBzcmMpIHtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuXG4gICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3JjID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdyZWFkeVN0YXRlJyxcbiAgICAgICAgICAgIFwiSEFWRV9OT1RISU5HXCJcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwicGxheVwiLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwic3RvcFwiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFByaXZhdGUgY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImxvYWRBdWRpb0Zyb21Tb3VyY2VcIiwgdGhpcy5sb2FkQXVkaW9Gcm9tU291cmNlKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJwbGF5XCIsICgpID0+IHt0aGlzLnBsYXkodHJ1ZSk7fSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwicGF1c2VcIiwgKCkgPT4ge3RoaXMucGxheShmYWxzZSk7fSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwic3RvcFwiLCB0aGlzLnN0b3ApO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5sb2FkQXVkaW9Gcm9tU291cmNlID0gdGhpcy5sb2FkQXVkaW9Gcm9tU291cmNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGxheSA9IHRoaXMucGxheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0b3AgPSB0aGlzLnN0b3AuYmluZCh0aGlzKTtcblxuXG4gICAgICAgIC8vIGxvYWQgdGhlIHNyYyBpZiBwcm92aWRlZFxuICAgICAgICBpZihzcmMpe1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3R5bGUgcHJvcGVydGllc1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkVGV4dFN0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIFtcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiXS5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c2lkZX0td2lkdGhgLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnYXVkaW8nO1xuICAgIH1cblxuICAgIGxvYWRBdWRpb0Zyb21Tb3VyY2Uoc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHNvdXJjZVVybCk7XG4gICAgfVxuXG4gICAgcGxheSh2YWx1ZSl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInBsYXlcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzdG9wXCIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBzdG9wKCl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInBsYXlcIiwgZmFsc2UpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzdG9wXCIsIHRydWUpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQXVkaW8sXG4gICAgQXVkaW8gYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCB7UGFydH0gZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRUZXh0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBCcm93c2VyIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIHNyYykge1xuICAgICAgICBzdXBlcihvd25lcik7XG5cbiAgICAgICAgLy8gUHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zcmMgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdyZWFkeVN0YXRlJyxcbiAgICAgICAgICAgIFwiSEFWRV9OT1RISU5HXCJcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwicGxheVwiLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwic3RvcFwiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFByaXZhdGUgY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInNldFVSTFRvXCIsIHRoaXMuc2V0VVJMKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJmb3J3YXJkXCIsIHRoaXMuc2VuZE1lc3NhZ2VUb0Jyb3dzZXIpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXRVUkwgPSB0aGlzLnNldFVSTC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlVG9Ccm93c2VyID0gdGhpcy5zZW5kTWVzc2FnZVRvQnJvd3Nlci5iaW5kKHRoaXMpO1xuXG5cbiAgICAgICAgLy8gbG9hZCB0aGUgc3JjIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC10cmFuc3BhcmVuY3knLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl0uZm9yRWFjaCgoc2lkZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3NpZGV9LXdpZHRoYCxcbiAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgICAgIDQwMCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2Jyb3dzZXInO1xuICAgIH1cblxuICAgIHNldFVSTChzZW5kZXJzLCBzb3VyY2VVcmwpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgc291cmNlVXJsKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZVRvQnJvd3NlcihzZW5kZXJzLCBtZXNzYWdlKXtcbiAgICAgICAgbGV0IHZpZXdzID0gd2luZG93LlN5c3RlbS5maW5kVmlld3NCeUlkKHRoaXMuaWQpO1xuICAgICAgICB2aWV3cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICBsZXQgaWZyYW1lID0gdi5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiaWZyYW1lXCIpO1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgd2luZG93Lm9yaWdpbik7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQnJvd3NlcixcbiAgICBCcm93c2VyIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEJ1dHRvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIEJ1dHRvbiBQYXJ0LlxuICogTXkgb3duZXIgaXMgYWx3YXlzIGEgQ2FyZC5cbiAqIEkgYW0gYSBjbGlja2FibGUgcG9pbnQgb2YgaW50ZXJhY3Rpb24gb24gYSBDYXJkLFxuICogd2hvc2UgZnVuY3Rpb25hbGl0eSBjYW4gYmUgY3VzdG9taXplZCBieSB0aGUgYXV0aG9yLlxuICovXG5pbXBvcnQgUGFydCBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRUZXh0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcil7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICB0aGlzLmlzQnV0dG9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBBZGQgQnV0dG9uLXNwZWNpZmljIHBhcnQgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgJ3NlbGVjdGVkVGV4dCcsXG4gICAgICAgICAgICBudWxsLCAvLyByZWFkT25seSAoZm9yIG5vdylcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VsZWN0ZWRUZXh0LFxuICAgICAgICAgICAgdHJ1ZSwgLy8gcmVhZE9ubHksXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkVGV4dFN0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgIFwicmdiKDI1NSwgMjM0LCAxNDkpXCIsIC8vIHZhcigtLXBhbGV0dGUteWVsbG93KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2Nvcm5lci10b3AtbGVmdC1yb3VuZCcsXG4gICAgICAgICAgICAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY29ybmVyLXRvcC1yaWdodC1yb3VuZCcsXG4gICAgICAgICAgICAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY29ybmVyLWJvdHRvbS1sZWZ0LXJvdW5kJyxcbiAgICAgICAgICAgIDNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjb3JuZXItYm90dG9tLXJpZ2h0LXJvdW5kJyxcbiAgICAgICAgICAgIDNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdib3JkZXItdG9wLXdpZHRoJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdib3JkZXItYm90dG9tLXdpZHRoJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdib3JkZXItbGVmdC13aWR0aCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYm9yZGVyLXJpZ2h0LXdpZHRoJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdzaGFkb3ctbGVmdCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnc2hhZG93LXRvcCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnc2hhZG93LWJsdXInLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3NoYWRvdy1ibHVyJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnYnV0dG9uJztcbiAgICB9XG5cbiAgICAvL1RPRE86IGltcGxlbWVudCB0aGlzIHByb3BlcnR5XG4gICAgLy8gZ2V0dGVyIGZvciByZWFsXG4gICAgZ2V0U2VsZWN0ZWRUZXh0KHByb3BOYW1lLCBwcm9wVmFsKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBCdXR0b24sXG4gICAgQnV0dG9uIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIENhcmRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgQ2FyZCBQYXJ0LlxuICogSSByZXByZXNlbnQgYSBjb2xsZWN0aW9uIG9mIFBhcnRzIHRoYXQgaXNcbiAqIGRpc3BsYXllZCBvbiB0aGUgc2NyZWVuLiBNeSBvd25lciBpcyBhbHdheXNcbiAqIGEgU3RhY2sgUGFydC5cbiAqIEkgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgUGFydCwgaW5jbHVkaW5nXG4gKiBidXR0b25zIGFuZCBmaWVsZHMuXG4gKi9cbmltcG9ydCB7UGFydH0gZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgQmFzaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcblxuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkTGF5b3V0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBDYXJkIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIG5hbWUpe1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLl9vd25lcjtcbiAgICAgICAgdGhpcy5hY2NlcHRlZFN1YnBhcnRUeXBlcyA9IFtcbiAgICAgICAgICAgIFwid2luZG93XCIsIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBcImZpZWxkXCIsIFwiZmllbGRcIiwgXCJhcmVhXCIsIFwiZHJhd2luZ1wiLFxuICAgICAgICAgICAgXCJpbWFnZVwiLCBcImF1ZGlvXCIsIFwiYnJvd3NlclwiLCBcInJlc291cmNlXCJcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5pc0NhcmQgPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCBDYXJkLXNwZWNpZmljIHBhcnRcbiAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdtYXJrZWQnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnY2FudERlbGV0ZScsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdkb250U2VhcmNoJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3Nob3dQaWN0JyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIGluaXRpYWxpemluZyB3aXRoIGEgbmFtZVxuICAgICAgICAvLyBzZXQgdGhlIG5hbWUgcHJvcGVydHlcbiAgICAgICAgaWYobmFtZSl7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0eWxpbmdcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRMYXlvdXRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcInJnYigwLCA3NSwgMTAzKVwiIC8vIHBhbGV0dGUtYmx1ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnY2FyZCc7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBDYXJkLFxuICAgIENhcmQgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQmFzaWMgVXNlciBEcmF3aW5nIFBhcnRcbiAqL1xuaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jbGFzcyBEcmF3aW5nIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpe1xuICAgICAgICBzdXBlcihvd25lcik7XG5cbiAgICAgICAgLy8gU2V0IG5ldyBwcm9wZXJ0aWVzIGZvciB0aGlzXG4gICAgICAgIC8vIHBhcnQgdHlwZVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ21vZGUnLFxuICAgICAgICAgICAgJ2RyYXdpbmcnXG4gICAgICAgICk7XG4gICAgICAgIC8vIFN0eWxlXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC10cmFuc3BhcmVuY3knLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LWNvbG9yYCxcbiAgICAgICAgICAgICAgICBcInJnYigyMzgsIDIzOCwgMjM4KVwiLCAvL2dyZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tdHJhbnNwYXJlbmN5YCxcbiAgICAgICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAzMDBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgMjAwXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gV2UgYXJlIHVzaW5nIGEgZGlzdGluY3Qgc2hvdy1ib3JkZXJcbiAgICAgICAgLy8gcHJvcGVydHkgdG8gZGVhbCB3aXRoIGJlaW5nIGFibGUgdG8gc2VlXG4gICAgICAgIC8vIGEgZHJhd2luZyB0aGF0IGlzIGVtcHR5XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3Nob3ctYm9yZGVyJyxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBXaGVuIGRyYXdpbmcgZnJvbSBhIHNjcmlwdC9jb21tYW5kcyxcbiAgICAgICAgLy8gd2Ugd2lsbCB1c2UgdGhpcyBhcyB0aGUgb3BlbiBjYW52YXNcbiAgICAgICAgLy8gd2hvc2UgaW1hZ2UgYnl0ZXMgd2lsbCBiZSBzZXQgdG8gdGhlXG4gICAgICAgIC8vIGltYWdlIHByb3BlcnR5XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gbnVsbDtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGRyYXdpbmcgY29tbWFuZHNcbiAgICAgICAgdGhpcy5zZXR1cERyYXdpbmdDb21tYW5kcygpO1xuXG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNldHVwRHJhd2luZ0NvbW1hbmRzID0gdGhpcy5zZXR1cERyYXdpbmdDb21tYW5kcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0cm9rZSA9IHRoaXMuc3Ryb2tlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVRvID0gdGhpcy5tb3ZlVG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5saW5lVG8gPSB0aGlzLmxpbmVUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJlZ2luRHJhdyA9IHRoaXMuYmVnaW5EcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5kRHJhdyA9IHRoaXMuZW5kRHJhdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsZWFyID0gdGhpcy5jbGVhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvb3Jkc0Zyb21TdHJpbmcgPSB0aGlzLmNvb3Jkc0Zyb21TdHJpbmcuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2RyYXdpbmcnO1xuICAgIH1cblxuICAgIHNldHVwRHJhd2luZ0NvbW1hbmRzKCl7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdsaW5lVG8nLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5saW5lVG8oLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignbW92ZVRvJywgKHNlbmRlcnMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ2JlZ2luRHJhdycsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luRHJhdyguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdmaW5pc2hEcmF3JywgKHNlbmRlcnMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhdyguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdzdHJva2UnLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdHJva2UoLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignY2xlYXInLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhciguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyogU2NyaXB0YWJsZSBEcmF3aW5nIENvbW1hbmRzICovXG4gICAgc3Ryb2tlKCl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIC8vIEhhcmQtY29kZWQuIEdldCBmcm9tIHByb3BzXG4gICAgICAgICAgICAvLyBhbmQgbGluayB0byB2aWV3c1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LnN0cm9rZVdpZHRoID0gMTA7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVRvKHgsIHkpe1xuICAgICAgICBpZih0aGlzLmlzRHJhd2luZyl7XG4gICAgICAgICAgICAvL2xldCBjb29yZHMgPSB0aGlzLmNvb3Jkc0Zyb21TdHJpbmcoY29vcmRQYWlyKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5tb3ZlVG8oXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGluZVRvKHgsIHkpe1xuICAgICAgICBpZih0aGlzLmlzRHJhd2luZyl7XG4gICAgICAgICAgICAvL2xldCBjb29yZHMgPSB0aGlzLmNvb3Jkc0Zyb21TdHJpbmcoY29vcmRQYWlyKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5saW5lVG8oXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVnaW5EcmF3KCl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRHJhd2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzLndpZHRoID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICd3aWR0aCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMuaGVpZ2h0ID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dCA9IHRoaXMuYWN0aXZlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgY3VycmVudGx5IGltYWdlIGRhdGEgc2V0IHRvIHRoZVxuICAgICAgICAvLyBpbWFnZSBwYXJ0IHByb3BlcnR5LCB3ZSBuZWVkIHRvIGRyYXcgdGhhdCBpbWFnZVxuICAgICAgICAvLyBvbnRvIHRoZSBjYW52YXMgZmlyc3QuXG4gICAgICAgIGxldCBjdXJyZW50SW1hZ2UgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50SW1hZ2Upe1xuICAgICAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IGN1cnJlbnRJbWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlZ2luIGEgZHJhd2luZyBwYXRoXG4gICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBlbmREcmF3KCl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5zdHJva2UoKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbWFnZSBwcm9wZXJ0eSB0byBiZSB0aGVcbiAgICAgICAgICAgIC8vIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBpbWFnZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB1cGRhdGUgYW55IHN1YnNjcmliZWQgdmlld3NcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMudG9EYXRhVVJMKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc0RyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcy53aWR0aCA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnd2lkdGgnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzLmhlaWdodCA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaGVpZ2h0J1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQgPSB0aGlzLmFjdGl2ZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzLnRvRGF0YVVSTCgpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKiBVdGlsaXR5IE1ldGhvZHMgZm9yIFNjcmlwdGFibGUgRHJhd2luZyAqL1xuICAgIGNvb3Jkc0Zyb21TdHJpbmcoY29vcmRTdHJpbmcpe1xuICAgICAgICBsZXQgcGFpciA9IGNvb3JkU3RyaW5nLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgbGV0IHggPSBwYXJzZUludChwYWlyWzBdKTtcbiAgICAgICAgbGV0IHkgPSBwYXJzZUludChwYWlyWzFdKTtcbiAgICAgICAgcmV0dXJuIHt4LCB5fTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIERyYXdpbmcsXG4gICAgRHJhd2luZyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBGaWVsZFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBGaWVsZCBQYXJ0LlxuICogSSBhbSBhIGNvbnRhaW5lciB0aGF0IGhvbGRzIHRleHQuIEkgYWxzbyBhbGxvd1xuICogYSB1c2VyIHRvIGVkaXQgbXkgdGV4dC5cbiAqL1xuaW1wb3J0IFBhcnQgZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgQmFzaWNQcm9wZXJ0eSxcbiAgICBEeW5hbWljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRUZXh0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jb25zdCBzaWRlcyA9IFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXTtcblxuY2xhc3MgRmllbGQgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgbmFtZSl7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzID0gW1wiZmllbGRcIl07XG5cbiAgICAgICAgdGhpcy5pc0ZpZWxkID0gdHJ1ZTtcblxuICAgICAgICBpZihuYW1lKXtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBGaWVsZC1zcGVjaWZpY1xuICAgICAgICAvLyBQYXJ0IFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICAnZWRpdGluZycgLy9UT0RPIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBcImJyYXZvXCIgb3IgXCJzaW1wbGV0YWxrXCJcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdpbm5lckhUTUwnLFxuICAgICAgICAgICAgJydcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICd0YXJnZXRSYW5nZUlkJyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyAndGV4dCcgaXMgYSBEeW5hbWljUHJvcGVydHkgY29uZmlndXJlZCB0byBhbHNvIHNldCB0aGUgaW5uZXJIVE1MXG4gICAgICAgIC8vIEJhc2ljUHJvcGVydHkgd2hlbiBjaGFuZ2VkLiBUaGUgYmFzaWMgaWRlYSBpcyB0aGF0ICd0ZXh0JyB3aWxsIGJlXG4gICAgICAgIC8vIHRoZSBwcm9wZXJ0eSB0aGF0IFNUIHdpbGwgaW50ZXJmYWNlIHdpdGggYW5kIGV2ZXJ5dGltZSBpdFxuICAgICAgICAvLyBpcyBjaGFuZ2VkIHRoZSAnaW5uZXJIVE1MJyBwcm9wZXJ0eSBzaG91bGQgZm9sbG93LlxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgKG93bmVyLCBwcm9wLCB2YWx1ZSwgbm90aWZ5KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcC5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZihub3RpZnkpe1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBpZighdmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIjxicj5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGFsbCBuZXdsaW5lIGNoYXJhY3RlcnMgd2l0aCA8YnI+XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChvd25lciwgJ2lubmVySFRNTCcsIHZhbHVlLCBub3RpZnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAob3duZXIsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcC5fdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2UsIC8vIG5vdCByZWFkIG9ubHlcbiAgICAgICAgICAgICcnICAgICAvLyBkZWZhdWx0IGlzIGVtcHR5IHN0cmluZ1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuXG4gICAgICAgIC8vIEEgbnVtYmVyIG9mIHRoZSBwcm9wcyBkZWFsIHdpdGggZGlyZWN0IHRleHQgZWRpdGluZyxcbiAgICAgICAgLy8gYW5kIHNvIHRoZXkgYXJlIGxpa2UgY29tbWFuZHMuIEV4YW1wbGVzIGluY2x1ZGUgXCJ1bmRvXCJcbiAgICAgICAgLy8gXCJyZWRvXCIgXCJjbGVhclwiIGV0Yy4gSGVyZSB3ZSB1c2UgZHluYW1pIHByb3BzIHdoaWNoIHRoZVxuICAgICAgICAvLyB2aWV3IGNhbiByZXNwb25kIHRvIGFjY29yZGluZ2x5LCBidXQgaGF2aW5nIHRoZXNlIHByb3BzIGhhdmVcbiAgICAgICAgLy8gbm8gYWN0dWFsICdzdGF0ZSdcbiAgICAgICAgLyoqIFRPRE86IHRoZXNlIHNob3VsZCBiZSBwcml2YXRlIGNvbW1hbmRzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICBcInVuZG9cIixcbiAgICAgICAgICAgICgpID0+IHt9LCAvLyBhbGwgd2UgaXMgYSBub3RpZmljYXRpb25cbiAgICAgICAgICAgICgpID0+IHt9IC8vIG5vIGdldHRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgXCJyZWRvXCIsXG4gICAgICAgICAgICAoKSA9PiB7fSwgLy8gYWxsIHdlIGlzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAoKSA9PiB7fSAvLyBubyBnZXR0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgIFwicmVtb3ZlLWZvcm1hdFwiLFxuICAgICAgICAgICAgKCkgPT4ge30sIC8vIGFsbCB3ZSBpcyBhIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgKCkgPT4ge30gLy8gbm8gZ2V0dGVyXG4gICAgICAgICk7XG4gICAgICAgICoqL1xuXG4gICAgICAgIC8vIFN0eWxpbmdcbiAgICAgICAgLy8gc2V0dGluZyB3aWR0aCBhbmQgaGVpZ2h0IHRvIG51bGxcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgZm9yY2VzIHRvIHRoZSBkZWZhdWx0IHNpemVcbiAgICAgICAgLy8gb2YgdGhlIGJ1dHRvbiB0byBmaXQgdGhlIGJ1dHRvbiBuYW1lXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRUZXh0U3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICAvLyBwYXJ0IHNwZWNpZmljIGRlZmF1bHQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InLFxuICAgICAgICAgICAgXCJyZ2IoMjU1LCAyNDgsIDIyMClcIiwgLy8gdmFyKC0tcGFsZXR0ZS1jb3Juc2lrKVxuICAgICAgICApO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgICAgIFwibWVkaXVtXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LXN0eWxlYCxcbiAgICAgICAgICAgICAgICBcInNvbGlkXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LWNvbG9yYCxcbiAgICAgICAgICAgICAgICBcImJsYWNrXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LXdpZHRoYCxcbiAgICAgICAgICAgICAgICBcIjFcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICAgICAgNDAwLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFByaXZhdGUgY29tbWFuZCBoYW5kbGVyc1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0UmFuZ2UgPSB0aGlzLmluc2VydFJhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uID0gdGhpcy5zZXRTZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJpbnNlcnRSYW5nZVwiLCB0aGlzLmluc2VydFJhbmdlKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzZXRTZWxlY3Rpb25cIiwgdGhpcy5zZXRTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImhpZ2hsaWdodFN5bnRheFwiLCB0aGlzLmhpZ2hsaWdodFN5bnRheCk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwidW5oaWdobGlnaHRTeW50YXhcIiwgdGhpcy51bmhpZ2hsaWdodFN5bnRheCk7XG4gICAgfVxuXG4gICAgaW5zZXJ0UmFuZ2Uoc2VuZGVycywgcmFuZ2VJZCwgaHRtbCwgY3NzKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5maW5kVmlld3NCeUlkKHRoaXMuaWQpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcuaW5zZXJ0UmFuZ2UocmFuZ2VJZCwgaHRtbCwgY3NzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0aW9uKHNlbmRlcnMsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSl7XG4gICAgICAgIC8vIGZvciBub3cganVzdCBhbGxvdyBwcm9wZXJ0aWVzIG9mIHR5cGUgXCJ0ZXh0LSpcIiB0byBiZSBzZXRcbiAgICAgICAgaWYocHJvcGVydHlOYW1lLnN0YXJ0c1dpdGgoXCJ0ZXh0LVwiKSl7XG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGhpcy5pZCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0U2VsZWN0aW9uKHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZ2hsaWdodFN5bnRheCgpe1xuICAgICAgICBsZXQgdmlldyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKHRoaXMuaWQpO1xuICAgICAgICBpZih2aWV3KXtcbiAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0U3ludGF4KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bmhpZ2hsaWdodFN5bnRheCgpe1xuICAgICAgICBsZXQgdmlldyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKHRoaXMuaWQpO1xuICAgICAgICBpZih2aWV3KXtcbiAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHRTeW50YXgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnZmllbGQnO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRmllbGQsXG4gICAgRmllbGQgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCB7UGFydH0gZnJvbSAnLi9QYXJ0LmpzJztcblxuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIEltYWdlIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIHNyYykge1xuICAgICAgICBzdXBlcihvd25lcik7XG5cbiAgICAgICAgLy8gUHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgIHRoaXMuc2V0U291cmNlLFxuICAgICAgICAgICAgdGhpcy5nZXRTb3VyY2VcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9zcmMgPSBzcmM7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcIm1pbWVUeXBlXCIsXG4gICAgICAgICAgICBcInVua25vd25cIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJpbWFnZURhdGFcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdkcmFnZ2FibGUnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC10cmFuc3BhcmVuY3knLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InLFxuICAgICAgICAgICAgXCJibGFja1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZEltYWdlRnJvbVwiLCB0aGlzLmxvYWRJbWFnZUZyb21Tb3VyY2UpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImxvYWRJbWFnZUZyb21GaWxlXCIsIHRoaXMubG9hZEltYWdlRnJvbUZpbGUpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2VGcm9tU291cmNlID0gdGhpcy5sb2FkSW1hZ2VGcm9tU291cmNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubG9hZEltYWdlRnJvbUZpbGUgPSB0aGlzLmxvYWRJbWFnZUZyb21GaWxlLmJpbmQodGhpcyk7XG4gICAgfVxuXG5cbiAgICBsb2FkSW1hZ2VGcm9tU291cmNlKHNlbmRlcnMsIHNvdXJjZVVybCl7XG4gICAgICAgIGZldGNoKHNvdXJjZVVybClcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgaWYoIWNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlJykpe1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW1hZ2UgbWltZVR5cGU6ICR7Y29udGVudFR5cGV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgXCJtaW1lVHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYoY29udGVudFR5cGUuc3RhcnRzV2l0aChcImltYWdlL3N2Z1wiKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbih0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbWFnZURhdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCkudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbWFnZURhdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVzdWx0IC8vIHdpbGwgYmUgdGhlIGJhc2U2NCBlbmNvZGVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgX3NyYy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBpbmZpbml0ZWx5XG4gICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgbG9hZCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLl9zcmMgPSBzb3VyY2VVcmw7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbG9hZEltYWdlRnJvbUZpbGUoKXtcbiAgICAgICAgbGV0IGZpbGVQaWNrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBmaWxlUGlja2VyLnR5cGUgPSAnZmlsZSc7XG4gICAgICAgIGZpbGVQaWNrZXIuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCAnaW1hZ2UvKicpO1xuICAgICAgICBmaWxlUGlja2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGZpbGVQaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGZpbGUgaGVyZVxuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbWVUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBpY2tlci5maWxlc1swXS50eXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICdpbWFnZURhdGEnLFxuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVzdWx0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgaW1hZ2VGaWxlID0gZmlsZVBpY2tlci5maWxlc1swXTtcbiAgICAgICAgICAgIGlmKGltYWdlRmlsZS50eXBlLmluY2x1ZGVzKCdzdmcnKSl7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoaW1hZ2VGaWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2VGaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVQaWNrZXIucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChmaWxlUGlja2VyKTtcbiAgICAgICAgZmlsZVBpY2tlci5jbGljaygpO1xuICAgIH1cblxuICAgIHNldFNvdXJjZShvd25lciwgcHJvcGVydHksIHZhbHVlKXtcbiAgICAgICAgb3duZXIuX3NyYyA9IHZhbHVlO1xuICAgICAgICBpZih2YWx1ZSl7XG4gICAgICAgICAgICBvd25lci5sb2FkSW1hZ2VGcm9tU291cmNlKFt0aGlzXSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U291cmNlKG93bmVyLCBwcm9wZXJ0eSl7XG4gICAgICAgIHJldHVybiBvd25lci5fc3JjO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgIH1cblxuICAgIGdldCBpc1N2Zygpe1xuICAgICAgICBsZXQgbWltZVR5cGUgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgXCJtaW1lVHlwZVwiXG4gICAgICAgICk7XG4gICAgICAgIGlmKCFtaW1lVHlwZSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWltZVR5cGUuc3RhcnRzV2l0aCgnaW1hZ2Uvc3ZnJyk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBJbWFnZSxcbiAgICBJbWFnZSBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBQYXJ0XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIHJlcHJlc2VudCB0aGUgcHJvdG90eXBlIG9iamVjdCBmb3IgYWxsXG4gKiBTaW1wbGVUYWxrIHBhcnRzLlxuICovXG5pbXBvcnQge1xuICAgIGlkTWFrZXIsXG4gICAgaXNWYWxpZElkXG59IGZyb20gJy4uL3V0aWxzL2lkLmpzJztcbmltcG9ydCBlcnJvckhhbmRsZXIgZnJvbSAnLi4vdXRpbHMvZXJyb3JIYW5kbGVyLmpzJztcbmltcG9ydCB7XG4gICAgUGFydFByb3BlcnRpZXMsXG4gICAgQmFzaWNQcm9wZXJ0eSxcbiAgICBEeW5hbWljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmltcG9ydCB7QWN0aXZhdGlvbkNvbnRleHR9IGZyb20gJy4uL0V4ZWN1dGlvblN0YWNrLmpzJztcblxuXG5jbGFzcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihhbk93bmVyUGFydCwgbmFtZSwgZGVzZXJpYWxpemluZz1mYWxzZSl7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgIC8vIEFuIGFycmF5IG9mIGNoaWxkIHBhcnRzXG4gICAgICAgIHRoaXMuc3VicGFydHMgPSBbXTtcbiAgICAgICAgLy8gYSBsaXN0IG9mIGFsbCBhY2NlcHRlZCBzdWJwYXJ0cyBieSB0eXBlXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhpcyBpcyBudWxsIGFuZCBlYWNoIFBhcnQgc3ViY2xjYXNzIHNob3VsZFxuICAgICAgICAvLyBzcGVjaWZ5IGlmIG90aGVyd2lzZVxuICAgICAgICB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzID0gW107XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcyA9IG5ldyBQYXJ0UHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLl9vd25lciA9IGFuT3duZXJQYXJ0O1xuICAgICAgICB0aGlzLl9jb21tYW5kSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZUNvbW1hbmRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9mdW5jdGlvbkhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuX3NjcmlwdFNlbWFudGljcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eVN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3N0ZXBJbnRlcnZhbElkID0gbnVsbDtcblxuICAgICAgICB0aGlzLmlzUGFydCA9IHRydWU7XG5cbiAgICAgICAgLy8gQmluZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wZXJ0aWVzID0gdGhpcy5zZXR1cFByb3BlcnRpZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcyA9IHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmFkZFBhcnQgPSB0aGlzLmFkZFBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQYXJ0ID0gdGhpcy5yZW1vdmVQYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWNjZXB0c1N1YnBhcnQgPSB0aGlzLmFjY2VwdHNTdWJwYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyID0gdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQcml2YXRlQ29tbWFuZEhhbmRsZXIgPSB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEZ1bmNIYW5kbGVyID0gdGhpcy5zZXRGdW5jSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVDbWQgPSB0aGlzLnJlY2VpdmVDbWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlRnVuYyA9IHRoaXMucmVjZWl2ZUZ1bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlRXJyb3IgPSB0aGlzLnJlY2VpdmVFcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlID0gdGhpcy5yZWNlaXZlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlTWVzc2FnZSA9IHRoaXMuZGVsZWdhdGVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSB0aGlzLnNlbmRNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHlTdWJzY3JpYmVyID0gdGhpcy5hZGRQcm9wZXJ0eVN1YnNjcmliZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQcm9wZXJ0eVN1YnNjcmliZXIgPSB0aGlzLnJlbW92ZVByb3BlcnR5U3Vic2NyaWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFZpZXdTdWJzY3JpYmVyID0gdGhpcy5hZGRWaWV3U3Vic2NyaWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVZpZXdTdWJzY3JpYmVyID0gdGhpcy5yZW1vdmVWaWV3U3Vic2NyaWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHRoaXMuc2VyaWFsaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9KU09OID0gdGhpcy50b0pTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wc0Zyb21EZXNlcmlhbGl6ZXIgPSB0aGlzLnNldFByb3BzRnJvbURlc2VyaWFsaXplci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmRBbmNlc3Rvck9mVHlwZSA9IHRoaXMuZmluZEFuY2VzdG9yT2ZUeXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbkVkaXRvckNtZEhhbmRsZXIgPSB0aGlzLm9wZW5FZGl0b3JDbWRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3JDbWRIYW5kbGVyID0gdGhpcy5jbG9zZUVkaXRvckNtZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb3B5Q21kSGFuZGxlciA9IHRoaXMuY29weUNtZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXN0ZUNtZEhhbmRsZXIgPSB0aGlzLnBhc3RlQ21kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzU3VicGFydE9mQ3VycmVudENhcmQgPSB0aGlzLmlzU3VicGFydE9mQ3VycmVudENhcmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc1N1YnBhcnRPZkN1cnJlbnRTdGFjayA9IHRoaXMuaXNTdWJwYXJ0T2ZDdXJyZW50U3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRPd25lckJyYW5jaCA9IHRoaXMuZ2V0T3duZXJCcmFuY2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdGFydFN0ZXBwaW5nID0gdGhpcy5zdGFydFN0ZXBwaW5nLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3RvcFN0ZXBwaW5nID0gdGhpcy5zdG9wU3RlcHBpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUYXJnZXRQcm9wID0gdGhpcy5zZXRUYXJnZXRQcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vdmVTdWJwYXJ0VXAgPSB0aGlzLm1vdmVTdWJwYXJ0VXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlU3VicGFydERvd24gPSB0aGlzLm1vdmVTdWJwYXJ0RG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vdmVTdWJwYXJ0VG9GaXJzdCA9IHRoaXMubW92ZVN1YnBhcnRUb0ZpcnN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVN1YnBhcnRUb0xhc3QgPSB0aGlzLm1vdmVTdWJwYXJ0VG9MYXN0LmJpbmQodGhpcyk7XG5cblxuXG4gICAgICAgIC8vIEZpbmFsbHksIHdlIGZpbmlzaCBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLnNldHVwUHJvcGVydGllcygpO1xuXG4gICAgICAgIC8vIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJvcGVuRWRpdG9yXCIsIHRoaXMub3BlbkVkaXRvckNtZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImNsb3NlRWRpdG9yXCIsIHRoaXMuY2xvc2VFZGl0b3JDbWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzZXRUYXJnZXRUb1wiLCB0aGlzLnNldFRhcmdldFByb3ApO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImNvcHlcIiwgdGhpcy5jb3B5Q21kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwicGFzdGVcIiwgdGhpcy5wYXN0ZUNtZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlVXBcIiwgKCkgPT4ge3RoaXMuX293bmVyLm1vdmVTdWJwYXJ0VXAodGhpcyk7fSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZURvd25cIiwgKCkgPT4ge3RoaXMuX293bmVyLm1vdmVTdWJwYXJ0RG93bih0aGlzKTt9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlVG9GaXJzdFwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnRUb0ZpcnN0KHRoaXMpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0xhc3RcIiwgKCkgPT4ge3RoaXMuX293bmVyLm1vdmVTdWJwYXJ0VG9MYXN0KHRoaXMpO30pO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGdldHRlciB0byBnZXQgdGhlIGlkXG4gICAgLy8gZnJvbSB0aGUgcGFydFByb3BlcnRpZXNcbiAgICBnZXQgaWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCAnaWQnKTtcbiAgICB9XG5cbiAgICBzZXQgaWQodmFsKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCAnaWQnLCB2YWwpO1xuICAgIH1cblxuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIG5hbWVzIG9mIGFsbCBvZiBteSBhbmQgbXkgYW5jZXN0b3JzJyBoYW5kbGVyc1xuICAgIC8vIGZvciB0aGUgbW9tZW50IHRoaXMgaXMganVzdCBuYW1lcywgdHlwZSwgaWQgYW5kIHdoZXRoZXIgdGhlIGhhbmRsZXIgb3ZlcnJpZGVzXG4gICAgLy8gYW4gb3duZXIncywgYnV0IGNvdWxkIGJlIHJpY2hlciBpbmZvLCBzdWNoIGFzIGFyZ3VtZW50cywgZG9jdW1lbnRhdGlvbiBldGNcbiAgICBnZXQgY29tbWFuZEhhbmRsZXJSZWdpc3RyeSgpe1xuICAgICAgICBsZXQgaGFuZGxlcnNJbmZvID0ge307XG4gICAgICAgIGxldCBvd25lckJyYW5jaCA9IHRoaXMuZ2V0T3duZXJCcmFuY2goKTtcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8PSBvd25lckJyYW5jaC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgcGFydCA9IG93bmVyQnJhbmNoW293bmVyQnJhbmNoLmxlbmd0aCAtIGldO1xuICAgICAgICAgICAgbGV0IHBhcnRUeXBlID0gcGFydC50eXBlO1xuICAgICAgICAgICAgaWYocGFydC5pZCA9PT0gLTEpe1xuICAgICAgICAgICAgICAgIHBhcnRUeXBlID0gXCJTeXN0ZW1cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3lzdGVtIGRvZXNuJ3QgaGF2ZSBwcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJ0Ll9wcml2YXRlQ29tbWFuZEhhbmRsZXJzKS5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdmVycmlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZihoYW5kbGVyc0luZm9baF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzSW5mb1toXSA9IHtwYXJ0SWQ6IHBhcnQuaWQsIHBhcnRUeXBlOiBwYXJ0VHlwZSwgb3ZlcnJpZGU6IG92ZXJyaWRlLCBwcml2YXRlOiB0cnVlfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcnQuX2NvbW1hbmRIYW5kbGVycykuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvdmVycmlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKGhhbmRsZXJzSW5mb1toXSl7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNJbmZvW2hdID0ge3BhcnRJZDogcGFydC5pZCwgcGFydFR5cGU6IHBhcnRUeXBlLCBvdmVycmlkZTogb3ZlcnJpZGUsIHByaXZhdGU6IGZhbHNlfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVyc0luZm87XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB0aGUgdGhpcy5wYXJ0IC0+IFN5c3RlbSBicmFuY2ggYnkgcGFydCBpZFxuICAgIGdldE93bmVyQnJhbmNoKGJyYW5jaCl7XG4gICAgICAgIGlmKCFicmFuY2gpe1xuICAgICAgICAgICAgYnJhbmNoID0gW3RoaXNdO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMudHlwZSA9PT0gXCJ3b3JsZFwiKXtcbiAgICAgICAgICAgIGJyYW5jaC5wdXNoKHdpbmRvdy5TeXN0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyYW5jaC5wdXNoKHRoaXMuX293bmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX293bmVyLmdldE93bmVyQnJhbmNoKGJyYW5jaCk7XG4gICAgfVxuXG4gICAgLy8gQ29uZmlndXJlcyB0aGUgc3BlY2lmaWMgcHJvcGVydGllcyB0aGF0IHRoZVxuICAgIC8vIGdpdmVuIHBhcnQgY2FuIGV4cGVjdCwgYWxvbmcgd2l0aCBhbnkgZGVmYXVsdFxuICAgIC8vIHZhbHVlcy5cbiAgICAvLyBEZXNjZW5kYW50IFBhcnRzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZFxuICAgIC8vIGluIHRoZWlyIG93biBjb25zdHJ1Y3RvciBhZnRlciBjYWxsaW5nIHN1cGVyLFxuICAgIC8vIHNvIHRoYXQgdGhleSBnZXQgdGhlIHBhcmVudCdzIGdlbmVyYWwgcHJvcGVydGllc1xuICAgIC8vIHRvby5cbiAgICBzZXR1cFByb3BlcnRpZXMoKXtcbiAgICAgICAgLy8gSGVyZSwgd2Ugc2V0IHVwIHByb3BlcnRpZXMgY29tbW9uXG4gICAgICAgIC8vIHRvIEFMTCBQYXJ0cyBpbiB0aGUgc3lzdGVtLlxuICAgICAgICBsZXQgYmFzaWNQcm9wcyA9IFtcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICd0YXJnZXQnLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ2NvbnRlbnRzJyxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ3dhbnRzLW1vdmUnLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAgICAgICBpZE1ha2VyLm5ldygpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgIGBOZXcgJHt0aGlzLnR5cGV9YFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdyZWN0YW5nbGUnLFxuICAgICAgICAgICAgICAgIFwiMCwgMCwgMCwgMFwiLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgWydyZWN0J11cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAgICAgICAgICBudWxsIC8vIEZvciBub3dcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIC8vIFN0eWxpbmdcbiAgICAgICAgICAgIC8vIGNzcyAocmVhbGx5IEpTIHN0eWxlKSBrZXktdmFsdWVzXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnY3NzU3R5bGUnLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC8vIGNzcyAocmVhbGx5IEpTIHN0eWxlKSBrZXktdmFsdWVzXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnY3NzVGV4dFN0eWxlJyxcbiAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICAgICAgYmFzaWNQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5hZGRQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhlIGluZGV4IG51bWJlciBvZiB0aGUgcGFydCBpbiBwYXJ0Ll9vd25lci5zdWJwYXJ0XG4gICAgICAgIC8vIGFycmF5LiBOb3RlOiB0aGlzIGlzIDEtaW5kZXhlZFxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICBudWxsLCAvLyBubyBzZXR0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICAgICAgaWYocHJvcE93bmVyLnR5cGUgPT0gXCJ3b3JsZFwiKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wT3duZXIuX293bmVyLnN1YnBhcnRzLmluZGV4T2YocHJvcE93bmVyKSArIDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1ZSAvLyByZWFkb25seVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAndGFyZ2V0JyxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsKXtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHRhcmdldCBpcyBhIG5vbi1JRFxuICAgICAgICAgICAgICAgIGxldCBpZCA9IGlzVmFsaWRJZCh2YWwpO1xuICAgICAgICAgICAgICAgIGlmKGlkKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgYW4gSUQgaW5zZXJ0IFwicGFydFwiIHNpbmNlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBncmFtbWFyIGRvZXNuJ3QgaGFuZGxlIElEIHdpdGhvdXQgc3lzdGVtIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVmaXhlc1xuICAgICAgICAgICAgICAgICAgICBwcm9wT2JqZWN0Ll92YWx1ZSA9IGBwYXJ0IGlkICR7dmFsfWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE9iamVjdC5fdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BPYmplY3QuX3ZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgKSxcblxuICAgICAgICAvLyBDdXN0b20gUHJvcGVydGllcyBzdG9yZSBwcm9wcyBkZWZpbmVkIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gU1QgZW52aXJvbm1lbnRcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdDdXN0b21Qcm9wKFxuICAgICAgICApLFxuXG4gICAgICAgIC8vIFN0ZXBwaW5nIHJlbGF0ZWQgcHJvcHNcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgLy8gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGJldHdlZW5cbiAgICAgICAgICAgIC8vIHNlbmRzIG9mIHRoZSBzdGVwIGNvbW1hbmQgaWYgdGhlXG4gICAgICAgICAgICAvLyBzdGVwcGluZyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgJ3N0ZXBUaW1lJyxcbiAgICAgICAgICAgIC8vIER5bmFtaWMgc2V0dGVyXG4gICAgICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3QsIHZhbHVlKXtcbiAgICAgICAgICAgICAgICBpZihwcm9wT3duZXIuaXNTdGVwcGluZyl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVycnVwdCB0aGUgY3VycmVudCBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmVzdGFydCB3aXRoIG5ldyBzdGVwVGltZVxuICAgICAgICAgICAgICAgICAgICBwcm9wT3duZXIuc3RvcFN0ZXBwaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHByb3BPd25lci5zdGFydFN0ZXBwaW5nKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBEeW5hbWljIGdldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2UsIC8vIGNhbiByZWFkIGFuZCB3cml0ZVxuICAgICAgICAgICAgNTAwIC8vIERlZmF1bHQgdG8gaGFsZiBhIHNlY29uZFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAnc3RlcHBpbmcnLFxuICAgICAgICAgICAgLy8gRHluYW1pYyBzZXR0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsdWUpe1xuICAgICAgICAgICAgICAgIGlmKHZhbHVlID09PSBmYWxzZSAmJiBwcm9wT3duZXIuaXNTdGVwcGluZyl7XG4gICAgICAgICAgICAgICAgICAgIHByb3BPd25lci5zdG9wU3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT09IHRydWUgJiYgIXByb3BPd25lci5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnN0YXJ0U3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRHluYW1pYyBnZXR0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGludGVydmFsSWQgaXMgc2V0LCB0aGVuXG4gICAgICAgICAgICAgICAgLy8gdGhlIFBhcnQgaXMgY3VycmVudGx5IHN0ZXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BPd25lci5pc1N0ZXBwaW5nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIC8vIFRvIGJlIGNhbGxlZCBpbiBlYWNoIHN1Yi1jbGFzcyB0aGF0IGhhcyBTdHlsZVByb3BlcnRpZXNcbiAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHN0eWxlIHByb3BzIGFyZSBjb25maWd1cmVkXG4gICAgc2V0dXBTdHlsZVByb3BlcnRpZXMoKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5fcHJvcGVydGllcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZihwcm9wLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiU3R5bGVQcm9wZXJ0eVwiKXtcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSB2YWx1ZSBvbiBpdHNlbGYgZW5zdXJlcyB0aGF0IHRoZSBjc3NTdHlsZVxuICAgICAgICAgICAgICAgIC8vIEJhc2ljUHJvcGVydHkgaXMgdXBkYXRlZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBzdHlsZXJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJzaW9uIGNzcyBrZXktdmFsXG4gICAgICAgICAgICAgICAgcHJvcC5zZXRWYWx1ZSh0aGlzLCBwcm9wLl92YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBTdWJwYXJ0IEFjY2VzcyAqKi9cbiAgICAvKipcbiAgICAgKiBFYWNoIHN1YmNsYXNzIHdpbGwgaW1wbGVtZW50IGl0cyBvd24gc2V0IG9mIGNoZWNrcyxcbiAgICAgKiBhbmQgdGhyb3cgYW4gYXBwcm9wcml0ZSBlcnJvciBpZiB0aGUgc3VicGFydCB0eXBlIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgYWNjZXB0c1N1YnBhcnQoYVBhcnRUeXBlKXtcbiAgICAgICAgaWYgKHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXNbMF0gPT09IFwiKlwiKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzLmluY2x1ZGVzKGFQYXJ0VHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcGFydCB0byB0aGlzIHBhcnQncyBzdWJwYXJ0c1xuICAgICAqIGNvbGxlY3Rpb24sIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gICAgICogSXQgd2lsbCBhbHNvIHNldCB0aGUgb3duZXIgb2YgdGhlXG4gICAgICogYWRkZWQgcGFydCB0byBiZSB0aGlzIHBhcnQuXG4gICAgICovXG4gICAgYWRkUGFydChhUGFydCl7XG4gICAgICAgIGlmKCF0aGlzLmFjY2VwdHNTdWJwYXJ0KGFQYXJ0LnR5cGUpKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLnR5cGV9IGRvZXMgbm90IGFjY2VwdCBzdWJwYXJ0cyBvZiB0eXBlICR7YVBhcnQudHlwZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihhUGFydCk7XG4gICAgICAgIGlmKGZvdW5kIDwgMCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICAgICAgYVBhcnQuX293bmVyID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIHBhcnQgZnJvbSB0aGlzXG4gICAgICogcGFydCdzIGxpc3Qgb2Ygc3VicGFydHMgKGlmIHByZXNlbnQpLlxuICAgICAqIEl0IHdpbGwgYWxzbyB1bnNldCB0aGUgb3duZXIgb2YgdGhlXG4gICAgICogZ2l2ZW4gcGFydC5cbiAgICAgKi9cbiAgICByZW1vdmVQYXJ0KGFQYXJ0KXtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihhUGFydCk7XG4gICAgICAgIGlmKHBhcnRJbmRleCA+PSAwKXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydHMuc3BsaWNlKHBhcnRJbmRleCwgMSk7XG4gICAgICAgICAgICBhUGFydC5fb3duZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBQYXJ0IGluc3RhbmNlIGlzIGEgc3VicGFydCBvZiB0aGUgY3VycmVudFxuICAgICAqIENhcmQuXG4gICAgICovXG4gICAgaXNTdWJwYXJ0T2ZDdXJyZW50Q2FyZCgpe1xuICAgIH1cblxuICAgIC8qKiBDaGVja3Mgd2hldGhlciB0aGUgUGFydCBpbnN0YW5jZSBpcyBhIHN1YnBhcnQgb2YgdGhlIGN1cnJlbnRcbiAgICAgKiBTdGFjay5cbiAgICAgKi9cbiAgICBpc1N1YnBhcnRPZkN1cnJlbnRTdGFjaygpe1xuICAgIH1cblxuICAgIC8qKiBMb2dnaW5nIGFuZCBSZXBvcnRpbmcgKiovXG4gICAgc2hvdWxkQmVJbXBsZW1lbnRlZChmdW5jdGlvbk5hbWUpe1xuICAgICAgICBsZXQgbXNnID0gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBzaG91bGQgaW1wbGVtZW50ICR7ZnVuY3Rpb25OYW1lfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIC8qKiBNZXNzYWdlIEhhbmRsaW5nIGFuZCBEZWxlZ2F0aW9uICoqL1xuICAgIGRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSl7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICB0aGlzLl9vd25lclxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0YXJnZXQpe1xuICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5zZW5kTWVzc2FnZShhTWVzc2FnZSwgdGhpcywgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWNlaXZlTWVzc2FnZShhTWVzc2FnZSl7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIFBhcnRzIHdpbGwgb25seSBoYW5kbGVcbiAgICAgICAgLy8gbWVzc2FnZXMgb2YgdHlwZSAnY29tbWFuZCcgYW5kICdmdW5jdGlvbidcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAnY29tbWFuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNtZChhTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy9icmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlRnVuYyhhTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy9icmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlRXJyb3IoYU1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZU1lc3NhZ2UoYU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVjZWl2ZUVycm9yKGFNZXNzYWdlKXtcbiAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlci5oYW5kbGUoYU1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJlY2VpdmVDbWQoYU1lc3NhZ2Upe1xuICAgICAgICBsZXQgaGFuZGxlciA9IHRoaXMuX2NvbW1hbmRIYW5kbGVyc1thTWVzc2FnZS5jb21tYW5kTmFtZV07XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBQYXJ0IGhhcyBhIGhhbmRsZXIgZm9yXG4gICAgICAgICAgICAvLyB0aGUgZ2l2ZW4gY29tbWFuZCwgd2UgcnVuIGl0LlxuICAgICAgICAgICAgLy8gV2UgYWxzbyBsYXRlLWJpbmQgdGhlIGN1cnJlbnQgcGFydFxuICAgICAgICAgICAgLy8gaW5zdGFuY2UgYXMgdGhlICd0aGlzJyBjb250ZXh0IGZvclxuICAgICAgICAgICAgLy8gdGhlIGhhbmRsZXJcbiAgICAgICAgICAgIGxldCBib3VuZEhhbmRsZXIgPSBoYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB2YXIgYWN0aXZhdGlvbiA9IG5ldyBBY3RpdmF0aW9uQ29udGV4dChcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS5jb21tYW5kTmFtZSxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGJvdW5kSGFuZGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucHVzaChhY3RpdmF0aW9uKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBib3VuZEhhbmRsZXIoYU1lc3NhZ2Uuc2VuZGVycywgLi4uYU1lc3NhZ2UuYXJncyk7XG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcml2YXRlSGFuZGxlciA9IHRoaXMuX3ByaXZhdGVDb21tYW5kSGFuZGxlcnNbYU1lc3NhZ2UuY29tbWFuZE5hbWVdO1xuICAgICAgICBpZihwcml2YXRlSGFuZGxlcil7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIFBhcnQgaGFzIGEgaGFuZGxlciBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBnaXZlbiBjb21tYW5kLCB3ZSBydW4gaXQuXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGxhdGUtYmluZCB0aGUgY3VycmVudCBwYXJ0XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSBhcyB0aGUgJ3RoaXMnIGNvbnRleHQgZm9yXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlclxuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IHByaXZhdGVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB2YXIgYWN0aXZhdGlvbiA9IG5ldyBBY3RpdmF0aW9uQ29udGV4dChcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS5jb21tYW5kTmFtZSxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGJvdW5kSGFuZGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucHVzaChhY3RpdmF0aW9uKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBib3VuZEhhbmRsZXIoYU1lc3NhZ2Uuc2VuZGVycywgLi4uYU1lc3NhZ2UuYXJncyk7XG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmV4ZWN1dGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgaGF2ZSBubyBoYW5kbGVyIGZvclxuICAgICAgICAvLyBpdC4gVW5sZXNzIHRoZSBtZXNzYWdlIGluZGljYXRlcyBzaG91bGROb3REZWxlZ2F0ZVxuICAgICAgICAvLyB3ZSBkZWxlZ2F0ZSBhbG9uZyB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSBkZWxlZ2F0aW9uIGNoYWluLiBJdCBpcyB1cFxuICAgICAgICAvLyB0byBQYXJ0cyB0byBwcm9wZXJseSBpbXBsZW1lbnQgZGVsZWdhdGlvblxuICAgICAgICAvLyBmb3IgdGhlbXNlbHZlcyFcbiAgICAgICAgaWYoYU1lc3NhZ2Uuc2hvdWxkTm90RGVsZWdhdGUpe1xuICAgICAgICAgICAgcmV0dXJuIGFNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmVjZWl2ZUZ1bmMoYU1lc3NhZ2Upe1xuICAgICAgICBsZXQgaGFuZGxlciA9IHRoaXMuX2Z1bmN0aW9uSGFuZGxlcnNbYU1lc3NhZ2UuZnVuY3Rpb25OYW1lXTtcblxuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICAgIGxldCBib3VuZEhhbmRsZXIgPSBoYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRIYW5kbGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZU1lc3NhZ2UoYU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKGNvbW1hbmROYW1lLCBoYW5kbGVyKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZUNvbW1hbmRIYW5kbGVyc1tjb21tYW5kTmFtZV0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIHJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihjb21tYW5kTmFtZSl7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcml2YXRlQ29tbWFuZEhhbmRsZXJzW2NvbW1hbmROYW1lXTtcbiAgICB9XG5cbiAgICBzZXRGdW5jSGFuZGxlcihmdW5jTmFtZSwgaGFuZGxlcil7XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uSGFuZGxlcnNbZnVuY05hbWVdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICAvKiogQ29tbWFuZCBIYW5kbGVyc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIENvbW1hbmQgaGFuZGxlcnMgd2hpY2ggYXJlIGludm9rZWQgYXQgdGhlIFBhcnQgbGV2ZWxcbiAgICAgICAgd2hpY2ggYXJlIG5vdCBpbW1lZGlhdGVseSBkZWxlZ2FlZCB0byB0aGUgUGFydC5fb3duZXJcbiAgICAqKi9cblxuICAgIG9wZW5FZGl0b3JDbWRIYW5kbGVyKCl7XG4gICAgICAgIGxldCBlZGl0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1lZGl0b3InKTtcbiAgICAgICAgZWRpdG9yLnJlbmRlcih0aGlzKTtcbiAgICAgICAgaWYoIWVkaXRvci5pc09wZW4pe1xuICAgICAgICAgICAgZWRpdG9yLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlRWRpdG9yQ21kSGFuZGxlcigpe1xuICAgICAgICBsZXQgZWRpdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtZWRpdG9yLm9wZW4nKTtcbiAgICAgICAgaWYoZWRpdG9yKXtcbiAgICAgICAgICAgIGVkaXRvci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGFyZ2V0UHJvcChzZW5kZXJzLCAuLi5hcmdzKXtcbiAgICAgICAgbGV0IHRhcmdldCA9IGFyZ3Muam9pbihcIiBcIik7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIGNvcHlDbWRIYW5kbGVyKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLmNvcHlQYXJ0KHRoaXMpO1xuICAgIH1cblxuICAgIHBhc3RlQ21kSGFuZGxlcigpe1xuICAgICAgICBpZighd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuaXNFbXB0eSl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLmNvbnRlbnRzWzBdO1xuICAgICAgICAgICAgaWYoaXRlbS50eXBlID09ICdzaW1wbGV0YWxrL2pzb24nICYmIHRoaXMuYWNjZXB0c1N1YnBhcnQoaXRlbS5wYXJ0VHlwZSkpe1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLnBhc3RlQ29udGVudHNJbnRvKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZShzZW5kZXJzLCBtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIGlmKCF0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJ3YW50cy1tb3ZlXCIpKXtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBQYXJ0ICR7dGhpcy5pZH0gdHJ5aW5nIHRvIG1vdmUgd2l0aCAnd2FudHMtbW92ZScgcHJvcGVydHkgZmFsc2VgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9wID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwidG9wXCIpO1xuICAgICAgICB0b3AgKz0gbW92ZW1lbnRZO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJ0b3BcIiwgdG9wKTtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJsZWZ0XCIpO1xuICAgICAgICBsZWZ0ICs9IG1vdmVtZW50WDtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwibGVmdFwiLCBsZWZ0KTtcbiAgICB9XG5cbiAgICBtb3ZlU3VicGFydERvd24ocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VXAocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA+IDApe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgY3VycmVudEluZGV4IC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RlOiBtb3ZlU3VicGFydFRvRmlyc3QgbWVhbnMgbW92ZSB0byBmaXJzdCBpbiB0aGUgdmlld1xuICAgIC8vIGkuZS4gbGFzdCBhcyBhIHN1YmFwcnRcbiAgICBtb3ZlU3VicGFydFRvRmlyc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIDApO1xuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VG9MYXN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCB0aGlzLnN1YnBhcnRzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8qKiBQcm9wZXJ0eSBTdWJzY3JpYmVyc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgT2JqZWN0cyBhZGRlZCBhcyBwcm9wZXJ0eSBzdWJzY3JpYmVyc1xuICAgICAgICB3aWxsIGJlICdub3RpZmllZCcgd2hlbmV2ZXIgb25lIG9mIHRoaXNcbiAgICAgICAgUGFydCdzIHByb3BlcnRpZXMgY2hhbmdlc1xuICAgICoqL1xuICAgIGFkZFByb3BlcnR5U3Vic2NyaWJlcihhbk9iamVjdCl7XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5U3Vic2NyaWJlcnMuYWRkKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICByZW1vdmVQcm9wZXJ0eVN1YnNjcmliZXIoYW5PYmplY3Qpe1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eVN1YnNjcmliZXJzLmRlbGV0ZShhbk9iamVjdCk7XG4gICAgfVxuXG4gICAgcHJvcGVydHlDaGFuZ2VkKHByb3BlcnR5TmFtZSwgbmV3VmFsdWUpe1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdwcm9wZXJ0eUNoYW5nZWQnLFxuICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBwYXJ0SWQ6IHRoaXMuaWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJvcGVydHlTdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShtZXNzYWdlLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFZpZXcgU3Vic2NyaWJlcnNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIE9iamVjdHMgYWRkZWQgYXMgdmlldyBzdWJzY3JpYmVyc1xuICAgICAgICB3aWxsIGJlICdub3RpZmllZCcgd2hlbmV2ZXIgdGhpcyBQYXJ0XG4gICAgICAgIGluY3VycnMgYSB2aWV3IGNoYW5nZSAoYWRkLCBkZWxldGUgc3VicGFydHMsIHJlb3JkZXIgZXRjKVxuICAgICoqL1xuICAgIGFkZFZpZXdTdWJzY3JpYmVyKGFuT2JqZWN0KXtcbiAgICAgICAgdGhpcy5fdmlld1N1YnNjcmliZXJzLmFkZChhbk9iamVjdCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlVmlld1N1YnNjcmliZXIoYW5PYmplY3Qpe1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMuZGVsZXRlKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICB2aWV3Q2hhbmdlZChjaGFuZ2VOYW1lLCAuLi5hcmdzKXtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAndmlld0NoYW5nZWQnLFxuICAgICAgICAgICAgY2hhbmdlTmFtZTogY2hhbmdlTmFtZSxcbiAgICAgICAgICAgIHBhcnRJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdmlld1N1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2UsIHN1YnNjcmliZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdWJwYXJ0T3JkZXJDaGFuZ2VkKGlkLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4KXtcbiAgICAgICAgbGV0IHN1YnBhcnQgPSB0aGlzLnN1YnBhcnRzLnNwbGljZShjdXJyZW50SW5kZXgsIDEpWzBdO1xuICAgICAgICB0aGlzLnN1YnBhcnRzLnNwbGljZShuZXdJbmRleCwgMCwgc3VicGFydCk7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZWQoXCJzdWJwYXJ0LW9yZGVyXCIsIGlkLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4KTtcbiAgICB9XG5cbiAgICBzdGFydFN0ZXBwaW5nKCl7XG4gICAgICAgIGlmKHRoaXMuX3N0ZXBJbnRlcnZhbElkKXtcbiAgICAgICAgICAgIHRoaXMuc3RvcFN0ZXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0ZXBUaW1lID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdzdGVwVGltZSdcbiAgICAgICAgKTtcbiAgICAgICAgaWYoc3RlcFRpbWUgPiAwKXtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXBJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnc3RlcCcsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LCBzdGVwVGltZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wU3RlcHBpbmcoKXtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9zdGVwSW50ZXJ2YWxJZCk7XG4gICAgICAgIHRoaXMuX3N0ZXBJbnRlcnZhbElkID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgaXNTdGVwcGluZygpe1xuICAgICAgICAvLyBXZSBrbm93IHRoZSBQYXJ0IGlzIGN1cnJlbnRseSBzdGVwcGluZ1xuICAgICAgICAvLyBvZiB0aGUgc3RvcmVkIGludGVydmFsSWQgaXMgc2V0IHRvXG4gICAgICAgIC8vIHNvbWV0aGluZyBiZXNpZGVzIG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBJbnRlcnZhbElkICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGlzIFBhcnQncyBzdGF0ZSBhcyBKU09OLlxuICAgICAqIEJ5IGRlZmF1bHQsIHdlIGRvIG5vdCBzZXJpYWxpemUgc3BlY2lmaWNcbiAgICAgKiBQYXJ0Q29sbGVjdGlvbiBpbmZvcm1hdGlvbiAocmVjdXJzaXZlbHkpLFxuICAgICAqIGFuZCBvbmx5IGluY2x1ZGUgYmFzaWNzIGluY2x1ZGluZyB0aGUgY3VycmVudFxuICAgICAqIHN0YXRlIG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpe1xuICAgICAgICBsZXQgb3duZXJJZCA9IG51bGw7XG4gICAgICAgIGlmKHRoaXMuX293bmVyKXtcbiAgICAgICAgICAgIG93bmVySWQgPSB0aGlzLl9vd25lci5pZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgIHN1YnBhcnRzOiB0aGlzLnN1YnBhcnRzLm1hcChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC5pZDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3duZXJJZDogb3duZXJJZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLl9wcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AuZ2V0VmFsdWUodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHByb3BlcnRpZXMgYW5kIG90aGVyXG4gICAgICogYXR0cmlidXRlcyBvZiB0aGlzIFBhcnQgbW9kZWxcbiAgICAgKiBmcm9tIGEgZGVzZXJpYWxpemVkIEpTT04gb2JqZWN0LlxuICAgICAqL1xuICAgIHNldFByb3BzRnJvbURlc2VyaWFsaXplcihpbmNvbWluZ1Byb3BzLCBkZXNlcmlhbGl6ZXIpe1xuICAgICAgICBPYmplY3Qua2V5cyhpbmNvbWluZ1Byb3BzKS5mb3JFYWNoKHByb3BOYW1lID0+IHtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IHRoaXMucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUpO1xuICAgICAgICAgICAgaWYoIXByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICAvLyBJZiBzb21lIG9sZCBvciBpbnZhbGlkIHByb3BlcnR5IGlzXG4gICAgICAgICAgICAgICAgLy8gcHJlc2VudCBpbiB0aGUgZGVzZXJpYWxpemF0aW9uLCBzaW1wbHkgcHJvdmlkZVxuICAgICAgICAgICAgICAgIC8vIGEgd2FybmluZyBhbmQgdGhlbiBza2lwIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVzZXJpYWxpemVkIHByb3BlcnR5IFwiJHtwcm9wTmFtZX1cIiBpcyBub3QgYSB2YWxpZCBwcm9wZXJ0eSBuYW1lIGZvciAke3RoaXMudHlwZX0gKGlkICR7dGhpcy5pZH0pIGFuZCB3aWxsIGJlIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wTmFtZSA9PSBcImN1c3RvbS1wcm9wZXJ0aWVzXCIpe1xuICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBwcm9wZXJ0aWVzIGFyZSBzZXJpYWxpemVkIGFzIGFuIG9iamVjdCBsaWtlIG90aGVyIHByb3BzXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHByb3BlcnRpZXMgZnJvbSB0aGVzZSBhbmQgc2V0IHRoZWlyIHJlc3BlY3RpdmVcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMuIFRoZW4gd2UgbmVlZCB0byBzZXQgdGhlIHZhbHVlIG9mIFwiY3VzdG9tLXByb3BlcnRpZXNcIiBwcm9wXG4gICAgICAgICAgICAgICAgLy8gaXRzZWxmIHRvIGJlIHRoZSBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlc2VcbiAgICAgICAgICAgICAgICBsZXQgY3VzdG9tUHJvcHNEYXRhID0gaW5jb21pbmdQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0N1c3RvbVByb3BzT2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhjdXN0b21Qcm9wc0RhdGEpLmZvckVhY2goKHByb3BEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdQcm9wID0gbmV3IEJhc2ljUHJvcGVydHkocHJvcERhdGEubmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3Auc2V0VmFsdWUodGhpcywgcHJvcERhdGEuX3ZhbHVlLCBmYWxzZSk7IC8vIG5vIG5lZWQgdG8gbm90aWZ5XG4gICAgICAgICAgICAgICAgICAgIG5ld0N1c3RvbVByb3BzT2JqZWN0W3Byb3BEYXRhLm5hbWVdID0gbmV3UHJvcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5zZXRWYWx1ZSh0aGlzLCBuZXdDdXN0b21Qcm9wc09iamVjdCwgZmFsc2UpOyAvLyBubyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgfSBlbHNlIGlmKCFwcm9wZXJ0eS5yZWFkT25seSl7XG4gICAgICAgICAgICAgICAgLy8gTGFzdCBhcmcgaXMgZmFsc2UsIHdoaWNoIHRlbGxzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5vdCB0byBub3RpZnkgaXRzIG93bmVyJ3Mgc3Vic2NyaWJlcnMgb2ZcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBjaGFuZ2VzLiBXZSBkb24ndCBuZWVkIHRoYXQgd2hlblxuICAgICAgICAgICAgICAgIC8vIGRlc2VyaWFsaXppbmdcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5zZXRWYWx1ZSh0aGlzLCBpbmNvbWluZ1Byb3BzW3Byb3BOYW1lXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0b0pTT04oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgfVxuXG4gICAgZmluZEFuY2VzdG9yT2ZUeXBlKGFQYXJ0VHlwZSl7XG4gICAgICAgIGxldCBvd25lciA9IHRoaXMuX293bmVyO1xuICAgICAgICB3aGlsZShvd25lcil7XG4gICAgICAgICAgICBpZihvd25lci50eXBlID09IGFQYXJ0VHlwZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG93bmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3duZXIgPSBvd25lci5fb3duZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBQYXJ0LFxuICAgIFBhcnQgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCB7UGFydH0gZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRUZXh0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBSZXNvdXJjZSBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBzcmMpIHtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuICAgICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNyYyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVhZHlTdGF0ZScsXG4gICAgICAgICAgICBcIm5vdFJlYWR5XCJcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwicHJlcmVxdWlzaXRlXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInJlc291cmNlTmFtZVwiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFByaXZhdGUgY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImxvYWRSZXNvdXJjZVwiLCB0aGlzLmxvYWRSZXNvdXJjZSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwic2V0U291cmNlVG9cIiwgdGhpcy5zZXRTb3VyY2VUbyk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiZ2V0XCIsIHRoaXMuZ2V0KTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMubG9hZFJlc291cmNlID0gdGhpcy5sb2FkUmVzb3VyY2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0ID0gdGhpcy5yZXNldC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIGxvYWQgdGhlIHNyYyBpZiBwcm92aWRlZFxuICAgICAgICBpZihzcmMpe1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3R5bGUgcHJvcGVydGllc1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkVGV4dFN0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIFtcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiXS5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c2lkZX0td2lkdGhgLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAncmVzb3VyY2UnO1xuICAgIH1cblxuICAgIGxvYWRSZXNvdXJjZShzZW5kZXJzLCByZXNvdXJjZU5hbWUpe1xuICAgICAgICBpZighd2luZG93LlN5c3RlbS5hdmFpbGFibGVSZXNvdXJjZXMgfHwgIXdpbmRvdy5TeXN0ZW0uYXZhaWxhYmxlUmVzb3VyY2VzW3Jlc291cmNlTmFtZV0pe1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgcmVzb3VyY2UgJHtyZXNvdXJjZU5hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSB3aW5kb3cuU3lzdGVtLmF2YWlsYWJsZVJlc291cmNlc1tyZXNvdXJjZU5hbWVdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZXNvdXJjZU5hbWVcIiwgcmVzb3VyY2VOYW1lKTtcbiAgICAgICAgLy8gd2UgY2FuJ3QgZ3VhcmFudGVlIHRoZSBzdGF0ZSBvZiBhIHJlc291cmNlIGFuZCBzbyBpdCBzaG91bGQgYmUgcmUtc2V0IGV2ZXJ5IHRpbWVcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHNldFNvdXJjZVRvKHNlbmRlcnMsIHNvdXJjZVVybCl7XG4gICAgICAgIGlmKCF0aGlzLnJlc291cmNlKXtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgYSBTVCBlcnJvclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYG5vIHJlc291cmNlIGxvYWRlZCBmb3IgcmVzb3VyY2UgcGFydCBpZCAke3RoaXMuaWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHNvdXJjZVVybCk7XG4gICAgICAgIHRoaXMucmVzb3VyY2UubG9hZChzb3VyY2VVcmwpO1xuICAgICAgICAvLyB3ZSBjYW4ndCBndWFyYW50ZWUgdGhlIHN0YXRlIG9mIGEgcmVzb3VyY2UgYW5kIHNvIGl0IHNob3VsZCBiZSByZS1zZXQgZXZlcnkgdGltZVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICB9XG5cbiAgICBnZXQoc2VuZGVycywgLi4uYXJncyl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlYWR5U3RhdGVcIiwgXCJmZXRjaGluZ1wiKTtcbiAgICAgICAgbGV0IHByZXJlcXVpc2l0ZSA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInByZXJlcXVpc2l0ZVwiKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZS5nZXQocHJlcmVxdWlzaXRlLCAuLi5hcmdzKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVhZHlTdGF0ZVwiLCBcInJlYWR5XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwicmVzcG9uZGVkXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW3RoaXMuaWQsIHRoaXMucmVzb3VyY2UubmFtZV0sXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZWFkeVN0YXRlXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZXNwb25zZVwiLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImVycm9yZWRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5pZCwgdGhpcy5yZXNvdXJjZS5uYW1lLCBlcnJvci5tZXNzYWdlXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNldCgpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZWFkeVN0YXRlXCIsIFwibm90UmVhZHlcIik7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlc3BvbnNlXCIsIG51bGwpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgUmVzb3VyY2UsXG4gICAgUmVzb3VyY2UgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogU3RhY2tcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gdGhlIFN0YWNrIFBhcnQuXG4gKiBJIHJlcHJlc2VudCBhIGNvbGxlY3Rpb24gb2YgQ2FyZCBwYXJ0cyxcbiAqIGFsb25nIHdpdGggc29tZSBleHRyYSBjb25maWd1cmFiaWxpdHkuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQuanMnO1xuaW1wb3J0IHtcbiAgICBCYXNpY1Byb3BlcnR5XG59IGZyb20gJy4uL3Byb3BlcnRpZXMvUGFydFByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBTdGFjayBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBuYW1lLCBkZXNlcmlhbGl6aW5nPWZhbHNlKXtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuICAgICAgICB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzID0gW1xuICAgICAgICAgICAgXCJjYXJkXCIsIFwid2luZG93XCIsIFwiYnV0dG9uXCIsIFwiYXJlYVwiLCBcImZpZWxkXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdcIiwgXCJpbWFnZVwiLCBcImF1ZGlvXCIsIFwiYnJvd3NlclwiXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gU2V0IHVwIFN0YWNrIHNwZWNpZmljXG4gICAgICAgIC8vIFBhcnRQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2NhbnRQZWVrJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3Jlc2l6YWJsZScsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG5cbiAgICAgICAgLy8gV2lsbCBob2xkIHRoZSBjYXJkLWJhc2VkIGluZGV4LFxuICAgICAgICAvLyB3aGljaCBoZXJlIGlzIHplcm8taW5kZXhlZCwgb2YgdGhlXG4gICAgICAgIC8vIGNhcmQgdGhhdCBpcyB0aGUgY3VycmVudCBjYXJkIGZvciB0aGlzXG4gICAgICAgIC8vIFN0YWNrLlxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIGdlbmVyYWwgbWV0aG9kc1xuICAgICAgICB0aGlzLnNlbmRPcGVuQ2FyZFRvID0gdGhpcy5zZW5kT3BlbkNhcmRUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRDbG9zZUNhcmRUbyA9IHRoaXMuc2VuZENsb3NlQ2FyZFRvLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBzdGFjayBuYXZpZ2F0aW9uIG1ldGhvZHNcbiAgICAgICAgdGhpcy5nb1RvTmV4dENhcmQgPSB0aGlzLmdvVG9OZXh0Q2FyZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdvVG9QcmV2Q2FyZCA9IHRoaXMuZ29Ub1ByZXZDYXJkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub0NhcmRCeUlkID0gdGhpcy5nb1RvQ2FyZEJ5SWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvTnRoQ2FyZCA9IHRoaXMuZ29Ub050aENhcmQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnb1RvTmV4dENhcmQoKXtcbiAgICAgICAgbGV0IGNhcmRzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdjYXJkJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGNhcmRzLmxlbmd0aCA8IDIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZElkID0gdGhpcy5jdXJyZW50Q2FyZElkO1xuICAgICAgICBsZXQgY3VycmVudENhcmQgPSB0aGlzLmN1cnJlbnRDYXJkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IGNhcmRzLmluZGV4T2YoY3VycmVudENhcmQpO1xuICAgICAgICBsZXQgbmV4dElkeCA9IGN1cnJlbnRJZHggKyAxO1xuICAgICAgICBpZihuZXh0SWR4ID49IGNhcmRzLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0SWR4ID0gKG5leHRJZHggJSBjYXJkcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0Q2FyZCA9IGNhcmRzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dENhcmQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYoY3VycmVudENhcmRJZCAhPSBuZXh0Q2FyZC5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZUNhcmRUbyhjdXJyZW50Q2FyZCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuQ2FyZFRvKG5leHRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9DYXJkQnlJZChhbklkKXtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBjYXJkcyA9IE9iamVjdC52YWx1ZXMod2luZG93LlN5c3RlbS5wYXJ0c0J5SWQpLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBuZXh0Q2FyZCA9IGNhcmRzLmZpbmQoY2FyZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FyZC5pZCA9PSBhbklkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoIW5leHRDYXJkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNhcmQgaWQ6ICR7YW5JZH0gY2FudCBiZSBmb3VuZCBzdGFja2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBjYXJkIGlzIG5vdCBvbiB0aGlzIHN0YWNrIHdlIHNob3VsZCBnbyB0byB0aGUgY29ycmVzcG9uZGluZyBzdGFja1xuICAgICAgICBpZihuZXh0Q2FyZC5fb3duZXIgIT0gdGhpcyl7XG4gICAgICAgICAgICB0aGlzLl9vd25lci5nb1RvU3RhY2tCeUlkKG5leHRDYXJkLl9vd25lci5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG5leHRDYXJkLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRDYXJkSWQgIT0gbmV4dENhcmQuaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VDYXJkVG8oY3VycmVudENhcmQpO1xuICAgICAgICAgICAgdGhpcy5zZW5kT3BlbkNhcmRUbyhuZXh0Q2FyZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvUHJldkNhcmQoKXtcbiAgICAgICAgbGV0IGNhcmRzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdjYXJkJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGNhcmRzLmxlbmd0aCA8IDIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZElkID0gdGhpcy5jdXJyZW50Q2FyZElkO1xuICAgICAgICBsZXQgY3VycmVudENhcmQgPSB0aGlzLmN1cnJlbnRDYXJkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IGNhcmRzLmluZGV4T2YoY3VycmVudENhcmQpO1xuXG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCAtIDE7XG4gICAgICAgIGlmKG5leHRJZHggPCAwKXtcbiAgICAgICAgICAgIG5leHRJZHggPSBjYXJkcy5sZW5ndGggKyBuZXh0SWR4O1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0Q2FyZCA9IGNhcmRzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dENhcmQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYoY3VycmVudENhcmRJZCAhPSBuZXh0Q2FyZC5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZUNhcmRUbyhjdXJyZW50Q2FyZCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuQ2FyZFRvKG5leHRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9OdGhDYXJkKGFuSW5kZXgpe1xuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgdXNpbmcgMS1pbmRleGVkIHZhbHVlc1xuICAgICAgICAvLyBwZXIgdGhlIFNpbXBsZVRhbGsgc3lzdGVtXG4gICAgICAgIGxldCB0cnVlSW5kZXggPSBhbkluZGV4IC0gMTtcbiAgICAgICAgbGV0IGNhcmRzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdjYXJkJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKHRydWVJbmRleCA8IDAgfHwgdHJ1ZUluZGV4ID4gY2FyZHMubGVuZ3RoIC0xKXtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IG5hdmlnYXRlIHRvIGNhcmQgbnVtYmVyICR7YW5JbmRleH0gLS0gb3V0IG9mIGJvdW5kc2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZElkID0gdGhpcy5jdXJyZW50Q2FyZElkO1xuICAgICAgICBsZXQgY3VycmVudENhcmQgPSB0aGlzLmN1cnJlbnRDYXJkO1xuICAgICAgICBsZXQgbmV4dENhcmQgPSBjYXJkc1t0cnVlSW5kZXhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICBuZXh0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50Q2FyZElkICE9IG5leHRDYXJkLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvKGN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8obmV4dENhcmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VuZENsb3NlQ2FyZFRvKGFDYXJkKXtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbG9zZUNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFDYXJkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2VuZE9wZW5DYXJkVG8oYUNhcmQpe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5DYXJkJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhQ2FyZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnc3RhY2snO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50Q2FyZElkKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRDYXJkKCl7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFt0aGlzLmN1cnJlbnRDYXJkSWRdO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHRoZSBiYXNlIGNsYXNzIG1ldGhvZHNcbiAgICBtb3ZlU3VicGFydERvd24ocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBsYXN0VmFsaWRQYXJ0SW5kZXggPSB0aGlzLnN1YnBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKHBhcnQudHlwZSA9PSBcImNhcmRcIil7XG4gICAgICAgICAgICBsZXQgYWxsQ2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RWYWxpZFBhcnRJbmRleCA9IGFsbENhcmRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbGFzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0xhc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBsYXN0VmFsaWRQYXJ0SW5kZXggPSB0aGlzLnN1YnBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKHBhcnQudHlwZSA9PSBcImNhcmRcIil7XG4gICAgICAgICAgICBsZXQgYWxsQ2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RWYWxpZFBhcnRJbmRleCA9IGFsbENhcmRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbGFzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGxhc3RWYWxpZFBhcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlU3VicGFydFVwKHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgZmlyc3RWYWxpZFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmKHBhcnQudHlwZSAhPSBcImNhcmRcIil7XG4gICAgICAgICAgICBsZXQgYWxsQ2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0VmFsaWRQYXJ0SW5kZXggPSBhbGxDYXJkcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gZmlyc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VG9GaXJzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGZpcnN0VmFsaWRQYXJ0SW5kZXggPSAwO1xuICAgICAgICBpZihwYXJ0LnR5cGUgIT0gXCJjYXJkXCIpe1xuICAgICAgICAgICAgbGV0IGFsbENhcmRzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwiY2FyZFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaXJzdFZhbGlkUGFydEluZGV4ID0gYWxsQ2FyZHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA+IGZpcnN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgZmlyc3RWYWxpZFBhcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgaWYoIXRoaXMuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gZG9lcyBub3QgYWNjZXB0IHN1YnBhcnRzIG9mIHR5cGUgJHthUGFydC50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYoZm91bmQgPCAwKXtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJ0IGlzIGEgY2FyZCB0aGVuIGFwcGVuZCBhZnRlciB0aGUgbGFzdCBjYXJkXG4gICAgICAgICAgICBpZihhUGFydC50eXBlID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgICAgICBsZXQgYWxsQ2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwiY2FyZFwiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VicGFydHMuc3BsaWNlKGFsbENhcmRzLmxlbmd0aCwgMCwgYVBhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVBhcnQuX293bmVyID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgU3RhY2ssXG4gICAgU3RhY2sgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogV2luZG93IFBhcnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQSBXaW5kb3cgaXMgYSBQYXJ0IHRoYXQgd3JhcHMgYW5vdGhlclxuICogUGFydCBvZiB0eXBlIENhcmQsIFN0YWNrLCBvciBXb3JsZFN0YWNrXG4gKiBpbiBhIG1vdmVhYmxlIHdpbmRvdy5cbiAqIEkgY2FuIGFsc28gb3B0aW9uYWxseSBob2xkIGEgcmVmZXJlbmNlXG4gKiB0byBhIHRhcmdldCBQYXJ0IHRoYXQgSSBkbyBub3Qgb3duLiBJIGNhbGxcbiAqIHRoaXMgSlMgcHJvcGVydHkgdGFyZ2V0IGFuZCBJIHN0b3JlIHRoZVxuICogdGFyZ2V0IHBhcnQncyBpZCBhcyBhIEh5cGVyVGFsayBwcm9wZXJ0eVxuICogY2FsbGVkIHRhcmdldElkLlxuICogV2hlbiBteSBvd25lciBwYXJ0IGlzIHRoZSBjdXJyZW50IHZpZXcsIElcbiAqIHdpbGwgYmUgdmlzaWJsZSBvbiB0b3Agb2YgZXZlcnl0aGluZyBlbHNlLlxuICovXG5pbXBvcnQgUGFydCBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4vU3RhY2suanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZExheW91dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgV2luZG93IGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIG5hbWUsIHRhcmdldCwgZGVzZXJpYWxpemluZz1mYWxzZSl7XG4gICAgICAgIHN1cGVyKG93bmVyLCBuYW1lKTtcblxuICAgICAgICB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzID0gW1xuICAgICAgICAgICAgXCJhcmVhXCIsXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgXCJmaWVsZFwiLFxuICAgICAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICAgICAgXCJhdWRpb1wiLFxuICAgICAgICAgICAgXCJyZXNvdXJjZVwiLFxuICAgICAgICAgICAgXCJkcmF3aW5nXCIsXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gSWYgd2UgcGFzcyBpbiBhIHRhcmdldCxcbiAgICAgICAgLy8gc2V0IGl0LlxuICAgICAgICBpZih0YXJnZXQpe1xuICAgICAgICAgICAgdGhpcy5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB1cCBXaW5kb3cgc3BlY2lmaWNcbiAgICAgICAgLy8gcGFydCBwdG9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3RhcmdldElkJyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICd0aXRsZScsXG4gICAgICAgICAgICBcIk5ldyBXaW5kb3cgVGl0bGVcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2lzUmVzaXphYmxlJyxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU3R5bGVcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmluZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0ID0gdGhpcy5zZXRUYXJnZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldpbmRvd0Nsb3NlID0gdGhpcy5vbldpbmRvd0Nsb3NlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQWRkIHByaXZhdGUgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ3dpbmRvd0Nsb3NlJywgdGhpcy5vbldpbmRvd0Nsb3NlKTtcbiAgICB9XG5cbiAgICBzZXRUYXJnZXQoYVBhcnQpe1xuICAgICAgICB0aGlzLnRhcmdldCA9IGFQYXJ0O1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3RhcmdldElkJyxcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmlkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdW5zZXRUYXJnZXQoKXtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3RhcmdldElkJyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZVxuICAgICAqIFVubGlrZSBvdGhlciBraW5kcyBvZiBQYXJ0cywgYSB3aW5kb3dcbiAgICAgKiBoYXMgb25seSBvbmUgc3VicGFydCwgd2hpY2ggc2hvdWxkIGJlXG4gICAgICogQ2FyZCwgU3RhY2ssIG9yIFdvcmxkU3RhY2suXG4gICAgICovXG4gICAgYWRkUGFydChhUGFydCl7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdGhpcy5hY2NlcHRzU3VicGFydChhUGFydC50eXBlKTtcbiAgICAgICAgaWYoIWlzVmFsaWQpe1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgcmVwbGFjaW5nIHRoaXMgZ2VuZXJpYyBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIHdpdGggYSBtZXNzYWdlIGJhc2VkIGFwcHJvYWNoIHRoYXQgc2VuZHNcbiAgICAgICAgICAgIC8vIHRoZXNlIHNvcnRzIG9mIG5vbi1mYXRhbCBlcnJvcnMgdG8gU3lzdGVtXG4gICAgICAgICAgICAvLyBhcyBhIGtpbmQgb2YgbWVzc2FnZS4gVGhpcyB3YXkgd2UgY2FuIGRpc3BsYXlcbiAgICAgICAgICAgIC8vIGVycm9ycyBpbiBTaW1wbHRUYWxrIG9iamVjdHMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdpbmRvd3MgY2Fubm90IHdyYXAgcGFydHMgb2YgdHlwZSAke2FQYXJ0LnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJ0KHN1YnBhcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJwYXJ0cy5wdXNoKGFQYXJ0KTtcbiAgICAgICAgYVBhcnQuX293bmVyID0gdGhpcztcbiAgICB9XG5cbiAgICBvbldpbmRvd0Nsb3NlKHNlbmRlcnMsIC4uLmFyZ3Mpe1xuICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGRlbGV0ZVxuICAgICAgICAvLyB0aGUgd2luZG93IG1vZGVsIGZyb20gdGhlIFN5c3RlbS5cbiAgICAgICAgLy8gU2NyaXB0cyBjYW4gb3ZlcnJpZGUgdGhpcyBoYW5kbGVyXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnZGVsZXRlTW9kZWwnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsgdGhpcy5pZCBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2luZG93LlN5c3RlbVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnd2luZG93JztcbiAgICB9XG59XG5cbmV4cG9ydCB7XG4gICAgV2luZG93LFxuICAgIFdpbmRvdyBhcyBkZWZhdWx0XG59XG4iLCIvKipcbiAqIFdvcmxkU3RhY2tcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIFN0YWNrIHBhcnQgdGhhdCByZXByZXNlbnRzIHRoZSByb290IG9mIGFcbiAqIGhpZXJhcmNoeSBvZiBwYXJ0cy4gSSBhbSB0aGUgZW5kIG9mIHRoZSBvd25lcnNoaXBcbiAqIGNoYWluIGZvciBhbnkgZ2l2ZW4gY29uZmlndXJhdGlvbiBvZiBQYXJ0cy5cbiAqIEkgYW0gYWxzbyB0aGUgZmluYWwgcmVzb2x2ZXIgb2YgYWxsIHVuaGFuZGxlZFxuICogbWVzc2FnZXMgc2VudCBhbG9uZyB0aGUgZGVsZWdhdGlvbiBjaGFpbiBmb3IgcGFydHMuXG4gKiBBbGwgcGFydHMgY2FuIGV2ZW50dWFsbHkgcmVzb2x2ZSB0byBtZSB2aWEgdGhlIGRlbGVnYXRpb25cbiAqIGNoYWluIG9yIG93bmVyc2hpcCBoaWVyYXJjaHkuXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBvbmUgaW5zdGFuY2Ugb2YgbWUgaW4gYW55IGdpdmVuXG4gKiBTaW1wbGVUYWxrIGVudmlyb25tZW50LlxuICovXG5pbXBvcnQgUGFydCBmcm9tICcuL1BhcnQuanMnO1xuXG5cbmNsYXNzIFdvcmxkU3RhY2sgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcihudWxsKTtcblxuICAgICAgICB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzID0gW1wic3RhY2tcIiwgXCJpbWFnZVwiXTtcblxuICAgICAgICB0aGlzLmlzV29ybGQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBzdGFja1xuICAgICAgICAvLyBpZCBvZiB0aGUgY3VycmVudCBzdGFja1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTZXQgdGhlIGlkIHByb3BlcnR5IHRvIGFsd2F5c1xuICAgICAgICAvLyBiZSAnd29ybGQnXG4gICAgICAgIHRoaXMuaWQgPSAnd29ybGQnO1xuXG4gICAgICAgIC8vIEJpbmQgZ2VuZXJhbCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvID0gdGhpcy5zZW5kT3BlblN0YWNrVG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kQ2xvc2VTdGFja1RvID0gdGhpcy5zZW5kQ2xvc2VTdGFja1RvLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBuYXZpZ2F0aW9uIG1ldGhvZHNcbiAgICAgICAgdGhpcy5nb1RvTmV4dFN0YWNrID0gdGhpcy5nb1RvTmV4dFN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub1ByZXZTdGFjayA9IHRoaXMuZ29Ub1ByZXZTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdvVG9OdGhTdGFjayA9IHRoaXMuZ29Ub050aFN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub1N0YWNrQnlJZCA9IHRoaXMuZ29Ub1N0YWNrQnlJZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tYW5kIGhhbmRsZXJzIHdoaWNoIGFyZSBub3QgbmVlZGVkIGZvciB3b3JsZFxuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVVcFwiKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlRG93blwiKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlVG9GaXJzdFwiKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlVG9MYXN0XCIpO1xuICAgIH1cblxuICAgIGdvVG9OZXh0U3RhY2soKXtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoc3RhY2tzLmxlbmd0aCA8IDIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgbGV0IGN1cnJlbnRJZHggPSBzdGFja3MuaW5kZXhPZihjdXJyZW50U3RhY2spO1xuICAgICAgICBsZXQgbmV4dElkeCA9IGN1cnJlbnRJZHggKyAxO1xuICAgICAgICBpZihuZXh0SWR4ID49IHN0YWNrcy5sZW5ndGgpe1xuICAgICAgICAgICAgbmV4dElkeCA9IChuZXh0SWR4ICUgc3RhY2tzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFjayA9IHN0YWNrc1tuZXh0SWR4XTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG5leHRTdGFjay5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50U3RhY2tJZCAhPSBuZXh0U3RhY2suaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VTdGFja1RvKGN1cnJlbnRTdGFjayk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuU3RhY2tUbyhuZXh0U3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub1N0YWNrQnlJZChhbklkKXtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG5leHRTdGFjayA9IHN0YWNrcy5maW5kKHN0YWNrID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5pZCA9PSBhbklkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoIW5leHRTdGFjayl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayBpZDogJHthbklkfSBjYW50IGJlIGZvdW5kIG9uIHRoaXMgc3RhY2tgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5jdXJyZW50U3RhY2s7XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2tJZCA9IHRoaXMuY3VycmVudFN0YWNrSWQ7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBuZXh0U3RhY2suaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYoY3VycmVudFN0YWNrSWQgIT0gbmV4dFN0YWNrLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlU3RhY2tUbyhjdXJyZW50U3RhY2spO1xuICAgICAgICAgICAgdGhpcy5zZW5kT3BlblN0YWNrVG8obmV4dFN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9QcmV2U3RhY2soKXtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoc3RhY2tzLmxlbmd0aCA8IDIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgbGV0IGN1cnJlbnRJZHggPSBzdGFja3MuaW5kZXhPZihjdXJyZW50U3RhY2spO1xuICAgICAgICBsZXQgbmV4dElkeCA9IGN1cnJlbnRJZHggLSAxO1xuICAgICAgICBpZihuZXh0SWR4IDwgMCl7XG4gICAgICAgICAgICBuZXh0SWR4ID0gc3RhY2tzLmxlbmd0aCArIG5leHRJZHg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFjayA9IHN0YWNrc1tuZXh0SWR4XTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG5leHRTdGFjay5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50U3RhY2tJZCAhPSBuZXh0U3RhY2suaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VTdGFja1RvKGN1cnJlbnRTdGFjayk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuU3RhY2tUbyhuZXh0U3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub050aFN0YWNrKGFuSW5kZXgpe1xuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgdXNpbmcgMS1pbmRleGVkIHZhbHVlc1xuICAgICAgICAvLyBwZXIgdGhlIFNpbXBsZVRhbGsgc3lzdGVtXG4gICAgICAgIGxldCB0cnVlSW5kZXggPSBhbkluZGV4IC0gMTtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYodHJ1ZUluZGV4IDwgMCB8fCB0cnVlSW5kZXggPiBzdGFja3MubGVuZ3RoIC0xKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG5hdmlnYXRlIHRvIHN0YWNrIG51bWJlciAke2FuSW5kZXh9IC0tIG91dCBvZiBib3VuZHNgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5jdXJyZW50U3RhY2s7XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2tJZCA9IHRoaXMuY3VycmVudFN0YWNrSWQ7XG4gICAgICAgIGxldCBuZXh0U3RhY2sgPSBzdGFja3NbdHJ1ZUluZGV4XTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG5leHRTdGFjay5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50U3RhY2tJZCAhPSBuZXh0U3RhY2suaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VTdGFja1RvKGN1cnJlbnRTdGFjayk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuU3RhY2tUbyhuZXh0U3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VuZENsb3NlU3RhY2tUbyhhU3RhY2spe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnY2xvc2VTdGFjaycsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCBhU3RhY2spO1xuICAgICAgICBsZXQgY3VycmVudENhcmQgPSBhU3RhY2suY3VycmVudENhcmQ7XG4gICAgICAgIGlmKGN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIGFTdGFjay5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnY2xvc2VDYXJkJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgIH0sIGFTdGFjay5jdXJyZW50Q2FyZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kT3BlblN0YWNrVG8oYVN0YWNrKXtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TdGFjaycsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCBhU3RhY2spO1xuICAgICAgICBsZXQgY3VycmVudENhcmQgPSBhU3RhY2suY3VycmVudENhcmQ7XG4gICAgICAgIGlmKGN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIGFTdGFjay5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLCBcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5DYXJkJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgIH0sIGFTdGFjay5jdXJyZW50Q2FyZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ3dvcmxkJztcbiAgICB9XG5cbiAgICBnZXQgbG9hZGVkU3RhY2tzKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ3N0YWNrJztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgbm9ybWFsIFBhcnQgc2VyaWFsaXphdGlvbi5cbiAgICAvLyBIZXJlIHdlIG5lZWQgdG8gYWxzbyBpbmNsdWRlIGFuIGFycmF5IG9mIGlkcyBvZlxuICAgIC8vIGxvYWRlZCBzdGFja3MgYW5kIHRoZSBpZCBvZiB0aGUgY3VycmVudCBzdGFja1xuICAgIHNlcmlhbGl6ZSgpe1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgIHN1YnBhcnRzOiB0aGlzLnN1YnBhcnRzLm1hcChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC5pZDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3duZXJJZDogbnVsbCxcbiAgICAgICAgICAgIGxvYWRlZFN0YWNrczogKHRoaXMubG9hZGVkU3RhY2tzLm1hcChzdGFjayA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmlkO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNlcmlhbGl6ZSBjdXJyZW50IHBhcnQgcHJvcGVydGllc1xuICAgICAgICAvLyB2YWx1ZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5fcHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wLmdldFZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgcmVzdWx0LnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgZm9yIGRlbGVnYXRpb24uXG4gICAgLy8gV2Ugc2VuZCBhbnkgbWVzc2FnZXMgdGhhdCBzaG91bGQgYmUgZGVsZWdhdGVkXG4gICAgLy8gdG8gdGhlIGdsb2JhbCBTeXN0ZW0gb2JqZWN0LCB3aGljaCBoYXMgYW55XG4gICAgLy8gJ2hhbmRsZXJzIG9mIGxhc3QgcmVzb3J0J1xuICAgIGRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSl7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKGFNZXNzYWdlLCB3aW5kb3cuU3lzdGVtKTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFN0YWNrSWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFN0YWNrKCl7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFt0aGlzLmN1cnJlbnRTdGFja0lkXTtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgYmFzZSBjbGFzcyBtZXRob2RzXG4gICAgYWRkUGFydChhUGFydCl7XG4gICAgICAgIGlmKCF0aGlzLmFjY2VwdHNTdWJwYXJ0KGFQYXJ0LnR5cGUpKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLnR5cGV9IGRvZXMgbm90IGFjY2VwdCBzdWJwYXJ0cyBvZiB0eXBlICR7YVBhcnQudHlwZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihhUGFydCk7XG4gICAgICAgIGlmKGZvdW5kIDwgMCl7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFydCBpcyBhIHN0YWNrIHRoZW4gYXBwZW5kIGFmdGVyIHRoZSBsYXN0IHN0YWNrXG4gICAgICAgICAgICBpZihhUGFydC50eXBlID09IFwic3RhY2tcIil7XG4gICAgICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJzdGFja1wiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VicGFydHMuc3BsaWNlKGFsbFN0YWNrcy5sZW5ndGgsIDAsIGFQYXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5wdXNoKGFQYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFQYXJ0Ll9vd25lciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlU3VicGFydERvd24ocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBsYXN0VmFsaWRQYXJ0SW5kZXggPSB0aGlzLnN1YnBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKHBhcnQudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RWYWxpZFBhcnRJbmRleCA9IGFsbFN0YWNrcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IGxhc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VG9MYXN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgbGFzdFZhbGlkUGFydEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICBpZihwYXJ0LnR5cGUgPT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBhbGxTdGFja3MgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJzdGFja1wiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0VmFsaWRQYXJ0SW5kZXggPSBhbGxTdGFja3MubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPCBsYXN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgbGFzdFZhbGlkUGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VXAocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBmaXJzdFZhbGlkUGFydEluZGV4ID0gMDtcbiAgICAgICAgaWYocGFydC50eXBlICE9IFwic3RhY2tcIil7XG4gICAgICAgICAgICBsZXQgYWxsU3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwic3RhY2tcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlyc3RWYWxpZFBhcnRJbmRleCA9IGFsbFN0YWNrcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gZmlyc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VG9GaXJzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGZpcnN0VmFsaWRQYXJ0SW5kZXggPSAwO1xuICAgICAgICBpZihwYXJ0LnR5cGUgIT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBhbGxTdGFja3MgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJzdGFja1wiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaXJzdFZhbGlkUGFydEluZGV4ID0gYWxsU3RhY2tzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPiBmaXJzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGZpcnN0VmFsaWRQYXJ0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5leHBvcnQge1xuICAgIFdvcmxkU3RhY2ssXG4gICAgV29ybGRTdGFjayBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IGNzc1N0eWxlciBmcm9tICcuLi91dGlscy8vc3R5bGVyLmpzJztcblxuLyoqXG4gKiBQYXJ0UHJvcGVydGllc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJhc2VcbiAqIFBhcnQgUHJvcGVydGllcyBmb3IgYWxsIFBhcnRzLlxuICogSSBhbHNvIGluY2x1ZGUgc29tZSBjb252ZW5pZW5jZSBtZXRob2RzXG4gKiBvbiBteSBwcm90b3R5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCBieVxuICogb3RoZXIgUGFydHMgd2hlbiB0aGV5IGluaGVyaXQgZnJvbSBtZS5cbiAqIEZvciBub3csIHdlIHVzZSBPYmplY3QuY3JlYXRlKCkgZm9yIGluaGVyaXRhbmNlLlxuICovXG5cbmNsYXNzIEJhc2ljUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlZmF1bHRWYWx1ZSwgcmVhZE9ubHk9ZmFsc2UsIGFsaWFzZXM9W10pe1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5yZWFkT25seSA9IHJlYWRPbmx5O1xuICAgICAgICB0aGlzLmFsaWFzZXMgPSBhbGlhc2VzO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYXNBbGlhcyA9IHRoaXMuaGFzQWxpYXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gdGhpcy5tYXRjaGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWF0Y2hlc05hbWVPckFsaWFzID0gdGhpcy5tYXRjaGVzTmFtZU9yQWxpYXMuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYmFzaWMgcHJvcGVydGllcywgd2UgcmV0dXJuXG4gICAgLy8gdGhlIHNldC9zdG9yZWQgdmFsdWVcbiAgICBnZXRWYWx1ZShvd25lcil7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBGb3IgdGhlIGJhc2ljIHByb3BlcnRpZXMsIHdlIHNldFxuICAgIC8vIGJhc2VkIG9uIHRoZSBpbmNvbWluZyBkZXNpcmVkIHZhbHVlXG4gICAgLy8gYWxvbmUgKG5vdGhpbmcgaXMgY29tcHV0ZWQpXG4gICAgc2V0VmFsdWUob3duZXIsIHZhbCwgbm90aWZ5PXRydWUpe1xuICAgICAgICBpZighdGhpcy5yZWFkT25seSl7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIGlmKG5vdGlmeSl7XG4gICAgICAgICAgICAgICAgb3duZXIucHJvcGVydHlDaGFuZ2VkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhpcyBwcm9wZXJ0eVxuICAgIC8vIGdvZXMgYnkgdGhlIGdpdmVuIGFsaWFzXG4gICAgaGFzQWxpYXMoYW5BbGlhcyl7XG4gICAgICAgIHJldHVybiB0aGlzLmFsaWFzZXMuaW5jbHVkZXMoYW5BbGlhcyk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBuYW1lIGlzXG4gICAgLy8gZWl0aGVyIGFuIGFsaWFzIG9yIHRoZSBleGFjdCBuYW1lXG4gICAgLy8gZm9yIHRoaXMgcHJvcGVydHlcbiAgICBtYXRjaGVzTmFtZU9yQWxpYXMoYU5hbWVPckFsaWFzKXtcbiAgICAgICAgaWYodGhpcy5oYXNBbGlhcyhhTmFtZU9yQWxpYXMpKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoYU5hbWVPckFsaWFzID09IHRoaXMubmFtZSl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBpbmNvbWluZyBQcm9wZXJ0eVxuICAgIC8vIGhhcyB0aGUgc2FtZSBuYW1lIGFuZC9vciBvbmUgb2YgdGhlIHNhbWVcbiAgICAvLyBhbGlhc2VzIGFzIHRoaXMgUHJvcGVydHlcbiAgICBtYXRjaGVzKGFQcm9wZXJ0eSl7XG4gICAgICAgIGlmKGFQcm9wZXJ0eS5uYW1lID09IHRoaXMubmFtZSl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmFsaWFzZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGxldCBteUFsaWFzID0gdGhpcy5hbGlhc2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmKGFQcm9wZXJ0eS5oYXNBbGlhcyhteUFsaWFzKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuXG4vKiogQ3VzdG9tIFByb3BlcnRpZXMgYXJlIHNpbWlsYXIgdG8gZHluYW1pYyBwcm9wcywgZXhjZXB0IHRoYXRcbiAgKiB1bmRlciB0aGUgaG9vZCB0aGV5IHN0b3JlIGFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG4gICogc3RvcmluZyBwcm9wcyBkZWZpbmVkIHdpdGhpbiB0aGUgU1QgZW52aXJvbm1lbnQuIFRoZSBmaW5kKClcbiAgKiBhZGQoKSBkZWxldGUoKSBtZXRob2RzIGZpbmQsIGFkZCwgb3IgcmVtb3ZlIHByb3BlcnRpZXMgZnJvbSB0aGVcbiAgKiB0aGlzLmN1c3RvbVByb3BlcnRpZXMgb2JqZWN0LlxuICoqL1xuY2xhc3MgQ3VzdG9tUHJvcGVydHkgZXh0ZW5kcyBCYXNpY1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lPVwiY3VzdG9tLXByb3BlcnRpZXNcIiwgZGVmYXVsdFZhbHVlPXt9LCByZWFkT25seT1mYWxzZSwgYWxpYXNlcz1bXSl7XG4gICAgICAgIHN1cGVyKG5hbWUsIGRlZmF1bHRWYWx1ZSwgcmVhZE9ubHk9ZmFsc2UsIGFsaWFzZXMpO1xuICAgIH1cblxuICAgIGZpbmQobmFtZSl7XG4gICAgICAgIGxldCBwcm9wID0gdGhpcy5fdmFsdWVbbmFtZV07XG4gICAgICAgIGlmKHByb3Ape1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYWRkKGFQcm9wZXJ0eSl7XG4gICAgICAgIC8vIE5PVEU6IGFsaWFzZXMgYXJlIGNvbXBsZXRlZCBpZ25vcmVkIGZvciBub3dcbiAgICAgICAgaWYoIXRoaXMuZmluZChhUHJvcGVydHkubmFtZSkpe1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVbYVByb3BlcnR5Lm5hbWVdID0gYVByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlKGFQcm9wZXJ0eSl7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl92YWx1ZVthUHJvcGVydHkubmFtZV07XG4gICAgfVxuXG5cblxufTtcblxuY2xhc3MgRHluYW1pY1Byb3BlcnR5IGV4dGVuZHMgQmFzaWNQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgc2V0dGVyLCBnZXR0ZXIsIHJlYWRPbmx5PWZhbHNlLCBkZWZhdWx0VmFsdWU9bnVsbCwgYWxpYXNlcz1bXSl7XG4gICAgICAgIHN1cGVyKG5hbWUsIGRlZmF1bHRWYWx1ZSwgcmVhZE9ubHksIGFsaWFzZXMpO1xuICAgICAgICB0aGlzLnZhbHVlU2V0dGVyID0gc2V0dGVyO1xuICAgICAgICB0aGlzLnZhbHVlR2V0dGVyID0gZ2V0dGVyO1xuICAgIH1cblxuICAgIC8vIEluIHRoaXMgb3ZlcnJpZGUsIHdlIHVzZSB0aGUgZ2V0dGVyXG4gICAgLy8gaWYgYXZhaWxhYmxlLCB0byBkeW5hbWljYWxseSBnZXQgdGhlXG4gICAgLy8gaW5jb21pbmcgdmFsdWUuXG4gICAgZ2V0VmFsdWUob3duZXIpe1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUdldHRlcihvd25lciwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhpcyBvdmVycmlkZSwgd2UgdXNlIHRoZSBzZXR0ZXJcbiAgICAvLyBpZiBhdmFpbGFibGUsIHRvIGR5bmFtaWNhbGx5IHNldCB0aGVcbiAgICAvLyBpbmNvbWluZyB2YWx1ZVxuICAgIHNldFZhbHVlKG93bmVyLCB2YWwsIG5vdGlmeT10cnVlKXtcbiAgICAgICAgaWYoIXRoaXMucmVhZE9ubHkpe1xuICAgICAgICAgICAgdGhpcy52YWx1ZVNldHRlcihvd25lciwgdGhpcywgdmFsLCBub3RpZnkpO1xuICAgICAgICAgICAgaWYobm90aWZ5KXtcbiAgICAgICAgICAgICAgICBvd25lci5wcm9wZXJ0eUNoYW5nZWQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqIEkgYW0gYSBzcGVjaWFsIHByb3BlcnR5IHdoaWNoIGhhbmRsZXMgaW50ZXJmYWNpbmcgd2l0aCB0aGVcbiAgKiB0aGUgY3NzU3R5bGUgYmFzaWMgcHJvcGVydHkuIFdoZW5ldmVyIEkgYW0gdXBkYXRlZCBJIG1ha2VcbiAgKiBzdXJlIHRvIHVwZGF0ZSB0aGUgY3NzU3R5bGUgcHJvcGVydHkgdmlhIHRoZSBzdHlsZXIgdXRpbGl0eVxuICAqIGZ1bmN0aW9uLiBJIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBkaWZmZXJlbnQgYW5kIGluZGVwZW50XG4gICogc3R5bGluZyBvcHRpb25zLlxuICAqKi9cbmNsYXNzIFN0eWxlUHJvcGVydHkgZXh0ZW5kcyBCYXNpY1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkZWZhdWx0VmFsdWUsICBwcm9wTmFtZT0nY3NzU3R5bGUnLCBzdHlsZXI9Y3NzU3R5bGVyLCByZWFkT25seT1mYWxzZSwgYWxpYXNlcz1bXSl7XG4gICAgICAgIHN1cGVyKG5hbWUsIGRlZmF1bHRWYWx1ZSwgcmVhZE9ubHksIGFsaWFzZXMpO1xuICAgICAgICB0aGlzLnByb3BOYW1lID0gcHJvcE5hbWU7XG4gICAgICAgIHRoaXMuc3R5bGVyID0gc3R5bGVyO1xuICAgIH1cblxuICAgIC8vIEluIHRoaXMgb3ZlcnJpZGUsIHdlIHVwZGF0ZSB0aGUgY3NzU3R5bGUgcHJvcGVydHlcbiAgICBzZXRWYWx1ZShvd25lciwgdmFsLCBub3RpZnk9dHJ1ZSl7XG4gICAgICAgIGlmKCF0aGlzLnJlYWRPbmx5KXtcbiAgICAgICAgICAgIGxldCBzdHlsZVByb3BlcnR5ID0gb3duZXIucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQodGhpcy5wcm9wTmFtZSk7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZVByb3BlcnR5LmdldFZhbHVlKG93bmVyKTtcbiAgICAgICAgICAgIGxldCBuZXdTdHlsZSA9IHRoaXMuc3R5bGVyKHN0eWxlLCB0aGlzLm5hbWUsIHZhbCk7XG4gICAgICAgICAgICBzdHlsZVByb3BlcnR5LnNldFZhbHVlKG93bmVyLCBuZXdTdHlsZSwgbm90aWZ5KTtcblxuICAgICAgICAgICAgLy8gc2V0IG15IHZhbHVlIGFzIHdlbGxcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICAgICAgaWYobm90aWZ5KXtcbiAgICAgICAgICAgICAgICBvd25lci5wcm9wZXJ0eUNoYW5nZWQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNsYXNzIFBhcnRQcm9wZXJ0aWVzIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmhhc1Byb3BlcnR5ID0gdGhpcy5oYXNQcm9wZXJ0eS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5ID0gdGhpcy5hZGRQcm9wZXJ0eS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5ID0gdGhpcy5yZW1vdmVQcm9wZXJ0eS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkID0gdGhpcy5maW5kUHJvcGVydHlOYW1lZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5TmFtZWQgPSB0aGlzLnNldFByb3BlcnR5TmFtZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eU5hbWVkID0gdGhpcy5nZXRQcm9wZXJ0eU5hbWVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubmV3QmFzaWNQcm9wID0gdGhpcy5uZXdCYXNpY1Byb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXdTdHlsZVByb3AgPSB0aGlzLm5ld1N0eWxlUHJvcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5ld0R5bmFtaWNQcm9wID0gdGhpcy5uZXdEeW5hbWljUHJvcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9pbmRleE9mUHJvcGVydHkgPSB0aGlzLl9pbmRleE9mUHJvcGVydHkuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgYWxsKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIC8vIFRoaXMgY29sbGVjdGlvbiAnaGFzJyBhIHByb3BlcnR5IGlmIGl0IGNvbnRhaW5zXG4gICAgLy8gYSBQcm9wZXJ0eSBvYmplY3Qgd2l0aCBtYXRjaGluZyBuYW1lIG9yIGFsaWFzXG4gICAgLy8gb2YgdGhlIGluY29taW5nIHByb3BlcnR5LlxuICAgIGhhc1Byb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIGlmKGFQcm9wZXJ0eS5tYXRjaGVzKHByb3ApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRmluZCBvbmUgb2YgbXkgUHJvcGVydGllcyBieVxuICAgIC8vIGEgbmFtZSBvciBhbGlhcy4gUmV0dXJucyBudWxsXG4gICAgLy8gaWYgbm8gbWF0Y2ggZm91bmQuIFBlcmhhcHMgd2Ugc2hvdWxkXG4gICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICBmaW5kUHJvcGVydHlOYW1lZChhTmFtZSl7XG4gICAgICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXN0b21Qcm9wZXJ0aWVzUHJvcDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYocHJvcC5tYXRjaGVzTmFtZU9yQWxpYXMoYU5hbWUpKXtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBncmFiIHRoZSBjdXN0b20gcHJvcGVydGllcyBwcm9wLCBhcyB3ZSBtaWdodCBuZWVkIGl0XG4gICAgICAgICAgICAvLyBmb3IgbGF0ZXJcbiAgICAgICAgICAgIGlmKHByb3AubWF0Y2hlc05hbWVPckFsaWFzKFwiY3VzdG9tLXByb3BlcnRpZXNcIikpe1xuICAgICAgICAgICAgICAgIGN1c3RvbVByb3BlcnRpZXNQcm9wID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZWUgaWYgdGhlIHByb3BlcnR5IGlzIGN1c3RvbVxuICAgICAgICBpZighZm91bmQgJiYgY3VzdG9tUHJvcGVydGllc1Byb3Ape1xuICAgICAgICAgICAgZm91bmQgPSBjdXN0b21Qcm9wZXJ0aWVzUHJvcC5maW5kKGFOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdHMgdG8gZ2V0IHRoZSAqdmFsdWUqIG9mIHRoZSBwcm9wZXJ0eVxuICAgIC8vIHdpdGggdGhlIGdpdmVuIG5hbWUgb3IgYWxpYXMuXG4gICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgd2UgdGhyb3cgYW5cbiAgICAvLyBlcnJvclxuICAgIGdldFByb3BlcnR5TmFtZWQob3duZXIsIGFOYW1lKXtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5maW5kUHJvcGVydHlOYW1lZChhTmFtZSk7XG4gICAgICAgIGlmKCFmb3VuZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3duZXJ9IGRvZXMgbm90IGhhdmUgcHJvcGVydHkgXCIke2FOYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kLmdldFZhbHVlKG93bmVyKTtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0cyB0byBzZXQgdGhlICp2YWx1ZSogb2YgdGhlIHByb3BlcnR5XG4gICAgLy8gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciBhbGlhcy5cbiAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB3ZSB0aHJvdyBhblxuICAgIC8vIGVycm9yXG4gICAgc2V0UHJvcGVydHlOYW1lZChvd25lciwgYU5hbWUsIGFWYWx1ZSwgbm90aWZ5PXRydWUpe1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkKGFOYW1lKTtcbiAgICAgICAgaWYoIWZvdW5kKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvd25lcn0gZG9lcyBub3QgaGF2ZSBwcm9wZXJ0eSBcIiR7YU5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQuc2V0VmFsdWUob3duZXIsIGFWYWx1ZSwgbm90aWZ5KTtcbiAgICB9XG5cbiAgICAvLyBJZiB5b3UgYWRkIGEgcHJvcGVydHkgd2l0aCBhIG5hbWUgb3IgYWxpYXNcbiAgICAvLyB0aGF0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgY29sbGVjdGlvbixcbiAgICAvLyB0aGVuIHdlICdvdmVyd3JpdGUnIGl0IGJ5IHJlbW92aW5nIHRoZSBleGlzaW5nXG4gICAgLy8gcHJvcGVydHkgYW5kIHJlcGxhY2luZyBpdCB3aXRoIHRoZSBpbmNvbWluZyBvbmUuXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSBqdXN0IGFkZCB0aGUgcHJvcGVydHlcbiAgICBhZGRQcm9wZXJ0eShhUHJvcGVydHkpe1xuICAgICAgICBpZih0aGlzLmhhc1Byb3BlcnR5KGFQcm9wZXJ0eSkpe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcm9wZXJ0eShhUHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMucHVzaChhUHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8vIFJlbW92aW5nIGEgcHJvcGVydHkgaGVyZSBtZWFucyByZW1vdmluZ1xuICAgIC8vIGl0IGZyb20gdGhlIHN0b3JlZCBhcnJheS4gSWYgdGhlIHByb3BlcnR5XG4gICAgLy8gaXMgbm90IGluIHRoZSBhcnJheSwgd2UgZG8gTk9UIHRocm93IGFuIGVycm9yLlxuICAgIC8vIFdlIGp1c3QgZ28gb24gd2l0aCBvdXIgbGl2ZXMsIGJlY2F1c2Ugd2hvIGNhcmVzP1xuICAgIHJlbW92ZVByb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGxldCBwcm9wSW5kZXggPSB0aGlzLl9pbmRleE9mUHJvcGVydHkoYVByb3BlcnR5KTtcbiAgICAgICAgaWYocHJvcEluZGV4ID49IDApe1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5zcGxpY2UocHJvcEluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXcgYmFzaWNcbiAgICAvLyBwcm9wZXJ0eS5cbiAgICBuZXdCYXNpY1Byb3AoLi4uYXJncyl7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IEJhc2ljUHJvcGVydHkoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBjdXN0b21cbiAgICAvLyBwcm9wZXJ0eS5cbiAgICBuZXdDdXN0b21Qcm9wKC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbmV3UHJvcCA9IG5ldyBDdXN0b21Qcm9wZXJ0eSguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShuZXdQcm9wKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IHN0eWxlXG4gICAgLy8gcHJvcGVydHkuXG4gICAgbmV3U3R5bGVQcm9wKC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbmV3UHJvcCA9IG5ldyBTdHlsZVByb3BlcnR5KC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KG5ld1Byb3ApO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXdcbiAgICAvLyBkeW5hbWljIHByb3BcbiAgICBuZXdEeW5hbWljUHJvcCguLi5hcmdzKXtcbiAgICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgRHluYW1pY1Byb3BlcnR5KC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KG5ld1Byb3ApO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGUgbWV0aG9kLiBGaW5kcyB0aGUgZmlyc3Qgb2NjdXJyaW5nXG4gICAgLy8gaW5kZXggb2YgdGhlIGdpdmVuIFByb3BlcnR5IGluIHRoZSBhcnJheVxuICAgIC8vIG9mIHByb3BlcnRpZXMgaW4gdGhpcyBjb2xsZWN0aW9uLiBSZXR1cm5zXG4gICAgLy8gLTEgaWYgbm90IGZvdW5kLCBwZXIgSlMgaW1wbGVtZW50YXRpb24uXG4gICAgX2luZGV4T2ZQcm9wZXJ0eShhUHJvcGVydHkpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyB0aGlzLl9wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIGlmKGFQcm9wZXJ0eS5tYXRjaGVzKHByb3ApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBQYXJ0UHJvcGVydGllcyxcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIEN1c3RvbVByb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eSxcbiAgICBQYXJ0UHJvcGVydGllcyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqIFNlY29uZCBwYXNzIGF0IHN5bnRheCBoaWdobGlnaHRlciBzZW1hbnRpY3MgKiovXG5jb25zdCBzeW50YXhTcGFuID0gKHJ1bGVOYW1lKSA9PiB7XG4gICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdzdC1zeW50YXgnKTtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZSgnZGF0YS1zdC1ydWxlJywgcnVsZU5hbWUpO1xuICAgIHJldHVybiBzcGFuO1xufVxuXG5jb25zdCBjcmVhdGVIaWdobGlnaHRlciA9IChmaWVsZEVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBNZXNzYWdlSGFuZGxlck9wZW46IGZ1bmN0aW9uKGxpdGVyYWxPbiwgbWVzc2FnZU5hbWUsIG9wdGlvbmFsUGFyYW1MaXN0KXtcbiAgICAgICAgICAgIGxldCBzcGFuID0gc3ludGF4U3BhbihcIk1lc3NhZ2VIYW5kbGVyT3BlblwiKTtcbiAgICAgICAgICAgIGxldCBvblNwYW4gPSBzeW50YXhTcGFuKFwia2V5d29yZFwiKTtcbiAgICAgICAgICAgIG9uU3Bhbi5hcHBlbmQoXCJvbiBcIik7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZChvblNwYW4pO1xuXG4gICAgICAgICAgICAvLyBBcHBlbmQgc3ViLXJ1bGVzXG4gICAgICAgICAgICBzcGFuLmFwcGVuZChtZXNzYWdlTmFtZS5oaWdobGlnaHRTeW50YXgoKSk7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZCguLi5vcHRpb25hbFBhcmFtTGlzdC5oaWdobGlnaHRTeW50YXgoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9LFxuXG4gICAgICAgIE1lc3NhZ2VIYW5kbGVyQ2xvc2UobGl0ZXJhbEVuZCwgbWVzc2FnZU5hbWUpe1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBzeW50YXhTcGFuKFwiTWVzc2FnZUhhbmRsZXJDbG9zZVwiKTtcbiAgICAgICAgICAgIGxldCBlbmRTcGFuID0gc3ludGF4U3BhbihcImtleXdvcmRcIik7XG4gICAgICAgICAgICBlbmRTcGFuLmFwcGVuZChcImVuZCBcIik7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZChlbmRTcGFuKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBwYXJ0c1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmQobWVzc2FnZU5hbWUuaGlnaGxpZ2h0U3ludGF4KCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfSxcblxuICAgICAgICBQYXJhbWV0ZXJMaXN0OiBmdW5jdGlvbihwYXJhbVN0cmluZyl7XG4gICAgICAgICAgICBsZXQgb3V0ZXIgPSBzeW50YXhTcGFuKFwiUGFyYW1ldGVyTGlzdFwiKTtcbiAgICAgICAgICAgIGxldCBpbm5lckl0ZW1zID0gcGFyYW1TdHJpbmcuYXNJdGVyYXRpb24oKS5jaGlsZHJlbi5tYXAocGFyYW1OYW1lID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IHN5bnRheFNwYW4oXCJQYXJhbWV0ZXJMaXN0LWl0ZW1cIik7XG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmQocGFyYW1OYW1lLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYW4ub3V0ZXJIVE1MO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRlci5pbm5lckhUTUwgPSBpbm5lckl0ZW1zLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRlcjtcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIG1lc3NhZ2VOYW1lOiBmdW5jdGlvbihzdHJpbmcpe1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3N0LXN5bnRheCcpO1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3QtcnVsZScsICdtZXNzYWdlTmFtZScpO1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmQoc3RyaW5nLnNvdXJjZVN0cmluZyArIFwiIFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9LFxuXG4gICAgICAgIGtleXdvcmQ6IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZCgnc3Qtc3ludGF4Jyk7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnZGF0YS1zdC1ydWxlJywgJ2tleXdvcmQnKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKHN0cmluZy5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuZXhwb3J0IHtcbiAgICBjcmVhdGVIaWdobGlnaHRlcixcbiAgICBjcmVhdGVIaWdobGlnaHRlciBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIENsaXBib2FyZCBGdW5jdGlvbmFsaXR5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEZvciB0aGUgbW9tZW50IHdlIHVzZSBhIHZlcnkgcHJpbWl0aXZlIHN0YW5kLWluXG4gKiBzaW5jZSB0aGUgQ2xpcGJvYXJkIEFQSSBpcyBub3Qgc3RhbmRhcmRpemVkIGFjcm9zc1xuICogYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMuXG4gKiovXG5pbXBvcnQgaWRNYWtlciBmcm9tICcuL2lkLmpzJztcbmltcG9ydCB7U1REZXNlcmlhbGl6ZXIsIFNUU2VyaWFsaXplcn0gZnJvbSAnLi9zZXJpYWxpemF0aW9uLmpzJztcblxuY2xhc3MgU1RDbGlwYm9hcmQge1xuICAgIGNvbnN0cnVjdG9yKGFTeXN0ZW0pe1xuICAgICAgICB0aGlzLnN5c3RlbSA9IGFTeXN0ZW07XG4gICAgICAgIHRoaXMuY29udGVudHMgPSBbXTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuY29weVBhcnQgPSB0aGlzLmNvcHlQYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFzdGVDb250ZW50c0ludG8gPSB0aGlzLnBhc3RlQ29udGVudHNJbnRvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUxlbnNlZENoaWxkcmVuID0gdGhpcy5fY3JlYXRlTGVuc2VkQ2hpbGRyZW4uYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb3B5UGFydChhUGFydCl7XG4gICAgICAgIGxldCBzZXJpYWxpemVyID0gbmV3IFNUU2VyaWFsaXplcih0aGlzLnN5c3RlbSk7XG4gICAgICAgIGxldCByb290U2VyaWFsaXphdGlvbiA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKGFQYXJ0LCBmYWxzZSk7XG4gICAgICAgIGxldCBpdGVtID0gbmV3IFNUQ2xpcGJvYXJkSXRlbShcbiAgICAgICAgICAgICdzaW1wbGV0YWxrL2pzb24nLFxuICAgICAgICAgICAgcm9vdFNlcmlhbGl6YXRpb24sXG4gICAgICAgICAgICBhUGFydC50eXBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY29udGVudHMgPSBbaXRlbV07XG4gICAgfVxuXG4gICAgcGFzdGVDb250ZW50c0ludG8oYVRhcmdldFBhcnQpe1xuICAgICAgICBsZXQgcHJvbWlzZXMgPSB0aGlzLmNvbnRlbnRzLm1hcChjbGlwYm9hcmRDb250ZW50ID0+IHtcbiAgICAgICAgICAgIGxldCBzZXJpYWxpemVkQ29udGVudCA9IGNsaXBib2FyZENvbnRlbnQuZGF0YTtcbiAgICAgICAgICAgIGxldCBkZXNlcmlhbGl6ZXIgPSBuZXcgU1REZXNlcmlhbGl6ZXIodGhpcy5zeXN0ZW0pO1xuICAgICAgICAgICAgZGVzZXJpYWxpemVyLnRhcmdldElkID0gYVRhcmdldFBhcnQuaWQ7XG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRDb250ZW50KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRvcCBhbmQgbGVmdCB2YWx1ZXMgdG8gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGFzdGVkIHBhcnQgZG9lc24ndCBydW4gb3V0c2lkZSBvZiB0aGUgbmV3XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0aXZlIGJvdW5kcyBpbiB3aGljaCBpdCBoYXMgYmVlbiBwYXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1BhcnQgPSBkZXNlcmlhbGl6ZXIucm9vdFBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzVG9wID0gbmV3UGFydC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCgndG9wJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNMZWZ0ID0gbmV3UGFydC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCgnbGVmdCcpO1xuICAgICAgICAgICAgICAgICAgICBpZihoYXNUb3Ape1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFydC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzTGVmdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gSGFsbyBvbiB0aGUgbmV3IHZpZXdcbiAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemVyLnJvb3RWaWV3c1swXS5vcGVuSGFsbygpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBDdXN0b21FdmVudCB0aGF0IG5vdGlmaWVzIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGEgbmV3IHZpZXcgd2FzIGFkZGVkICh1c2VkIGJ5IE5hdiBldGMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc3Qtdmlldy1hZGRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRUeXBlOiBuZXdQYXJ0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydElkOiBuZXdQYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVySWQ6IG5ld1BhcnQuX293bmVyLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZXIucm9vdFZpZXdzWzBdLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgbGVuc2VkIHZpZXdzIHRoYXQgbWlnaHQgYmUgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGxldCByb290TGVuc1ZpZXdzID0gdGhpcy5zeXN0ZW0uZmluZExlbnNWaWV3c0J5SWQobmV3UGFydC5fb3duZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICByb290TGVuc1ZpZXdzLmZvckVhY2gobGVuc1ZpZXcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0xlbnNWaWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5c3RlbS50YWdOYW1lRm9yVmlld05hbWVkKG5ld1BhcnQudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRNb2RlbChuZXdQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbnNWaWV3LnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnLCBuZXdQYXJ0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldEF0dHJpYnV0ZSgncm9sZScsICdsZW5zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5zVmlldy5hcHBlbmRDaGlsZChuZXdMZW5zVmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVMZW5zZWRDaGlsZHJlbihuZXdMZW5zVmlldywgbmV3UGFydC5zdWJwYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUxlbnNlZENoaWxkcmVuKGFMZW5zVmlldywgc3VicGFydHMpe1xuICAgICAgICBzdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IG5ld0xlbnNWaWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICB0aGlzLnN5c3RlbS50YWdOYW1lRm9yVmlld05hbWVkKHN1YnBhcnQudHlwZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRNb2RlbChzdWJwYXJ0KTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnLCBzdWJwYXJ0LmlkKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldEF0dHJpYnV0ZSgncm9sZScsICdsZW5zJyk7XG4gICAgICAgICAgICBhTGVuc1ZpZXcuYXBwZW5kQ2hpbGQobmV3TGVuc1ZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlTGVuc2VkQ2hpbGRyZW4obmV3TGVuc1ZpZXcsIHN1YnBhcnQuc3VicGFydHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgZ2V0IGlzRW1wdHkoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMubGVuZ3RoIDw9IDA7XG4gICAgfVxufVxuXG5jbGFzcyBTVENsaXBib2FyZEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG1pbWVUeXBlLCBkYXRhLCBwYXJ0VHlwZSl7XG4gICAgICAgIGlmKG1pbWVUeXBlKXtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhcnRUeXBlKXtcbiAgICAgICAgICAgIHRoaXMuX3BhcnRUeXBlID0gcGFydFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YSl7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBhcnRUeXBlKCl7XG4gICAgICAgIGlmKHRoaXMudHlwZSA9PSAnc2ltcGxldGFsay9qc29uJyl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc2V0IHBhcnRUeXBlKHZhbCl7XG4gICAgICAgIHRoaXMuX3BhcnRUeXBlID0gdmFsO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgU1RDbGlwYm9hcmQsXG4gICAgU1RDbGlwYm9hcmQgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogRXJyb3IgSGFuZGxlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIHJlc3BvbnNpYmxlIGZvciBoYW5kbGVyIGFsbFxuICogU3lzdGVtLXdpZGUgZXJyb3JzXG4gKi9cblxuY29uc3QgZXJyb3JIYW5kbGVyID0ge1xuXG4gICAgaGFuZGxlOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIHN3aXRjaChhTWVzc2FnZS5uYW1lKXtcbiAgICAgICAgICAgIGNhc2UgJ0dyYW1tYXJNYXRjaEVycm9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVHcmFtbWFyTWF0Y2hFcnJvcihhTWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlICdNZXNzYWdlTm90VW5kZXJzdG9vZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTWVzc2FnZU5vdFVuZGVyc3Rvb2QoYU1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBpZiBJIGRvbid0IGtub3cgd2hhdCB0byBkbyB3aXRoIHRoaXMgbWVzc2FnZVxuICAgICAgICAgICAgICAgIC8vIEkgc2VuZCBpdCBhbG9uZyB0byB0aGUgU3lzdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0ucmVjZWl2ZU1lc3NhZ2UoYU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUdyYW1tYXJNYXRjaEVycm9yOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIC8vIFRPRE8gaXMgdGhlcmUgYSBtb3JlIHN0cnVjdHVyZWQgd2F5IHRvIGdldCB0aGlzIG91dCBvZiBvaG0/XG4gICAgICAgIGxldCByZWdleCA9IC9MaW5lICg/PGxpbmU+XFxkKSwgY29sICg/PGNvbHVtbj5cXGQpLztcbiAgICAgICAgbGV0IG1hdGNoID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0Lm1lc3NhZ2UubWF0Y2gocmVnZXgpO1xuICAgICAgICBsZXQgZXJyb3JMaW5lTnVtID0gcGFyc2VJbnQobWF0Y2guZ3JvdXBzW1wibGluZVwiXSkgLSAxOyAvLyBvaG0gbGluZXMgc3RhcnQgd2l0aCAxIFxuICAgICAgICAvLyBzZWUgaWYgdGhlIGdyYW1tYXIgcnVsZSBoYXMgYmVlbiBpZGVudGlmaWVkXG4gICAgICAgIGxldCBydWxlTmFtZTtcbiAgICAgICAgbGV0IHJpZ2h0TW9zdEZhaWx1cmVzID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmdldFJpZ2h0bW9zdEZhaWx1cmVzKCk7XG4gICAgICAgIGlmKHJpZ2h0TW9zdEZhaWx1cmVzWzFdKXtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gcmlnaHRNb3N0RmFpbHVyZXNbMV0ucGV4cHIucnVsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IHNvbWUgbW9yZSBpbmZvIGFib3V0IHdoYXQgdGhlIHBhcnNlciBleHBlY3RlZFxuICAgICAgICBsZXQgZXhwZWN0ZWRUZXh0ID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmdldEV4cGVjdGVkVGV4dCgpO1xuICAgICAgICAvLyBnZXQgdGhlIG9yaWdpbmFsIHNjcmlwdFxuICAgICAgICBsZXQgdGV4dCA9IGFNZXNzYWdlLnBhcnNlZFNjcmlwdC5pbnB1dDtcbiAgICAgICAgbGV0IHRleHRMaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIC8vIHJlcGxhY2Ugc2FpZCB0ZXh0IGxpbmUgd2l0aCBhbiBlcnJvciBtYXJrZXJcbiAgICAgICAgdGV4dExpbmVzW2Vycm9yTGluZU51bV0gKz0gYCAtLTw8PFtFeHBlY3RlZDoke2V4cGVjdGVkVGV4dH07IHJ1bGVOYW1lOiBcIiR7cnVsZU5hbWV9XCJdYDtcbiAgICAgICAgdGV4dCA9IHRleHRMaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAvLyBpZiB0aGUgZmlyc3QgbWVzc2FnZSBpbiB0aGUgcGFyc2VkIHNjcmlwdCBpcyBcImRvSXRcIiB0aGVuIHRoZSBzdGF0ZW1lbnRMaW5lcyBhcmVcbiAgICAgICAgLy8gbG9jYXRlZCBpbiB0aGUgY29ycmVzcG9uZGluZyBmaWVsZCB0ZXh0LCBub3QgdGhlIHNjcmlwdCwgcHJvcGVydHkgYW5kXG4gICAgICAgIC8vIHdlIHdhbnQgdGhlIGVycm9yIHRvIGJlIG1hcmtlZCB1cCBpbiB0aGUgZmllbGQgdGV4dGFyZWFcbiAgICAgICAgaWYoYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmlucHV0LnN0YXJ0c1dpdGgoXCJvbiBkb0l0XCIpKXtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFNlbmRlck1vZGVsID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbYU1lc3NhZ2UucGFydElkXTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZ2V0IHRoZSBvcmlnaW5hbCB0ZXh0IHNvIGFzIG5vdCB0byBjb21wbGV0ZWx5IHJlcGxhY2UgaXRcbiAgICAgICAgICAgIC8vIHRoZW4gaW5zZXJ0IHRoZSBtYXJrdXAgaW4gdGhlIGFwcHJvcHJpYXRlIGxpbmVcbiAgICAgICAgICAgIGxldCBmaWVsZFRleHQgPSBvcmlnaW5hbFNlbmRlck1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQob3JpZ2luYWxTZW5kZXJNb2RlbCwgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgbGV0IHNjcmlwdCA9IGFNZXNzYWdlLnBhcnNlZFNjcmlwdC5pbnB1dDtcbiAgICAgICAgICAgIHNjcmlwdCA9IHRoaXMuX2NsZWFuRG9JdFNDcmlwdChzY3JpcHQpO1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgXCJkb0l0XCIgaGFuZGxlciBpbnNlcnRlZCBiYWNrIGluLCBzaW5jZSBpdCdzIGp1c3QgYSBoaWRkZW4gd3JhcHBlciBmb3IgdGhlXG4gICAgICAgICAgICAvLyBzdGF0ZW1lbnQgbGluZXNcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLl9jbGVhbkRvSXRTQ3JpcHQodGV4dCk7XG4gICAgICAgICAgICBmaWVsZFRleHQgPSBmaWVsZFRleHQucmVwbGFjZShzY3JpcHQsIHRleHQpO1xuICAgICAgICAgICAgb3JpZ2luYWxTZW5kZXJNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG9yaWdpbmFsU2VuZGVyTW9kZWwsIFwidGV4dFwiLCBmaWVsZFRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmlyc3QgbG9jYXRlIHRoZSBzY3JpcHQgZWRpdG9yIGluIHF1ZXN0aW9uXG4gICAgICAgICAgICBsZXQgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChhTWVzc2FnZS5wYXJ0SWQpO1xuICAgICAgICAgICAgaWYoIXNjcmlwdEVkaXRvcil7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3BlblNjcmlwdEVkaXRvcihhTWVzc2FnZS5wYXJ0SWQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVkaXRvciA9IHdpbmRvdy5TeXN0ZW0uZmluZFNjcmlwdEVkaXRvckJ5VGFyZ2V0SWQoYU1lc3NhZ2UucGFydElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcmlwdEVkaXRvci5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNjcmlwdEVkaXRvci5tb2RlbCwgXCJ0ZXh0XCIsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wZW4gdGhlIGdyYW1tYXIgaWYgdGhlcmUgaXMgbm90IG9uZSBvcGVuIGFscmVhZHlcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkID0gd2luZG93LlN5c3RlbS5nZXRDdXJyZW50Q2FyZE1vZGVsKCk7XG4gICAgICAgIGxldCBncmFtbWFyID0gY3VycmVudENhcmQuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHBhcnQudHlwZSA9PSBcImZpZWxkXCIpICYmIChwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQocGFydCwgXCJuYW1lXCIpID09IFwiU2ltcGxlVGFsa1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGdyYW1tYXIubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgdGhpcy5fb3BlbkdyYW1tYXIoYU1lc3NhZ2UucGFydElkLCBydWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlTWVzc2FnZU5vdFVuZGVyc3Rvb2QoYU1lc3NhZ2Upe1xuICAgICAgICBsZXQgb2ZmZW5kaW5nTWVzc2FnZSA9IGFNZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgIGxldCBvcmlnaW5hbFNlbmRlciA9IG9mZmVuZGluZ01lc3NhZ2Uuc2VuZGVyc1swXTtcbiAgICAgICAgLy8gQXJlIHdlIGV2ZXIgZ29pbmcgdG8gaGF2ZSBNTlUgZXJyb3JzIG9uIG1lc3NhZ2VzIHRoYXRcbiAgICAgICAgLy8gYXJlIG5vdCB0eXBlOiBjb21tYW5kP1xuICAgICAgICBpZihvZmZlbmRpbmdNZXNzYWdlLnR5cGUgPT09IFwiY29tbWFuZFwiKXtcbiAgICAgICAgICAgIGxldCBjb21tYW5kTmFtZSA9IG9mZmVuZGluZ01lc3NhZ2UuY29tbWFuZE5hbWU7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTZW5kZXJNb2RlbCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW29yaWdpbmFsU2VuZGVyLmlkXTtcbiAgICAgICAgICAgIGxldCByZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxzKiR7Y29tbWFuZE5hbWV9KFxcc3xcXG58JClgLCAnZycpO1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IGV4ZWN1dGlvblN0YWNrID0gd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5fc3RhY2s7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgbWVzc2FnZSBpbiB0aGUgZXhlY3V0aW9uIHN0YWNrIGlzIFwiZG9JdFwiIHRoZW4gdGhlIHN0YXRlbWVudExpbmVzIGFyZVxuICAgICAgICAgICAgLy8gbG9jYXRlZCBpbiB0aGUgY29ycmVzcG9uZGluZyBmaWVsZCB0ZXh0LCBub3QgdGhlIHNjcmlwdCwgcHJvcGVydHkgYW5kXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRoZSBlcnJvciB0byBiZSBtYXJrZWQgdXAgaW4gdGhlIGZpZWxkIHRleHRhcmVhXG4gICAgICAgICAgICBpZihleGVjdXRpb25TdGFja1swXSAmJiBleGVjdXRpb25TdGFja1swXS5tZXNzYWdlTmFtZSA9PSBcImRvSXRcIil7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZXhlY3V0aW9uU3RhY2tbMF0ucGFydDtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQob3JpZ2luYWxTZW5kZXJNb2RlbCwgJ3RleHQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IG9yaWdpbmFsU2VuZGVyTW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvcmlnaW5hbFNlbmRlck1vZGVsLCAnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgbGV0IHNjcmlwdEVkaXRvciA9IHdpbmRvdy5TeXN0ZW0uZmluZFNjcmlwdEVkaXRvckJ5VGFyZ2V0SWQob3JpZ2luYWxTZW5kZXIuaWQpO1xuICAgICAgICAgICAgICAgIGlmKCFzY3JpcHRFZGl0b3Ipe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuU2NyaXB0RWRpdG9yKG9yaWdpbmFsU2VuZGVyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChvcmlnaW5hbFNlbmRlci5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHNjcmlwdEVkaXRvcil7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHNjcmlwdEVkaXRvci5tb2RlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIFNvcnQgdGhpcyBvdXRcbiAgICAgICAgICAgIGlmKHRhcmdldCl7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRMaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgLy8gb2ZmZW5kaW5nIGNvbW1hbmQgdGV4dCBsaW5lIHdpdGggYW4gZXJyb3IgbWFya2VyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dExpbmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZihsaW5lLm1hdGNoKHJlZ2V4KSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZXNbaV0gPSBsaW5lICs9IGAgLS08PDxbTWVzc2FnZU5vdFVuZGVyc3Rvb2Q6IGNvbW1hbmQ7IGNvbW1hbmROYW1lOiBcIiR7Y29tbWFuZE5hbWV9XCJdYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dExpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcInRleHRcIiwgdGV4dCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpbmFsbHkgb3BlbiB0aGUgZGVidWdnZXIgKG9yIGN1cnJlbnQgdmVyc2lvbiB0aGVyZW9mKVxuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBpcyBhIGJpdCBkYW5nZXJvdXMsIGIvYyBpZiB0aGUgU3lzdGVtIGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgYG9wZW5EZWJ1Z2dlcmAgY29tbWFuZCBhbnl3aGVyZSBpdCB3aWxsIHRocm93XG4gICAgICAgICAgICAvLyBhIE1OVSBlcnJvciwgd2hpY2ggd2lsbCB0aGVuIGludm9rZSB0aGlzIGhhbmRsZXIgY3Vhc2luZ1xuICAgICAgICAgICAgLy8gYW4gaW5maW5pdGUgbG9vcCFcbiAgICAgICAgICAgIHRoaXMuX29wZW5EZWJ1Z2dlcihvcmlnaW5hbFNlbmRlci5pZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFuRG9JdFNDcmlwdChzY3JpcHQpe1xuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgRG9JdCBzY3JpcHQgYnkgcmVtb3ZpbmcgdGhlIGhhbmRsZXJcbiAgICAgICAgLy8gbmV3bGluZXMsIHRhYnMgYW5kIHNwYWNlc1xuICAgICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShcIm9uIGRvSXRcIiwgXCJcIik7XG4gICAgICAgIHNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlKFwiZW5kIGRvSXRcIiwgXCJcIik7XG4gICAgICAgIHNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlKC9eW1xcblxcdCBdKy8sIFwiXCIpO1xuICAgICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZSgvW1xcblxcdCBdKyQvLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdDtcbiAgICB9LFxuXG4gICAgX29wZW5TY3JpcHRFZGl0b3I6IGZ1bmN0aW9uKHBhcnRJZCl7XG4gICAgICAgIGxldCB0YXJnZXQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtwYXJ0SWRdO1xuICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBcImNvbW1hbmROYW1lXCI6IFwib3BlblNjcmlwdEVkaXRvclwiLFxuICAgICAgICAgICAgYXJnczogW3BhcnRJZF1cbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0LnNlbmRNZXNzYWdlKG1zZywgdGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgX29wZW5HcmFtbWFyOiBmdW5jdGlvbihwYXJ0SWQsIHJ1bGVOYW1lKXtcbiAgICAgICAgbGV0IHRhcmdldCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3BhcnRJZF07XG4gICAgICAgIGxldCBzdGF0ZW1lbnRMaW5lcyA9IFtcbiAgICAgICAgICAgICdpZiB0aGVyZSBpcyBub3QgYSBmaWVsZCBcIlNpbXBsZVRhbGtcIiBvZiBjdXJyZW50IGNhcmQnLFxuICAgICAgICAgICAgJ3RoZW4nLFxuICAgICAgICAgICAgJ2FkZCBmaWVsZCBcIlNpbXBsZVRhbGtcIiB0byBjdXJyZW50IGNhcmQnLFxuICAgICAgICAgICAgJ3RlbGwgZmllbGQgXCJTaW1wbGVUYWxrXCIgb2YgY3VycmVudCBjYXJkIHRvIHNldCBcImVkaXRhYmxlXCIgdG8gZmFsc2UnLFxuICAgICAgICAgICAgJ1NpbXBsZVRhbGsnLFxuICAgICAgICAgICAgJ3RlbGwgZmllbGQgXCJTaW1wbGVUYWxrXCJvZiBjdXJyZW50IGNhcmQgdG8gc2V0IFwidGV4dFwiIHRvIGl0JyxcbiAgICAgICAgICAgICdlbmQgaWYnXG4gICAgICAgIF07XG4gICAgICAgIGxldCBzY3JpcHQgPSBgb24gZG9JdFxcbiAgICR7c3RhdGVtZW50TGluZXMuam9pbignXFxuJyl9XFxuZW5kIGRvSXRgO1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21waWxlXCIsXG4gICAgICAgICAgICAgICAgY29kZVN0cmluZzogc2NyaXB0LFxuICAgICAgICAgICAgICAgIHRhcmdldElkOiB0YXJnZXQuaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgKTtcbiAgICAgICAgdGFyZ2V0LnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImRvSXRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8vIEF0IHRoZSBtb21lbnQgdGhpcyBzaW1wbHkgb3BlbnMgYSBzdC13aW5kb3cgc3QtZmllbGQgd2l0aFxuICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhdmFpbGFibGUgY29tbWFuZHMgZm9yIHNhaWQgcGFydHNcbiAgICBfb3BlbkRlYnVnZ2VyOiBmdW5jdGlvbihwYXJ0SWQpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbcGFydElkXTtcbiAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgXCJjb21tYW5kTmFtZVwiOiBcIm9wZW5EZWJ1Z2dlclwiLFxuICAgICAgICAgICAgYXJnczogW3BhcnRJZF1cbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0LnNlbmRNZXNzYWdlKG1zZywgdGFyZ2V0KTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIGVycm9ySGFuZGxlcixcbiAgICBlcnJvckhhbmRsZXIgYXMgZGVmYXVsdFxufTtcbiIsImNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbmNvbnN0IHNjYWxlRGltID0gKGRpbSkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gMC43O1xuICAgIGNvbnN0IHN0cmlkZSA9IDE2O1xuICAgIGNvbnN0IGV2ZW5SZXMgPSBkaW0gKiBzY2FsZSAtIDE7XG4gICAgcmV0dXJuIGV2ZW5SZXMgLSAoZXZlblJlcyAlIHN0cmlkZSkgKyAxO1xufTtcblxuY29uc3QgZGV0ZWN0SGFuZHMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBzY2FsZURpbShjYW52YXMud2lkdGgpO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IHNjYWxlRGltKGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29uc3QgaW1hZ2UgPSB0Zi50aWR5KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRmLmZyb21QaXhlbHMoY2FudmFzKS5yZXNpemVCaWxpbmVhcihbc2NhbGVkSGVpZ2h0LCBzY2FsZWRXaWR0aF0pLmV4cGFuZERpbXMoMCk7XG4gICAgfSk7XG4gICAgY29uc3QgW3Njb3JlcywgdGJveGVzXSA9IGF3YWl0IGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbk1vZGVsLmV4ZWN1dGVBc3luYyhpbWFnZSk7XG4gICAgaW1hZ2UuZGlzcG9zZSgpO1xuICAgIGNvbnN0IGhhbmRzRGV0ZWN0ZWQgPSB0Zi50aWR5KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRmLmltYWdlLm5vbk1heFN1cHByZXNzaW9uKFxuICAgICAgICAgICAgdGJveGVzLnJlc2hhcGUoW3Rib3hlcy5zaGFwZVsxXSwgdGJveGVzLnNoYXBlWzNdXSksXG4gICAgICAgICAgICBzY29yZXMucmVzaGFwZShbc2NvcmVzLnNoYXBlWzFdXSksXG4gICAgICAgICAgICAyMCxcbiAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgIDAuODUpLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBib3hlcyA9IFtdO1xuICAgICAgICB2YXIgaWR4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlkeCA9IGluZGljZXNbaV07XG4gICAgICAgICAgICB2YXIgc2NvcmUgPSBzY29yZXMuZ2V0KDAsIGlkeCwgMCk7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBvcmRlciBpcyBbbWluWSwgbWluWCwgbWF4WSwgbWF4WF0gc28gd2UgcmVvcmRlci5cbiAgICAgICAgICAgIHZhciBib3ggPSB7XG4gICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiBbdGJveGVzLmdldCgwLCBpZHgsIDAsIDEpLCB0Ym94ZXMuZ2V0KDAsIGlkeCwgMCwgMCldLFxuICAgICAgICAgICAgICAgIGxvd2VyUmlnaHQ6IFt0Ym94ZXMuZ2V0KDAsIGlkeCwgMCwgMyksIHRib3hlcy5nZXQoMCwgaWR4LCAwLCAyKV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBib3hlcy5wdXNoKHtzY29yZTogc2NvcmUsIGJveDogYm94fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtib3hlczogYm94ZXMsIHRpbWVzdGFtcDogRGF0ZS5ub3coKX07XG4gICAgfSk7XG4gICAgc2NvcmVzLmRpc3Bvc2UoKTtcbiAgICB0Ym94ZXMuZGlzcG9zZSgpO1xuICAgIGlmIChoYW5kc0RldGVjdGVkLmJveGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBpZiAoaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uUnVubmluZykge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkZXRlY3RIYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBib3ggPSBoYW5kc0RldGVjdGVkLmJveGVzWzBdLmJveDtcbiAgICBjb25zdCBbeDEsIHkxXSA9IGJveC51cHBlckxlZnQ7XG4gICAgY29uc3QgW3gyLCB5Ml0gPSBib3gubG93ZXJSaWdodDtcbiAgICBjb25zdCBhcmVhID0ge2FyZWE6ICh4MiAtIHgxKSAqICh5MiAtIHkxKSwgdGltZXN0YW1wOiBEYXRlLm5vdygpfTtcbiAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25BcmVhcyA9IFtdLmNvbmNhdChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25BcmVhcy5zbGljZSgtMiksIFthcmVhXSk7XG4gICAgLy8gVXBkYXRlIGhhbmQgbG9jYXRpb25cbiAgICBjb25zdCB2dyA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKVxuICAgIGNvbnN0IHZoID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCAwLCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMClcbiAgICBjb25zdCBwID0gWzAuNSAqICh4MSArIHgyKSAqIHZ3LCAwLjUgKiAoeTEgKyB5MikgKiB2aF07XG4gICAgaGFuZEludGVyZmFjZS5wb3NpdGlvbnMgPSBbXS5jb25jYXQoaGFuZEludGVyZmFjZS5wb3NpdGlvbnMuc2xpY2UoLTIpLCBbcF0pO1xuICAgIHZhciB0YXJnZXQgPSBoYW5kSW50ZXJmYWNlLnRhcmdldEVsZW1lbnQ7XG4gICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSBoYW5kSW50ZXJmYWNlLmxlbmluSGFuZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBhdmVyYWdlIHBvc2l0aW9uXG4gICAgY29uc3QgW3AxLCBwMiwgcDNdID0gaGFuZEludGVyZmFjZS5wb3NpdGlvbnM7XG4gICAgY29uc3QgW2FwMSwgYXAyXSA9IFsoMS8zKSoocDFbMF0gKyBwMlswXSArIHAzWzBdKSwgKDEvMykqKHAxWzFdICsgcDJbMV0gKyBwM1sxXSldO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRhcmdldCwgXCJsZWZ0XCIsIGFwMSk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcInRvcFwiLCBhcDIpO1xuICAgIC8vIEV4dHJhY3QgYXJlYSBpbmZvcm1hdGlvbiB3aXRob3V0IGFueSB0aW1lc3RhbXBzXG4gICAgdmFyIGp1c3RBcmVhcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uQXJlYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAganVzdEFyZWFzLnB1c2goaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uQXJlYXNbaV0uYXJlYSk7XG4gICAgfVxuICAgIHZhciBqdXN0QXJlYXMgPSBbXS5jb25jYXQoQXJyYXkoMyAtIGp1c3RBcmVhcy5sZW5ndGgpLmZpbGwoMCksIGp1c3RBcmVhcyk7XG4gICAgLy8gQ2hlY2sgaWYgaGFuZCBpcyBwdXNoaW5nIGluXG4gICAgY29uc3QgW2ExLCBhMiwgYTNdID0ganVzdEFyZWFzO1xuICAgIGNvbnN0IGF2ZUFyZWEgPSAoMS8zKSAqIChhMSArIGEyICsgYTMpO1xuICAgIGlmIChhdmVBcmVhID4gMC4yNSkge1xuICAgICAgICBpZiAoIWhhbmRJbnRlcmZhY2UuaGFuZE1hc2tlZCkge1xuICAgICAgICAgICAgaGFuZEludGVyZmFjZS5oYW5kTWFza2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBoYW5kSW50ZXJmYWNlLmhhbmRNYXNrZWQgPSBmYWxzZTsgfSwgMzAwMCk7XG4gICAgICAgICAgICBpZiAoaGFuZEludGVyZmFjZS50YXJnZXRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNsb3Nlc3RWaWV3ID0gZmluZENsb3Nlc3RWaWV3KFtwMSwgcDJdKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdFZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZEludGVyZmFjZS5sZW5pbkhhbmQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChoYW5kSW50ZXJmYWNlLmxlbmluSGFuZCwgXCJoaWRlXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnRhcmdldEVsZW1lbnQgPSBjbG9zZXN0Vmlldy5tb2RlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoaGFuZEludGVyZmFjZS5sZW5pbkhhbmQsIFwiaGlkZVwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaGFuZEludGVyZmFjZS50YXJnZXRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uUnVubmluZykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRldGVjdEhhbmRzKTtcbiAgICB9XG59O1xuXG5jb25zdCBmaW5kQ2xvc2VzdFZpZXcgPSAocG9pbnQpID0+IHtcbiAgICBsZXQgdmlld3MgPSBbXTtcbiAgICB3aW5kb3cuU3lzdGVtLmdldEN1cnJlbnRDYXJkTW9kZWwoKS5zdWJwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgIGxldCBwYXJ0Vmlld3MgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQocGFydC5pZCk7XG4gICAgICAgIHBhcnRWaWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHZhciBbY2xvc2VzdERpc3QsIGNsb3Nlc3RWaWV3XSA9IFtJbmZpbml0eSwgbnVsbF07XG4gICAgdmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICBsZXQgdmlld0Rpc3QgPSBkaXN0KHBvaW50LCBnZXRWZXJ0aWNlcyh2aWV3KSk7XG4gICAgICAgIGlmICh2aWV3RGlzdCA8IGNsb3Nlc3REaXN0KSB7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdCA9IHZpZXdEaXN0O1xuICAgICAgICAgICAgY2xvc2VzdFZpZXcgPSB2aWV3O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RWaWV3O1xufVxuXG4vLyBodHRwczovL2Fhcm9uc21pdGgub25saW5lL2Vhc2lseS1sb2FkLWFuLWV4dGVybmFsLXNjcmlwdC11c2luZy1qYXZhc2NyaXB0L1xuY29uc3QgbG9hZFNjcmlwdCA9IHNyYyA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cudGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbnNvcmZsb3dqcyBhbHJlYWR5IGxvYWRlZFwiKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcImxvYWRpbmcgdGVuc29yZmxvd2pzXCIpO1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZChzY3JpcHQpO1xuICAgIH0pO1xufTtcblxuY29uc3QgbG9hZEhhbmREZXRlY3Rpb25Nb2RlbCA9ICgpID0+IHtcbiAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25BcmVhcyA9IFtdO1xuICAgIGxvYWRTY3JpcHQoXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B0ZW5zb3JmbG93L3RmanNAMC4xMy41L2Rpc3QvdGYuanNcIikudGhlbigoKSA9PiB7XG4gICAgICAgIHdpbmRvdy50Zi5sb2FkRnJvemVuTW9kZWwoXG4gICAgICAgICAgICBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vaGFuZHRyYWNranMvbW9kZWxzL3dlYi9zc2RsaXRlbW9iaWxlbmV0djIvdGVuc29yZmxvd2pzX21vZGVsLnBiXCIsXG4gICAgICAgICAgICBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vaGFuZHRyYWNranMvbW9kZWxzL3dlYi9zc2RsaXRlbW9iaWxlbmV0djIvd2VpZ2h0c19tYW5pZmVzdC5qc29uXCJcbiAgICAgICAgKS50aGVuKG1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaGFuZCBkZXRlY3Rpb24gbW9kZWwgbG9hZGVkXCIpO1xuICAgICAgICAgICAgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uTW9kZWwgPSBtb2RlbDtcbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KTtcbiAgICAgICAgfSkudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInZpZGVvIHN0YXJ0ZWRcIik7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB2aWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgtMSwgMCwgMCwgMSwgY2FudmFzLndpZHRoLCAwKTsgLy8gTWlycm9yIGluY29taW5nIHZpZGVvXG4gICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kID0gd2luZG93LlN5c3RlbS5uZXdNb2RlbCgnaW1hZ2UnLCB3aW5kb3cuU3lzdGVtLmdldFdvcmxkU3RhY2tNb2RlbCgpLmlkLCBcIi9pbWFnZXMvbGVuaW5IYW5kLnBuZ1wiKTtcbiAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UudGFyZ2V0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRldGVjdEhhbmRzKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgbG9hZGluZyBoYW5kIGRldGVjdGlvbiBtb2RlbFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5jb25zdCB1bmxvYWRIYW5kRGV0ZWN0aW9uTW9kZWwgPSAoKSA9PiB7XG4gICAgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uUnVubmluZyA9IGZhbHNlO1xuICAgIHdpbmRvdy5TeXN0ZW0uZGVsZXRlTW9kZWwoaGFuZEludGVyZmFjZS5sZW5pbkhhbmQuaWQpXG4gICAgaGFuZEludGVyZmFjZS5sZW5pbkhhbmQgPSBudWxsO1xuICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgY29uc3QgdHJhY2tzID0gdmlkZW8uc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYWNrc1tpXS5zdG9wKCk7XG4gICAgfVxuICAgIHZpZGVvLnNyY09iamVjdCA9IG51bGw7XG4gICAgY29uc29sZS5sb2coXCJ2aWRlbyBzdG9wcGVkXCIpO1xuICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbk1vZGVsID0gbnVsbDtcbiAgICBjb25zb2xlLmxvZyhcInVubG9hZGluZyBoYW5kIGRldGVjdGlvbiBtb2RlbFwiKTtcbn1cblxuY29uc3QgZ2V0VmVydGljZXMgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHVwcGVyTGVmdCA9IFtyZWN0LngsIHJlY3QueV07XG4gICAgY29uc3QgdXBwZXJSaWdodCA9IFtyZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnldO1xuICAgIGNvbnN0IGxvd2VyTGVmdCA9IFtyZWN0LngsIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcbiAgICBjb25zdCBsb3dlclJpZ2h0ID0gW3JlY3QueCArIHJlY3Qud2lkdGgsIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cHBlckxlZnQ6IHVwcGVyTGVmdCxcbiAgICAgICAgdXBwZXJSaWdodDogdXBwZXJSaWdodCxcbiAgICAgICAgbG93ZXJMZWZ0OiBsb3dlckxlZnQsXG4gICAgICAgIGxvd2VyUmlnaHQ6IGxvd2VyUmlnaHRcbiAgICB9O1xufVxuXG5jb25zdCBkaXN0ID0gKHBvaW50LCB2ZXJ0aWNlcykgPT4ge1xuICAgIGNvbnN0IFtwMSwgcDJdID0gcG9pbnQ7XG4gICAgY29uc3QgW3VsMSwgdWwyXSA9IHZlcnRpY2VzLnVwcGVyTGVmdDtcbiAgICBjb25zdCBbbGwxLCBsbDJdID0gdmVydGljZXMubG93ZXJMZWZ0O1xuICAgIGNvbnN0IFt1cjEsIHVyMl0gPSB2ZXJ0aWNlcy51cHBlclJpZ2h0O1xuICAgIGNvbnN0IFtscjEsIGxyMl0gPSB2ZXJ0aWNlcy5sb3dlclJpZ2h0O1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICAgIC8vIE5leHQgd2UgY29tcHV0ZSB0aGUgdmVjdG9yIHBvaW50aW5nIGZyb20gdGhlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50XG4gICAgLy8gb24gdGhlIHJlY3RhbmdsZS4gVGhlcmUgYXJlIDkgY2FzZXMuIFRoZSBmaXJzdCBpcyB3aGVuIHRoZSBwb2luc3QgaXNcbiAgICAvLyBpbnNpZGUgdGhlIHJlY3RhbmdsZS4gVGhlIG5leHQgZm91ciBjYXNlcyBhcmUgaWYgdGhlIHBvaW50IGluIG9uZSBvZlxuICAgIC8vIHRoZSBmb3VyIGNvcm5lcnMgYW5kIHRoZSBmaW5hbCBmb3VyIGNhc2VzIGFyZSB3aGVuIHRoZSBwb2ludCBpcyBvbiBvbmVcbiAgICAvLyBvZiB0aGUgZm91ciBzaWRlcy5cbiAgICB2YXIgW3YxLCB2Ml0gPSBbbnVsbCwgbnVsbF07XG4gICAgaWYgKCh1bDEgPD0gcDEpICYmIChwMSA8PSBscjEpICYmICh1bDIgPD0gcDIpICYmIChwMiA8PSBscjIpKSB7XG4gICAgICAgIC8vIENhc2UgMDogaW5zaWRlIHRoZSByZWN0YW5nbGVcbiAgICAgICAgW3YxLCB2Ml0gPSBbMCwgMF07XG4gICAgfSBlbHNlIGlmICgocDEgPD0gdWwxKSAmJiAocDIgPD0gdWwyKSkge1xuICAgICAgICAvLyBDYXNlIDE6IHVwcGVyIGxlZnRcbiAgICAgICAgW3YxLCB2Ml0gPSBbdWwxIC0gcDEsIHVsMiAtIHAyXTtcbiAgICB9IGVsc2UgaWYgKChwMSA+PSB1cjEpICYmIChwMiA8PSB1cjIpKSB7XG4gICAgICAgIC8vIENhc2UgMjogdXBwZXIgcmlnaHRcbiAgICAgICAgW3YxLCB2Ml0gPSBbdXIxIC0gcDEsIHVyMiAtIHAyXTtcbiAgICB9IGVsc2UgaWYgKChwMSA8PSBsbDEpICYmIChwMiA+PSBsbDIpKSB7XG4gICAgICAgIC8vIENhc2UgMzogbG93ZXIgbGVmdFxuICAgICAgICBbdjEsIHYyXSA9IFtsbDEgLSBwMSwgbGwyIC0gcDJdO1xuICAgIH0gZWxzZSBpZiAoKHAxID49IGxyMSkgJiYgKHAyID49IGxyMikpIHtcbiAgICAgICAgLy8gQ2FzZSA0OiBsb3dlciByaWdodFxuICAgICAgICBbdjEsIHYyXSA9IFtscjEgLSBwMSwgbHIyIC0gcDJdO1xuICAgIH0gZWxzZSBpZiAocDEgPD0gdWwxKSB7XG4gICAgICAgIC8vIENhc2UgNTogc2lkZSBsZWZ0XG4gICAgICAgIFt2MSwgdjJdID0gW3VsMSAtIHAxLCAwXTtcbiAgICB9IGVsc2UgaWYgKHAxID49IGxyMSkge1xuICAgICAgICAvLyBDYXNlIDY6IHNpZGUgcmlnaHRcbiAgICAgICAgW3YxLCB2Ml0gPSBbbHIxIC0gcDEsIDBdO1xuICAgIH0gZWxzZSBpZiAocDIgPD0gdWwyKSB7XG4gICAgICAgIC8vIENhc2UgNzogc2lkZSB0b3BcbiAgICAgICAgW3YxLCB2Ml0gPSBbMCwgdWwyIC0gcDJdO1xuICAgIH0gZWxzZSBpZiAocDIgPj0gbHIyKSB7XG4gICAgICAgIC8vIENhc2UgODogc2lkZSBib3R0b21cbiAgICAgICAgW3YxLCB2Ml0gPSBbMCwgbHIyIC0gcDJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhc2UgOTogaW5zaWRlXG4gICAgICAgIFt2MSwgdjJdID0gWzAsIDBdO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHYxKnYxICsgdjIqdjIpO1xufVxuXG5jbGFzcyBIYW5kSW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kRGV0ZWN0aW9uTW9kZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmREZXRlY3Rpb25SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuaW5IYW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kTWFza2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZERldGVjdGlvbkFyZWFzID0gW107XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gW1swLCAwXSwgWzAsIDBdLCBbMCwgMF1dO1xuICAgICAgICAvLyBYWFggLSBPbmx5IGhlcmUgdG8gaWdub3JlIHRoZSB0ZW5zb3JmbG93IHdhcm5pbmdzXG4gICAgICAgIGNvbnNvbGUud2FybiA9ICgpID0+IHt9O1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICBsb2FkSGFuZERldGVjdGlvbk1vZGVsKCk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdW5sb2FkSGFuZERldGVjdGlvbk1vZGVsKCk7XG4gICAgfVxufVxuXG5jb25zdCBUZXN0YWJsZXMgPSB7XG4gICAgZGlzdDogZGlzdFxufVxuXG5jb25zdCBoYW5kSW50ZXJmYWNlID0gbmV3IEhhbmRJbnRlcmZhY2UoKTtcblxuZXhwb3J0IHtcbiAgICBUZXN0YWJsZXMsXG4gICAgaGFuZEludGVyZmFjZSxcbiAgICBoYW5kSW50ZXJmYWNlIGFzIGRlZmF1bHRcbn07XG4iLCJsZXQgcGFydEljb25zID0ge307XG5cbnBhcnRJY29ucy53b3JsZCA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci13b3JsZFwiIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI0NFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMmMzZTUwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiOVwiIC8+XG4gIDxsaW5lIHgxPVwiMy42XCIgeTE9XCI5XCIgeDI9XCIyMC40XCIgeTI9XCI5XCIgLz5cbiAgPGxpbmUgeDE9XCIzLjZcIiB5MT1cIjE1XCIgeDI9XCIyMC40XCIgeTI9XCIxNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTEuNSAzYTE3IDE3IDAgMCAwIDAgMThcIiAvPlxuICA8cGF0aCBkPVwiTTEyLjUgM2ExNyAxNyAwIDAgMSAwIDE4XCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLnN0YWNrID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXN0YWNrXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjEyIDQgNCA4IDEyIDEyIDIwIDggMTIgNFwiIC8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCI0IDEyIDEyIDE2IDIwIDEyXCIgLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjQgMTYgMTIgMjAgMjAgMTZcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuY2FyZCA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zcXVhcmVcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzJjM2U1MFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cmVjdCB4PVwiNFwiIHk9XCI0XCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgcng9XCIyXCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmJ1dHRvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1oYW5kLWZpbmdlclwiIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI0NFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMmMzZTUwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNOCAxM3YtOC41YTEuNSAxLjUgMCAwIDEgMyAwdjcuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTEgMTEuNXYtMmExLjUgMS41IDAgMSAxIDMgMHYyLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDEwLjVhMS41IDEuNSAwIDAgMSAzIDB2MS41XCIgLz5cbiAgPHBhdGggZD1cIk0xNyAxMS41YTEuNSAxLjUgMCAwIDEgMyAwdjQuNWE2IDYgMCAwIDEgLTYgNmgtMmguMjA4YTYgNiAwIDAgMSAtNS4wMTIgLTIuN2E2OS43NCA2OS43NCAwIDAgMSAtLjE5NiAtLjNjLS4zMTIgLS40NzkgLTEuNDA3IC0yLjM4OCAtMy4yODYgLTUuNzI4YTEuNSAxLjUgMCAwIDEgLjUzNiAtMi4wMjJhMS44NjcgMS44NjcgMCAwIDEgMi4yOCAuMjhsMS40NyAxLjQ3XCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLndpbmRvdyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci13aW5kb3dcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEyIDNjLTMuODY2IDAgLTcgMy4yNzIgLTcgN3YxMGExIDEgMCAwIDAgMSAxaDEyYTEgMSAwIDAgMCAxIC0xdi0xMGMwIC0zLjcyOCAtMy4xMzQgLTcgLTcgLTd6XCIgLz5cbiAgPGxpbmUgeDE9XCI1XCIgeTE9XCIxM1wiIHgyPVwiMTlcIiB5Mj1cIjEzXCIgLz5cbiAgPGxpbmUgeDE9XCIxMlwiIHkxPVwiM1wiIHgyPVwiMTJcIiB5Mj1cIjIxXCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmFyZWEgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc2hhcGVcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8Y2lyY2xlIGN4PVwiNVwiIGN5PVwiNVwiIHI9XCIyXCIgLz5cbiAgPGNpcmNsZSBjeD1cIjE5XCIgY3k9XCI1XCIgcj1cIjJcIiAvPlxuICA8Y2lyY2xlIGN4PVwiNVwiIGN5PVwiMTlcIiByPVwiMlwiIC8+XG4gIDxjaXJjbGUgY3g9XCIxOVwiIGN5PVwiMTlcIiByPVwiMlwiIC8+XG4gIDxsaW5lIHgxPVwiNVwiIHkxPVwiN1wiIHgyPVwiNVwiIHkyPVwiMTdcIiAvPlxuICA8bGluZSB4MT1cIjdcIiB5MT1cIjVcIiB4Mj1cIjE3XCIgeTI9XCI1XCIgLz5cbiAgPGxpbmUgeDE9XCI3XCIgeTE9XCIxOVwiIHgyPVwiMTdcIiB5Mj1cIjE5XCIgLz5cbiAgPGxpbmUgeDE9XCIxOVwiIHkxPVwiN1wiIHgyPVwiMTlcIiB5Mj1cIjE3XCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmZpZWxkID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWZvcm1zXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMiAzYTMgMyAwIDAgMCAtMyAzdjEyYTMgMyAwIDAgMCAzIDNcIiAvPlxuICA8cGF0aCBkPVwiTTYgM2EzIDMgMCAwIDEgMyAzdjEyYTMgMyAwIDAgMSAtMyAzXCIgLz5cbiAgPHBhdGggZD1cIk0xMyA3aDdhMSAxIDAgMCAxIDEgMXY4YTEgMSAwIDAgMSAtMSAxaC03XCIgLz5cbiAgPHBhdGggZD1cIk01IDdoLTFhMSAxIDAgMCAwIC0xIDF2OGExIDEgMCAwIDAgMSAxaDFcIiAvPlxuICA8cGF0aCBkPVwiTTE3IDEyaC4wMVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTMgMTJoLjAxXCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmRyYXdpbmcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcGFsZXR0ZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTIgMjFhOSA5IDAgMSAxIDAgLTE4YTkgOCAwIDAgMSA5IDhhNC41IDQgMCAwIDEgLTQuNSA0aC0yLjVhMiAyIDAgMCAwIC0xIDMuNzVhMS4zIDEuMyAwIDAgMSAtMSAyLjI1XCIgLz5cbiAgPGNpcmNsZSBjeD1cIjcuNVwiIGN5PVwiMTAuNVwiIHI9XCIuNVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiAvPlxuICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjcuNVwiIHI9XCIuNVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiAvPlxuICA8Y2lyY2xlIGN4PVwiMTYuNVwiIGN5PVwiMTAuNVwiIHI9XCIuNVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuaW1hZ2UgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcGhvdG9cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8bGluZSB4MT1cIjE1XCIgeTE9XCI4XCIgeDI9XCIxNS4wMVwiIHkyPVwiOFwiIC8+XG4gIDxyZWN0IHg9XCI0XCIgeT1cIjRcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjNcIiAvPlxuICA8cGF0aCBkPVwiTTQgMTVsNCAtNGEzIDUgMCAwIDEgMyAwbDUgNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTRsMSAtMWEzIDUgMCAwIDEgMyAwbDIgMlwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5nZW5lcmljID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXB1enpsZVwiIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI0NFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMmMzZTUwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNNCA3aDNhMSAxIDAgMCAwIDEgLTF2LTFhMiAyIDAgMCAxIDQgMHYxYTEgMSAwIDAgMCAxIDFoM2ExIDEgMCAwIDEgMSAxdjNhMSAxIDAgMCAwIDEgMWgxYTIgMiAwIDAgMSAwIDRoLTFhMSAxIDAgMCAwIC0xIDF2M2ExIDEgMCAwIDEgLTEgMWgtM2ExIDEgMCAwIDEgLTEgLTF2LTFhMiAyIDAgMCAwIC00IDB2MWExIDEgMCAwIDEgLTEgMWgtM2ExIDEgMCAwIDEgLTEgLTF2LTNhMSAxIDAgMCAxIDEgLTFoMWEyIDIgMCAwIDAgMCAtNGgtMWExIDEgMCAwIDEgLTEgLTF2LTNhMSAxIDAgMCAxIDEgLTFcIiAvPlxuPC9zdmc+XG5gO1xuXG5leHBvcnQge1xuICAgIHBhcnRJY29ucyxcbiAgICBwYXJ0SWNvbnMgYXMgZGVmYXVsdFxufTtcbiIsIi8vIElEIHJlbGF0ZWQgdXRpbGl0aWVzXG5cbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuXG4vKipcbiAqIElEIE1ha2VyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGdsb2JhbGx5XG4gKiB1bmlxdWUgSUQgdmFsdWVzIGZvciBQYXJ0cyBpbiB0aGUgU2ltcGxlVGFsa1xuICogd29ybGQuXG4gKiBIQyByZXF1aXJlcyB0aGF0IGFsbCBQYXJ0cyBoYXZlIHVuaXF1ZSBpZHMgYW5kXG4gKiB0aGF0IHRoZXNlIHNob3VsZCBub3QgYmUgcmVwZWF0ZWQgaW4gYW55IGdpdmVuXG4gKiBcImFwcGxpY2F0aW9uXCIgaW5zdGFuY2UuXG4gKiBXZSBuZWVkIHRvIGRldGVybWluZSB3aGF0IGFuIFwiYXBwbGljYXRpb25cIiBpc1xuICogaW4gb3VyIGNvbnRleHQsIGJ1dCByZWdhcmRsZXNzIHdlIGNhbiB1c2UgdGhpc1xuICogbW9kdWxlIGFzIGEgZHJvcCBpbiByZXBsYWNlbWVudCwgaW1wbGVtZW50aW5nXG4gKiBVVUlEcyBvciBVUkxzIG9yIHdoYXRldmVyIHdlIHdhbnQuXG4gKiBGb3Igbm93IHdlIGp1c3QgaW5jcmVtZW50IGFuIGludGVnZXIuXG4gKi9cbmNvbnN0IGlkTWFrZXIgPSB7XG4gICAgbmV3OiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgaWQgPSB1dWlkdjQoKTtcbiAgICAgICAgcmV0dXJuIGlkLnJlcGxhY2UoLy0vZywgJycpO1xuICAgIH1cbn07XG5cbi8qIElEIGNoZWNrZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIHJlc3BvbnNpYmxlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIGlkIGlzXG4gKiBpcyB2YWxpZCBhbmQgcmV0dXJuaW5nIGl0IGlmIHNvXG4gKi9cbmNvbnN0IGlzVmFsaWRJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgaWYoaWQgPT09IG51bGwgfHwgaWQgPT09IHVuZGVmaW5lZCB8fCBpZCA9PT0gXCJcIil7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYoaWQubGVuZ3RoICE9IDMyIHx8IGlkLm1hdGNoKCdbYS16MC05XSonKVswXS5sZW5ndGggIT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnQge1xuICAgIGlkTWFrZXIsXG4gICAgaXNWYWxpZElkLFxuICAgIGlkTWFrZXIgYXMgZGVmYXVsdFxufTtcbiIsImNvbnN0IG1lcnJpYW1TaW1TY29yZSA9IGFzeW5jIChzZW5kZXIsIGRvY0lkKSA9PiB7XG4gICAgY29uc3QgdXJsID0gXCJodHRwczovL3BhdGVudHMubWVycmlhbXRlY2guY29tL19hcGkvbWVycmlhbS9cIlxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIFwiZmllbGRzXCI6IFtcbiAgICAgICAgICAgIFwidGl0bGVcIixcbiAgICAgICAgICAgIFwiZGF0ZV9wdWJsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ3ZWlnaHRzXCI6IHtcbiAgICAgICAgICAgIFwibWVycmlhbVwiOjAuNyxcbiAgICAgICAgICAgIFwiZGF0ZVwiOjAuMyxcbiAgICAgICAgICAgIFwiaGllcmFyY2h5XCI6MC4xXG4gICAgICAgIH0sXG4gICAgICAgIFwiZG9jX2lkc1wiOiBbXG4gICAgICAgICAgICBkb2NJZFxuICAgICAgICBdLFxuICAgICAgICBcImxpbWl0XCI6IDV9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJoZWFkZXJzXCI6IHtcbiAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYm9keVwiOiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKVxuICAgIH1cbiAgICBmZXRjaCh1cmwsIHBhcmFtcykudGhlbihkYXRhID0+IHtcbiAgICAgICAgcmV0dXJuIGRhdGEuanNvbigpO1xuICAgIH0pLnRoZW4oanNvbiA9PiB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbWVycmlhbXJlc3VsdCcsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgc2VuZGVyLnNlbmRNZXNzYWdlKG1zZywgc2VuZGVyKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHtcbiAgICBtZXJyaWFtU2ltU2NvcmUsXG4gICAgbWVycmlhbVNpbVNjb3JlIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFNlcmlhbGl6YXRpb24gYW5kIERlc2VyaWFsaXphdGlvbiBVdGlsaXR5IENsYXNzZXNcbiAqL1xuaW1wb3J0IGlkTWFrZXIgZnJvbSAnLi9pZC5qcyc7XG5cbmNvbnN0IHZlcnNpb24gPSBcIjAuMC4yXCI7XG5cbmNsYXNzIFNURGVzZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihhU3lzdGVtKXtcbiAgICAgICAgdGhpcy5zeXN0ZW0gPSBhU3lzdGVtO1xuXG4gICAgICAgIC8vIFRoZXNlIGNhY2hlcyBhcmUgdXNlZCBkdXJpbmcgdGhlIHByb2Nlc3NcbiAgICAgICAgLy8gYXMgb3B0aW1pemF0aW9uc1xuICAgICAgICB0aGlzLl9tb2RlbENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3N1YnBhcnRNYXBDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9pZENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2luc3RhbmNlQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJvcHNDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl92aWV3c0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3NjcmlwdENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3Jvb3RzQ2FjaGUgPSBbXTtcblxuICAgICAgICAvLyBUaGUgdGFyZ2V0SWQgaXMgdGhlIGlkIG9mXG4gICAgICAgIC8vIHRoZSBQYXJ0IHRoYXQgd2Ugd2lzaCB0byBhcHBlbmQgYW55XG4gICAgICAgIC8vIGRlc2VyaWFsaXplZCBzdWJwYXJ0IHRyZWUgaW50by5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCB3ZSBhc3N1bWUgdGhlIHdob2xlIHN5c3RlbSxcbiAgICAgICAgLy8gaWUgZnVsbCBkZXNlcmlhbGl6YXRpb24uXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSAnc3lzdGVtJztcbiAgICAgICAgLy8gdGhlIHJvb3QgaWQgaXMgdGhlIGlkIG9mIHRoZSByb290IHBhcnQgaW5zdGFuY2VcbiAgICAgICAgLy8gYmVpbmcgYXR0YWNoZWRcbiAgICAgICAgdGhpcy5yb290SWQgPSBudWxsO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IHRoaXMuZGVzZXJpYWxpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZURhdGEgPSB0aGlzLmRlc2VyaWFsaXplRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplUGFydCA9IHRoaXMuZGVzZXJpYWxpemVQYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXR0YWNoU3VicGFydHMgPSB0aGlzLmF0dGFjaFN1YnBhcnRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyA9IHRoaXMuc2V0UHJvcGVydGllcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZpZXcgPSB0aGlzLmNyZWF0ZVZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hdHRhY2hWaWV3ID0gdGhpcy5hdHRhY2hWaWV3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Vmlld01vZGVsID0gdGhpcy5zZXRWaWV3TW9kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb21waWxlUGFydFNjcmlwdCA9IHRoaXMuY29tcGlsZVBhcnRTY3JpcHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoV29ybGQgPSB0aGlzLnJlZnJlc2hXb3JsZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFwcGVuZFdvcmxkID0gdGhpcy5hcHBlbmRXb3JsZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFBhcnRzVG9TeXN0ZW0gPSB0aGlzLmFkZFBhcnRzVG9TeXN0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb21waWxlU2NyaXB0cyA9IHRoaXMuY29tcGlsZVNjcmlwdHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZSA9IHRoaXMuZ2V0RmxhdHRlbmVkUGFydFRyZWUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRNb2RlbENsYXNzID0gdGhpcy5nZXRNb2RlbENsYXNzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlSWQgPSB0aGlzLmhhbmRsZUlkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGhyb3dFcnJvciA9IHRoaXMudGhyb3dFcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZsdXNoQ2FjaGVzID0gdGhpcy5mbHVzaENhY2hlcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVmlld0FkZGVkID0gdGhpcy5kaXNwYXRjaFZpZXdBZGRlZC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGRlc2VyaWFsaXplKGFKU09OU3RyaW5nKXtcbiAgICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZShhSlNPTlN0cmluZyk7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN5c3RlbS5wYXJ0c0J5SWRbdGhpcy50YXJnZXRJZF07XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRGF0YSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGFsbCBkZXNlcmlhbGl6ZWQgUGFydHMgdG8gdGhlIFN5c3RlbSBkaWN0LFxuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGluZyB0aGUgbmV3IFdvcmxkLlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFydHNUb1N5c3RlbSh0aGlzLl9pbnN0YW5jZUNhY2hlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ29tcGlsZSB0aGUgc2NyaXB0cyBvbiAqYWxsKiBkZXNlcmlhbGl6ZWRcbiAgICAgICAgICAgICAgICAvLyBwYXJ0c1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZVNjcmlwdHModGhpcy5faW5zdGFuY2VDYWNoZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgcm9vdCBQYXJ0IGludG8gd2hhdGV2ZXJcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXQgc2hvdWxkIGdvIGludG8uXG4gICAgICAgICAgICAgICAgbGV0IHJvb3RQYXJ0ID0gdGhpcy5yb290UGFydHNbMF07XG4gICAgICAgICAgICAgICAgbGV0IHJvb3RWaWV3ID0gdGhpcy5yb290Vmlld3NbMF07XG4gICAgICAgICAgICAgICAgaWYodGhpcy50YXJnZXRJZCA9PSAnc3lzdGVtJyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFdvcmxkKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFkZFBhcnQocm9vdFBhcnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGFwcGVuZCB0aGUgUGFydFZpZXcgcm9vdCBub2RlXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgaXQgc2hvdWxkIGdvIGluIHRoZSB2aWV3IHRyZWUuXG4gICAgICAgICAgICAgICAgaWYodGhpcy50YXJnZXRJZCA9PSAnc3lzdGVtJyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kV29ybGQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHt0aGlzLnRhcmdldElkfVwiXWApO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWaWV3LmFwcGVuZENoaWxkKHJvb3RWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFZpZXdBZGRlZChyb290Vmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzZXJpYWxpemVEYXRhKCl7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ2FjaGVzKCk7XG4gICAgICAgICAgICAvLyBGaXJzdCwgd2UgZW5zdXJlIHRoYXQgdGhlIHRhcmdldCB3ZVxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGRlc2VyaWFsaXppbmcgaW50byBhY3R1YWxseSBleGlzdHNcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN5c3RlbS5wYXJ0c0J5SWRbdGhpcy50YXJnZXRJZF07XG4gICAgICAgICAgICBpZighdGFyZ2V0ICYmIHRoaXMudGFyZ2V0SWQgIT0gJ3N5c3RlbScpe1xuICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihgVGFyZ2V0IGlkICR7dGhpcy50YXJnZXRJZH0gZG9lcyBub3QgZXhpc3QgaW4gU3lzdGVtYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlY29uZCwgd2UgY3JlYXRlIGluc3RhbmNlcyBvZiBhbGwgbW9kZWxzIGluIHRoZSBzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICAvLyBidXQgd2UgZG8gbm90IHlldCBhdHRhY2ggdGhlaXIgc3VicGFydHMuXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuZGF0YS5wYXJ0cykuZm9yRWFjaChwYXJ0RGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZVBhcnQoT2JqZWN0LmFzc2lnbih7fSwgcGFydERhdGEpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgdGFyZ2V0c1xuICAgICAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLl9wcm9wc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3BzID0gdGhpcy5fcHJvcHNDYWNoZVttb2RlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG9sZElkIGluIHRoaXMuX2lkQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJZCA9IHRoaXMuX2lkQ2FjaGVbb2xkSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLnRhcmdldCA9PT0gJ3BhcnQgaWQgJyArIG9sZElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMudGFyZ2V0ID0gJ3BhcnQgaWQgJyArIG5ld0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHNjcmlwdHNcbiAgICAgICAgICAgIGZvciAobGV0IG1vZGVsSWQgaW4gdGhpcy5fc2NyaXB0Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NyaXB0ID0gdGhpcy5fc2NyaXB0Q2FjaGVbbW9kZWxJZF07XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdCAhPT0gbnVsbCAmJiBzY3JpcHQubWF0Y2goJ3BhcnQgaWQnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvbGRJZCBpbiB0aGlzLl9pZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SWQgPSB0aGlzLl9pZENhY2hlW29sZElkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGRSZSA9ICdwYXJ0IGlkICcgKyBvbGRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdSZSA9ICdwYXJ0IGlkICcgKyBuZXdJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zY3JpcHRDYWNoZVttb2RlbElkXS5tYXRjaChvbGRSZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtb2RlbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKG9sZFJlLCBcImdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NyaXB0Q2FjaGVbbW9kZWxJZF0gPSBzY3JpcHQucmVwbGFjZShyZSwgbmV3UmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlyZCwgd2UgZ28gdGhyb3VnaCBlYWNoIGNyZWF0ZWQgUGFydCBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gYW5kIGFkZCBhbnkgc3VicGFydHMgdG8gaXQuIE5vdGUgdGhhdCB0aGlzIGlzIG5vdFxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZUNhY2hlLmZvckVhY2gocGFydEluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFN1YnBhcnRzKHBhcnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRm9ydGggYW5kIGZpZnRoLiBDcmVhdGUgYW5kIGF0dGFjaCB2aWV3c1xuICAgICAgICAgICAgLy8gTm90ZSB0aGlzIGlzIHJlY3Vyc2l2ZSB0byBwcmVzZXJ2ZSB0aGUgc3VicGFydCArIHZpZXcgY2hpbGRyZW4gb3JkZXJcbiAgICAgICAgICAgIGxldCByb290ID0gdGhpcy5faW5zdGFuY2VDYWNoZS5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHBhcnQsIFwiaWRcIikgPT0gdGhpcy5yb290SWQ7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQW5kQXR0YWNoVmlld3Mocm9vdCk7XG5cbiAgICAgICAgICAgIC8vIFNpeHRoLCB3ZSBzZXQgYWxsIHByb3BlcnRpZXMgb24gZWFjaCBjcmVhdGVkXG4gICAgICAgICAgICAvLyBQYXJ0IG1vZGVsIGZyb20gdGhlIGRlc2VyaWFsaXplZCBkYXRhLlxuICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyB1c2luZyBhIHZpc2l0b3IgbWV0aG9kIG9uIHRoZSBpbnN0YW5jZXNcbiAgICAgICAgICAgIC8vIHRoZW1zZWx2ZXMuXG4gICAgICAgICAgICAvLyBUaGlzIGdpdmVzIHRoZSBpbi1tZW1vcnkgdmlld3MgdGhlIGFiaWxpdHkgdG9cbiAgICAgICAgICAgIC8vIHJlYWN0IHRvIGFueSBpbml0aWFsIGNoYW5nZXMgdG8gdGhlaXIgbW9kZWxzLlxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VDYWNoZS5mb3JFYWNoKHBhcnRJbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHBhcnRJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFuc2xhdGUgbmV3IGlkcyB0byBvbGQgb25lc1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0SW5zdGFuY2UubmFtZSA9PSBcIldvcmxkU3RhY2tcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd29ybGQgPSBwYXJ0SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faWRDYWNoZVt3b3JsZC5jdXJyZW50U3RhY2tJZF1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRJbnN0YW5jZS5uYW1lID09IFwiU3RhY2tcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBwYXJ0SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faWRDYWNoZVtzdGFjay5jdXJyZW50Q2FyZElkXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdNb2RlbChwYXJ0SW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFdlIGRldGVybWluZSB3aGljaCBvZiB0aGUgaW5zdGFuY2VzIGlzIGEgXCJyb290XCIsXG4gICAgICAgICAgICAvLyBtZWFuaW5nIHRoYXQgaXQgaGFzLCBhdCB0aGlzIHBvaW50LCBubyBvd25lciBpblxuICAgICAgICAgICAgLy8gdGhlIGRlc2VyaWFsaXplZCBkYXRhLiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgcm9vdHNcbiAgICAgICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIG11bHRpcGxlIHRyZWVzKSBpbiBhIHNpbmdsZSBkZXNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzQ2FjaGUgPSB0aGlzLl9pbnN0YW5jZUNhY2hlLmZpbHRlcihpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLl9vd25lciA9PSBudWxsIHx8IGluc3RhbmNlLl9vd25lciA9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW5zZXJ0aW9uIHNob3VsZCBiZSBoYW5kbGVkIGJ5IGNvbXBvc2VkXG4gICAgICAgICAgICAvLyBwcm9taXNlcyBlbHNld2hlcmUgKHNlZSBpbXBvcnRzIGFuZCBkZXNlcmlhbGl6ZSgpXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZXMpXG5cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjcmVhdGVBbmRBdHRhY2hWaWV3cyhwYXJ0SW5zdGFuY2Upe1xuICAgICAgICB0aGlzLmNyZWF0ZVZpZXcocGFydEluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5hdHRhY2hWaWV3KHBhcnRJbnN0YW5jZSk7XG4gICAgICAgIGlmKHBhcnRJbnN0YW5jZS5zdWJwYXJ0cy5sZW5ndGgpe1xuICAgICAgICAgICAgcGFydEluc3RhbmNlLnN1YnBhcnRzLmZvckVhY2goKHN1YnBhcnRJbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQW5kQXR0YWNoVmlld3Moc3VicGFydEluc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RnJvbVNlcmlhbGl6YXRpb24oYUpTT05TdHJpbmcsIGZpbHRlckZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZShhSlNPTlN0cmluZyk7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN5c3RlbS5wYXJ0c0J5SWRbdGhpcy50YXJnZXRJZF07XG4gICAgICAgIGxldCB0YXJnZXRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3RoaXMudGFyZ2V0SWR9XCJdYCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRGF0YSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIHByb3ZpZGUgYSBmaWx0ZXIgZnVuY3Rpb24gb3ZlclxuICAgICAgICAgICAgICAgIC8vIGFsbCBkZXNlcmlhbGl6ZWQgcGFydCBpbnN0YW5jZXMsIHJldHVybmluZyBvbmx5XG4gICAgICAgICAgICAgICAgLy8gdGhvc2UgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBhbGwgU3RhY2tzIGluIHRoZSBXb3JsZFN0YWNrLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZUNhY2hlLmZpbHRlcihmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJvb3RQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJvb3RQYXJ0cy5mb3JFYWNoKHJvb3RQYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbFRyZWVQYXJ0cyA9IHRoaXMuZ2V0RmxhdHRlbmVkUGFydFRyZWUocm9vdFBhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcnRzVG9TeXN0ZW0oYWxsVHJlZVBhcnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFBhcnRzO1xuXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJvb3RQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJvb3RQYXJ0cy5mb3JFYWNoKHJvb3RQYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbFRyZWVQYXJ0cyA9IHRoaXMuZ2V0RmxhdHRlbmVkUGFydFRyZWUocm9vdFBhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVTY3JpcHRzKGFsbFRyZWVQYXJ0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RQYXJ0cztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocm9vdFBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdFBhcnRzLmZvckVhY2gocm9vdFBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3ZpZXdzQ2FjaGVbcm9vdFBhcnQuaWRdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYWRkUGFydChyb290UGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZpZXcuYXBwZW5kQ2hpbGQodmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hWaWV3QWRkZWQodmlldyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXNlcmlhbGl6ZVBhcnQocGFydERhdGEpe1xuICAgICAgICBsZXQgcGFydENsYXNzID0gdGhpcy5nZXRNb2RlbENsYXNzKHBhcnREYXRhLnR5cGUpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgcGFydENsYXNzKCk7XG5cbiAgICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IElEIGZvciB0aGlzIHBhcnQsIHNpbmNlIHdlIGNhbm5vdFxuICAgICAgICAvLyBndWFyYW50ZWUgSUQgY2xhc2hlcyB3aXRoIHRoZSBleGlzdGluZyBTeXN0ZW0uXG4gICAgICAgIC8vIEV4Y2VwdGlvbiBpcyBpZiB0aGUgdXNlT3JpZ2luYWxpZHMgZmxhZyBpcyBzZXQsXG4gICAgICAgIC8vIHN1Y2ggYXMgYXQgbG9hZCB0aW1lXG4gICAgICAgIGxldCB7bmV3SWQsIG9sZElkfSA9IHRoaXMuaGFuZGxlSWQoaW5zdGFuY2UsIHBhcnREYXRhKTtcbiAgICAgICAgaW5zdGFuY2UuaWQgPSBuZXdJZDtcbiAgICAgICAgLy8gY2FjaGUgdGhlIG5ldyByb290IElEIGlmIHRoaXMgaXMgYSByb290IGluc3RhbmNlXG4gICAgICAgIGlmKHRoaXMuZGF0YS5yb290SWQgPT0gb2xkSWQpe1xuICAgICAgICAgICAgdGhpcy5yb290SWQgPSBuZXdJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0byBvdXIgY2FjaGVzIGFuZCBhbHNvIHRvIHRoZSBTeXN0ZW1cbiAgICAgICAgdGhpcy5faWRDYWNoZVtvbGRJZF0gPSBuZXdJZDtcbiAgICAgICAgdGhpcy5fc2NyaXB0Q2FjaGVbbmV3SWRdID0gcGFydERhdGEucHJvcGVydGllcy5zY3JpcHQ7XG4gICAgICAgIHRoaXMuX3Byb3BzQ2FjaGVbbmV3SWRdID0gcGFydERhdGEucHJvcGVydGllcztcbiAgICAgICAgdGhpcy5fbW9kZWxDYWNoZVtuZXdJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5fc3VicGFydE1hcENhY2hlW25ld0lkXSA9IHBhcnREYXRhLnN1YnBhcnRzO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZUNhY2hlLnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGhhbmRsZUlkKGFQYXJ0LCBwYXJ0RGF0YSl7XG4gICAgICAgIGxldCBuZXdJZCwgb2xkSWQ7XG4gICAgICAgIG9sZElkID0gcGFydERhdGEuaWQ7XG4gICAgICAgIG5ld0lkID0gYVBhcnQuaWQ7XG4gICAgICAgIGlmKGFQYXJ0LnR5cGUgIT09ICd3b3JsZCcpe1xuICAgICAgICAgICAgbmV3SWQgPSBpZE1ha2VyLm5ldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXdJZCxcbiAgICAgICAgICAgIG9sZElkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkUGFydHNUb1N5c3RlbShhTGlzdE9mUGFydHMpe1xuICAgICAgICBhTGlzdE9mUGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3lzdGVtLnBhcnRzQnlJZFtwYXJ0LmlkXSA9IHBhcnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbXBpbGVTY3JpcHRzKGFMaXN0T2ZQYXJ0cyl7XG4gICAgICAgIGFMaXN0T2ZQYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21waWxlUGFydFNjcmlwdChwYXJ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXR0YWNoU3VicGFydHMoYVBhcnQpe1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgX3N1YnBhcnRNYXBDYWNoZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhbiBlbnRyeSBtYXBwaW5nIGZyb20gdGhpcyBhUGFydCdzIChuZXcpXG4gICAgICAgIC8vIGlkIHRvIGFuIGFycmF5IG9mIGlkcyBvZiBhbHNvLWluaXRpYWxpemVkXG4gICAgICAgIC8vIHN1YnBhcnQgbW9kZWxzXG4gICAgICAgIGxldCBzdWJwYXJ0SWRzID0gdGhpcy5fc3VicGFydE1hcENhY2hlW2FQYXJ0LmlkXTtcbiAgICAgICAgc3VicGFydElkcy5mb3JFYWNoKHN1YnBhcnRJZCA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3SWQgPSB0aGlzLl9pZENhY2hlW3N1YnBhcnRJZF07XG4gICAgICAgICAgICBsZXQgc3VicGFydE1vZGVsID0gdGhpcy5fbW9kZWxDYWNoZVtuZXdJZF07XG4gICAgICAgICAgICBpZighc3VicGFydE1vZGVsKXtcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFQYXJ0LmFkZFBhcnQoc3VicGFydE1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydGllcyhhUGFydCl7XG4gICAgICAgIGxldCBwcm9wcyA9IHRoaXMuX3Byb3BzQ2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICBkZWxldGUgcHJvcHNbJ2lkJ107XG4gICAgICAgIGFQYXJ0LnNldFByb3BzRnJvbURlc2VyaWFsaXplcihwcm9wcywgdGhpcyk7XG4gICAgfVxuXG4gICAgY3JlYXRlVmlldyhhUGFydCl7XG4gICAgICAgIGxldCBuZXdWaWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIHRoaXMuc3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQoYVBhcnQudHlwZSlcbiAgICAgICAgKTtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzZXQgdGhlIHBhcnQtaWQgYXR0cmlidXRlIHNpbmNlIHRoZXNlXG4gICAgICAgIC8vIGFyZSB1c2VkIGZvciBxdWVyaWVzIG5lZWRlZCBmb3IgdGhpbmdzIGxpa2VcbiAgICAgICAgLy8gY3VycmVudCBzdGFjayBhbmQgY2FyZFxuICAgICAgICBuZXdWaWV3LnNldEF0dHJpYnV0ZShcInBhcnQtaWRcIiwgYVBhcnQuaWQpO1xuICAgICAgICB0aGlzLl92aWV3c0NhY2hlW2FQYXJ0LmlkXSA9IG5ld1ZpZXc7XG4gICAgfVxuXG4gICAgc2V0Vmlld01vZGVsKGFQYXJ0KXtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLl92aWV3c0NhY2hlW2FQYXJ0LmlkXTtcbiAgICAgICAgdmlldy5zZXRNb2RlbChhUGFydCk7XG4gICAgfVxuICAgIFxuICAgIGF0dGFjaFZpZXcoYVBhcnQpe1xuICAgICAgICBsZXQgb3duZXIgPSBhUGFydC5fb3duZXI7XG4gICAgICAgIGlmKG93bmVyKXtcbiAgICAgICAgICAgIGxldCBvd25lclZpZXcgPSB0aGlzLl92aWV3c0NhY2hlW293bmVyLmlkXTtcbiAgICAgICAgICAgIGxldCBwYXJ0VmlldyA9IHRoaXMuX3ZpZXdzQ2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICAgICAgb3duZXIuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidmlld0NoYW5nZWRcIixcbiAgICAgICAgICAgICAgICBjaGFuZ2VOYW1lOiBcInN1YnBhcnQtbmV3XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW3BhcnRWaWV3XVxuICAgICAgICAgICAgfSwgb3duZXJWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBpbGVQYXJ0U2NyaXB0KGFQYXJ0KXtcbiAgICAgICAgbGV0IHNjcmlwdFN0cmluZyA9IHRoaXMuX3NjcmlwdENhY2hlW2FQYXJ0LmlkXTtcbiAgICAgICAgaWYoc2NyaXB0U3RyaW5nICYmIHNjcmlwdFN0cmluZyAhPSBcIlwiKXtcbiAgICAgICAgICAgIHRoaXMuc3lzdGVtLmNvbXBpbGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21waWxlJyxcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogYVBhcnQuaWQsXG4gICAgICAgICAgICAgICAgY29kZVN0cmluZzogc2NyaXB0U3RyaW5nLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVmcmVzaFdvcmxkKCl7XG4gICAgICAgIC8vIFdlIGFzc3VtZSBhIHNpbmdsZSByb290IHBhcnQgd2FzIGRlc2VyaWFsaXplZCBhbmRcbiAgICAgICAgLy8gYXR0YWNoIGl0IGFzIHRoZSBXb3JsZCBhY2NvcmRpbmdseVxuICAgICAgICBsZXQgbmV3V29ybGQgPSB0aGlzLnJvb3RQYXJ0c1swXTtcbiAgICAgICAgaWYobmV3V29ybGQudHlwZSAhPT0gJ3dvcmxkJyl7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoYEZvdW5kICR7dGhpcy5yb290UGFydHMubGVuZ3RofSByb290cywgYnV0IG5vIHdvcmxkIWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3lzdGVtLnBhcnRzQnlJZFsnd29ybGQnXSA9IHRoaXMucm9vdFBhcnRzWzBdO1xuICAgIH1cblxuICAgIGFwcGVuZFdvcmxkKCl7XG4gICAgICAgIC8vIFdlIGFzc3VtZSBhIHNpbmdsZSByb290IHZpZXcgdGhhdCBpcyBhbiBzdC13b3JsZC5cbiAgICAgICAgbGV0IGZvdW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgaWYoZm91bmQpe1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZXBsYWNlQ2hpbGQodGhpcy5yb290Vmlld3NbMF0sIGZvdW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucHJlcGVuZCh0aGlzLnJvb3RWaWV3c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaFZpZXdBZGRlZChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpKTtcbiAgICB9XG5cbiAgICBnZXRGbGF0dGVuZWRQYXJ0VHJlZShhUGFydCwgbGlzdD1bXSl7XG4gICAgICAgIGxpc3QucHVzaChhUGFydCk7XG4gICAgICAgIGFQYXJ0LnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldEZsYXR0ZW5lZFBhcnRUcmVlKHN1YnBhcnQsIGxpc3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgdGhyb3dFcnJvcihtZXNzYWdlKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZXNlcmlhbGl6YXRpb24gRXJyb3I6ICR7bWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBnZXRNb2RlbENsYXNzKGFQYXJ0VHlwZVN0cil7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLnN5c3RlbS5hdmFpbGFibGVQYXJ0c1thUGFydFR5cGVTdHJdO1xuICAgICAgICBpZighY2xzKXtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihgUGFydCB0eXBlIFwiJHthUGFydFR5cGVTdHJ9XCIgZG9lcyBub3QgZXhpc3QgaW4gc3lzdGVtYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNscztcbiAgICB9XG5cbiAgICBmbHVzaENhY2hlcygpe1xuICAgICAgICB0aGlzLl9tb2RlbENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3N1YnBhcnRNYXBDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9pZENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2luc3RhbmNlQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJvcHNDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl92aWV3c0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3NjcmlwdENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3Jvb3RzQ2FjaGUgPSBbXTtcbiAgICB9XG5cbiAgICBkaXNwYXRjaFZpZXdBZGRlZChhVmlldyl7XG4gICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc3Qtdmlldy1hZGRlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHBhcnRUeXBlOiBhVmlldy5tb2RlbC50eXBlLFxuICAgICAgICAgICAgICAgIHBhcnRJZDogYVZpZXcubW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgLy9vd25lcklkOiBhVmlldy5tb2RlbC5fb3duZXIuaWQgfHwgbnVsbFxuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgICAgIGFWaWV3LnBhcmVudEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgZ2V0IHJvb3RQYXJ0cygpe1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdHNDYWNoZTtcbiAgICB9XG5cbiAgICBnZXQgcm9vdFZpZXdzKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RQYXJ0cy5tYXAocGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld3NDYWNoZVtwYXJ0LmlkXTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbmNsYXNzIFNUU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoYVN5c3RlbSl7XG4gICAgICAgIHRoaXMuc3lzdGVtID0gYVN5c3RlbTtcbiAgICAgICAgdGhpcy5fb2JqZWN0Q2FjaGUgPSB7fTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2VyaWFsaXplUGFydCA9IHRoaXMuc2VyaWFsaXplUGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZsdXNoQ2FjaGVzID0gdGhpcy5mbHVzaENhY2hlcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZShhUm9vdFBhcnQsIHByZXR0eT10cnVlKXtcbiAgICAgICAgdGhpcy5mbHVzaENhY2hlcygpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgIHJvb3RJZDogYVJvb3RQYXJ0LmlkLFxuICAgICAgICAgICAgdHlwZTogYVJvb3RQYXJ0LnR5cGUsXG4gICAgICAgICAgICBpZDogYVJvb3RQYXJ0LmlkXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIFBhcnRzIGFuZFxuICAgICAgICAvLyBzdG9yZSBpbiBmbGF0IGxpc3RcbiAgICAgICAgdGhpcy5zZXJpYWxpemVQYXJ0KGFSb290UGFydCk7XG5cbiAgICAgICAgLy8gV2Ugc2V0IHRoZSByZXN1bHQgb2JqZWN0cyBwYXJ0c1xuICAgICAgICAvLyBkaWN0IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBjYWNoZVxuICAgICAgICByZXN1bHQucGFydHMgPSB0aGlzLl9vYmplY3RDYWNoZTtcblxuICAgICAgICAvLyBGaW5hbGx5LCB3ZSBjb252ZXJ0IHRvIGEgc3RyaW5nIGFuZFxuICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgaWYocHJldHR5KXtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXJpYWxpemVQYXJ0KGFQYXJ0KXtcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBzZXJpYWxpemUgbWV0aG9kIGF2YWlsYWJsZSBvblxuICAgICAgICAvLyBiYXNlIFBhcnRzLCBwYXNzaW5nIGluIHRoaXMgc2VyaWFsaXplciBpbnN0YW5jZVxuICAgICAgICAvLyBhcyB0aGUgc29sZSBhcmdcbiAgICAgICAgdGhpcy5fb2JqZWN0Q2FjaGVbYVBhcnQuaWRdID0gYVBhcnQuc2VyaWFsaXplKHRoaXMpO1xuICAgICAgICBhUGFydC5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVQYXJ0KHN1YnBhcnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmbHVzaENhY2hlcygpe1xuICAgICAgICB0aGlzLl9vYmplY3RDYWNoZSA9IHt9O1xuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBTVFNlcmlhbGl6ZXIsXG4gICAgU1REZXNlcmlhbGl6ZXJcbn07XG4iLCIvKipcbiAqIEhlbHBlcnMgZm9yIHNldHRpbmcgdXAgdmFyaW91c1xuICogc3R5bGUgcHJvcGVydGllc1xuICovXG5cblxuLyoqXG4gKiBCYXNpYyBzdHlsZSBwcm9wZXJ0aWVzIGFyZSB0aG9zZVxuICogY29tbW9uIHRvIGFsbCAodmlzdWFsKSBQYXJ0c1xuICovXG5jb25zdCBzaWRlcyA9IFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXTtcblxuY29uc3QgYWRkQmFzaWNTdHlsZVByb3BzID0gKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgIDEsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgIFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsIC8vIHdoaXRlIFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RyYW5zcGFyZW5jeScsXG4gICAgICAgIDEuMCxcbiAgICApO1xuICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgICAgIGBib3JkZXItJHtzfS1zdHlsZWAsXG4gICAgICAgICAgICAnc29saWQnXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAgICAgYGJvcmRlci0ke3N9LXdpZHRoYCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAgICAgYGJvcmRlci0ke3N9LWNvbG9yYCxcbiAgICAgICAgICAgIFwicmdiKDAsIDAsIDApXCIsIC8vIGJsYWNrXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAgICAgYGJvcmRlci0ke3N9LXRyYW5zcGFyZW5jeWAsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3NoYWRvdy1sZWZ0JyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3NoYWRvdy10b3AnLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LWJsdXInLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LXNwcmVhZCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctY29sb3InLFxuICAgICAgICBcInJnYigyMzgsIDIzOCwgMjM4KVwiLCAvLyBncmV5XG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LXRyYW5zcGFyZW5jeScsXG4gICAgICAgIDFcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdjb3JuZXItdG9wLWxlZnQtcm91bmQnLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnY29ybmVyLXRvcC1yaWdodC1yb3VuZCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdjb3JuZXItYm90dG9tLWxlZnQtcm91bmQnLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnY29ybmVyLWJvdHRvbS1yaWdodC1yb3VuZCcsXG4gICAgICAgIDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBTdHlsZSBwcm9wZXJ0aWVzIGZvciBQYXJ0cyB0aGF0IGNhblxuICogYmUgbW92ZWQgYW5kIHRoYXQgY2FuIGhhdmUgZXhwbGljaXRcbiAqIGRpbWVuc2lvbnMuIEV4YW1wbGVzOiBidXR0b25zLCBmaWVsZHMuXG4gKiBFeGFtcGxlcyBvZiB0aG9zZSB0aGF0IGNhbid0OiBDYXJkcywgU3RhY2tzXG4gKi9cbmNvbnN0IGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyA9ICh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnaGlkZScsXG4gICAgICAgIGZhbHNlLFxuICAgICk7XG4gICAgLy8gc2V0dGluZyB3aWR0aCBhbmQgaGVpZ2h0IHRvIG51bGxcbiAgICAvLyBlZmZlY3RpdmVseSBmb3JjZXMgdG8gdGhlIGRlZmF1bHQgc2l6ZVxuICAgIC8vIG9mIHRoZSBidXR0b24gdG8gZml0IHRoZSBidXR0b24gbmFtZVxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgIDEwMCxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICBudWxsLFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RvcCcsXG4gICAgICAgIDAsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnbGVmdCcsXG4gICAgICAgIDAsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAncm90YXRlJyxcbiAgICAgICAgbnVsbCxcbiAgICApO1xuXG4gICAgLy8gaG9yaXpvbnRhbC1yZXNpemluZyBzcGVjaWZpZXMgYSBzdHJhdGVneVxuICAgIC8vIGZvciBob3cgdGhpcyBQYXJ0IHNob3VsZCBhZGp1c3QgaXRzXG4gICAgLy8gaG9yaXpvbnRhbCBheGlzIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gICAgLy8gUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAvLyAqIHJpZ2lkIC0gU3RpY2sgdG8gdGhlIHRvcCwgbGVmdCwgd2lkdGhcbiAgICAvLyBhbmQgaGVpZ2h0IHByb3BlcnRpZXMgYXMgdGhleSBhcmUgZXhwbGljaXRseVxuICAgIC8vIHNldDtcbiAgICAvLyAqIHNocmluay13cmFwIC0gQmVjb21lIGxhcmdlIGVub3VnaCBvbiB0aGUgaG9yaS1cbiAgICAvLyB6b250YWwgYXhpcyBvbmx5IHRvIGZpdCBhbnkgY2hpbGQgY29udGVudHM7XG4gICAgLy8gKiBzcGFjZS1maWxsIC0gRmlsbCBhcyBtdWNoIGFzIHdlIGNhbiBpbiB0aGVcbiAgICAvLyBob3Jpem9udGFsIGF4aXMgaW4gdGhlIHBhcmVudCBQYXJ0LlxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdob3Jpem9udGFsLXJlc2l6aW5nJyxcbiAgICAgICAgJ3JpZ2lkJ1xuICAgICk7XG5cbiAgICAvLyB2ZXJ0aWNhbC1yZXNpemluZyBzcGVjaWZpZXMgYSBzdHJhdGVneVxuICAgIC8vIGZvciBob3cgdGhpcyBQYXJ0IHNob3VsZCBhZGp1c3QgaXRzXG4gICAgLy8gdmVydGljYWwgYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFyZW50LlxuICAgIC8vIFBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgLy8gKiByaWdpZCAtIFN0aWNrIHRvIHRoZSB0b3AsIGxlZnQsIHdpZHRoXG4gICAgLy8gYW5kIGhlaWdodCBwcm9wZXJ0aWVzIGFzIHRoZXkgYXJlIGV4cGxpY2l0bHlcbiAgICAvLyBzZXQ7XG4gICAgLy8gKiBzaHJpbmstd3JhcCAtIEJlY29tZSBsYXJnZSBlbm91Z2ggb24gdGhlIGhvcmktXG4gICAgLy8gem9udGFsIGF4aXMgb25seSB0byBmaXQgYW55IGNoaWxkIGNvbnRlbnRzO1xuICAgIC8vICogc3BhY2UtZmlsbCAtIEZpbGwgYXMgbXVjaCBhcyB3ZSBjYW4gaW4gdGhlXG4gICAgLy8gdmVydGljYWwgYXhpcyBpbiB0aGUgcGFyZW50IFBhcnQuXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3ZlcnRpY2FsLXJlc2l6aW5nJyxcbiAgICAgICAgJ3JpZ2lkJ1xuICAgICk7XG5cbiAgICAvLyBNYXJnaW4gc3BlY2lmaWVzIHNvbWUgc3BhY2UgYmV0d2VlbiB0aGVcbiAgICAvLyB0YXJnZXQgUGFydCBhbmQgYW55IG90aGVyIFBhcnRzIHRoYXQgbWlnaHRcbiAgICAvLyBiZSBhZGphY2VudCB0byBpdCBpbiBhIGNvbW1vbiBPd25lci4gSXQgd2lsbFxuICAgIC8vIG5vdCBiZSBpbiBlZmZlY3Qgd2hlbiB0aGUgb3duZXIgaXMgdXNpbmcgYVxuICAgIC8vIHN0cmljdCBsYXlvdXQuXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RvcC1tYXJnaW4nLFxuICAgICAgICBudWxsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAncmlnaHQtbWFyZ2luJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2JvdHRvbS1tYXJnaW4nLFxuICAgICAgICBudWxsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnbGVmdC1tYXJnaW4nLFxuICAgICAgICBudWxsXG4gICAgKTtcblxuICAgIC8vIFBpbm5pbmcgc3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90XG4gICAgLy8gYSBnaXZlbiBwYXJ0IHNob3VsZCBcInN0aWNrXCIgdG8gYVxuICAgIC8vIHBhcnRpY3VsYXIgc2lkZSBvZiBpdHMgb3duZXIgUGFydC5cbiAgICAvLyBQaW5uaW5nIHByb3BlcnRpZXMgb25seSBoYXZlIGVmZmVjdFxuICAgIC8vIGluc2lkZSBvZiBQYXJ0cyB3aXRoIGEgc3RyaWN0IGxheW91dFxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgJ3Bpbm5pbmctdG9wJyxcbiAgICAgICAgcGlubmluZ1NldHRlcixcbiAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgIHJldHVybiBwcm9wT2JqZWN0Ll92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2UsIC8vIG5vdCByZWFkIG9ubHlcbiAgICAgICAgZmFsc2UgLy8gZGVmYXVsdCB2YWx1ZVxuXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICdwaW5uaW5nLWxlZnQnLFxuICAgICAgICBwaW5uaW5nU2V0dGVyLFxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHByb3BPYmplY3QuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICBmYWxzZSAvLyBkZWZhdWx0IHZhbHVlXG5cbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgJ3Bpbm5pbmctYm90dG9tJyxcbiAgICAgICAgcGlubmluZ1NldHRlcixcbiAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgIHJldHVybiBwcm9wT2JqZWN0Ll92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2UsIC8vIG5vdCByZWFkIG9ubHlcbiAgICAgICAgZmFsc2UgLy8gZGVmYXVsdCB2YWx1ZVxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAncGlubmluZy1yaWdodCcsXG4gICAgICAgIHBpbm5pbmdTZXR0ZXIsXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlLCAvLyBub3QgcmVhZCBvbmx5XG4gICAgICAgIGZhbHNlIC8vIGRlZmF1bHQgdmFsdWVcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgLy8gUG9zc2libGUgdmFsdWVzIGZvciB0aGUgY29tcG91bmRcbiAgICAgICAgLy8gJ3Bpbm5pbmcnIHByb3BlcnR5IGFyZTpcbiAgICAgICAgLy8gKlwibm9uZVwiIG9yIG51bGxcbiAgICAgICAgLy8gKnRvcFxuICAgICAgICAvLyAqdG9wLXJpZ2h0XG4gICAgICAgIC8vICp0b3AtbGVmdFxuICAgICAgICAvLyAqYm90dG9tXG4gICAgICAgIC8vICpib3R0b20tcmlnaHRcbiAgICAgICAgLy8gKmJvdHRvbS1sZWZ0XG4gICAgICAgIC8vICpsZWZ0XG4gICAgICAgIC8vICpyaWdodFxuICAgICAgICAncGlubmluZycsXG4gICAgICAgIC8vIFNldHRlclxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3QsIHZhbHVlKXtcbiAgICAgICAgICAgIGlmKCF2YWx1ZSB8fCB2YWx1ZSA9PSBcIm5vbmVcIil7XG4gICAgICAgICAgICAgICAgWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXS5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGluID0gYHBpbm5pbmctJHtzaWRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGluLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaW5uaW5nQWRqdXN0KHByb3BPd25lciwgdmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEdldHRlclxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgbGV0IHRvcCA9IHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy10b3AnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1ib3R0b20nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBwcm9wT3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctbGVmdCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBwcm9wT3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctcmlnaHQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYodG9wKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgndG9wJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoYm90dG9tKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnYm90dG9tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihsZWZ0KXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHJpZ2h0KXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgncmlnaHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCctJyk7XG4gICAgICAgIH1cbiAgICApO1xufTtcblxuLyoqXG4gKiBTdHlsZSBwcm9wZXJ0aWVzIGZvciBQYXJ0cyB0aGF0IGRpc3BsYXlcbiAqIHRleHRcbiAqL1xuY29uc3QgYWRkVGV4dFN0eWxlUHJvcHMgPSAodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtYWxpZ24nLFxuICAgICAgICAnbGVmdCcsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1mb250JyxcbiAgICAgICAgJ2RlZmF1bHQnLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtY29sb3InLFxuICAgICAgICBcInJnYigwLCAwLCAwKVwiLCAvLyBibGFja1xuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgMSxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LXN0eWxlJyxcbiAgICAgICAgJ3BsYWluJyxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LWJvbGQnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LWl0YWxpYycsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtc2l6ZScsXG4gICAgICAgIDE1LFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG59O1xuXG4vKipcbiAqIEJhc2ljIGxheW91dCBzdHlsZXMgYXJlIHRob3NlIHBlcnRhaW5pbmdcbiAqIHRvIHRoZSBwb3NpdGlvbmluZyBhbmQgcmVzaXppbmcgb2Ygc3VicGFydHMuXG4gKiBFeGFtcGxlcyBpbmNsdWRlIENhcmRzIGFuZCBBcmVhXG4gKi9cbmNvbnN0IGFkZExheW91dFN0eWxlUHJvcHMgPSAodGFyZ2V0KSA9PiB7XG4gICAgLy8gVGhlICdsYXlvdXQnIHByb3BlcnR5IGlzXG4gICAgLy8gb25lIG9mIHR3byBzdHJpbmdzOlxuICAgIC8vIHN0cmljdCAtIEVxdWl2YWxlbnQgdG8gdGhlIGFic29sdXRlXG4gICAgLy8gbGF5b3V0IGJhc2VkIHN0cmljdGx5IG9uIGNvb3JkaW5hdGVzXG4gICAgLy8gbGlzdCAtIFdpbGwgZm9yY2UgaXRlbXMgaW50byBlaXRoZXIgYSByb3dcbiAgICAvLyBvciBjb2x1bW4gbGlzdCwgYmFzZWQgb24gdGhlIHBhaXJpbmcgd2l0aFxuICAgIC8vIHRoZSAnbGlzdERpcmVjdGlvbicgcHJvcGVydHlcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAnbGF5b3V0JyxcbiAgICAgICAgJ3N0cmljdCdcbiAgICApO1xuXG4gICAgLy8gbGlzdC1kaXJlY3Rpb24gc3BlY2lmaWVzIHJvdyBvciBjb2x1bW5cbiAgICAvLyBhbmQgd2lsbCBvbmx5IGhhdmUgYW4gZWZmZWN0IHdoZW50IHRoZVxuICAgIC8vIGxheW91dCBwcm9wZXJ0eSBpcyBzZXQgdG8gJ2xpc3QnXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgJ2xpc3QtZGlyZWN0aW9uJyxcbiAgICAgICAgJ3JvdydcbiAgICApO1xuXG4gICAgLy8gV3JhcHBpbmcgc3BlY2lmaWVzIHdoZXRoZXIgYSBsaXN0IHNob3VsZFxuICAgIC8vIHdyYXAgYWxvbmcgaXRzIGRvbWluYW50IGRpbWVuc2lvbiAocm93IG9yIGNvbHVtbilcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAnbGlzdC13cmFwcGluZycsXG4gICAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIC8vIFBhZGRpbmcgc3BlY2lmaWVzIHNvbWUgc3BhY2UgZnJvbSB0aGVcbiAgICAvLyBib3JkZXIgb2YgdGhlIHRhcmdldCBQYXJ0IHRvIHRoZSBiZWdpbm5pbmdcbiAgICAvLyBvZiB0aGUgbGF5b3V0IG9mIGFueSBzdWJwYXJ0cy5cbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndG9wLXBhZGRpbmcnLFxuICAgICAgICBudWxsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAncmlnaHQtcGFkZGluZycsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdib3R0b20tcGFkZGluZycsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdsZWZ0LXBhZGRpbmcnLFxuICAgICAgICBudWxsXG4gICAgKTtcblxuICAgIC8vIExpc3QgYWxpZ25tZW50IGRlc2NyaWJlcyBob3cgZWxlbWVudHMgaW5cbiAgICAvLyBhIGxpc3QgbGF5b3V0IHNob3VsZCBhbGlnbiB0aGVtc2VsdmVzIGFsb25nXG4gICAgLy8gdGhlIGRvbWluYW50IGRpbWVuc2lvbiAocm93IG9yIGNvbHVtbilcbiAgICAvLyBUaGV5IGFyZSBlc3NlbnRpYWxseSBwcm94aWVzIGZvciBhbGlnbi1pdGVtc1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICdsaXN0LWFsaWdubWVudCcsXG4gICAgICAgIG51bGxcbiAgICApO1xuXG4gICAgLy8gTGlzdCBkaXN0cmlidXRpb24gZGVzY3JpYmVzIGhvdyBlbGVtZW50c1xuICAgIC8vIGluIGEgbGlzdCBsYXlvdXQgc2hvdWxkIGRpc3RyaWJ1dGUgdGhlbXNlbHZlc1xuICAgIC8vIGFjcm9zcyBvciBhbG9uZyB0aGUgZG9taW5hbnQgZGltZW5zaW9uXG4gICAgLy8gKHJvdyBvciBjb2x1bW4pXG4gICAgLy8gVGhpcyBpcyBlc3NlbnRpYWxseSBhIHdyYXBwZXIgZm9yIGp1c3RpZnktY29udGVudFxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICdsaXN0LWRpc3RyaWJ1dGlvbicsXG4gICAgICAgIG51bGxcbiAgICApO1xufTtcblxuLyoqXG4gICogSEVMUEVSU1xuICoqL1xuXG5jb25zdCBwaW5uaW5nU2V0dGVyID0gKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsdWUpID0+IHtcbiAgICBsZXQgc2lkZSA9IHByb3BPYmplY3QubmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgbGV0IHRvcExlZnQ7XG4gICAgc3dpdGNoIChzaWRlKXtcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgdG9wTGVmdCA9IFwibGVmdFwiO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIHRvcExlZnQgPSBcInRvcFwiO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0b3BMZWZ0ID0gc2lkZTtcbiAgICB9XG4gICAgLy8gd2UnbGwgbmVlZCB0byBmaXggYW5kIHVuLWZpeCB0aGUgY29ycmVzcG9uZGluZyB0b3Agb3IgbGVmdCBwcm9wZXJ0eSBkZXBlbmRpbmdcbiAgICAvLyBvbiB3aGV0aGVyIHZhbHVlIGlzIHRydWUgb2YgZmFsc2UsIHJlc3BlY3RpdmVseVxuICAgIGxldCBwcm9wID0gcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICB0b3BMZWZ0IFxuICAgICk7XG4gICAgbGV0IG9wcG9zaXRlU2lkZTtcbiAgICBzd2l0Y2ggKHNpZGUpe1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIG9wcG9zaXRlU2lkZSA9IFwicmlnaHRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIG9wcG9zaXRlU2lkZSA9IFwibGVmdFwiO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIG9wcG9zaXRlU2lkZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgb3Bwb3NpdGVTaWRlID0gXCJ0b3BcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKHZhbHVlKXtcbiAgICAgICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgcGlubmluZy1ib3R0b20gaXMgZmFsc2VcbiAgICAgICAgcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBwcm9wT3duZXIsXG4gICAgICAgICAgICBgcGlubmluZy0ke29wcG9zaXRlU2lkZX1gLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgcHJvcC5yZWFkT25seSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHZhbHVlIGJhY2sgdG8gdHJpZ2dlciBhIG5vdGlmaWNhdGlvblxuICAgICAgICBwcm9wLnNldFZhbHVlKHByb3BPd25lciwgcHJvcC5fdmFsdWUpO1xuICAgICAgICBwcm9wLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfVxuICAgIHByb3BPYmplY3QuX3ZhbHVlID0gdmFsdWU7XG59O1xuXG5jb25zdCBwaW5uaW5nQWRqdXN0ID0gKG93bmVyLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBzaWRlcyA9IFsndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJ107XG4gICAgc2lkZXMuZm9yRWFjaChzaWRlID0+IHtcbiAgICAgICAgaWYodmFsdWUuc3RhcnRzV2l0aChzaWRlKSl7XG4gICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgIGBwaW5uaW5nLSR7c2lkZX1gLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgIGBwaW5uaW5nLSR7c2lkZX1gLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZih2YWx1ZS5pbmNsdWRlcyhcIi1cIikpe1xuICAgICAgICBpZih2YWx1ZS5lbmRzV2l0aCgnbGVmdCcpKXtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctbGVmdCcsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctcmlnaHQnLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUuZW5kc1dpdGgoJ3JpZ2h0Jykpe1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1sZWZ0JyxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgJ3Bpbm5pbmctcmlnaHQnLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkVGV4dFN0eWxlUHJvcHMsXG4gICAgYWRkTGF5b3V0U3R5bGVQcm9wc1xufTtcbiIsIi8qKlxuICogU3R5bGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gcmVzcG9uc2libGUgZm9yIGNvbnZlcnRpbmdcbiAqIFNpbXBsZVRhbGsgdmlzdWFsIHN0eWxpbmcgdG8gYSBkaWN0XG4gKiBPYmplY3Qgb2YgQ1NTIEphdmFTY3JpcHQgdHlwZSBrZXktdmFsdWUgcGFpcnNcbiAqL1xuXG4vKiogSSBzdHlsZSB0aGUgc3R5bGVPYmpcbiAqIHN0eWxlT2JqOiBjc3MgSmF2YVNjcmlwdCBrZXk6dmFsdWUgcGFpcnNcbiAqIHByb3BlcnR5TmFtZTogKFNpbXBsZVRhbGspIHN0eWxpbmcgcHJvcGVydHkgbmFtZVxuICogcHJvcGVydHlWYWx1ZTogKFNpbXBsZVRhbGspIHN0eWxpbmcgcHJvcGVydHkgdmFsdWVcbiAqL1xuXG5jb25zdCBjc3NTdHlsZXIgPSAoc3R5bGVPYmosIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkgPT4ge1xuICAgIHN3aXRjaChwcm9wZXJ0eU5hbWUpe1xuXG4gICAgY2FzZSBcImJhY2tncm91bmQtY29sb3JcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImJhY2tncm91bmRDb2xvclwiLCAgX2NvbG9yVG9SR0JBKHN0eWxlT2JqW1wiYmFja2dyb3VuZENvbG9yXCJdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImJhY2tncm91bmQtdHJhbnNwYXJlbmN5XCI6XG4gICAgICAgIC8vIGhlcmUgd2Ugc2V0IHRoZSBBbHBoYSB2YWx1ZSBvZiB0aGUgY3VycmVudCBzdHlsZU9ialtcImJhY2tncm91bmRDb2xvclwiXSByZ2JhXG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgIF9jb2xvclRyYW5zcGFyZW5jeVRvUkdCQShzdHlsZU9ialtcImJhY2tncm91bmRDb2xvclwiXSwgcHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJib3JkZXItdG9wLXN0eWxlXCI6XG4gICAgY2FzZSBcImJvcmRlci1ib3R0b20tc3R5bGVcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWxlZnQtc3R5bGVcIjpcbiAgICBjYXNlIFwiYm9yZGVyLXJpZ2h0LXN0eWxlXCI6IHtcbiAgICAgICAgbGV0IHMgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtzfS1zdHlsZWAsICBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImJvcmRlci10b3Atd2lkdGhcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiOlxuICAgIGNhc2UgXCJib3JkZXItbGVmdC13aWR0aFwiOlxuICAgIGNhc2UgXCJib3JkZXItcmlnaHQtd2lkdGhcIjoge1xuICAgICAgICBsZXQgcyA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYGJvcmRlci0ke3N9LXdpZHRoYCwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImJvcmRlci10b3AtY29sb3JcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWJvdHRvbS1jb2xvclwiOlxuICAgIGNhc2UgXCJib3JkZXItdG9wLWNvbG9yXCI6XG4gICAgY2FzZSBcImJvcmRlci1yaWdodC1jb2xvclwiOiB7XG4gICAgICAgIGxldCBzID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgYm9yZGVyLSR7c30tY29sb3JgLCAgX2NvbG9yVG9SR0JBKHN0eWxlT2JqW2Bib3JkZXItJHtzfS1jb2xvcmBdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgXCJib3JkZXItdG9wLXRyYW5zcGFyZW5jeVwiOlxuICAgIGNhc2UgXCJib3JkZXItYm90dG9tLXRyYW5zcGFyZW5jeVwiOlxuICAgIGNhc2UgXCJib3JkZXItbGVmdC10cmFuc3BhcmVuY3lcIjpcbiAgICBjYXNlIFwiYm9yZGVyLXJpZ2h0LXRyYW5zcGFyZW5jeVwiOiB7XG4gICAgICAgIGxldCBzID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgYm9yZGVyLSR7c30tY29sb3JgLCAgX2NvbG9yVHJhbnNwYXJlbmN5VG9SR0JBKHN0eWxlT2JqW2Bib3JkZXItJHtzfS1jb2xvcmBdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgXCJjb3JuZXItdG9wLWxlZnQtcm91bmRcIjpcbiAgICBjYXNlIFwiY29ybmVyLXRvcC1yaWdodC1yb3VuZFwiOlxuICAgIGNhc2UgXCJjb3JuZXItYm90dG9tLWxlZnQtcm91bmRcIjpcbiAgICBjYXNlIFwiY29ybmVyLWJvdHRvbS1yaWdodC1yb3VuZFwiOntcbiAgICAgICAgbGV0IGMxID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICAgICAgbGV0IGMyID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsyXTtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgYm9yZGVyLSR7YzF9LSR7YzJ9LXJhZGl1c2AsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgXCJzaGFkb3ctbGVmdFwiOlxuICAgIGNhc2UgXCJzaGFkb3ctdG9wXCI6XG4gICAgY2FzZSBcInNoYWRvdy1ibHVyXCI6XG4gICAgY2FzZSBcInNoYWRvdy1zcHJlYWRcIjpcbiAgICBjYXNlIFwic2hhZG93LWNvbG9yXCI6XG4gICAgY2FzZSBcInNoYWRvdy10cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgbGV0IHNoYWRvd1Byb3AgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBsZXQgW2xlZnQsIHRvcCwgYmx1ciwgc3ByZWFkLCBjb2xvcl0gPSBfY3NzQm94U2hhZG93KHN0eWxlT2JqW1wiYm94LXNoYWRvd1wiXSk7XG4gICAgICAgIHN3aXRjaChzaGFkb3dQcm9wKXtcbiAgICAgICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgICAgICBjb2xvciA9IF9jb2xvclRvUkdCQShjb2xvciwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRyYW5zcGFyZW5jeVwiOlxuICAgICAgICAgICAgY29sb3IgPSBfY29sb3JUcmFuc3BhcmVuY3lUb1JHQkEoY29sb3IsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICBsZWZ0ID0gX2ludFRvUHgocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgdG9wID0gX2ludFRvUHgocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgICAgIGJsdXIgPSBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3ByZWFkXCI6XG4gICAgICAgICAgICBzcHJlYWQgPSBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJib3gtc2hhZG93XCIsIGAke2xlZnR9ICR7dG9wfSAke2JsdXJ9ICR7c3ByZWFkfSAke2NvbG9yfWApO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWNvbG9yXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJjb2xvclwiLCAgX2NvbG9yVG9SR0JBKHN0eWxlT2JqW1wiY29sb3JcIl0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1mb250XCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJmb250RmFtaWx5XCIsICBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1zaXplXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJmb250U2l6ZVwiLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1hbGlnblwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidGV4dEFsaWduXCIsICBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1ib2xkXCI6XG4gICAgICAgIGlmKHByb3BlcnR5VmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnQtd2VpZ2h0XCIsICBcImJvbGRcIik7XG4gICAgICAgIH0gZWxzZSBpZihwcm9wZXJ0eVZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udC13ZWlnaHRcIiwgIFwibm9ybWFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtaXRhbGljXCI6XG4gICAgICAgIGlmKHByb3BlcnR5VmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnQtc3R5bGVcIiwgIFwiaXRhbGljXCIpO1xuICAgICAgICB9IGVsc2UgaWYocHJvcGVydHlWYWx1ZSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnQtc3R5bGVcIiwgIFwibm9ybWFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtdW5kZXJsaW5lXCI6XG4gICAgICAgIGlmKHByb3BlcnR5VmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcInRleHREZWNvcmF0aW9uXCIsICBcInVuZGVybGluZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LXN0cmlrZXRocm91Z2hcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidGV4dERlY29yYXRpb25cIiwgIFwibGluZS10aHJvdWdoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtdHJhbnNwYXJlbmN5XCI6XG4gICAgICAgIC8vIGhlcmUgd2Ugc2V0IHRoZSBBbHBoYSB2YWx1ZSBvZiB0aGUgY3VycmVudCBzdHlsZU9ialtcImNvbG9yXCJdIHJnYmFcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImNvbG9yXCIsICBfY29sb3JUcmFuc3BhcmVuY3lUb1JHQkEoc3R5bGVPYmpbXCJjb2xvclwiXSwgcHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcInRvcFwiLCAgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJsZWZ0XCIsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ3aWR0aFwiLCAgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImhlaWdodFwiLCAgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJsZWZ0LW1hcmdpblwiOlxuICAgIGNhc2UgXCJyaWdodC1tYXJnaW5cIjpcbiAgICBjYXNlIFwiYm90dG9tLW1hcmdpblwiOlxuICAgIGNhc2UgXCJ0b3AtbWFyZ2luXCI6XG4gICAgICAgIGxldCBtYXJnaW5TaWRlID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVswXTtcbiAgICAgICAgbWFyZ2luU2lkZSA9IGAke21hcmdpblNpZGVbMF0udG9VcHBlckNhc2UoKX0ke21hcmdpblNpZGUuc2xpY2UoMSl9YDtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgbWFyZ2luJHttYXJnaW5TaWRlfWAsIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwibGVmdC1wYWRkaW5nXCI6XG4gICAgY2FzZSBcInJpZ2h0LXBhZGRpbmdcIjpcbiAgICBjYXNlIFwiYm90dG9tLXBhZGRpbmdcIjpcbiAgICBjYXNlIFwidG9wLXBhZGRpbmdcIjpcbiAgICAgICAgbGV0IHBhZGRpbmdTaWRlID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVswXTtcbiAgICAgICAgcGFkZGluZ1NpZGUgPSBgJHtwYWRkaW5nU2lkZVswXS50b1VwcGVyQ2FzZSgpfSR7cGFkZGluZ1NpZGUuc2xpY2UoMSl9YDtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgcGFkZGluZyR7cGFkZGluZ1NpZGV9YCwgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LXN0eWxlXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0ZXh0U3R5bGVcIiwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJyb3RhdGVcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcInRyYW5zZm9ybVwiLCAgX2ludFRvUm90YXRlRGVnKHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJhbnNwYXJlbmN5XCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJvcGFjaXR5XCIsICBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiaGlkZVwiOlxuICAgICAgICBpZihwcm9wZXJ0eVZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgIHN0eWxlT2JqW1wiZGlzcGxheVwiXSA9IFwibm9uZVwiO1xuICAgICAgICB9IGVsc2UgaWYocHJvcGVydHlWYWx1ZSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgc3R5bGVPYmpbXCJkaXNwbGF5XCJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuXG4gICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZm9yIHRoZSBkZWZhdWx0IHdlIHNpbXBseSBhbGxvdyBTVCBzdHlsZSBuYW1lcyB0byBtYXAgMS0xXG4gICAgICAgIC8vIHRvIENTUy9KUyBzdHlsZSBuYW1lcy4gVGhpcyBpcyBvbmx5IHNvbWV3aGF0IHNhZmUsIHNpbmNlIHRoZSBET01cbiAgICAgICAgLy8gd2lsbCBzaW1wbHkgaWdub3JlIG5vbnNlbnNlIG5hbWVzIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IuIEJ1dCBpdFxuICAgICAgICAvLyBkb2VzIGFsbG93IHVzIHRvIGF2b2lkIHdyaXRpbmcgYSBydWxlIGZvciBldmVyeSB0ZXJtIChleGFtcGxlOiB3aWR0aCxcbiAgICAgICAgLy8gaGVpZ2h0LCB0b3AsIGxlZnQgZXRjKVxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIHByb3BlcnR5TmFtZSwgIHByb3BlcnR5VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVPYmo7XG5cbn07XG5cbi8vIEluIG9yZGVyIHRvIGF2b2lkIGNsYXNoaW5nIHdpdGggdmlld3MgaW50ZXJhY3Rpbmdcbi8vIHRoZSBzdHlsZSBhdHRyaWJ1dGUgZGlyZWN0bHkgd2UgaWdub3JlIGV2ZXJ5dGhpbmcgdGhhdFxuLy8gaXMgZWl0aGVyIG51bGwgb3IgdW5kZWZpbmVkXG4vLyBUT0RPIHJldmlldyB0aGlzIGRlY2lzaW9uIVxuY29uc3QgX3NldE9yTm90ID0gKHN0eWxlT2JqLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGlmKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpe1xuICAgICAgICBzdHlsZU9ialtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn07XG5cbmNvbnN0IF9pbnRUb1JvdGF0ZURlZyA9IChuKSA9PiB7XG4gICAgaWYobiAhPT0gbnVsbCAmJiBuICE9PSB1bmRlZmluZWQpe1xuICAgICAgICBpZih0eXBlb2YobikgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgbiA9IG4uc3BsaXQoXCJkZWdcIilbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGByb3RhdGUoJHtufWRlZylgO1xuICAgIH1cbn07XG5cblxuY29uc3QgX2ludFRvUHggPSAobikgPT4ge1xuICAgIGlmKG4gIT09IG51bGwgJiYgbiAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgaWYodHlwZW9mKG4pID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgICAgIGlmKG4gPT0gXCJmaWxsXCIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjEwMCVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZihbXCJ0aGluXCIsIFwibWVkaXVtXCIsIFwidGhpY2tcIl0uaW5kZXhPZihuKSA+IC0xKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuLnNwbGl0KFwicHhcIilbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke259cHhgO1xuICAgIH1cbn07XG5cbi8vIENvbnZlcnQgY29sb3JzIHRvIHJnYmFcbi8vIGNoYW5nZSBhIGNzcyBjb2xvciBSR0IgdmFsdWVzLCBwcmVzZXJ2aW5nIHRoZSBBKGxwaGEpIHZhbHVlXG5jb25zdCBfY29sb3JUb1JHQkEgPSAoY3NzQ29sb3IsIFNUQ29sb3IpID0+IHtcbiAgICBpZighU1RDb2xvcil7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHIsIGcsIGIsIGEsIF87XG4gICAgLy8gU1QgY29sb3JzIGFyZSBSR0JcbiAgICBpZihTVENvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JcIikpe1xuICAgICAgICBbciwgZywgYl0gPSBTVENvbG9yLm1hdGNoKC9cXGQrL2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb2xvckluZm8gPSBiYXNpY0NTU0NvbG9yc1tTVENvbG9yXTtcbiAgICAgICAgaWYoY29sb3JJbmZvKXtcbiAgICAgICAgICAgIHIgPSBjb2xvckluZm9bXCJyXCJdO1xuICAgICAgICAgICAgZyA9IGNvbG9ySW5mb1tcImdcIl07XG4gICAgICAgICAgICBiID0gY29sb3JJbmZvW1wiYlwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihjc3NDb2xvcil7XG4gICAgICAgIFtfLCBfLCBfLCBhXSA9IGNzc0NvbG9yLm1hdGNoKC9bXFxkXFwuXSsvZyk7XG4gICAgICAgIC8vIGlmIEFscGhhIGlzIG5vdCBkZWZpbmVkIHRoZW4gd2Ugc2V0IGl0IHRvIDFcbiAgICAgICAgLy8gZGVmYXVsdCBmb3IgYnJvd3NlcnNcbiAgICB9XG4gICAgaWYoIWEpe1xuICAgICAgICBhID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7YX0pYDtcbn1cblxuLy8gY2hhbmdlIHRoZSBBKGFscGhhKSB2YWx1ZSwgcHJlc2VydmluZyB0aGUgUkdCIHZhbHVlc1xuY29uc3QgX2NvbG9yVHJhbnNwYXJlbmN5VG9SR0JBID0gKGNzc0NvbG9yLCB0VmFsdWUpID0+IHtcbiAgICBpZighY3NzQ29sb3Ipe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHIsIGcsIGI7XG4gICAgbGV0IG1hcHBlZENvbG9yID0gYmFzaWNDU1NDb2xvcnNbY3NzQ29sb3JdO1xuICAgIGlmKG1hcHBlZENvbG9yKXtcbiAgICAgICAgciA9IG1hcHBlZENvbG9yLnI7XG4gICAgICAgIGcgPSBtYXBwZWRDb2xvci5nO1xuICAgICAgICBiID0gbWFwcGVkQ29sb3IuYjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBbciwgZywgYl0gPSBjc3NDb2xvci5tYXRjaCgvXFxkKy9nKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7dFZhbHVlfSlgO1xufVxuXG4vLyBBZGQgbW9yZSBjb2xvcnMgYXMgbmVlZGVkXG5jb25zdCBiYXNpY0NTU0NvbG9ycyA9IHtcbiAgICBibGFjazoge2hleDogXCIjMDAwMDAwXCIsIHI6IDAsIGc6IDAsIGI6IDB9LFxuXHRcdHNpbHZlcjoge2hleDogXCIjQzBDMEMwXCIsIHI6IDE5MiwgZzogMTkyLCBiOiAxOTJ9LFxuXHRcdGdyYXk6IHtoZXg6IFwiIzgwODA4MFwiLCByOiAxMjgsIGc6IDEyOCwgYjogMTI4fSxcblx0XHR3aGl0ZToge2hleDogXCIjRkZGRkZGXCIsIHI6IDI1NSwgZzogMjU1LCBiOiAyNTV9LFxuXHRcdG1hcm9vbjoge2hleDogXCIjODAwMDAwXCIsIHI6IDEyOCwgZzogMCwgYjogMH0sXG5cdFx0cmVkOiB7aGV4OiBcIiNGRjAwMDBcIiwgcjogMjU1LCBnOiAwLCBiOiAwfSxcblx0XHRwdXJwbGU6IHtoZXg6IFwiIzgwMDA4MFwiLCByOiAxMjgsIGc6IDAsIGI6IDEyOH0sXG5cdFx0ZnVjaHNpYToge2hleDogXCIjRkYwMEZGXCIsIHI6IDI1NSwgZzogMCwgYjogMjU1fSxcblx0XHRncmVlbjoge2hleDogXCIjMDA4MDAwXCIsIHI6IDAsIGc6IDEyOCwgYjogMH0sXG5cdFx0bGltZToge2hleDogXCIjMDBGRjAwXCIsIHI6IDAsIGc6IDI1NSwgYjogMH0sXG5cdFx0b2xpdmU6IHtoZXg6IFwiIzgwODAwMFwiLCByOiAxMjgsIGc6IDEyOCwgYjogMH0sXG5cdFx0eWVsbG93OiB7aGV4OiBcIiNGRkZGMDBcIiwgcjogMjU1LCBnOiAyNTUsIGI6IDB9LFxuXHRcdG5hdnk6IHtoZXg6IFwiIzAwMDA4MFwiLCByOiAwLCBnOiAwLCBiOiAxMjh9LFxuXHRcdGJsdWU6IHtoZXg6IFwiIzAwMDBGRlwiLCByOiAwLCBnOiAwLCBiOiAyNTV9LFxuXHRcdHRlYWw6IHtoZXg6IFwiIzAwODA4MFwiLCByOiAwLCBnOiAxMjgsIGI6IDEyOH0sXG5cdFx0YXF1YToge2hleDogXCIjMDBGRkZGXCIsIHI6IDAsIGc6IDI1NSwgYjogMjU1fSxcbn07XG5cbi8vIHRha2UgdGhlIGNzcyBib3gtc2hhZG93IHByb3BlcnR5IGFuZCByZXR1cm4gaXRzXG4vLyBjb21wb25lbnRzIChvZmZzZXQteSwgb2Zmc2V0LXgsIGJsdXIsIHNwcmVhZCBhbmQgY29sb3IpXG4vLyBpZiB0aGUgdmFsdWUgaXMgbm90IGRlZmluZWQgcmV0dXJuIGEgZGVmYXVsdFxuY29uc3QgX2Nzc0JveFNoYWRvdyA9IChjc3NQcm9wVmFsdWUpID0+e1xuICAgIGlmKCFjc3NQcm9wVmFsdWUpe1xuICAgICAgICByZXR1cm4gW1wiMHB4XCIsIFwiMHB4XCIsIFwiMHB4XCIsIFwiMHB4XCIsIFwicmdiYSgwLCAwLCAwLCAxKVwiXTtcbiAgICB9XG4gICAgbGV0IFtpbnRWYWx1ZXMsIHJnYmFdID0gY3NzUHJvcFZhbHVlLnNwbGl0KFwiIHJnYmFcIik7XG4gICAgbGV0IFtsZWZ0LCB0b3AsIGJsdXIsIHNwcmVhZF0gPSBpbnRWYWx1ZXMuc3BsaXQoXCIgXCIpO1xuICAgIHJldHVybiBbbGVmdCwgdG9wLCBibHVyLCBzcHJlYWQsIGByZ2JhJHtyZ2JhfWBdO1xufVxuXG5leHBvcnQge1xuICAgIGNzc1N0eWxlcixcbiAgICBjc3NTdHlsZXIgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQXJlYVZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSB3ZWJjb21wb25lbnQgcmVwcmVzZW50YXRpb25cbiAqIG9mIGFuIEFyZWEsIHdoaWNoIGlzIGEgZ3JvdXBpbmcgb2ZcbiAqIFBhcnRzIHRoYXQgaGF2ZSBzb21lIGtpbmQgb2YgbGF5b3V0XG4gKiBzcGVjaWZpZWRcbiAqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbiAgICAgICAgICAgICAgICA8c3R5bGU+XG4gICAgICAgICAgICAgICAgI2FyZWEtd3JhcHBlciB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBpbmhlcml0O1xuICAgICAgICAgICAgICAgICAgICBmbGV4LXdyYXA6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBpbmhlcml0O1xuICAgICAgICAgICAgICAgICAgICBhbGlnbi1jb250ZW50OiBpbmhlcml0O1xuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC5jbGlwIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAuYWxsb3ctc2Nyb2xsIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvc3R5bGU+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cImFyZWEtd3JhcHBlclwiPlxuICAgICAgICAgICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbmA7XG5cbmNsYXNzIEFyZWFWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5jbGlwcGluZ0NoYW5nZWQgPSB0aGlzLmNsaXBwaW5nQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFsbG93U2Nyb2xsaW5nQ2hhbmdlZCA9IHRoaXMuYWxsb3dTY3JvbGxpbmdDaGFuZ2VkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gUHJvcCBjaGFuZ2UgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2NsaXBwaW5nJywgdGhpcy5jbGlwcGluZ0NoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnYWxsb3ctc2Nyb2xsaW5nJywgdGhpcy5hbGxvd1Njcm9sbGluZ0NoYW5nZWQpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgbGV0IGNsaXBwaW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwiY2xpcHBpbmdcIlxuICAgICAgICApO1xuICAgICAgICBsZXQgYWxsb3dTY3JvbGxpbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJhbGxvdy1zY3JvbGxpbmdcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsaXBwaW5nQ2hhbmdlZChjbGlwcGluZywgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIGlmKGNsaXBwaW5nICYmIGFsbG93U2Nyb2xsaW5nKXtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dTY3JvbGxpbmdDaGFuZ2VkKGFsbG93U2Nyb2xsaW5nLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsaXBwaW5nQ2hhbmdlZChuZXdWYWwsIGlkKXtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdhcmVhLXdyYXBwZXInKTtcbiAgICAgICAgaWYobmV3VmFsID09IHRydWUpe1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdhbGxvdy1zY3JvbGwnKTtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnY2xpcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdjbGlwJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhbGxvd1Njcm9sbGluZ0NoYW5nZWQobmV3VmFsLCBpZCl7XG4gICAgICAgIGxldCB3cmFwcGVyID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYXJlYS13cmFwcGVyJyk7XG4gICAgICAgIGlmKG5ld1ZhbCA9PSB0cnVlKXtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnY2xpcCcpO1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdhbGxvdy1zY3JvbGwnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnYWxsb3ctc2Nyb2xsJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDb250ZXh0TWVudUl0ZW1zKGNvbnRleHRNZW51KXtcbiAgICAgICAgY29udGV4dE1lbnUuYWRkU3BhY2VyKCk7XG4gICAgICAgIGxldCBsYXlvdXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2xheW91dCdcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbGlzdC1kaXJlY3Rpb24nXG4gICAgICAgICk7XG4gICAgICAgIGlmKGxheW91dCAhPSAnbGlzdCcpe1xuICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgXCJTZXQgTGF5b3V0IHRvIExpc3RcIixcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXlvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3QnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgIFwiU2V0IExheW91dCB0byBTdHJpY3RcIixcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXlvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cmljdCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYoZGlyZWN0aW9uID09ICdyb3cnKXtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgXCJTZXQgTGlzdCBEaXJlY3Rpb24gdG8gQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3QtZGlyZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29sdW1uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICBcIlNldCBMaXN0IERpcmVjdGlvbiB0byBDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGlzdC1kaXJlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyb3cnXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQXJlYVZpZXcsXG4gICAgQXJlYVZpZXcgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgbGlua0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbGlua1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAgMTRhMy41IDMuNSAwIDAgMCA1IDBsNCAtNGEzLjUgMy41IDAgMCAwIC01IC01bC0uNSAuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTBhMy41IDMuNSAwIDAgMCAtNSAwbC00IDRhMy41IDMuNSAwIDAgMCA1IDVsLjUgLS41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG46aG9zdCB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcGFkZGluZzogMXB4O1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLndyYXBwZXJ7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbn1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwid3JhcHBlclwiPlxuICAgIDxhdWRpbz48L2F1ZGlvPlxuICAgIDxzcGFuIGNsYXNzPVwibmFtZVwiPjwvc3Bhbj5cbiAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbXVzaWNcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICAgPGNpcmNsZSBjeD1cIjZcIiBjeT1cIjE3XCIgcj1cIjNcIj48L2NpcmNsZT5cbiAgICA8Y2lyY2xlIGN4PVwiMTZcIiBjeT1cIjE3XCIgcj1cIjNcIj48L2NpcmNsZT5cbiAgICA8cG9seWxpbmUgcG9pbnRzPVwiOSAxNyA5IDQgMTkgNCAxOSAxN1wiPjwvcG9seWxpbmU+XG4gICAgPGxpbmUgeDE9XCI5XCIgeTE9XCI4XCIgeDI9XCIxOVwiIHkyPVwiOFwiPjwvbGluZT5cbiAgICA8L3N2Zz5cbjwvZGl2PlxuYDtcblxuLy8gSFRNTE1lZGlhRWxlbWVudFN0YXRlcyBjb3BpZWQgZnJvbVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvcmVhZHlTdGF0ZVxuY29uc3QgbWVkaWFTdGF0ZXMgPSB7XG4gICAgMDogXCJIQVZFX05PVEhJTkdcIixcbiAgICAxOiBcIkhBVkVfTUVUQURBVEFcIixcbiAgICAyOiBcIkhBVkVfQ1VSUkVOVF9EQVRBXCIsXG4gICAgMzogXCJIQVZFX0ZVVFVSRV9EQVRBXCIsXG4gICAgNDogXCJIQVZFX0VOT1VHSF9EQVRBXCJcbn07XG5cbmNsYXNzIEF1ZGlvVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgZG9tXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24gPSB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlQXVkaW9MaW5rID0gdGhpcy51cGRhdGVBdWRpb0xpbmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wbGF5ID0gdGhpcy5wbGF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGF1c2UgPSB0aGlzLnBhdXNlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgbGV0IGF1ZGlvID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiYXVkaW9cIik7XG4gICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGVDb2RlID0gYXVkaW8ucmVhZHlTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgIFwicmVhZHlTdGF0ZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhU3RhdGVzW3N0YXRlQ29kZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCF0aGlzLmhhbG9CdXR0b24pe1xuICAgICAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIGxldCBuYW1lU3BhbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5uYW1lXCIpO1xuICAgICAgICBuYW1lU3Bhbi5pbm5lclRleHQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJuYW1lXCIpO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJyZWFkeVN0YXRlXCIsXG4gICAgICAgICAgIFwiSEFWRV9OT1RISU5HXCJcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGF1ZGlvID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiYXVkaW9cIik7XG4gICAgICAgIGxldCBzcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJzcmNcIik7XG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICBhdWRpby5zcmMgPSBzcmM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcCBjaGFuZ2VzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwibmFtZVwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIG5hbWVTcGFuLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJyZWFkeVN0YXRlXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGJvcmRlckNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgICAgIGlmKHZhbHVlID09IFwiSEFWRV9GVVRVUkVfREFUQVwiIHx8IHZhbHVlID09IFwiSEFWRV9FTk9VR0hfREFUQVwiKXtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IFwiZ3JlZW5cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl0uZm9yRWFjaCgoc2lkZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBgYm9yZGVyLSR7c2lkZX0tY29sb3JgLCBib3JkZXJDb2xvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwicGxheVwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcInN0b3BcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgYXVkaW8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJzcmNcIiwgKHVybCkgPT4ge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIC8vIHJlc291cmNlIGxvYWQgaXMgYXV0by1sb2FkZWQgYnkgdGhlIDxhdWRpbz4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGF1ZGlvLnNyYyA9IHVybDtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyb3Ipe1xuICAgICAgICAgICAgICAgIGxldCBlcnJvck1zZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJlc291cmNlTm90Rm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBcImF1ZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRJZDogdGhpcy5tb2RlbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczoge3NvdXJjZTogdXJsLCB0eXBlOiBcInVybFwifVxuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtlcnJvck1zZ30sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwbGF5KCl7XG4gICAgICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHRoZSByZXNvdXJjZSBpcyByZWFkeVxuICAgICAgICBsZXQgYXVkaW8gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKTtcbiAgICAgICAgbGV0IHJlYWR5U3RhdGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyZWFkeVN0YXRlXCIpO1xuICAgICAgICBpZihyZWFkeVN0YXRlID09IFwiSEFWRV9GVVRVUkVfREFUQVwiIHx8IHJlYWR5U3RhdGUgPT0gXCJIQVZFX0VOT1VHSF9EQVRBXCIpe1xuICAgICAgICAgICAgYXVkaW8ucGxheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoYGF1ZGlvIGlzIG5vdCByZWFkeTsgY3VycmVudCBzdGF0ZTogJHtyZWFkeVN0YXRlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2UoKXtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiYXVkaW9cIikucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvLyByZS1sb2FkcyB0aGUgbWVkaWEsIHNldHRpbmcgaXQgYmFjayB0byB0aGUgYmVnZ25pbmdcbiAgICBzdG9wKCl7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpLmxvYWQoKTtcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDApe1xuICAgICAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyB0aGUgb24gY2xpY2sgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZighdGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgY2xpY2sgY29tbWFuZCBtZXNzYWdlIHRvIHNlbGZcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQuIEhlcmUgd2UgYWRkIGEgY3VzdG9tIGJ1dHRvblxuICAgICAgICAvLyB3aGVuIHNob3dpbmcuXG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZighZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChmb3VuZEhhbG8pO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kSGFsby5hcHBlbmQodGhpcy5oYWxvQnV0dG9uKTtcbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbigpe1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlkID0gJ2hhbG8tYXVkaW8tbGluayc7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaW5uZXJIVE1MID0gbGlua0ljb247XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zdHlsZS5tYXJnaW5Ub3AgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ3JpZ2h0LWNvbHVtbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdFZGl0IGxpbmsgZm9yIGF1ZGlvIHNvdXJjZScpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnVwZGF0ZUF1ZGlvTGluayk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXVkaW9MaW5rKGV2ZW50KXtcbiAgICAgICAgLy8gVGVsbHMgdGhlIG1vZGVsIHRvIHVwZGF0ZSBpdHNcbiAgICAgICAgLy8gc3JjIGxpbmsgZm9yIHRoZSBhdWRpb1xuICAgICAgICBsZXQgY3VycmVudFNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnc3JjJ1xuICAgICAgICApO1xuICAgICAgICBsZXQgcmVzdWx0ID0gd2luZG93LnByb21wdChcIkVkaXQgVVJMIGZvciBhdWRpbzpcIiwgY3VycmVudFNyYyk7XG4gICAgICAgIGlmKHJlc3VsdCAmJiByZXN1bHQgIT09ICcnICYmIHJlc3VsdCAhPT0gY3VycmVudFNyYyl7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2xvYWRBdWRpb0Zyb21Tb3VyY2UnLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbIHJlc3VsdCBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG5cbmV4cG9ydCB7XG4gICAgQXVkaW9WaWV3LFxuICAgIEF1ZGlvVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuXG5jb25zdCBsaW5rSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1saW5rXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMCAxNGEzLjUgMy41IDAgMCAwIDUgMGw0IC00YTMuNSAzLjUgMCAwIDAgLTUgLTVsLS41IC41XCIgLz5cbiAgPHBhdGggZD1cIk0xNCAxMGEzLjUgMy41IDAgMCAwIC01IDBsLTQgNGEzLjUgMy41IDAgMCAwIDUgNWwuNSAtLjVcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbjpob3N0IHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBwYWRkaW5nOiAxcHg7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuaWZyYW1lIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG48L3N0eWxlPlxuPGlmcmFtZSBmcmFtZWJvcmRlcj1cIjBcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+XG5gO1xuXG5jbGFzcyBCcm93c2VyVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgZG9tXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24gPSB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlQnJvd3NlckxpbmsgPSB0aGlzLnVwZGF0ZUJyb3dzZXJMaW5rLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgaWYoIXRoaXMuaGFsb0J1dHRvbil7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgbGV0IGlmcmFtZSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKTtcbiAgICAgICAgbGV0IHNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInNyY1wiKTtcbiAgICAgICAgaWYoc3JjKXtcbiAgICAgICAgICAgIGlmcmFtZS5zcmMgPSBzcmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJzcmNcIiwgKHVybCkgPT4ge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIC8vIHJlc291cmNlIGxvYWQgaXMgYXV0by1sb2FkZWQgYnkgdGhlIDxicm93c2VyPiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9IHVybDtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyb3Ipe1xuICAgICAgICAgICAgICAgIGxldCBlcnJvck1zZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJlc291cmNlTm90Rm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBcImJyb3dzZXJcIixcbiAgICAgICAgICAgICAgICAgICAgcGFydElkOiB0aGlzLm1vZGVsLmlkLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiB7c291cmNlOiB1cmwsIHR5cGU6IFwidXJsXCJ9XG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe2Vycm9yTXNnfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCl7XG4gICAgICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIHRoZSBvbiBjbGljayBtZXNzYWdlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmhhc09wZW5IYWxvKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5IYWxvKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKCF0aGlzLmhhc09wZW5IYWxvKXtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBjbGljayBjb21tYW5kIG1lc3NhZ2UgdG8gc2VsZlxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlIC8vIFNob3VsZCBpZ25vcmUgaWYgU3lzdGVtIEROVVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9CdXR0b24pO1xuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9uKCl7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaWQgPSAnaGFsby1icm93c2VyLWxpbmsnO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlubmVySFRNTCA9IGxpbmtJY29uO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luVG9wID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdyaWdodC1jb2x1bW4nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnRWRpdCBsaW5rIGZvciBicm93c2VyIHNvdXJjZScpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnVwZGF0ZUJyb3dzZXJMaW5rKTtcbiAgICB9XG5cbiAgICB1cGRhdGVCcm93c2VyTGluayhldmVudCl7XG4gICAgICAgIC8vIFRlbGxzIHRoZSBtb2RlbCB0byB1cGRhdGUgaXRzXG4gICAgICAgIC8vIHNyYyBsaW5rIGZvciB0aGUgYnJvd3NlclxuICAgICAgICBsZXQgY3VycmVudFNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnc3JjJ1xuICAgICAgICApO1xuICAgICAgICBsZXQgcmVzdWx0ID0gd2luZG93LnByb21wdChcIkVkaXQgVVJMIGZvciBicm93c2VyOlwiLCBjdXJyZW50U3JjKTtcbiAgICAgICAgaWYocmVzdWx0ICYmIHJlc3VsdCAhPT0gJycgJiYgcmVzdWx0ICE9PSBjdXJyZW50U3JjKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnc2V0VVJMVG8nLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbIHJlc3VsdCBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG5cbmV4cG9ydCB7XG4gICAgQnJvd3NlclZpZXcsXG4gICAgQnJvd3NlclZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQnV0dG9uVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgd2ViY29tcG9uZW50IHJlcHJlc2VudGluZyBhIEJ1dHRvbi5cbiAqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbiAgICAgICAgICAgICAgICA8c3R5bGU+XG4gICAgICAgICAgICAgICAgIC5zdC1idXR0b24tbGFiZWwge1xuICAgICAgICAgICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgICAgICAgICAgIG1heC13aWR0aDogOTUlO1xuICAgICAgICAgICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvc3R5bGU+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdC1idXR0b24tbGFiZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3Q+PC9zbG90PjwhLS0gVGV4dCBvZiB0aGUgTmFtZSAtLT5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG5gO1xuXG5jbGFzcyBCdXR0b25WaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldHVwIHByb3AgY2hhbmdlIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb3BIYW5kbGVycygpe1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbmFtZScsICh2YWx1ZSwgcGFydElkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICBsZXQgYnV0dG9uTmFtZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcIm5hbWVcIik7XG4gICAgICAgIGlmKGJ1dHRvbk5hbWUpe1xuICAgICAgICAgICAgdGhpcy5pbm5lclRleHQgPSBidXR0b25OYW1lO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHRoZSBiYXNlIGNsYXNzIGltcGxlbWVudGF0aW9uXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNsaWNrIGNvbW1hbmQgbWVzc2FnZSB0byBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdmVyd3JpdGluZyB0aGUgYmFzZSBjbGFzcyBvcGVuL2Nsb3NlIGVkaXRvciBtZXRob2RzXG4gICAgb3BlbkVkaXRvcigpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLm9wZW5FZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgIH1cblxuICAgIGNsb3NlRWRpdG9yKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xvc2VFZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQnV0dG9uVmlldyxcbiAgICBCdXR0b25WaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIENhcmRWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHdlYmNvbXBvbmVudCByZXByZXNlbnRhdGlvbiBvZiBhIENhcmQuXG4gKi9cblxuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbiAgICAgICAgICAgICAgICA8c3R5bGU+XG4gICAgICAgICAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgICAgICAgICA8c2xvdD48L3Nsb3Q+XG5gO1xuXG5jbGFzcyBDYXJkVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBIYWxvIHNldHRpbmdzLiBDYXJkcyBkb24ndCB3YW50XG4gICAgICAgIC8vYSBoYWxvIHRvIG9wZW5cbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGNsYXNzIG1ldGhvZFxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiBldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDb250ZXh0TWVudUl0ZW1zKGNvbnRleHRNZW51KXtcbiAgICAgICAgY29udGV4dE1lbnUuYWRkU3BhY2VyKCk7XG4gICAgICAgIC8vIFRvb2xib3ggdG9nZ2xlIGhpZGUvdW5oaWRlXG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB3aW5kb3cuU3lzdGVtLmdldEN1cnJlbnRTdGFja01vZGVsKCk7XG4gICAgICAgIGxldCB0b29sYm94ID0gY3VycmVudFN0YWNrLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQocGFydCwgXCJuYW1lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT0gXCJUb29sYm94XCI7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyB0b29sYm94IGF0IGFsbCwgdGhhdCdzIHdlaXJkIGJ1dCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZih0b29sYm94KXtcbiAgICAgICAgICAgIGxldCBoaWRkZW4gPSB0b29sYm94LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodG9vbGJveCwgXCJoaWRlXCIpO1xuICAgICAgICAgICAgaWYoaGlkZGVuKXtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgXCJVbmhpZGUgVG9vbGJveFwiLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xib3gucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0b29sYm94LCBcImhpZGVcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiSGlkZSBUb29sYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbGJveC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRvb2xib3gsIFwiaGlkZVwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIENhcmRWaWV3LFxuICAgIENhcmRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEZpZWxkVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIHRoZSB2aWV3IG9mIGFuIEZpZWxkIHBhcnQuXG4gKiBJIGFtIGFuIFwiaW50ZXJpbVwiIHZpZXcgaW50ZW5kZWQgdG8gZGlzcGxheVxuICogYW5kIGVkaXQgcGxhaW4gdGV4dCBvbiBhIENhcmQuXG4gKiBJIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGEgbW9yZSBjb21wcmVoZW5zaXZlXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBGaWVsZC9GaWVsZFZpZXcgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuaW1wb3J0IGNzc1N0eWxlciBmcm9tICcuLi91dGlscy8vc3R5bGVyLmpzJztcbmltcG9ydCBDb2xvcldoZWVsV2lkZ2V0IGZyb20gJy4vZHJhd2luZy9Db2xvcldoZWVsV2lkZ2V0LmpzJztcbmltcG9ydCBpbnRlcnByZXRlclNlbWFudGljcyBmcm9tICcuLi8uLi9vaG0vaW50ZXJwcmV0ZXItc2VtYW50aWNzLmpzJztcbmltcG9ydCBjcmVhdGVIaWdobGlnaHRlciBmcm9tICcuLi91dGlscy9BbHRTeW50YXhIaWdobGlnaHRlci5qcyc7XG5cbmNvbnN0IGhhbG9FZGl0QnV0dG9uU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXRvb2xzXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0zIDIxaDRsMTMgLTEzYTEuNSAxLjUgMCAwIDAgLTQgLTRsLTEzIDEzdjRcIiAvPlxuICA8bGluZSB4MT1cIjE0LjVcIiB5MT1cIjUuNVwiIHgyPVwiMTguNVwiIHkyPVwiOS41XCIgLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjEyIDggNyAzIDMgNyA4IDEyXCIgLz5cbiAgPGxpbmUgeDE9XCI3XCIgeTE9XCI4XCIgeDI9XCI1LjVcIiB5Mj1cIjkuNVwiIC8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCIxNiAxMiAyMSAxNyAxNyAyMSAxMiAxNlwiIC8+XG4gIDxsaW5lIHgxPVwiMTZcIiB5MT1cIjE3XCIgeDI9XCIxNC41XCIgeTI9XCIxOC41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgaGFsb0xvY2tCdXR0b25TVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbG9ja1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHJlY3QgeD1cIjVcIiB5PVwiMTFcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTBcIiByeD1cIjJcIj48L3JlY3Q+XG4gICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjE2XCIgcj1cIjFcIj48L2NpcmNsZT5cbiAgIDxwYXRoIGQ9XCJNOCAxMXYtNGE0IDQgMCAwIDEgOCAwdjRcIj48L3BhdGg+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGhhbG9VbmxvY2tCdXR0b25TVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbG9jay1vcGVuXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8cmVjdCB4PVwiNVwiIHk9XCIxMVwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMlwiPjwvcmVjdD5cbiAgIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTZcIiByPVwiMVwiPjwvY2lyY2xlPlxuICAgPHBhdGggZD1cIk04IDExdi01YTQgNCAwIDAgMSA4IDBcIj48L3BhdGg+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGZpZWxkVGVtcGxhdGVTdHJpbmcgPSBgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIC5maWVsZCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLmZpZWxkIGNvbG9yLXdoZWVsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5maWVsZC10ZXh0YXJlYSB7XG4gICAgICAgICAgICB3aWR0aDogY2FsYygxMDAlIC0gNXB4KTtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgICAgICAgICAgb3ZlcmZsb3ctd3JhcDogYW55d2hlcmU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBTeW50YXggSGlnaGxpZ2h0aW5nXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5zcGFuW2RhdGEtc3QtcnVsZT1cIm1lc3NhZ2VOYW1lXCJde1xuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xufVxuXG5zcGFuW2RhdGEtc3QtcnVsZT1cImtleXdvcmRcIl17XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG59XG5cbnNwYW5bZGF0YS1zdC1ydWxlPVwiUGFyYW1ldGVyTGlzdC1pdGVtXCJde1xuICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcbiAgICBjb2xvcjogZ3JleTtcbn1cblxuXG4gICAgPC9zdHlsZT5cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkLXRleHRhcmVhXCIgc3BlbGxjaGVjaz1cImZhbHNlXCI+PC9kaXY+XG4gICAgPC9kaXY+YDtcblxuXG5mdW5jdGlvbiBmb3JtYXREb2Moc0NtZCwgc1ZhbHVlKSB7XG4gIGRvY3VtZW50LmV4ZWNDb21tYW5kKHNDbWQsIGZhbHNlLCBzVmFsdWUpOyBvRG9jLmZvY3VzKCk7XG59XG5cbmNsYXNzIEZpZWxkVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIHRoaXMuZWRpdG9yQ29tcGxldGVyID0gdGhpcy5zaW1wbGVUYWxrQ29tcGxldGVyO1xuICAgICAgICB0aGlzLnRleHRTdHlsZXIgPSBjc3NTdHlsZXI7ICAvLyB3ZSBtaWdodCB3YW50IHRvIGNvbnNpZGVyIGEgbW9yZSBwcm9ncmFtbWF0aWMgd2F5IHRvIHNldCB0aGlzXG4gICAgICAgIHRoaXMuZWRpdG9yQ29tcGxldGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudU9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYWxvTG9ja1VubG9ja0J1dHRvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2VzID0ge307XG4gICAgICAgIHRoaXMud2FudHNDb250ZXh0TWVudSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFByZXNldHMgZm9yIHN5bnRheCBoaWdobGlnaHRpbmcuXG4gICAgICAgIC8vIFdoZW4gaGlnaGxpZ2h0aW5nIGlzIGVuYWJsZWQsIHdlIHdpbGwgY2hlY2tcbiAgICAgICAgLy8gZWFjaCBsaW5lIG9mIHRoZSB0ZXh0IGZvciB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIGdyYW1tYXRpY2FsIHJ1bGVzOlxuICAgICAgICB0aGlzLl9zeW50YXhSdWxlcyA9IFtcbiAgICAgICAgICAgIFwiTWVzc2FnZUhhbmRsZXJPcGVuXCIsXG4gICAgICAgICAgICBcIk1lc3NhZ2VIYW5kbGVyQ2xvc2VcIlxuICAgICAgICBdO1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IGZpZWxkVGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmluZCBtZXRob2RzXG4gICAgICAgIHRoaXMub25JbnB1dCA9IHRoaXMub25JbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQmVmb3JlSW5wdXQgPSB0aGlzLm9uQmVmb3JlSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25LZXlkb3duID0gdGhpcy5vbktleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlZG93biA9IHRoaXMub25Nb3VzZWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnUgPSB0aGlzLm9wZW5Db250ZXh0TWVudS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUgPSB0aGlzLmNsb3NlQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb0l0ID0gdGhpcy5kb0l0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0aW9uID0gdGhpcy5oYW5kbGVTZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuRmllbGQgPSB0aGlzLm9wZW5GaWVsZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRleHRUb0h0bWwgPSB0aGlzLnRleHRUb0h0bWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycyA9IHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zaW1wbGVUYWxrQ29tcGxldGVyID0gdGhpcy5zaW1wbGVUYWxrQ29tcGxldGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b25zID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnNlcnRSYW5nZSA9IHRoaXMuaW5zZXJ0UmFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRSYW5nZUluVGFyZ2V0ID0gdGhpcy5zZXRSYW5nZUluVGFyZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uID0gdGhpcy5zZXRTZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTeW50YXggPSB0aGlzLmhpZ2hsaWdodFN5bnRheC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0U3ludGF4ID0gdGhpcy51bmhpZ2hsaWdodFN5bnRheC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb3BIYW5kbGVycygpe1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnZWRpdGFibGUnLCAodmFsdWUsIGlkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdmFsdWUpO1xuICAgICAgICAgICAgaWYodmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSB0aGlzLmhhbG9Mb2NrQnV0dG9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChcImVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSB0aGlzLmhhbG9VbmxvY2tCdXR0b247XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFwiZWRpdGFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAndGV4dCcgaXMgYSBEeW5hbWljUHJvcCB3aG9zZSBzZXR0ZXIgd2lsbCBzZXQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLy8gdmFsdWUgZm9yIGBpbm5lckhUTUxgLiBUaGlzIHdheSB3ZSBjYW4gaGF2ZSBwcm9ncmFtbWF0aWMgY29udGVudFxuICAgICAgICAvLyBzZXR0aW5nIGFuZCBzdGlsbCBhbGxvdyB0byBub3QgbG9vc2UgbWFya3VwLlxuICAgICAgICAvLyAnaW5uZXJIVE1MJyBpcyBhIEJhc2ljUHJvcC4gU2VlIGhvdyB0aGVzZSBhcmUgc2V0LCB3aXRob3V0XG4gICAgICAgIC8vIG5vdGlmaWNhdGlvbiBpbiB0aGlzLm9uSW5wdXQoKVxuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnaW5uZXJIVE1MJywgKHZhbHVlLCBpZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJUZXh0LFxuICAgICAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnksIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIC8vIFRoZSBldmVudHMgaGVyZSBhcmUgYWRkZWQgdmlhIHRoZSAuYWRkRXZlbnRMaXN0ZW5lcigpIEFQSSB3aGljaCBpc1xuICAgICAgICAvLyBkaXN0aW5jdCBmcm9tIHRoZSB0aGlzLmV2ZW50UmVzcG9uZCgpIHdoaWNoIHVzZXMgdGhlIERPTSBlbGVtZW50XG4gICAgICAgIC8vIGVsZW1lbnQub25FdmVudCBBUEkuIFRoaXMgYWxsb3dzIHVzIHRvIGRpc3RuZ3Vpc2ggYmV0d2VlbiBcImNvcmVcIlxuICAgICAgICAvLyBzeXN0ZW0td2ViIGV2ZW50cyB0aGF0IHdlIGRvbid0IHdhbnQgbWVkZGxlZCB3aXRoIGF0IHRoZSBtb21lbnQsIGxpa2VcbiAgICAgICAgLy8gZW50ZXJpbmcgdGV4dCBpbiBhIGZpZWxkLCBhbmQgb25lcyBleHBvc2VkIGluIHRoZSBlbnZpcm9uZW1udCBmb3Igc2NyaXB0aW5nXG4gICAgICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC10ZXh0YXJlYScpO1xuXG4gICAgICAgIHRoaXMudGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXQpO1xuICAgICAgICAvL3RoaXMudGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCB0aGlzLm9uQmVmb3JlSW5wdXQpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bik7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93bik7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIGEgY2xpY2sgbGlzdGVuZXIgYXMgdGhlIGJhc2UgUGFydFZpZXcgY2xhc3MgZG9lcyB0aGF0XG5cbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZGVhbCB3aXRoIHJhbmdlIGluc2VydGlvbnMgKGZvciBzdHlsaW5nIHRleHQgZnJhZ21lbnRzIHdpdGhpblxuICAgICAgICAvLyB0aGUgdGV4dGFyZWEpLCB3ZSBuZWVkIHRvIGhhdmUgdGhlIGRlZmF1bHQgcGFyYWdyYXBoIHRhZyA9IDwvYnI+LiBPdGhlcndpc2VcbiAgICAgICAgLy8gdGhlIGluc2VydCBuZXcgbGluZSBpcyBvZiB0aGUgZm9ybSA8ZGl2PjwvYnI+PGRpdj4gd2hpY2ggY2F1c2VzIHRoZSBhcHBlYXJhbmNlXG4gICAgICAgIC8vIG9mIG5ld2xpbmVzIHdoZW4gbm9kZXMgYXJlIGluc2VydGVkIGludG8gYSByYW5nZVxuICAgICAgICAvL2RvY3VtZW50LmV4ZWNDb21tYW5kKFwiZGVmYXVsdFBhcmFncmFwaFNlcGFyYXRvclwiLCBmYWxzZSwgXCJzdC1saW5lXCIpO1xuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgICAgIHRoaXMudGV4dGFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXQpO1xuICAgICAgICAvL3RoaXMudGV4dGFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCB0aGlzLm9uQmVmb3JlSW5wdXQpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bik7XG4gICAgICAgIHRoaXMudGV4dGFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93bik7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICB0aGlzLnRleHRhcmVhID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZmllbGQtdGV4dGFyZWEnKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1vZGVsLCBzZXQgdGhlIHZhbHVlIG9mIHRoZSB0ZXh0YXJlYVxuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBodG1sIG9mIHRoZSBmaWVsZCBtb2RlbFxuICAgICAgICBsZXQgaW5uZXJIVE1MID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdpbm5lckhUTUwnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuXG4gICAgICAgIGxldCBpc0VkaXRhYmxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiZWRpdGFibGVcIik7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBpc0VkaXRhYmxlKTtcblxuICAgICAgICAvLyBzZXR1cCB0aGUgbG9jay91bmxvY2sgaGFsbyBidXR0b25cbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbnMoKTtcbiAgICAgICAgbGV0IGVkaXRhYmxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdlZGl0YWJsZSdcbiAgICAgICAgKTtcbiAgICAgICAgaWYoZWRpdGFibGUgPT09IHRydWUpe1xuICAgICAgICAgICAgdGhpcy5oYWxvTG9ja1VubG9ja0J1dHRvbiA9IHRoaXMuaGFsb0xvY2tCdXR0b247XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0YWJsZSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgdGhpcy5oYWxvTG9ja1VubG9ja0J1dHRvbiA9IHRoaXMuaGFsb1VubG9ja0J1dHRvbjtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcImVkaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2ltcGxlVGFsa0NvbXBsZXRlcihlbGVtZW50KXtcbiAgICAgICAgbGV0IHRleHRDb250ZW50ID0gdGhpcy5odG1sVG9UZXh0KGVsZW1lbnQpO1xuICAgICAgICBsZXQgc3RhcnRPZkhhbmRsZXJSZWdleCA9IC9eb25cXHMoXFx3KykoXFxzfFxcbikrJC87XG4gICAgICAgIGxldCBtYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHN0YXJ0T2ZIYW5kbGVyUmVnZXgpO1xuICAgICAgICBpZihtYXRjaCl7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZU5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIC8vIGlmIGlucHV0IGJyZWFrIGlzIGEgbmV3IGxpbmUgdGhlbiBhbiBleHRyYVxuICAgICAgICAgICAgLy8gPGRpdj48L2JyPjwvZGl2PiBoYXMgYmVlZCBhZGRlZCBpbnRvIHRoZSBlbGVtZW4gYWxyZWFkeVxuICAgICAgICAgICAgbGV0IHRhYkxpbmUgPSBcIlxcdFxcblwiO1xuICAgICAgICAgICAgaWYobWF0Y2hbMl0gPT09IFwiXFxuXCIpe1xuICAgICAgICAgICAgICAgIHRhYkxpbmU9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0Q29udGVudCA9IGAke3RhYkxpbmV9ZW5kICR7bWVzc2FnZU5hbWV9YDtcbiAgICAgICAgICAgIGxldCBpbm5lckhUTUwgPSB0aGlzLnRleHRUb0h0bWwodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgaW5uZXJIVE1MKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJIG92ZXJyaWRlIG15IGJhc2UtY2xhc3MncyBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGFyZ2V0IHJlbGF0ZWQgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIHN0eWxlVGV4dENTUygpe1xuICAgICAgICBsZXQgdGV4dGFyZWEgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC10ZXh0YXJlYScpO1xuICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJjc3NUZXh0U3R5bGVcIik7XG4gICAgICAgIE9iamVjdC5rZXlzKGNzc1N0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNzc1N0eWxlW2tleV07XG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHRhcmdldCBhbmQgcmFuZ2Ugc2V0IHRoZW4gc2VuZCB0aGUgdGFyZ2V0IGFuIHVwZGF0ZSBtZXNzYWdlXG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgJ3RhcmdldCcpO1xuICAgICAgICBpZih0YXJnZXQpe1xuICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluVGFyZ2V0KHRhcmdldCwgdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwsIGNzc1N0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogc2V0IGEgdGV4dC0qIHByb3BlcnR5IG9uIHNlbGVjdGlvbiB0byBzdHlsZSB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgICAqIE5vdGU6IHRoaXMgaXMgZG9uZSBmb3IgZXZlcnkgY3VycmVudCBzZWxlY3Rpb24sIGkuZS4gZXZlcnRoaW5nXG4gICAgICogaW4gdGhpcy5zZWxlY3Rpb25SYW5nZXNcbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb24ocHJvcE5hbWUsIHZhbHVlKXtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLnNlbGVjdGlvblJhbmdlcykuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3R5bGUgPSB7fTtcbiAgICAgICAgICAgIC8vIC8vIGlmIHRoZSBkb2N1bWVudCBmcmFnbWVudCBoYXMgb25lIGNoaWxkIG5vZGUgYW5kIGl0J3MgYSBzcGFuXG4gICAgICAgICAgICAvLyAvLyB3ZSBzaG91bGQgc3R5bGUgdGhhdCBkaXJlY3RseS4gVGhpcyBhdm9pZHMgdW5uY2Vzc2FyeSBET00gZWxlbWVudHNcbiAgICAgICAgICAgIC8vIC8vIGJlaW5nIGNyZWF0ZWQgdG8gd3JhcCB0aGUgY29udGVudHMsIHN1Y2ggYXMgd2hlbiBzdHlsaW5nIGlzIGNvbnRpbnVhbGx5XG4gICAgICAgICAgICAvLyAvLyBhcHBsaWVkIG90IHRoZSBzYW1lIHNlbGVjdGlvblxuICAgICAgICAgICAgLy8gbGV0IHNwYW47XG4gICAgICAgICAgICAvLyBpZihkb2NGcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIGRvY0ZyYWdtZW50LmNoaWxkTm9kZXNbMF0ubm9kZU5hbWUgPT0gXCJTUEFOXCIpe1xuICAgICAgICAgICAgLy8gICAgIHNwYW4gPSBkb2NGcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgLy8gICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBPYmVqY3QudmFsdWVzIGhlcmUgZm9yIHRoZSBET00gc3R5bGUgYXR0cmlidXRlIG9iamVjdFxuICAgICAgICAgICAgLy8gICAgIC8vIHRoYXQncyB3ZWlyZFxuICAgICAgICAgICAgLy8gICAgIE9iamVjdC52YWx1ZXMoc3Bhbi5zdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGN1cnJlbnRTdHlsZVtrZXldID0gc3Bhbi5zdHlsZVtrZXldO1xuICAgICAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHNwYW4gZWxlbWVudCB0byB3cmFwIHRoZSBjb250ZW50cyBpbiBzdHlsZVxuICAgICAgICAgICAgLy8gICAgIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAvLyAgICAgLy8gV2hpbGUgdGVtcHRpbmcgdG8gdXNlIHJhbmdlLnN1cnJvdW5kQ29udGVudHMoKSBhdm9pZCB0aGlzXG4gICAgICAgICAgICAvLyAgICAgLy8gc2luY2UgaXQgd2lsbCBmYWlsIHdpdGggYSBub24taW5mb3JtYXRpdmUgZXJyb3IgaWYgdGhlIHJhbmdlXG4gICAgICAgICAgICAvLyAgICAgLy8gaW5jbHVkZXMgcGFydGlhbCBub2RlcyAoZXggdGV4dCBhY3Jvc3MgdmFyaW91cyBub2RlcylcbiAgICAgICAgICAgIC8vICAgICB3aGlsZSAoZG9jRnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGgpe1xuICAgICAgICAgICAgLy8gICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY0ZyYWdtZW50LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgbGV0IGNzc09iamVjdCA9IHRoaXMudGV4dFN0eWxlcihjdXJyZW50U3R5bGUsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjc3NPYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uc3R5bGVba2V5XSA9IGNzc09iamVjdFtrZXldO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKHJhbmdlLmV4dHJhY3RDb250ZW50cygpKTtcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoc3Bhbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdpbm5lckhUTUwnLFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLFxuICAgICAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHRhcmdldCBhbmQgcmFuZ2Ugc2V0IHRoZW4gc2VuZCB0aGUgdGFyZ2V0IGFuIHVwZGF0ZSBtZXNzYWdlXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsICd0YXJnZXQnKTtcbiAgICAgICAgICAgIGlmKHRhcmdldCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluVGFyZ2V0KHRhcmdldCwgdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkJlZm9yZUlucHV0KGV2ZW50KXtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBsZXQgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3RlZFJhbmdlLmNsb25lUmFuZ2UoKTtcblxuICAgICAgICBsZXQgaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTDtcbiAgICAgICAgaWYoIWlubmVySFRNTC5lbmRzV2l0aChcIjxkaXY+PGJyPjwvZGl2PlwiKSl7XG4gICAgICAgICAgICBpbm5lckhUTUwgKz0gXCI8ZGl2Pjxicj48L2Rpdj5cIjtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGV2ZW50LmlucHV0VHlwZSA9PSBcImluc2VydFBhcmFncmFwaFwiKXtcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBsZXQgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpO1xuICAgICAgICAgICAgbGV0IGJyMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGJyKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoYnIyKTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIoYnIyKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKGJyMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbklucHV0KGV2ZW50KXtcbiAgICAgICAgbGV0IGlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgIC8qXG4gICAgICAgIGlmKCFpbm5lckhUTUwuZW5kc1dpdGgoXCI8YnI+XCIpKXtcbiAgICAgICAgICAgIGlubmVySFRNTCArPSBcIjxicj5cIjtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICBpZih0aGlzLmVkaXRvckNvbXBsZXRlcil7XG4gICAgICAgICAgICAvLyBUT0RPIHNvcnQgb3V0IGhvdyB0aGlzIHdvdWxkIHdvcmtcbiAgICAgICAgICAgIGxldCBpbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgaW5uZXJIVE1MID0gdGhpcy5lZGl0b3JDb21wbGV0ZXIoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJUZXh0LFxuICAgICAgICAgICAgZmFsc2UgLy8gZG8gbm90IG5vdGlmeSwgdG8gcHJlc2VydmUgY29udGVudGVkaXRhYmxlIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdpbm5lckhUTUwnLFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCxcbiAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnlcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU2luY2Ugd2UgdXBkYXRlIHRoZSAndGV4dCcgcHJvcGVydHkgd2l0aG91dCBub3RpZmljYXRpb24sIHRoZSBwYXJ0L21vZGVsXG4gICAgICAgIC8vIGlzIG5vdCBzZW50IHRoZSBcInByb3BlcnR5Q2hhbmdlZFwiIG1lc3NhZ2Ugc28gd2UgZG8gc28gbWFudWFsbHlcbiAgICAgICAgdGhpcy5tb2RlbC5wcm9wZXJ0eUNoYW5nZWQoXCJ0ZXh0XCIsIGV2ZW50LnRhcmdldC5pbm5lclRleHQpO1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHRhcmdldCBhbmQgcmFuZ2Ugc2V0IHRoZW4gc2VuZCB0aGUgdGFyZ2V0IGFuIHVwZGF0ZSBtZXNzYWdlXG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgJ3RhcmdldCcpO1xuICAgICAgICBpZih0YXJnZXQpe1xuICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluVGFyZ2V0KHRhcmdldCwgZXZlbnQudGFyZ2V0LmlubmVySFRNTCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbktleWRvd24oZXZlbnQpe1xuICAgICAgICAvLyBwcmV2ZW50IHRoZSBkZWZhdWx0IHRhYiBrZXkgdG8gbGVhdmUgZm9jdXMgb24gdGhlIGZpZWxkXG4gICAgICAgIGlmKGV2ZW50LmtleT09PVwiVGFiXCIpe1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydEhUTUwnLCBmYWxzZSwgJyYjeDknKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuXG4gICAgICAgICAgICBsZXQgdGFiTm9kZVZhbHVlID0gJ1xcdCc7XG4gICAgICAgICAgICBsZXQgdGFiTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRhYk5vZGVWYWx1ZSk7XG5cbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUodGFiTm9kZSk7XG5cbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIodGFiTm9kZSk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcih0YWJOb2RlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBvbk1vdXNlZG93bihldmVudCl7XG4gICAgICAgIC8vIGNsZWFyIGFsbCBzZWxlY3Rpb25zXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2VzID0ge307XG4gICAgfVxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDApe1xuICAgICAgICAgICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIHdlIHRvZ2dsZSB0aGUgaGFsb1xuICAgICAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgICAgIHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHRleHQgaXMgc2VsZWN0ZWQgd2UgZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIGlmKHRleHQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYWx0S2V5IGlzIHByZXNzZWQgd2Ugb3BlbiB0aGUgY29udGV4dCAoXCJkbyBpdFwiKSBtZW51XG4gICAgICAgICAgICAgICAgICAgIGlmKGV2ZW50LmFsdEtleSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5jb250ZXh0TWVudU9wZW4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdGlvbihldmVudC5tZXRhS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBubyBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbnRleHRNZW51T3Blbil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBhbGwgdGhlIHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJIGhhbmRsZSBzZWxlY3RlZCB0ZXh0LCBjcmVhdGluZyBhIG5ldyBmaWVsZCBtb2RlbC92aWV3XG4gICAgICogZm9yIGV2ZXJ5IHJhbmdlIGluIHRoZSBzZWxlY3Rpb24sIGtlZXBpbmcgdHJhY2sgb2YgZXZlcnkgcmFuZ2VcbiAgICAgKiBpbiB0aGlzLnNlbGVjdGlvbiBPYmplY3QvZGljdCBzbyB0aGF0IG1vZGlmaWNhdGlvbiBjYW4gYmUgaW5zZXJ0ZWRcbiAgICAgKiBiYWNrIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgcmFuZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZVNlbGVjdGlvbihvcGVuTmV3RmllbGQpe1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBmb3IobGV0IGk9MDsgaSA8IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpKyspe1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoaXMgaXMgbm90IGEgY29udGludWluZyBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIGFuZCB0aGF0IHRoZSByYW5nZSBpcyBub3QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UmFuZ2VzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnNlbGVjdGlvblJhbmdlcyk7XG4gICAgICAgICAgICBpZihjdXJyZW50UmFuZ2VzLmluZGV4T2YocmFuZ2UpID49IDApe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgZ2VuZXJhdGUgb3VyIG93biByYW5nZSBpZHMsIHNpbmNlIHdlIHdhbnQgdGhpcyB0byBjb3JyZXNwb25kIHRvXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gb3JkZXIgd2hpY2ggaXMgbm90IHJlc3BlY3RlZCBieSB0aGUgYnJvd3NlciBzZWxlY3Rpb24gb2JqZWN0XG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgd2UgZG9uJ3QgaGl0IG9uIG90aGVyIHZpZXdzJyByYW5nZXMgYnkgYWNjaWRlbnQgd2UgbmVlZCB1bmlxdWUgaWQnc1xuICAgICAgICAgICAgbGV0IHJhbmdlSWQgPSBEYXRlLm5vdygpOyAvL1RPRE8gd2UgbmVlZCBhIGJldHRlciByYW5kb20gaWRcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2VzW3JhbmdlSWRdID0gcmFuZ2U7XG4gICAgICAgICAgICBpZihvcGVuTmV3RmllbGQpe1xuICAgICAgICAgICAgICAgIC8vIG9wZW4gYSBmaWVsZCBmb3IgZWFjaCBuZXcgc2VsZWN0aW9uIGFuZCBwb3B1bGF0ZSBpdCB3aXRoIHRoZSByYW5nZSBodG1sXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRmllbGQocmFuZ2UsIHJhbmdlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkZpZWxkKHJhbmdlLCByYW5nZUlkKXtcbiAgICAgICAgLy8gY3JlYXRlIGFuIEhUTUwgZG9jdW1lbnQgZnJhZ21lbnQgZnJvbSB0aGUgcmFuZ2UgdG8gYXZvaWQgZGVhbGluZyB3aWh0IHN0YXJ0L2VuZFxuICAgICAgICAvLyBhbmQgb2Zmc2V0IGNhbGN1bGF0aW9uc1xuICAgICAgICAvLyBmcmFnbWVudHMgZG9uJ3QgaGF2ZSB0aGUgZnVsbCBodG1sIERPTSBlbGVtZW50IEFQSSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQocmFuZ2UuY2xvbmVDb250ZW50cygpKTtcblxuICAgICAgICAvLyBUT0RPIHRoZXNlIHNob3VsZCBhbGwgYmUgbWVzc2FnZXMgYW5kIGNvcnJlc3BuZGluZyBjb21tYW5kIGhhbmRsZXIgZGVmaW5pdGlvbnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIHBhcnQgb2YgdGhlIGZpZWxkJ3Mgb3duIHNjcmlwdFxuICAgICAgICBsZXQgZmllbGRNb2RlbCA9IHdpbmRvdy5TeXN0ZW0ubmV3TW9kZWwoXCJmaWVsZFwiLCB0aGlzLm1vZGVsLl9vd25lci5pZCwgYHNlbGVjdGlvbiAke3JhbmdlSWR9YCk7XG4gICAgICAgIGZpZWxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChmaWVsZE1vZGVsLCBcImlubmVySFRNTFwiLCBzcGFuLmlubmVySFRNTCk7XG4gICAgICAgIGZpZWxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChmaWVsZE1vZGVsLCBcInRhcmdldFwiLCBgZmllbGQgaWQgJHt0aGlzLm1vZGVsLmlkfWApO1xuICAgICAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoZmllbGRNb2RlbCwgXCJ0YXJnZXRSYW5nZUlkXCIsIHJhbmdlSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBHaXZlbiBhIHRhZ3JnZXQgc3BlY2lmaWVyIGFuZCBodG1sXG4gICAgICAqIEkgZmlyc3QgbG9vayB1cCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdGFyZ2V0IGhhcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgKiByYW5nZSAoY29taW5nIGZyb20gdGhlIHRhcmdldFJhbmdlSWQgcHJvcGVydHkpLCBhbmQgdGhlbiBzZXQgaXQgd2l0aCBteVxuICAgICAgKiBpbm5lckhUTUwuIE5vdGUsIHNpbmNlIHRoZSB0YXJnZXQgcHJvcGVydHkgdmFsdWUgaXMgYW4gb2JqZWN0IHNwZWNpZmllciBJXG4gICAgICAqIGNyZWF0ZSBhIHNlbWFudGljcyBvYmplY3RzIGFuZCBpbnRlcnByZXQgdGhlIHZhbHVlIHJlc3VsdGluZyBpbiBhIHZhbGlkXG4gICAgICAqIHBhcnQgaWQuXG4gICAgICAqL1xuICAgIHNldFJhbmdlSW5UYXJnZXQodGFyZ2V0U3BlY2lmaWVyLCBodG1sLCBjc3Mpe1xuICAgICAgICBsZXQgdGFyZ2V0UmFuZ2VJZCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCAndGFyZ2V0UmFuZ2VJZCcpO1xuICAgICAgICBsZXQgbWF0Y2ggPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIubWF0Y2godGFyZ2V0U3BlY2lmaWVyLCBcIk9iamVjdFNwZWNpZmllclwiKTtcbiAgICAgICAgbGV0IHNlbWFudGljcyA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgc2VtYW50aWNzLmFkZE9wZXJhdGlvbignaW50ZXJwcmV0JywgaW50ZXJwcmV0ZXJTZW1hbnRpY3ModGhpcy5tb2RlbCwgd2luZG93LlN5c3RlbSkpO1xuICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobWF0Y2gpLmludGVycHJldCgpO1xuXG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogXCJpbnNlcnRSYW5nZVwiLFxuICAgICAgICAgICAgYXJnczogW3RhcmdldFJhbmdlSWQsIGh0bWwsIGNzc11cbiAgICAgICAgfSwgd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbdGFyZ2V0SWRdKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEkgaW5zZXJ0IHRoZSBodG1sIChzdHJpbmcpIGludG8gdGhlIHNwZWNpZmllZCByYW5nZSAoYnkgaWQpXG4gICAgICovXG4gICAgaW5zZXJ0UmFuZ2UocmFuZ2VJZCwgaHRtbCwgY3NzT2JqKXtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5zZWxlY3Rpb25SYW5nZXNbcmFuZ2VJZF07XG4gICAgICAgIGlmKHJhbmdlKXtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgc3Bhbi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgaWYoY3NzT2JqKXtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjc3NPYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjc3NPYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShzcGFuKTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdGV4dCBhbmQgaW5uZXJIVE1MIHByb3BlcnRpZXMgd2l0aG91dCBub3RpZmljYXRpb25cbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnkgc2V0dGluZyBvZiB0aGUgdGV4dC9odG1sXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5pbm5lclRleHQsXG4gICAgICAgICAgICAgICAgZmFsc2UgLy8gZG8gbm90IG5vdGlmeSwgdG8gcHJlc2VydmUgY29udGVudGVkaXRhYmxlIGNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaW5uZXJIVE1MJyxcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVySFRNTCxcbiAgICAgICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkNvbnRleHRNZW51KCl7XG4gICAgICAgIGxldCB0ZXh0ID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGZvY3VzTm9kZSA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLmZvY3VzTm9kZTtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIGJ1dHRvbi5pZCA9IFwiZG9JdFwiO1xuICAgICAgICBidXR0b24uc3R5bGUubWFyZ2luTGVmdCA9IFwiMTBweFwiO1xuICAgICAgICBidXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ2YXIoLS1wYWxldHRlLWdyZWVuKVwiO1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSBcIkRvIGl0IVwiO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuZG9JdCk7XG4gICAgICAgIGZvY3VzTm9kZS5hZnRlcihidXR0b24pO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51T3BlbiA9IHRydWU7XG4gICAgfTtcblxuICAgIGNsb3NlQ29udGV4dE1lbnUoKXtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI2RvSXQnKTtcbiAgICAgICAgaWYoYnV0dG9uKXtcbiAgICAgICAgICAgIGJ1dHRvbi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciB0aGUgc2VsZWN0aW9uIGFuZCBzZXQgdGhlIGNvbnRleHQgbWVudSB0byBjbG9zZWRcbiAgICAgICAgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVPcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZG9JdChldmVudCl7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGNsZWFuIHVwIHRoZSB0ZXh0IHRvIG1ha2Ugc3VyZSBubyBuZXdsaW5lcyBvciBzcGFjZXMgbWFkZSBpdCBpblxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eW1xcdFxcbiBdKy8sIFwiXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9bXFx0XFxuIF0rJC8sIFwiXCIpO1xuICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgLy8gc2VuZCBtZXNzYWdlIHRvIGNvbXBpbGUgdGhlIHByZXBwZWQgc2NyaXB0XG4gICAgICAgIGxldCBzY3JpcHQgPSBgb24gZG9JdFxcbiAgICR7dGV4dH1cXG5lbmQgZG9JdGA7XG4gICAgICAgIC8vIHNlbmQgdGhlc2UgbWVzc2FnZXMgZnJvbSB0aGUgbW9kZWwgKG5vdCB0aGUgdmlldylcbiAgICAgICAgLy8gc2luY2UgaWYgdGhlcmUgaXMgYW4gZXJyb3IgdGhlIG9yaWdpbmFsIHNlbmRlciB3aWxsXG4gICAgICAgIC8vIGhhdmUgYW4gaWRcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbXBpbGVcIixcbiAgICAgICAgICAgICAgICBjb2RlU3RyaW5nOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHRoaXMubW9kZWwuaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZG9JdFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b25zKCl7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5pZCA9IFwiaGFsby1maWVsZC1sb2NrLWVkaXRvclwiO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uaW5uZXJIVE1MID0gaGFsb0xvY2tCdXR0b25TVkc7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uc3R5bGUubWFyZ2luUmlnaHQgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdib3R0b20tcm93Jyk7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdMb2NrIEVkaXRpbmcnKTtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ3NldFByb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJlZGl0YWJsZVwiLCBmYWxzZV0sXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5IYWxvKCk7XG4gICAgICAgICAgICAvLyBjbG9zZS9vcGVuIHRoZSBoYWxvIHRvIHVwZGF0ZSB0aGUgZWRpdGluZyBzdGF0ZSB0b2dnbGUgYnV0dG9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLmlkID0gXCJoYWxvLWZpZWxkLXVubG9jay1lZGl0b3JcIjtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5pbm5lckhUTUwgPSBoYWxvVW5sb2NrQnV0dG9uU1ZHO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uc3R5bGUubWFyZ2luUmlnaHQgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ2JvdHRvbS1yb3cnKTtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnVW5sb2NrIEVkaXRpbmcnKTtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnc2V0UHJvcGVydHknLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcImVkaXRhYmxlXCIsIHRydWVdLFxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAvLyBjbG9zZS9vcGVuIHRoZSBoYWxvIHRvIHVwZGF0ZSB0aGUgZWRpdGluZyBzdGF0ZSB0b29nbGUgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24pO1xuICAgIH1cblxuICAgIC8vIE92ZXJ3cml0aW5nIHRoZSBiYXNlIGNsYXNzIG9wZW4vY2xvc2UgZWRpdG9yIG1ldGhvZHNcbiAgICBvcGVuRWRpdG9yKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0ub3BlbkVkaXRvckZvclBhcnQodGhpcy5tb2RlbC5pZCk7XG4gICAgfVxuXG4gICAgY2xvc2VFZGl0b3IoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5jbG9zZUVkaXRvckZvclBhcnQodGhpcy5tb2RlbC5pZCk7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIEkgY29udmVydCByYXcgdGV4dCB0byBodG1sIHJlc3BlY3RpbmcgdGhlIEZpcmVmb3hcbiAgICAgKiBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlIGd1aWRlbG5lcy5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgc2luZ2xlIGxpbnMgb2YgdGV4dCBhcmUgbGVmdCBhcyBpcztcbiAgICAgKiBtdWx0aWxpbmUgdGV4dCwgaS5lLiB0ZXh0IHdoaWNoIGluY2x1ZGVzIFwiXFxuXCIsIGlzXG4gICAgICogd3JhcHBlZCBpbiA8ZGl2PjwvZGl2PiBmb3IgZXZlcnkgbGluZTsgYW5kIHRoZSBsYXN0XG4gICAgICogbGluZSBnZXRzIGEgPGJyPiB0YWcgaW5zZXJ0ZWQgYmVmb3JlIHRoZSA8L2Rpdj4gdG8gcmVmbGVjdFxuICAgICAqIHRoZSBcIm9uLWVudGVyLWtleVwiIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHRleHRUb0h0bWwodGV4dCl7XG4gICAgICAgIGlmKHRleHQpe1xuICAgICAgICAgICAgbGV0IHRleHRMaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBpZih0ZXh0TGluZXMubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRleHRMaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGxpbmUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBgPGRpdj4ke2xpbmV9PC9kaXY+YDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gXCI8ZGl2Pjxicj48L2Rpdj5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAgYDxkaXY+JHtodG1sfTxicj48L2Rpdj5gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaHRtbFRvVGV4dChlbGVtZW50KXtcbiAgICAgICAgLy8gVE9ETyB0aGlzIGlzIHZlcnkgbmFpdmUgYW5kIGlnbm9yZXMgbW9zdCBwb3NzaWJsZSBzdHJ1Y3R1cmVcbiAgICAgICAgaWYoZWxlbWVudC5pbm5lckhUTUwpe1xuICAgICAgICAgICAgLy8gZmlyc3QgcmVwbGFjZSBhbGwgdGhlIFwiPC9kaXY+PGRpdj5cIiB3aXRoIGxpbmUgYnJlYWtzXG4gICAgICAgICAgICBsZXQgY2xlYW5IVE1MID0gIGVsZW1lbnQuaW5uZXJIVE1MLnJlcGxhY2UoLzxcXC9kaXY+PGRpdj4vZywgXCJcXG5cIik7XG4gICAgICAgICAgICAvLyB0aGVuIHJlbW92ZSBhbGwgaHRtbFxuICAgICAgICAgICAgbGV0IHRlbXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRlbXBFbGVtZW50LmlubmVySFRNTCA9IGNsZWFuSFRNTDtcbiAgICAgICAgICAgIGxldCBjbGVhblRleHQgPSB0ZW1wRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIHRlbXBFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFuVGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJzeW50YXhcIik7XG4gICAgICAgIGlmKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gXCJmYWxzZVwiKXtcbiAgICAgICAgICAgIHRoaXMudW5oaWdobGlnaHRTeW50YXgoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VtYW50aWNzID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLmNyZWF0ZVNlbWFudGljcygpO1xuICAgICAgICBzZW1hbnRpY3MuYWRkT3BlcmF0aW9uKFxuICAgICAgICAgICAgXCJoaWdobGlnaHRTeW50YXhcIixcbiAgICAgICAgICAgIGNyZWF0ZUhpZ2hsaWdodGVyKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwidGV4dFwiXG4gICAgICAgICk7XG4gICAgICAgIGlmKCF0ZXh0KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3SFRNTCA9IHRleHQuc3BsaXQoXCJcXG5cIikubWFwKGxpbmUgPT4ge1xuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgdHJ5IHRvIG1hdGNoXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3ludGF4UnVsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5fc3ludGF4UnVsZXNbaV07XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLm1hdGNoKGxpbmUsIHJ1bGUpO1xuICAgICAgICAgICAgICAgIGlmKG1hdGNoLnN1Y2NlZWRlZCgpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljcyhtYXRjaCkuaGlnaGxpZ2h0U3ludGF4KCkub3V0ZXJIVE1MO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuXG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcImlubmVySFRNTFwiLFxuICAgICAgICAgICAgbmV3SFRNTFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMudG9nZ2xlQXR0cmlidXRlKFwic3ludGF4XCIsIHRydWUpO1xuICAgIH1cblxuICAgIHVuaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwidGV4dFwiXG4gICAgICAgICk7XG4gICAgICAgIGlmKCF0ZXh0KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGxhaW5FbGVtZW50cyA9IHRleHQuc3BsaXQoXCJcXG5cIikubWFwKGxpbmUgPT4ge1xuICAgICAgICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBkaXYuaW5uZXJUZXh0ID0gbGluZTtcbiAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmluYWxMaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZmluYWxMaW5lLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgICBwbGFpbkVsZW1lbnRzLnB1c2goZmluYWxMaW5lKTtcblxuICAgICAgICBsZXQgbmV3SFRNTCA9IFwiXCI7XG4gICAgICAgIHBsYWluRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIG5ld0hUTUwgKz0gZWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcImlubmVySFRNTFwiLFxuICAgICAgICAgICAgbmV3SFRNTFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMudG9nZ2xlQXR0cmlidXRlKFwic3ludGF4XCIsIGZhbHNlKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEZpZWxkVmlldyxcbiAgICBGaWVsZFZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogTmV3IEhhbG9cbiAqL1xuXG4vKiogTm90ZTogSWNvbnMgYXJlIGZyb20gXG4qKiogaHR0cHM6Ly90YWJsZXJpY29ucy5jb20vXG4qKi9cbmNvbnN0IGRlbGV0ZUljb24gPWBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci10cmFzaFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxsaW5lIHgxPVwiNFwiIHkxPVwiN1wiIHgyPVwiMjBcIiB5Mj1cIjdcIiAvPlxuICA8bGluZSB4MT1cIjEwXCIgeTE9XCIxMVwiIHgyPVwiMTBcIiB5Mj1cIjE3XCIgLz5cbiAgPGxpbmUgeDE9XCIxNFwiIHkxPVwiMTFcIiB4Mj1cIjE0XCIgeTI9XCIxN1wiIC8+XG4gIDxwYXRoIGQ9XCJNNSA3bDEgMTJhMiAyIDAgMCAwIDIgMmg4YTIgMiAwIDAgMCAyIC0ybDEgLTEyXCIgLz5cbiAgPHBhdGggZD1cIk05IDd2LTNhMSAxIDAgMCAxIDEgLTFoNGExIDEgMCAwIDEgMSAxdjNcIiAvPlxuPC9zdmc+XG5gO1xuY29uc3QgZWRpdEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItZWRpdFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNOSA3aC0zYTIgMiAwIDAgMCAtMiAydjlhMiAyIDAgMCAwIDIgMmg5YTIgMiAwIDAgMCAyIC0ydi0zXCIgLz5cbiAgPHBhdGggZD1cIk05IDE1aDNsOC41IC04LjVhMS41IDEuNSAwIDAgMCAtMyAtM2wtOC41IDguNXYzXCIgLz5cbiAgPGxpbmUgeDE9XCIxNlwiIHkxPVwiNVwiIHgyPVwiMTlcIiB5Mj1cIjhcIiAvPlxuPC9zdmc+XG5gO1xuY29uc3QgZ3Jvd0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItYXJyb3dzLWRpYWdvbmFsLTJcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiMTYgMjAgMjAgMjAgMjAgMTZcIiAvPlxuICA8bGluZSB4MT1cIjE0XCIgeTE9XCIxNFwiIHgyPVwiMjBcIiB5Mj1cIjIwXCIgLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjggNCA0IDQgNCA4XCIgLz5cbiAgPGxpbmUgeDE9XCI0XCIgeTE9XCI0XCIgeDI9XCIxMFwiIHkyPVwiMTBcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjb3B5SWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jb3B5XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8cmVjdCB4PVwiOFwiIHk9XCI4XCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjEyXCIgcng9XCIyXCI+PC9yZWN0PlxuICAgPHBhdGggZD1cIk0xNiA4di0yYTIgMiAwIDAgMCAtMiAtMmgtOGEyIDIgMCAwIDAgLTIgMnY4YTIgMiAwIDAgMCAyIDJoMlwiPjwvcGF0aD5cbjwvc3ZnPlxuYDtcblxuY29uc3QgcGFzdGVJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNsaXBib2FyZC1jaGVja1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHBhdGggZD1cIk05IDVoLTJhMiAyIDAgMCAwIC0yIDJ2MTJhMiAyIDAgMCAwIDIgMmgxMGEyIDIgMCAwIDAgMiAtMnYtMTJhMiAyIDAgMCAwIC0yIC0yaC0yXCI+PC9wYXRoPlxuICAgPHJlY3QgeD1cIjlcIiB5PVwiM1wiIHdpZHRoPVwiNlwiIGhlaWdodD1cIjRcIiByeD1cIjJcIj48L3JlY3Q+XG4gICA8cGF0aCBkPVwiTTkgMTRsMiAybDQgLTRcIj48L3BhdGg+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRhcmdldEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItZm9jdXNcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiLjVcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+PC9jaXJjbGU+XG4gICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjlcIj48L2NpcmNsZT5cbjwvc3ZnPlxuYDtcblxuY29uc3Qgc2V0dGluZ3NJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXNldHRpbmdzXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMC4zMjUgNC4zMTdjLjQyNiAtMS43NTYgMi45MjQgLTEuNzU2IDMuMzUgMGExLjcyNCAxLjcyNCAwIDAgMCAyLjU3MyAxLjA2NmMxLjU0MyAtLjk0IDMuMzEgLjgyNiAyLjM3IDIuMzdhMS43MjQgMS43MjQgMCAwIDAgMS4wNjUgMi41NzJjMS43NTYgLjQyNiAxLjc1NiAyLjkyNCAwIDMuMzVhMS43MjQgMS43MjQgMCAwIDAgLTEuMDY2IDIuNTczYy45NCAxLjU0MyAtLjgyNiAzLjMxIC0yLjM3IDIuMzdhMS43MjQgMS43MjQgMCAwIDAgLTIuNTcyIDEuMDY1Yy0uNDI2IDEuNzU2IC0yLjkyNCAxLjc1NiAtMy4zNSAwYTEuNzI0IDEuNzI0IDAgMCAwIC0yLjU3MyAtMS4wNjZjLTEuNTQzIC45NCAtMy4zMSAtLjgyNiAtMi4zNyAtMi4zN2ExLjcyNCAxLjcyNCAwIDAgMCAtMS4wNjUgLTIuNTcyYy0xLjc1NiAtLjQyNiAtMS43NTYgLTIuOTI0IDAgLTMuMzVhMS43MjQgMS43MjQgMCAwIDAgMS4wNjYgLTIuNTczYy0uOTQgLTEuNTQzIC44MjYgLTMuMzEgMi4zNyAtMi4zN2MxIC42MDggMi4yOTYgLjA3IDIuNTcyIC0xLjA2NXpcIiAvPlxuICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjNcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCByb3RhdGVJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXJvdGF0ZS1jbG9ja3dpc2VcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxwYXRoIGQ9XCJNNC4wNSAxMWE4IDggMCAxIDEgLjUgNG0tLjUgNXYtNWg1XCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiA6aG9zdCB7XG4gICAgIC0taGFsby1idXR0b24taGVpZ2h0OiAyNXB4O1xuICAgICAtLWhhbG8tYnV0dG9uLXdpZHRoOiAyNXB4O1xuICAgICAtLWhhbG8tcmltLW1hcmdpbjogMTBweDtcbiAgICAgLS1oYWxvLWJ1dHRvbi13aWR0aC1wYWRkZWQ6IGNhbGModmFyKC0taGFsby1idXR0b24td2lkdGgpICsgdmFyKC0taGFsby1yaW0tbWFyZ2luKSk7XG4gICAgIC0taGFsby1idXR0b24taGVpZ2h0LXBhZGRlZDogY2FsYyh2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQpICsgdmFyKC0taGFsby1yaW0tbWFyZ2luKSk7XG4gICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgdG9wOiBjYWxjKC0xICogdmFyKC0taGFsby1idXR0b24taGVpZ2h0LXBhZGRlZCkpO1xuICAgICBsZWZ0OiBjYWxjKC0xICogdmFyKC0taGFsby1idXR0b24td2lkdGgtcGFkZGVkKSk7XG4gICAgIHdpZHRoOiBjYWxjKDEwMCUgKyAoMiAqIHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoLXBhZGRlZCkpKTtcbiAgICAgaGVpZ2h0OiBjYWxjKDEwMCUgKyAoMiAqIHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpKSk7XG4gICAgIGNvbG9yOiBpbml0aWFsO1xuICAgICB6LWluZGV4OiAxMDtcbiB9XG5cblxuIC5oYWxvLXJvdyxcbiAuaGFsby1jb2x1bW4ge1xuICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gfVxuXG4gLmhhbG8tY29sdW1uIHtcbiAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiB9XG5cbiAjaGFsby10b3Atcm93LFxuICNoYWxvLWJvdHRvbS1yb3cge1xuICAgICB3aWR0aDogY2FsYygxMDAlIC0gdmFyKC0taGFsby1idXR0b24td2lkdGgtcGFkZGVkKSk7XG4gICAgIGhlaWdodDogdmFyKC0taGFsby1idXR0b24taGVpZ2h0LXBhZGRlZCk7XG4gfVxuXG4gI2hhbG8tdG9wLXJvdyB7XG4gICAgIGxlZnQ6IDA7XG4gICAgIHRvcDogMDtcbiB9XG5cbiAjaGFsby1ib3R0b20tcm93IHtcbiAgICAgcmlnaHQ6IDA7XG4gICAgIGJvdHRvbTogMDtcbiAgICAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gfVxuXG4gI2hhbG8tcmlnaHQtY29sdW1uLFxuICNoYWxvLWxlZnQtY29sdW1uIHtcbiAgICAgaGVpZ2h0OiBjYWxjKDEwMCUgLSB2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQtcGFkZGVkKSk7XG4gICAgIHdpZHRoOiB2YXIoLS1oYWxvLWJ1dHRvbi13aWR0aC1wYWRkZWQpO1xuIH1cblxuICNoYWxvLXJpZ2h0LWNvbHVtbiB7XG4gICAgIHJpZ2h0OiAwO1xuICAgICB0b3A6IDA7XG4gICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiB9XG5cbiAjaGFsby1sZWZ0LWNvbHVtbiB7XG4gICAgIGxlZnQ6IDA7XG4gICAgIHRvcDogdmFyKC0taGFsby1idXR0b24taGVpZ2h0LXBhZGRlZCk7XG4gfVxuXG4gLmhhbG8tYnV0dG9uLFxuIDo6c2xvdHRlZCgqKSB7XG4gICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuOCk7XG4gICAgIHdpZHRoOiB2YXIoLS1oYWxvLWJ1dHRvbi13aWR0aCk7XG4gICAgIGhlaWdodDogdmFyKC0taGFsby1idXR0b24taGVpZ2h0KTtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyMCwgMjIwLCAyMjApO1xuIH1cblxuIC5oYWxvLWJ1dHRvbjpob3ZlclxuIDo6c2xvdHRlZCgqKS5oYWxvLWJ1dHRvbjpob3ZlciB7XG4gICAgIGN1cnNvcjogcG9pbnRlcjtcbiB9XG5cbiAuaGFsby1idXR0b246YWN0aXZlXG4gOjpzbG90dGVkKCopLmhhbG8tYnV0dG9uOmFjdGl2ZSB7XG4gICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuIH1cblxuIC5oYWxvLWJ1dHRvbi5oaWRkZW5cbiA6OnNsb3R0ZWQoKikuaGFsby1idXR0b24uaGlkZGVuIHtcbiAgICAgZGlzcGxheTogbm9uZTtcbiB9XG5cbjwvc3R5bGU+XG5cbjxkaXYgaWQ9XCJoYWxvLXRvcC1yb3dcIiBjbGFzcz1cImhhbG8tcm93XCI+XG4gICAgPGRpdiBpZD1cImhhbG8tZGVsZXRlXCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiRGVsZXRlIHRoaXMgcGFydFwiPlxuICAgICAgICAke2RlbGV0ZUljb259XG4gICAgPC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cInRvcC1yb3dcIj48L3Nsb3Q+XG48L2Rpdj5cblxuPGRpdiBpZD1cImhhbG8tYm90dG9tLXJvd1wiIGNsYXNzPVwiaGFsby1yb3dcIj5cbiAgICA8ZGl2IGlkPVwiaGFsby1yZXNpemVcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJSZXNpemUgdGhpcyBwYXJ0XCI+XG4gICAgICAgICR7Z3Jvd0ljb259XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImhhbG8tc2NyaXB0LWVkaXRcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJFZGl0IHRoaXMgcGFydCdzIHNjcmlwdFwiPlxuICAgICAgICAke2VkaXRJY29ufVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoYWxvLWVkaXRcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJFZGl0IHRoaXMgcGFydFwiPlxuICAgICAgICAke3NldHRpbmdzSWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwiYm90dG9tLXJvd1wiPjwvc2xvdD5cbjwvZGl2PlxuXG48ZGl2IGlkPVwiaGFsby1sZWZ0LWNvbHVtblwiIGNsYXNzPVwiaGFsby1jb2x1bW5cIj5cbiAgICA8ZGl2IGlkPVwiaGFsby1jb3B5XCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiQ29weSB0aGlzIFBhcnRcIj5cbiAgICAgICAgJHtjb3B5SWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwiaGFsby1wYXN0ZVwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIlBhc3RlIHRoZSBjb250ZW50cyBvZiBjbGlwYm9hcmQgaW50byB0aGlzIFBhcnRcIj5cbiAgICAgICAgJHtwYXN0ZUljb259XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImhhbG8tdGFyZ2V0XCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiU2VsZWN0IHRoaXMgUGFydCdzIHRhcmdldFwiPlxuICAgICAgICAke3RhcmdldEljb259XG4gICAgPC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cImxlZnQtY29sdW1uXCI+PC9zbG90PlxuPC9kaXY+XG5cbjxkaXYgaWQ9XCJoYWxvLXJpZ2h0LWNvbHVtblwiIGNsYXNzPVwiaGFsby1jb2x1bW5cIj5cbiAgICA8ZGl2IGlkPVwiaGFsby1yb3RhdGVcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJSb3RhdGUgdGhpcyBwYXJ0XCI+XG4gICAgICAgICR7cm90YXRlSWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwicmlnaHQtY29sdW1uXCI+PC9zbG90PlxuPC9kaXY+XG5cbmA7XG5cbmNsYXNzIEhhbG8gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBDb25maWd1cmUgdGhlIFNoYWRvdyBET00gYW5kIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcblxuXG4gICAgICAgIC8vIEJpbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZU1vdXNlRG93biA9IHRoaXMub25SZXNpemVNb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZU1vdXNlVXAgPSB0aGlzLm9uUmVzaXplTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplTW91c2VNb3ZlID0gdGhpcy5vblJlc2l6ZU1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUm90YXRlTW91c2VEb3duID0gdGhpcy5vblJvdGF0ZU1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUm90YXRlTW91c2VVcCA9IHRoaXMub25Sb3RhdGVNb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Sb3RhdGVNb3VzZU1vdmUgPSB0aGlzLm9uUm90YXRlTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFJvb3ROb2RlKCkuaG9zdDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdlZGl0aW5nJyk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQuaGFzT3BlbkhhbG8gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuXG4gICAgICAgICAgICAvLyBSZXNpemUgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tcmVzaXplJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblJlc2l6ZU1vdXNlRG93bik7XG4gICAgICAgICAgICBpZighdGhpcy50YXJnZXRFbGVtZW50LndhbnRzSGFsb1Jlc2l6ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUm90YXRlIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5yb3RhdGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXJvdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Sb3RhdGVNb3VzZURvd24pO1xuICAgICAgICAgICAgaWYoIXRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9Sb3RhdGUpe1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWxldGUgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tZGVsZXRlJyk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvRGVsZXRlKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvRGVsZXRlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFZGl0IGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5zY3JpcHRFZGl0b3IgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tc2NyaXB0LWVkaXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0RWRpdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb09wZW5TY3JpcHRFZGl0b3IpO1xuICAgICAgICAgICAgaWYoIXRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9TY3JpcHRFZGl0KXtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdEVkaXRvci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXByZWhlbnNpdmUgZWRpdG9yIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tZWRpdCcpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvT3BlbkVkaXRvcik7XG4gICAgICAgICAgICBpZighdGhpcy50YXJnZXRFbGVtZW50LndhbnRzSGFsb0VkaXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29weSBidXR0b25cbiAgICAgICAgICAgIHRoaXMuY29waWVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLWNvcHknKTtcbiAgICAgICAgICAgIHRoaXMuY29waWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb0NvcHkpO1xuXG5cbiAgICAgICAgICAgIC8vIFBhc3RlIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5wYXN0ZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tcGFzdGUnKTtcbiAgICAgICAgICAgIHRoaXMucGFzdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb1Bhc3RlKTtcblxuICAgICAgICAgICAgLy8gVGFyZ2V0IGJ1dHRvblxuICAgICAgICAgICAgdGhpcy50YXJnZXRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby10YXJnZXQnKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUVudGVyKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUxlYXZlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0aW5nJyk7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudC5oYXNPcGVuSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5yZXNpemVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25SZXNpemVNb3VzZURvd24pO1xuICAgIH1cblxuXG4gICAgLyogRXZlbnQgSGFuZGxpbmcgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwICYmIHRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9Nb3ZlKXtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgbGV0IGN1cnJlbnRUb3AgPSBwYXJzZUludCh0aGlzLnRhcmdldEVsZW1lbnQuc3R5bGUudG9wKTtcbiAgICAgICAgbGV0IGN1cnJlbnRMZWZ0ID0gcGFyc2VJbnQodGhpcy50YXJnZXRFbGVtZW50LnN0eWxlLmxlZnQpO1xuICAgICAgICBsZXQgbmV3VG9wID0gZXZlbnQubW92ZW1lbnRZICsgY3VycmVudFRvcDtcbiAgICAgICAgbGV0IG5ld0xlZnQgPSBldmVudC5tb3ZlbWVudFggKyBjdXJyZW50TGVmdDtcblxuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLnRhcmdldEVsZW1lbnQubW9kZWw7XG4gICAgICAgIG1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQobW9kZWwsIFwidG9wXCIsIG5ld1RvcCk7XG4gICAgICAgIG1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQobW9kZWwsIFwibGVmdFwiLCBuZXdMZWZ0KTtcbiAgICB9XG5cbiAgICBvbk1vdXNlVXAoZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZU1vdXNlRG93bihldmVudCl7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uUmVzaXplTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25SZXNpemVNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZU1vdXNlVXAoZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uUmVzaXplTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25SZXNpemVNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZU1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9SZXNpemUoXG4gICAgICAgICAgICBldmVudC5tb3ZlbWVudFgsXG4gICAgICAgICAgICBldmVudC5tb3ZlbWVudFlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBvblJvdGF0ZU1vdXNlRG93bihldmVudCl7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uUm90YXRlTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Sb3RhdGVNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvblJvdGF0ZU1vdXNlVXAoZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uUm90YXRlTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Sb3RhdGVNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvblJvdGF0ZU1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9Sb3RhdGUoXG4gICAgICAgICAgICBldmVudC5tb3ZlbWVudFgsXG4gICAgICAgICAgICBldmVudC5tb3ZlbWVudFlcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEhhbG8sXG4gICAgSGFsbyBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuXG5jb25zdCBsaW5rSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1saW5rXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMCAxNGEzLjUgMy41IDAgMCAwIDUgMGw0IC00YTMuNSAzLjUgMCAwIDAgLTUgLTVsLS41IC41XCIgLz5cbiAgPHBhdGggZD1cIk0xNCAxMGEzLjUgMy41IDAgMCAwIC01IDBsLTQgNGEzLjUgMy41IDAgMCAwIDUgNWwuNSAtLjVcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBwaWN0dXJlSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1waG90b1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPGxpbmUgeDE9XCIxNVwiIHkxPVwiOFwiIHgyPVwiMTUuMDFcIiB5Mj1cIjhcIj48L2xpbmU+XG4gICA8cmVjdCB4PVwiNFwiIHk9XCI0XCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgcng9XCIzXCI+PC9yZWN0PlxuICAgPHBhdGggZD1cIk00IDE1bDQgLTRhMyA1IDAgMCAxIDMgMGw1IDVcIj48L3BhdGg+XG4gICA8cGF0aCBkPVwiTTE0IDE0bDEgLTFhMyA1IDAgMCAxIDMgMGwyIDJcIj48L3BhdGg+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPGltZyBpZD1cIndyYXBwZWQtaW1hZ2VcIiBjbGFzcz1cImhpZGRlblwiIC8+XG48c3ZnIGNsYXNzPVwiaGlkZGVuXCIgaWQ9XCJ3cmFwcGVkLXN2Z1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbjwvc3ZnPlxuPHN0eWxlPlxuOmhvc3Qge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xufVxuXG4uaGlkZGVuIHtcbiAgICBkaXNwbGF5OiBub25lO1xufVxuaW1nIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IGF1dG87XG4gICAgZGlzcGxheTogYmxvY2s7XG59XG5cbi5jdXJyZW50bHktd3JhcHBlZCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuPC9zdHlsZT5cbmA7XG5cbmNsYXNzIEltYWdlVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgZG9tXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy51cGRhdGVJbWFnZURhdGEgPSB0aGlzLnVwZGF0ZUltYWdlRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN2Z0ltYWdlID0gdGhpcy51cGRhdGVTdmdJbWFnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJpbmFyeUltYWdlID0gdGhpcy51cGRhdGVCaW5hcnlJbWFnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldERlZmF1bHRJbWFnZSA9IHRoaXMuc2V0RGVmYXVsdEltYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUltYWdlTGluayA9IHRoaXMudXBkYXRlSW1hZ2VMaW5rLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nRm9yVmlld3BvcnQgPSB0aGlzLnVwZGF0ZVNpemluZ0ZvclZpZXdwb3J0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICAvLyBwcm9wIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJpbWFnZURhdGFcIiwgKGltYWdlRGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYoIWltYWdlRGF0YSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0SW1hZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2VEYXRhKGltYWdlRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGltYWdlRGF0YS4gSWYgbm90LCB0cnlcbiAgICAgICAgLy8gdG8gbG9hZCBmcm9tIGEgc3JjLlxuICAgICAgICBsZXQgY3VycmVudEltYWdlRGF0YSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcImltYWdlRGF0YVwiXG4gICAgICAgICk7XG4gICAgICAgIGxldCBjdXJyZW50U3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwic3JjXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYoIWN1cnJlbnRJbWFnZURhdGEpe1xuICAgICAgICAgICAgaWYoY3VycmVudFNyYyl7XG4gICAgICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2xvYWRJbWFnZUZyb20nLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbIGN1cnJlbnRTcmMgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZShtc2csIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERlZmF1bHRJbWFnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbWFnZURhdGEoY3VycmVudEltYWdlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgc2V0RGVmYXVsdEltYWdlKCl7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImltYWdlRGF0YVwiLCBwaWN0dXJlSWNvbik7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcIm1pbWVUeXBlXCIsIFwiaW1hZ2Uvc3ZnXCIpO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJzcmNcIiwgXCJcIik7XG4gICAgICAgIHRoaXMudXBkYXRlSW1hZ2VEYXRhKHBpY3R1cmVJY29uKTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbWFnZURhdGEoaW1hZ2VEYXRhKXtcbiAgICAgICAgaWYodGhpcy5tb2RlbC5pc1N2Zyl7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN2Z0ltYWdlKGltYWdlRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJpbmFyeUltYWdlKGltYWdlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVCaW5hcnlJbWFnZShpbWFnZURhdGEpe1xuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSBpbWFnZURhdGEgaXNcbiAgICAgICAgLy8gYSBiYXNlNjQgZW5jb2RlZCBkYXRhIHVybCBkZXNjcmliaW5nXG4gICAgICAgIC8vIHRoZSBiaXRzIG9mIHRoZSBpbWFnZS5cbiAgICAgICAgbGV0IGltZ0VsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnd3JhcHBlZC1pbWFnZScpO1xuICAgICAgICBsZXQgc3ZnRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd3cmFwcGVkLXN2ZycpO1xuICAgICAgICBzdmdFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgc3ZnRWwuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudGx5LXdyYXBwZWQnKTtcbiAgICAgICAgaW1nRWwuY2xhc3NMaXN0LmFkZCgnY3VycmVudGx5LXdyYXBwZWQnKTtcbiAgICAgICAgaW1nRWwuc3JjID0gaW1hZ2VEYXRhO1xuICAgICAgICBpbWdFbC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvL3RoaXMudXBkYXRlU2l6aW5nRm9yVmlld3BvcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZUFzcGVjdE9uUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgaW1nRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgdXBkYXRlU3ZnSW1hZ2UoaW1hZ2VEYXRhKXtcbiAgICAgICAgbGV0IGltZ0VsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnd3JhcHBlZC1pbWFnZScpO1xuICAgICAgICBsZXQgY3VycmVudFN2Z0VsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnd3JhcHBlZC1zdmcnKTtcbiAgICAgICAgbGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgbGV0IHhtbERvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhpbWFnZURhdGEsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAgICAgbGV0IG5ld1N2Z0VsID0geG1sRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBTVkcgaGFzIHNvbWUgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzXG4gICAgICAgIC8vIHNldCBzbyB3ZSBoYXZlIGluaXRpYWwgZGltZW5zaW9ucyB0byBkaXNwbGF5LiBJZiBub3QgcHJlc2VudCxcbiAgICAgICAgLy8gcHVsbCBmcm9tIHZpZXdib3guXG4gICAgICAgIGlmKCFuZXdTdmdFbC5oYXNBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgIW5ld1N2Z0VsLmhhc0F0dHJpYnV0ZSgnaGVpZ2h0Jykpe1xuICAgICAgICAgICAgbGV0IHZpZXdCb3ggPSBuZXdTdmdFbC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICAgICAgICAgIGlmKHZpZXdCb3gpe1xuICAgICAgICAgICAgICAgIHZpZXdCb3ggPSB2aWV3Qm94LnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgdmlld0JveFdpZHRoID0gcGFyc2VJbnQodmlld0JveFsyXSk7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdCb3hIZWlnaHQgPSBwYXJzZUludCh2aWV3Qm94WzNdKTtcbiAgICAgICAgICAgICAgICBuZXdTdmdFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHZpZXdCb3hIZWlnaHQpO1xuICAgICAgICAgICAgICAgIG5ld1N2Z0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB2aWV3Qm94V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBuZXdTdmdFbC5pZCA9ICd3cmFwcGVkLXN2Zyc7XG4gICAgICAgIG5ld1N2Z0VsLmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGltZ0VsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBpbWdFbC5jbGFzc0xpc3QucmVtb3ZlKCdjdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBjdXJyZW50U3ZnRWwucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQobmV3U3ZnRWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZ0ZvclZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMucHJlc2VydmVBc3BlY3RPblJlc2l6ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHVwZGF0ZUltYWdlTGluayhldmVudCl7XG4gICAgICAgIC8vIFRlbGxzIHRoZSBtb2RlbCB0byB1cGRhdGUgaXRzXG4gICAgICAgIC8vIHNyYyBsaW5rIGZvciB0aGUgaW1hZ2VcbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3NyYydcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoXCJFZGl0IFVSTCBmb3IgaW1hZ2U6XCIsIGN1cnJlbnRTcmMpO1xuICAgICAgICBpZihyZXN1bHQgJiYgcmVzdWx0ICE9PSAnJyAmJiByZXN1bHQgIT09IGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdsb2FkSW1hZ2VGcm9tJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyByZXN1bHQgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVNpemluZ0ZvclZpZXdwb3J0KCl7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMgY29tcG9uZW50IGRvZXMgbm90IGRpc3BsYXkgbGFyZ2VyXG4gICAgICAgIC8vIHRoYW4gdGhlIGN1cnJlbnQgcmVtYWluaW5nIHN1YnJlY3RhbmdsZSBvZiBpdHMgb3JpZ2luXG4gICAgICAgIC8vIGFuZCB0aGUgY29ybmVyIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICBsZXQgcGFkZGluZyA9IDQwO1xuICAgICAgICAvLyBGaXJzdCwgd2UgbmVlZCB0byBmaW5kIHRoZSBhYnNvbHV0ZSB0b3AgY29ybmVyXG4gICAgICAgIC8vIGxvY2F0aW9ucyBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgbGV0IGVsID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuY3VycmVudGx5LXdyYXBwZWQnKTtcbiAgICAgICAgbGV0IHRvcCA9IDA7XG4gICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgd2hpbGUoZWwpe1xuICAgICAgICAgICAgdG9wICs9IGVsLm9mZnNldFRvcDtcbiAgICAgICAgICAgIGxlZnQgKz0gZWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgaGVpZ2h0TGltaXQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IC0gcGFkZGluZztcbiAgICAgICAgaWYoKHJlY3QuaGVpZ2h0ICsgdG9wKSA+IGhlaWdodExpbWl0KXtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IChoZWlnaHRMaW1pdCAtIHRvcCkgLyByZWN0LmhlaWdodDtcbiAgICAgICAgICAgIC8vIHRoaXMuc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHQgKiByYXRpb31weGA7XG4gICAgICAgICAgICAvLyB0aGlzLnN0eWxlLndpZHRoID0gYCR7cmVjdC53aWR0aCAqIHJhdGlvfXB4YDtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgKHJlY3Qud2lkdGggKiByYXRpbylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAocmVjdC5oZWlnaHQgKiByYXRpbylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgb25IYWxvUmVzaXplKG1vdmVtZW50WCwgbW92ZW1lbnRZKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgICAgLy8gV2UgcmVzaXplIHRoZSB3cmFwcGVkIHN2ZyBvciBpbWcgaW5zdGVhZFxuICAgICAgICAvLyBhbmQgaGF2ZSB0aGUgb3V0ZXIgY29tcG9uZW50IHNpbXBseSByZWFjdCB0b1xuICAgICAgICAvLyB0aGUgY2hhbmdlLlxuICAgICAgICAvLyBJZiB0aGUgcGFydCBpcyByb3RhdGVkIHRoaXMgd2lsbCB0aHJvdyBvZmYgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAgICAvLyBicm93c2VyIGNhbGN1YWx0aW9uLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHJvdGF0ZSB0aGUgcGFydCB0byAwXG4gICAgICAgIC8vIChpZiBuZWNlc3NhcnkpIGRvIHRoZSBjYWxjdWxhdGlvbnMgYW5kIHRoZW4gcm90YXRlIGl0IGJhY2tcbiAgICAgICAgbGV0IGFuZ2xlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIpO1xuICAgICAgICBpZihhbmdsZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIiwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdyYXBwZWRJbWFnZSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmN1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGxldCByZWN0ID0gd3JhcHBlZEltYWdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgbmV3V2lkdGgsIG5ld0hlaWdodDtcbiAgICAgICAgaWYodGhpcy5wcmVzZXJ2ZUFzcGVjdE9uUmVzaXplKXtcbiAgICAgICAgICAgIGxldCBtYXhXaWR0aCA9IHJlY3Qud2lkdGggKyBtb3ZlbWVudFg7XG4gICAgICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyBtb3ZlbWVudFk7XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSBNYXRoLm1pbihtYXhXaWR0aCAvIHJlY3Qud2lkdGgsIG1heEhlaWdodCAvIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IHJlY3QuaGVpZ2h0ICogcmF0aW87XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHJlY3Qud2lkdGggKiByYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gcmVjdC53aWR0aCArIG1vdmVtZW50WDtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IHJlY3QuaGVpZ2h0ICsgbW92ZW1lbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobmV3V2lkdGggJiYgbmV3SGVpZ2h0KXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgbmV3V2lkdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIHJvdGF0ZSBhbmdsZSB0byB0aGUgb3JpZ2luYWwgKGlmIG5lY2Vzc2FyeSlcbiAgICAgICAgaWYoYW5nbGUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIsIGFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9uKCl7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaWQgPSAnaGFsby1pbWFnZS1saW5rJztcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBsaW5rSWNvbjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnN0eWxlLm1hcmdpblRvcCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAncmlnaHQtY29sdW1uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0VkaXQgbGluayBmb3IgaW1hZ2UgZmlsZScpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnVwZGF0ZUltYWdlTGluayk7XG4gICAgfVxuXG4gICAgYWRkQ29udGV4dE1lbnVJdGVtcyhjb250ZXh0TWVudSl7XG4gICAgICAgIGNvbnRleHRNZW51LmFkZFNwYWNlcigpO1xuICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdFZGl0IEltYWdlIFVSTCcsXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlTGlua1xuICAgICAgICApO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgSW1hZ2VWaWV3LFxuICAgIEltYWdlVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBQYXJ0Vmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhbiAqYWJzdHJhY3QqIHdlYmNvbXBvZW50IEN1c3RvbUVsZW1lbnRcbiAqIHRoYXQgc2VydmVzIGFzIHRoZSBnZW5lcmljIHZpZXcgZm9yIGFueSBQYXJ0XG4gKiBtb2RlbHMuXG4gKiBJIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LCBub3Igc2hvdWxkXG4gKiBJIGJlIGFkZGVkIHRvIGFueSB3ZWIgcGFnZSdzIHJlZ2lzdHJ5IG9mIEN1c3RvbUVsZW1lbnRzLlxuICogSSBhbSBpbmRlbmRlZCB0byBiZSBleHRlbmRlZCAoc3ViY2xhc3NlZCkgYnkgdGhlIGFjdHVhbFxuICogdmlld3MgZm9yIGVhY2ggUGFydCBraW5kLCBhbmQgdGhlcmVmb3JlIEkgY29udGFpbiBhbGxcbiAqIG9mIHRoZSBjb21tb24gYmVoYXZpb3IsIGluY2x1ZGluZyBsaWZlY3ljbGUgbWV0aG9kcyxcbiAqIGZvciB0aGVzZS5cbiAqL1xuaW1wb3J0IENvbnRleHRNZW51IGZyb20gJy4vY29udGV4dG1lbnUvQ29udGV4dE1lbnUuanMnO1xuaW1wb3J0IGludGVycHJldGVyU2VtYW50aWNzIGZyb20gJy4uLy4uL29obS9pbnRlcnByZXRlci1zZW1hbnRpY3MuanMnO1xuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdC1jb250ZXh0LW1lbnUnLCBDb250ZXh0TWVudSk7XG5cbmNsYXNzIFBhcnRWaWV3IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmlzUGFydFZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTGVuc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5wcm9wQ2hhbmdlSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXR1cEJhc2VQcm9wSGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXR1cEJhc2VWaWV3Q2hhbmdlSGFuZGxlcnMoKTtcblxuICAgICAgICAvLyBIYWxvIHNldHRpbmdzLiBBbGwgYXJlIG9uIGJ5IGRlZmF1bHRcbiAgICAgICAgdGhpcy53YW50c0hhbG9SZXNpemUgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsb1JvdGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMud2FudHNIYWxvU2NyaXB0RWRpdCA9IHRydWU7XG4gICAgICAgIHRoaXMud2FudHNIYWxvRWRpdCA9IHRydWU7XG4gICAgICAgIHRoaXMud2FudHNIYWxvRGVsZXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSB0cnVlO1xuICAgICAgICAvLyBOb3RlOiBzZWUgZ2V0dGVyIGZvciB3YW50c0hhbG9Nb3ZlXG5cbiAgICAgICAgLy8gQ29udGV4dCBtZW51IHNldHRpbmdzXG4gICAgICAgIHRoaXMud2FudHNDb250ZXh0TWVudSA9IHRydWU7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNldE1vZGVsID0gdGhpcy5zZXRNb2RlbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVuc2V0TW9kZWwgPSB0aGlzLnVuc2V0TW9kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IHRoaXMuc2VuZE1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cEJhc2VQcm9wSGFuZGxlcnMgPSB0aGlzLnNldHVwQmFzZVByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwQmFzZVZpZXdDaGFuZ2VIYW5kbGVycyA9IHRoaXMuc2V0dXBCYXNlVmlld0NoYW5nZUhhbmRsZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdExheW91dCA9IHRoaXMuaW5pdExheW91dC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgaW5pdGlhbCBwcm9wZXJ0eSBtZXRob2RcbiAgICAgICAgdGhpcy5zdHlsZUNTUyA9IHRoaXMuc3R5bGVDU1MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdHlsZVRleHRDU1MgPSB0aGlzLnN0eWxlVGV4dENTUy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgcHJvcGVydHkgY2hhbmdlIHJlYWN0aW9uIG1ldGhvZHNcbiAgICAgICAgdGhpcy5wcmltSGFuZGxlUHJvcENoYW5nZSA9IHRoaXMucHJpbUhhbmRsZVByb3BDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UgPSB0aGlzLm9uUHJvcENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByaW1IYW5kbGVWaWV3Q2hhbmdlID0gdGhpcy5wcmltSGFuZGxlVmlld0NoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVmlld0NoYW5nZSA9IHRoaXMub25WaWV3Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NyaXB0Q2hhbmdlZCA9IHRoaXMuc2NyaXB0Q2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxheW91dENoYW5nZWQgPSB0aGlzLmxheW91dENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5saXN0RGlyZWN0aW9uQ2hhbmdlZCA9IHRoaXMubGlzdERpcmVjdGlvbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5saXN0V3JhcHBpbmdDaGFuZ2VkID0gdGhpcy5saXN0V3JhcHBpbmdDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudlJlc2l6aW5nQ2hhbmdlZCA9IHRoaXMudlJlc2l6aW5nQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhSZXNpemluZ0NoYW5nZWQgPSB0aGlzLmhSZXNpemluZ0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5uaW5nTGVmdENoYW5nZWQgPSB0aGlzLnBpbm5pbmdMZWZ0Q2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpbm5pbmdUb3BDaGFuZ2VkID0gdGhpcy5waW5uaW5nVG9wQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpbm5pbmdCb3R0b21DaGFuZ2VkID0gdGhpcy5waW5uaW5nQm90dG9tQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpbm5pbmdSaWdodENoYW5nZWQgPSB0aGlzLnBpbm5pbmdSaWdodENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5saXN0QWxpZ25tZW50Q2hhbmdlZCA9IHRoaXMubGlzdEFsaWdubWVudENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5saXN0RGlzdHJpYnV0aW9uQ2hhbmdlZCA9IHRoaXMubGlzdERpc3RyaWJ1dGlvbkNoYW5nZWQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIHZpZXcgY2hhbmdlIHJlYWN0aW9uIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkID0gdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubmV3U3VicGFydFZpZXcgPSB0aGlzLm5ld1N1YnBhcnRWaWV3LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBIYWxvIHJlbGF0ZWQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9wZW5IYWxvID0gdGhpcy5vcGVuSGFsby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlSGFsbyA9IHRoaXMuY2xvc2VIYWxvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvRGVsZXRlID0gdGhpcy5vbkhhbG9EZWxldGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9PcGVuRWRpdG9yID0gdGhpcy5vbkhhbG9PcGVuRWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvT3BlblNjcmlwdEVkaXRvciA9IHRoaXMub25IYWxvT3BlblNjcmlwdEVkaXRvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1Jlc2l6ZSA9IHRoaXMub25IYWxvUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvUm90YXRlID0gdGhpcy5vbkhhbG9Sb3RhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9QYXN0ZSA9IHRoaXMub25IYWxvUGFzdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9Db3B5ID0gdGhpcy5vbkhhbG9Db3B5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvVGFyZ2V0ID0gdGhpcy5vbkhhbG9UYXJnZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmRIYWxvVGFyZ2V0ID0gdGhpcy5lbmRIYWxvVGFyZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VFbnRlciA9IHRoaXMub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlTGVhdmUgPSB0aGlzLm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2sgPSB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb09wZW5FZGl0b3IgPSB0aGlzLm9uSGFsb09wZW5FZGl0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkF1eENsaWNrID0gdGhpcy5vbkF1eENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ29udGV4dE1lbnVDbGljayA9IHRoaXMub25Db250ZXh0TWVudUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUYXJnZXRLZXkgPSB0aGlzLmhhbmRsZVRhcmdldEtleS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVRhcmdldE1vdXNlQ2xpY2sgPSB0aGlzLmhhbmRsZVRhcmdldE1vdXNlQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU92ZXIgPSB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3V0ID0gdGhpcy5oYW5kbGVUYXJnZXRNb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkQ29udGV4dE1lbnVJdGVtcyA9IHRoaXMuYWRkQ29udGV4dE1lbnVJdGVtcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRUYXJnZXRWaWV3cyA9IHRoaXMuZ2V0Q3VycmVudFRhcmdldFZpZXdzLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBlZGl0b3IgcmVsYXRlZCBtZXRob2RzXG4gICAgICAgIHRoaXMub3BlbkVkaXRvciA9IHRoaXMub3BlbkVkaXRvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yID0gdGhpcy5jbG9zZUVkaXRvci5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIENvbnRleHQgbWVudVxuICAgICAgICB0aGlzLm9wZW5Db250ZXh0TWVudUF0ID0gdGhpcy5vcGVuQ29udGV4dE1lbnVBdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUgPSB0aGlzLmNsb3NlQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBtaXNjXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodCA9IHRoaXMudW5oaWdobGlnaHQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIGxpZmVjeWNsZSBtZXRob2RzXG4gICAgICAgIHRoaXMuYWZ0ZXJNb2RlbFNldCA9IHRoaXMuYWZ0ZXJNb2RlbFNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFmdGVyTW9kZWxVbnNldCA9IHRoaXMuYWZ0ZXJNb2RlbFVuc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWZ0ZXJDb25uZWN0ZWQgPSB0aGlzLmFmdGVyQ29ubmVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWZ0ZXJEaXNjb25uZWN0ZWQgPSB0aGlzLmFmdGVyRGlzY29ubmVjdGVkLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICAvLyBEbyBzb21lIHVuaXZlcnNhbCBQYXJ0VmlldyBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAvLyB3aGVuIGF0dGFjaGVkIHRvIGEgcGFyZW50IGVsZW1lbnQsIGxpa2VcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyaW5nIGV2ZW50IGxpc3RlbmVycyBldGNcblxuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgbWlkZGxlIG1vdXNlIGJ1dHRvbiBjbGlja1xuICAgICAgICAgICAgLy8gdG8gdG9nZ2xlIHRoZSBoYWxvXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2F1eGNsaWNrJywgdGhpcy5vbkF1eENsaWNrKTtcblxuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgZGVmYXVsdCBldmVudCBoYW5kbGVycyBtYW51YWxseV1cbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgbGlmZWN5Y2xlIG1ldGhvZCB3aGVuIGRvbmVcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIGFib3ZlXG4gICAgICAgICAgICB0aGlzLmFmdGVyQ29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2F1eGNsaWNrJywgdGhpcy5vbkF1eENsaWNrKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVDbGljayk7XG4gICAgICAgIHRoaXMuYWZ0ZXJEaXNjb25uZWN0ZWQoKTtcbiAgICB9XG5cbiAgICBzZXRNb2RlbChhTW9kZWwpe1xuICAgICAgICB0aGlzLnVuc2V0TW9kZWwoKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcbiAgICAgICAgYU1vZGVsLmFkZFByb3BlcnR5U3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgYU1vZGVsLmFkZFZpZXdTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICBpZih0aGlzLmlzTGVuc2VkKXtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbGVucy1wYXJ0LWlkJywgYU1vZGVsLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdwYXJ0LWlkJywgYU1vZGVsLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvYWQgYWxsIHRoZSBpbml0aWFsIHN0eWxpbmdcbiAgICAgICAgdGhpcy5zdHlsZUNTUygpO1xuICAgICAgICB0aGlzLnN0eWxlVGV4dENTUygpO1xuICAgICAgICB0aGlzLmluaXRMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5hZnRlck1vZGVsU2V0KCk7XG4gICAgfVxuXG4gICAgdW5zZXRNb2RlbCgpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIGxldCByZW1vdmVkTW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5yZW1vdmVQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdwYXJ0LWlkJywgXCJcIik7XG4gICAgICAgICAgICB0aGlzLmFmdGVyTW9kZWxVbnNldChyZW1vdmVkTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0dXBCYXNlUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgd2Ugc2hvdWxkIHNldHVwIGFueVxuICAgICAgICAvLyBwcm9wIGNoYW5nZSBoYW5kbGVycyB0aGF0IGFyZSB1bml2ZXJzYWxcbiAgICAgICAgLy8gdG8gYWxsIFBhcnRWaWV3cy4gV2Ugd291bGQgZG8gdGhpcyB2aWFcbiAgICAgICAgLy8gdGhlICNvblByb3BDaGFuZ2UgbWV0aG9kLCB3aGljaCByZWdpc3RlcnNcbiAgICAgICAgLy8gYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHRoZSB1bml2ZXJzYWxzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdzY3JpcHQnLCB0aGlzLnNjcmlwdENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbnVtYmVyJywgdGhpcy5udW1iZXJDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2Nzc1N0eWxlJywgdGhpcy5zdHlsZUNTUyk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjc3NUZXh0U3R5bGUnLCB0aGlzLnN0eWxlVGV4dENTUyk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdsYXlvdXQnLCB0aGlzLmxheW91dENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbGlzdC1kaXJlY3Rpb24nLCB0aGlzLmxpc3REaXJlY3Rpb25DaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2xpc3Qtd3JhcHBpbmcnLCB0aGlzLmxpc3RXcmFwcGluZ0NoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbGlzdC1hbGlnbm1lbnQnLCB0aGlzLmxpc3RBbGlnbm1lbnRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2xpc3QtZGlzdHJpYnV0aW9uJywgdGhpcy5saXN0RGlzdHJpYnV0aW9uQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdob3Jpem9udGFsLXJlc2l6aW5nJywgdGhpcy5oUmVzaXppbmdDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3ZlcnRpY2FsLXJlc2l6aW5nJywgdGhpcy52UmVzaXppbmdDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Bpbm5pbmctdG9wJywgdGhpcy5waW5uaW5nVG9wQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdwaW5uaW5nLXJpZ2h0JywgdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Bpbm5pbmctbGVmdCcsIHRoaXMucGlubmluZ0xlZnRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Bpbm5pbmctYm90dG9tJywgdGhpcy5waW5uaW5nQm90dG9tQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCd3YW50cy1tb3ZlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZih2YWx1ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0dXBCYXNlVmlld0NoYW5nZUhhbmRsZXJzKCl7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgd2Ugc2hvdWxkIHNldHVwIGFueVxuICAgICAgICAvLyB2aWV3IGNoYW5nZSBoYW5kbGVycyB0aGF0IGFyZSB1bml2ZXJzYWxcbiAgICAgICAgLy8gdG8gYWxsIFBhcnRWaWV3cy4gV2Ugd291bGQgZG8gdGhpcyB2aWFcbiAgICAgICAgLy8gdGhlICNvblZpZXdDaGFuZ2UgbWV0aG9kLCB3aGljaCByZWdpc3RlcnNcbiAgICAgICAgLy8gYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2RcbiAgICAgICAgdGhpcy5vblZpZXdDaGFuZ2UoJ3N1YnBhcnQtb3JkZXInLCB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uVmlld0NoYW5nZSgnc3VicGFydC1uZXcnLCB0aGlzLm5ld1N1YnBhcnRWaWV3KTtcbiAgICB9XG5cbiAgICBpbml0TGF5b3V0KCl7XG4gICAgICAgIC8vIE5vdCBhbGwgUGFydC9QYXJ0VmlldyBwYWlycyBoYXZlIHRoZSBsYXlvdXRcbiAgICAgICAgLy8gcHJvcGVydGllcy4gRW5zdXJlIHRoZXkgZXhpc3QgZmlyc3RcbiAgICAgICAgbGV0IGhhc0xheW91dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoJ2xheW91dCcpO1xuICAgICAgICBsZXQgaGFzQm94UmVzaXppbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCd2ZXJ0aWNhbC1yZXNpemluZycpO1xuICAgICAgICBsZXQgaGFzUGlubmluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoJ3Bpbm5pbmcnKTtcbiAgICAgICAgaWYoaGFzTGF5b3V0KXtcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGF5b3V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2xheW91dCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbExpc3REaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnbGlzdC1kaXJlY3Rpb24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxMaXN0V3JhcHBpbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnbGlzdC13cmFwcGluZydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmxheW91dENoYW5nZWQoaW5pdGlhbExheW91dCk7XG4gICAgICAgICAgICB0aGlzLmxpc3REaXJlY3Rpb25DaGFuZ2VkKGluaXRpYWxMaXN0RGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubGlzdFdyYXBwaW5nQ2hhbmdlZChpbml0aWFsTGlzdFdyYXBwaW5nKTtcbiAgICAgICAgICAgIHRoaXMubGlzdEFsaWdubWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdERpc3RyaWJ1dGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGhhc0JveFJlc2l6aW5nKXtcbiAgICAgICAgICAgIGxldCBpbml0aWFsVlJlc2l6aW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3ZlcnRpY2FsLXJlc2l6aW5nJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsSFJlc2l6aW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2hvcml6b250YWwtcmVzaXppbmcnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy52UmVzaXppbmdDaGFuZ2VkKGluaXRpYWxWUmVzaXppbmcpO1xuICAgICAgICAgICAgdGhpcy5oUmVzaXppbmdDaGFuZ2VkKGluaXRpYWxIUmVzaXppbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaGFzUGlubmluZyl7XG4gICAgICAgICAgICB0aGlzLnBpbm5pbmdUb3BDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnBpbm5pbmdCb3R0b21DaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnBpbm5pbmdMZWZ0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdHlsZUNTUygpe1xuICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJjc3NTdHlsZVwiKTtcbiAgICAgICAgT2JqZWN0LmtleXMoY3NzU3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY3NzU3R5bGVba2V5XTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdHlsZVRleHRDU1MoKXtcbiAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwiY3NzVGV4dFN0eWxlXCIpO1xuICAgICAgICBPYmplY3Qua2V5cyhjc3NTdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjc3NTdHlsZVtrZXldO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0YXJnZXQpe1xuICAgICAgICBpZighdGhpcy5pc0xlbnNlZCl7XG4gICAgICAgICAgICAvLyBMZW5zZWQgdmlld3Mgc2hvdWxkIG5vdCBzZW5kIG1lc3NhZ2VzXG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLnNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0aGlzLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVjZWl2ZU1lc3NhZ2UoYU1lc3NhZ2Upe1xuICAgICAgICBzd2l0Y2goYU1lc3NhZ2UudHlwZSl7XG4gICAgICAgIGNhc2UgJ3Byb3BlcnR5Q2hhbmdlZCc6XG4gICAgICAgICAgICB0aGlzLnByaW1IYW5kbGVQcm9wQ2hhbmdlKFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLnByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS5wYXJ0SWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmlld0NoYW5nZWQnOlxuICAgICAgICAgICAgdGhpcy5wcmltSGFuZGxlVmlld0NoYW5nZShcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS5jaGFuZ2VOYW1lLFxuICAgICAgICAgICAgICAgIC4uLmFNZXNzYWdlLmFyZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaW1IYW5kbGVQcm9wQ2hhbmdlKG5hbWUsIHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICAvLyBXZSBub3RpZnkgdGhlIG1vZGVsIHRoYXQgdGhlIHByb3BlcnR5IGNoYW5nZSBzbyB0aGF0XG4gICAgICAgIC8vIG9uIHByb3BlcnR5Q2hhbmdlZCBjb21tYW5kIGhhbmRsZXJzIGNvdWxkIGJlIGludm9rZWRcbiAgICAgICAgLy8gYnV0IHdlIG1ha2Ugc3VyZSB0aGF0IHRoaXMgc3RvcHMgYXQgdGhlIHNhaWQgbW9kZWwgYW5kXG4gICAgICAgIC8vIGRvZXMgbm90IGdvIHVwIHRoZSBkZWxlZ2F0aW9uIGNoYWluXG4gICAgICAgIGxldCBjb21tYW5kTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAncHJvcGVydHlDaGFuZ2VkJyxcbiAgICAgICAgICAgIGFyZ3M6IFtuYW1lLCB2YWx1ZV0sXG4gICAgICAgICAgICBzaG91bGROb3REZWxlZ2F0ZTp0cnVlLCAvLyBkbyBub3Qgc2VuZCB0aGlzIHVwIHRoZSBkZWxlZ2F0aW9uIGNoYWluXG4gICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShjb21tYW5kTWVzc2FnZSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBuYW1lZFxuICAgICAgICAvLyBwcm9wZXJ0eS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIGRvIG5vdGhpbmdcbiAgICAgICAgbGV0IGhhbmRsZXIgPSB0aGlzLnByb3BDaGFuZ2VIYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgaWYoIWhhbmRsZXIpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodmFsdWUsIHBhcnRJZCk7XG4gICAgfVxuXG5cbiAgICBvblByb3BDaGFuZ2UobmFtZSwgZnVuYyl7XG4gICAgICAgIHRoaXMucHJvcENoYW5nZUhhbmRsZXJzW25hbWVdID0gZnVuYztcbiAgICB9XG5cbiAgICBwcmltSGFuZGxlVmlld0NoYW5nZShuYW1lLCAuLi5hcmdzKXtcbiAgICAgICAgLy8gRmluZCB0aGUgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5hbWVkXG4gICAgICAgIC8vIHByb3BlcnR5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgZG8gbm90aGluZ1xuICAgICAgICBsZXQgaGFuZGxlciA9IHRoaXMudmlld0NoYW5nZUhhbmRsZXJzW25hbWVdO1xuICAgICAgICBpZighaGFuZGxlcil7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gaGFuZGxlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgICBvblZpZXdDaGFuZ2UobmFtZSwgZnVuYyl7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZUhhbmRsZXJzW25hbWVdID0gZnVuYztcbiAgICB9XG5cbiAgICBzY3JpcHRDaGFuZ2VkKHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21waWxlJyxcbiAgICAgICAgICAgIGNvZGVTdHJpbmc6IHZhbHVlLFxuICAgICAgICAgICAgdGFyZ2V0SWQ6IHBhcnRJZFxuICAgICAgICB9LCB3aW5kb3cuU3lzdGVtKTtcbiAgICB9XG5cbiAgICBzdWJwYXJ0T3JkZXJDaGFuZ2VkKGlkLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4KXtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBkbyBhbnl0aGluZyBmb3IgdGhlIHdyYXBwZWQgdmlld3NcbiAgICAgICAgLy8gQ2FyZFJvdyBhbmQgU3RhY2tSb3cgd2lsbCBoYW5kbGUgdGhlIHVwZGF0ZXNcbiAgICAgICAgaWYodGhpcy5uYW1lID09IFwiV3JhcHBlZFZpZXdcIil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnBhcnROb2RlID0gdGhpcy5jaGlsZE5vZGVzW2N1cnJlbnRJbmRleF07XG4gICAgICAgIGlmKG5ld0luZGV4ID09IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3VicGFydE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhY2NvdW50IGZvciB3aGV0aGVyIHRoZSBpbmRleCBvZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIG5ld0luZGV4XG4gICAgICAgICAgICBpZihjdXJyZW50SW5kZXggPCBuZXdJbmRleCl7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tuZXdJbmRleF07XG4gICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShzdWJwYXJ0Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdTdWJwYXJ0VmlldyhuZXdWaWV3KXtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdWaWV3KTtcbiAgICB9XG5cbiAgICBsYXlvdXRDaGFuZ2VkKHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICBpZih2YWx1ZSA9PSAnbGlzdCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdsaXN0LWxheW91dCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdsaXN0LWxheW91dCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdERpcmVjdGlvbkNoYW5nZWQodmFsdWUsIHBhcnRJZCl7XG4gICAgICAgIC8vIFJvdyBpcyB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIGZvciBhIGxpc3QgbGF5b3V0LCBzbyBvbmx5IG9uZSBleHRyYVxuICAgICAgICAvLyBDU1MgY2xhc3MgbmVlZHMgdG8gYmUgdG9nZ2xlZFxuICAgICAgICBpZih2YWx1ZSA9PSAncm93Jyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3QtY29sdW1uJyk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAnY29sdW1uJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3QtY29sdW1uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0V3JhcHBpbmdDaGFuZ2VkKHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICBpZih2YWx1ZSA9PSB0cnVlKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnd3JhcC1saXN0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3dyYXAtbGlzdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaFJlc2l6aW5nQ2hhbmdlZCh2YWx1ZSl7XG4gICAgICAgIGlmKHZhbHVlID09ICdzcGFjZS1maWxsJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2gtc3BhY2UtZmlsbCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICdoLXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAnaC1zaHJpbmstd3JhcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAnc2hyaW5rLXdyYXAnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaC1zaHJpbmstd3JhcCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICdoLXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAnaC1zcGFjZS1maWxsJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlID09ICdyaWdpZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoLXJpZ2lkJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ2gtc3BhY2UtZmlsbCcsXG4gICAgICAgICAgICAgICAgJ2gtc2hyaW5rLXdyYXAnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdlJlc2l6aW5nQ2hhbmdlZCh2YWx1ZSl7XG4gICAgICAgIGlmKHZhbHVlID09ICdzcGFjZS1maWxsJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Ytc3BhY2UtZmlsbCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICd2LXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAndi1zaHJpbmstd3JhcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAnc2hyaW5rLXdyYXAnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgndi1zaHJpbmstd3JhcCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICd2LXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAndi1zcGFjZS1maWxsJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlID09ICdyaWdpZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd2LXJpZ2lkJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ3Ytc3BhY2UtZmlsbCcsXG4gICAgICAgICAgICAgICAgJ3Ytc2hyaW5rLXdyYXAnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ1RvcENoYW5nZWQoKXtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAncGlubmluZy10b3AnXG4gICAgICAgICk7XG4gICAgICAgIGlmKHRvcCl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Bpbi10b3AnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncGluLXRvcCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ0xlZnRDaGFuZ2VkKCl7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdwaW5uaW5nLWxlZnQnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGxlZnQpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwaW4tbGVmdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdwaW4tbGVmdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ1JpZ2h0Q2hhbmdlZCgpe1xuICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3Bpbm5pbmctcmlnaHQnXG4gICAgICAgICk7XG4gICAgICAgIGlmKHJpZ2h0KXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGluLXJpZ2h0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Bpbi1yaWdodCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ0JvdHRvbUNoYW5nZWQoKXtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAncGlubmluZy1ib3R0b20nXG4gICAgICAgICk7XG4gICAgICAgIGlmKGJvdHRvbSl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Bpbi1ib3R0b20nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncGluLWJvdHRvbScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdEFsaWdubWVudENoYW5nZWQoKXtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdsaXN0LWFsaWdubWVudCdcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHZhbGlkID0gW1xuICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICdyaWdodCcsXG4gICAgICAgICAgICAnY2VudGVyJ1xuICAgICAgICBdO1xuICAgICAgICBpZih2YWxpZC5pbmNsdWRlcyh2YWx1ZSkpe1xuICAgICAgICAgICAgdmFsaWQuZm9yRWFjaChzaWRlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoYGxpc3QtYWxpZ24tJHtzaWRlfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoYGxpc3QtYWxpZ24tJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxpc3REaXN0cmlidXRpb25DaGFuZ2VkKCl7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbGlzdC1kaXN0cmlidXRpb24nXG4gICAgICAgICk7XG4gICAgICAgIGxldCB2YWxpZCA9IFtcbiAgICAgICAgICAgICdzdGFydCcsXG4gICAgICAgICAgICAnZW5kJyxcbiAgICAgICAgICAgICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICdzcGFjZS1hcm91bmQnLFxuICAgICAgICAgICAgJ2NlbnRlcidcbiAgICAgICAgXTtcbiAgICAgICAgaWYodmFsaWQuaW5jbHVkZXModmFsdWUpKXtcbiAgICAgICAgICAgIHZhbGlkLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGBsaXN0LWRpc3RyaWJ1dGlvbi0ke3NpZGV9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChgbGlzdC1kaXN0cmlidXRpb24tJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIExpZmVjeWNsZSBNZXRob2QgRGVmYXVsdHMgKi9cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsVW5zZXQocmVtb3ZlZE1vZGVsKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBieSBkZWZhdWx0LlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzXG4gICAgfVxuXG4gICAgLyogSGFsbyBSZWxhdGVkIE1ldGhvZHMgKi9cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgaGFsbyBpblxuICAgICAgICAvLyB0aGUgY29tcG9uZW50J3Mgc2hhZG93IHJvb3QgYWxyZWFkeVxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBsZXQgbmV3SGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChuZXdIYWxvKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlSGFsbygpe1xuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsby5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZUFudHNCb3JkZXIoKXtcbiAgICAgICAgaWYodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ21hcmNoaW5nLWFudHMnKSl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ21hcmNoaW5nLWFudHMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbWFyY2hpbmctYW50cycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25IYWxvRGVsZXRlKCl7XG4gICAgICAgIC8vIFdoYXQgdG8gZG8gd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlXG4gICAgICAgIC8vIGRlbGV0ZSBidXR0b24gb24gYSBoYWxvIGZvciB0aGlzIHBhcnR2aWV3LlxuICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyB0byBzZW5kIGEgbWVzc2FnZVxuICAgICAgICAvLyB0byB0aGUgU3lzdGVtIHRvIGRlbGV0ZSB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAvLyBtb2RlbCBhbmQgKmFsbCogdmlld3MgcmVmZXJlbmNpbmcgdGhhdFxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ2RlbGV0ZU1vZGVsJyxcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLm1vZGVsLmlkXVxuICAgICAgICB9LCB3aW5kb3cuU3lzdGVtKTtcbiAgICB9XG5cbiAgICBvbkhhbG9PcGVuU2NyaXB0RWRpdG9yKCl7XG4gICAgICAgIC8vIFNlbmQgdGhlIG1lc3NhZ2UgdG8gb3BlbiBhIHNjcmlwdCBlZGl0b3JcbiAgICAgICAgLy8gd2l0aCB0aGlzIHZpZXcncyBtb2RlbCBhcyB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLm1vZGVsLmlkXVxuICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbkhhbG9PcGVuRWRpdG9yKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uZWRpdG9yLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgd2luZG93LlN5c3RlbS5lZGl0b3Iub3BlbigpO1xuICAgIH1cblxuICAgIG9uSGFsb1Jlc2l6ZShtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb24gd2hhdCB0byBkbyBkdXJpbmdcbiAgICAgICAgLy8gaGFsbyBidXR0b24gcmVzaXplIG9wZXJ0YXRpb25zLiBTdWJjbGFzc2VzXG4gICAgICAgIC8vIGNhbiBvdmVycmlkZSBmb3IgY3VzdG9tIGJlaGF2aW9yLlxuICAgICAgICAvLyBEZWZhdWx0IGlzIHRvIHVwZGF0ZSB0aGUgVmlldyBjb21wb25lbnQnc1xuICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHN0eWxlIHByb3BlcnRpZXMgZGlyZWN0bHkuXG4gICAgICAgIC8vIElmIHRoZSBwYXJ0IGlzIHJvdGF0ZWQgdGhpcyB3aWxsIHRocm93IG9mZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgIC8vIGJyb3dzZXIgY2FsY3VhbHRpb24uIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gcm90YXRlIHRoZSBwYXJ0IHRvIDBcbiAgICAgICAgLy8gKGlmIG5lY2Vzc2FyeSkgZG8gdGhlIGNhbGN1bGF0aW9ucyBhbmQgdGhlbiByb3RhdGUgaXQgYmFja1xuICAgICAgICBsZXQgYW5nbGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIik7XG4gICAgICAgIGlmKGFuZ2xlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBuZXdXaWR0aCwgbmV3SGVpZ2h0O1xuICAgICAgICBpZih0aGlzLnByZXNlcnZlQXNwZWN0T25SZXNpemUpe1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGh5cCA9IE1hdGguc3FydCgobW92ZW1lbnRYKioyKSArIChtb3ZlbWVudFkqKjIpKTtcbiAgICAgICAgICAgIGlmKG1vdmVtZW50WCA8IDAgfHwgbW92ZW1lbnRZIDwgMCl7XG4gICAgICAgICAgICAgICAgaHlwID0gaHlwICogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSByZWN0LmhlaWdodCArIGh5cDtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gcmVjdC53aWR0aCArIGh5cDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gbW92ZW1lbnRYICsgcmVjdC53aWR0aDtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IG1vdmVtZW50WSArIHJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcIndpZHRoXCIsIG5ld1dpZHRoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiaGVpZ2h0XCIsIG5ld0hlaWdodCk7XG4gICAgICAgIC8vIHJlc2V0IHRoZSByb3RhdGUgYW5nbGUgdG8gdGhlIG9yaWdpbmFsIChpZiBuZWNlc3NhcnkpXG4gICAgICAgIGlmKGFuZ2xlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkhhbG9Sb3RhdGUobW92ZW1lbnRYLCBtb3ZlbWVudFkpe1xuICAgICAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9uIHdoYXQgdG8gZG8gZHVyaW5nXG4gICAgICAgIC8vIGhhbG8gYnV0dG9uIHJvdGF0ZSBvcGVydGF0aW9ucy4gU3ViY2xhc3Nlc1xuICAgICAgICAvLyBjYW4gb3ZlcnJpZGUgZm9yIGN1c3RvbSBiZWhhdmlvci5cbiAgICAgICAgLy8gRGVmYXVsdCBpcyB0byB1cGRhdGUgdGhlIFZpZXcgY29tcG9uZW50J3NcbiAgICAgICAgLy8gcm90YXRlIHN0eWxlIHByb3BlcnR5IGRpcmVjdGx5LlxuICAgICAgICBpZihtb3ZlbWVudFggfHwgbW92ZW1lbnRZKXtcbiAgICAgICAgICAgIGxldCBjdXJyZW50QW5nbGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIik7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZighY3VycmVudEFuZ2xlKXtcbiAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRoZXRhMSA9IE1hdGguYXRhbigocmVjdC5oZWlnaHQvMikvKHJlY3Qud2lkdGgvMikpO1xuICAgICAgICAgICAgbGV0IHRoZXRhMiA9IE1hdGguYXRhbigocmVjdC5oZWlnaHQvMiArIG1vdmVtZW50WSkvKHJlY3Qud2lkdGgvMiArIG1vdmVtZW50WCkpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZUFuZ2xlID0gTWF0aC5hYnMoKHRoZXRhMiAtIHRoZXRhMSkqMTgwL01hdGguUEkpO1xuICAgICAgICAgICAgbGV0IG5ld0FuZ2xlID0gKGN1cnJlbnRBbmdsZSArIGNoYW5nZUFuZ2xlKSAlIDM2MDtcbiAgICAgICAgICAgIGlmKG5ld0FuZ2xlIDwgMCl7XG4gICAgICAgICAgICAgICAgbmV3QW5nbGUgPSAzNjAgKyBuZXdBbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG5ld0FuZ2xlKXtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIiwgbmV3QW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25IYWxvQ29weSgpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5jb3B5UGFydCh0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbkhhbG9QYXN0ZSgpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5wYXN0ZUNvbnRlbnRzSW50byh0aGlzLm1vZGVsKTtcbiAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICB9XG5cbiAgICBvbkhhbG9UYXJnZXQoZXZlbnQpe1xuICAgICAgICAvLyBBZGQgdGFyZ2V0aW5nIHJlY2VpdmUgbGlzdGVuZXJzIHRvIGFsbCBQYXJ0Vmlld3NcbiAgICAgICAgLy8gb24gdGhlIGN1cnJlbnQgY2FyZC5cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja1ZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suaWR9XCJdYCk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suY3VycmVudENhcmQuaWR9XCJdYCk7XG4gICAgICAgIGxldCB0YXJnZXRDYXJkUGFydHMgPSBBcnJheS5mcm9tKGN1cnJlbnRDYXJkVmlldy5xdWVyeVNlbGVjdG9yQWxsKCdbcGFydC1pZF0nKSk7XG4gICAgICAgIGxldCB0YXJnZXRTdGFja1BhcnRzID0gQXJyYXkuZnJvbShjdXJyZW50U3RhY2tWaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ1twYXJ0LWlkXTpub3Qoc3QtY2FyZCk6bm90KHN0LXN0YWNrKScpKTtcbiAgICAgICAgbGV0IGFsbFRhcmdldHMgPSB0YXJnZXRDYXJkUGFydHMuY29uY2F0KHRhcmdldFN0YWNrUGFydHMpO1xuICAgICAgICBhbGxUYXJnZXRzLmZvckVhY2gocGFydFZpZXcgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlVGFyZ2V0S2V5KTtcbiAgICAgICAgICAgIHBhcnRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdmVyKTtcbiAgICAgICAgICAgIHBhcnRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU91dCk7XG4gICAgICAgICAgICBwYXJ0Vmlldy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VDbGljayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3RhcmdldGluZy1tb2RlJyk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIG9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlRW50ZXIoKXtcbiAgICAgICAgLy8gbGlnaHQgdXAgdGhlIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFRhcmdldFZpZXdzKCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy5oaWdobGlnaHQoXCJyZ2IoNTQsIDE3MiwgMTAwKVwiKTsgLy9ncmVlblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUxlYXZlKCl7XG4gICAgICAgIC8vIGxpZ2h0IHVwIHRoZSBjdXJyZW50IHRhcmdldFxuICAgICAgICB0aGlzLmdldEN1cnJlbnRUYXJnZXRWaWV3cygpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0KGNvbG9yKXtcbiAgICAgICAgaWYodGhpcy5uYW1lICE9IFwiU3RhY2tWaWV3XCIgJiYgdGhpcy5uYW1lICE9IFwiV29ybGRWaWV3XCIpe1xuICAgICAgICAgICAgdGhpcy5fdGVtcEJhY2tncm91bmRDb2xvciA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtY29sb3JcIik7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBCYWNrZ3JvdW5kVHJhbnNwYXJlbmN5ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIik7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeVwiLCAxKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdW5oaWdobGlnaHQoKXtcbiAgICAgICAgaWYodGhpcy5uYW1lICE9IFwiU3RhY2tWaWV3XCIgJiYgdGhpcy5uYW1lICE9IFwiV29ybGRWaWV3XCIpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC1jb2xvclwiLCB0aGlzLl90ZW1wQmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtdHJhbnNwYXJlbmN5XCIsIHRoaXMuX3RlbXBCYWNrZ3JvdW5kVHJhbnNwYXJlbmN5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZEhhbG9UYXJnZXQoKXtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0YXJnZXRpbmcgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdGhhdCB3ZXJlIGFkZGVkIGR1cmluZyB0aGUgb25IYWxvVGFyZ2V0XG4gICAgICAgIC8vIGhhbmRsZXJcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja1ZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suaWR9XCJdYCk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suY3VycmVudENhcmQuaWR9XCJdYCk7XG4gICAgICAgIGxldCB0YXJnZXRDYXJkUGFydHMgPSBBcnJheS5mcm9tKGN1cnJlbnRDYXJkVmlldy5xdWVyeVNlbGVjdG9yQWxsKCdbcGFydC1pZF0nKSk7XG4gICAgICAgIGxldCB0YXJnZXRTdGFja1BhcnRzID0gQXJyYXkuZnJvbShjdXJyZW50U3RhY2tWaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ1twYXJ0LWlkXTpub3Qoc3QtY2FyZCk6bm90KHN0LXN0YWNrKScpKTtcbiAgICAgICAgbGV0IGFsbFRhcmdldHMgPSB0YXJnZXRDYXJkUGFydHMuY29uY2F0KHRhcmdldFN0YWNrUGFydHMpO1xuICAgICAgICBhbGxUYXJnZXRzLmZvckVhY2gocGFydFZpZXcgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlVGFyZ2V0S2V5KTtcbiAgICAgICAgICAgIHBhcnRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZVRhcmdldEtleSk7XG4gICAgICAgICAgICBwYXJ0Vmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3Zlcik7XG4gICAgICAgICAgICBwYXJ0Vmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdXQpO1xuICAgICAgICAgICAgcGFydFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlQ2xpY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd0YXJnZXRpbmctbW9kZScpO1xuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldEtleShldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmtleSA9PSAnRXNjYXBlJyl7XG4gICAgICAgICAgICB0aGlzLmVuZEhhbG9UYXJnZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldE1vdXNlT3ZlcihldmVudCl7XG4gICAgICAgIGlmKCFldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXRpbmcnKSl7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgndGFyZ2V0aW5nJyk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuaGlnaGxpZ2h0KFwicmdiKDIzNCwgNTUsIDU1KVwiKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50LnRhcmdldC5vbkNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldE1vdXNlTGVhdmUoZXZlbnQpe1xuICAgICAgICBpZihldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXRpbmcnKSl7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgndGFyZ2V0aW5nJyk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudW5oaWdobGlnaHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50LnRhcmdldC5vbkNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldE1vdXNlQ2xpY2soZXZlbnQpe1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiBldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3RhcmdldGluZycpO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3RhcmdldCcsXG4gICAgICAgICAgICBldmVudC50YXJnZXQubW9kZWwuaWRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbmRIYWxvVGFyZ2V0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC50YXJnZXQudW5oaWdobGlnaHQoKTtcbiAgICAgICAgZXZlbnQudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQudGFyZ2V0Lm9uQ2xpY2spO1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRUYXJnZXRWaWV3cygpe1xuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgY3VycmVudCB0YXJnZXRcbiAgICAgICAgbGV0IGN1cnJlbnRUYXJnZXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJ0YXJnZXRcIik7XG4gICAgICAgIGlmKGN1cnJlbnRUYXJnZXQpe1xuICAgICAgICAgICAgbGV0IHNlbWFudGljcyA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJTZW1hbnRpY3ModGhpcy5tb2RlbCwgd2luZG93LlN5c3RlbSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgbSA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5tYXRjaChjdXJyZW50VGFyZ2V0LCBcIk9iamVjdFNwZWNpZmllclwiKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IHNlbWFudGljcyhtKS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBvbkNvbnRleHRNZW51Q2xpY2soZXZlbnQpe1xuICAgICAgICBpZih0aGlzLndhbnRzQ29udGV4dE1lbnUpe1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaWYodGhpcy5jb250ZXh0TWVudUlzT3Blbil7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51QXQoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNsaWVudFlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkF1eENsaWNrKGV2ZW50KXtcbiAgICAgICAgLy8gU2hvdWxkIG9ubHkgb3BlbiBoYWxvIHdoZW4gbWlkZGxlXG4gICAgICAgIC8vIG1vdXNlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAxKXtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy5jb250ZXh0TWVudUlzT3Blbil7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiBldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25IYWxvQWN0aXZhdGlvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy53YW50c0hhbG8pe1xuICAgICAgICAgICAgaWYodGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBhbnkgb3RoZXIgb3BlbiBIYWxvc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBhdXRvbWF0aWNhbGx5IGNsb3NlIHRoZW1cbiAgICAgICAgICAgICAgICBsZXQgZXhTZWxlY3RvciA9IGAuZWRpdGluZzpub3QoW3BhcnQtaWQ9XCIke3RoaXMubW9kZWwuaWR9XCJdKWA7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGV4U2VsZWN0b3IpKS5mb3JFYWNoKG9wZW5IYWxvRWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcGVuSGFsb0VsLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgb3BlbiBvbiB0aGlzIHZpZXdcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5IYWxvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlRG93bihldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwICYmICFldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3ZlJyxcbiAgICAgICAgICAgIGFyZ3M6IFtldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WV1cbiAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb3BlbkNvbnRleHRNZW51QXQoeCwgeSl7XG4gICAgICAgIGxldCBtZW51RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1jb250ZXh0LW1lbnUnKTtcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1twYXJ0LWlkPVwid29ybGRcIl0nKTtcbiAgICAgICAgbWVudUVsLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgbWVudUVsLnN0eWxlLmxlZnQgPSBgJHt4fXB4YDtcbiAgICAgICAgbWVudUVsLnN0eWxlLnRvcCA9IGAke3l9cHhgO1xuICAgICAgICB3b3JsZFZpZXcuYXBwZW5kKG1lbnVFbCk7XG4gICAgfVxuXG4gICAgY2xvc2VDb250ZXh0TWVudSgpe1xuICAgICAgICBsZXQgZm91bmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1jb250ZXh0LW1lbnUnKTtcbiAgICAgICAgaWYoZm91bmQpe1xuICAgICAgICAgICAgZm91bmQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDb250ZXh0TWVudUl0ZW1zKGNvbnRleHRNZW51KXtcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgdG9cbiAgICAgICAgLy8gZG8gbm90aGlucy5cbiAgICAgICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gcGFzc2VkLWluIGNvbnRleHRNZW51IG9iamVjdCB0byBjb25zdHJ1Y3RcbiAgICAgICAgLy8gbGlzdCBpdGVtcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGVpciBuZWVkc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0IHdhbnRzSGFsb01vdmUoKXtcbiAgICAgICAgaWYoIXRoaXMucGFyZW50RWxlbWVudCB8fCAhdGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRFbGVtZW50Lm1vZGVsO1xuICAgICAgICBpZighcGFyZW50TW9kZWwpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGFzTGF5b3V0ID0gcGFyZW50TW9kZWwucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBwYXJlbnRNb2RlbCxcbiAgICAgICAgICAgICdsYXlvdXQnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYoIWhhc0xheW91dCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJlbnRMYXlvdXQgPSBwYXJlbnRNb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgcGFyZW50TW9kZWwsXG4gICAgICAgICAgICAnbGF5b3V0J1xuICAgICAgICApO1xuICAgICAgICBpZihwYXJlbnRMYXlvdXQgPT09ICdzdHJpY3QnIHwgIXBhcmVudExheW91dCB8fCBwYXJlbnRMYXlvdXQgPT0gXCJcIil7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgY29udGV4dE1lbnVJc09wZW4oKXtcbiAgICAgICAgbGV0IGZvdW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtY29udGV4dC1tZW51Jyk7XG4gICAgICAgIGlmKGZvdW5kKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBFZGl0b3IgcmVsYXRlZCBtZXRob2RzICovXG4gICAgb3BlbkVkaXRvcigpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzXG4gICAgfVxuXG4gICAgY2xvc2VFZGl0b3IoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgUGFydFZpZXcsXG4gICAgUGFydFZpZXcgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgbGlua0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbGlua1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAgMTRhMy41IDMuNSAwIDAgMCA1IDBsNCAtNGEzLjUgMy41IDAgMCAwIC01IC01bC0uNSAuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTBhMy41IDMuNSAwIDAgMCAtNSAwbC00IDRhMy41IDMuNSAwIDAgMCA1IDVsLjUgLS41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG46aG9zdCB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcGFkZGluZzogMXB4O1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xufVxuXG4ud3JhcHBlcntcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxufVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJuYW1lXCI+PC9zcGFuPlxuICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1idWlsZGluZy1icmlkZ2UtMlwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgICA8cGF0aCBkPVwiTTYgN2gxMmEyIDIgMCAwIDEgMiAydjlhMSAxIDAgMCAxIC0xIDFoLTJhMSAxIDAgMCAxIC0xIC0xdi0yYTQgNCAwIDAgMCAtOCAwdjJhMSAxIDAgMCAxIC0xIDFoLTJhMSAxIDAgMCAxIC0xIC0xdi05YTIgMiAwIDAgMSAyIC0yXCI+PC9wYXRoPlxuICAgIDwvc3ZnPlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBSZXNvdXJjZVZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlc291cmNlTGluayA9IHRoaXMudXBkYXRlUmVzb3VyY2VMaW5rLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlID0gdGhpcy5pbmRpY2F0ZVJlYWR5U3RhdGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICAvLyBpZiB0aGUgcmVzb3VyY2VOYW1lIHByb3BlcnR5IGlzIHNldCB0aGVuIG1ha2Ugc3VyZSBpdCBpcyBsb2FkZWRcbiAgICAgICAgLy8gVE9ETzogaSBkb24ndCBsaWtlIHRoaXMgdmlldyBhc2tpbmcgdGhlIG1vZGVsIHRvIGxvYWQhXG4gICAgICAgIGxldCByZXNvdXJjZU5hbWUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyZXNvdXJjZU5hbWVcIik7XG4gICAgICAgIGlmKHJlc291cmNlTmFtZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLmxvYWRSZXNvdXJjZShbdGhpc10sIHJlc291cmNlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInNyY1wiKTtcbiAgICAgICAgaWYoc3JjKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0U291cmNlVG8oW3RoaXNdLCBzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lU3BhbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5uYW1lXCIpO1xuICAgICAgICBuYW1lU3Bhbi5pbm5lclRleHQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJuYW1lXCIpO1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJyZWFkeVN0YXRlXCIsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlKHN0YXRlKTtcbiAgICAgICAgLy8gcHJvcCBjaGFuZ2VzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwibmFtZVwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIG5hbWVTcGFuLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJyZWFkeVN0YXRlXCIsIHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJzcmNcIiwgKHVybCkgPT4ge1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDApe1xuICAgICAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyB0aGUgb24gY2xpY2sgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZighdGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgY2xpY2sgY29tbWFuZCBtZXNzYWdlIHRvIHNlbGZcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluZGljYXRlUmVhZHlTdGF0ZSh2YWx1ZSl7XG4gICAgICAgIGxldCBib3JkZXJDb2xvciA9IFwicmVkXCI7XG4gICAgICAgIGlmKHZhbHVlID09IFwiZmV0Y2hpbmdcIil7XG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IFwieWVsbG93XCI7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSBcInJlYWR5XCIpe1xuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBcImdyZWVuXCI7XG4gICAgICAgIH07XG4gICAgICAgIFtcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiXS5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgYGJvcmRlci0ke3NpZGV9LWNvbG9yYCwgYm9yZGVyQ29sb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b24oKXtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pZCA9ICdoYWxvLXJlc291cmNlLWxpbmsnO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlubmVySFRNTCA9IGxpbmtJY29uO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luVG9wID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdyaWdodC1jb2x1bW4nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnRWRpdCBsaW5rIGZvciByZXNvdXJjZScpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnVwZGF0ZVJlc291cmNlTGluayk7XG4gICAgfVxuXG4gICAgdXBkYXRlUmVzb3VyY2VMaW5rKGV2ZW50KXtcbiAgICAgICAgLy8gVGVsbHMgdGhlIG1vZGVsIHRvIHVwZGF0ZSBpdHNcbiAgICAgICAgLy8gc3JjIGxpbmsgZm9yIHRoZSByZXNvdXJjZVxuICAgICAgICBsZXQgY3VycmVudFNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnc3JjJ1xuICAgICAgICApO1xuICAgICAgICBsZXQgcmVzdWx0ID0gd2luZG93LnByb21wdChcIkVkaXQgVVJMIGZvciByZXNvdXJjZTpcIiwgY3VycmVudFNyYyk7XG4gICAgICAgIGlmKHJlc3VsdCAmJiByZXN1bHQgIT09ICcnICYmIHJlc3VsdCAhPT0gY3VycmVudFNyYyl7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2xvYWRSZXNvdXJjZScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsgcmVzdWx0IF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcblxuZXhwb3J0IHtcbiAgICBSZXNvdXJjZVZpZXcsXG4gICAgUmVzb3VyY2VWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFN0YWNrVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIFdlYmNvbXBvbmVudCAoY3VzdG9tIGVsZW1lbnQpIHJlcHJlc2VudGluZ1xuICogdGhlIHZpZXcgb2YgYSBTdGFjay5cbiAqIEkgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgY3VycmVudCB2aWV3cG9ydFxuICogd2hlbiBJIGFtIGJlaW5nIGRpc3BsYXllZC5cbiAqIE15IGNoaWxkIGVsZW1lbnRzIGFyZSBCYWNrZ3JvdW5kVmlldyBhbmQgQ2FyZFZpZXdcbiAqL1xuXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi4vcGFydHMvU3RhY2suanMnO1xuXG4vLyBieSBkZWZhdWx0LCBzdGFja3MgYXJlIGhpZGRlbiB1bmxlc3MgdGhleSdyZVxuLy8gdGhlIGN1cnJlbnQgc3RhY2ssIG9yIGVsc2UgdGhleSBoYXZlIHRoZSBjbGFzc1xuLy8gd2luZG93LXN0YWNrIChzdWdnZXN0aW5nIHRoZXJlJ3Mgd2luZG93IHBhcnRcbi8vIHdobyB3aXNoZXMgdG8gZGlzcGxheSBpdClcbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYDxzbG90Pjwvc2xvdD5gO1xuXG5jbGFzcyBTdGFja1ZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0aW5nIGFuZCBzaGFkb3cgZG9tXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEhhbG8gc2V0dGluZ3MuIENhcmRzIGRvbid0IHdhbnRcbiAgICAgICAgLy9hIGhhbG8gdG8gb3BlblxuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBjdXJyZW50LW5lc3MgcHJvcCBjaGFuZ2VcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2N1cnJlbnQnLCB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UpO1xuXG4gICAgICAgIC8vIEJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UgPSB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIERvIGFuIGluaXRpYWwgc2V0dGluZyBvZiB0aGVcbiAgICAgICAgLy8gY3VycmVudCBjYXJkXG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSgpO1xuICAgIH1cblxuICAgIGhhbmRsZUN1cnJlbnRDaGFuZ2UoKXtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IHByb3AgaXMgdGhlIGNhcmQgSURcbiAgICAgICAgLy8gb2YgdGhlIGNoaWxkIENhcmQgdGhhdCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgb25lLiBXZSByZW1vdmUgdGhlIGN1cnJlbnQtY2FyZCBjbGFzcyBmcm9tXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBjdXJyZW50IGNhcmQgYW5kIGFkZCBpdCB0byB0aGUgbmV3IG9uZS5cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuY3VycmVudC1jYXJkJyk7XG4gICAgICAgIGxldCBuZXh0Q3VycmVudElkID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdjdXJyZW50J1xuICAgICAgICApO1xuICAgICAgICBsZXQgc2hvdWxkTm90aWZ5ID0gZmFsc2U7XG4gICAgICAgIGxldCBzZWxlY3RvciA9IGA6c2NvcGUgPiBzdC1jYXJkW3BhcnQtaWQ9XCIke25leHRDdXJyZW50SWR9XCJdYDtcbiAgICAgICAgaWYodGhpcy5pc0xlbnNlZCl7XG4gICAgICAgICAgICBzZWxlY3RvciA9IGA6c2NvcGUgPiBzdC1jYXJkW2xlbnMtcGFydC1pZD1cIiR7bmV4dEN1cnJlbnRJZH1cIl1gO1xuICAgICAgICAgICAgc2hvdWxkTm90aWZ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dEN1cnJlbnRDYXJkID0gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gY3VycmVudENhcmQgYW5kIG5vIG5leHQgY3VycmVudENhcmQgd2Ugc2V0IGl0IHRvIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyBjYXJkIGNoaWxkICh0aGlzIGNhbiBoYXBwZW4gd2hlbiBuZXcgaWRzIGFyZSBjcmVhdGVkIG9uIGRlc2VyaWFsaXphdGlvbiBhbmQgc29cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgcHJvcGVydHkgc3RvcmVkIGlkIGlzIG5vIGxvbmdlciByZWxldmFudClcbiAgICAgICAgaWYoIW5leHRDdXJyZW50Q2FyZCAmJiAhY3VycmVudENhcmQpe1xuICAgICAgICAgICAgbmV4dEN1cnJlbnRDYXJkID0gdGhpcy5xdWVyeVNlbGVjdG9yKGA6c2NvcGUgPiBzdC1jYXJkYCk7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gY2FyZHMgYXQgYWxsLCB0aGlzIG11c3QgYmUgYSBicmFuZCBuZXcgc3RhY2tcbiAgICAgICAgICAgIGlmKCFuZXh0Q3VycmVudENhcmQpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgICAgICAgIG5leHRDdXJyZW50Q2FyZC5pZCxcbiAgICAgICAgICAgICAgICBzaG91bGROb3RpZnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYobmV4dEN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIG5leHRDdXJyZW50Q2FyZC5jbGFzc0xpc3QuYWRkKCdjdXJyZW50LWNhcmQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50Q2FyZCAmJiBjdXJyZW50Q2FyZCAhPSBuZXh0Q3VycmVudENhcmQpe1xuICAgICAgICAgICAgY3VycmVudENhcmQuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudC1jYXJkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSBzdWJjbGFzcyBtZXRob2RzXG4gICAgbmV3U3VicGFydFZpZXcobmV3Vmlldyl7XG4gICAgICAgIGlmKHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggJiYgbmV3Vmlldy5uYW1lID09IFwiQ2FyZFZpZXdcIil7XG4gICAgICAgICAgICBsZXQgbGFzdENhcmROb2RlO1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoY2hpbGQubmFtZSA9PSBcIkNhcmRWaWV3XCIpe1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2FyZE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKGxhc3RDYXJkTm9kZSl7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IGNhcmRcbiAgICAgICAgICAgICAgICBsYXN0Q2FyZE5vZGUuYWZ0ZXIobmV3Vmlldyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXJlIGFyZSBubyBjYXJkc1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBiZWZvcmUgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLmluc2VydEJlZm9yZShuZXdWaWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Vmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmV4cG9ydCB7XG4gICAgU3RhY2tWaWV3LFxuICAgIFN0YWNrVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBXaW5kb3dWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIHRoZSB2aWV3IG9mIGEgV2luZG93IFBhcnQuXG4gKiBXaW5kb3dzIGFyZSB3cmFwcGVycyBmb3IgU3RhY2tzL1N0YWNrVmlld3MgdGhhdFxuICogYXBwZWFyIGFzIHRoZSBzdWJwYXJ0cyBvZiBvdGhlciBTdGFja3Mgb3IgQ2FyZHMuXG4gKiBUaGV5IGFyZSBleGFtcGxlcyBvZiBob3cgd2UgY2FuIHVzZSBzdGFjayBhbmQgY2FyZFxuICogY29tcG9zaXRpb24gdG8gY3JlYXRlIG1vcmUgY29tcGxleCBVSXMuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuICoge1xuICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuIH1cblxuIC5zdC13aW5kb3ctYmFyIHtcbiAgICAgZGlzcGxheTogZmxleDtcbiAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgd2lkdGg6IDEwMCU7XG4gICAgIG1pbi1oZWlnaHQ6IDI1cHg7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyMTgsIDIxOCwgMjE4KTtcbiAgICAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcbiAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiB9XG4gLnN0LXdpbmRvdy1idXR0b24ge1xuICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgd2lkdGg6IDEycHg7XG4gICAgIGhlaWdodDogMTJweDtcbiAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDE1MCwgMTUwKTtcbiAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gfVxuIC5jbG9zZS1idXR0b24ge1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgNTAsIDUwLCAwLjQpO1xuIH1cbiAuc2hhZGUtYnV0dG9uIHtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMC4gMC40KTtcbiB9XG4gLmV4cGFuZC1idXR0b24ge1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE1MCwgMjU1LCAwLCAwLjgpO1xuIH1cbiAuc3Qtd2luZG93LXBhbmUge1xuICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICBtaW4taGVpZ2h0OiA1MHB4O1xuICAgICBmbGV4OiAxO1xuIH1cbiAuc3Qtd2luZG93LXBhbmUuc2hhZGVkIHtcbiAgICAgZGlzcGxheTogbm9uZTtcbiB9XG4gLnN0LXdpbmRvdy1ncmlwcGVyIHtcbiAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgdG9wOiBjYWxjKDEwMCUgLSAxNXB4KTtcbiAgICAgd2lkdGg6IDMwcHg7XG4gICAgIGhlaWdodDogMzBweDtcbiB9XG4gLnN0LXdpbmRvdy10aXRsZSB7XG4gICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgbWF4LXdpZHRoOiA3MCU7XG4gfVxuIC5yaWdodC1ncmlwcGVyIHtcbiAgICAgbGVmdDogY2FsYygxMDAlIC0gMTVweCk7XG4gfVxuIC5yaWdodC1ncmlwcGVyOmhvdmVyIHtcbiAgICAgY3Vyc29yOiBud3NlLXJlc2l6ZTtcbiB9XG4gLmxlZnQtZ3JpcHBlciB7XG4gICAgIHJpZ2h0OiBjYWxjKDEwMCUgLSAxNXB4KTtcbiB9XG4gLmxlZnQtZ3JpcHBlcjpob3ZlciB7XG4gICAgIGN1cnNvcjogbmVzdy1yZXNpemU7XG4gfVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYmFyXCI+XG4gICAgPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1idXR0b24gY2xvc2UtYnV0dG9uXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1idXR0b24gc2hhZGUtYnV0dG9uXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1idXR0b24gZXhwYW5kLWJ1dHRvblwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctdGl0bGVcIj5cbiAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgIDwvZGl2PlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwic3Qtd2luZG93LXBhbmVcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbjxkaXYgY2xhc3M9XCJzdC13aW5kb3ctZ3JpcHBlciByaWdodC1ncmlwcGVyXCIgZGF0YS1ncmlwLWVuZD1cInJpZ2h0XCI+PC9kaXY+XG5gO1xuXG5jbGFzcyBXaW5kb3dWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdmFyIHRlbXBsYXRlQ29udGVudCA9IHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlQ29udGVudCk7XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd25JbkJhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU2hhZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV4cGFuZENhY2hlID0ge307XG5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgYXJlIGdyaXBwaW5nIHRoZVxuICAgICAgICAvLyBib3R0b20gcmlnaHQgY29ybmVyIGZvciBhIHJlc2l6ZVxuICAgICAgICB0aGlzLmlzR3JpcHBpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0dXBDbGlja0FuZERyYWcgPSB0aGlzLnNldHVwQ2xpY2tBbmREcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBCYXJCdXR0b25zID0gdGhpcy5zZXR1cEJhckJ1dHRvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cEV4cGFuZGVyQXJlYXMgPSB0aGlzLnNldHVwRXhwYW5kZXJBcmVhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlSW5CYXIgPSB0aGlzLm9uTW91c2VNb3ZlSW5CYXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bkluQmFyID0gdGhpcy5vbk1vdXNlRG93bkluQmFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwQWZ0ZXJEcmFnID0gdGhpcy5vbk1vdXNlVXBBZnRlckRyYWcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TaGFkZSA9IHRoaXMub25TaGFkZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRXhwYW5kID0gdGhpcy5vbkV4cGFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uR3JpcERvd24gPSB0aGlzLm9uR3JpcERvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkdyaXBVcCA9IHRoaXMub25HcmlwVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkdyaXBNb3ZlID0gdGhpcy5vbkdyaXBNb3ZlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0dXAgcHJvcCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3RpdGxlJywgdGhpcy5zZXRUaXRsZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgdGhpcy5zZXR1cENsaWNrQW5kRHJhZygpO1xuICAgICAgICB0aGlzLnNldHVwQmFyQnV0dG9ucygpO1xuICAgICAgICB0aGlzLnNldHVwRXhwYW5kZXJBcmVhcygpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5zZXRUaXRsZShcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd0aXRsZSdcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXR1cENsaWNrQW5kRHJhZygpe1xuICAgICAgICBsZXQgYmFyID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3Qtd2luZG93LWJhcicpO1xuICAgICAgICBiYXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkluQmFyKTtcbiAgICB9XG5cbiAgICBzZXR1cEJhckJ1dHRvbnMoKXtcbiAgICAgICAgbGV0IGNsb3NlQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuY2xvc2UtYnV0dG9uJyk7XG4gICAgICAgIGxldCBzaGFkZUJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnNoYWRlLWJ1dHRvbicpO1xuICAgICAgICBsZXQgZXhwYW5kQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZXhwYW5kLWJ1dHRvbicpO1xuXG4gICAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsb3NlKTtcbiAgICAgICAgc2hhZGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uU2hhZGUpO1xuICAgICAgICBleHBhbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRXhwYW5kKTtcbiAgICB9XG5cbiAgICBzZXR1cEV4cGFuZGVyQXJlYXMoKXtcbiAgICAgICAgbGV0IGxvd2VyUmlnaHQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5yaWdodC1ncmlwcGVyJyk7XG4gICAgICAgIGxvd2VyUmlnaHQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbkdyaXBEb3duKTtcbiAgICB9XG5cbiAgICBvbkV4cGFuZChldmVudCl7XG4gICAgICAgIGlmKHRoaXMuaXNFeHBhbmRlZCl7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gdGhpcy5leHBhbmRDYWNoZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5leHBhbmRDYWNoZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRvcCA9IHRoaXMuZXhwYW5kQ2FjaGUudG9wO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gdGhpcy5leHBhbmRDYWNoZS5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZENhY2hlID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnN0eWxlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLnN0eWxlLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnN0eWxlLmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTZXQgbmV3IHZhbHVlcyBiYXNlZCBvbiB3aW5kb3cgc2l6ZVxuICAgICAgICAgICAgdGhpcy5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSBcIjEwMHZ3XCI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmhlaWdodCA9IFwiMTAwdmhcIjtcbiAgICAgICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNoYWRlKGV2ZW50KXtcbiAgICAgICAgbGV0IHBhbmUgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zdC13aW5kb3ctcGFuZScpO1xuICAgICAgICBpZih0aGlzLmlzU2hhZGVkKXtcbiAgICAgICAgICAgIHBhbmUuY2xhc3NMaXN0LnJlbW92ZSgnc2hhZGVkJyk7XG4gICAgICAgICAgICB0aGlzLmlzU2hhZGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ3NoYWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5pc1NoYWRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsb3NlKGV2ZW50KXtcbiAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnd2luZG93Q2xvc2UnLFxuICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZShtc2csIHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIG9uTW91c2VEb3duSW5CYXIoZXZlbnQpe1xuICAgICAgICB0aGlzLm1vdXNlRG93bkluQmFyID0gdHJ1ZTtcbiAgICAgICAgbGV0IGJhciA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUluQmFyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwQWZ0ZXJEcmFnKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlVXBBZnRlckRyYWcoZXZlbnQpe1xuICAgICAgICB0aGlzLm1vdXNlRG93bkluQmFyID0gZmFsc2U7XG4gICAgICAgIGxldCBiYXIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcEFmdGVyRHJhZyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVJbkJhcik7XG4gICAgfVxuXG4gICAgb25Nb3VzZU1vdmVJbkJhcihldmVudCl7XG4gICAgICAgIGxldCBjdXJyZW50VG9wID0gcGFyc2VJbnQodGhpcy5zdHlsZS50b3ApO1xuICAgICAgICBsZXQgY3VycmVudExlZnQgPSBwYXJzZUludCh0aGlzLnN0eWxlLmxlZnQpO1xuICAgICAgICAvLyBsZXQgbmV3VG9wID0gYCR7Y3VycmVudFRvcCArIGV2ZW50Lm1vdmVtZW50WX1weGA7XG4gICAgICAgIC8vIGxldCBuZXdMZWZ0ID0gYCR7Y3VycmVudExlZnQgKyBldmVudC5tb3ZlbWVudFh9cHhgO1xuICAgICAgICBsZXQgbmV3VG9wID0gY3VycmVudFRvcCArIGV2ZW50Lm1vdmVtZW50WTtcbiAgICAgICAgbGV0IG5ld0xlZnQgPSBjdXJyZW50TGVmdCArIGV2ZW50Lm1vdmVtZW50WDtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwidG9wXCIsIG5ld1RvcCk7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImxlZnRcIiwgbmV3TGVmdCk7XG4gICAgfVxuXG4gICAgb25HcmlwVXAoZXZlbnQpe1xuICAgICAgICB0aGlzLmlzR3JpcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkdyaXBNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25HcmlwVXApO1xuICAgIH1cblxuICAgIG9uR3JpcERvd24oZXZlbnQpe1xuICAgICAgICB0aGlzLmlzR3JpcHBpbmcgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uR3JpcE1vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkdyaXBVcCk7XG4gICAgfVxuXG4gICAgb25HcmlwTW92ZShldmVudCl7XG4gICAgICAgIGlmKHRoaXMuaXNHcmlwcGluZyl7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBjdXJyZW50IHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgICAgICAvLyBhbmQgc2V0IHRoZSBwcm9wZXJ0eSB0byB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgbGV0IGJveCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBsZXQgbmV3V2lkdGggPSBNYXRoLmZsb29yKGJveC53aWR0aCkgKyBldmVudC5tb3ZlbWVudFg7XG4gICAgICAgICAgICBpZihuZXdXaWR0aCl7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwid2lkdGhcIiwgbmV3V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5ld0hlaWdodCA9IE1hdGguZmxvb3IoYm94LmhlaWdodCkgKyBldmVudC5tb3ZlbWVudFk7XG4gICAgICAgICAgICBpZihuZXdIZWlnaHQpe1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImhlaWdodFwiLCBuZXdIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGl0bGUoYVN0cmluZyl7XG4gICAgICAgIGxldCB0aXRsZUFyZWEgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnLnN0LXdpbmRvdy10aXRsZSA+IHNwYW4nXG4gICAgICAgICk7XG4gICAgICAgIHRpdGxlQXJlYS5pbm5lclRleHQgPSBhU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHN1YmNsYXNzIG1ldGhvZHNcbiAgICBuZXdTdWJwYXJ0VmlldyhuZXdWaWV3KXtcbiAgICAgICAgLy8gc2xvdCB0aGUgbmV3IHZpZXcgaW50byB0aGUgd2luZG93IHBhbmVcbiAgICAgICAgbGV0IHBhbmUgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zdC13aW5kb3ctcGFuZScpO1xuICAgICAgICBwYW5lLmFwcGVuZChuZXdWaWV3KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdWaWV3KTtcbiAgICB9XG5cblxufTtcblxuZXhwb3J0IHtcbiAgICBXaW5kb3dWaWV3LFxuICAgIFdpbmRvd1ZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogV29ybGRWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBXZWJjb21wb25lbnQgKGN1c3RvbSBlbGVtZW50KSB0aGF0IHJlcHJlc2VudHNcbiAqIGEgdmlldyBvZiBhIFdvcmxkU3RhY2sgbW9kZWwuXG4gKiBNeSBlbGVtZW50IGNoaWxkcmVuIHNob3VsZCBjb250YWluIGEgc2luZ2xlIFN0YWNrVmlldyByZXByZXNlbnRpbmdcbiAqIHRoZSBjdXJyZW50IGRpc3BsYXllZCBzdGFjayAodGhpcyBjb21lcyBmcm9tIHRoZSBtb2RlbCkuXG4gKiBJIGFtIHRoZSByb290LWxldmVsIGVsZW1lbnQgZm9yIHRoZSBTaW1wbGVUYWxrIHN5c3RlbSBpbiBhIHdlYlxuICogcGFnZS4gVGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIG9mIG1lIG9uIGFueSBnaXZlbiBIVE1MIHBhZ2UuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgPHNsb3Q+PC9zbG90PmA7XG5cbmNsYXNzIFdvcmxkVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldCB1cCB0ZW1wbGF0aW5nIGFuZCBzaGFkb3cgZG9tXG4gICAgICAgIC8vIFRPRE86IFB1dCB0aGUgdGVtcGxhdGUgZGVmaW5pdGlvbiBpbiB0aGlzXG4gICAgICAgIC8vIG1vZHVsZSBhcyBmb3JtYXR0ZWQgdGV4dFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUaGUgd29ybGQgbmV2ZXIgd2FudHMgYSBoYWxvXG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRTdGFjayA9IHRoaXMudXBkYXRlQ3VycmVudFN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZU1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMgPSB0aGlzLnNldHVwUHJvcEhhbmRsZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldHVwIHByb3AgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy51cGRhdGVDdXJyZW50U3RhY2spO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gRG8gYW4gaW5pdGlhbCB1cGRhdGUgdG8gZGlzcGxheVxuICAgICAgICAvLyB0aGUgbW9kZWwncyBjdXJyZW50IHN0YWNrXG4gICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFN0YWNrKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQ3VycmVudFN0YWNrKCl7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBwcm9wIGlzIHRoZSBzdGFjayBJRFxuICAgICAgICAvLyBvZiB0aGUgY2hpbGQgU3RhY2sgdGhhdCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgb25lLiBXZSByZW1vdmUgdGhlIGN1cnJlbnQtc3RhY2sgY2xhc3MgZnJvbVxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgY3VycmVudCBzdGFjayBhbmQgYWRkIGl0IHRvIHRoZSBuZXcgb25lLlxuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuY3VycmVudC1zdGFjaycpO1xuICAgICAgICBsZXQgbmV4dEN1cnJlbnRJZCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IG5leHRDdXJyZW50U3RhY2sgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYDpzY29wZSA+IHN0LXN0YWNrW3BhcnQtaWQ9XCIke25leHRDdXJyZW50SWR9XCJdYCk7XG4gICAgICAgIGlmKG5leHRDdXJyZW50U3RhY2spe1xuICAgICAgICAgICAgbmV4dEN1cnJlbnRTdGFjay5jbGFzc0xpc3QuYWRkKCdjdXJyZW50LXN0YWNrJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gcHJldmVudCB0aGUgc2V0dGluZyBvZiB0aGUgc2FtZSBpZCBhcyB0aGUgY3VycmVudCBzdGFjayBtYWtlIHN1cmVcbiAgICAgICAgLy8gbmV4dCBhbmQgY3VycmVudCBhcmUgbm90IHRoZSBzYW1lXG4gICAgICAgIGlmKGN1cnJlbnRTdGFjayAmJiBjdXJyZW50U3RhY2sgIT0gbmV4dEN1cnJlbnRTdGFjayl7XG4gICAgICAgICAgICBjdXJyZW50U3RhY2suY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudC1zdGFjaycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlS2V5RG93bihldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmFsdEtleSAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmNvZGUgPT0gXCJTcGFjZVwiKXtcbiAgICAgICAgICAgIGxldCBuYXZpZ2F0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1uYXZpZ2F0b3InKTtcbiAgICAgICAgICAgIG5hdmlnYXRvci50b2dnbGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHN1YmNsYXNzIG1ldGhvZHNcbiAgICBuZXdTdWJwYXJ0VmlldyhuZXdWaWV3KXtcbiAgICAgICAgaWYodGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAmJiBuZXdWaWV3Lm5hbWUgPT0gXCJTdGFja1ZpZXdcIil7XG4gICAgICAgICAgICBsZXQgbGFzdFN0YWNrTm9kZTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGNoaWxkLm5hbWUgPT0gXCJTdGFja1ZpZXdcIil7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja05vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKGxhc3RTdGFja05vZGUpe1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBhZnRlciB0aGUgbGFzdCBzdGFja1xuICAgICAgICAgICAgICAgIGxhc3RTdGFja05vZGUuYWZ0ZXIobmV3Vmlldyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXJlIGFyZSBubyBzdGFja3NcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmVmb3JlIGFsbCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS5pbnNlcnRCZWZvcmUobmV3Vmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld1ZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5leHBvcnQge1xuICAgIFdvcmxkVmlldyxcbiAgICBXb3JsZFZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8vIFBSRUFNQkxFXG5pbXBvcnQgQ29udGV4dE1lbnVJdGVtIGZyb20gJy4vQ29udGV4dE1lbnVJdGVtLmpzJztcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3QtY29udGV4dC1tZW51LWl0ZW0nLCBDb250ZXh0TWVudUl0ZW0pO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBib3gtc2hhZG93OiAxcHggMnB4IDEwcHggcmdiYSg1MCwgNTAsIDUwLCAwLjcpO1xuICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDhweDtcbiAgICAgICAgbWluLXdpZHRoOiAyMDBweDtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgIH1cblxuICAgIDpob3N0LWNvbnRleHQobGkpIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAxMDAlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICB9XG5cbiAgICA6aG9zdC1jb250ZXh0KGxpKTpob3ZlciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuXG4gICAgaGVhZGVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxNTAsIDE1MCwgMTUwLCAwLjUpO1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAxNnB4O1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7XG4gICAgICAgIHBhZGRpbmctdG9wOiA4cHg7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgfVxuXG4gICAgaGVhZGVyID4gaDQge1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBtYXJnaW46MDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgZm9udC1zaXplOiAwLjhyZW07XG4gICAgfVxuXG48L3N0eWxlPlxuPGhlYWRlcj5cbiAgICA8aDQ+PC9oND5cbjwvaGVhZGVyPlxuPHVsIGlkPVwibGlzdC1pdGVtc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbjwvdWw+XG5gO1xuXG5jbGFzcyBDb250ZXh0TWVudSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuYWRkSGFsb1RvZ2dsZUl0ZW0gPSB0aGlzLmFkZEhhbG9Ub2dnbGVJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkQ29weUFuZFBhc3RlSXRlbXMgPSB0aGlzLmFkZENvcHlBbmRQYXN0ZUl0ZW1zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkT3BlbkVkaXRvckl0ZW0gPSB0aGlzLmFkZE9wZW5FZGl0b3JJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkU2NyaXB0RWRpdEl0ZW0gPSB0aGlzLmFkZFNjcmlwdEVkaXRJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkTW92ZW1lbnRJdGVtcyA9IHRoaXMuYWRkTW92ZW1lbnRJdGVtcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFBhcnRTdWJtZW51ID0gdGhpcy5hZGRQYXJ0U3VibWVudS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZExpc3RJdGVtID0gdGhpcy5hZGRMaXN0SXRlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFNwYWNlciA9IHRoaXMuYWRkU3BhY2VyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGlkZUhlYWRlciA9IHRoaXMuaGlkZUhlYWRlci5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIGxldCBoZWFkZXJFbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignaGVhZGVyID4gaDQnKTtcbiAgICAgICAgbGV0IGhlYWRlclRleHQgPSBgJHt0aGlzLm1vZGVsLnR5cGVbMF0udG9VcHBlckNhc2UoKX0ke3RoaXMubW9kZWwudHlwZS5zbGljZSgxKX1gO1xuICAgICAgICBoZWFkZXJUZXh0ID0gYGEgJHtoZWFkZXJUZXh0fWA7XG4gICAgICAgIGhlYWRlckVsLnRleHRDb250ZW50ID0gaGVhZGVyVGV4dDtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIGRlZmF1bHQgbWVudSBpdGVtc1xuICAgICAgICB0aGlzLmFkZEhhbG9Ub2dnbGVJdGVtKCk7XG4gICAgICAgIHRoaXMuYWRkQ29weUFuZFBhc3RlSXRlbXMoKTtcbiAgICAgICAgdGhpcy5hZGRPcGVuRWRpdG9ySXRlbSgpO1xuICAgICAgICB0aGlzLmFkZFBhcnRTdWJtZW51KCk7XG4gICAgICAgIHRoaXMuYWRkU2NyaXB0RWRpdEl0ZW0oKTtcbiAgICAgICAgdGhpcy5hZGRNb3ZlbWVudEl0ZW1zKCk7XG5cbiAgICAgICAgLy8gQWRkIFZpZXctc3BlY2lmaWMgaXRlbXNcbiAgICAgICAgbGV0IHZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7dGhpcy5tb2RlbC5pZH1cIl1gKTtcbiAgICAgICAgdmlldy5hZGRDb250ZXh0TWVudUl0ZW1zKHRoaXMpO1xuICAgIH1cblxuICAgIGFkZExpc3RJdGVtKGxhYmVsLCBjYWxsYmFjaywgc3VibWVudT1udWxsKXtcbiAgICAgICAgbGV0IGl0ZW1FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWNvbnRleHQtbWVudS1pdGVtJyk7XG4gICAgICAgIGl0ZW1FbC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICBpdGVtRWwuY2xhc3NMaXN0LmFkZCgnY29udGV4dC1tZW51LWl0ZW0nKTtcbiAgICAgICAgaXRlbUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FsbGJhY2spO1xuICAgICAgICBpZihzdWJtZW51KXsgICAgICAgICAgICAgXG4gICAgICAgICAgICBzdWJtZW51LmNsYXNzTGlzdC5hZGQoJ2NvbnRleHQtc3VibWVudScsICdzdWJtZW51LWhpZGRlbicpO1xuICAgICAgICAgICAgc3VibWVudS5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnc3VibWVudScpO1xuICAgICAgICAgICAgaXRlbUVsLmFwcGVuZChzdWJtZW51KTtcbiAgICAgICAgICAgIGl0ZW1FbC5zaG93Q2FyZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZChpdGVtRWwpO1xuICAgIH1cblxuICAgIGFkZEhhbG9Ub2dnbGVJdGVtKCl7XG4gICAgICAgIGxldCB0YXJnZXQgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZCh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgLy8gZG9uJ3QgYWRkIGhhbG8gb3B0aW9uIHRvIGNhcmRzLCBzaW5jZSB5b3UgY2FuJ3Qgc2VlIHRob3NlXG4gICAgICAgIGlmKHRhcmdldC5uYW1lICE9IFwiQ2FyZFZpZXdcIil7XG4gICAgICAgICAgICBpZih0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0aW5nJykpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICdDbG9zZSBIYWxvJyxcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICAnT3BlbiBIYWxvJyxcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQub3BlbkhhbG8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDb3B5QW5kUGFzdGVJdGVtcygpe1xuICAgICAgICAvLyBBZGQgY29weSBpdGVtXG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnQ29weScsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5jb3B5UGFydCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgcGFzdGUgYnV0IG9ubHkgaWY6XG4gICAgICAgIC8vIDEuIFRoZXJlIGlzIGNsaXBib2FyZCBjb250ZW50cztcbiAgICAgICAgLy8gMi4gVGhlIHBhcnQgdHlwZSBpbiB0aGUgY2xpcGJvYXJkIGlzXG4gICAgICAgIC8vICAgIG9uZSB0aGF0IGlzIGFjY2VwdGVkIGJ5IHRoaXMgbW9kZWwncyBwYXJ0XG4gICAgICAgIGlmKHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLmNvbnRlbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBsZXQgcGFydFR5cGUgPSB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5jb250ZW50c1swXS5wYXJ0VHlwZTtcbiAgICAgICAgICAgIGlmKHRoaXMubW9kZWwuYWNjZXB0c1N1YnBhcnQocGFydFR5cGUpKXtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBgUGFzdGUgKGEgJHtwYXJ0VHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7cGFydFR5cGUuc2xpY2UoMSl9KWA7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShsYWJlbCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLnBhc3RlQ29udGVudHNJbnRvKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkT3BlbkVkaXRvckl0ZW0oKXtcbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdPcGVuIEVkaXRvcicsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU3lzdGVtLm9wZW5FZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGFkZFNjcmlwdEVkaXRJdGVtKCl7XG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnRWRpdCBTY3JpcHQnLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMubW9kZWwuaWRdXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdFZGl0IFdvcmxkIFNjcmlwdCcsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbJ3dvcmxkJ11cbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgd2luZG93QW5jZXN0b3IgPSB0aGlzLm1vZGVsLmZpbmRBbmNlc3Rvck9mVHlwZSgnd2luZG93Jyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSAhPSAnd2luZG93JyAmJiB3aW5kb3dBbmNlc3RvciAhPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdFZGl0IE93bmluZyBXaW5kb3cgU2NyaXB0JyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3dpbmRvd0FuY2VzdG9yLmlkXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgY2FyZEFuY2VzdG9yID0gdGhpcy5tb2RlbC5maW5kQW5jZXN0b3JPZlR5cGUoJ2NhcmQnKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlICE9ICdjYXJkJyAmJiBjYXJkQW5jZXN0b3Ipe1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnRWRpdCBPd25pbmcgQ2FyZCBTY3JpcHQnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY2FyZEFuY2VzdG9yLmlkXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YWNrQW5jZXN0b3IgPSB0aGlzLm1vZGVsLmZpbmRBbmNlc3Rvck9mVHlwZSgnc3RhY2snKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlICE9ICdzdGFjaycgJiYgc3RhY2tBbmNlc3Rvcil7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdFZGl0IE93bmluZyBTdGFjayBTY3JpcHQnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbc3RhY2tBbmNlc3Rvci5pZF1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFBhcnRTdWJtZW51KCl7XG4gICAgICAgIC8vIEZpcnN0LCB3ZSBuZWVkIHRvIGdldCBhIGxpc3Qgb2YgbmFtZXNcbiAgICAgICAgLy8gb2Ygc3VicGFydHMgdGhhdCB0aGlzIG1vZGVsIGFjY2VwdHNcbiAgICAgICAgbGV0IHN1YnBhcnROYW1lcztcbiAgICAgICAgaWYodGhpcy5tb2RlbC5hY2NlcHRlZFN1YnBhcnRUeXBlc1swXSA9PSBcIipcIil7XG4gICAgICAgICAgICAvLyBUaGlzIG1vZGVsIGFjY2VwdHMgYWxsIHN1YnBhcnQgdHlwZXMuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCB0aGUgbmFtZXMgZm9yIHRoZXNlIHN1YnBhcnRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggYXJlIHJlZ2lzdGVyZWQgYXQgdGhlIFN5c3RlbSBsZXZlbC5cbiAgICAgICAgICAgIHN1YnBhcnROYW1lcyA9IE9iamVjdC5rZXlzKHdpbmRvdy5TeXN0ZW0uYXZhaWxhYmxlVmlld3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VicGFydE5hbWVzID0gdGhpcy5tb2RlbC5hY2NlcHRlZFN1YnBhcnRUeXBlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBzdWJwYXJ0IG5hbWVzIChtZWFuaW5nXG4gICAgICAgIC8vIHRoZSBnaXZlbiBwYXJ0LCBsaWtlIGEgYnV0dG9uLCBkb2Vzbid0XG4gICAgICAgIC8vIGFjY2VwdCBhbnkgc3VicGFydHMpLCB0aGVuIHdlIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmKHN1YnBhcnROYW1lcy5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgd2UgY29uc3RydWN0IHRoZSBzdWJtZW51IGZvciBhZGRpbmcgcGFydHNcbiAgICAgICAgLy8gb2YgdGhlIGdpdmVuIHR5cGVcbiAgICAgICAgbGV0IHN1Ym1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1jb250ZXh0LW1lbnUnKTtcbiAgICAgICAgc3VibWVudS5oaWRlSGVhZGVyKCk7XG4gICAgICAgIHN1YnBhcnROYW1lcy5mb3JFYWNoKHN1YnBhcnROYW1lID0+IHtcbiAgICAgICAgICAgIHN1Ym1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgc3VicGFydE5hbWVbMF0udG9VcHBlckNhc2UoKSArIHN1YnBhcnROYW1lLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ25ld01vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJwYXJ0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vdyBhZGQgdGhlIGxpc3QgaXRlbSB0aGF0IHdpbGwgXCJyZXZlYWxcIlxuICAgICAgICAvLyB0aGUgc3VibWVudVxuICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgJ0FkZCBhIG5ldyBwYXJ0JyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJtZW51XG4gICAgICAgICk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIGFkZE1vdmVtZW50SXRlbXMoKXtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tb2RlbC5fb3duZXIuc3VicGFydHMuaW5kZXhPZih0aGlzLm1vZGVsKTtcbiAgICAgICAgbGV0IG93bmVyTGVuZ3RoID0gdGhpcy5tb2RlbC5fb3duZXIuc3VicGFydHMubGVuZ3RoO1xuICAgICAgICBpZihvd25lckxlbmd0aCAmJiBpbmRleCA8IG93bmVyTGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG1vdmVEb3duIG9wdGlvblxuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnTW92ZSBEb3duJyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmVEb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdNb3ZlIHRvIExhc3QnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZVRvTGFzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmKGluZGV4ID4gMCl7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG1vdmVVcCBvcHRpb25cbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ01vdmUgVXAnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZVVwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdNb3ZlIHRvIEZpcnN0JyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmVUb0ZpcnN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRTcGFjZXIoKXtcbiAgICAgICAgbGV0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2NvbnRleHQtbWVudS1zcGFjZXInKTtcbiAgICAgICAgdGhpcy5hcHBlbmQoaXRlbSk7XG4gICAgfVxuXG4gICAgaGlkZUhlYWRlcigpe1xuICAgICAgICBsZXQgaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlcicpO1xuICAgICAgICBoZWFkZXJFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBDb250ZXh0TWVudSxcbiAgICBDb250ZXh0TWVudSBhcyBkZWZhdWx0XG59O1xuIiwiY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICAgIC5zdWJtZW51LWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDEwMCU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgIH1cblxuICAgIDpob3N0KDpob3ZlcikgLnN1Ym1lbnUtYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuXG4gICAgLmxhYmVsLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cblxuICAgIC5jYXJldC5oaWRkZW4ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAuY2FyZXQge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJsYWJlbC1hcmVhXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPjxzbG90Pjwvc2xvdD48L3NwYW4+XG4gICAgPGRpdiBjbGFzcz1cImNhcmV0IGhpZGRlblwiPuKGkjwvZGl2PlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwic3VibWVudS1hcmVhXCI+XG4gICAgPHNsb3QgbmFtZT1cInN1Ym1lbnVcIj48L3Nsb3Q+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIENvbnRleHRNZW51SXRlbSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHNoYWRvdyBkb20gYW5kIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2hvd0NhcmV0ID0gdGhpcy5zaG93Q2FyZXQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzaG93Q2FyZXQoKXtcbiAgICAgICAgbGV0IGNhcmV0RWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5jYXJldCcpO1xuICAgICAgICBjYXJldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICBcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIENvbnRleHRNZW51SXRlbSxcbiAgICBDb250ZXh0TWVudUl0ZW0gYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQ29sb3JQaWNrZXJUb29sXG4gKiBJIHByb3ZpZGUgYSBjb2xvciBjaG9vcnNlciBjYXBhYmlsaXR5XG4gKiBmb3IgdGhlIHNoYWRvdyBjYW52YXMgb2YgbXkgcGFyZW50IGVsZW1lbnQuXG4gKiBCcnVzaGVzIG9uIG15IHBhcmVudCBEcmF3aW5nIGNhbnZhcyB3aWxsIHVzZVxuICogd2hhdGV2ZXIgY29sb3IgSSBoYXZlIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAqIEkgYW0gZXhwbGljaXRseSBkZXNpZ25lZCBmb3IgdXNlIHdpdGhcbiAqIERyYXdpbmdWaWV3Ki9cbmltcG9ydCB7Q29sb3JXaGVlbFdpZGdldH0gZnJvbSAnLi9Db2xvcldoZWVsV2lkZ2V0LmpzJztcbmNvbnN0IGNvbG9yUGlja2VyU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNvbG9yLXN3YXRjaFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTkgM2gtNGEyIDIgMCAwIDAgLTIgMnYxMmE0IDQgMCAwIDAgOCAwdi0xMmEyIDIgMCAwIDAgLTIgLTJcIiAvPlxuICA8cGF0aCBkPVwiTTEzIDcuMzVsLTIgLTJhMiAyIDAgMCAwIC0yLjgyOCAwbC0yLjgyOCAyLjgyOGEyIDIgMCAwIDAgMCAyLjgyOGw5IDlcIiAvPlxuICA8cGF0aCBkPVwiTTcuMyAxM2gtMi4zYTIgMiAwIDAgMCAtMiAydjRhMiAyIDAgMCAwIDIgMmgxMlwiIC8+XG4gIDxsaW5lIHgxPVwiMTdcIiB5MT1cIjE3XCIgeDI9XCIxN1wiIHkyPVwiMTcuMDFcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjb2xvclBpY2tlclRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuICAgIH1cblxuICAgICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIC0tYWN0aXZlLWNvbG9yOiBibGFjaztcbiAgICAgICAgLS1pbmFjdGl2ZS1jb2xvcjogcmdiKDE3MCwgMTcwLCAxNzApO1xuICAgICAgICAtLWhvdmVyLWNvbG9yOiByZ2IoMTQwLCAxNDAsIDE0MCk7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICB9XG5cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiAjdG9vbC1idXR0b24ge1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICBjb2xvci13aGVlbCB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG5cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiBjb2xvci13aGVlbCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJ0b29sLWJ1dHRvblwiPlxuJHtjb2xvclBpY2tlclNWR31cbjwvZGl2PlxuPGNvbG9yLXdoZWVsPjwvY29sb3Itd2hlZWw+XG5gO1xuXG5cbmNsYXNzIENvbG9yUGlja2VyVG9vbCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldCB1cCBzaGFkb3cgZG9tLiBUaGlzIHRvb2wgd2lsbFxuICAgICAgICAvLyBkaXNwbGF5IGl0c2VsZiBhcyBhIGJ1dHRvbiB0aGF0IGNhbiBiZVxuICAgICAgICAvLyB0b2dnbGVkIHdpdGhpbiBpdHMgcGFyZW50IERyYXdpbmdWaWV3LlxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBjb2xvclBpY2tlclRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZHJhd2luZyBjb250ZXh0IGlzIG51bGwuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBzZXQgaWYgYW5kIHdoZW4gdGhpcyB0b29sXG4gICAgICAgIC8vIGlzIGNvbm5lY3RlZCB0byBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgIC8vIHRoYXQgaGFzIGEgY29udGV4dFxuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUgPSB0aGlzLnRvZ2dsZUFjdGl2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ29sb3JTZWxlY3RlZCA9IHRoaXMub25Db2xvclNlbGVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2VkID0gdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMgPSB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLmhhc0F0dHJpYnV0ZSgnY3VycmVudC1jb2xvcicpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY3VycmVudC1jb2xvcicsICdyZ2JhKDAsIDAsIDAsIDApJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgSSBhbSB0aGUgb25seSB0b29sIGluIG15IHBhcmVudCxcbiAgICAgICAgICAgICAgICAvLyBzZXQgbXlzZWxmIHRvIGFjdGl2ZVxuICAgICAgICAgICAgICAgIGxldCBzaWJsaW5nVG9vbHMgPSB0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYoc2libGluZ1Rvb2xzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5idXR0b24gPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2wtYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JXaGVlbCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjb2xvci13aGVlbCcpO1xuICAgICAgICAgICAgdGhpcy5jb2xvcldoZWVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbG9yLXNlbGVjdGVkJywgdGhpcy5vbkNvbG9yU2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5jb2xvcldoZWVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zcGFyZW5jeS1jaGFuZ2VkJywgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB0aGlzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgdGhpcy5jb2xvcldoZWVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbG9yLXNlbGVjdGVkJywgdGhpcy5vbkNvbG9yU2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmNvbG9yV2hlZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNwYXJlbmN5LWNoYW5nZWQnLCB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlZCk7XG4gICAgfVxuXG4gICAgc3RhcnQoeCwgeSl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBpbiB0aGlzIHRvb2xcbiAgICB9XG5cbiAgICBlbmQoeCwgeSl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBpbiB0aGlzIHRvb2xcbiAgICB9XG5cbiAgICBvbk1vdmUoeCwgeSl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBpbiB0aGlzIHRvb2xcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGluIHRoaXMgdG9vbFxuICAgIH1cblxuICAgIG9uQ29sb3JTZWxlY3RlZChldmVudCl7XG4gICAgICAgIGxldCBjb2xvckluZm8gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGxldCBjb2xvclN0ciA9IGByZ2JhKCR7Y29sb3JJbmZvLnJ9LCAke2NvbG9ySW5mby5nfSwgJHtjb2xvckluZm8uYn0sICR7Y29sb3JJbmZvLmFscGhhfSlgO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yU3RyO1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvclN0cjtcbiAgICB9XG5cbiAgICBvblRyYW5zcGFyZW5jeUNoYW5nZWQoZXZlbnQpe1xuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogXCJzZXRQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgYXJnczogW1widHJhbnNwYXJlbmN5XCIsIGV2ZW50LmRldGFpbF1cbiAgICAgICAgfSwgdGhpcy5wYXJlbnRFbGVtZW50Lm1vZGVsKTtcbiAgICB9XG5cbiAgICB0b2dnbGVBY3RpdmUoZXZlbnQpe1xuICAgICAgICBsZXQgaXNBY3RpdmUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlJyk7XG4gICAgICAgIGlmKGlzQWN0aXZlID09IFwidHJ1ZVwiKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBmaW5kIGFueSBvdGhlciB0b29scyBpbiBteSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgYW5kIGRlYWN0aXZhdGUgdGhlbS5cbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIHRvb2wgdG8gYmUgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjb2xvci1waWNrZXItdG9vbCcsIENvbG9yUGlja2VyVG9vbCk7XG5cbmV4cG9ydCB7XG4gICAgQ29sb3JQaWNrZXJUb29sLFxuICAgIENvbG9yUGlja2VyVG9vbCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBDb2xvcldoZWVsV2lkZ2V0XG4gKiBJIGFtIGEgKmdlbmVyaWMgdXNlKiB3ZWJjb21wb25lbnQgcmVwcmVzZW50aW5nXG4gKiBhIENvbG9yV2hlZWwgc2VsZWN0aW9uIHdpZGdldC5cbiAqIEkgb3BlcmF0ZSBhcyBhIGZsb2F0aW5nIG1vZGFsIHdpbmRvdyB3aXRoIGFcbiAqIGNpcmN1bGFyIGNvbG9yIHdoZWVsIGFzIHdlbGwgYXMgYSBsaXN0IG9mXG4gKiByZWNlbnRseSBzZWxlY3RlZCBjb2xvcnMuXG4gKiBJIGFtIGRlc2lnbmVkIHRvIGJlIHVzZWQgYnkgYW55IHBhcmVudCBlbGVtZW50LlxuICogSSB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgY2FsbGVkICdjb2xvci1jaGFuZ2UnIHdoZW5ldmVyXG4gKiBhIG5ldyBjb2xvciBoYXMgYmVlbiBzZWxlY3RlZCBmcm9tIHdpdGhpbiBtZVxuICovXG5cbmNvbnN0IGNvbG9yV2hlZWxUZW1wbGF0ZSA9IGBcbjxzdHlsZT5cbiAgOmhvc3Qge1xuICAgIGRpc3BsYXk6IGluaXRpYWwgIWltcG9ydGFudDtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICB9XG5cbiAgI3BhbGV0dGUtYmFyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgIGhlaWdodDogMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwMCwgMjAwLCAyMDApO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cblxuICAjcGFsZXR0ZS10aXRsZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG5cbiAgI2Nsb3NlLWJ1dHRvbiB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgd2lkdGg6IDEycHg7XG4gICAgaGVpZ2h0OiAxMnB4O1xuICAgIG1hcmdpbi1sZWZ0OiA4cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgfVxuXG4gICNwYWxldHRlLWNvbnRlbnQge1xuICAgIGZsZXg6IDE7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG4gICNob3Zlci1jb2xvciB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICB9XG4gICNvcHRpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMjVweDtcbiAgICBtYXJnaW4tdG9wOiA1cHg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIH1cblxuICAjb3B0aW9ucyA+IGxhYmVse1xuICAgIGZvbnQtc2l6ZTogLjhyZW07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgI3JlY2VudC1jb2xvcnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgIHBhZGRpbmctbGVmdDogMTVweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiAxNXB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgfVxuICAucmVjZW50LWNvbG9yLWl0ZW0ge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAyNnB4O1xuICAgIGhlaWdodDogMjZweDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjAwLCAyMDAsIDIwMCwgMC44KTtcbiAgfVxuXG4gIC5yZWNlbnQtY29sb3ItaXRlbS5zZWxlY3RlZCB7XG4gICAgYm9yZGVyOiAycHggc29saWQgYmxhY2s7XG4gIH1cblxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJwYWxldHRlLXdyYXBwZXJcIj5cbiAgPGRpdiBpZD1cInBhbGV0dGUtYmFyXCI+PGRpdiBpZD1cImNsb3NlLWJ1dHRvblwiPng8L2Rpdj48c3BhbiBpZD1cInBhbGV0dGUtdGl0bGVcIj48L3NwYW4+PC9kaXY+XG4gIDxkaXYgaWQ9XCJwYWxldHRlLWNvbnRlbnRcIj5cbiAgICA8ZGl2IGlkPVwib3B0aW9uc1wiPlxuICAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGlkPVwidHJhbnNwYXJlbmN5XCIgbmFtZT1cInRyYW5zcGFyZW5jeVwiIG1pbj1cIjBcIiBtYXg9XCIxXCIgc3RlcD1cIjAuMVwiIHZhbHVlPVwiMVwiPlxuICAgICAgPCEtLSA8bGFiZWwgZm9yPVwidHJhbnNwYXJlbmN5XCI+VHJhbnNwYXJlbmN5PC9sYWJlbD4tLT5cbiAgICA8L2Rpdj5cbiAgICA8dWwgaWQ9XCJyZWNlbnQtY29sb3JzXCI+XG4gICAgICA8bGkgY2xhc3M9XCJyZWNlbnQtY29sb3ItaXRlbSBzZWxlY3RlZFwiPjwvbGk+XG4gICAgICA8bGkgY2xhc3M9XCJyZWNlbnQtY29sb3ItaXRlbVwiPjwvbGk+XG4gICAgICA8bGkgY2xhc3M9XCJyZWNlbnQtY29sb3ItaXRlbVwiPjwvbGk+XG4gICAgPC91bD5cbiAgICA8Y2FudmFzIGlkPVwiY29sb3Itd2hlZWxcIiB3aWR0aD1cIjE1MFwiIGhlaWdodD1cIjE1MFwiPjwvY2FudmFzPlxuICAgIDxkaXYgaWQ9XCJob3Zlci1jb2xvclwiPjwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxuY2xhc3MgQ29sb3JXaGVlbFdpZGdldCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIFNldHVwIHNoYWRvdyBkb20gYW5kIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IGNvbG9yV2hlZWxUZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIGxvY2FsIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbldoZWVsTW91c2VFbnRlciA9IHRoaXMub25XaGVlbE1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldoZWVsTW91c2VMZWF2ZSA9IHRoaXMub25XaGVlbE1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldoZWVsTW91c2VNb3ZlID0gdGhpcy5vbldoZWVsTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25XaGVlbENsaWNrID0gdGhpcy5vbldoZWVsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkl0ZW1DbGljayA9IHRoaXMub25JdGVtQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkJhck1vdXNlRG93biA9IHRoaXMub25CYXJNb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkJhck1vdXNlVXAgPSB0aGlzLm9uQmFyTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQmFyTW91c2VNb3ZlID0gdGhpcy5vbkJhck1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZSA9IHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZHJhd1doZWVsID0gdGhpcy5fZHJhd1doZWVsLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuYmFyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdwYWxldHRlLWJhcicpO1xuICAgICAgICAgICAgLy8gZ2l2ZSB0aGUgd2lkZ2V0IGEgdGl0bGUgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmKHRoaXMubmFtZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdwYWxldHRlLXRpdGxlJykuaW5uZXJUZXh0ID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25XaGVlbENsaWNrKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uV2hlZWxNb3VzZUVudGVyKTtcbiAgICAgICAgICAgIHRoaXMuYmFyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25CYXJNb3VzZURvd24pO1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnLnJlY2VudC1jb2xvci1pdGVtJykpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkl0ZW1DbGljayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5U2xpZGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0cmFuc3BhcmVuY3knKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5U2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlKTtcblxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgY29sb3Igd2hlZWwgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgdGhpcy5fZHJhd1doZWVsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25XaGVlbENsaWNrKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25XaGVlbE1vdXNlRW50ZXIpO1xuICAgICAgICB0aGlzLmJhci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uQmFyTW91c2VEb3duKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnJlY2VudC1jb2xvci1pdGVtJykpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uSXRlbUNsaWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwYXJlbmN5U2xpZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZSk7XG4gICAgfVxuXG5cbiAgICBvbldoZWVsTW91c2VFbnRlcihldmVudCl7XG4gICAgICAgIC8vIENhY2hlIHRoZSBpbWFnZSBkYXRhIGZvciB0aGUgd2hvbGUgY2FudmFzXG4gICAgICAgIGxldCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9jYWNoZWRJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodFxuICAgICAgICApO1xuICAgICAgICAvLyBCaW5kIHN1YnNlcXVlbnQgZXZlbnRzXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25XaGVlbE1vdXNlTW92ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uV2hlZWxNb3VzZUxlYXZlKTtcbiAgICB9XG5cbiAgICBvbldoZWVsTW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25XaGVlbE1vdXNlTW92ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uV2hlZWxNb3VzZUxlYXZlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkSW1hZ2VEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBvbldoZWVsTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb25Gcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICBsZXQgcmdiID0gZ2V0UkdCRnJvbUltYWdlRGF0YShcbiAgICAgICAgICAgIHBvc2l0aW9uLngsXG4gICAgICAgICAgICBwb3NpdGlvbi55LFxuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRJbWFnZURhdGEuZGF0YVxuICAgICAgICApO1xuICAgICAgICBsZXQgaG92ZXJDb2xvckFyZWEgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hvdmVyLWNvbG9yJyk7XG4gICAgICAgIGxldCBuZXdTdHlsZSA9IGByZ2JhKCR7cmdiWzBdfSwgJHtyZ2JbMV19LCAke3JnYlsyXX0sICR7cmdiWzNdfSlgO1xuICAgICAgICBob3ZlckNvbG9yQXJlYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBuZXdTdHlsZTtcbiAgICB9XG5cbiAgICBvbldoZWVsQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBnZXRQb3NpdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICAgIGxldCByZ2IgPSBnZXRSR0JGcm9tSW1hZ2VEYXRhKFxuICAgICAgICAgICAgcG9zaXRpb24ueCxcbiAgICAgICAgICAgIHBvc2l0aW9uLnksXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZEltYWdlRGF0YS5kYXRhXG4gICAgICAgICk7XG4gICAgICAgIGxldCBjb2xvckluZm8gPSB7XG4gICAgICAgICAgICByOiByZ2JbMF0sXG4gICAgICAgICAgICBnOiByZ2JbMV0sXG4gICAgICAgICAgICBiOiByZ2JbMl0sXG4gICAgICAgICAgICBhbHBoYTogcmdiWzNdXG4gICAgICAgIH07XG4gICAgICAgIGxldCBuZXdFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29sb3Itc2VsZWN0ZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGNvbG9ySW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbG9yID0gY29sb3JJbmZvO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVjZW50IGNvbG9yIHN3YXRjaGVzXG4gICAgICAgIGxldCBjdXJyZW50U3dhdGNoU2VsZWN0aW9uID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5yZWNlbnQtY29sb3ItaXRlbS5zZWxlY3RlZCcpO1xuICAgICAgICBpZihjdXJyZW50U3dhdGNoU2VsZWN0aW9uKXtcbiAgICAgICAgICAgIGN1cnJlbnRTd2F0Y2hTZWxlY3Rpb24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYHJnYmEoJHtjb2xvckluZm8ucn0sICR7Y29sb3JJbmZvLmd9LCAke2NvbG9ySW5mby5ifSwgJHtjb2xvckluZm8uYWxwaGF9KWA7XG4gICAgICAgICAgICBjdXJyZW50U3dhdGNoU2VsZWN0aW9uLnNlbGVjdGVkQ29sb3IgPSBjb2xvckluZm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblRyYW5zcGFyZW5jeUNoYW5nZShldmVudCl7XG4gICAgICAgIGxldCBjb21tYW5kID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJzZWxlY3Rvci1jb21tYW5kXCIpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgdHJhbnNwYXJlbmN5IC0gdGV4dCBvciBiYWNrZ3JvdW5kXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGF0IHRoaXMgY29sb3Igd2hlZWwgaXMgc2V0dXAgdG8gdXBkYXRlXG4gICAgICAgIGxldCBwcm9wTmFtZSA9IFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIjtcbiAgICAgICAgaWYoY29tbWFuZCA9PT0gXCJ0ZXh0LWNvbG9yXCIpe1xuICAgICAgICAgICAgcHJvcE5hbWUgPSBcInRleHQtdHJhbnNwYXJlbmN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50RGV0YWlsID0ge3Byb3BOYW1lOiBwcm9wTmFtZSwgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZX07XG4gICAgICAgIGxldCBuZXdFdmVudCA9IG5ldyBDdXN0b21FdmVudCgndHJhbnNwYXJlbmN5LWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGV2ZW50RGV0YWlsLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9XG5cbiAgICBvbkl0ZW1DbGljayhldmVudCl7XG4gICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBpcyBub3QgdGhlIGN1cnJlbnRseVxuICAgICAgICAvLyBzZWxlY3RlZCByZWNlbnQgaXRlbSwgZmluZCB0aGUgb25lIHRoYXQgaXNcbiAgICAgICAgLy8gYW5kIHRvZ2dsZSB0aGUgc2VsZWN0aW9uIGNsYXNzLCB0aGVuIHRvZ2dsZVxuICAgICAgICAvLyB0aGlzIGl0ZW0ncyBzZWxlY3Rpb24gY2xhc3MuXG4gICAgICAgIGlmKCFldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKXtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZWNlbnQtY29sb3ItaXRlbS5zZWxlY3RlZCcpKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC5zZWxlY3RlZENvbG9yKXtcbiAgICAgICAgICAgIGxldCBuZXdFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29sb3Itc2VsZWN0ZWQnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiBldmVudC50YXJnZXQuc2VsZWN0ZWRDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25CYXJNb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uQmFyTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25CYXJNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvbkJhck1vdXNlVXAoZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uQmFyTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25CYXJNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvbkJhck1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIGxldCBuZXdUb3AgPSB0aGlzLm9mZnNldFRvcCArIGV2ZW50Lm1vdmVtZW50WTtcbiAgICAgICAgbGV0IG5ld0xlZnQgPSB0aGlzLm9mZnNldExlZnQgKyBldmVudC5tb3ZlbWVudFg7XG4gICAgICAgIHRoaXMuc3R5bGUudG9wID0gYCR7bmV3VG9wfXB4YDtcbiAgICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gYCR7bmV3TGVmdH1weGA7XG4gICAgfVxuXG4gICAgb25DbG9zZShldmVudCl7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgX2RyYXdXaGVlbCgpe1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgZHJhd0NpcmNsZShjdHgsIHRoaXMuY2FudmFzLndpZHRoIC8gMik7XG4gICAgfVxufTtcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY29sb3Itd2hlZWwnLCBDb2xvcldoZWVsV2lkZ2V0KTtcblxuLyoqIFV0aWxpdHkgRnVuY3Rpb25zICoqL1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BiYW50aWMvaGFuZC1jb2RpbmctYS1jb2xvci13aGVlbC13aXRoLWNhbnZhcy03ODI1NmM5ZDdkNDNcbmNvbnN0IGRyYXdDaXJjbGUgPSAoY3R4LCByYWRpdXMpID0+IHtcbiAgICBsZXQgaW1hZ2UgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDIqcmFkaXVzLCAyKnJhZGl1cyk7XG4gICAgbGV0IGRhdGEgPSBpbWFnZS5kYXRhO1xuXG4gICAgZm9yIChsZXQgeCA9IC1yYWRpdXM7IHggPCByYWRpdXM7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gLXJhZGl1czsgeSA8IHJhZGl1czsgeSsrKSB7XG5cbiAgICAgICAgICAgIGxldCBbciwgcGhpXSA9IHh5MnBvbGFyKHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAociA+IHJhZGl1cykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgYWxsICh4LHkpIGNvb3JkaW5hdGVzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNpcmNsZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVnID0gcmFkMmRlZyhwaGkpO1xuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBzdGFydGluZyBpbmRleCBvZiB0aGlzIHBpeGVsIGluIHRoZSBpbWFnZSBkYXRhIGFycmF5LlxuICAgICAgICAgICAgbGV0IHJvd0xlbmd0aCA9IDIqcmFkaXVzO1xuICAgICAgICAgICAgbGV0IGFkanVzdGVkWCA9IHggKyByYWRpdXM7IC8vIGNvbnZlcnQgeCBmcm9tIFstNTAsIDUwXSB0byBbMCwgMTAwXSAodGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbWFnZSBkYXRhIGFycmF5KVxuICAgICAgICAgICAgbGV0IGFkanVzdGVkWSA9IHkgKyByYWRpdXM7IC8vIGNvbnZlcnQgeSBmcm9tIFstNTAsIDUwXSB0byBbMCwgMTAwXSAodGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbWFnZSBkYXRhIGFycmF5KVxuICAgICAgICAgICAgbGV0IHBpeGVsV2lkdGggPSA0OyAvLyBlYWNoIHBpeGVsIHJlcXVpcmVzIDQgc2xvdHMgaW4gdGhlIGRhdGEgYXJyYXlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IChhZGp1c3RlZFggKyAoYWRqdXN0ZWRZICogcm93TGVuZ3RoKSkgKiBwaXhlbFdpZHRoO1xuXG4gICAgICAgICAgICBsZXQgaHVlID0gZGVnO1xuICAgICAgICAgICAgbGV0IHNhdHVyYXRpb24gPSByIC8gcmFkaXVzO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gMS4wO1xuXG4gICAgICAgICAgICBsZXQgW3JlZCwgZ3JlZW4sIGJsdWVdID0gaHN2MnJnYihodWUsIHNhdHVyYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGxldCBhbHBoYSA9IDI1NTtcblxuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSByZWQ7XG4gICAgICAgICAgICBkYXRhW2luZGV4KzFdID0gZ3JlZW47XG4gICAgICAgICAgICBkYXRhW2luZGV4KzJdID0gYmx1ZTtcbiAgICAgICAgICAgIGRhdGFbaW5kZXgrM10gPSBhbHBoYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xufTtcblxuLy8gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AYmFudGljL2hhbmQtY29kaW5nLWEtY29sb3Itd2hlZWwtd2l0aC1jYW52YXMtNzgyNTZjOWQ3ZDQzXG5jb25zdCB4eTJwb2xhciA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHIgPSBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbiAgICBsZXQgcGhpID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgICByZXR1cm4gW3IsIHBoaV07XG59O1xuXG4vLyBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BiYW50aWMvaGFuZC1jb2RpbmctYS1jb2xvci13aGVlbC13aXRoLWNhbnZhcy03ODI1NmM5ZDdkNDNzXG5jb25zdCByYWQyZGVnID0gKHJhZCkgPT4ge1xuICAgIHJldHVybiAoKHJhZCArIE1hdGguUEkpIC8gKDIgKiBNYXRoLlBJKSkgKiAzNjA7XG59O1xuXG4vLyBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BiYW50aWMvaGFuZC1jb2RpbmctYS1jb2xvci13aGVlbC13aXRoLWNhbnZhcy03ODI1NmM5ZDdkNDNcbmNvbnN0IGhzdjJyZ2IgPSAoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBjaHJvbWEgPSB2YWx1ZSAqIHNhdHVyYXRpb247XG4gICAgbGV0IGh1ZTEgPSBodWUgLyA2MDtcbiAgICBsZXQgeCA9IGNocm9tYSAqICgxLSBNYXRoLmFicygoaHVlMSAlIDIpIC0gMSkpO1xuICAgIGxldCByMSwgZzEsIGIxO1xuICAgIGlmIChodWUxID49IDAgJiYgaHVlMSA8PSAxKSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbY2hyb21hLCB4LCAwXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDEgJiYgaHVlMSA8PSAyKSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbeCwgY2hyb21hLCAwXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDIgJiYgaHVlMSA8PSAzKSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbMCwgY2hyb21hLCB4XSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDMgJiYgaHVlMSA8PSA0KSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbMCwgeCwgY2hyb21hXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDQgJiYgaHVlMSA8PSA1KSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbeCwgMCwgY2hyb21hXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDUgJiYgaHVlMSA8PSA2KSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbY2hyb21hLCAwLCB4XSk7XG4gICAgfVxuXG4gICAgbGV0IG0gPSB2YWx1ZSAtIGNocm9tYTtcbiAgICBsZXQgW3IsZyxiXSA9IFtyMSttLCBnMSttLCBiMSttXTtcblxuICAgIC8vIENoYW5nZSByLGcsYiB2YWx1ZXMgZnJvbSBbMCwxXSB0byBbMCwyNTVdXG4gICAgcmV0dXJuIFsyNTUqciwyNTUqZywyNTUqYl07XG59O1xuXG5jb25zdCBnZXRQb3NpdGlvbkZyb21FdmVudCA9IChldmVudCkgPT4ge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IG9mZnNldFggPSB0YXJnZXQub2Zmc2V0TGVmdDtcbiAgICBsZXQgb2Zmc2V0WSA9IHRhcmdldC5vZmZzZXRUb3A7XG4gICAgbGV0IGNoZWNrID0gdGFyZ2V0Lm9mZnNldFBhcmVudDtcbiAgICB3aGlsZShjaGVjayl7XG4gICAgICAgIG9mZnNldFggKz0gY2hlY2sub2Zmc2V0TGVmdDtcbiAgICAgICAgb2Zmc2V0WSArPSBjaGVjay5vZmZzZXRUb3A7XG4gICAgICAgIGNoZWNrID0gY2hlY2sub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gb2Zmc2V0WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIG9mZnNldFlcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBnZXRSR0JGcm9tSW1hZ2VEYXRhID0gKHgsIHksIHdpZHRoLCBkYXRhKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gKHkgKiB3aWR0aCArIHgpICogNDtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRhW2luZGV4XSwgLy8gclxuICAgICAgICBkYXRhW2luZGV4ICsgMV0sIC8vIGdcbiAgICAgICAgZGF0YVtpbmRleCArIDJdLCAvLyBiXG4gICAgICAgIGRhdGFbaW5kZXggKyAzXSAvLyBhbHBoYVxuICAgIF07XG59O1xuXG5leHBvcnQge1xuICAgIENvbG9yV2hlZWxXaWRnZXQsXG4gICAgQ29sb3JXaGVlbFdpZGdldCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBEcmF3aW5nVmlld1xuICogRXhwZXJpbWVudGFsLlxuICogVGhpcyBpcyBzdGlsbCBhIHB1cmUgd2ViY29tcG9uZW50IGFuZCBpcyBub3RcbiAqIGxpbmtlZCBhdCBhbGwgdG8gU2ltcGxlVGFsayB5ZXQuXG4gKlxuICovXG5pbXBvcnQge1BhcnRWaWV3fSBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5pbXBvcnQge1BlbmNpbFRvb2x9IGZyb20gJy4vUGVuY2lsVG9vbC5qcyc7XG5pbXBvcnQge0VyYXNlclRvb2x9IGZyb20gJy4vRXJhc2VyVG9vbC5qcyc7XG5pbXBvcnQge0NvbG9yUGlja2VyVG9vbH0gZnJvbSAnLi9Db2xvclBpY2tlclRvb2wuanMnO1xuXG5jb25zdCBoYWxvQnV0dG9uU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXRvb2xcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTcgMTBoM3YtM2wtMy41IC0zLjVhNiA2IDAgMCAxIDggOGw2IDZhMiAyIDAgMCAxIC0zIDNsLTYtNmE2IDYgMCAwIDEgLTggLThsMy41IDMuNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgICN0b29sLWJ1dHRvbnMge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IGNhbGMoMTAwJSArIDVweCk7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cbiAgICA6aG9zdCguc2hvdy1ib3JkZXIpe1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgICB9XG4gICAgOmhvc3QoOm5vdChbbW9kZT1cImRyYXdpbmdcIl0pKSA+ICN0b29sLWJ1dHRvbnMge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbjwvc3R5bGU+XG48Y2FudmFzPjwvY2FudmFzID5cbjxkaXYgaWQ9XCJ0b29sLWJ1dHRvbnNcIj5cbjxzbG90Pjwvc2xvdD5cbjwvZGl2PlxuYDtcblxuY2xhc3MgRHJhd2luZ1ZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCBzaGFkb3cgZG9tXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJUb29sID0gbnVsbDtcblxuICAgICAgICB0aGlzLmlzQ3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VMZWF2ZSA9IHRoaXMub25Nb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvUmVzaXplID0gdGhpcy5vbkhhbG9SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGVNb2RlID0gdGhpcy50b2dnbGVNb2RlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWZ0ZXJEcmF3QWN0aW9uID0gdGhpcy5hZnRlckRyYXdBY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwgPSB0aGlzLnJlc3RvcmVJbWFnZUZyb21Nb2RlbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVDaGFuZ2VkID0gdGhpcy5tb2RlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldHVwIHByb3AgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdtb2RlJywgdGhpcy5tb2RlQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdpbWFnZScsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBpbWFnZUJpdHMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaW1hZ2UnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwoaW1hZ2VCaXRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdzaG93LWJvcmRlcicsICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmKHZhbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzaG93LWJvcmRlcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3ctYm9yZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnd2lkdGgnLCAodmFsKSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3aGF0IHdlIHdhbnQgaXMgdGhlIGNhbGN1bGF0ZWQgQ1NTLCBub3QgdGhlIFNUIHBhcnQgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImNzc1N0eWxlXCIpO1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGNzc1N0eWxlLndpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdoZWlnaHQnLCAodmFsKSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3aGF0IHdlIHdhbnQgaXMgdGhlIGNhbGN1bGF0ZWQgQ1NTLCBub3QgdGhlIFNUIHBhcnQgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImNzc1N0eWxlXCIpO1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBjc3NTdHlsZS5oZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2RlQ2hhbmdlZCh2YWx1ZSl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RlJywgdmFsdWUpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5zaGFkb3cucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuXG4gICAgICAgIC8vIFNldCBhbmQgc3RvcmUgdGhlIGRyYXdpbmcgY29udGV4dFxuICAgICAgICB0aGlzLmRyYXdpbmdDb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBJZiBJIGRvbid0IGhhdmUgdGhlIGRlZmF1bHQgdG9vbHMsIGFkZFxuICAgICAgICAvLyB0aGVtIGFzIHJlYWwgZG9tIGNoaWxkcmVuIG5vd1xuICAgICAgICBsZXQgcGVuY2lsQ2hpbGQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3BlbmNpbC10b29sJyk7XG4gICAgICAgIGlmKCFwZW5jaWxDaGlsZCl7XG4gICAgICAgICAgICBsZXQgbmV3UGVuY2lsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGVuY2lsLXRvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5ld1BlbmNpbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVyYXNlckNoaWxkID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdlcmFzZXItdG9vbCcpO1xuICAgICAgICBpZighZXJhc2VyQ2hpbGQpe1xuICAgICAgICAgICAgbGV0IG5ld0VyYXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VyYXNlci10b29sJyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChuZXdFcmFzZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbG9yUGlja2VyQ2hpbGQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2NvbG9yLXBpY2tlci10b29sJyk7XG4gICAgICAgIGlmKCFjb2xvclBpY2tlckNoaWxkKXtcbiAgICAgICAgICAgIGxldCBuZXdDb2xvclBpY2tlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbG9yLXBpY2tlci10b29sJyk7XG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgaXMgYSB0b3RhbCBoYWNrIHNpbmNlIGRyYXdpbmcgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggc3R5bGVzIGF0IHRoZSBtb21lbnRcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5ld0NvbG9yUGlja2VyKTtcbiAgICAgICAgICAgIG5ld0NvbG9yUGlja2VyLmNvbG9yV2hlZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdkaXYjb3B0aW9ucycpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JQaWNrZXJUb29sID0gbmV3Q29sb3JQaWNrZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gc2V0dXAgdGhlIGNhbnZhcyBoZWlnaHQgYW5kIHdpZHRoXG4gICAgICAgIC8vIE5vdGU6IHdoYXQgd2Ugd2FudCBpcyB0aGUgY2FsY3VsYXRlZCBDU1MsIG5vdCB0aGUgU1QgcGFydCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJjc3NTdHlsZVwiKTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGNzc1N0eWxlLmhlaWdodCk7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBjc3NTdHlsZS53aWR0aCk7XG4gICAgICAgIGxldCBjdXJyZW50SW1hZ2UgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50SW1hZ2Upe1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwoY3VycmVudEltYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbml0aWFsU2hvd0JvcmRlciA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnc2hvdy1ib3JkZXInXG4gICAgICAgICk7XG4gICAgICAgIGlmKGluaXRpYWxTaG93Qm9yZGVyKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc2hvdy1ib3JkZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91c2VEb3duKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaW5EcmF3aW5nTW9kZSkge1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgbW91c2VVcCBjb21tYW5kIG1lc3NhZ2UgdG8gc2VsZlxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW91c2VVcCcsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlIC8vIFNob3VsZCBpZ25vcmUgaWYgU3lzdGVtIEROVVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVUb29sID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdbcm9sZT1cInRvb2xcIl1bYWN0aXZlPVwidHJ1ZVwiXScpO1xuICAgICAgICBpZighdGhpcy5hY3RpdmVUb29sKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvdy5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVUb29sLnN0YXJ0KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIH1cblxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuYWN0aXZlVG9vbCAmJiB0aGlzLmluRHJhd2luZ01vZGUpe1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUb29sLm9uTW92ZShcbiAgICAgICAgICAgICAgICBldmVudC5vZmZzZXRYLFxuICAgICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJ3YW50cy1tb3ZlXCIpKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmUnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WV1cbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuYWN0aXZlVG9vbCAmJiB0aGlzLmluRHJhd2luZ01vZGUgJiYgdGhpcy5pc0N1cnJlbnRseURyYXdpbmcpe1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUb29sLmVuZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJEcmF3QWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0N1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgIH1cblxuXG4gICAgb25Nb3VzZUxlYXZlKGV2ZW50KXtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIGxlZnQgdGhlIGFyZWFcbiAgICAgICAgLy8gd2hpbGUgZHJhd2luZy4gU28gY2FsbCB0aGUgYWN0aXZlVG9vbCdzXG4gICAgICAgIC8vIGVuZCBtZXRob2RcbiAgICAgICAgdGhpcy5hY3RpdmVUb29sLmVuZChcbiAgICAgICAgICAgIGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICBldmVudC5vZmZzZXRZXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaXNDdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWZ0ZXJEcmF3QWN0aW9uKCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIG9uSGFsb1Jlc2l6ZShtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIGxldCBjdXJyZW50SW1hZ2UgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICApO1xuICAgICAgICAvLyBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGggKyBtb3ZlbWVudFg7XG4gICAgICAgIC8vIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICsgbW92ZW1lbnRZO1xuICAgICAgICBsZXQgbmV3V2lkdGggPSBjYW52YXMud2lkdGggKyBtb3ZlbWVudFg7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICsgbW92ZW1lbnRZO1xuICAgICAgICBpZihuZXdXaWR0aCAmJiBuZXdIZWlnaHQpe1xuICAgICAgICAgICAgLy8gdGhpcy5zdHlsZS53aWR0aCA9IGAke25ld1dpZHRofXB4YDtcbiAgICAgICAgICAgIC8vIHRoaXMuc3R5bGUuaGVpZ2h0ID0gYCR7bmV3SGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgbmV3V2lkdGgsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgICAgIG5ld0hlaWdodCxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdG9yZUltYWdlRnJvbU1vZGVsKGN1cnJlbnRJbWFnZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJEcmF3QWN0aW9uKCl7XG4gICAgICAgIC8vIEVuY29kZSBjYW52YXMgY29udGVudHMgYXMgYmFzZTY0IHBuZ1xuICAgICAgICAvLyBhbmQgc2V0IHRvIG1vZGVsJ3MgaW1hZ2UgcHJvcGVydHlcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICBjYW52YXMudG9EYXRhVVJMKClcbiAgICAgICAgKTtcbiAgICAgICAgLy90aGlzLnNldEF0dHJpYnV0ZShcIm1vZGVcIiwgXCJcIik7XG4gICAgfVxuXG4gICAgcmVzdG9yZUltYWdlRnJvbU1vZGVsKGJhc2U2NEltYWdlRGF0YSl7XG4gICAgICAgIC8vIENsZWFyIGFuZCBkcmF3IHRoZSBpbWFnZSB0byByZXN0b3JlIHRvXG4gICAgICAgIC8vIHRoZSBjYW52YXNcbiAgICAgICAgaWYoYmFzZTY0SW1hZ2VEYXRhKXtcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgICAgICBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBiYXNlNjRJbWFnZURhdGE7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgYm9yZGVyIHRvIGhpZGVcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdzaG93LWJvcmRlcicsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbigpe1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlkID0gXCJoYWxvLWRyYXdpbmctdG9nZ2xlLW1vZGVcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBoYWxvQnV0dG9uU1ZHO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luUmlnaHQgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ2JvdHRvbS1yb3cnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnVG9nZ2xlIGRyYXdpbmcgdG9vbHMnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVNb2RlKTtcbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgdG9nZ2xlTW9kZSgpe1xuICAgICAgICBsZXQgY3VycmVudE1vZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kZScpO1xuICAgICAgICBsZXQgbmV4dE1vZGUgPSAndmlld2luZyc7IC8vIEJ5IGRlZmF1bHQsIHNldCB0byB2aWV3aW5nXG4gICAgICAgIGxldCBpc0VtcHR5ID0gKCFjdXJyZW50TW9kZSB8fCBjdXJyZW50TW9kZSA9PSB1bmRlZmluZWQgfHwgY3VycmVudE1vZGUgPT0gXCJcIik7XG4gICAgICAgIGlmKGN1cnJlbnRNb2RlID09ICd2aWV3aW5nJyB8fCBpc0VtcHR5KXtcbiAgICAgICAgICAgIG5leHRNb2RlID0gJ2RyYXdpbmcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICBuZXh0TW9kZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCBpbkRyYXdpbmdNb2RlKCl7XG4gICAgICAgIGlmKCF0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RlJyk7XG4gICAgICAgIGlmKG1vZGUgPT0gJ2RyYXdpbmcnKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIERyYXdpbmdWaWV3LFxuICAgIERyYXdpbmdWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEVyYXNlclRvb2xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIHByb3ZpZGUgZXJhc2VyLWxpa2UgZnVuY3Rpb25hbGl0eSBvblxuICogbXkgcGFyZW50IGVsZW1lbnQncyBzaGFkb3cgY2FudmFzLlxuICogSSBhbSBzcGVjaWZpY2FsbHkgZGVzaWduZWQgZm9yIHVzZSBhcyBhXG4gKiBjaGlsZCBvZiBEcmF3aW5nVmlld1xuICovXG5jb25zdCBlcmFzZXJTVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItZXJhc2VyXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xOSAxOWgtMTFsLTQgLTRhMSAxIDAgMCAxIDAgLTEuNDFsMTAgLTEwYTEgMSAwIDAgMSAxLjQxIDBsNSA1YTEgMSAwIDAgMSAwIDEuNDFsLTkgOVwiIC8+XG4gIDxsaW5lIHgxPVwiMThcIiB5MT1cIjEyLjNcIiB4Mj1cIjExLjdcIiB5Mj1cIjZcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBlcmFzZXJUb29sVGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDZweDtcbiAgICB9XG4gICAgI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgLS1hY3RpdmUtY29sb3I6IGJsYWNrO1xuICAgICAgICAtLWluYWN0aXZlLWNvbG9yOiByZ2IoMTcwLCAxNzAsIDE3MCk7XG4gICAgICAgIC0taG92ZXItY29sb3I6IHJnYigxNDAsIDE0MCwgMTQwKTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pID4gI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgICAgICBjb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgI2JydXNoZXMtY29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAjYnJ1c2gtYWRqdXN0ZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA2cHg7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgICNicnVzaC1zbGlkZXIsXG4gICAgI2JydXNoLW51bWJlciB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgICNicnVzaC1udW1iZXIge1xuICAgICAgICBtYXgtd2lkdGg6IDNyZW07XG4gICAgfVxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+ICNicnVzaGVzLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJ0b29sLWJ1dHRvblwiPlxuICAke2VyYXNlclNWR31cbjwvZGl2PlxuPGRpdiBpZD1cImJydXNoZXMtY29udGFpbmVyXCI+XG4gIDxkaXYgaWQ9XCJicnVzaC1hZGp1c3RlclwiPlxuICAgIDxpbnB1dCBpZD1cImJydXNoLXNsaWRlclwiIHR5cGU9XCJyYW5nZVwiIG1pbj1cIjFcIiBtYXg9XCIxMDBcIiBzdGVwPVwiMVwiPlxuICAgIDxpbnB1dCBpZD1cImJydXNoLW51bWJlclwiIHR5cGU9XCJudW1iZXJcIj5cbiAgPC9kaXY+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIEVyYXNlclRvb2wgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCBzaGFkb3cgZG9tLiBUaGlzIHRvb2wgd2lsbFxuICAgICAgICAvLyBkaXNwbGF5IGl0c2VsZiBhcyBhIGJ1dHRvbiB0aGF0IGNhblxuICAgICAgICAvLyBiZSB0b2dnbGVkLlxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBlcmFzZXJUb29sVGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLnNoYWRvdy5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBkcmF3aW5nIGNvbnRleHQgaXMgbnVsbC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHNldCBpZiBhbmQgd2hlbiB0aGlzIHRvb2wgaXNcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIGEgcGFyZW50IGVsZW1lbnQgdGhhdCBoYXMgYSBjb250ZXh0XG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy5lbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZSA9IHRoaXMudG9nZ2xlQWN0aXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzID0gdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSA9IHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlID0gdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYoIXRoaXMuaGFzQXR0cmlidXRlKCd3aWR0aCcpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnNicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIElmIEkgYW0gdGhlIG9ubHkgdG9vbCBpbiBteSBwYXJlbnQsXG4gICAgICAgICAgICAgICAgLy8gc2V0IG15c2VsZiB0byBhY3RpdmVcbiAgICAgICAgICAgICAgICBsZXQgc2libGluZ1Rvb2xzID0gdGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpO1xuICAgICAgICAgICAgICAgIGlmKHNpYmxpbmdUb29scy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0b29sLWJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2ZSk7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdicnVzaC1zbGlkZXInKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dCA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYnJ1c2gtbnVtYmVyJyk7XG4gICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgaXMgY3VycmVudGx5IGEgd2lkdGggc2V0LFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBzbGlkZXIgYW5kIG51bWJlciBpbnB1dCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYoY3VycmVudFdpZHRoKXtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnZhbHVlID0gcGFyc2VJbnQoY3VycmVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQudmFsdWUgPSBwYXJzZUludChjdXJyZW50V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB0aGlzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgdGhpcy5icnVzaFNsaWRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UpO1xuICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UpO1xuICAgIH1cblxuICAgIHN0YXJ0KHgsIHkpe1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmNhY2hlZFN0cm9rZVN0eWxlID0gdGhpcy5jdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIG9uTW92ZSh4LCB5KXtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBlbmQoeCwgeSl7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY2FjaGVkU3Ryb2tlU3R5bGU7XG4gICAgfVxuXG4gICAgc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzKCl7XG4gICAgICAgIC8vIGxpbmUgY2FwXG4gICAgICAgIGxldCBsaW5lQ2FwID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xpbmUtY2FwJyk7XG4gICAgICAgIGlmKGxpbmVDYXApe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lQ2FwID0gXCJyb3VuZFwiOyAvLyBkZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW5lIGpvaW5cbiAgICAgICAgbGV0IGxpbmVKb2luID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xpbmUtam9pbicpO1xuICAgICAgICBpZihsaW5lSm9pbil7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW5lIHdpZHRoXG4gICAgICAgIGxldCBsaW5lV2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgaWYobGluZVdpZHRoKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHBhcnNlSW50KGxpbmVXaWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSA2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKXtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAnbGluZS1qb2luJyxcbiAgICAgICAgICAgICdsaW5lLWNhcCdcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsLCBuZXdWYWwpe1xuICAgICAgICBpZihuYW1lID09ICd3aWR0aCcpe1xuICAgICAgICAgICAgaWYodGhpcy5icnVzaFNsaWRlcil7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlci52YWx1ZSA9IHBhcnNlSW50KG5ld1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmJydXNoTnVtYmVySW5wdXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC52YWx1ZSA9IHBhcnNlSW50KG5ld1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVCcnVzaFNsaWRlckNoYW5nZShldmVudCl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZShldmVudCl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlQWN0aXZlKGV2ZW50KXtcbiAgICAgICAgbGV0IGlzQWN0aXZlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpO1xuICAgICAgICBpZihpc0FjdGl2ZSA9PSBcInRydWVcIil7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZmluZCBhbnkgb3RoZXIgdG9vbHMgaW4gbXkgcGFyZW50XG4gICAgICAgICAgICAvLyBlbGVtZW50IGFuZCBkZWFjdGl2YXRlIHRoZW0uXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnYWN0aXZlJykgPT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhpcyB0b29sIHRvIGJlIGFjdGl2ZVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZXJhc2VyLXRvb2wnLCBFcmFzZXJUb29sKTtcblxuZXhwb3J0IHtcbiAgICBFcmFzZXJUb29sLFxuICAgIEVyYXNlclRvb2wgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogUGVuY2lsVG9vbFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgcHJvdmlkZSBwZW5jaWwtbGlrZSBkcmF3aW5nIGNhcGFiaWxpdHlcbiAqIG9uIHRoZSBzaGFkb3cgY2FudmFzIG9mIG15IHBhcmVudCBlbGVtZW50LlxuICogSSBhbSBleHBsaWNpdGx5IGRlc2lnbmVkIGZvciB1c2Ugd2l0aFxuICogRHJhd2luZ1ZpZXdcbiAqL1xuY29uc3QgcGVuY2lsU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXBlbmNpbFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNNCAyMGg0bDEwLjUgLTEwLjVhMS41IDEuNSAwIDAgMCAtNCAtNGwtMTAuNSAxMC41djRcIiAvPlxuICA8bGluZSB4MT1cIjEzLjVcIiB5MT1cIjYuNVwiIHgyPVwiMTcuNVwiIHkyPVwiMTAuNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHBlbmNpbFRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA2cHg7XG4gICAgfVxuICAgICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIC0tYWN0aXZlLWNvbG9yOiBibGFjaztcbiAgICAgICAgLS1pbmFjdGl2ZS1jb2xvcjogcmdiKDE3MCwgMTcwLCAxNzApO1xuICAgICAgICAtLWhvdmVyLWNvbG9yOiByZ2IoMTQwLCAxNDAsIDE0MCk7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBib3JkZXItd2lkdGg6IDFweDtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+ICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgICNicnVzaGVzLWNvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgI2JydXNoLWFkanVzdGVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBib3JkZXItd2lkdGg6IDFweDtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICAjYnJ1c2gtc2xpZGVyLFxuICAgICNicnVzaC1udW1iZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAjYnJ1c2gtbnVtYmVyIHtcbiAgICAgICAgbWF4LXdpZHRoOiAzcmVtO1xuICAgIH1cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiAjYnJ1c2hlcy1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwidG9vbC1idXR0b25cIj5cbiAgJHtwZW5jaWxTVkd9XG48L2Rpdj5cbjxkaXYgaWQ9XCJicnVzaGVzLWNvbnRhaW5lclwiPlxuICA8ZGl2IGlkPVwiYnJ1c2gtYWRqdXN0ZXJcIj5cbiAgICA8aW5wdXQgaWQ9XCJicnVzaC1zbGlkZXJcIiB0eXBlPVwicmFuZ2VcIiBtaW49XCIxXCIgbWF4PVwiMTAwXCIgc3RlcD1cIjFcIj5cbiAgICA8aW5wdXQgaWQ9XCJicnVzaC1udW1iZXJcIiB0eXBlPVwibnVtYmVyXCI+XG4gIDwvZGl2PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBQZW5jaWxUb29sIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHNoYWRvdyBkb20uIFRoaXMgdG9vbCB3aWxsXG4gICAgICAgIC8vIGRpc3BsYXkgaXRzZWxmIGFzIGEgYnV0dG9uIHRoYXQgY2FuXG4gICAgICAgIC8vIGJlIHRvZ2dsZWQuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHBlbmNpbFRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZHJhd2luZyBjb250ZXh0XG4gICAgICAgIC8vIGlzIG51bGwuIFRoaXMgd2lsbCBiZSBzZXRcbiAgICAgICAgLy8gaWYgYW5kIHdoZW4gdGhpcyB0b29sIGlzXG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgIC8vIHRoYXQgaGFzIGEgY29udGV4dFxuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUgPSB0aGlzLnRvZ2dsZUFjdGl2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcyA9IHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UgPSB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZSA9IHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLmhhc0F0dHJpYnV0ZSgnd2lkdGgnKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBJIGFtIHRoZSBvbmx5IHRvb2wgaW4gbXkgcGFyZW50LFxuICAgICAgICAgICAgICAgIC8vIHNldCBteXNlbGYgdG8gYWN0aXZlXG4gICAgICAgICAgICAgICAgbGV0IHNpYmxpbmdUb29scyA9IHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKTtcbiAgICAgICAgICAgICAgICBpZihzaWJsaW5nVG9vbHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndG9vbC1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVBY3RpdmUpO1xuICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYnJ1c2gtc2xpZGVyJyk7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2JydXNoLW51bWJlcicpO1xuICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGlzIGN1cnJlbnRseSBhIHdpZHRoIHNldCxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2xpZGVyIGFuZCBudW1iZXIgaW5wdXQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIGxldCBjdXJyZW50V2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRXaWR0aCl7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnZhbHVlID0gcGFyc2VJbnQoY3VycmVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQudmFsdWUgPSBwYXJzZUludChjdXJyZW50V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB0aGlzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgdGhpcy5icnVzaFNsaWRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UpO1xuICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UpO1xuICAgIH1cblxuICAgIHN0YXJ0KHgsIHkpe1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIG9uTW92ZSh4LCB5KXtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBlbmQoeCwgeSl7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHNldENvbnRleHRGcm9tQXR0cmlidXRlcygpe1xuICAgICAgICAvLyBsaW5lIGNhcFxuICAgICAgICBsZXQgbGluZUNhcCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsaW5lLWNhcCcpO1xuICAgICAgICBpZihsaW5lQ2FwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUNhcCA9IFwicm91bmRcIjsgLy8gZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGluZSBqb2luXG4gICAgICAgIGxldCBsaW5lSm9pbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsaW5lLWpvaW4nKTtcbiAgICAgICAgaWYobGluZUpvaW4pe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGluZSB3aWR0aFxuICAgICAgICBsZXQgbGluZVdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICAgIGlmKGxpbmVXaWR0aCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSBwYXJzZUludChsaW5lV2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gNjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCl7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgJ2xpbmUtam9pbicsXG4gICAgICAgICAgICAnbGluZS1jYXAnXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbCwgbmV3VmFsKXtcbiAgICAgICAgaWYobmFtZSA9PSAnd2lkdGgnKXtcbiAgICAgICAgICAgIGlmKHRoaXMuYnJ1c2hTbGlkZXIpe1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIudmFsdWUgPSBwYXJzZUludChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5icnVzaE51bWJlcklucHV0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQudmFsdWUgPSBwYXJzZUludChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UoZXZlbnQpe1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cblxuICAgIGhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UoZXZlbnQpe1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cblxuICAgIHRvZ2dsZUFjdGl2ZShldmVudCl7XG4gICAgICAgIGxldCBpc0FjdGl2ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKTtcbiAgICAgICAgaWYoaXNBY3RpdmUgPT0gXCJ0cnVlXCIpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QsIGZpbmQgYW55IG90aGVyIHRvb2xzIGluIG15IHBhcmVudFxuICAgICAgICAgICAgLy8gZWxlbWVudCBhbmQgZGVhY3RpdmF0ZSB0aGVtLlxuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpID09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG9vbCB0byBiZSBhY3RpdmVcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgncGVuY2lsLXRvb2wnLCBQZW5jaWxUb29sKTtcblxuZXhwb3J0IHtcbiAgICBQZW5jaWxUb29sLFxuICAgIFBlbmNpbFRvb2wgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBFZGl0b3JUYWIgZnJvbSAnLi9FZGl0b3JUYWIuanMnO1xuaW1wb3J0IEVkaXRvclByb3BMaXN0IGZyb20gJy4vRWRpdG9yUHJvcExpc3QuanMnO1xuaW1wb3J0IEVkaXRvck1lc3NlbmdlciBmcm9tICcuL0VkaXRvck1lc3Nlbmdlci5qcyc7XG5pbXBvcnQgRWRpdG9yQ3VzdG9tTGlzdCBmcm9tICcuL0VkaXRvckN1c3RvbUxpc3QuanMnO1xuaW1wb3J0IEVkaXRvclN1YnBhcnRzUGFuZSBmcm9tICcuL0VkaXRvclN1YnBhcnRzUGFuZS5qcyc7XG5pbXBvcnQgcGFydEljb25zIGZyb20gJy4uLy4uL3V0aWxzL2ljb25zLmpzJztcbi8vIFBSRUFNQkxFXG5cbi8vIEFkZCBlZGl0b3IgdGFiIGVsZW1lbnRcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci10YWInLCBFZGl0b3JUYWIpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLXByb3BzLWxpc3QnLCBFZGl0b3JQcm9wTGlzdCk7XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3ItY3VzdG9tLWxpc3QnLCBFZGl0b3JDdXN0b21MaXN0KTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1tZXNzZW5nZXInLCBFZGl0b3JNZXNzZW5nZXIpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLXN1YnBhcnRzJywgRWRpdG9yU3VicGFydHNQYW5lKTtcblxuY29uc3QgY2xvc2VCdXR0b24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXIteFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjOWU5ZTllXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxsaW5lIHgxPVwiMThcIiB5MT1cIjZcIiB4Mj1cIjZcIiB5Mj1cIjE4XCIgLz5cbiAgPGxpbmUgeDE9XCI2XCIgeTE9XCI2XCIgeDI9XCIxOFwiIHkyPVwiMThcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBzY3JpcHRJY29uID0gYFxuPHN2ZyBpZD0nc2NyaXB0JyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWZpbGUtY29kZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgICA8cGF0aCBkPVwiTTE0IDN2NGExIDEgMCAwIDAgMSAxaDRcIiAvPlxuICAgIDxwYXRoIGQ9XCJNMTcgMjFoLTEwYTIgMiAwIDAgMSAtMiAtMnYtMTRhMiAyIDAgMCAxIDIgLTJoN2w1IDV2MTFhMiAyIDAgMCAxIC0yIDJ6XCIgLz5cbiAgICA8cGF0aCBkPVwiTTEwIDEzbC0xIDJsMSAyXCIgLz5cbiAgICA8cGF0aCBkPVwiTTE0IDEzbDEgMmwtMSAyXCIgLz5cbjwvc3ZnPmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwNSUpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTUwbXMgbGluZWFyO1xuICAgICAgICB3aWR0aDogNDAwcHg7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjUpO1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDEwcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICB9XG4gICAgXG4gICAgOmhvc3QoLm9wZW4pe1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCUpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTUwbXMgbGluZWFyO1xuICAgICAgICB6LWluZGV4OiAxMDA7XG4gICAgfVxuXG4gICAgOmhvc3QoOjphZnRlcikge1xuICAgICAgICBjb250ZW50OiBcIiBcIjtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogNXB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogLTEwO1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMHB4IDNweCAxMHB4IHJnYmEoMTAwLCAxMDAsIDEwMCwgMC42KTtcbiAgICB9XG5cbiAgICA6OnNsb3R0ZWQoZWRpdG9yLXByb3BzLWxpc3Q6bm90KC5zaG93LXBhbmUpKSxcbiAgICA6OnNsb3R0ZWQoZWRpdG9yLW1lc3Nlbmdlcjpub3QoLnNob3ctcGFuZSkpLFxuICAgIDo6c2xvdHRlZChlZGl0b3ItY3VzdG9tLWxpc3Q6bm90KC5zaG93LXBhbmUpKSxcbiAgICA6OnNsb3R0ZWQoZWRpdG9yLXN1YnBhcnRzOm5vdCguc2hvdy1wYW5lKSl7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgI3RhYi1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG4gICAgXG4gICAgI3BhbmUtYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBtYXJnaW4tdG9wOiAyMHB4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cblxuICAgICNoZWFkZXItYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICB9XG5cbiAgICAuaGVhZGVyLXNpZGUge1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBtYXJnaW4tdG9wOiAyMHB4O1xuICAgIH1cblxuICAgICNkaXNwbGF5LWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAzMHB4O1xuICAgIH1cblxuICAgICNoZWFkZXItYXJlYSBoMyB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDVweDtcbiAgICAgICAgZm9udC1zaXplOiAxLjdyZW07XG4gICAgfVxuXG4gICAgI2hlYWRlci1sZWZ0ID4gaW5wdXQge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBhZGRpbmc6IDRweDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuOCk7XG4gICAgICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xuICAgIH1cblxuICAgICNoZWFkZXItcmlnaHQgPiBidXR0b24ge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44NWVtO1xuICAgIH1cblxuICAgICNoZWFkZXItcmlnaHQgPiBidXR0b246aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC4zKTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLXJpZ2h0ID4gYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC44KTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMjAsIDIyMCwgMjIwKTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLXJpZ2h0ID4gYnV0dG9uID4gc3ZnIHtcbiAgICAgICAgaGVpZ2h0OiAxLjNlbTtcbiAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgIH1cblxuICAgICNoZWFkZXItbGVmdCB7XG4gICAgICAgIG1heC13aWR0aDogODAlO1xuICAgIH1cblxuICAgICNoZWFkZXItbGVmdCBzcGFuIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICAgICAgZm9udC1zaXplOiAxLjFyZW07XG4gICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cblxuICAgICNpY29uLWRpc3BsYXktYXJlYSB7XG4gICAgICAgIHdpZHRoOiAxLjdyZW07XG4gICAgICAgIGhlaWdodDogMS43cmVtO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7XG4gICAgfVxuICAgICNpY29uLWRpc3BsYXktYXJlYSA+IHN2ZyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuXG4gICAgI2Nsb3NlLWJ1dHRvbiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogNTtcbiAgICAgICAgcmlnaHQ6IDU7XG4gICAgfVxuICAgICNjbG9zZS1idXR0b246aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJjbG9zZS1idXR0b25cIj4ke2Nsb3NlQnV0dG9ufTwvZGl2PlxuPGRpdiBpZD1cImhlYWRlci1hcmVhXCI+XG4gICAgPGRpdiBpZD1cImhlYWRlci1sZWZ0XCIgY2xhc3M9XCJoZWFkZXItc2lkZVwiPlxuICAgICAgICA8ZGl2IGlkPVwiZGlzcGxheS1hcmVhXCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwiaWNvbi1kaXNwbGF5LWFyZWFcIj48L2Rpdj5cbiAgICAgICAgICAgIDxoMz48L2gzPjxzcGFuPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwicGFydC1uYW1lLWlucHV0XCIvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoZWFkZXItcmlnaHRcIiBjbGFzcz1cImhlYWRlci1zaWRlXCI+XG4gICAgICAgIDxidXR0b24gaWQ9XCJlZGl0LXNjcmlwdC1idXR0b25cIj5cbiAgICAgICAgICAgICR7c2NyaXB0SWNvbn1cbiAgICAgICAgICAgIDxzcGFuPkVkaXQgU2NyaXB0PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBpZD1cInRhYi1hcmVhXCI+XG4gICAgPGVkaXRvci10YWIgYWN0aXZlPVwidHJ1ZVwiIG5hbWU9XCJwcm9wZXJ0aWVzXCI+UHJvcGVydGllczwvZWRpdG9yLXRhYj5cbiAgICA8ZWRpdG9yLXRhYiBuYW1lPVwiY3VzdG9tXCI+Q3VzdG9tPC9lZGl0b3ItdGFiPlxuICAgIDxlZGl0b3ItdGFiIG5hbWU9XCJtZXNzZW5nZXJcIj5NZXNzZW5nZXI8L2VkaXRvci10YWI+XG4gICAgPGVkaXRvci10YWIgbmFtZT1cInN1YnBhcnRzXCI+U3VicGFydHM8L2VkaXRvci10YWI+XG48L2Rpdj5cbjxkaXYgaWQ9XCJwYW5lLWFyZWFcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIEVkaXRvciBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMudG9nZ2xlID0gdGhpcy50b2dnbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuID0gdGhpcy5vcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jZW50ZXJPbkVsZW1lbnQgPSB0aGlzLmNlbnRlck9uRWxlbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVuZG9DZW50ZXJPbkVsZW1lbnQgPSB0aGlzLnVuZG9DZW50ZXJPbkVsZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVIZWFkZXIgPSB0aGlzLnVwZGF0ZUhlYWRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNoZWNrRm9yTmF2aWdhdGlvbiA9IHRoaXMuY2hlY2tGb3JOYXZpZ2F0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZU1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25UYWJBY3RpdmF0ZWQgPSB0aGlzLm9uVGFiQWN0aXZhdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25OYW1lSW5wdXRDaGFuZ2UgPSB0aGlzLm9uTmFtZUlucHV0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25FZGl0U2NyaXB0Q2xpY2sgPSB0aGlzLm9uRWRpdFNjcmlwdENsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RhYi1hY3RpdmF0ZWQnLCB0aGlzLm9uVGFiQWN0aXZhdGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2Nsb3NlLWJ1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgICAgIGxldCBuYW1lSW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdwYXJ0LW5hbWUtaW5wdXQnKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uTmFtZUlucHV0Q2hhbmdlKTtcblxuICAgICAgICAgICAgbGV0IGVkaXRTY3JpcHRCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdlZGl0LXNjcmlwdC1idXR0b24nKTtcbiAgICAgICAgICAgIGVkaXRTY3JpcHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRWRpdFNjcmlwdENsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFiLWFjdGl2YXRlZCcsIHRoaXMub25UYWJBY3RpdmF0ZWQpO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjbG9zZS1idXR0b24nKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAgIHRoaXMuY2xvc2VcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEV2ZW50c1xuICAgICAgICBsZXQgbmFtZUlucHV0ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgncGFydC1uYW1lLWlucHV0Jyk7XG4gICAgICAgIG5hbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uTmFtZUlucHV0Q2hhbmdlKTtcblxuICAgICAgICBsZXQgZWRpdFNjcmlwdEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2VkaXQtc2NyaXB0LWJ1dHRvbicpO1xuICAgICAgICBlZGl0U2NyaXB0QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkVkaXRTY3JpcHRDbGljayk7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCl7XG4gICAgICAgIGlmKHRoaXMuaXNPcGVuKXtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3Blbigpe1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5jZW50ZXJPbkVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpe1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcbiAgICAgICAgdGhpcy51bmRvQ2VudGVyT25FbGVtZW50KCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5yZW1vdmVQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcbiAgICAgICAgdGhpcy5tb2RlbC5hZGRQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGluY29taW5nIG1vZGVsIGlzIGEgQ2FyZCBvclxuICAgICAgICAvLyBTdGFjayB0aGF0IGlzIG5vdCB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgIC8vIHdlIG5hdmlnYXRlIHRvIGl0XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnY2FyZCcgfHwgdGhpcy5tb2RlbC50eXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgdGhpcy5jaGVja0Zvck5hdmlnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsb3NlIGFueSBvcGVuIEhhbG9zLlxuICAgICAgICAvLyBJZiB0aGUgbmV3IG1vZGVsIHdhbnRzIGEgSGFsbyxcbiAgICAgICAgLy8gb3BlbiBpdCBvbiB0aGUgVmlldyBmb3IgdGhhdCBNb2RlbC5cbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuZWRpdGluZ2ApKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGVsLmNsb3NlSGFsbygpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRhcmdldFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7dGhpcy5tb2RlbC5pZH1cIl1gKTtcbiAgICAgICAgaWYodGFyZ2V0VmlldyAmJiB0YXJnZXRWaWV3LndhbnRzSGFsbyl7XG4gICAgICAgICAgICB0YXJnZXRWaWV3Lm9wZW5IYWxvKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMudXBkYXRlSGVhZGVyKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgc2xvdHRlZCBpbm5lciBET01cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIEFkZCBwYW5lc1xuICAgICAgICBsZXQgcHJvcHNQYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLXByb3BzLWxpc3QnKTtcbiAgICAgICAgcHJvcHNQYW5lLnNldEF0dHJpYnV0ZSgndGFiLW5hbWUnLCAncHJvcGVydGllcycpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHByb3BzUGFuZSk7XG4gICAgICAgIHByb3BzUGFuZS5yZW5kZXIodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgbGV0IG1lc3NlbmdlclBhbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItbWVzc2VuZ2VyJyk7XG4gICAgICAgIG1lc3NlbmdlclBhbmUuc2V0QXR0cmlidXRlKCd0YWItbmFtZScsICdtZXNzZW5nZXInKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChtZXNzZW5nZXJQYW5lKTtcbiAgICAgICAgbWVzc2VuZ2VyUGFuZS5yZW5kZXIodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgbGV0IGN1c3RvbVBhbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItY3VzdG9tLWxpc3QnKTtcbiAgICAgICAgY3VzdG9tUGFuZS5zZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJywgJ2N1c3RvbScpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGN1c3RvbVBhbmUpO1xuICAgICAgICBjdXN0b21QYW5lLnJlbmRlcih0aGlzLm1vZGVsKTtcblxuICAgICAgICBsZXQgc3VicGFydHNQYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLXN1YnBhcnRzJyk7XG4gICAgICAgIHN1YnBhcnRzUGFuZS5zZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJywgJ3N1YnBhcnRzJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3VicGFydHNQYW5lKTtcbiAgICAgICAgc3VicGFydHNQYW5lLnJlbmRlcih0aGlzLm1vZGVsKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBhY3RpdmUgdGFiIGFuZCBzaG93IGl0cyBjb3JyZXNwb25kaW5nIHBhbmVcbiAgICAgICAgbGV0IGFjdGl2ZVRhYiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihgZWRpdG9yLXRhYlthY3RpdmU9XCJ0cnVlXCJdYCk7XG4gICAgICAgIGlmKGFjdGl2ZVRhYil7XG4gICAgICAgICAgICBsZXQgYWN0aXZlTmFtZSA9IGFjdGl2ZVRhYi5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbdGFiLW5hbWVdJykpLmZvckVhY2gocGFuZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBwYW5lLmdldEF0dHJpYnV0ZSgndGFiLW5hbWUnKTtcbiAgICAgICAgICAgICAgICBpZihuYW1lID09IGFjdGl2ZU5hbWUpe1xuICAgICAgICAgICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ3Nob3ctcGFuZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdy1wYW5lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIHBhbmUgaXMgYWxyZWFkeSBvcGVuLCB0aGVuIGNlbnRlclxuICAgICAgICAvLyBvbiB0aGUgcHJpbWFyeSB2aWV3IGVsZW1lbnQgZm9yIHRoZSBtb2RlbFxuICAgICAgICBpZih0aGlzLmlzT3Blbil7XG4gICAgICAgICAgICB0aGlzLmNlbnRlck9uRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2VudGVyT25FbGVtZW50KCl7XG4gICAgICAgIC8vIFVzZSBDU1MgdHJhbnNmb3JtcyBvZiB0aGUgd2hvbGUgV29ybGQgdG8gY2VudGVyIG9uXG4gICAgICAgIC8vIHRoZSBwcmltYXJ5IHZpZXcgZWxlbWVudCBvZiB0aGUgUGFydCBiZWluZyBlZGl0ZWQsXG4gICAgICAgIC8vIGlmIHNldC4gSWYgbm90IHNldCwgZG8gbm90aGluZy5cbiAgICAgICAgaWYodGhpcy5tb2RlbCl7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZWRpdGluZyBhIENhcmQsIFN0YWNrLCBvciBXb3JsZCwgdGhlblxuICAgICAgICAgICAgLy8gd2UgdW5jZW50ZXIgYW5kIHJldHVyblxuICAgICAgICAgICAgbGV0IGlzQ2FyZFN0YWNrT3JXb3JsZCA9IFsnY2FyZCcsICdzdGFjaycsICd3b3JsZCddLmluY2x1ZGVzKHRoaXMubW9kZWwudHlwZSk7XG4gICAgICAgICAgICBpZihpc0NhcmRTdGFja09yV29ybGQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuZG9DZW50ZXJPbkVsZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHBhcnRWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgICAgICBsZXQgd29ybGRWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQoJ3dvcmxkJyk7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHdvcmxkVmlldy5nZXRBdHRyaWJ1dGUoJ2NlbnRlcmVkLW9uJyk7XG4gICAgICAgICAgICBpZihjdXJyZW50ID09IHRoaXMubW9kZWwuaWQudG9TdHJpbmcoKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbWVudVJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGV0IHBhcnRSZWN0ID0gcGFydFZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgYWN0dWFsIHZpZXdhYmxlIHdpZHRoLCBwbHVzIHRoZSBlZGl0b3IgbWVudVxuICAgICAgICAgICAgbGV0IHZpZXdXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICsgbWVudVJlY3Qud2lkdGg7XG4gICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gbWVudVJlY3QuaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgWCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgbGV0IHRhcmdldFggPSAodmlld1dpZHRoIC0gcGFydFJlY3Qud2lkdGgpIC8gMjtcbiAgICAgICAgICAgIGxldCBuZXdYO1xuICAgICAgICAgICAgaWYodGFyZ2V0WCA8IHBhcnRSZWN0LmxlZnQpe1xuICAgICAgICAgICAgICAgIG5ld1ggPSAocGFydFJlY3QubGVmdCAtIHRhcmdldFgpICogLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ggPSB0YXJnZXRYIC0gcGFydFJlY3QubGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIFkgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIGxldCB0YXJnZXRZID0gKHZpZXdIZWlnaHQgLSBwYXJ0UmVjdC5oZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIGxldCBuZXdZO1xuICAgICAgICAgICAgaWYodGFyZ2V0WSA8IHBhcnRSZWN0LnRvcCl7XG4gICAgICAgICAgICAgICAgbmV3WSA9IChwYXJ0UmVjdC50b3AgLSB0YXJnZXRZKSAqIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdZID0gdGFyZ2V0WSAtIHBhcnRSZWN0LnRvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29ybGRWaWV3LnNldEF0dHJpYnV0ZSgnY2VudGVyZWQtb24nLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2V0IHRyYW5zZm9ybSBhbmQgdHJhbnNpdGlvblxuICAgICAgICAgICAgd29ybGRWaWV3LnN0eWxlLnRyYW5zaXRpb24gPSBcInRyYW5zZm9ybSAwLjNzIGVhc2Utb3V0XCI7XG4gICAgICAgICAgICB3b3JsZFZpZXcuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke25ld1h9cHgsICR7bmV3WX1weClgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5kb0NlbnRlck9uRWxlbWVudCgpe1xuICAgICAgICBsZXQgd29ybGRWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQoJ3dvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVBdHRyaWJ1dGUoJ2NlbnRlcmVkLW9uJyk7XG4gICAgICAgIHdvcmxkVmlldy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNmb3JtJyk7XG4gICAgfVxuXG4gICAgdXBkYXRlSGVhZGVyKCl7XG4gICAgICAgIGxldCBuYW1lSW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNoZWFkZXItbGVmdCA+IGlucHV0Jyk7XG4gICAgICAgIGxldCB0eXBlRGlzcGxheSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI2Rpc3BsYXktYXJlYSA+IGgzJyk7XG4gICAgICAgIGxldCBpZERpc3BsYXkgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNkaXNwbGF5LWFyZWEgPiBzcGFuJyk7XG4gICAgICAgIGxldCBpY29uRGlzcGxheSA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2ljb24tZGlzcGxheS1hcmVhJyk7XG5cbiAgICAgICAgbGV0IHBhcnROYW1lID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICduYW1lJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmKHBhcnROYW1lICYmIHBhcnROYW1lICE9PSBcIlwiKXtcbiAgICAgICAgICAgIG5hbWVJbnB1dC52YWx1ZSA9IHBhcnROYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZUlucHV0LnZhbHVlID0gXCIoVW5uYW1lZClcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGVEaXNwbGF5LnRleHRDb250ZW50ID0gdGhpcy5tb2RlbC50eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGhpcy5tb2RlbC50eXBlLnNsaWNlKDEpO1xuICAgICAgICBpZERpc3BsYXkudGV4dENvbnRlbnQgPSBgaWQ9JHt0aGlzLm1vZGVsLmlkfWA7XG4gICAgICAgIGlkRGlzcGxheS50aXRsZSA9IHRoaXMubW9kZWwuaWQ7XG5cbiAgICAgICAgaWYoT2JqZWN0LmtleXMocGFydEljb25zKS5pbmNsdWRlcyh0aGlzLm1vZGVsLnR5cGUpKXtcbiAgICAgICAgICAgIGljb25EaXNwbGF5LmlubmVySFRNTCA9IHBhcnRJY29uc1t0aGlzLm1vZGVsLnR5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWNvbkRpc3BsYXkuaW5uZXJIVE1MID0gcGFydEljb25zLmdlbmVyaWM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja0Zvck5hdmlnYXRpb24oKXtcbiAgICAgICAgLy8gSWYgdGhlIG1vZGVsIGlzIGEgQ2FyZCBvciBTdGFjayB0aGF0XG4gICAgICAgIC8vIGlzIG5vdCB0aGUgY3VycmVudCAoaWUsIG5vdCBiZWluZyBkaXNwbGF5ZWRcbiAgICAgICAgLy8gaW4gdGhlIG1haW4gd2luZG93KSwgdGhlbiB3ZSBzaG91bGQgbmF2aWdhdGVcbiAgICAgICAgLy8gdG8gaXRcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHdpbmRvdy5TeXN0ZW0ud29ybGQuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudENhcmQgPSBjdXJyZW50U3RhY2suY3VycmVudENhcmQ7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnY2FyZCcgJiYgdGhpcy5tb2RlbC5pZCAhPSBjdXJyZW50Q2FyZC5pZCl7XG4gICAgICAgICAgICBjdXJyZW50U3RhY2suZ29Ub0NhcmRCeUlkKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5tb2RlbC50eXBlID09ICdzdGFjaycgJiYgdGhpcy5tb2RlbC5pZCAhPSBjdXJyZW50U3RhY2suaWQpe1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS53b3JsZC5nb1RvU3RhY2tCeUlkKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIHJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLnR5cGUpe1xuICAgICAgICBjYXNlICdwcm9wZXJ0eUNoYW5nZWQnOlxuICAgICAgICAgICAgLy8gRmluZCBhbnkgbmVzdGVkIGVkaXRvci1wcm9wLWl0ZW0gZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGFuZCByZS1yZW5kZXIsIHNvIHRoZXkgZGlzcGxheSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgLy8gdmFsdWVzIGluIHRoZSBlZGl0b3JcbiAgICAgICAgICAgIGxldCBxdWVyeVN0cmluZyA9IGBlZGl0b3ItcHJvcC1pdGVtW25hbWU9XCIke2FNZXNzYWdlLnByb3BlcnR5TmFtZX1cIl1bb3duZXItaWQ9XCIke2FNZXNzYWdlLnBhcnRJZH1cIl1gO1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnlTdHJpbmcpKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBpZihlbC5wcm9wZXJ0eS52YWx1ZSAhPT0gYU1lc3NhZ2UudmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25UYWJBY3RpdmF0ZWQoZXZlbnQpe1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnZWRpdG9yLXRhYicpKVxuICAgICAgICAgICAgLmZpbHRlcih0YWJFbCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYkVsICE9PSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKHRhYkVsID0+IHtcbiAgICAgICAgICAgICAgICB0YWJFbC5yZW1vdmVBdHRyaWJ1dGUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBuYW1lIG9mIHRoZSBhY3RpdmF0ZWQgdGFiXG4gICAgICAgIGxldCB0YXJnZXROYW1lID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW3RhYi1uYW1lXScpKS5mb3JFYWNoKHBhbmUgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBwYW5lLmdldEF0dHJpYnV0ZSgndGFiLW5hbWUnKTtcbiAgICAgICAgICAgIGlmKG5hbWUgPT0gdGFyZ2V0TmFtZSl7XG4gICAgICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QuYWRkKCdzaG93LXBhbmUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93LXBhbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25OYW1lSW5wdXRDaGFuZ2UoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIGxldCBuZXdOYW1lID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgIG5ld05hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkVkaXRTY3JpcHRDbGljayhldmVudCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaXNPcGVuKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yLFxuICAgIEVkaXRvciBhcyBkZWZhdWx0XG59O1xuIiwiXG5cbi8vIFBSRUFNQkxFXG5cbmNvbnN0IGNhcmV0RG93bkljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2FyZXQtZG93blwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTggMTVsLTYgLTZsLTYgNmgxMlwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY2FyZXRSaWdodEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2FyZXQtcmlnaHRcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTE4IDE1bC02IC02bC02IDZoMTJcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgMTIgMTIpXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cblxuICAgICNwcm9wcy1saXN0IHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIH1cbiAgICAjZmlsdGVyLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG4gICAgI2ZpbHRlci1hcmVhID4gaW5wdXQge1xuICAgICAgICBtaW4td2lkdGg6IDA7XG4gICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBmb250LXNpemU6IDEuMHJlbTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA2cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDZweDtcbiAgICAgICAgcGFkZGluZy10b3A6IDNweDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDNweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjgpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgfVxuICAgIFxuICAgICNuZXctcHJvcC1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgI25ldy1wcm9wLWFyZWEub3BlbiA+ICNuZXctcHJvcC1mb3JtIHtcbiAgICAgICAgZGlzcGxheTpmbGV4O1xuICAgIH1cblxuICAgICNuZXctcHJvcC1mb3JtIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLnJvdyB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxZW07XG4gICAgfVxuXG4gICAgaDMge1xuICAgICAgICBwYWRkaW5nOiAwcHg7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDFlbTtcbiAgICB9XG5cbiAgICAjbmV3LXByb3AtZm9ybSA+IC5yb3cgPiAqIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxNnB4O1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDhweDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogOHB4O1xuICAgIH1cbiAgICAjbmV3LXByb3AtZm9ybSBpbnB1dCB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjcpO1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBwYWRkaW5nOiA2cHg7XG4gICAgfVxuXG4gICAgI25ldy1wcm9wLW5hbWU6aW52YWxpZCB7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZWQ7XG4gICAgfVxuICAgIFxuICAgIHNlbGVjdCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMWVtO1xuICAgIH1cbiAgICAjYWRkLXByb3AtZHJvcGRvd24tY29udHJvbCB7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIH1cblxuICAgICNhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sOmhvdmVyLFxuICAgICNhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sIGxhYmVsIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cblxuICAgICNjYXJldC1idXR0b24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxLjVlbTtcbiAgICAgICAgaGVpZ2h0OiAxLjVlbTtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGxpbmVhcjtcbiAgICB9XG5cbiAgICAjY2FyZXQtYnV0dG9uID4gc3ZnIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG4gICAgI25ldy1wcm9wLWFyZWEub3BlbiAjY2FyZXQtYnV0dG9uIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xcyBsaW5lYXI7XG4gICAgfVxuXG48L3N0eWxlPlxuPGRpdiBpZD1cIm5ldy1wcm9wLWFyZWFcIj5cbiAgICA8ZGl2IGNsYXNzPVwicm93XCIgaWQ9XCJhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sXCI+XG4gICAgICAgIDxoMz48bGFiZWwgZm9yPVwiY2FyZXQtYnV0dG9uXCI+QWRkIE5ldyBQcm9wZXJ0eTwvbGFiZWw+PC9oMz5cbiAgICAgICAgPGRpdiBpZD1cImNhcmV0LWJ1dHRvblwiPiR7Y2FyZXRSaWdodEljb259PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cIm5ldy1wcm9wLWZvcm1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cIm5ldy1wcm9wLW5hbWVcIj5Qcm9wZXJ0eSBOYW1lIDwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cIm5ldy1wcm9wLW5hbWVcIiBwbGFjZWhvbGRlcj1cInByb3BlcnR5LW5hbWVcIiBwYXR0ZXJuPVwiW2EtelxcXFwtXXszLDY0fVwiLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJkZWZhdWx0LXZhbC1zZWxlY3RcIj5EZWZhdWx0IHZhbHVlIHR5cGU8L2xhYmVsPlxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cImRlZmF1bHQtdmFsLXNlbGVjdFwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIiBzZWxlY3RlZD5Ob25lPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInN0cmluZ1wiPlRleHQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibnVtYmVyXCI+TnVtYmVyPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJvb2xlYW5cIj5UcnVlIG9yIEZhbHNlPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJkZWZhdWx0LXZhbHVlXCI+RGVmYXVsdCB2YWx1ZSA8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJkZWZhdWx0LXZhbHVlXCIgcGxhY2Vob2xkZXI9XCJEZWZhdWx0IHZhbHVlXCIgZGlzYWJsZWQvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiIGlkPVwic3VibWl0LWNvbnRyb2xcIj5cbiAgICAgICAgICAgIDxidXR0b24gaWQ9XCJzdWJtaXQtcHJvcFwiPkNyZWF0ZTwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBpZD1cImZpbHRlci1hcmVhXCI+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJmaWx0ZXItaW5wdXRcIiBuYW1lPVwiZmlsdGVyLWlucHV0XCIgcGxhY2Vob2xkZXI9XCJGaWx0ZXIuLi5cIi8+XG4gICAgPGJ1dHRvbiBpZD1cImNsZWFyXCI+Q2xlYXI8L2J1dHRvbj5cbjwvZGl2PlxuPHVsIGlkPVwicHJvcHMtbGlzdFwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbjwvdWw+XG5gO1xuXG5jbGFzcyBFZGl0b3JDdXN0b21MaXN0IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0Rm9ybSA9IHRoaXMucmVzZXRGb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25EZWZhdWx0TmV3VHlwZUNoYW5nZSA9IHRoaXMub25EZWZhdWx0TmV3VHlwZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2FyZXRDbGljayA9IHRoaXMub25DYXJldENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DcmVhdGVTdWJtaXQgPSB0aGlzLm9uQ3JlYXRlU3VibWl0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25GaWx0ZXJJbnB1dCA9IHRoaXMub25GaWx0ZXJJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljayA9IHRoaXMub25GaWx0ZXJDbGVhckNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BUeXBlU2VsZWN0ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZGVmYXVsdC12YWwtc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BOYW1lSW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCduZXctcHJvcC1uYW1lJyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdkZWZhdWx0LXZhbHVlJyk7XG4gICAgICAgICAgICB0aGlzLmFkZFByb3BDb250cm9sID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYWRkLXByb3AtZHJvcGRvd24tY29udHJvbCcpO1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRm9ybSA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25ldy1wcm9wLWZvcm0nKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnc3VibWl0LXByb3AnKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjbGVhcicpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnB1dCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmFkZFByb3BDb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNhcmV0Q2xpY2spO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ3JlYXRlU3VibWl0KTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uRmlsdGVySW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25GaWx0ZXJDbGVhckNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuXG4gICAgICAgIC8vIENsZWFyIGFueSBtYWluIGRvbSBjaGlsZHJlblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc29ydGVkIGNvcHkgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIG9iamVjdHNcbiAgICAgICAgbGV0IGN1c3RvbVByb3BzID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdjdXN0b20tcHJvcGVydGllcydcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBzb3J0ZWQgbGlzdCBvZiB0aGUgY3VzdG9tIHByb3BlcnRpZXNcbiAgICAgICAgLy8gYXZhaWxhYmxlXG4gICAgICAgIHRoaXMucHJvcExpc3QgPSBPYmplY3QudmFsdWVzKGN1c3RvbVByb3BzKVxuICAgICAgICAgICAgLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3QubmFtZS5sb2NhbGVDb21wYXJlKHNlY29uZC5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgcHJvcGVydHkgaXRlbXMgYW5kIGluc2VydCB0aGVtXG4gICAgICAgIHRoaXMucHJvcExpc3QuZm9yRWFjaChwcm9wT2JqZWN0ID0+IHtcbiAgICAgICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1wcm9wLWl0ZW0nKTtcbiAgICAgICAgICAgIGVsLnNldFByb3BlcnR5KHByb3BPYmplY3QsIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCduYW1lJywgcHJvcE9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMubmV3UHJvcFR5cGVTZWxlY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbkRlZmF1bHROZXdUeXBlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5uZXdQcm9wVHlwZVNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uRGVmYXVsdE5ld1R5cGVDaGFuZ2UpO1xuICAgIH1cblxuICAgIG9uRGVmYXVsdE5ld1R5cGVDaGFuZ2UoZXZlbnQpe1xuICAgICAgICBsZXQgb3B0aW9uID0gZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9uc1swXTtcbiAgICAgICAgc3dpdGNoKG9wdGlvbi52YWx1ZSl7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgXCJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbnVtYmVyJyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG9wdGlvbi52YWx1ZSA9PSBcIlwiKXtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DYXJldENsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IG5ld1Byb3BBcmVhID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbmV3LXByb3AtYXJlYScpO1xuICAgICAgICBuZXdQcm9wQXJlYS5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJyk7XG4gICAgfVxuXG4gICAgb25DcmVhdGVTdWJtaXQoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIGxldCBwcm9wTmFtZSA9IHRoaXMubmV3UHJvcE5hbWVJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIGxldCBkZWZhdWx0VmFsdWUgPSB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudmFsdWU7XG4gICAgICAgICAgICBpZih0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudHlwZSA9PSAnY2hlY2tib3gnKXtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuY2hlY2tlZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudHlwZSA9PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBwcm9wZXJ0eSBjcmVhdGUgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbmV3UHJvcGVydHknLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuaWRcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjcmVhdGVkIHByb3AgdG8gdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIHZhbHVlXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFJlLXJlbmRlciB0aGlzIHBhbmVcbiAgICAgICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlckJ5KHRleHQpe1xuICAgICAgICAvLyBGaW5kIGFsbCBvZiB0aGUgcHJvcCBpdGVtIGVsZW1lbnRzIHdob3NlXG4gICAgICAgIC8vIHByb3BlcnR5IG5hbWUgZG9lcyAqbm90KiBpbmNsdWRlIHRoZSBzdWJzdHJpbmcsXG4gICAgICAgIC8vIGFuZCBzZXQgdGhvc2UgdG8gbm90IGRpc3BsYXlcbiAgICAgICAgbGV0IGFsbEVsZW1lbnRzID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2VkaXRvci1wcm9wLWl0ZW0nKSk7XG4gICAgICAgIGFsbEVsZW1lbnRzLmZvckVhY2gocHJvcEVsID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJvcEVsLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRleHQpKXtcbiAgICAgICAgICAgICAgICBwcm9wRWwuY2xhc3NMaXN0LnJlbW92ZSgnaXRlbS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcEVsLmNsYXNzTGlzdC5hZGQoJ2l0ZW0taGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uRmlsdGVySW5wdXQoZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlckJ5KGV2ZW50LnRhcmdldC52YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBvbkZpbHRlckNsZWFyQ2xpY2soZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5maWx0ZXJCeShcIlwiKTtcbiAgICB9XG5cbiAgICByZXNldEZvcm0oKXtcbiAgICAgICAgdGhpcy5uZXdQcm9wTmFtZUlucHV0LnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYodGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnR5cGUgPT0gJ2NoZWNrZWQnKXtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMubmV3UHJvcFR5cGVTZWxlY3Quc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JDdXN0b21MaXN0LFxuICAgIEVkaXRvckN1c3RvbUxpc3QgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBpbnRlcnByZXRlclNlbWFudGljcyBmcm9tICcuLi8uLi8uLi9vaG0vaW50ZXJwcmV0ZXItc2VtYW50aWNzLmpzJztcbmltcG9ydCB7b25Mb2NhdGlvbkxpbmtDbGljaywgZ2V0TG9jYXRpb25TdHJpbmdGb3J9IGZyb20gJy4vdXRpbHMvc3VicGFydHMuanMnO1xuXG4vLyBQUkVBTUJMRVxuY29uc3QgYXJyb3dMZWZ0SWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1hcnJvdy1uYXJyb3ctbGVmdFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxsaW5lIHgxPVwiNVwiIHkxPVwiMTJcIiB4Mj1cIjE5XCIgeTI9XCIxMlwiIC8+XG4gIDxsaW5lIHgxPVwiNVwiIHkxPVwiMTJcIiB4Mj1cIjlcIiB5Mj1cIjE2XCIgLz5cbiAgPGxpbmUgeDE9XCI1XCIgeTE9XCIxMlwiIHgyPVwiOVwiIHkyPVwiOFwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGNsaXBib2FyZEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2xpcGJvYXJkXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk05IDVoLTJhMiAyIDAgMCAwIC0yIDJ2MTJhMiAyIDAgMCAwIDIgMmgxMGEyIDIgMCAwIDAgMiAtMnYtMTJhMiAyIDAgMCAwIC0yIC0yaC0yXCIgLz5cbiAgPHJlY3QgeD1cIjlcIiB5PVwiM1wiIHdpZHRoPVwiNlwiIGhlaWdodD1cIjRcIiByeD1cIjJcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCguaGlkZGVuKXtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgLmJ1dHRvbi1saW5rIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC4zKTtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgZWFzZS1vdXQ7XG4gICAgICAgIHZlcnRpY2FsLWFsaWdubWVudDogY2VudGVyO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgcGFkZGluZzogMHB4O1xuICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICB9XG5cbiAgICAuYnV0dG9uLWxpbms6aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuNyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIC5idXR0b24tbGluayA+IHN2ZyB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA4cHg7XG4gICAgICAgIG9wYWNpdHk6IDAuNztcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDBweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgLmJ1dHRvbi1saW5rOmhvdmVyID4gc3ZnIHtcbiAgICAgICAgb3BhY2l0eTogMS4wO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTVweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuPC9zdHlsZT5cbjxwIGNsYXNzPVwicGFydC1pbmZvXCI+XG4gICAgTXkgPGJ1dHRvbiBpZD1cIm93bmVyLWxpbmtcIiBjbGFzcz1cImJ1dHRvbi1saW5rXCIgdGl0bGU9XCJcIj48c3Bhbj48L3NwYW4+JHthcnJvd0xlZnRJY29ufTwvYnV0dG9uPiBpcyBuYW1lZCA8c3BhbiBjbGFzcz1cInBhcnQtbmFtZVwiPjwvc3Bhbj4gYW5kIGlzIGxvY2F0ZWQgYXQgPGJ1dHRvbiBpZD1cImxvY2F0aW9uLWxpbmtcIiBjbGFzcz1cImJ1dHRvbi1saW5rXCIgdGl0bGU9XCJDb3B5IGxvY2F0aW9uXCI+PHNwYW4+PC9zcGFuPiR7Y2xpcGJvYXJkSWNvbn08L2J1dHRvbj4gPGJ1dHRvbiBpZD1cImlkLWxpbmtcIiBjbGFzcz1cImJ1dHRvbi1saW5rXCIgdGl0bGU9XCJDb3B5IGlkXCI+PHNwYW4+Q29weSBpZDwvc3Bhbj4ke2NsaXBib2FyZEljb259PC9idXR0b24+XG48L3A+XG5gO1xuXG5jbGFzcyBFZGl0b3JMb2NhdGlvbkluZm8gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWNjZXB0ZWQgdmFsdWVzIGZvciB0aGUga2luZCBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5hbGxvd2VkS2luZHMgPSBbJ3N0YWNrJywgJ2NhcmQnLCAnb3duZXInXTtcblxuICAgICAgICAvLyBkZWZpbmUgYW5kIGJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uU3RyaW5nRm9yID0gZ2V0TG9jYXRpb25TdHJpbmdGb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrID0gb25Mb2NhdGlvbkxpbmtDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5oYW5kbGVTdGFja0tpbmQgPSB0aGlzLmhhbmRsZVN0YWNrS2luZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNhcmRLaW5kID0gdGhpcy5oYW5kbGVDYXJkS2luZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUluZm8gPSB0aGlzLnVwZGF0ZUluZm8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRBbmNlc3Rvck9mVHlwZUZvciA9IHRoaXMuZ2V0QW5jZXN0b3JPZlR5cGVGb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzID0gdGhpcy5nZXRMb2NhdGlvblZpZXdzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MaW5rQ2xpY2sgPSB0aGlzLm9uTGlua0NsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZUVudGVyID0gdGhpcy5vbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTGVhdmUgPSB0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIC8vIEV2ZW50c1xuICAgICAgICBsZXQgb3duZXJMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnb3duZXItbGluaycpO1xuICAgICAgICBsZXQgbG9jYXRpb25MaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbG9jYXRpb24tbGluaycpO1xuICAgICAgICBsZXQgaWRMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaWQtbGluaycpO1xuICAgICAgICBvd25lckxpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTGlua0NsaWNrKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uQ2xpY2spO1xuICAgICAgICBpZExpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25DbGljayk7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuICAgICAgICBpZExpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgICAgIGlkTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGxldCBvd25lckxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdvd25lci1saW5rJyk7XG4gICAgICAgIGxldCBsb2NhdGlvbkxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1saW5rJyk7XG4gICAgICAgIGxldCBpZExpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdpZC1saW5rJyk7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkNsaWNrKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uQ2xpY2spO1xuICAgICAgICBvd25lckxpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgICAgIGlkTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuICAgICAgICBsb2NhdGlvbkxpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIGxldCBraW5kID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2tpbmQnKTtcbiAgICAgICAgaWYoIWtpbmQgfHwgIXRoaXMuYWxsb3dlZEtpbmRzLmluY2x1ZGVzKGtpbmQpKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICd3b3JsZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGVsZW1lbnQgcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLm93bmVyTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ293bmVyLWxpbmsnKTtcbiAgICAgICAgdGhpcy5vd25lckxpbmtUeXBlU3BhbiA9IHRoaXMub3duZXJMaW5rQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1saW5rJyk7XG4gICAgICAgIHRoaXMubG9jYXRpb25MaW5rU3BhbiA9IHRoaXMubG9jYXRpb25MaW5rQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5pZExpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdpZC1saW5rJyk7XG4gICAgICAgIHRoaXMuaWRMaW5rU3BhbiA9IHRoaXMuaWRMaW5rQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5uYW1lU3BhbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcigncCAucGFydC1uYW1lJyk7XG5cbiAgICAgICAgaWYoa2luZCA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RhY2tLaW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZihraW5kID09J2NhcmQnKXtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2FyZEtpbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5mbygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSW5mbygpe1xuICAgICAgICBsZXQga2luZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdraW5kJyk7XG4gICAgICAgIGxldCBhbmNlc3RvciA9IHRoaXMubW9kZWwuX293bmVyO1xuICAgICAgICBpZihraW5kID09ICdzdGFjaycgfHwga2luZCA9PSAnY2FyZCcpe1xuICAgICAgICAgICAgYW5jZXN0b3IgPSB0aGlzLmdldEFuY2VzdG9yT2ZUeXBlRm9yKHRoaXMubW9kZWwsIGtpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgY2Fubm90IGZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuXG4gICAgICAgIC8vIGtpbmQsIHRoZW4gd2UgaGlkZSB0aGlzIGZpZWxkXG4gICAgICAgIGlmKCFhbmNlc3Rvcil7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG5hbWUgc3BhblxuICAgICAgICBsZXQgYW5jZXN0b3JOYW1lID0gYW5jZXN0b3IucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIGFuY2VzdG9yLFxuICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICk7XG4gICAgICAgIGlmKCFhbmNlc3Rvck5hbWUpe1xuICAgICAgICAgICAgYW5jZXN0b3JOYW1lID0gJyh1bm5hbWVkKSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNlc3Rvck5hbWUgPSBgXCIke2FuY2VzdG9yTmFtZX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lU3Bhbi50ZXh0Q29udGVudCA9IGFuY2VzdG9yTmFtZTtcblxuICAgICAgICAvLyBVcGRhdGUga2luZCBzcGFuXG4gICAgICAgIGxldCBraW5kTGFiZWwgPSBraW5kWzBdLnRvVXBwZXJDYXNlKCkgKyBraW5kLnNsaWNlKDEpO1xuICAgICAgICB0aGlzLm93bmVyTGlua1R5cGVTcGFuLnRleHRDb250ZW50ID0ga2luZExhYmVsO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBsb2NhdGlvbiBsaW5rIHNwYW5cbiAgICAgICAgdGhpcy5sb2NhdGlvbkxpbmtTcGFuLnRleHRDb250ZW50ID0gdGhpcy5nZXRMb2NhdGlvblN0cmluZ0ZvcihhbmNlc3Rvcik7XG5cbiAgICAgICAgLy8gVXBkYXRlIGJ1dHRvbiB0aXRsZXNcbiAgICAgICAgbGV0IGVkaXRUaXRsZSA9IGBFZGl0IG93bmluZyAke2tpbmRMYWJlbH1gO1xuICAgICAgICBpZihraW5kID09ICdvd25lcicpe1xuICAgICAgICAgICAgZWRpdFRpdGxlID0gJ0VkaXQgT3duZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3duZXJMaW5rQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICd0aXRsZScsXG4gICAgICAgICAgICBlZGl0VGl0bGVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgdGhlIHJlZi1pZCBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JlZi1pZCcsIGFuY2VzdG9yLmlkKTtcbiAgICB9XG5cbiAgICBoYW5kbGVTdGFja0tpbmQoKXtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICdzdGFjaycgfHwgdGhpcy5tb2RlbC50eXBlID09ICd3b3JsZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUluZm8oKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDYXJkS2luZCgpe1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ2NhcmQnIHx8IHRoaXMubW9kZWwudHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbmZvKCk7XG4gICAgfVxuXG4gICAgZ2V0QW5jZXN0b3JPZlR5cGVGb3IoYVBhcnQsIGFUeXBlKXtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGN1cnJlbnRPd25lciA9IGFQYXJ0Ll9vd25lcjtcbiAgICAgICAgd2hpbGUoY3VycmVudE93bmVyKXtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRPd25lci50eXBlID09IGFUeXBlKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXJyZW50T3duZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50T3duZXIgPSBjdXJyZW50T3duZXIuX293bmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgb25MaW5rQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmLWlkJyk7XG4gICAgICAgIGlmKGlkICYmIHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgLy8gUmUtcmVuZGVyIHRoZSBlZGl0b3Igb24gdGhlIFBhcnRcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZWQgYnkgdGhlIGZvdW5kIGlkXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbaWRdO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5lZGl0b3IucmVuZGVyKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlRW50ZXIoZXZlbnQpe1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MoZXZlbnQpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0KFwicmdiKDU0LCAxNzIsIDEwMClcIik7IC8vIGdyZWVuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uTW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyhldmVudCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRMb2NhdGlvblZpZXdzKGV2ZW50KXtcbiAgICAgICAgbGV0IHRhcmdldElkO1xuICAgICAgICBsZXQgc3BhbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICBpZihzcGFuLnBhcmVudEVsZW1lbnQuaWQgPT0gJ2lkLWxpbmsnKXtcbiAgICAgICAgICAgIHRhcmdldElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZi1pZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbWFudGljcyA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJTZW1hbnRpY3Mod2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbJ3dvcmxkJ10sIHdpbmRvdy5TeXN0ZW0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IG0gPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIubWF0Y2goc3Bhbi50ZXh0Q29udGVudCwgXCJPYmplY3RTcGVjaWZpZXJcIik7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobSkuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjYW5ub3QgbG9jYXRlICR7c3Bhbi50ZXh0Q29udGVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5maW5kVmlld3NCeUlkKHRhcmdldElkKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvckxvY2F0aW9uSW5mbyxcbiAgICBFZGl0b3JMb2NhdGlvbkluZm8gYXMgZGVmYXVsdFxufTtcbiIsIlxuXG4vLyBQUkVBTUJMRVxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cbiAgIFxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcmVzaXplOiBub25lO1xuICAgICAgICBmbGV4OiAwLjI1O1xuICAgIH1cbjwvc3R5bGU+XG48aDM+U2VuZCB0aGlzIDxzcGFuPjwvc3Bhbj4gYSBNZXNzYWdlOjwvaDM+XG48dGV4dGFyZWEgcGxhY2Vob2xkZXI9XCJUeXBlIHlvdXIgU2ltcGxldGFsayBtZXNzYWdlIGhlcmUuLi5cIj48L3RleHRhcmVhPlxuPGJ1dHRvbj5TZW5kPC9idXR0b24+XG5gO1xuXG5jbGFzcyBFZGl0b3JNZXNzZW5nZXIgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25NZXNzYWdlRmllbGRJbnB1dCA9IHRoaXMub25NZXNzYWdlRmllbGRJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQgPSB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQpO1xuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUZpZWxkID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uTWVzc2FnZUZpZWxkSW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5tZXNzYWdlRmllbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uTWVzc2FnZUZpZWxkSW5wdXQpO1xuICAgICAgICB0aGlzLnNlbmRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQpO1xuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICBcbiAgICAgICAgbGV0IHBhcnRUeXBlTGFiZWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2gzID4gc3BhbicpO1xuICAgICAgICBwYXJ0VHlwZUxhYmVsLnRleHRDb250ZW50ID0gdGhpcy5tb2RlbC50eXBlO1xuICAgIH1cblxuICAgIG9uTWVzc2FnZUZpZWxkSW5wdXQoZXZlbnQpe1xuXG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2VGcm9tVGV4dCgpe1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMubWVzc2FnZUZpZWxkLnZhbHVlO1xuICAgICAgICBsZXQgc2NyaXB0ID0gYG9uIGRvSXRcXG5cXHQke3RleHR9XFxuZW5kIGRvSXRgO1xuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21waWxlJyxcbiAgICAgICAgICAgIGNvZGVTdHJpbmc6IHNjcmlwdCxcbiAgICAgICAgICAgIHRhcmdldElkOiB0aGlzLm1vZGVsLmlkXG4gICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnZG9JdCcsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvck1lc3NlbmdlcixcbiAgICBFZGl0b3JNZXNzZW5nZXIgYXMgZGVmYXVsdFxufTtcbiIsIi8vIFBSRUFNQkxFXG5cbmNvbnN0IGNoZWNrSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jaXJjbGUtY2hlY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwYjM0MVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjlcIiAvPlxuICA8cGF0aCBkPVwiTTkgMTJsMiAybDQgLTRcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjYW5jZWxJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNpcmNsZS14XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiNmZjI4MjVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI5XCIgLz5cbiAgPHBhdGggZD1cIk0xMCAxMGw0IDRtMCAtNGwtNCA0XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgbGkge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIHBhZGRpbmc6IDZweDtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcbiAgICAgICAgbWFyZ2luLXRvcDogNnB4O1xuICAgIH1cbiAgIFxuICAgIGxpID4gbGFiZWwge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cblxuICAgIDpob3N0IHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgOmhvc3QoLml0ZW0taGlkZGVuKSB7XG4gICAgICAgIGRpc3BsYXk6bm9uZTtcbiAgICB9XG5cbiAgICBidXR0b24ge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIG9wYWNpdHk6IDEuMDtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGxpbmVhcjtcbiAgICB9XG5cbiAgICBidXR0b246ZGlzYWJsZWQge1xuICAgICAgICBvcGFjaXR5OiAwLjA1O1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5OiAwLjFzIGxpbmVhcjtcbiAgICB9XG5cbiAgICBidXR0b246aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuXG4gICAgYnV0dG9uLmJ1dHRvbi1oaWRkZW4ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgIGxhYmVsIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICB9XG5cbiAgICBpbnB1dCB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjUpO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgIH1cbiAgICBcbiAgICBpbnB1dDpmb2N1cyB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC44KTtcbiAgICB9XG48L3N0eWxlPlxuPGxpPlxuICAgIDxsYWJlbCBmb3I9XCJwcm9wLXZhbHVlXCI+PC9sYWJlbD5cbiAgICA8aW5wdXQgaWQ9XCJwcm9wLXZhbHVlXCIgbmFtZT1cInByb3AtdmFsdWVcIi8+XG4gICAgPGJ1dHRvbiBpZD1cImFjY2VwdFwiIGRpc2FibGVkPiR7Y2hlY2tJY29ufTwvYnV0dG9uPlxuICAgIDxidXR0b24gaWQ9XCJjYW5jZWxcIiBkaXNhYmxlZD4ke2NhbmNlbEljb259PC9idXR0b24+XG48L2xpPlxuYDtcblxuY2xhc3MgRWRpdG9yUHJvcEl0ZW0gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlcmUgaXMgbm8gcHJvcGVydHlcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSW5wdXRDaGFuZ2UgPSB0aGlzLm9uSW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbklucHV0SW5wdXQgPSB0aGlzLm9uSW5wdXRJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQWNjZXB0Q2xpY2sgPSB0aGlzLm9uQWNjZXB0Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNhbmNlbENsaWNrID0gdGhpcy5vbkNhbmNlbENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25FbnRlcktleSA9IHRoaXMub25FbnRlcktleS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwTnVtZXJpY0lucHV0ID0gdGhpcy5zZXR1cE51bWVyaWNJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuYWJsZUJ1dHRvbnMgPSB0aGlzLmVuYWJsZUJ1dHRvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucyA9IHRoaXMuZGlzYWJsZUJ1dHRvbnMuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzZXRQcm9wZXJ0eShhUHJvcGVydHksIGFuT3duZXIpe1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IGFQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5vd25lciA9IGFuT3duZXI7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlbGVtZW50IGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCB0aGlzLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnb3duZXItaWQnLCB0aGlzLm93bmVyLmlkKTtcblxuICAgICAgICAvLyBBZGQgbmV3IGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMub25FbnRlcktleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5vbkVudGVyS2V5KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKXtcbiAgICAgICAgdGhpcy5sYWJlbEVsZW1lbnQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJyk7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2FjY2VwdCcpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2NhbmNlbCcpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgaGlkZSBjbGFzc2VzXG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2J1dHRvbi1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYnV0dG9uLWhpZGRlbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBib3VuZCBldmVudHNcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXRJbnB1dCk7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25JbnB1dENoYW5nZSk7XG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkFjY2VwdENsaWNrKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2FuY2VsQ2xpY2spO1xuXG4gICAgICAgIC8vIEFkZCBuZXcgZXZlbnRzXG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0SW5wdXQpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uSW5wdXRDaGFuZ2UpO1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25BY2NlcHRDbGljayk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNhbmNlbENsaWNrKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubGFiZWxFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGhpcy5wcm9wZXJ0eS5uYW1lfTpgO1xuICAgICAgICBsZXQgY3VycmVudFZhbCA9IHRoaXMucHJvcGVydHkuZ2V0VmFsdWUodGhpcy5vd25lcik7XG4gICAgICAgIGlmKGN1cnJlbnRWYWwgPT0gbnVsbCB8fCBjdXJyZW50VmFsID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAvLyBEbyBzb21ldGhpbmcgZGlmZmVyZW50IGhlcmVcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihjdXJyZW50VmFsKSA9PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICB0aGlzLnNldHVwTnVtZXJpY0lucHV0KCk7XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YoY3VycmVudFZhbCkgPT0gJ2Jvb2xlYW4nKXtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuY2hlY2tlZCA9IGN1cnJlbnRWYWw7XG4gICAgICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidXR0b24taGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidXR0b24taGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIGN1cnJlbnRWYWwpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IGN1cnJlbnRWYWw7XG4gICAgfVxuXG4gICAgc2V0dXBOdW1lcmljSW5wdXQoKXtcbiAgICAgICAgaWYodGhpcy5wcm9wZXJ0eS5uYW1lLmVuZHNXaXRoKCctdHJhbnNwYXJlbmN5Jykpe1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3JhbmdlJyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0ZXAnLCAnMC4wNScpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdtaW4nLCAnMC4wJyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21heCcsICcxLjAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdudW1iZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSW5wdXRDaGFuZ2UoZXZlbnQpe1xuICAgICAgICBpZihldmVudC50YXJnZXQudHlwZSA9PSBcImNoZWNrYm94XCIpe1xuICAgICAgICAgICAgdGhpcy5vd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25JbnB1dElucHV0KGV2ZW50KXtcbiAgICAgICAgbGV0IGlucHV0VHlwZSA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgaWYoaW5wdXRUeXBlID09ICdyYW5nZScpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25BY2NlcHRDbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC52YWx1ZSAhPT0gdGhpcy5wcm9wZXJ0eS5nZXRWYWx1ZSh0aGlzLm93bmVyKSl7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRW50ZXJLZXkoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5rZXkgPT0gJ0VudGVyJyl7XG4gICAgICAgICAgICB0aGlzLm9uQWNjZXB0Q2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuYWJsZUJ1dHRvbnMoKXtcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgZGlzYWJsZUJ1dHRvbnMoKXtcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgb25BY2NlcHRDbGljayhldmVudCl7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgICAgICBpZih0aGlzLmlucHV0RWxlbWVudC50eXBlID09ICdudW1iZXInKXtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBpZihpc05hTih2YWx1ZSkpe1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IHBhcnNlIHRoZSB2YWx1ZSBqdXN0IGxldCBpdCBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQgbWlnaHQgYmUgYSBwcm9wIHN0eWxlIGtleXdvcmQgc3VjaCBhcyBcImZpbGxcIlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIG1pZ2h0IHdhbnQgdG8gbGltaXQgdGhpcyB0byBhIHNldCBvZiBwcm9wIGtleXdvcmRzXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuaW5wdXRFbGVtZW50LnR5cGUgPT0gJ3JhbmdlJyl7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5pbnB1dEVsZW1lbnQudHlwZSA9PSAnY2hlY2tib3gnKXtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnB1dEVsZW1lbnQuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm93bmVyLFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucygpO1xuICAgIH1cblxuICAgIG9uQ2FuY2VsQ2xpY2soZXZlbnQpe1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IHRoaXMub3duZXIucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMub3duZXIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5Lm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucygpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yUHJvcEl0ZW0sXG4gICAgRWRpdG9yUHJvcEl0ZW0gYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBFZGl0b3JQcm9wSXRlbSBmcm9tICcuL0VkaXRvclByb3BJdGVtLmpzJztcblxuLy8gUFJFQU1CTEVcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1wcm9wLWl0ZW0nLCBFZGl0b3JQcm9wSXRlbSk7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgICAgICBmb250LXNpemU6IDAuOHJlbTtcbiAgICB9XG5cbiAgICAjcHJvcHMtbGlzdCB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB9XG4gICAgI2ZpbHRlci1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuICAgICNmaWx0ZXItYXJlYSA+IGlucHV0IHtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOiAxLjByZW07XG4gICAgICAgIHBhZGRpbmctbGVmdDogNnB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiA2cHg7XG4gICAgICAgIHBhZGRpbmctdG9wOiAzcHg7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAzcHg7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC44KTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwiZmlsdGVyLWFyZWFcIj5cbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImZpbHRlci1pbnB1dFwiIG5hbWU9XCJmaWx0ZXItaW5wdXRcIiBwbGFjZWhvbGRlcj1cIkZpbHRlci4uLlwiLz5cbiAgICA8YnV0dG9uIGlkPVwiY2xlYXJcIj5DbGVhcjwvYnV0dG9uPlxuPC9kaXY+XG48dWwgaWQ9XCJwcm9wcy1saXN0XCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC91bD5cbmA7XG5cbmNvbnN0IHNwZWNpYWxQcm9wcyA9IFtcbiAgICAnY3NzU3R5bGUnLFxuICAgICdjc3NUZXh0U3R5bGUnLFxuICAgICdpZCcsXG4gICAgJ25hbWUnLFxuICAgICd0YXJnZXQnLFxuICAgICdldmVudHMnLFxuICAgICdjdXJyZW50JyxcbiAgICAnc2NyaXB0JyxcbiAgICAnY3VzdG9tLXByb3BlcnRpZXMnXG5dO1xuXG5jbGFzcyBFZGl0b3JQcm9wTGlzdCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbklucHV0ID0gdGhpcy5vbklucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25GaWx0ZXJDbGVhckNsaWNrID0gdGhpcy5vbkZpbHRlckNsZWFyQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5wdXRFbGVtZW50ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLWlucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnY2xlYXInKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcblxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgbWFpbiBET00gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBsZXQgaW5wdXRFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpO1xuICAgICAgICBpbnB1dEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0KTtcbiAgICAgICAgaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25JbnB1dCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc29ydGVkIGNvcHkgb2YgdGhlIHByb3BlcnR5IG9iamVjdHNcbiAgICAgICAgdGhpcy5wcm9wTGlzdCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuYWxsLnNsaWNlKCkuZmlsdGVyKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc3BlY2lhbFByb3BzLmluY2x1ZGVzKHByb3AubmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9wTGlzdFxuICAgICAgICAgICAgLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdC5uYW1lLmxvY2FsZUNvbXBhcmUoc2Vjb25kLm5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIGxpc3QgaXRlbSBlbGVtZW50cyBhbmQgaW5zZXJ0IHRoZW1cbiAgICAgICAgdGhpcy5wcm9wTGlzdC5mb3JFYWNoKHByb3BPYmplY3QgPT4ge1xuICAgICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLXByb3AtaXRlbScpO1xuICAgICAgICAgICAgZWwuc2V0UHJvcGVydHkocHJvcE9iamVjdCwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBwcm9wT2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZpbHRlckJ5KHRleHQpe1xuICAgICAgICAvLyBGaW5kIGFsbCBvZiB0aGUgcHJvcCBpdGVtIGVsZW1lbnRzIHdob3NlXG4gICAgICAgIC8vIHByb3BlcnR5IG5hbWUgZG9lcyAqbm90KiBpbmNsdWRlIHRoZSBzdWJzdHJpbmcsXG4gICAgICAgIC8vIGFuZCBzZXQgdGhvc2UgdG8gbm90IGRpc3BsYXlcbiAgICAgICAgbGV0IGFsbEVsZW1lbnRzID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2VkaXRvci1wcm9wLWl0ZW0nKSk7XG4gICAgICAgIGFsbEVsZW1lbnRzLmZvckVhY2gocHJvcEVsID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJvcEVsLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRleHQpKXtcbiAgICAgICAgICAgICAgICBwcm9wRWwuY2xhc3NMaXN0LnJlbW92ZSgnaXRlbS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcEVsLmNsYXNzTGlzdC5hZGQoJ2l0ZW0taGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uSW5wdXQoZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlckJ5KGV2ZW50LnRhcmdldC52YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBvbkZpbHRlckNsZWFyQ2xpY2soZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0RWxlbWVudC52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZmlsdGVyQnkoXCJcIik7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JQcm9wTGlzdCxcbiAgICBFZGl0b3JQcm9wTGlzdCBhcyBkZWZhdWx0XG59O1xuIiwiLy8gUFJFQU1CTEVcbmltcG9ydCBFZGl0b3JMb2NhdGlvbkluZm8gZnJvbSAnLi9FZGl0b3JMb2NhdGlvbkluZm8uanMnO1xuaW1wb3J0IHBhcnRJY29ucyBmcm9tICcuLi8uLi91dGlscy9pY29ucy5qcyc7XG5pbXBvcnQge29uTG9jYXRpb25MaW5rQ2xpY2ssIGdldExvY2F0aW9uU3RyaW5nRm9yfSBmcm9tICcuL3V0aWxzL3N1YnBhcnRzLmpzJztcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLWxvY2F0aW9uLWluZm8nLCBFZGl0b3JMb2NhdGlvbkluZm8pO1xuXG5jb25zdCBjbGlwYm9hcmRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNsaXBib2FyZFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNOSA1aC0yYTIgMiAwIDAgMCAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTBhMiAyIDAgMCAwIDIgLTJ2LTEyYTIgMiAwIDAgMCAtMiAtMmgtMlwiIC8+XG4gIDxyZWN0IHg9XCI5XCIgeT1cIjNcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCI0XCIgcng9XCIyXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cblxuICAgIDpob3N0KCkgPiBsaSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgICB9XG5cbiAgICAuaWQtbGluayxcbiAgICAubG9jYXRpb24tbGluayB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGVhc2Utb3V0O1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbm1lbnQ6IGNlbnRlcjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIHBhZGRpbmc6IDBweDtcbiAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgfVxuXG4gICAgLmlkLWxpbms6aG92ZXIsXG4gICAgLmxvY2F0aW9uLWxpbms6aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuNyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIC5pZC1saW5rID4gc3ZnLFxuICAgIC5sb2NhdGlvbi1saW5rID4gc3ZnIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgb3BhY2l0eTogMC43O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMHB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBlYXNlLW91dDtcbiAgICB9XG5cbiAgICAuaWQtbGluazpob3ZlciA+IHN2ZyxcbiAgICAubG9jYXRpb24tbGluazpob3ZlciA+IHN2ZyB7XG4gICAgICAgIG9wYWNpdHk6IDEuMDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01cHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIHNlY3Rpb24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBtYXJnaW46IDZweDtcbiAgICB9XG5cbiAgICAjYnV0dG9uLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsnXG4gICAgfVxuXG4gICAgI3N1YnBhcnRzLWxpc3Qtd3JhcHBlciB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuaGlkZGVuIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICAjc3VicGFydHMtYXJlYSB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBtYXJnaW4tbGVmdDogMzJweDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB9XG48L3N0eWxlPlxuPHNlY3Rpb24gaWQ9XCJidXR0b24tYXJlYVwiPlxuICAgIDxzbG90IG5hbWU9XCJidXR0b25cIj48L3Nsb3Q+XG48L3NlY3Rpb24+XG48c2VjdGlvbiBpZD1cImxvY2F0aW9uLWFyZWFcIj5cbiAgICA8aDM+UGFydCBMb2NhdGlvbiBhbmQgT3duZXJzPC9oMz5cbiAgICA8cCBjbGFzcz1cInBhcnQtaW5mb1wiPlxuICAgICAgICBJIGFtIGxvY2F0ZWQgYXQgPGJ1dHRvbiBjbGFzcz1cImxvY2F0aW9uLWxpbmtcIj48c3Bhbj48L3NwYW4+JHtjbGlwYm9hcmRJY29ufTwvYnV0dG9uPlxuICAgICAgICBhbmQgbXkgaWQgaXMgPGJ1dHRvbiBjbGFzcz1cImlkLWxpbmtcIj48c3Bhbj48L3NwYW4+JHtjbGlwYm9hcmRJY29ufTwvYnV0dG9uPlxuICAgIDwvcD5cbiAgICA8c2xvdCBuYW1lPVwiYW5jZXN0b3ItaW5mb1wiPjwvc2xvdD5cbjwvc2VjdGlvbj5cbjxzZWN0aW9uIGlkPVwic3VicGFydHMtbGlzdC13cmFwcGVyXCI+XG4gICAgPGgzPlN1YnBhcnRzPC9oMz5cbiAgICA8b2wgaWQ9XCJzdWJwYXJ0cy1hcmVhXCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L29sPlxuPC9zZWN0aW9uPlxuYDtcblxuY2xhc3MgRWRpdG9yU3VicGFydHNQYW5lIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGRlZmluZSBhbmQgYmluZCBtZXRob2RzXG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25TdHJpbmdGb3IgPSBnZXRMb2NhdGlvblN0cmluZ0Zvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2sgPSBvbkxvY2F0aW9uTGlua0NsaWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQWRkU3VicGFydCA9IHRoaXMub25BZGRTdWJwYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TdWJwYXJ0SXRlbUNsaWNrID0gdGhpcy5vblN1YnBhcnRJdGVtQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN1YnBhcnRJdGVtTW91c2VFbnRlciA9IHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN1YnBhcnRJdGVtTW91c2VMZWF2ZSA9IHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVBZGRQYXJ0QnV0dG9uID0gdGhpcy5jcmVhdGVBZGRQYXJ0QnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlU3VicGFydENvbXBvbmVudCA9IHRoaXMuY3JlYXRlU3VicGFydENvbXBvbmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MgPSB0aGlzLmdldExvY2F0aW9uVmlld3MuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1hcmVhJyk7XG4gICAgICAgICAgICB0aGlzLm15TG9jYXRpb25BcmVhID0gdGhpcy5oZWFkZXJFbC5xdWVyeVNlbGVjdG9yKCdwJyk7XG4gICAgICAgICAgICB0aGlzLm15TG9jYXRpb25CdXR0b24gPSB0aGlzLm15TG9jYXRpb25BcmVhLnF1ZXJ5U2VsZWN0b3IoJy5sb2NhdGlvbi1saW5rJyk7XG4gICAgICAgICAgICB0aGlzLm15SWRCdXR0b24gPSB0aGlzLm15TG9jYXRpb25BcmVhLnF1ZXJ5U2VsZWN0b3IoJy5pZC1saW5rJyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciB0byBidXR0b25zXG4gICAgICAgICAgICB0aGlzLm15TG9jYXRpb25CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5teUlkQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMubXlMb2NhdGlvbkJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayk7XG4gICAgICAgIHRoaXMubXlJZEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIHRoaXMuaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1hcmVhJyk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IERPTSBjaGlsZHJlblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cblxuICAgICAgICAvLyBDcmVhdGUgbG9jYXRpb24gbGluayBlbGVtZW50c1xuICAgICAgICAvLyBhbmQgYWxzbyB0aGUgc2VsZi1sb2NhdGlvbiBlbGVtZW50XG4gICAgICAgIGxldCBteUxvY2F0aW9uVGV4dCA9IHRoaXMuZ2V0TG9jYXRpb25TdHJpbmdGb3IodGhpcy5tb2RlbCk7XG4gICAgICAgIHRoaXMubXlMb2NhdGlvbkJ1dHRvbi5xdWVyeVNlbGVjdG9yKCdzcGFuJykudGV4dENvbnRlbnQgPSBteUxvY2F0aW9uVGV4dDtcbiAgICAgICAgdGhpcy5teUlkQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS50ZXh0Q29udGVudCA9IHRoaXMubW9kZWwuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICd3b3JsZCcpe1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgaW5mbyBlbGVtZW50c1xuICAgICAgICAgICAgWydzdGFjaycsICdjYXJkJywgJ293bmVyJ10uZm9yRWFjaChraW5kID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLWxvY2F0aW9uLWluZm8nKTtcbiAgICAgICAgICAgICAgICBpbmZvRWwuc2V0QXR0cmlidXRlKCdzbG90JywgJ2FuY2VzdG9yLWluZm8nKTtcbiAgICAgICAgICAgICAgICBpbmZvRWwuc2V0QXR0cmlidXRlKCdraW5kJywga2luZCk7XG4gICAgICAgICAgICAgICAgaW5mb0VsLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGluZm9FbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgXCJhZGQgc3VicGFydFwiIGJ1dHRvbnMgZm9yIHBhcnRzIHRoYXQgYXJlIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAgICAvLyBjdXJyZW50IE1vZGVsIHBhcnQuXG4gICAgICAgIHRoaXMubW9kZWwuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMuZm9yRWFjaChwYXJ0VHlwZSA9PiB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuY3JlYXRlQWRkUGFydEJ1dHRvbihwYXJ0VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbGFiZWxIZWFkZXIgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNzdWJwYXJ0cy1saXN0LXdyYXBwZXIgPiBoMycpO1xuICAgICAgICBpZih0aGlzLm1vZGVsLnN1YnBhcnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBsYWJlbEhlYWRlci50ZXh0Q29udGVudCA9IFwiQ3VycmVudCBTdWJwYXJ0c1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxIZWFkZXIudGV4dENvbnRlbnQgPSBcIlRoZXJlIGFyZSBubyBzdWJwYXJ0c1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RlbC5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZVN1YnBhcnRDb21wb25lbnQoc3VicGFydCk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjcmVhdGVTdWJwYXJ0Q29tcG9uZW50KGFQYXJ0KXtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ3N1YnBhcnQtaXRlbScpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgncmVmLWlkJywgYVBhcnQuaWQpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblN1YnBhcnRJdGVtQ2xpY2spO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uU3VicGFydEl0ZW1Nb3VzZUVudGVyKTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vblN1YnBhcnRJdGVtTW91c2VMZWF2ZSk7XG5cbiAgICAgICAgLy8gQWRkIGljb24gYXJlYSBhbiBTVkcgZm9yIFBhcnRcbiAgICAgICAgbGV0IGljb25BcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGljb25BcmVhLmNsYXNzTGlzdC5hZGQoJ2ljb24tZGlzcGxheS1hcmVhJyk7XG4gICAgICAgIGxldCBpY29uSW1hZ2U7XG4gICAgICAgIGlmKE9iamVjdC5rZXlzKHBhcnRJY29ucykuaW5jbHVkZXMoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgaWNvbkltYWdlID0gcGFydEljb25zW2FQYXJ0LnR5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWNvbkltYWdlID0gcGFydEljb25zLmdlbmVyaWM7XG4gICAgICAgIH1cbiAgICAgICAgaWNvbkFyZWEuaW5uZXJIVE1MID0gaWNvbkltYWdlO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZChpY29uQXJlYSk7XG5cbiAgICAgICAgLy8gQWRkIGxhYmVsLCBuYW1lLCBhbmQgaWQgaW5mb1xuICAgICAgICBsZXQgbGFiZWxBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICAgICAgbGFiZWxBcmVhLnRleHRDb250ZW50ID0gYGEgJHthUGFydC50eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHthUGFydC50eXBlLnNsaWNlKDEpfWA7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKGxhYmVsQXJlYSk7XG4gICAgICAgIGxldCBuYW1lID0gYVBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIGFQYXJ0LFxuICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICk7XG4gICAgICAgIGlmKG5hbWUgJiYgbmFtZSAhPSBcIlwiKXtcbiAgICAgICAgICAgIGxldCBuYW1lQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIG5hbWVBcmVhLmNsYXNzTGlzdC5hZGQoJ25hbWUtc3BhbicpO1xuICAgICAgICAgICAgbmFtZUFyZWEudGV4dENvbnRlbnQgPSBgXCIke25hbWV9XCJgO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmQobmFtZUFyZWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlkQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgaWRBcmVhLmNsYXNzTGlzdC5hZGQoJ2lkLXNwYW4nKTtcbiAgICAgICAgaWRBcmVhLnRleHRDb250ZW50ID0gYCgke2FQYXJ0LmlkfSlgO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZChpZEFyZWEpO1xuXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIGNyZWF0ZUFkZFBhcnRCdXR0b24oYVBhcnROYW1lKXtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBsZXQgaWNvbiA9IHBhcnRJY29uc1thUGFydE5hbWVdO1xuICAgICAgICBpZighaWNvbil7XG4gICAgICAgICAgICBpY29uID0gcGFydEljb25zLmdlbmVyaWM7XG4gICAgICAgIH1cbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnZGF0YS10eXBlJywgYVBhcnROYW1lKTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBgQWRkIGEgJHthUGFydE5hbWV9IHRvIHRoaXMgJHt0aGlzLm1vZGVsLnR5cGV9YCk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdhZGQtcGFydC1idXR0b24nKTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkFkZFN1YnBhcnQpO1xuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbjtcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG5cbiAgICBvblN1YnBhcnRJdGVtQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgaWQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgncmVmLWlkJyk7XG4gICAgICAgIGxldCB0YXJnZXRQYXJ0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbaWRdO1xuICAgICAgICBpZih0YXJnZXRQYXJ0KXtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZWRpdG9yLnJlbmRlcih0YXJnZXRQYXJ0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU3VicGFydEl0ZW1Nb3VzZUVudGVyKGV2ZW50KXtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzKGV2ZW50KS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LmhpZ2hsaWdodChcInJnYig1NCwgMTcyLCAxMDApXCIpOyAvLyBncmVlblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvblN1YnBhcnRJdGVtTW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyhldmVudCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkFkZFN1YnBhcnQoZXZlbnQpe1xuICAgICAgICBsZXQgdHlwZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKTtcbiAgICAgICAgaWYodHlwZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICduZXdNb2RlbCcsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5tb2RlbCk7XG4gICAgfVxuXG4gICAgZ2V0TG9jYXRpb25WaWV3cyhldmVudCl7XG4gICAgICAgIGxldCB0YXJnZXRJZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdyZWYtaWQnKTtcbiAgICAgICAgbGV0IHNwYW4gPSBldmVudC5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0YXJnZXRJZCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JTdWJwYXJ0c1BhbmUsXG4gICAgRWRpdG9yU3VicGFydHNQYW5lIGFzIGRlZmF1bHRcbn07XG4iLCIvLyBQUkVBTUJMRVxuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBwYWRkaW5nOiA2cHg7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC43KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgbGluZWFyLCBvcGFjaXR5IDAuMnMgbGluZWFyO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG5cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSl7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCByZ2JhKDIwMCwgMCwgMCwgMC45KTtcbiAgICAgICAgb3BhY2l0eTogMS4wO1xuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMC4ycyBsaW5lYXIsIG9wYWNpdHkgMC4ycyBsaW5lYXI7XG4gICAgfVxuXG4gICAgOmhvc3QoOmhvdmVyKXtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbjwvc3R5bGU+XG48c3BhbiBpZD1cImxhYmVsXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC9zcGFuPlxuYDtcblxuY2xhc3MgRWRpdG9yVGFiIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRhYiBpcyBjdXJyZW50bHkgYWN0aXZhdGVkLCBlbWl0XG4gICAgICAgICAgICAvLyB0aGUgdGFiLWFjdGl2YWVkIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKSA9PSBcInRydWVcIil7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwidGFiLWFjdGl2YXRlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGxldCBpc0FjdGl2ZSA9ICh0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlJykgPT0gXCJ0cnVlXCIpO1xuICAgICAgICBpZighaXNBY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJ0YWItYWN0aXZhdGVkXCIsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvclRhYixcbiAgICBFZGl0b3JUYWIgYXMgZGVmYXVsdFxufTtcbiIsIiBjb25zdCBnZXRMb2NhdGlvblN0cmluZ0ZvciA9IChhUGFydCkgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXJ0ID0gYVBhcnQ7XG4gICAgICAgIGxldCBjdXJyZW50T3duZXIgPSBhUGFydC5fb3duZXI7XG4gICAgICAgIHdoaWxlKGN1cnJlbnRPd25lcil7XG4gICAgICAgICAgICBsZXQgaW5kZXhJblBhcmVudCA9IGN1cnJlbnRPd25lci5zdWJwYXJ0cy5maWx0ZXIoKHN1YnBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09IGN1cnJlbnRQYXJ0LnR5cGU7XG4gICAgICAgICAgICB9KS5pbmRleE9mKGN1cnJlbnRQYXJ0KSArIDE7XG4gICAgICAgICAgICByZXN1bHQgKz0gYCR7Y3VycmVudFBhcnQudHlwZX0gJHtpbmRleEluUGFyZW50fSBvZiBgO1xuICAgICAgICAgICAgY3VycmVudFBhcnQgPSBjdXJyZW50UGFydC5fb3duZXI7XG4gICAgICAgICAgICBjdXJyZW50T3duZXIgPSBjdXJyZW50T3duZXIuX293bmVyO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAndGhpcyB3b3JsZCc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuY29uc3Qgb25Mb2NhdGlvbkxpbmtDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgdGV4dCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3Rvcignc3BhbicpLnRleHRDb250ZW50O1xuICAgICAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGlucHV0LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChpbnB1dCk7XG4gICAgICAgIGxldCBjdXJyZW50Rm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHRleHQ7XG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0LnZhbHVlKTtcbiAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgICAgIGlucHV0LnJlbW92ZSgpO1xuICAgICAgICBjdXJyZW50Rm9jdXMuZm9jdXMoKTtcbn1cblxuZXhwb3J0IHtcbiAgICBnZXRMb2NhdGlvblN0cmluZ0ZvcixcbiAgICBvbkxvY2F0aW9uTGlua0NsaWNrXG59O1xuIiwiLyoqXG4gKiBOYXZpZ2F0b3IgQ2FyZCBSb3dcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgdmlldyBvbiBhIGdpdmVuIFN0YWNrIHRoYXQgc2hvd3MgZWFjaFxuICogc3VicGFydCBjYXJkIGl0ZW0gYXMgYSB3cmFwcGVkIGxlbnMgdmlldyBhbG9uZ1xuICogYSByb3cuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgfVxuPC9zdHlsZT5cbjxzbG90IG5hbWU9XCJjYXJkc1wiPjwvc2xvdD5cbmA7XG5cbmNsYXNzIENhcmRSb3cgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCB1cCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuaW5pdFZpZXcgPSB0aGlzLmluaXRWaWV3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkV3JhcHBlZENhcmQgPSB0aGlzLmFkZFdyYXBwZWRDYXJkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSA9IHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRBZGRlZCA9IHRoaXMuaGFuZGxlUGFydEFkZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQgPSB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2hvd0luaXRpYWxseSA9IHRoaXMuc2hvd0luaXRpYWxseS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV3JhcHBlckNsaWNrID0gdGhpcy5vbldyYXBwZXJDbGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIGNvbnRleHQgbWVudSB0byBvcGVuIGluIHRoZSBuYXYgc2luY2VcbiAgICAgICAgLy8gaXQgZG9lbnMndCBtYWtlIHNlbnNlIGF0bSBhbmQgd2lsbCBlcnJvclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NhcmQtaWQnLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2N1cnJlbnQnLCB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIFN0YWNrIE1vZGVsJ3MgbWFpbiB2aWV3IGVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGFkZCB0aGUgc3Qtdmlldy1hZGRlZC9yZW1vdmVkIEN1c3RvbUV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAvLyBoZXJlIHNvIHdlIGNhbiByZWFjdCBvbmx5IHRvIGRpcmVjdCBzdGFjayBhZGRpdGlvbnNcbiAgICAgICAgLy8gdG8gdGhlIFN0YWNrIChhbmQgbm90LCBzYXksIHRvIFdpbmRvd3Mgb3Igb3RoZXIgbmVzdGVkIGtpbmRzKVxuICAgICAgICBsZXQgc3RhY2tWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHN0YWNrVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICBzdGFja1ZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFVuc2V0KHJlbW92ZWRNb2RlbCl7XG4gICAgICAgIGxldCBzdGFja1ZpZXcgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZChyZW1vdmVkTW9kZWwuaWQpO1xuICAgICAgICBzdGFja1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1hZGRlZCcsIHRoaXMuaGFuZGxlUGFydEFkZGVkKTtcbiAgICAgICAgc3RhY2tWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctcmVtb3ZlZCcsIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQpO1xuICAgIH1cblxuICAgIGhhbmRsZUN1cnJlbnRDaGFuZ2UoKXtcbiAgICAgICAgaWYoIXRoaXMubW9kZWwuY3VycmVudENhcmQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwcGVycyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd3cmFwcGVkLXZpZXcnKSk7XG4gICAgICAgIHdyYXBwZXJzLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlZElkID0gd3JhcHBlci5nZXRBdHRyaWJ1dGUoJ3dyYXBwZWQtaWQnKTtcbiAgICAgICAgICAgIGlmKHdyYXBwZWRJZCA9PSB0aGlzLm1vZGVsLmN1cnJlbnRDYXJkLmlkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydEFkZGVkKGV2ZW50KXtcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVyIGlzIGZvciB0aGUgc3Qtdmlldy1hZGRlZFxuICAgICAgICAvLyBDdXN0b21FdmVudCB0aGF0IGlzIHRyaWdnZXJlZCBieSBTeXN0ZW0gd2hlblxuICAgICAgICAvLyBuZXdNb2RlbCgpIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnY2FyZCcpe1xuICAgICAgICAgICAgbGV0IGNhcmRQYXJ0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbZXZlbnQuZGV0YWlsLnBhcnRJZF07XG4gICAgICAgICAgICB0aGlzLmFkZFdyYXBwZWRDYXJkKGNhcmRQYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0luaXRpYWxseSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydFJlbW92ZWQoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ2NhcmQnKXtcbiAgICAgICAgICAgIGxldCB3cmFwcGVkVmlldyA9IHRoaXMucXVlcnlTZWxlY3Rvcihgd3JhcHBlZC12aWV3W3dyYXBwZWQtaWQ9XCIke2V2ZW50LmRldGFpbC5wYXJ0SWR9XCJdYCk7XG4gICAgICAgICAgICBpZih3cmFwcGVkVmlldyl7XG4gICAgICAgICAgICAgICAgd3JhcHBlZFZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBudW1iZXIgZGlzcGxheSBvZiBhbGwgd3JhcHBlZCB2aWV3cyBpbiB0aGUgcm93XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChgd3JhcHBlZC12aWV3YCkpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uV3JhcHBlckNsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IHdyYXBwZXJJc0N1cnJlbnQgPSBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjdXJyZW50Jyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwgJiYgIXdyYXBwZXJJc0N1cnJlbnQpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5nb1RvQ2FyZEJ5SWQoZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnd3JhcHBlZC1pZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRWaWV3KCl7XG4gICAgICAgIC8vIEZpcnN0LCB3ZSBjbGVhciBvdXQgYW55IGV4aXN0aW5nIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAvLyBXZSBpdGVyYXRlIG92ZXIgZWFjaCBjYXJkIG9mIHRoZSBzdGFjayBhbmQ6XG4gICAgICAgIC8vICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIGNhcmQgdmlldyBlbGVtZW50O1xuICAgICAgICAvLyAqIEF0dGFjaCB0aGUgY29ycmVjdCBtb2RlbDtcbiAgICAgICAgLy8gKiBTZXQgaXQgdG8gYmUgYSBsZW5zZWQgdmlldztcbiAgICAgICAgLy8gKiBEbyB0aGUgc2FtZSBmb3IgYWxsIGNoaWxkcmVuLCByZWN1cnNpdmVseVxuICAgICAgICB0aGlzLm1vZGVsLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KS5mb3JFYWNoKGNhcmRQYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlZENhcmQoY2FyZFBhcnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgc2V0dGluZyB0aGUgY3VycmVudFxuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzaG93SW5pdGlhbGx5KCl7XG4gICAgICAgIC8vIE5vdGhpbmcgZm9yIG5vd1xuICAgIH1cblxuICAgIGFkZFdyYXBwZWRDYXJkKGFDYXJkKXtcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBsZW5zZWQgQ2FyZFZpZXcgaW50byB0aGUgd3JhcHBlclxuICAgICAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3dyYXBwZWQtdmlldycpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdjYXJkcycpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbldyYXBwZXJDbGljayk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIHdyYXBwZXIuc2V0TW9kZWwoYUNhcmQpO1xuICAgIH1cblxuICAgIHN1YnBhcnRPcmRlckNoYW5nZWQoaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpe1xuICAgICAgICBsZXQgc3VicGFydE5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgaWYoIXN1YnBhcnROb2RlKXtcbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBtb2RlbCBzdWJwYXJ0IHdoaWNoIGlzIG5vdCBhIGNhcmQgYW5kIGhlbmNlIG5vdFxuICAgICAgICAgICAgLy8gZGlzcGxheWVkIGluIHRoZSBDYXJkUm93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYobmV3SW5kZXggPT0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdWJwYXJ0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHdoZXRoZXIgdGhlIGluZGV4IG9mIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGJlZm9yZSBvciBhZnRlciB0aGUgbmV3SW5kZXhcbiAgICAgICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IG5ld0luZGV4KXtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gdGhpcy5jaGlsZE5vZGVzW25ld0luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHN1YnBhcnROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIGRpc3BsYXkgb2YgYWxsIHdyYXBwZWQgdmlld3MgaW4gdGhlIHJvd1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChgd3JhcHBlZC12aWV3YCkpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5leHBvcnQge1xuICAgIENhcmRSb3csXG4gICAgQ2FyZFJvdyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTaW1wbGVUYWxrIE5hdmlnYXRvciBXZWJjb21wb25lbnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgY29tcG9uZW50IHRoYXQgYWxsb3dzXG4gKiBhdXRob3JzIHRvIG5hdmlnYXRlIHRoZSBXb3JsZFN0YWNrIGFuZCBpbmRpdmlkdWFsXG4gKiBTdGFja3MgdGhlcmVpbiB1c2luZyBhIGNvbnZlbmllbnQgcG9wLW91dCB0cmF5IGZyb21cbiAqIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbi5cbiAqKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5pbXBvcnQgV3JhcHBlZFZpZXcgZnJvbSAnLi9XcmFwcGVkVmlldy5qcyc7XG5pbXBvcnQgU3RhY2tSb3cgZnJvbSAnLi9TdGFja1Jvdy5qcyc7XG5pbXBvcnQgQ2FyZFJvdyBmcm9tICcuL0NhcmRSb3cuanMnO1xuXG4vLyBBZGQgYW55IG5lZWRlZCBjdXN0b21FbGVtZW50c1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbmF2LXN0YWNrLXJvdycsIFN0YWNrUm93KTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ25hdi1jYXJkLXJvdycsIENhcmRSb3cpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnd3JhcHBlZC12aWV3JywgV3JhcHBlZFZpZXcpO1xuXG5jb25zdCBzdGFja0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc3RhY2tcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxwb2x5bGluZSBwb2ludHM9XCIxMiA0IDQgOCAxMiAxMiAyMCA4IDEyIDRcIj48L3BvbHlsaW5lPlxuICAgPHBvbHlsaW5lIHBvaW50cz1cIjQgMTIgMTIgMTYgMjAgMTJcIj48L3BvbHlsaW5lPlxuICAgPHBvbHlsaW5lIHBvaW50cz1cIjQgMTYgMTIgMjAgMjAgMTZcIj48L3BvbHlsaW5lPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjYXJkSWNvbiA9IGBcbjxzdmdcbiAgIHhtbG5zOmRjPVwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIlxuICAgeG1sbnM6Y2M9XCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcIlxuICAgeG1sbnM6cmRmPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1wiXG4gICB4bWxuczpzdmc9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zdGFja1wiXG4gICB3aWR0aD1cIjUwXCJcbiAgIGhlaWdodD1cIjIwLjgzMzMwOVwiXG4gICB2aWV3Qm94PVwiMCAwIDI0IDkuOTk5OTg4NFwiXG4gICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICBmaWxsPVwibm9uZVwiXG4gICBzdHJva2UtbGluZWNhcD1cInJvdW5kXCJcbiAgIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCJcbiAgIHZlcnNpb249XCIxLjFcIlxuICAgaWQ9XCJzdmc4OTNcIj5cbiAgPG1ldGFkYXRhXG4gICAgIGlkPVwibWV0YWRhdGE4OTlcIj5cbiAgICA8cmRmOlJERj5cbiAgICAgIDxjYzpXb3JrXG4gICAgICAgICByZGY6YWJvdXQ9XCJcIj5cbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XG4gICAgICAgIDxkYzp0eXBlXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXCIgLz5cbiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+XG4gICAgICA8L2NjOldvcms+XG4gICAgPC9yZGY6UkRGPlxuICA8L21ldGFkYXRhPlxuICA8ZGVmc1xuICAgICBpZD1cImRlZnM4OTdcIiAvPlxuICA8cGF0aFxuICAgICBzdHJva2U9XCJub25lXCJcbiAgICAgZD1cIk0gLTIuNzY2OTE1MSwtMS4yNTY0OTQ4IEggMjEuMjMzMDg1IFYgMjIuNzQzNTA1IEggLTIuNzY2OTE1MSBaXCJcbiAgICAgZmlsbD1cIm5vbmVcIlxuICAgICBpZD1cInBhdGg4ODVcIiAvPlxuICA8cG9seWxpbmVcbiAgICAgcG9pbnRzPVwiMTIgNCA0IDggMTIgMTIgMjAgOCAxMiA0XCJcbiAgICAgaWQ9XCJwb2x5bGluZTg4N1wiXG4gICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLC0zKVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBtaW4taGVpZ2h0OiAyNzFweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig0cHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dDtcbiAgICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMCUpO1xuICAgICAgICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSg1MCwgNTAsIDUwLCAwLjQpO1xuICAgICAgICBvdmVyZmxvdy15OiBoaWRkZW47XG4gICAgICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgICAgIHotaW5kZXg6IDEwMDA7XG4gICAgfVxuXG4gICAgLm5hdi1kaXNwbGF5LXJvdyB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgIH1cbiAgICAubmF2LWljb24ge1xuICAgICAgICBjb2xvcjogZ3JheTtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAzMHB4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwic3RhY2tzLWRpc3BsYXlcIiBjbGFzcz1cIm5hdi1kaXNwbGF5LXJvd1wiPlxuICAgIDxkaXYgaWQ9XCJzdGFjay1pY29uXCIgY2xhc3M9XCJuYXYtaWNvblwiPiR7c3RhY2tJY29ufTwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJzdGFjay1yb3dcIj48L3Nsb3Q+XG48L2Rpdj5cbjxkaXYgaWQ9XCJjYXJkcy1kaXNwbGF5XCIgY2xhc3M9XCJuYXYtZGlzcGxheS1yb3dcIj5cbiAgICA8ZGl2IGlkPVwiY2FyZC1pY29uXCIgY2xhc3M9XCJuYXYtaWNvblwiPiR7Y2FyZEljb259PC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cImNhcmQtcm93XCI+PC9zbG90PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBTVE5hdmlnYXRvciBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgdXAgdGVtcGxhdGVcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnRvZ2dsZSA9IHRoaXMudG9nZ2xlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbiA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UgPSB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0QWRkZWQgPSB0aGlzLmhhbmRsZVBhcnRBZGRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkID0gdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNhcmRSb3dGb3IgPSB0aGlzLmNyZWF0ZUNhcmRSb3dGb3IuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBjb250ZXh0IG1lbnUgdG8gb3BlbiBpbiB0aGUgbmF2IHNpbmNlXG4gICAgICAgIC8vIGl0IGRvZW5zJ3QgbWFrZSBzZW5zZSBhdG0gYW5kIHdpbGwgZXJyb3JcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICBsZXQgd29ybGRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgd29ybGRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG5cbiAgICAgICAgLy8gUmVzcG9uZCB0byB0aGUgU3lzdGVtIHBhcnQtYWRkZWQgQ3VzdG9tRXZlbnRcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICB3b3JsZFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG5cbiAgICAgICAgLy8gQWRkIGEgU3RhY2tSb3cgdmlldy5cbiAgICAgICAgdGhpcy5zdGFja1Jvd0VsID0gdGhpcy5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBuYXYtc3RhY2stcm93Jyk7XG4gICAgICAgIGlmKCF0aGlzLnN0YWNrUm93RWwpe1xuICAgICAgICAgICAgdGhpcy5zdGFja1Jvd0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmF2LXN0YWNrLXJvdycpO1xuICAgICAgICAgICAgdGhpcy5zdGFja1Jvd0VsLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdzdGFjay1yb3cnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5zdGFja1Jvd0VsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWNrUm93RWwuc2V0TW9kZWwodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFueSBuZWVkZWQgQ2FyZFJvdyB2aWV3cyBmb3IgYWxsIHN0YWNrc1xuICAgICAgICAvLyBjdXJyZW50bHkgaW4gdGhlIHdvcmxkXG4gICAgICAgIHRoaXMubW9kZWwuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KS5mb3JFYWNoKHN0YWNrUGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNhcmRSb3dGb3Ioc3RhY2tQYXJ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5pdCB0aGUgU3RhY2tSb3dcbiAgICAgICAgdGhpcy5zdGFja1Jvd0VsLmluaXRWaWV3KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2FyZC9zdGFjayB2YWx1ZXNcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKCk7XG5cbiAgICAgICAgLy8gUmVzcG9uZCB0byBldmVudHVhbCBjdXJyZW50LW5lc3MgcHJvcFxuICAgICAgICAvLyBjaGFuZ2VzIGZyb20gdGhlIFdvcmxkU3RhY2suXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDdXJyZW50Q2hhbmdlKCl7XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGlzIG1lYW5zIHRoYXQgdGhlIGN1cnJlbnQgKnN0YWNrKiBoYXMgY2hhbmdlZC5cbiAgICAgICAgLy8gU28gd2UgbmVlZCB0byBmaW5kIHRoZSBjb3JyZWN0IENhcmRSb3cgZm9yIGl0IGFuZCBzZXQgaXRcbiAgICAgICAgLy8gdG8gYmUgdGhlIHNsb3R0ZWQgb25lIGluIHRoZSBzaGFkb3cgRE9NXG4gICAgICAgIGxldCBjdXJyZW50U3RhY2tJZCA9IHRoaXMubW9kZWwuY3VycmVudFN0YWNrLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCduYXYtY2FyZC1yb3cnKSkuZm9yRWFjaChjYXJkUm93ID0+IHtcbiAgICAgICAgICAgIGxldCByb3dJZCA9IGNhcmRSb3cuZ2V0QXR0cmlidXRlKCdzdGFjay1pZCcpO1xuICAgICAgICAgICAgY2FyZFJvdy5yZW1vdmVBdHRyaWJ1dGUoJ3Nsb3QnKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRTdGFja0lkID09IHJvd0lkKXtcbiAgICAgICAgICAgICAgICBjYXJkUm93LnNldEF0dHJpYnV0ZSgnc2xvdCcsICdjYXJkLXJvdycpO1xuICAgICAgICAgICAgICAgIEFycmF5LmZyb20oY2FyZFJvdy5xdWVyeVNlbGVjdG9yQWxsKCd3cmFwcGVkLXZpZXcnKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci51cGRhdGVTY2FsaW5nKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZVBhcnRBZGRlZChldmVudCl7XG4gICAgICAgIC8vIElmIGEgbmV3IHN0YWNrIGlzIGFkZGVkLCB3ZSBuZWVkIHRvIGNyZWF0ZVxuICAgICAgICAvLyBhIG5ldyBDYXJkUm93IGZvciBpdC5cbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgbGV0IHN0YWNrUGFydCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW2V2ZW50LmRldGFpbC5wYXJ0SWRdO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDYXJkUm93Rm9yKHN0YWNrUGFydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVQYXJ0UmVtb3ZlZChldmVudCl7XG4gICAgICAgIC8vIElmIGEgc3RhY2sgaGFzIGJlZW4gcmVtb3ZlZCwgd2UgbmVlZCB0b1xuICAgICAgICAvLyByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgQ2FyZFJvd1xuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICBsZXQgY2FyZFJvdyA9IHRoaXMucXVlcnlTZWxlY3RvcihgW3N0YWNrLWlkPVwiJHtldmVudC5kZXRhaWwucGFydElkfVwiXWApO1xuICAgICAgICAgICAgaWYoY2FyZFJvdyl7XG4gICAgICAgICAgICAgICAgY2FyZFJvdy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZUNhcmRSb3dGb3IoYVN0YWNrKXtcbiAgICAgICAgbGV0IGNhcmRSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYtY2FyZC1yb3cnKTtcbiAgICAgICAgY2FyZFJvdy5zZXRBdHRyaWJ1dGUoJ3N0YWNrLWlkJywgYVN0YWNrLmlkKTtcbiAgICAgICAgY2FyZFJvdy5zZXRNb2RlbChhU3RhY2spO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNhcmRSb3cpO1xuICAgICAgICBjYXJkUm93LmluaXRWaWV3KCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCl7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpO1xuICAgICAgICBpZih0aGlzLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKXtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3Blbigpe1xuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgwKVwiO1xuICAgIH1cblxuICAgIGNsb3NlKCl7XG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKDEwMCUpXCI7XG4gICAgfVxuXG4gICAgXG59O1xuXG5leHBvcnQge1xuICAgIFNUTmF2aWdhdG9yLFxuICAgIFNUTmF2aWdhdG9yIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIE5hdmlnYXRvciBTdGFjayBSb3dcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgdmlldyBvbiB0aGUgV29ybGRTdGFjayB0aGF0IHNob3dzIGVhY2hcbiAqIHN1YnBhcnQgc3RhY2sgaXRlbSBhcyBhIHdyYXBwZWQgbGVucyB2aWV3IGFsb25nXG4gKiBhIHJvdy5cbiAqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4uL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG48L3N0eWxlPlxuPHNsb3QgbmFtZT1cInN0YWNrc1wiPjwvc2xvdD5cbmA7XG5cbmNsYXNzIFN0YWNrUm93IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5pbml0VmlldyA9IHRoaXMuaW5pdFZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRXcmFwcGVkU3RhY2sgPSB0aGlzLmFkZFdyYXBwZWRTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UgPSB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0QWRkZWQgPSB0aGlzLmhhbmRsZVBhcnRBZGRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkID0gdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNob3dJbml0aWFsbHkgPSB0aGlzLnNob3dJbml0aWFsbHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldyYXBwZXJDbGljayA9IHRoaXMub25XcmFwcGVyQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBjb250ZXh0IG1lbnUgdG8gb3BlbiBpbiB0aGUgbmF2IHNpbmNlXG4gICAgICAgIC8vIGl0IGRvZW5zJ3QgbWFrZSBzZW5zZSBhdG0gYW5kIHdpbGwgZXJyb3JcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICB9XG5cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YWNrLWlkJywgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBXb3JsZCBNb2RlbCdzIG1haW4gdmlldyBlbGVtZW50LlxuICAgICAgICAvLyBXZSBhZGQgdGhlIHN0LXZpZXctYWRkZWQgQ3VzdG9tRXZlbnQgbGlzdGVuZXJcbiAgICAgICAgLy8gaGVyZSBzbyB3ZSBjYW4gcmVhY3Qgb25seSB0byBkaXJlY3Qgc3RhY2sgYWRkaXRpb25zXG4gICAgICAgIC8vIHRvIHRoZSBXb3JsZFN0YWNrIChhbmQgbm90LCBzYXksIHRvIFdpbmRvd3Mgb3Igb3RoZXIgbmVzdGVkIGtpbmRzKVxuICAgICAgICBsZXQgd29ybGRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgd29ybGRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHdvcmxkVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsVW5zZXQoKXtcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICB3b3JsZFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ3VycmVudENoYW5nZSgpe1xuICAgICAgICBsZXQgY3VycmVudElkID0gdGhpcy5tb2RlbC5jdXJyZW50U3RhY2suaWQ7XG4gICAgICAgIGxldCB3cmFwcGVkVmlld3MgPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd3cmFwcGVkLXZpZXcnKVxuICAgICAgICApO1xuICAgICAgICB3cmFwcGVkVmlld3MuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVkSWQgPSB3cmFwcGVyLmdldEF0dHJpYnV0ZSgnd3JhcHBlZC1pZCcpO1xuICAgICAgICAgICAgaWYod3JhcHBlZElkID09IHRoaXMubW9kZWwuY3VycmVudFN0YWNrLmlkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydEFkZGVkKGV2ZW50KXtcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVyIGlzIGZvciB0aGUgc3Qtdmlldy1hZGRlZFxuICAgICAgICAvLyBDdXN0b21FdmVudCB0aGF0IGlzIHRyaWdnZXJlZCBieSBTeXN0ZW0gd2hlblxuICAgICAgICAvLyBuZXdNb2RlbCgpIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIGxldCBzdGFja1BhcnQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtldmVudC5kZXRhaWwucGFydElkXTtcbiAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlZFN0YWNrKHN0YWNrUGFydCk7XG4gICAgICAgICAgICB0aGlzLnNob3dJbml0aWFsbHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVBhcnRSZW1vdmVkKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgbGV0IHdyYXBwZWRWaWV3ID0gdGhpcy5xdWVyeVNlbGVjdG9yKGB3cmFwcGVkLXZpZXdbd3JhcHBlZC1pZD1cIiR7ZXZlbnQuZGV0YWlsLnBhcnRJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmKHdyYXBwZWRWaWV3KXtcbiAgICAgICAgICAgICAgICB3cmFwcGVkVmlldy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIG51bWJlcnMgb2YgcmVtYWluaW5nIHdyYXBwZWQgdmlld3MgaW4gdGhpcyBTdGFja1Jvd1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3dyYXBwZWQtdmlldycpKS5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbldyYXBwZXJDbGljayhldmVudCl7XG4gICAgICAgIGxldCB3cmFwcGVySXNDdXJyZW50ID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnY3VycmVudCcpO1xuICAgICAgICBpZih0aGlzLm1vZGVsICYmICF3cmFwcGVySXNDdXJyZW50KXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuZ29Ub1N0YWNrQnlJZChcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCd3cmFwcGVkLWlkJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Vmlldygpe1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIHdyYXBwZWQgdmlld3NcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgb3ZlciBlYWNoIGNvcnJlc3BvbmRpbmcgU3RhY2sgYW5kOlxuICAgICAgICAvLyAqIENyZWF0ZSBhIGNsb25lIG9mIGl0cyB2aWV3IG5vZGU7XG4gICAgICAgIC8vICogQXR0YWNoIHRoZSBjb3JyZWN0IG1vZGVsO1xuICAgICAgICAvLyAqIFNldCBpdCB0byBiZSBhIGxlbnNlZCB2aWV3XG4gICAgICAgIC8vICogRG8gdGhlIHNhbWUgZm9yIGFsbCBjaGlsZHJlbiwgcmVjdXJzaXZlbHlcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pLmZvckVhY2goc3RhY2tQYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlZFN0YWNrKHN0YWNrUGFydCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSBpbml0aWFsIGN1cnJlbnQtbmVzcyBkaXNwbGF5XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSgpO1xuICAgIH1cblxuICAgIHNob3dJbml0aWFsbHkoKXtcbiAgICAgICAgLy8gTm90aGluZyBmb3Igbm93XG4gICAgfVxuXG4gICAgYWRkV3JhcHBlZFN0YWNrKGFTdGFjayl7ICBcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBsZW5zZWQgU3RhY2tWaWV3IGludG8gdGhlIHdyYXBwZXJcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd3cmFwcGVkLXZpZXcnKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJzbG90XCIsIFwic3RhY2tzXCIpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbldyYXBwZXJDbGljayk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIHdyYXBwZXIuc2V0TW9kZWwoYVN0YWNrKTtcbiAgICB9XG5cbiAgICBzdWJwYXJ0T3JkZXJDaGFuZ2VkKGlkLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4KXtcbiAgICAgICAgbGV0IHN1YnBhcnROb2RlID0gdGhpcy5jaGlsZE5vZGVzW2N1cnJlbnRJbmRleF07XG4gICAgICAgIGlmKCFzdWJwYXJ0Tm9kZSl7XG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgbW9kZWwgc3VicGFydCB3aGljaCBpcyBub3QgYSBzdGFjayBhbmQgaGVuY2Ugbm90XG4gICAgICAgICAgICAvLyBkaXNwbGF5ZWQgaW4gdGhlIFN0YWNrUm93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYobmV3SW5kZXggPT0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdWJwYXJ0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHdoZXRoZXIgdGhlIGluZGV4IG9mIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGJlZm9yZSBvciBhZnRlciB0aGUgbmV3SW5kZXhcbiAgICAgICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IG5ld0luZGV4KXtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gdGhpcy5jaGlsZE5vZGVzW25ld0luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHN1YnBhcnROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIGRpc3BsYXkgb2YgYWxsIHdyYXBwZWQgdmlld3MgaW4gdGhlIHJvd1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChgd3JhcHBlZC12aWV3YCkpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTdGFja1JvdyxcbiAgICBTdGFja1JvdyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBXcmFwcGVkVmlldyBDb21wb25lbnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHBsYWluIFdlYmNvbXBvbmVudCB3aG9zZSBwdXJwb3NlIGlzIHRvXG4gKiB3cmFwIGEgdmlzdWFsIGNvcHkgb2YgYW4gYWN0dWFsIFNpbXBsZVRhbGsgVmlld1xuICogZWxlbWVudCBhbmQgZGlzcGxheSBpdCBpbiBhIHNjYWxlZCBkb3duIGZvcm1hdC5cbiAqIEkgbWFrZSBhIGNsb25lZCBjb3B5IG9mIHRoZSB1bmRlcmx5aW5nIHZpZXcgYW5kXG4gKiBhdHRhY2ggaXQgdG8gdGhlIHNhbWUgbW9kZWwgYXMgdGhlIG9yaWdpbmFsLlxuICoqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4uL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgI251bWJlci1kaXNwbGF5IHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW47XG4gICAgICAgIGZvbnQtc2l6ZTogMi4ycmVtO1xuICAgIH1cblxuICAgICNudW1iZXItZGlzcGxheSA+IHNwYW4ge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwcHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBsaW5lYXI7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIH1cblxuICAgIDpob3N0KDpub3QoLmN1cnJlbnQpKSA+ICNudW1iZXItZGlzcGxheSB7XG4gICAgICAgIG9wYWNpdHk6IDAuODtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjUpO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgICAgIHotaW5kZXg6IDEwMDA7XG4gICAgfVxuXG4gICAgOmhvc3QoOm5vdCguY3VycmVudCkpID4gI251bWJlci1kaXNwbGF5ID4gc3BhbiB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwcHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBsaW5lYXI7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJudW1iZXItZGlzcGxheVwiPlxuICAgIDxzcGFuPjwvc3Bhbj5cbjwvZGl2PlxuPHNsb3QgbmFtZT1cIndyYXBwZWQtdmlld1wiPjwvc2xvdD5cbmA7XG5cblxuY2xhc3MgV3JhcHBlZFZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgdXAgdGVtcGxhdGUgYW5kIHNoYWRvd0RvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbkNoaWxkU2xvdHRlZCA9IHRoaXMub25DaGlsZFNsb3R0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsaW5nID0gdGhpcy51cGRhdGVTY2FsaW5nLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlTnVtYmVyQ2hhbmdlID0gdGhpcy5oYW5kbGVOdW1iZXJDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRXcmFwcGVkVmlldyA9IHRoaXMuYWRkV3JhcHBlZFZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlbHlVcGRhdGVMZW5zVmlld3MgPSB0aGlzLl9yZWN1cnNpdmVseVVwZGF0ZUxlbnNWaWV3cy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgLy8gQmluZCBhIGxpc3RlbmVyIGZvciB0aGUgc2xvdCBjaGFuZ2UuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW5ldmVyIGFueVxuICAgICAgICAgICAgLy8gdW5kZXJseWluZyBlbGVtZW50IGlzIHNsb3R0ZWQsIHNvIHdlXG4gICAgICAgICAgICAvLyBrbm93IHRvIHJlY29tcHV0ZSB0aGUgYXBwcm9wcmlhdGUgc2l6aW5nXG4gICAgICAgICAgICAvLyBhbmQgc3R5bGluZ1xuICAgICAgICAgICAgbGV0IHNsb3RFbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc2xvdCcpO1xuICAgICAgICAgICAgc2xvdEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLm9uQ2hpbGRTbG90dGVkKTtcblxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgY29udGV4dCBtZW51IHRvIG9wZW4gaW4gdGhlIG5hdiBzaW5jZVxuICAgICAgICAgICAgLy8gaXQgZG9lbnMndCBtYWtlIHNlbnNlIGF0bSBhbmQgd2lsbCBlcnJvclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGxldCBzbG90RWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3Nsb3QnKTtcbiAgICAgICAgc2xvdEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLm9uQ2hpbGRTbG90dGVkKTtcbiAgICB9XG5cbiAgICBvbkNoaWxkU2xvdHRlZChldmVudCl7XG4gICAgICAgIC8vdGhpcy51cGRhdGVTY2FsaW5nKCk7XG4gICAgICAgIC8vdGhpcy51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbnVtYmVyJywgdGhpcy5oYW5kbGVOdW1iZXJDaGFuZ2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICB0aGlzLmFkZFdyYXBwZWRWaWV3KHRoaXMubW9kZWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTY2FsaW5nKCl7XG4gICAgICAgIGxldCBmaXJzdENoaWxkID0gdGhpcy5jaGlsZHJlblswXTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIHRoZSBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICAgIC8vIGFjdHVhbCB2aWV3IGZvciB0aGUgbGVucy1lZCBwYXJ0LCBpbiBvcmRlciB0byBnZXRcbiAgICAgICAgLy8gaXRzIGN1cnJlbnQgZGltZW5zaW9ucy5cbiAgICAgICAgbGV0IHBhcnRJZCA9IGZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnKTtcbiAgICAgICAgbGV0IHJlZkVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdC13b3JsZGApO1xuICAgICAgICBsZXQgd3JhcEJveCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBpbm5lckJveCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0LXdvcmxkYCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzY2FsaW5nWCA9ICh3cmFwQm94LndpZHRoIC8gaW5uZXJCb3gud2lkdGgpO1xuICAgICAgICBsZXQgcmVmRWxlbWVudEJveCA9IHJlZkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBgJHtyZWZFbGVtZW50Qm94LndpZHRofXB4YDtcbiAgICAgICAgZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBgJHtyZWZFbGVtZW50Qm94LmhlaWdodH1weGA7XG4gICAgICAgIGZpcnN0Q2hpbGQuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c2NhbGluZ1h9KWA7XG4gICAgICAgIGZpcnN0Q2hpbGQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCIwcHggMHB4XCI7XG4gICAgfVxuXG4gICAgdXBkYXRlTnVtYmVyRGlzcGxheSgpe1xuICAgICAgICBsZXQgZmlyc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bMF07XG4gICAgICAgIGxldCBtb2RlbCA9IGZpcnN0Q2hpbGQubW9kZWw7XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBsb29rIGF0IHN1YnBhcnRzIG9mIHRoZSBzYW1lIHR5cGUgKHN0YWNrIG9yIGNhcmQpXG4gICAgICAgIGxldCBzdWJwYXJ0cyA9IG1vZGVsLl9vd25lci5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC50eXBlID09IHBhcnQudHlwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBudW1EaXNwbGF5ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjbnVtYmVyLWRpc3BsYXkgPiBzcGFuJyk7XG4gICAgICAgIG51bURpc3BsYXkuaW5uZXJUZXh0ID0gc3VicGFydHMuaW5kZXhPZihtb2RlbCkgKyAxO1xuICAgIH1cblxuICAgIGhhbmRsZU51bWJlckNoYW5nZSgpe1xuICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIGRpc3BsYXkgb2YgYWxsIHdyYXBwZWQgdmlld3MgaW4gdGhlIHJvd1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKGB3cmFwcGVkLXZpZXdgKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRXcmFwcGVkVmlldyhhUGFydE1vZGVsKXtcbiAgICAgICAgLy8gRmlyc3QsIGNsZWFyIG91dCBhbnkgZXhpc3RpbmdcbiAgICAgICAgLy8gY2hpbGQgZWxlbWVudHNcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGxlbnNlZCBjb3B5IG9mIHRoZSBnaXZlblxuICAgICAgICAvLyB2aWV3IGFuZCB1cGRhdGUga2V5IGF0dHJpYnV0ZXMgb24gaXRcbiAgICAgICAgbGV0IG9yaWdpbmFsVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHthUGFydE1vZGVsLmlkfVwiXWApO1xuICAgICAgICBsZXQgbGVuc2VkVmlldyA9IG9yaWdpbmFsVmlldy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGxlbnNlZFZpZXcuc2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnLCBhUGFydE1vZGVsLmlkKTtcbiAgICAgICAgbGVuc2VkVmlldy5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnd3JhcHBlZC12aWV3Jyk7XG4gICAgICAgIGxlbnNlZFZpZXcuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICBsZW5zZWRWaWV3LndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIElubGluZSB0aGUgaW5pdGlhbCBzY2FsaW5nIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFdlIGJlZ2luIHdpdGggYW4gZXh0cmVtZWx5IHNtYWxsIGFtb3VudCB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGFkanVzdGVkIGxhdGVyIGR1cmluZyB1cGRhdGVTY2FsaW5nKCk7XG4gICAgICAgIGxlbnNlZFZpZXcuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7MC4wMDF9KWA7XG4gICAgICAgIGxlbnNlZFZpZXcuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCIwcHggMHB4XCI7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjcmVhdGUgbGVucyB2aWV3cyBvZiBhbGwgc3VicGFydCBjaGlsZHJlblxuICAgICAgICAvLyBhbmQgYXBwZW5kIHRoZW0gaW4gdGhlIGNvcnJlY3QgcGxhY2VzXG4gICAgICAgIGxlbnNlZFZpZXcuaXNMZW5zZWQgPSB0cnVlO1xuICAgICAgICBsZW5zZWRWaWV3LnNldE1vZGVsKGFQYXJ0TW9kZWwpO1xuICAgICAgICBsZW5zZWRWaWV3LnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICBpZihsZW5zZWRWaWV3LmhhbmRsZUN1cnJlbnRDaGFuZ2Upe1xuICAgICAgICAgICAgbGVuc2VkVmlldy5oYW5kbGVDdXJyZW50Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlbHlVcGRhdGVMZW5zVmlld3MobGVuc2VkVmlldywgYVBhcnRNb2RlbC5pZCk7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSByb290IGxlbnNlZCB2aWV3IGludG8gdGhlIHdyYXBwZXJcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dyYXBwZWQtaWQnLCBhUGFydE1vZGVsLmlkKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChsZW5zZWRWaWV3KTtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsaW5nKCk7XG4gICAgfVxuXG4gICAgX3JlY3Vyc2l2ZWx5VXBkYXRlTGVuc1ZpZXdzKGxlbnNlZFZpZXcsIGFuSWQpe1xuICAgICAgICBsZXQgc3ViVmlld3MgPSBBcnJheS5mcm9tKGxlbnNlZFZpZXcuY2hpbGRyZW4pLmZpbHRlcihjaGlsZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuaXNQYXJ0VmlldztcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YlZpZXdzLmZvckVhY2goc3ViVmlldyA9PiB7XG4gICAgICAgICAgICBzdWJWaWV3LmlzTGVuc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1YlZpZXcud2FudHNIYWxvID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3ViSWQgPSBzdWJWaWV3LmdldEF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgc3ViVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIHN1YklkKTtcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3N1YklkXTtcbiAgICAgICAgICAgIHN1YlZpZXcuc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgc3ViVmlldy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZWx5VXBkYXRlTGVuc1ZpZXdzKHN1YlZpZXcsIHN1YklkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFBhcnRWaWV3IE92ZXJyaWRlcyAqKi9cbiAgICBzdHlsZUNTUygpe1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuXG4gICAgc3R5bGVUZXh0Q1NTKCl7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICB9XG5cbiAgICBsYXlvdXRDaGFuZ2VkKCl7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFdyYXBwZWRWaWV3LFxuICAgIFdyYXBwZWRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQge0FjdGl2YXRpb25Db250ZXh0fSBmcm9tICcuLi9vYmplY3RzL0V4ZWN1dGlvblN0YWNrLmpzJztcblxuLy8gSGVscGVyc1xuZnVuY3Rpb24gZmluZE5lYXJlc3RQYXJlbnRPZktpbmQoYVBhcnQsIGFQYXJ0VHlwZSl7XG4gICAgbGV0IG93bmVyID0gYVBhcnQuX293bmVyO1xuICAgIHdoaWxlKG93bmVyKXtcbiAgICAgICAgaWYob3duZXIudHlwZSA9PSBhUGFydFR5cGUpe1xuICAgICAgICAgICAgcmV0dXJuIG93bmVyO1xuICAgICAgICB9XG4gICAgICAgIG93bmVyID0gb3duZXIuX293bmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCd0aGlzJyBpcyBhICR7YVBhcnQudHlwZX0sIG5vdCBhICR7YVBhcnRUeXBlfSBvciBkb2VzIG5vdCBoYXZlIGEgcGFyZW50IG9mIGEgJHthUGFydFR5cGV9IWApO1xufVxuXG4vLyBjaGVjayBmb3IgcG9zc2libGVBbmNlc3Rvci5hY2NlcHRzU3VicGFydChhUGFydC50eXBlKVxuLy8gYW5kIGlmIG5vdCBnbyB0byBvd25lciBhbmQgY2hlY2sgYWdhaW5cbmZ1bmN0aW9uIGZpbmRGaXJzdFBvc3NpYmxlQW5jZXN0b3IoYVBhcnQsIGFQYXJ0VHlwZSl7XG4gICAgaWYoX3N1YnBhcnRDaGVjayhhUGFydCwgYVBhcnRUeXBlKSl7XG4gICAgICAgIHJldHVybiBhUGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgb3duZXIgPSBhUGFydC5fb3duZXI7XG4gICAgICAgIHdoaWxlKG93bmVyKXtcbiAgICAgICAgICAgIGlmKF9zdWJwYXJ0Q2hlY2sob3duZXIsIGFQYXJ0VHlwZSkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBvd25lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG93bmVyID0gb3duZXIuX293bmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgYSAke2FQYXJ0LnR5cGV9LCBkb2VzIG5vdCBhY2NlcHQgbm9yIGhhcyBhbnkgYW5jZXN0b3JzIHdoaWNoIGFjY2VwdCBwYXJ0IHR5cGUgJHthUGFydFR5cGV9YCk7XG59XG5cbmZ1bmN0aW9uIF9zdWJwYXJ0Q2hlY2soYVBhcnQsIGFQYXJ0VHlwZSl7XG4gICAgaWYoYVBhcnRUeXBlID09ICdwYXJ0Jyl7XG4gICAgICAgIHJldHVybiBhUGFydC5hY2NlcHRlZFN1YnBhcnRUeXBlcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICByZXR1cm4gYVBhcnQuYWNjZXB0c1N1YnBhcnQoYVBhcnRUeXBlKTtcbn1cblxuY2xhc3MgU1RWYXJpYWJsZVJlZmVyZW5jZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIFNUVmFyaWFibGVSZWZlcmVuY2VFcnJvci5wcm90b3R5cGUsXG4gICAgJ25hbWUnLFxuICAgIHtcbiAgICAgICAgdmFsdWU6ICdTVFZhcmlhYmxlUmVmZXJlbmNlRXJyb3InXG4gICAgfVxuKTtcblxuY29uc3QgY3JlYXRlSW50ZXJwcmV0ZXJTZW1hbnRpY3MgPSAocGFydENvbnRleHQsIHN5c3RlbUNvbnRleHQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBTY3JpcHQ6IGZ1bmN0aW9uKHNjcmlwdFBhcnRzLCBfKXtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQYXJ0cy5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgTWVzc2FnZUhhbmRsZXI6IGZ1bmN0aW9uKGhhbmRsZXJPcGVuLCBsaW5lVGVybSwgb3B0aW9uYWxTdGF0ZW1lbnRMaXN0LCBoYW5kbGVyQ2xvc2Upe1xuICAgICAgICAgICAgbGV0IHttZXNzYWdlTmFtZSwgcGFyYW1ldGVyc30gPSBoYW5kbGVyT3Blbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyRnVuY3Rpb24gPSBmdW5jdGlvbihzZW5kZXJzLCAuLi5hcmdzKXtcblxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBncmFtbWFyLCB0aGUgU3RhdGVtZW50TGlzdCBpc1xuICAgICAgICAgICAgICAgIC8vIGFuIG9wdGlvbmFsIHJ1bGUsIG1lYW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgcnVsZVxuICAgICAgICAgICAgICAgIC8vIGlzIGFuIGVtcHR5IGFycmF5IChubyBzdGF0ZW1lbnRsaXN0KSBvciBhIHNpbmdsZVxuICAgICAgICAgICAgICAgIC8vIGl0ZW0gYXJyYXkgKHRoZSBzdGF0ZW1lbnRsaXN0KVxuICAgICAgICAgICAgICAgIGlmKG9wdGlvbmFsU3RhdGVtZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHN0YXRlbWVudExpc3QgPSBvcHRpb25hbFN0YXRlbWVudExpc3QuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgICAgICAvLyBOZXh0LCB3ZSBpbml0aWFsaXplIGEgbmV3IEFjdGl2YXRpb25Db250ZXh0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3aWxsIGhvbGQgYWxsIHZhcmlhYmxlIGluZm9ybWF0aW9uIGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBleGVjdXRpb24gb2YgdGhpcyBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIC8vIFdlIHB1c2ggaXQgdG8gdGhlIHRvcCBvZiB0aGUgY3VycmVudCBleGVjdXRpb24gc3RhY2tcbiAgICAgICAgICAgICAgICAvLyBhbmQgc2V0IHRoZSBhcmd1bWVudCB2YXJpYWJsZXMgdG8gbG9jYWxzXG4gICAgICAgICAgICAgICAgYXJncy5mb3JFYWNoKChhcmdWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ05hbWUgPSBwYXJhbWV0ZXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtQ29udGV4dC5leGVjdXRpb25TdGFjay5jdXJyZW50LnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIFN0YXRlbWVudExpc3QgaXMgYm90aCBvcHRpb25hbCAqYW5kKiBtYWRlIHVwXG4gICAgICAgICAgICAgICAgLy8gb2YgaXRlcmFibGUgU3RhdGVtZW50TGluZSBydWxlcyAoaWUsICdTdGF0ZW1lbnRMaW5lKycgaW4gZ3JhbW1hciksXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBcInVud3JhcFwiIHRoZXNlIG5vZGVzIHdpdGhvdXQgY2FsbGluZyBpbnRlcnByZXQoKSBvbiB0aGVtLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGV4cHJlc3Npb25zIHdpdGhpbiB0aGUgc3RhdGVtZW50cywgbGlrZSB2YXJpYWJsZSBsb29rdXBzLFxuICAgICAgICAgICAgICAgIC8vIGFyZSBub3QgY2FsbGVkIGJlZm9yZSBhbnkgcHJlY2VkaW5nIHN0YXRlbWVudHMgaGF2ZSBiZWVuIGludGVycHJldGVkIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2VzIGhhdmUgYWxyZWFkeSBiZWVuIHNlbnQuIEZvciBleGFtcGxlLCBzdGF0ZW1lbnQgMSBtaWdodFxuICAgICAgICAgICAgICAgIC8vIHNldCBhIHZhcmlhYmxlIHRoYXQgc3RhdGVtZW50IDIgbmVlZHMgdG8gbG9va3VwIGFuZCB1c2UsIHNvIHdlIHdhbnQgdGhlIGxvb2t1cCB0b1xuICAgICAgICAgICAgICAgIC8vIG9jY3VyIGFmdGVyIHN0YXRlbWVudCAxIGhhcyBiZWVuIGludGVycHJldGVkIGFuZCB0aGUgbWVzc2FnZSBmb3IgaXQgaGFzXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBzZW50LlxuICAgICAgICAgICAgICAgIHN0YXRlbWVudExpc3QuY2hpbGRyZW4uZm9yRWFjaChzdGF0ZW1lbnRMaW5lcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudExpbmVzLmNoaWxkcmVuLmZvckVhY2goc3RhdGVtZW50TGluZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHN0YXRlbWVudExpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcGFydENvbnRleHQuX2NvbW1hbmRIYW5kbGVyc1ttZXNzYWdlTmFtZV0gPSBoYW5kbGVyRnVuY3Rpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWVzc2FnZUhhbmRsZXJPcGVuOiBmdW5jdGlvbihsaXRlcmFsT24sIG1lc3NhZ2VOYW1lLCBvcHRpb25hbFBhcmFtZXRlckxpc3Qpe1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgUGFyYW1ldGVyTGlzdCBoZXJlIGlzIG9wdGlvbmFsLCBpZlxuICAgICAgICAgICAgLy8gaXQgaXMgc2V0IGl0IHdpbGwgYmUgaW4gdGhlIGZvcm0gb2YgYSBzaXplIDEgYXJyYXkuXG4gICAgICAgICAgICAvLyBUaGlzIHNpbmdsZSBhcnJheSBpdGVtIHdpbGwgaXRzZWxmIGJlIGFuIGFycmF5IG9mIHRoZVxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIHZhcmlhYmxlIG5hbWVzLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhbiBlbXB0eSBhcnJheSBpbmRpY2F0ZXMgbm8gcGFyYW1zXG4gICAgICAgICAgICAvLyBhcmUgcGFzc2VkIGluIGZvciB0aGlzIGhhbmRsZXJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBvcHRpb25hbFBhcmFtZXRlckxpc3QuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihwYXJhbXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlTmFtZTogbWVzc2FnZU5hbWUuc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBQYXJhbWV0ZXJMaXN0OiBmdW5jdGlvbihwYXJhbWV0ZXJTdHJpbmcpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlclN0cmluZy5hc0l0ZXJhdGlvbigpLmNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgSW5DbGF1c2U6IGZ1bmN0aW9uKGluTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hbnN3ZXI6IGZ1bmN0aW9uKGFuc3dlciwgZXhwcmVzc2lvbil7XG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImFuc3dlclwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5pbnRlcnByZXQoKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfZ29Ub0RpcmVjdGlvbjogZnVuY3Rpb24oZ29Ub0xpdGVyYWwsIG5leHRQcmV2aW91cywgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgICAgICBhcmdzLnB1c2gobmV4dFByZXZpb3VzLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICBpZiAoc3lzdGVtT2JqZWN0LnNvdXJjZVN0cmluZyl7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHN5c3RlbU9iamVjdC5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImdvIHRvIGRpcmVjdGlvblwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfZ29Ub1dlYnNpdGU6IGZ1bmN0aW9uKGdvVG9MaXRlcmFsLCB3ZWJzaXRlTGl0ZXJhbCwgdXJsKXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHVybC5pbnRlcnByZXQoKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJnbyB0byB3ZWJzaXRlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9nb1RvQnlTcGVjaWZpZXI6IGZ1bmN0aW9uKGdvVG9MaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IHRhcmdldElkID0gb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoIXRhcmdldElkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0YXJnZXRQYXJ0ID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYodGFyZ2V0UGFydC50eXBlID09IFwiY2FyZFwiIHx8IHRhcmdldFBhcnQudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJnbyB0byByZWZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UGFydC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWRcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgcGFydCBpcyBuZWl0aGVyIGEgQ2FyZCBub3JcbiAgICAgICAgICAgIC8vIGEgU3RhY2ssIHdlIGRvbid0IGdvIHRvIGl0LiBJbnN0ZWFkLCB3ZSBkb1xuICAgICAgICAgICAgLy8gbm90aGluZy5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYWRkUHJvcGVydHk6IGZ1bmN0aW9uKGFkZExpdGVyYWwsIHByb3BlcnR5TGl0ZXJhbCwgcHJvcE5hbWVBc0xpdGVyYWwsIHRvTGl0ZXJhbCwgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCBzcGVjaWZpZWRPYmplY3RJZCA9IHN5c3RlbU9iamVjdC5pbnRlcnByZXQoKVswXSB8fCBudWxsO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgcHJvcE5hbWVBc0xpdGVyYWwuaW50ZXJwcmV0KCksIC8vIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkT2JqZWN0SWRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwibmV3UHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2FkZE1vZGVsOiBmdW5jdGlvbihhZGRMaXRlcmFsLCBuZXdQYXJ0VHlwZSwgb3B0aW9uYWxQYXJ0TmFtZSl7XG4gICAgICAgICAgICAvLyBoZXJlIG5vIG93bmVyIGhhcyBiZWVuIHByb3ZpZGVkIHNvIHdlIGFzc3VtZSBpdCBpcyB0aGUgZmlyc3QgcG9zc2libGUgb25lXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZmluZEZpcnN0UG9zc2libGVBbmNlc3RvcihwYXJ0Q29udGV4dCwgbmV3UGFydFR5cGUuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIG5ld1BhcnRUeXBlLnNvdXJjZVN0cmluZyxcbiAgICAgICAgICAgICAgICBwYXJlbnQuaWRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgb3B0aW9uYWxOYW1lID0gb3B0aW9uYWxQYXJ0TmFtZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsTmFtZSAmJiBvcHRpb25hbE5hbWUubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9uYWxOYW1lWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJuZXdNb2RlbFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYWRkTW9kZWxUbzogZnVuY3Rpb24oYWRkTGl0ZXJhbCwgbmV3UGFydFR5cGUsIG9wdGlvbmFsUGFydE5hbWUsIHRvTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIG5ld1BhcnRUeXBlLnNvdXJjZVN0cmluZywgLy8gVGhlIGtpbmQgb2YgcGFydCB0byBhZGRcbiAgICAgICAgICAgICAgICBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCkgLy8gaWQgb2YgdGhlIHBhcmVudCBtb2RlbCBwYXJ0XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgb3B0aW9uYWxOYW1lID0gb3B0aW9uYWxQYXJ0TmFtZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsTmFtZSAmJiBvcHRpb25hbE5hbWUubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9uYWxOYW1lWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJuZXdNb2RlbFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfcHV0VmFyaWFibGU6IGZ1bmN0aW9uKHB1dExpdGVyYWwsIHZhbHVlLCBpbnRvTGl0ZXJhbCwgZ2xvYmFsTGl0ZXJhbCwgZGVzdGluYXRpb24pe1xuICAgICAgICAgICAgbGV0IGdsb2JhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoZ2xvYmFsTGl0ZXJhbC5zb3VyY2VTdHJpbmcpe1xuICAgICAgICAgICAgICAgIGdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgdmFsdWUuaW50ZXJwcmV0KCksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIGdsb2JhbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdwdXRJbnRvJyxcbiAgICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2RlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbihkZWxldGVMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lQXNMaXRlcmFsLCBmcm9tTGl0ZXJhbCwgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCBzcGVjaWZpZWRPYmplY3RJZCA9IHN5c3RlbU9iamVjdC5pbnRlcnByZXQoKVswXSB8fCBudWxsO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgcHJvcE5hbWVBc0xpdGVyYWwuaW50ZXJwcmV0KCksIC8vIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkT2JqZWN0SWRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZGVsZXRlUHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2RlbGV0ZU1vZGVsOiBmdW5jdGlvbihkZWxldGVMaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpIC8vIGlkIG9mIHRoZSBvYmplY3RcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZGVsZXRlTW9kZWxcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX3NldFByb3BlcnR5OiBmdW5jdGlvbihzZXRMaXRlcmFsLCBwcm9wTmFtZUFzTGl0ZXJhbCwgdG9MaXRlcmFsLCBsaXRlcmFsT3JWYXJOYW1lLCBvcHRpb25hbEluQ2xhdXNlKXtcbiAgICAgICAgICAgIGxldCBzcGVjaWZpZWRPYmplY3RJZCA9IG9wdGlvbmFsSW5DbGF1c2UuaW50ZXJwcmV0KClbMF0gfHwgbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHByb3BOYW1lQXNMaXRlcmFsLmludGVycHJldCgpLCAvLyBUaGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIGxpdGVyYWxPclZhck5hbWUuaW50ZXJwcmV0KCksIC8vIFRoZSB2YWx1ZSBvciBhIHZhciByZXByZXNlbnRpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkT2JqZWN0SWRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwic2V0UHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX3NldFNlbGVjdGlvbjogZnVuY3Rpb24oc2V0TGl0ZXJhbCwgc2VsZWN0aW9uTGl0ZXJhbCwgcHJvcE5hbWVBc0xpdGVyYWwsIHRvTGl0ZXJhbCwgbGl0ZXJhbE9yVmFyTmFtZSwgb3B0aW9uYWxJbkNsYXVzZSl7XG4gICAgICAgICAgICBsZXQgc3BlY2lmaWVkT2JqZWN0SWQgPSBvcHRpb25hbEluQ2xhdXNlLmludGVycHJldCgpWzBdIHx8IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZUFzTGl0ZXJhbC5pbnRlcnByZXQoKSwgLy8gVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBsaXRlcmFsT3JWYXJOYW1lLmludGVycHJldCgpLCAvLyBUaGUgdmFsdWUgb3IgYSB2YXIgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgIHNwZWNpZmllZE9iamVjdElkXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcInNldFNlbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYXNrOiBmdW5jdGlvbihhc2tMaXRlcmFsLCBxdWVzdGlvbil7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImFza1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsgcXVlc3Rpb24uaW50ZXJwcmV0KCkgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX3RlbGxDb21tYW5kOiBmdW5jdGlvbih0ZWxsTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyLCB0b0xpdGVyYWwsIGNvbW1hbmQpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICd0ZWxsJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5pbnRlcnByZXQoKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hcmJpdHJhcnlDb21tYW5kOiBmdW5jdGlvbihjb21tYW5kTmFtZSwgb3B0aW9uYWxBcmd1bWVudExpc3Qpe1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgYXJndW1lbnQgbGlzdCBpcyBvcHRpb25hbCBoZXJlLCBpdCB3aWxsXG4gICAgICAgICAgICAvLyBiZSBlaXRoZXIgYW4gZW1wdHkgYXJyYXkgKG5vIGFyZ3VtZW50cykgb3IgYSBzaXplIDFcbiAgICAgICAgICAgIC8vIGFycmF5ICh3aGljaCBpdHNlbGYgd2lsbCBjb250YWluIGFuIGFycmF5IG9mIHRoZSBhcmd1bWVudHMpXG4gICAgICAgICAgICBsZXQgb3B0aW9uYWxBcmd1bWVudHMgPSBvcHRpb25hbEFyZ3VtZW50TGlzdC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsQXJndW1lbnRzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsQXJndW1lbnRzID0gb3B0aW9uYWxBcmd1bWVudHNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IGNvbW1hbmROYW1lLnNvdXJjZVN0cmluZyxcbiAgICAgICAgICAgICAgICBhcmdzOiBvcHRpb25hbEFyZ3VtZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kQXJndW1lbnRMaXN0OiBmdW5jdGlvbihsaXN0KXtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmFzSXRlcmF0aW9uKCkuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3RhdGVtZW50TGluZTogZnVuY3Rpb24oc3RhdGVtZW50LCBuZXdsaW5lKXtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gc3RhdGVtZW50LmludGVycHJldCgpO1xuXG4gICAgICAgICAgICAvLyBTb21lIHN0YXRlbWVudHMsIGxpa2UgaWYtdGhlbiBjb250cm9sc1xuICAgICAgICAgICAgLy8gYW5kIHJlcGVhdCBjb250cm9scywgZG8gbm90IHJlc3VsdCBpblxuICAgICAgICAgICAgLy8gbWVzc2FnZXMgYnV0IHJldHVybiBudWxsLlxuICAgICAgICAgICAgLy8gV2UgaWdub3JlIHRoZXNlLlxuICAgICAgICAgICAgaWYobWVzc2FnZSAmJiB0eXBlb2YobWVzc2FnZSkgIT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZFJlc3VsdCA9IHBhcnRDb250ZXh0LnNlbmRNZXNzYWdlKG1lc3NhZ2UsIHBhcnRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBzeXN0ZW1Db250ZXh0LmV4ZWN1dGlvblN0YWNrLmN1cnJlbnQuc2V0TG9jYWwoJ2l0JywgY29tbWFuZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFN0YXRlbWVudDogZnVuY3Rpb24oYWN0dWFsU3RhdGVtZW50LCBvcHRpb25hbENvbW1lbnQpe1xuICAgICAgICAgICAgcmV0dXJuIGFjdHVhbFN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX2FkZEV4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwcmVzc2lvbiwgb3BlcmF0aW9uLCBzZWNvbmRFeHByZXNzaW9uKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ICsgc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fbWludXNFeHByOiBmdW5jdGlvbihmaXJzdEV4cHIsIG9wZXJhdGlvbiwgc2Vjb25kRXhwcil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmaXJzdEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX2RpdmlkZUV4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwciwgb3BlcmF0aW9uLCBzZWNvbmRFeHByKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0IC8gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fbW9kdWxvRGl2aWRlRXhwcjogZnVuY3Rpb24oZmlyc3RFeHByLCBvcGVyYXRpb24sIHNlY29uZEV4cHIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHNlY29uZEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgJSBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvbl90aW1lc0V4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwcmVzc2lvbiwgb3BlcmF0aW9uLCBzZWNvbmRFeHByZXNzaW9uKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ICogc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fc3RyaW5nQ29uY2F0RXhwcjogZnVuY3Rpb24oZmlyc3RFeHByZXNzaW9uLCBvcGVyYXRpb24sIHNlY29uZEV4cHJlc3Npb24pe1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBlbmNvdW50ZXIgdGhlIFwiJlwiIG9wZXJhdG9yLCB3ZSBjb2VyY2UgYm90aCBleHByZXNzaW9ucyBpbnRvXG4gICAgICAgICAgICAvLyBhIHN0cmluZ1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByZXNzaW9uLmludGVycHJldCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwcmVzc2lvbi5pbnRlcnByZXQoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2ZpcnN0fSR7c2Vjb25kfWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRmFjdG9yX3BhcmVuRmFjdG9yOiBmdW5jdGlvbihsZWZ0UGFyZW4sIGV4cHJlc3Npb24sIHJpZ2h0UGFyZW4pe1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRmFjdG9yX25vdEZhY3RvcjogZnVuY3Rpb24obm90TGl0ZXJhbCwgZXhwcmVzc2lvbil7XG4gICAgICAgICAgICByZXR1cm4gIWV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXF1YWxpdHlDb25kaXRpb25hbDogZnVuY3Rpb24oZXhwcjEsIGNvbXBhcmF0b3JMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBleHByMS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBleHByMi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIE5vbkVxdWFsaXR5Q29uZGl0aW9uYWw6IGZ1bmN0aW9uKGV4cHIxLCBjb21wYXJhdG9yTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgIT09IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb25kaXRpb25hbF9ndENvbXBhcmlzb246IGZ1bmN0aW9uKGV4cHIxLCBndExpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID4gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsX2x0Q29tcGFyaXNvbjogZnVuY3Rpb24oZXhwcjEsIGx0TGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPCBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxfZ3RlQ29tcGFyaXNvbjogZnVuY3Rpb24oZXhwcjEsIGd0ZUxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID49IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb25kaXRpb25hbF9sdGVDb21wYXJpc29uOiBmdW5jdGlvbihleHByMSwgbHRlTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZXJlSXNBbk9iamVjdENvbmRpdGlvbmFsOiBmdW5jdGlvbih0aGVyZUxpdGVyYWwsIGlzTGl0ZXJhbCwgYU9yQW5MaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzTm90QW5PYmplY3RDb25kaXRpb25hbDogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIG5vdExpdGVyYWwsIGFPckFuTGl0ZXJhbCwgaW5DbGF1c2Upe1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzQVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIGFMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lLCBvZkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXJ0IHdpdGggaWQgJHt0YXJnZXRJZH0gKCR7dGhpcy5zb3VyY2VTdHJpbmd9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKHByb3BOYW1lLmludGVycHJldCgpKTtcbiAgICAgICAgICAgIGlmKHByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzQVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aG91dFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIGFMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lKXtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IHBhcnRDb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKHByb3BOYW1lLmludGVycHJldCgpKTtcbiAgICAgICAgICAgIGlmKHByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzTm90QVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIG5vdExpdGVyYWwsIGFMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lLCBvZkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXJ0IHdpdGggaWQgJHt0YXJnZXRJZH0gKCR7dGhpcy5zb3VyY2VTdHJpbmd9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKHByb3BOYW1lLmludGVycHJldCgpKTtcbiAgICAgICAgICAgIGlmKHByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzTm90QVByb3BlcnR5Q29uZGl0aW9uYWxfd2l0aG91dFNwZWNpZmllcjogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIG5vdExpdGVyYWwsIGFMaXRlcmFsLCBwcm9wTGl0ZXJhbCwgcHJvcE5hbWUpe1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gcGFydENvbnRleHQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUuaW50ZXJwcmV0KCkpO1xuICAgICAgICAgICAgaWYocHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlbklubGluZTogZnVuY3Rpb24oaWZMaXRlcmFsLCBjb25kaXRpb25hbCwgdGhlbkxpdGVyYWwsIHN0YXRlbWVudCwgb3B0aW9uYWxDb21tZW50KXtcbiAgICAgICAgICAgIGxldCBzaG91bGRFdmFsdWF0ZSA9IGNvbmRpdGlvbmFsLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoc2hvdWxkRXZhbHVhdGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlblNpbmdsZWxpbmVfd2l0aG91dEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0xLCB0aGVuTGluZSl7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gaWZMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoY29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhlbkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlblNpbmdsZWxpbmVfd2l0aEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0xLCB0aGVuTGluZSwgbGluZVRlcm0yLCBlbHNlTGluZSl7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gaWZMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoY29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhlbkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbHNlTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBJZlRoZW5NdWx0aWxpbmVfd2l0aEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0sIG11bHRpVGhlbiwgbXVsdGlFbHNlLCBlbmRJZkxpbmUpe1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvbiA9IGlmTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKGNvbmRpdGlvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11bHRpVGhlbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11bHRpRWxzZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBJZlRoZW5NdWx0aWxpbmVfd2l0aG91dEVsc2U6IGZ1bmN0aW9uKGlmTGluZSwgbGluZVRlcm0sIG11bHRpVGhlbiwgZW5kSWZMaW5lKXtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBpZkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihjb25kaXRpb24pe1xuICAgICAgICAgICAgICAgIHJldHVybiBtdWx0aVRoZW4uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBJZkxpbmU6IGZ1bmN0aW9uKGlmTGl0ZXJhbCwgY29uZGl0aW9uYWwsIG9wdGlvbmFsQ29tbWVudCl7XG4gICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uYWwuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlbkxpbmU6IGZ1bmN0aW9uKHRoZW5MaXRlcmFsLCBzdGF0ZW1lbnQsIG9wdGlvbmFsQ29tbWVudCl7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEVsc2VMaW5lOiBmdW5jdGlvbihlbHNlTGl0ZXJhbCwgc3RhdGVtZW50LCBvcHRpb25hbENvbW1lbnQpe1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb250cm9sU3RhdGVtZW50TGluZTogZnVuY3Rpb24oc3RhdGVtZW50TGluZSl7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50TGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBNdWx0aVRoZW46IGZ1bmN0aW9uKHRoZW5MaXRlcmFsLCBvcHRpb25hbENvbW1lbnQsIGxpbnRUZXJtLCBjb250cm9sU3RhdGVtZW50TGluZXMpe1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xTdGF0ZW1lbnRMaW5lcy5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBNdWx0aUVsc2U6IGZ1bmN0aW9uKGVsc2VMaXRlcmFsLCBvcHRpb25hbENvbW1lbnQsIGxpbmVUZXJtLCBjb250cm9sU3RhdGVtZW50TGluZXMpe1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xTdGF0ZW1lbnRMaW5lcy5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBLaW5kQ29uZGl0aW9uYWw6IGZ1bmN0aW9uKGV4cHIxLCBjb21wYXJhdG9yTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgLy8gVE9ETzogRmxlc2ggb3V0IHRoaXMgZnVuY3Rpb24gdG8gYWNjb3VudCBmb3JcbiAgICAgICAgICAgIC8vIHZhcmlvdXMgb2JqZWN0IHR5cGVzIGFuZCB0aGVpciBraW5kIGNvbXBhcmlzb25zXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTm90S2luZENvbmRpdGlvbmFsOiBmdW5jdGlvbihleHByMSwgY29tcGFyYXRvckxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIC8vIFRPRE86IEZsZXNoIG91dCB0aGlzIGZ1bmN0aW9uIHRvIGFjY291bnQgZm9yXG4gICAgICAgICAgICAvLyB2YXJpb3VzIG9iamVjdCB0eXBlcyBhbmQgdGhlaXIga2luZCBjb21wYXJpc29uc1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0Q29udHJvbEZvcm1fZm9yTnVtVGltZXM6IGZ1bmN0aW9uKHJlcGVhdExpdCwgb3B0aW9uYWxGb3JMaXQsIGludE9yVmFyLCB0aW1lc0xpdCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcGVhdFR5cGU6ICdmb3JOdW1UaW1lcycsXG4gICAgICAgICAgICAgICAgbnVtVGltZXM6IGludE9yVmFyLmludGVycHJldCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdENvbnRyb2xGb3JtX3VudGlsQ29uZGl0aW9uOiBmdW5jdGlvbihyZXBlYXRMaXQsIHVudGlsTGl0LCBjb25kaXRpb25hbCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcGVhdFR5cGU6ICd1bnRpbENvbmRpdGlvbicsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBjb25kaXRpb25hbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRDb250cm9sRm9ybV93aGlsZUNvbmRpdGlvbjogZnVuY3Rpb24ocmVwZWF0TGl0LCB3aGlsZUxpdCwgY29uZGl0aW9uYWwpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXBlYXRUeXBlOiAnd2hpbGVDb25kaXRpb24nLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0Q29udHJvbEZvcm1fd2l0aFN0YXJ0RmluaXNoOiBmdW5jdGlvbihyZXBlYXRMaXQsIHdpdGhMaXQsIHZhck5hbWUsIGVxTGl0LCBmaXJzdFZhbCwgdG9MaXQsIHNlY29uZFZhbCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcGVhdFR5cGU6ICd3aXRoU3RhcnRGaW5pc2gnLFxuICAgICAgICAgICAgICAgIHZhck5hbWU6IHZhck5hbWUuc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFZhbC5pbnRlcnByZXQoKSxcbiAgICAgICAgICAgICAgICBmaW5pc2g6IHNlY29uZFZhbC5pbnRlcnByZXQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRBZGp1c3RfZXhpdDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByZXR1cm4gJ2V4aXQgcmVwZWF0JztcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRBZGp1c3RfbmV4dDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByZXR1cm4gJ25leHQgcmVwZWF0JztcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRCbG9jazogZnVuY3Rpb24ocmVwZWF0Q29udHJvbCwgbGluZVRlcm0sIHN0YXRlbWVudExpbmVPclJlcEFkanVzdFBsdXMsIGVuZExpdGVyYWwpe1xuICAgICAgICAgICAgbGV0IHJlcGVhdEluZm8gPSByZXBlYXRDb250cm9sLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHN0YXRlbWVudExpbmVzID0gc3RhdGVtZW50TGluZU9yUmVwQWRqdXN0UGx1cy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHN3aXRjaChyZXBlYXRJbmZvLnJlcGVhdFR5cGUpe1xuICAgICAgICAgICAgY2FzZSAnZm9yTnVtVGltZXMnOlxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gcmVwZWF0SW5mby5udW1UaW1lczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRQYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBzdGF0ZW1lbnRMaW5lcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlbWVudCA9IHN0YXRlbWVudExpbmVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGN1cnJlbnRTdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT0gJ2V4aXQgcmVwZWF0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzdWx0ID09ICduZXh0IHJlcGVhdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkUGFzcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkQnJlYWspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGUgbWFpbiBmb3IgbG9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBCcmVhayBvdXQgb2YgdGhlIHN3aXRjaFxuICAgICAgICAgICAgY2FzZSAndW50aWxDb25kaXRpb24nOlxuICAgICAgICAgICAgICAgIGxldCB1bnRpbFRlc3RDb25kaXRpb24gPSByZXBlYXRJbmZvLmNvbmRpdGlvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSghdW50aWxUZXN0Q29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdGF0ZW1lbnRMaW5lcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlbWVudCA9IHN0YXRlbWVudExpbmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGN1cnJlbnRTdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PSAnZXhpdCByZXBlYXQnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzdWx0ID09ICduZXh0IHJlcGVhdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkQnJlYWspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGUgb3V0ZXIgd2hpbGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVudGlsVGVzdENvbmRpdGlvbiA9IHJlcGVhdEluZm8uY29uZGl0aW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhazsgLy8gQnJlYWsgb3V0IG9mIHRoZSBzd2l0Y2ggY2FzZVxuICAgICAgICAgICAgY2FzZSAnd2hpbGVDb25kaXRpb24nOlxuICAgICAgICAgICAgICAgIGxldCB3aGlsZVRlc3RDb25kaXRpb24gPSByZXBlYXRJbmZvLmNvbmRpdGlvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSh3aGlsZVRlc3RDb25kaXRpb24pe1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHN0YXRlbWVudExpbmVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGVtZW50ID0gc3RhdGVtZW50TGluZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudFN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PSAnZXhpdCByZXBlYXQnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihyZXN1bHQgPT0gXCJuZXh0IHJlcGVhdFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoaXMgaW5uZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHNob3VsZEJyZWFrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2Ygb3V0ZXIgd2hpbGUgbG9vcCAoZW5kIHJlcGVhdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZVRlc3RDb25kaXRpb24gPSByZXBlYXRJbmZvLmNvbmRpdGlvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiBzd2l0Y2ggY2FzZVxuICAgICAgICAgICAgY2FzZSAnd2l0aFN0YXJ0RmluaXNoJzpcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSBhc3N1bWUgdGhhdCBzdGFydCBpcyBsZXNzIHRoYW5cbiAgICAgICAgICAgICAgICAvLyBmaW5pc2guIFdlIHNob3VsZCBwcm9iYWJseSB0aHJvdyBhbiBlcnJvciBpZlxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGlmKHJlcGVhdEluZm8uc3RhcnQgPiByZXBlYXRJbmZvLmZpbmlzaCl7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVwZWF0IGVycm9yOiBzdGFydCBncmVhdGVyIHRoYW4gZmluaXNoYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gcmVwZWF0SW5mby5zdGFydDsgaSA8PSByZXBlYXRJbmZvLmZpbmlzaDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtQ29udGV4dC5leGVjdXRpb25TdGFjay5jdXJyZW50LnNldExvY2FsKHJlcGVhdEluZm8udmFyTmFtZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkUGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgc3RhdGVtZW50TGluZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRMaW5lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBjdXJyZW50U3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09IFwiZXhpdCByZXBlYXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzdWx0ID09IFwibmV4dCByZXBlYXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRQYXNzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRCcmVhayl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoZSBvdXRlciAocmVwZWF0KSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBQcm9wZXJ0eVZhbHVlX3dpdGhTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZUxpdGVyYWwsIHByb3BOYW1lLCBvZkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXJ0IHdpdGggaWQgJHt0YXJnZXRJZH0gKCR7dGhpcy5zb3VyY2VTdHJpbmd9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wTmFtZS5pbnRlcnByZXQoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBQcm9wZXJ0eVZhbHVlX3dpdGhvdXRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZUxpdGVyYWwsIHByb3BOYW1lKXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q29udGV4dC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHBhcnRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHByb3BOYW1lLmludGVycHJldCgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBPYmplY3QgU3BlY2lmaWVycyAqKi9cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydEJ5VGFyZ2V0IFBhcnRpYWwgU3BlY2lmaWVyXG4gICAgICAgICAqIHJlZmVycyB0byBwYXJ0aWFscyB0aGF0IHNwZWNpZnkgYSBwYXJ0XG4gICAgICAgICAqIHNwZWNpZmllZCBpbiB0aGUgXCJ0YXJnZXRcIiBQYXJ0UHJvcGVydHlcbiAgICAgICAgICogb2YgdGhlIGNvbnRleHQgcGFydC4gVGhlIHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiB0YXJnZXQgcHJvcGVydHkgaXMgYW55IHZhbGlkIE9iamVjdFNwZWNpZmllclxuICAgICAgICAgKiBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWFsU3BlY2lmaWVyX3BhcnRCeVRhcmdldCh0YXJnZXRMaXRlcmFsKXtcbiAgICAgICAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRQcm9wVmFsdWUgPSBjb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoY29udGV4dCwgXCJ0YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBwYXJ0Q29udGV4dCBzaW5jZSB0aGUgY29udGV4dCBvYmplY3QgbWlnaHQgbm90IGhhdmUgYW55IHNlbWFudGljcyBzZXQgb24gaXRcbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgYSBjb250ZXh0IG9iamVjdC9wYXJ0IHdoaWNoIGRvZXMgbm90IGhhdmUgYSBzY3JpcHQgd2hpY2ggaGFzIGJlZW5cbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCB3aWxsIG5vdCBoYXZlIGhhZCBjb250ZXh0Ll9zZW1hbnRpY3Mgc2V0LlxuICAgICAgICAgICAgICAgIGxldCBzZW1hbnRpY3MgPSBwYXJ0Q29udGV4dC5fc2VtYW50aWNzO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaE9iamVjdCA9IHN5c3RlbUNvbnRleHQuZ3JhbW1hci5tYXRjaCh0YXJnZXRQcm9wVmFsdWUsICdPYmplY3RTcGVjaWZpZXInKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobWF0Y2hPYmplY3QpLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1Db250ZXh0LnBhcnRzQnlJZFt0YXJnZXRJZF07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudENhcmQgUGFydGlhbCBTcGVjaWZpZXJcbiAgICAgICAgICogcmVmZXJzIHRvIHBhcnRpYWxzIHRoYXQgc3BlY2lmeSB0aGUgY3VycmVudCBjYXJkXG4gICAgICAgICAqIGRlcGVuZGluZyBvbiB0aGUgc3RhY2sgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfY3VycmVudENhcmQ6IGZ1bmN0aW9uKGN1cnJlbnRMaXRlcmFsLCBjYXJkTGl0ZXJhbCl7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0UGFydC5jdXJyZW50Q2FyZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlJbmRleCBQYXJ0aWFsIFNwZWNpZmllclxuICAgICAgICAgKiByZWZlcnMgdG8gcGFydGlhbHMgdGhhdCBzcGVjaWZ5IGEgcGFydFxuICAgICAgICAgKiB0eXBlIGFuZCBhbiBpbnRlZ2VyIGxpdGVyYWwsIGZvciBleDpcbiAgICAgICAgICogICAgIGZpZWxkIDNcbiAgICAgICAgICogVGhlIGFib3ZlIGV4YW1wbGUgcmVmZXJzIHRvIHRoZSB0aGlyZFxuICAgICAgICAgKiBmaWVsZCBwYXJ0IGluIGl0cyBvd25lci9wYXJlbnQgcGFydC5cbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfcGFydEJ5SW5kZXg6IGZ1bmN0aW9uKG9iamVjdFR5cGUsIGludGVnZXJMaXRlcmFsKXtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGludGVnZXJMaXRlcmFsLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoaW5kZXggPCAxKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnQgaW5kaWNlcyBtdXN0IGJlIDEgb3IgZ3JlYXRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICBpZihvYmplY3RUeXBlLnNvdXJjZVN0cmluZyA9PSAncGFydCcpe1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA+IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSBwYXJ0IG51bWJlcmVkICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRQYXJ0LnN1YnBhcnRzW2luZGV4LTFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0c09mVHlwZSA9IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gb2JqZWN0VHlwZS5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA+IHBhcnRzT2ZUeXBlLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSAke29iamVjdFR5cGUuc291cmNlU3RyaW5nfSBudW1iZXJlZCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c09mVHlwZVtpbmRleC0xXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydEJ5TnVtZXJpY2FsSW5kZXggUGFydGlhbCBTcGVjaWZpZXJcbiAgICAgICAgICogcmVmZXJzIHRvIHBhcnRpYWwgdGhhdCBzcGVjaWZ5IGEgcGFydFxuICAgICAgICAgKiB0eXBlIHByZWNlZGVkIGJ5IHRoZSBFbmdsaXNoIHdvcmQgZm9yIHRoZVxuICAgICAgICAgKiBudW1iZXIuIEZvciB0aGUgbW9tZW50IHdlIGFjY2VwdCBmaXJzdCAtIHRlbnRoXG4gICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAqICAgICBzaXh0aCBidXR0b25cbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfcGFydEJ5TnVtZXJpY2FsSW5kZXg6IGZ1bmN0aW9uKG51bWVyaWNhbEtleXdvcmQsIG9iamVjdFR5cGUpe1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVtZXJpY2FsS2V5d29yZC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgaWYob2JqZWN0VHlwZS5zb3VyY2VTdHJpbmcgPT0gJ3BhcnQnKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPiBjb250ZXh0UGFydC5zdWJwYXJ0cy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHRQYXJ0LnR5cGV9WyR7Y29udGV4dFBhcnQuaWR9XSBkb2VzIG5vdCBoYXZlIGEgcGFydCBudW1iZXJlZCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4IDwgMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhlIFwibGFzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIG9mIHRoZSBkZXNpcmVkIGNvbGxlY3Rpb24gd2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0UGFydC5zdWJwYXJ0c1tjb250ZXh0UGFydC5zdWJwYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0UGFydC5zdWJwYXJ0c1tpbmRleC0xXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0c09mVHlwZSA9IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gb2JqZWN0VHlwZS5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA+IHBhcnRzT2ZUeXBlLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSAke29iamVjdFR5cGUuc291cmNlU3RyaW5nfSBudW1iZXJlZCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4IDwgMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhlIFwibGFzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIG9mIHRoZSBkZXNpcmVkIGNvbGxlY3Rpb24gd2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c09mVHlwZVtwYXJ0c09mVHlwZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c09mVHlwZVtpbmRleC0xXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlOYW1lIFBhcnRpYWwgU3BlY2lmaWVyXG4gICAgICAgICAqIHJlZmVycyB0byBhIHBhcnRpYWwgdGhhdCBzcGVjaWZpZXMgYSBwYXJ0XG4gICAgICAgICAqIGJ5IGl0cyBuYW1lIHByb3BlcnR5LiBFeGFtcGxlOlxuICAgICAgICAgKiAgICAgY2FyZCBcIk15IEN1c3RvbSBDYXJkXCJcbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfcGFydEJ5TmFtZTogZnVuY3Rpb24ob2JqZWN0VHlwZSwgc3RyaW5nTGl0ZXJhbCl7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHN0cmluZ0xpdGVyYWwuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihvYmplY3RUeXBlLnNvdXJjZVN0cmluZyA9PSAncGFydCcpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZE5hbWUgPSBzdWJwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PSBmb3VuZE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihmb3VuZC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0UGFydC50eXBlfVske2NvbnRleHRQYXJ0LmlkfV0gZG9lcyBub3QgaGF2ZSBhIHBhcnQgbmFtZWQgXCIke25hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb250ZXh0UGFydC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09IG9iamVjdFR5cGUuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmROYW1lID0gc3VicGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnBhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kTmFtZSA9PSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZm91bmQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSAke29iamVjdFR5cGUuc291cmNlU3RyaW5nfSBuYW1lZCBcIiR7bmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAndGhpcycgc3BlY2lmaWVyIGlzIGEgdGVybWluYWwgKGZpbmFsKVxuICAgICAgICAgKiBzcGVjaWZpZXIgdGhhdCByZWZlcnMgdG8gb25lIG9mIHRocmVlIHRoaW5nczpcbiAgICAgICAgICogMS4gdGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgcGFydCBleGVjdXRpbmcgdGhlIHNjcmlwdCxcbiAgICAgICAgICogICAgZXhhbXBsZTogdGhpcyBidXR0b25cbiAgICAgICAgICogMi4gQ2FyZCwgd2hpY2ggcmVmZXJzIHRvIHRoZSBjYXJkIHRoYXQgb3ducyB0aGVcbiAgICAgICAgICogICAgcGFydCB0aGF0IGlzIGN1cnJlbnRseSBleGVjdXRpbmcgdGhlIHNjcmlwdCwgZXg6XG4gICAgICAgICAqICAgIHRoaXMgY2FyZFxuICAgICAgICAgKiAzLiBTdGFjaywgd2hpY2ggcmVmZXJzIHRvIHRoZSBzdGFjayB0aGF0IG93bnMgdGhlXG4gICAgICAgICAqICAgIHBhcnQgdGhhdCBpcyBjdXJyZW50bHkgZXhlY3V0aW5nIHRoZSBzY3JpcHQsIGV4OlxuICAgICAgICAgKiAgICB0aGlzIHN0YWNrXG4gICAgICAgICAqL1xuICAgICAgICBUZXJtaW5hbFNwZWNpZmllcl90aGlzU3lzdGVtT2JqZWN0OiBmdW5jdGlvbih0aGlzTGl0ZXJhbCwgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCB0YXJnZXRUeXBlID0gc3lzdGVtT2JqZWN0LnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0VHlwZSA9PSBwYXJ0Q29udGV4dC50eXBlKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRDb250ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5kTmVhcmVzdFBhcmVudE9mS2luZChwYXJ0Q29udGV4dCwgdGFyZ2V0VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICdjdXJyZW50JyBzcGVjaWZpZXIgaXMgYSB0ZXJtaW5hbCAoZmluYWwpXG4gICAgICAgICAqIHNwZWNpZmllciB0aGF0IHJlZmVycyB0byBlaXRoZXIgdGhlIGN1cnJlbnQgY2FyZCBvciBzdGFja1xuICAgICAgICAgKiBiZWluZyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIFRoZXJlIGFyZSBvbmx5IHR3byBwb3NzaWJsZSB2YWxpZCBvcHRpb25zOlxuICAgICAgICAgKiAgICAgYGN1cnJlbnQgY2FyZGBcbiAgICAgICAgICogICAgIGBjdXJyZW50IHN0YWNrYFxuICAgICAgICAgKi9cbiAgICAgICAgVGVybWluYWxTcGVjaWZpZXJfY3VycmVudFN5c3RlbU9iamVjdDogZnVuY3Rpb24oY3VycmVudExpdGVyYWwsIHN5c3RlbU9iamVjdCl7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VHlwZSA9IHN5c3RlbU9iamVjdC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIGlmKHRhcmdldFR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1Db250ZXh0LmdldEN1cnJlbnRTdGFja01vZGVsKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRhcmdldFR5cGUgPT0gJ2NhcmQnKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbUNvbnRleHQuZ2V0Q3VycmVudENhcmRNb2RlbCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0YXJnZXRUeXBlfSBjYW5ub3QgYmUgYSAnY3VycmVudCcgc3lzdGVtIG9iamVjdGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlJZCBzcGVjaWZpZXIgaXMgYSB0ZXJtaW5hbCAoZmluYWwpXG4gICAgICAgICAqIHNwZWNpZmllciB0aGF0IHJlZmVycyB0byBhIGdpdmVuIHBhcnQgdHlwZVxuICAgICAgICAgKiBieSBpdHMgdW5pcXVlIHN5c3RlbSBpZC4gRm9yIGFueSBraW5kIG9mIHBhcnQsXG4gICAgICAgICAqIHdlIHVzZSBgcGFydCBpZCA8b2JqZWN0SWQ+YFxuICAgICAgICAgKiBFeGFtcGxlczogYGNhcmQgaWQgMjY2YCBgcGFydCBpZCA1YFxuICAgICAgICAgKi9cbiAgICAgICAgVGVybWluYWxTcGVjaWZpZXJfcGFydEJ5SWQ6IGZ1bmN0aW9uKG9iamVjdFR5cGUsIGlkTGl0ZXJhbCwgb2JqZWN0SWQpe1xuICAgICAgICAgICAgbGV0IGlkID0gb2JqZWN0SWQuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbaWRdO1xuICAgICAgICAgICAgaWYoIWZvdW5kKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kICR7b2JqZWN0VHlwZS5zb3VyY2VTdHJpbmd9IHdpdGggaWQgJHtvYmplY3RJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFwicHJlZml4ZWRcIiBxdWVyaWVkIHNwZWNpZmllciBpcyBqdXN0XG4gICAgICAgICAqIGEgUGFydGlhbFNwZWNpZmllciB3aXRoIFwib2ZcIiBpbiBmcm9udCBvZiBpdCwgaW5kaWNhdGluZ1xuICAgICAgICAgKiB0aGF0IGEgZGlmZmVyZW50IHBhcnRpYWwgd2lsbCBwcmVjZWRlIGl0IGJlIHF1ZXJpZWQgaW5zaWRlIG9mIGl0LlxuICAgICAgICAgKiBFeGFtcGxlIGBvZiBidXR0b24gXCJNeSBCdXR0b25cImBcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJpZWRTcGVjaWZpZXJfcHJlZml4ZWQ6IGZ1bmN0aW9uKHBhcnRpYWxTcGVjaWZpZXIsIG9mTGl0ZXJhbCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBuZXN0ZWQgcXVlcmllZCBzcGVjaWZpZXIgaXMgb25lIHRoYXQgaGFzIHR3b1xuICAgICAgICAgKiBvciBtb3JlIHByZWZpeGVkIHNwZWNpZmllcnMuIFRoZSBzaW1wbGVzdCB3b3VsZCBiZVxuICAgICAgICAgKiBzb21ldGhpbmcgbGlrZTpcbiAgICAgICAgICogICAgIGBvZiBjYXJkIFwiTXkgQ2FyZFwiIG9mIHN0YWNrIFwiQW5vdGhlciBuYW1lZCBzdGFja1wiYFxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcmllZFNwZWNpZmllcl9uZXN0ZWQ6IGZ1bmN0aW9uKGZpcnN0UXVlcnksIHNlY29uZFF1ZXJ5KXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gc2Vjb25kUXVlcnkuaW50ZXJwcmV0KCkoY29udGV4dFBhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBvdXRlciA9IGZpcnN0UXVlcnkuaW50ZXJwcmV0KCkoaW5uZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9iamVjdFNwZWNpZmllciB3aXRob3V0IGFuIGFubm90YXRlZFxuICAgICAgICAgKiBydWxlIG1lYW5zIGl0IHdhcyBpbnRlcnByZXRlZCBhcyBqdXN0XG4gICAgICAgICAqIGEgVGVybWluYWxTcGVjaWZpZXIgb2Ygc29tZSBzb3J0LlxuICAgICAgICAgKiBIb3dldmVyLCB3ZSBuZWVkIHRvIGV4dHJhY3QgdGhlIGlkXG4gICAgICAgICAqIGFuZCByZXR1cm4gdGhhdCByZXN1bHQsIHNpbmNlIHRoYXQgaXMgd2hhdCBpc1xuICAgICAgICAgKiBleHBlY3RlZCBvZiBhbGwgaW50ZXJwcmV0ZWQgT2JqZWN0U3BlY2lmaWVyc1xuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX3NpbmdsZVRlcm1pbmFsOiBmdW5jdGlvbih0ZXJtaW5hbFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0ZXJtaW5hbFNwZWNpZmllci5pbnRlcnByZXQoKSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIENvbXBvdW5kIHdpdGggdGVybWluYWwgc3BlY2lmaWVyIGlzIGEgUXVlcmllZFNwZWNpZmllclxuICAgICAgICAgKiB0aGF0IGZpbmlzaGVzIHdpdGggYSBUZXJtaW5hbCBzcGVjaWZpZXIuXG4gICAgICAgICAqIEV4YW1wbGU6IGBvZiBidXR0b24gMyBvZiBjYXJkIFwiU29tZSBuYW1lZCBjYXJkXCIgb2YgY3VycmVudCBzdGFja2BcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdFNwZWNpZmllcl9jb21wb3VuZFF1ZXJ5V2l0aFRlcm1pbmFsOiBmdW5jdGlvbihxdWVyaWVkU3BlY2lmaWVyLCB0ZXJtaW5hbFNwZWNpZmllcil7XG4gICAgICAgICAgICAvLyBUaGUgdGVybWluYWwgaGVyZSBpcyB0aGUgdWx0aW1hdGUgcGFydCBjb250ZXh0XG4gICAgICAgICAgICBsZXQgZmluYWxQYXJ0ID0gdGVybWluYWxTcGVjaWZpZXIuaW50ZXJwcmV0KCkoKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBxdWVyaWVkU3BlY2lmaWVyLmludGVycHJldCgpKGZpbmFsUGFydCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIENvbXBvdW5kIHdpdGhvdXQgdGVybWluYWwgc3BlY2lmaWVyIGlzIGEgUXVlcmllZFNwZWNpZmllclxuICAgICAgICAgKiB0aGF0IGZpbmlzaGVzIHdpdGggYSBQYXJ0aWFsIHNwZWNpZmllci5cbiAgICAgICAgICogRXhhbXBsZTogYG9mIGJ1dHRvbiAzIG9mIGZpcnN0IGNhcmRgICh3aGljaCBjYW4gY29udGludWUgYC4ub2YgY3VycmVudCBzdGFja2AgZXRjKVxuICAgICAgICAgKiBgZmlyc3QgYnV0dG9uIG9mIGZpcnN0IGFyZWEgb2Ygc3RhY2sgM2BcbiAgICAgICAgICogYGZpcnN0IGJ1dHRvbiBvZiBhcmVhIHR3byBvZiBzdGFjayAzYFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX2NvbXBvdW5kUXVlcnlXaXRob3V0VGVybWluYWw6IGZ1bmN0aW9uKHF1ZXJpZWRTcGVjaWZpZXIsIHBhcnRpYWxTcGVjaWZpZXIpe1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcnRpYWxTcGVjZmllciByZWZlcnMgdG8gZWl0aGVyIGFyZWEsIGNhcmQgb3Igc3RhY2tcbiAgICAgICAgICAgIC8vIHRoZW4gZ28gdG8gaXRzIG93bmVyIGZvciB0aGUgY29udGV4dFxuICAgICAgICAgICAgLy8gaWYgaXQgcmVmZXJzIHRvIHRoZSBjdXJyZW50IGNhcmQgdGhlbiBmaW5kIHRoZSBvd25lciBmb3IgdGhlIGNvbnRleHRcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHBhcnRpYWxTcGVjaWZpZXIuY2hpbGRyZW5bMF0uY2hpbGRyZW47XG4gICAgICAgICAgICBsZXQgc3lzdGVtT2JqZWN0U3RyaW5nO1xuICAgICAgICAgICAgaWYoY2hpbGRyZW5bMF0uc291cmNlU3RyaW5nID09IFwiY3VycmVudFwiICYmIGNoaWxkcmVuWzFdLnNvdXJjZVN0cmluZyA9PSBcImNhcmRcIil7XG4gICAgICAgICAgICAgICAgc3lzdGVtT2JqZWN0U3RyaW5nID0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkLmN0b3JOYW1lID09IFwic3lzdGVtT2JqZWN0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3lzdGVtT2JqZWN0U3RyaW5nID0gY2hpbGQuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmluYWxQYXJ0ID0gZmluZEZpcnN0UG9zc2libGVBbmNlc3RvcihwYXJ0Q29udGV4dCwgc3lzdGVtT2JqZWN0U3RyaW5nKTtcbiAgICAgICAgICAgIGxldCBmaW5hbFBhcnRpYWwgPSBwYXJ0aWFsU3BlY2lmaWVyLmludGVycHJldCgpKGZpbmFsUGFydCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcXVlcmllZFNwZWNpZmllci5pbnRlcnByZXQoKShmaW5hbFBhcnRpYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaW5nbGUgbm9uLXRlcm1pbmFsIE9iamVjdFNwZWNpZmllciBpcyBqdXN0IGEgUGFydGlhbFxuICAgICAgICAgKiBzcGVjaWZpZXIgYnkgaXRzZWxmLiBXaGVuIHByZXNlbnQgb3V0c2lkZSBvZiBhIFF1ZXJpZWRTcGVjaWZpZXIsXG4gICAgICAgICAqIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgdHJlYXRlZFxuICAgICAgICAgKiBhcyB0ZXJtaW5hbC9maW5hbC4gRm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAgICBidXR0b24gNFxuICAgICAgICAgKiBieSBpdHNlbGYgYXMgYSB3aG9sZSBzcGVjaWZpZXIgd2lsbCBiZSBpbnRlcnByZXRlZCBhc1xuICAgICAgICAgKiBgYnV0dG9uIDQgb2YgdGhpcyBjYXJkYFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX3NpbmdsZU5vblRlcm1pbmFsOiBmdW5jdGlvbihwYXJ0aWFsU3BlY2lmaWVyKXtcbiAgICAgICAgICAgIC8vIEEgc2luZ2xlIG5vbi10ZXJtaW5hbCBvYmplY3Qgc3BlY2lmaWVyIGlzIG9uZVxuICAgICAgICAgICAgLy8gd2hvc2UgdGVybWluYWwgb2JqZWN0IGlzIGltcGxpY2l0bHkgYXNzdW1lZCB0b1xuICAgICAgICAgICAgLy8gYmUgdGhlIGNhcmQgb3IgdGhlIHN0YWNrIGluIHdoaWNoIHRoZSBjdXJyZW50IGNvbnRleHQgcGFydFxuICAgICAgICAgICAgLy8gZXhpc3RzLlxuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gcGFydGlhbFNwZWNpZmllci5jaGlsZHJlblswXS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGxldCBzeXN0ZW1PYmplY3RTdHJpbmc7XG4gICAgICAgICAgICBpZihjaGlsZHJlblswXS5zb3VyY2VTdHJpbmcgPT0gXCJjdXJyZW50XCIgJiYgY2hpbGRyZW5bMV0uc291cmNlU3RyaW5nID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtQ29udGV4dC5nZXRDdXJyZW50Q2FyZE1vZGVsKCkuaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkLnNvdXJjZVN0cmluZyA9PSBcInBhcnRcIiB8fCBjaGlsZC5zb3VyY2VTdHJpbmcgPT0gXCJ0YXJnZXRcIiB8fCBjaGlsZC5jdG9yTmFtZSA9PSAnc3lzdGVtT2JqZWN0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeXN0ZW1PYmplY3RTdHJpbmcgPSBjaGlsZC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBzeXN0ZW1PYmplY3QgaXMgdGhlIHRhcmdldCAoZGVmaW5lZCBpbiBpdCdzIFwidGFyZ2V0XCIgcGFydCBwcm9wZXJ0eSksIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZmlyc3QgZ2V0IHRoZSB0YXJnZXQgcHJvcGVydHkgdmFsdWUgKHN0cmluZykgYW5kIGludGVycHJldCB0aGF0XG4gICAgICAgICAgICBpZihzeXN0ZW1PYmplY3RTdHJpbmcgPT0gXCJ0YXJnZXRcIil7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFByb3BWYWx1ZSA9IHBhcnRDb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQocGFydENvbnRleHQsIFwidGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgIGxldCBzZW1hbnRpY3MgPSBwYXJ0Q29udGV4dC5fc2VtYW50aWNzO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaE9iamVjdCA9IHN5c3RlbUNvbnRleHQuZ3JhbW1hci5tYXRjaCh0YXJnZXRQcm9wVmFsdWUsICdPYmplY3RTcGVjaWZpZXInKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobWF0Y2hPYmplY3QpLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRJZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZihzeXN0ZW1PYmplY3RTdHJpbmcgPT0gXCJjdXJyZW50IGNhcmRcIil7XG4gICAgICAgICAgICAgICAgc3lzdGVtT2JqZWN0U3RyaW5nID0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmluYWxQYXJ0ID0gZmluZEZpcnN0UG9zc2libGVBbmNlc3RvcihwYXJ0Q29udGV4dCwgc3lzdGVtT2JqZWN0U3RyaW5nKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJ0aWFsU3BlY2lmaWVyLmludGVycHJldCgpKGZpbmFsUGFydCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdFNwZWNpZmllcl9zaW5nbGVUZXJtaW5hbDogZnVuY3Rpb24odGVybWluYWxTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRlcm1pbmFsU3BlY2lmaWVyLmludGVycHJldCgpKHBhcnRDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW55TGl0ZXJhbDogZnVuY3Rpb24odGhlTGl0ZXJhbCl7XG4gICAgICAgICAgICByZXR1cm4gdGhlTGl0ZXJhbC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmdMaXRlcmFsOiBmdW5jdGlvbihvcGVuUXVvdGUsIHRleHQsIGNsb3NlUXVvdGUpe1xuICAgICAgICAgICAgcmV0dXJuIHRleHQuc291cmNlU3RyaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJvb2xlYW5MaXRlcmFsOiBmdW5jdGlvbih0ZXh0KXtcbiAgICAgICAgICAgIGlmKHRleHQuc291cmNlU3RyaW5nID09ICd0cnVlJyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0ZXh0LnNvdXJjZVN0cmluZyA9PSAnZmFsc2UnKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm9vbGVhbiBsaXRlcmFsOiAke3RleHR9YCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZWdlckxpdGVyYWw6IGZ1bmN0aW9uKG5lZ2F0aXZlU2lnbiwgaW50ZWdlcil7XG4gICAgICAgICAgICBsZXQgaW50ID0gcGFyc2VJbnQoaW50ZWdlci5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IGhhc05lZ2F0aXZlID0gKG5lZ2F0aXZlU2lnbi5zb3VyY2VTdHJpbmcgPT0gXCItXCIpO1xuICAgICAgICAgICAgaWYoaGFzTmVnYXRpdmUpe1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIGludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnQ7IFxuICAgICAgICB9LFxuXG4gICAgICAgIGZsb2F0TGl0ZXJhbDogZnVuY3Rpb24obmVnYXRpdmVTaWduLCBvbmVzUGxhY2UsIGRlY2ltYWwsIHJlc3RQbGFjZSl7XG4gICAgICAgICAgICBsZXQgZmxvYXRTdHJpbmcgPSBgJHtvbmVzUGxhY2Uuc291cmNlU3RyaW5nfS4ke3Jlc3RQbGFjZS5zb3VyY2VTdHJpbmd9YDtcbiAgICAgICAgICAgIGxldCBoYXNOZWdhdGl2ZSA9IChuZWdhdGl2ZVNpZ24uc291cmNlU3RyaW5nID09IFwiLVwiKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZsb2F0KGZsb2F0U3RyaW5nKTtcbiAgICAgICAgICAgIGlmKGhhc05lZ2F0aXZlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIG51bWVyaWNhbEtleXdvcmQ6IGZ1bmN0aW9uKG51bWVyYWxOYW1lKXtcbiAgICAgICAgICAgIHN3aXRjaChudW1lcmFsTmFtZS5zb3VyY2VTdHJpbmcpe1xuICAgICAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIGNhc2UgJ3RoaXJkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIGNhc2UgJ2ZvdXJ0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICBjYXNlICdmaWZ0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICBjYXNlICdzaXh0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICBjYXNlICdzZXZlbnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgICAgIGNhc2UgJ2VpZ2h0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgICBjYXNlICduaW50aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICBjYXNlICd0ZW50aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFyaWFibGVOYW1lOiBmdW5jdGlvbihsZXR0ZXJQbHVzLCBvcHRpb25hbERpZ2l0cyl7XG4gICAgICAgICAgICAvLyBMb29rdXAgdGhlIHZhcmlhYmxlIGluIHRoZSBwYXJ0J3NcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YXJpYWJsZSBpcyBub3QgYSBrZXkgb24gdGhlIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHdlIHRocm93IGFuIGVycm9yOiB0aGlzIG1lYW5zIHRoZSB2YXJpYWJsZSBoYXMgbm90IHlldFxuICAgICAgICAgICAgLy8gYmVlbiBkZWZpbmVkIGJ1dCBpcyBiZWluZyBsb29rZWQgdXAuXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzeXN0ZW1Db250ZXh0LmV4ZWN1dGlvblN0YWNrLmN1cnJlbnQuZ2V0KHRoaXMuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgIGlmKHZhbHVlID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNUVmFyaWFibGVSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFZhcmlhYmxlICR7dGhpcy5zb3VyY2VTdHJpbmd9IGhhcyBub3QgYmVlbiBkZWZpbmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWVudDogZnVuY3Rpb24oZGFzaGVzTGl0ZXJhbCwgbm9uTGluZVRlcm1pbmF0b3JDaGFycyl7XG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgZG9lc24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgLy8gd2l0aCBjb21tZW50cy5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF90ZXJtaW5hbCgpe1xuXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuXG5leHBvcnQge1xuICAgIGNyZWF0ZUludGVycHJldGVyU2VtYW50aWNzLFxuICAgIGNyZWF0ZUludGVycHJldGVyU2VtYW50aWNzIGFzIGRlZmF1bHRcbn07XG4iLCJ2YXIgb2htID0gcmVxdWlyZSgnLi4nKTtcbm1vZHVsZS5leHBvcnRzID0gb2htLm1ha2VSZWNpcGUoW1wiZ3JhbW1hclwiLHtcInNvdXJjZVwiOlwiQnVpbHRJblJ1bGVzIHtcXG5cXG4gIGFsbnVtICAoYW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXIpXFxuICAgID0gbGV0dGVyXFxuICAgIHwgZGlnaXRcXG5cXG4gIGxldHRlciAgKGEgbGV0dGVyKVxcbiAgICA9IGxvd2VyXFxuICAgIHwgdXBwZXJcXG4gICAgfCB1bmljb2RlTHRtb1xcblxcbiAgZGlnaXQgIChhIGRpZ2l0KVxcbiAgICA9IFxcXCIwXFxcIi4uXFxcIjlcXFwiXFxuXFxuICBoZXhEaWdpdCAgKGEgaGV4YWRlY2ltYWwgZGlnaXQpXFxuICAgID0gZGlnaXRcXG4gICAgfCBcXFwiYVxcXCIuLlxcXCJmXFxcIlxcbiAgICB8IFxcXCJBXFxcIi4uXFxcIkZcXFwiXFxuXFxuICBMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IE5vbmVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgfCBFbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuXFxuICBOb25lbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gZWxlbSAoc2VwIGVsZW0pKlxcblxcbiAgRW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IC8qIG5vdGhpbmcgKi9cXG5cXG4gIGxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gbm9uZW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICB8IGVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG5cXG4gIG5vbmVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgPSBlbGVtIChzZXAgZWxlbSkqXFxuXFxuICBlbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gLyogbm90aGluZyAqL1xcblxcbn1cIn0sXCJCdWlsdEluUnVsZXNcIixudWxsLG51bGwse1wiYWxudW1cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOCw3OF19LFwiYW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJcIixbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MCw3OF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYwLDY2XX0sXCJsZXR0ZXJcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzMsNzhdfSxcImRpZ2l0XCIsW11dXV0sXCJsZXR0ZXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MiwxNDJdfSxcImEgbGV0dGVyXCIsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA3LDE0Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNywxMTJdfSxcImxvd2VyXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExOSwxMjRdfSxcInVwcGVyXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwxNDJdfSxcInVuaWNvZGVMdG1vXCIsW11dXV0sXCJkaWdpdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NiwxNzddfSxcImEgZGlnaXRcIixbXSxbXCJyYW5nZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2OSwxNzddfSxcIjBcIixcIjlcIl1dLFwiaGV4RGlnaXRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODEsMjU0XX0sXCJhIGhleGFkZWNpbWFsIGRpZ2l0XCIsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE5LDI1NF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxOSwyMjRdfSxcImRpZ2l0XCIsW11dLFtcInJhbmdlXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMxLDIzOV19LFwiYVwiLFwiZlwiXSxbXCJyYW5nZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NiwyNTRdfSxcIkFcIixcIkZcIl1dXSxcIkxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1OCwzMzZdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyODIsMzM2XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjgyLDMwN119LFwiTm9uZW1wdHlMaXN0T2ZcIixbW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyOTcsMzAxXX0sMF0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMDMsMzA2XX0sMV1dXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMTQsMzM2XX0sXCJFbXB0eUxpc3RPZlwiLFtbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzMyNiwzMzBdfSwwXSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzMzMiwzMzVdfSwxXV1dXV0sXCJOb25lbXB0eUxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM0MCwzODhdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzIsMzg4XX0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzIsMzc2XX0sMF0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzM3NywzODhdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzgsMzg2XX0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzgsMzgxXX0sMV0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODIsMzg2XX0sMF1dXV1dLFwiRW1wdHlMaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszOTIsNDM0XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDM4LDQzOF19XV0sXCJsaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0MzgsNTE2XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDYyLDUxNl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ2Miw0ODddfSxcIm5vbmVtcHR5TGlzdE9mXCIsW1tcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDc3LDQ4MV19LDBdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDgzLDQ4Nl19LDFdXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDk0LDUxNl19LFwiZW1wdHlMaXN0T2ZcIixbW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MDYsNTEwXX0sMF0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MTIsNTE1XX0sMV1dXV1dLFwibm9uZW1wdHlMaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MjAsNTY4XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTUyLDU2OF19LFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTUyLDU1Nl19LDBdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NTcsNTY4XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTU4LDU2Nl19LFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTU4LDU2MV19LDFdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTYyLDU2Nl19LDBdXV1dXSxcImVtcHR5TGlzdE9mXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTcyLDYxNF19LG51bGwsW1wiZWxlbVwiLFwic2VwXCJdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzYxNiw2MTZdfV1dfV0pO1xuIiwidmFyIG9obSA9IHJlcXVpcmUoJy4uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG9obS5tYWtlUmVjaXBlKFtcImdyYW1tYXJcIix7XCJzb3VyY2VcIjpcIk9obSB7XFxuXFxuICBHcmFtbWFyc1xcbiAgICA9IEdyYW1tYXIqXFxuXFxuICBHcmFtbWFyXFxuICAgID0gaWRlbnQgU3VwZXJHcmFtbWFyPyBcXFwie1xcXCIgUnVsZSogXFxcIn1cXFwiXFxuXFxuICBTdXBlckdyYW1tYXJcXG4gICAgPSBcXFwiPDpcXFwiIGlkZW50XFxuXFxuICBSdWxlXFxuICAgID0gaWRlbnQgRm9ybWFscz8gcnVsZURlc2NyPyBcXFwiPVxcXCIgIFJ1bGVCb2R5ICAtLSBkZWZpbmVcXG4gICAgfCBpZGVudCBGb3JtYWxzPyAgICAgICAgICAgIFxcXCI6PVxcXCIgT3ZlcnJpZGVSdWxlQm9keSAgLS0gb3ZlcnJpZGVcXG4gICAgfCBpZGVudCBGb3JtYWxzPyAgICAgICAgICAgIFxcXCIrPVxcXCIgUnVsZUJvZHkgIC0tIGV4dGVuZFxcblxcbiAgUnVsZUJvZHlcXG4gICAgPSBcXFwifFxcXCI/IE5vbmVtcHR5TGlzdE9mPFRvcExldmVsVGVybSwgXFxcInxcXFwiPlxcblxcbiAgVG9wTGV2ZWxUZXJtXFxuICAgID0gU2VxIGNhc2VOYW1lICAtLSBpbmxpbmVcXG4gICAgfCBTZXFcXG5cXG4gIE92ZXJyaWRlUnVsZUJvZHlcXG4gICAgPSBcXFwifFxcXCI/IE5vbmVtcHR5TGlzdE9mPE92ZXJyaWRlVG9wTGV2ZWxUZXJtLCBcXFwifFxcXCI+XFxuXFxuICBPdmVycmlkZVRvcExldmVsVGVybVxcbiAgICA9IFxcXCIuLi5cXFwiICAtLSBzdXBlclNwbGljZVxcbiAgICB8IFRvcExldmVsVGVybVxcblxcbiAgRm9ybWFsc1xcbiAgICA9IFxcXCI8XFxcIiBMaXN0T2Y8aWRlbnQsIFxcXCIsXFxcIj4gXFxcIj5cXFwiXFxuXFxuICBQYXJhbXNcXG4gICAgPSBcXFwiPFxcXCIgTGlzdE9mPFNlcSwgXFxcIixcXFwiPiBcXFwiPlxcXCJcXG5cXG4gIEFsdFxcbiAgICA9IE5vbmVtcHR5TGlzdE9mPFNlcSwgXFxcInxcXFwiPlxcblxcbiAgU2VxXFxuICAgID0gSXRlcipcXG5cXG4gIEl0ZXJcXG4gICAgPSBQcmVkIFxcXCIqXFxcIiAgLS0gc3RhclxcbiAgICB8IFByZWQgXFxcIitcXFwiICAtLSBwbHVzXFxuICAgIHwgUHJlZCBcXFwiP1xcXCIgIC0tIG9wdFxcbiAgICB8IFByZWRcXG5cXG4gIFByZWRcXG4gICAgPSBcXFwiflxcXCIgTGV4ICAtLSBub3RcXG4gICAgfCBcXFwiJlxcXCIgTGV4ICAtLSBsb29rYWhlYWRcXG4gICAgfCBMZXhcXG5cXG4gIExleFxcbiAgICA9IFxcXCIjXFxcIiBCYXNlICAtLSBsZXhcXG4gICAgfCBCYXNlXFxuXFxuICBCYXNlXFxuICAgID0gaWRlbnQgUGFyYW1zPyB+KHJ1bGVEZXNjcj8gXFxcIj1cXFwiIHwgXFxcIjo9XFxcIiB8IFxcXCIrPVxcXCIpICAtLSBhcHBsaWNhdGlvblxcbiAgICB8IG9uZUNoYXJUZXJtaW5hbCBcXFwiLi5cXFwiIG9uZUNoYXJUZXJtaW5hbCAgICAgICAgICAgLS0gcmFuZ2VcXG4gICAgfCB0ZXJtaW5hbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIHRlcm1pbmFsXFxuICAgIHwgXFxcIihcXFwiIEFsdCBcXFwiKVxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBwYXJlblxcblxcbiAgcnVsZURlc2NyICAoYSBydWxlIGRlc2NyaXB0aW9uKVxcbiAgICA9IFxcXCIoXFxcIiBydWxlRGVzY3JUZXh0IFxcXCIpXFxcIlxcblxcbiAgcnVsZURlc2NyVGV4dFxcbiAgICA9ICh+XFxcIilcXFwiIGFueSkqXFxuXFxuICBjYXNlTmFtZVxcbiAgICA9IFxcXCItLVxcXCIgKH5cXFwiXFxcXG5cXFwiIHNwYWNlKSogbmFtZSAoflxcXCJcXFxcblxcXCIgc3BhY2UpKiAoXFxcIlxcXFxuXFxcIiB8ICZcXFwifVxcXCIpXFxuXFxuICBuYW1lICAoYSBuYW1lKVxcbiAgICA9IG5hbWVGaXJzdCBuYW1lUmVzdCpcXG5cXG4gIG5hbWVGaXJzdFxcbiAgICA9IFxcXCJfXFxcIlxcbiAgICB8IGxldHRlclxcblxcbiAgbmFtZVJlc3RcXG4gICAgPSBcXFwiX1xcXCJcXG4gICAgfCBhbG51bVxcblxcbiAgaWRlbnQgIChhbiBpZGVudGlmaWVyKVxcbiAgICA9IG5hbWVcXG5cXG4gIHRlcm1pbmFsXFxuICAgID0gXFxcIlxcXFxcXFwiXFxcIiB0ZXJtaW5hbENoYXIqIFxcXCJcXFxcXFxcIlxcXCJcXG5cXG4gIG9uZUNoYXJUZXJtaW5hbFxcbiAgICA9IFxcXCJcXFxcXFxcIlxcXCIgdGVybWluYWxDaGFyIFxcXCJcXFxcXFxcIlxcXCJcXG5cXG4gIHRlcm1pbmFsQ2hhclxcbiAgICA9IGVzY2FwZUNoYXJcXG4gICAgfCB+XFxcIlxcXFxcXFxcXFxcIiB+XFxcIlxcXFxcXFwiXFxcIiB+XFxcIlxcXFxuXFxcIiBhbnlcXG5cXG4gIGVzY2FwZUNoYXIgIChhbiBlc2NhcGUgc2VxdWVuY2UpXFxuICAgID0gXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIGJhY2tzbGFzaFxcbiAgICB8IFxcXCJcXFxcXFxcXFxcXFxcXFwiXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBkb3VibGVRdW90ZVxcbiAgICB8IFxcXCJcXFxcXFxcXFxcXFwnXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBzaW5nbGVRdW90ZVxcbiAgICB8IFxcXCJcXFxcXFxcXGJcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBiYWNrc3BhY2VcXG4gICAgfCBcXFwiXFxcXFxcXFxuXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gbGluZUZlZWRcXG4gICAgfCBcXFwiXFxcXFxcXFxyXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gY2FycmlhZ2VSZXR1cm5cXG4gICAgfCBcXFwiXFxcXFxcXFx0XFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gdGFiXFxuICAgIHwgXFxcIlxcXFxcXFxcdVxcXCIgaGV4RGlnaXQgaGV4RGlnaXQgaGV4RGlnaXQgaGV4RGlnaXQgIC0tIHVuaWNvZGVFc2NhcGVcXG4gICAgfCBcXFwiXFxcXFxcXFx4XFxcIiBoZXhEaWdpdCBoZXhEaWdpdCAgICAgICAgICAgICAgICAgICAgLS0gaGV4RXNjYXBlXFxuXFxuICBzcGFjZVxcbiAgICs9IGNvbW1lbnRcXG5cXG4gIGNvbW1lbnRcXG4gICAgPSBcXFwiLy9cXFwiICh+XFxcIlxcXFxuXFxcIiBhbnkpKiAmKFxcXCJcXFxcblxcXCIgfCBlbmQpICAtLSBzaW5nbGVMaW5lXFxuICAgIHwgXFxcIi8qXFxcIiAoflxcXCIqL1xcXCIgYW55KSogXFxcIiovXFxcIiAgLS0gbXVsdGlMaW5lXFxuXFxuICB0b2tlbnMgPSB0b2tlbipcXG5cXG4gIHRva2VuID0gY2FzZU5hbWUgfCBjb21tZW50IHwgaWRlbnQgfCBvcGVyYXRvciB8IHB1bmN0dWF0aW9uIHwgdGVybWluYWwgfCBhbnlcXG5cXG4gIG9wZXJhdG9yID0gXFxcIjw6XFxcIiB8IFxcXCI9XFxcIiB8IFxcXCI6PVxcXCIgfCBcXFwiKz1cXFwiIHwgXFxcIipcXFwiIHwgXFxcIitcXFwiIHwgXFxcIj9cXFwiIHwgXFxcIn5cXFwiIHwgXFxcIiZcXFwiXFxuXFxuICBwdW5jdHVhdGlvbiA9IFxcXCI8XFxcIiB8IFxcXCI+XFxcIiB8IFxcXCIsXFxcIiB8IFxcXCItLVxcXCJcXG59XCJ9LFwiT2htXCIsbnVsbCxcIkdyYW1tYXJzXCIse1wiR3JhbW1hcnNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5LDMyXX0sbnVsbCxbXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQsMzJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNCwzMV19LFwiR3JhbW1hclwiLFtdXV1dLFwiR3JhbW1hclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM2LDgzXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MCw4M119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzUwLDU1XX0sXCJpZGVudFwiLFtdXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1Niw2OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU2LDY4XX0sXCJTdXBlckdyYW1tYXJcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzAsNzNdfSxcIntcIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0LDc5XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQsNzhdfSxcIlJ1bGVcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODAsODNdfSxcIn1cIl1dXSxcIlN1cGVyR3JhbW1hclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3LDExNl19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA2LDExNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA2LDExMF19LFwiPDpcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExLDExNl19LFwiaWRlbnRcIixbXV1dXSxcIlJ1bGVfZGVmaW5lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDE4MV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDE3MF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwxMzZdfSxcImlkZW50XCIsW11dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNywxNDVdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzcsMTQ0XX0sXCJGb3JtYWxzXCIsW11dXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDYsMTU2XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ2LDE1NV19LFwicnVsZURlc2NyXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NywxNjBdfSxcIj1cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYyLDE3MF19LFwiUnVsZUJvZHlcIixbXV1dXSxcIlJ1bGVfb3ZlcnJpZGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODgsMjQ4XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODgsMjM1XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg4LDE5M119LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk0LDIwMl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5NCwyMDFdfSxcIkZvcm1hbHNcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE0LDIxOF19LFwiOj1cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE5LDIzNV19LFwiT3ZlcnJpZGVSdWxlQm9keVwiLFtdXV1dLFwiUnVsZV9leHRlbmRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTUsMzA1XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTUsMjk0XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU1LDI2MF19LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjYxLDI2OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI2MSwyNjhdfSxcIkZvcm1hbHNcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjgxLDI4NV19LFwiKz1cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjg2LDI5NF19LFwiUnVsZUJvZHlcIixbXV1dXSxcIlJ1bGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjAsMzA1XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEsMzA1XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDE3MF19LFwiUnVsZV9kZWZpbmVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg4LDIzNV19LFwiUnVsZV9vdmVycmlkZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTUsMjk0XX0sXCJSdWxlX2V4dGVuZFwiLFtdXV1dLFwiUnVsZUJvZHlcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMDksMzYyXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMjQsMzYyXX0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI0LDMyOF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI0LDMyN119LFwifFwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI5LDM2Ml19LFwiTm9uZW1wdHlMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzQ0LDM1Nl19LFwiVG9wTGV2ZWxUZXJtXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzU4LDM2MV19LFwifFwiXV1dXV0sXCJUb3BMZXZlbFRlcm1faW5saW5lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDQwOF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDM5N119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4NSwzODhdfSxcIlNlcVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODksMzk3XX0sXCJjYXNlTmFtZVwiLFtdXV1dLFwiVG9wTGV2ZWxUZXJtXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzY2LDQxOF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDQxOF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4NSwzOTddfSxcIlRvcExldmVsVGVybV9pbmxpbmVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDE1LDQxOF19LFwiU2VxXCIsW11dXV0sXCJPdmVycmlkZVJ1bGVCb2R5XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDIyLDQ5MV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDQ1LDQ5MV19LFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ0NSw0NDldfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ0NSw0NDhdfSxcInxcIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ1MCw0OTFdfSxcIk5vbmVtcHR5TGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ2NSw0ODVdfSxcIk92ZXJyaWRlVG9wTGV2ZWxUZXJtXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDg3LDQ5MF19LFwifFwiXV1dXV0sXCJPdmVycmlkZVRvcExldmVsVGVybV9zdXBlclNwbGljZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzUyMiw1NDNdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTIyLDUyN119LFwiLi4uXCJdXSxcIk92ZXJyaWRlVG9wTGV2ZWxUZXJtXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDk1LDU2Ml19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTIyLDU2Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzUyMiw1MjddfSxcIk92ZXJyaWRlVG9wTGV2ZWxUZXJtX3N1cGVyU3BsaWNlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU1MCw1NjJdfSxcIlRvcExldmVsVGVybVwiLFtdXV1dLFwiRm9ybWFsc1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU2Niw2MDZdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU4MCw2MDZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU4MCw1ODNdfSxcIjxcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTg0LDYwMl19LFwiTGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU5MSw1OTZdfSxcImlkZW50XCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTk4LDYwMV19LFwiLFwiXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjAzLDYwNl19LFwiPlwiXV1dLFwiUGFyYW1zXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjEwLDY0N119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjIzLDY0N119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjIzLDYyNl19LFwiPFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MjcsNjQzXX0sXCJMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjM0LDYzN119LFwiU2VxXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjM5LDY0Ml19LFwiLFwiXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjQ0LDY0N119LFwiPlwiXV1dLFwiQWx0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjUxLDY4NV19LG51bGwsW10sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjYxLDY4NV19LFwiTm9uZW1wdHlMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjc2LDY3OV19LFwiU2VxXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjgxLDY4NF19LFwifFwiXV1dXSxcIlNlcVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzY4OSw3MDRdfSxudWxsLFtdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2OTksNzA0XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjk5LDcwM119LFwiSXRlclwiLFtdXV1dLFwiSXRlcl9zdGFyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDczNl19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDcyN119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzcxOSw3MjNdfSxcIlByZWRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MjQsNzI3XX0sXCIqXCJdXV0sXCJJdGVyX3BsdXNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDMsNzYwXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDMsNzUxXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQzLDc0N119LFwiUHJlZFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0OCw3NTFdfSxcIitcIl1dXSxcIkl0ZXJfb3B0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzY3LDc4M119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzY3LDc3NV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc2Nyw3NzFdfSxcIlByZWRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NzIsNzc1XX0sXCI/XCJdXV0sXCJJdGVyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzA4LDc5NF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDc5NF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzcxOSw3MjddfSxcIkl0ZXJfc3RhclwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDMsNzUxXX0sXCJJdGVyX3BsdXNcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzY3LDc3NV19LFwiSXRlcl9vcHRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzkwLDc5NF19LFwiUHJlZFwiLFtdXV1dLFwiUHJlZF9ub3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODI0XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODE2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODEyXX0sXCJ+XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgxMyw4MTZdfSxcIkxleFwiLFtdXV1dLFwiUHJlZF9sb29rYWhlYWRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODUyXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODM4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODM0XX0sXCImXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgzNSw4MzhdfSxcIkxleFwiLFtdXV1dLFwiUHJlZFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc5OCw4NjJdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgwOSw4NjJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODE2XX0sXCJQcmVkX25vdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzEsODM4XX0sXCJQcmVkX2xvb2thaGVhZFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NTksODYyXX0sXCJMZXhcIixbXV1dXSxcIkxleF9sZXhcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODkyXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODg0XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODc5XX0sXCIjXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg4MCw4ODRdfSxcIkJhc2VcIixbXV1dXSxcIkxleFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg2Niw5MDNdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3Niw5MDNdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsODg0XX0sXCJMZXhfbGV4XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg5OSw5MDNdfSxcIkJhc2VcIixbXV1dXSxcIkJhc2VfYXBwbGljYXRpb25cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MTgsOTc5XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MTgsOTYzXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTE4LDkyM119LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTI0LDkzMV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkyNCw5MzBdfSxcIlBhcmFtc1wiLFtdXV0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTMyLDk2M119LFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkzNCw5NjJdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MzQsOTQ4XX0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTM0LDk0NF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkzNCw5NDNdfSxcInJ1bGVEZXNjclwiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5NDUsOTQ4XX0sXCI9XCJdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk1MSw5NTVdfSxcIjo9XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTU4LDk2Ml19LFwiKz1cIl1dXV1dLFwiQmFzZV9yYW5nZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk4NiwxMDQxXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5ODYsMTAyMl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk4NiwxMDAxXX0sXCJvbmVDaGFyVGVybWluYWxcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDAyLDEwMDZdfSxcIi4uXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwMDcsMTAyMl19LFwib25lQ2hhclRlcm1pbmFsXCIsW11dXV0sXCJCYXNlX3Rlcm1pbmFsXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA0OCwxMTA2XX0sbnVsbCxbXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDQ4LDEwNTZdfSxcInRlcm1pbmFsXCIsW11dXSxcIkJhc2VfcGFyZW5cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTEzLDExNjhdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMTMsMTEyNF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExMywxMTE2XX0sXCIoXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMTcsMTEyMF19LFwiQWx0XCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTEyMSwxMTI0XX0sXCIpXCJdXV0sXCJCYXNlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTA3LDExNjhdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkxOCwxMTY4XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTE4LDk2M119LFwiQmFzZV9hcHBsaWNhdGlvblwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5ODYsMTAyMl19LFwiQmFzZV9yYW5nZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDQ4LDEwNTZdfSxcIkJhc2VfdGVybWluYWxcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExMywxMTI0XX0sXCJCYXNlX3BhcmVuXCIsW11dXV0sXCJydWxlRGVzY3JcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTcyLDEyMzFdfSxcImEgcnVsZSBkZXNjcmlwdGlvblwiLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMTAsMTIzMV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIxMCwxMjEzXX0sXCIoXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMTQsMTIyN119LFwicnVsZURlc2NyVGV4dFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMjgsMTIzMV19LFwiKVwiXV1dLFwicnVsZURlc2NyVGV4dFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMzUsMTI2Nl19LG51bGwsW10sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNTUsMTI2Nl19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNTYsMTI2NF19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNTYsMTI2MF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI1NywxMjYwXX0sXCIpXCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjYxLDEyNjRdfSxcImFueVwiLFtdXV1dXSxcImNhc2VOYW1lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI3MCwxMzM4XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjg1LDEzMzhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyODUsMTI4OV19LFwiLS1cIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTAsMTMwNF19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTEsMTMwMl19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTEsMTI5Nl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5MiwxMjk2XX0sXCJcXG5cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTcsMTMwMl19LFwic3BhY2VcIixbXV1dXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzA1LDEzMDldfSxcIm5hbWVcIixbXV0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTAsMTMyNF19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTEsMTMyMl19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTEsMTMxNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxMiwxMzE2XX0sXCJcXG5cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTcsMTMyMl19LFwic3BhY2VcIixbXV1dXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzI2LDEzMzddfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMjYsMTMzMF19LFwiXFxuXCJdLFtcImxvb2thaGVhZFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMzMsMTMzN119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMzNCwxMzM3XX0sXCJ9XCJdXV1dXSxcIm5hbWVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzQyLDEzODJdfSxcImEgbmFtZVwiLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNjMsMTM4Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNjMsMTM3Ml19LFwibmFtZUZpcnN0XCIsW11dLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzczLDEzODJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzczLDEzODFdfSxcIm5hbWVSZXN0XCIsW11dXV1dLFwibmFtZUZpcnN0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM4NiwxNDE4XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDAyLDE0MThdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MDIsMTQwNV19LFwiX1wiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDEyLDE0MThdfSxcImxldHRlclwiLFtdXV1dLFwibmFtZVJlc3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDIyLDE0NTJdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MzcsMTQ1Ml19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQzNywxNDQwXX0sXCJfXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NDcsMTQ1Ml19LFwiYWxudW1cIixbXV1dXSxcImlkZW50XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ1NiwxNDg5XX0sXCJhbiBpZGVudGlmaWVyXCIsW10sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ4NSwxNDg5XX0sXCJuYW1lXCIsW11dXSxcInRlcm1pbmFsXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ5MywxNTMxXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTA4LDE1MzFdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1MDgsMTUxMl19LFwiXFxcIlwiXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUxMywxNTI2XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUxMywxNTI1XX0sXCJ0ZXJtaW5hbENoYXJcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUyNywxNTMxXX0sXCJcXFwiXCJdXV0sXCJvbmVDaGFyVGVybWluYWxcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTM1LDE1NzldfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NTcsMTU3OV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU1NywxNTYxXX0sXCJcXFwiXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NjIsMTU3NF19LFwidGVybWluYWxDaGFyXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU3NSwxNTc5XX0sXCJcXFwiXCJdXV0sXCJ0ZXJtaW5hbENoYXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTgzLDE2NDBdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MDIsMTY0MF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MDIsMTYxMl19LFwiZXNjYXBlQ2hhclwiLFtdXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjE5LDE2NDBdfSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjE5LDE2MjRdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MjAsMTYyNF19LFwiXFxcXFwiXV0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYyNSwxNjMwXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjI2LDE2MzBdfSxcIlxcXCJcIl1dLFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MzEsMTYzNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYzMiwxNjM2XX0sXCJcXG5cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MzcsMTY0MF19LFwiYW55XCIsW11dXV1dLFwiZXNjYXBlQ2hhcl9iYWNrc2xhc2hcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgzLDE3MzhdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4MywxNjg5XX0sXCJcXFxcXFxcXFwiXV0sXCJlc2NhcGVDaGFyX2RvdWJsZVF1b3RlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTc0NSwxODAyXX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE3NDUsMTc1MV19LFwiXFxcXFxcXCJcIl1dLFwiZXNjYXBlQ2hhcl9zaW5nbGVRdW90ZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4MDksMTg2Nl19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODA5LDE4MTVdfSxcIlxcXFwnXCJdXSxcImVzY2FwZUNoYXJfYmFja3NwYWNlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg3MywxOTI4XX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4NzMsMTg3OF19LFwiXFxcXGJcIl1dLFwiZXNjYXBlQ2hhcl9saW5lRmVlZFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5MzUsMTk4OV19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTM1LDE5NDBdfSxcIlxcXFxuXCJdXSxcImVzY2FwZUNoYXJfY2FycmlhZ2VSZXR1cm5cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTk2LDIwNTZdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk5NiwyMDAxXX0sXCJcXFxcclwiXV0sXCJlc2NhcGVDaGFyX3RhYlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIwNjMsMjExMl19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDYzLDIwNjhdfSxcIlxcXFx0XCJdXSxcImVzY2FwZUNoYXJfdW5pY29kZUVzY2FwZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMTksMjE3OF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjExOSwyMTYwXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTE5LDIxMjRdfSxcIlxcXFx1XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMjUsMjEzM119LFwiaGV4RGlnaXRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjEzNCwyMTQyXX0sXCJoZXhEaWdpdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTQzLDIxNTFdfSxcImhleERpZ2l0XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxNTIsMjE2MF19LFwiaGV4RGlnaXRcIixbXV1dXSxcImVzY2FwZUNoYXJfaGV4RXNjYXBlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE4NSwyMjQwXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTg1LDIyMDhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxODUsMjE5MF19LFwiXFxcXHhcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE5MSwyMTk5XX0sXCJoZXhEaWdpdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjAwLDIyMDhdfSxcImhleERpZ2l0XCIsW11dXV0sXCJlc2NhcGVDaGFyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY0NCwyMjQwXX0sXCJhbiBlc2NhcGUgc2VxdWVuY2VcIixbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgzLDIyNDBdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgzLDE2ODldfSxcImVzY2FwZUNoYXJfYmFja3NsYXNoXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE3NDUsMTc1MV19LFwiZXNjYXBlQ2hhcl9kb3VibGVRdW90ZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODA5LDE4MTVdfSxcImVzY2FwZUNoYXJfc2luZ2xlUXVvdGVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg3MywxODc4XX0sXCJlc2NhcGVDaGFyX2JhY2tzcGFjZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTM1LDE5NDBdfSxcImVzY2FwZUNoYXJfbGluZUZlZWRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk5NiwyMDAxXX0sXCJlc2NhcGVDaGFyX2NhcnJpYWdlUmV0dXJuXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIwNjMsMjA2OF19LFwiZXNjYXBlQ2hhcl90YWJcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjExOSwyMTYwXX0sXCJlc2NhcGVDaGFyX3VuaWNvZGVFc2NhcGVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE4NSwyMjA4XX0sXCJlc2NhcGVDaGFyX2hleEVzY2FwZVwiLFtdXV1dLFwic3BhY2VcIjpbXCJleHRlbmRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjQ0LDIyNjNdfSxudWxsLFtdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyNTYsMjI2M119LFwiY29tbWVudFwiLFtdXV0sXCJjb21tZW50X3NpbmdsZUxpbmVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjgxLDIzMjddfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjMxMl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4MSwyMjg1XX0sXCIvL1wiXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4NiwyMjk4XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4NywyMjk2XX0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4NywyMjkyXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjg4LDIyOTJdfSxcIlxcblwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI5MywyMjk2XX0sXCJhbnlcIixbXV1dXSxbXCJsb29rYWhlYWRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjk5LDIzMTJdfSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzAxLDIzMTFdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMDEsMjMwNV19LFwiXFxuXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMDgsMjMxMV19LFwiZW5kXCIsW11dXV1dXSxcImNvbW1lbnRfbXVsdGlMaW5lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMzNCwyMzcwXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzM0LDIzNTZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzQsMjMzOF19LFwiLypcIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzksMjM1MV19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNDAsMjM0OV19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNDAsMjM0NV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM0MSwyMzQ1XX0sXCIqL1wiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM0NiwyMzQ5XX0sXCJhbnlcIixbXV1dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNTIsMjM1Nl19LFwiKi9cIl1dXSxcImNvbW1lbnRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjY3LDIzNzBdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjM3MF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjMxMl19LFwiY29tbWVudF9zaW5nbGVMaW5lXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzQsMjM1Nl19LFwiY29tbWVudF9tdWx0aUxpbmVcIixbXV1dXSxcInRva2Vuc1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNzQsMjM4OV19LG51bGwsW10sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzODMsMjM4OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzODMsMjM4OF19LFwidG9rZW5cIixbXV1dXSxcInRva2VuXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM5MywyNDY5XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDAxLDI0NjldfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDAxLDI0MDldfSxcImNhc2VOYW1lXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MTIsMjQxOV19LFwiY29tbWVudFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDIyLDI0MjddfSxcImlkZW50XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MzAsMjQzOF19LFwib3BlcmF0b3JcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ0MSwyNDUyXX0sXCJwdW5jdHVhdGlvblwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDU1LDI0NjNdfSxcInRlcm1pbmFsXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NjYsMjQ2OV19LFwiYW55XCIsW11dXV0sXCJvcGVyYXRvclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NzMsMjUzOF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ4NCwyNTM4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDg0LDI0ODhdfSxcIjw6XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ5MSwyNDk0XX0sXCI9XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ5NywyNTAxXX0sXCI6PVwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MDQsMjUwOF19LFwiKz1cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTExLDI1MTRdfSxcIipcIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTE3LDI1MjBdfSxcIitcIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTIzLDI1MjZdfSxcIj9cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTI5LDI1MzJdfSxcIn5cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTM1LDI1MzhdfSxcIiZcIl1dXSxcInB1bmN0dWF0aW9uXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU0MiwyNTc4XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTU2LDI1NzhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NTYsMjU1OV19LFwiPFwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NjIsMjU2NV19LFwiPlwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NjgsMjU3MV19LFwiLFwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NzQsMjU3OF19LFwiLS1cIl1dXX1dKTtcbiIsInZhciBvaG0gPSByZXF1aXJlKCcuLicpO1xubW9kdWxlLmV4cG9ydHMgPSBvaG0ubWFrZVJlY2lwZShbXCJncmFtbWFyXCIse1wic291cmNlXCI6XCJPcGVyYXRpb25zQW5kQXR0cmlidXRlcyB7XFxuXFxuICBBdHRyaWJ1dGVTaWduYXR1cmUgPVxcbiAgICBuYW1lXFxuXFxuICBPcGVyYXRpb25TaWduYXR1cmUgPVxcbiAgICBuYW1lIEZvcm1hbHM/XFxuXFxuICBGb3JtYWxzXFxuICAgID0gXFxcIihcXFwiIExpc3RPZjxuYW1lLCBcXFwiLFxcXCI+IFxcXCIpXFxcIlxcblxcbiAgbmFtZSAgKGEgbmFtZSlcXG4gICAgPSBuYW1lRmlyc3QgbmFtZVJlc3QqXFxuXFxuICBuYW1lRmlyc3RcXG4gICAgPSBcXFwiX1xcXCJcXG4gICAgfCBsZXR0ZXJcXG5cXG4gIG5hbWVSZXN0XFxuICAgID0gXFxcIl9cXFwiXFxuICAgIHwgYWxudW1cXG5cXG59XCJ9LFwiT3BlcmF0aW9uc0FuZEF0dHJpYnV0ZXNcIixudWxsLFwiQXR0cmlidXRlU2lnbmF0dXJlXCIse1wiQXR0cmlidXRlU2lnbmF0dXJlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjksNThdfSxudWxsLFtdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU0LDU4XX0sXCJuYW1lXCIsW11dXSxcIk9wZXJhdGlvblNpZ25hdHVyZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzYyLDEwMF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODcsMTAwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODcsOTFdfSxcIm5hbWVcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTIsMTAwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTIsOTldfSxcIkZvcm1hbHNcIixbXV1dXV0sXCJGb3JtYWxzXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA0LDE0M119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTE4LDE0M119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTE4LDEyMV19LFwiKFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjIsMTM5XX0sXCJMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5LDEzM119LFwibmFtZVwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNSwxMzhdfSxcIixcIl1dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MCwxNDNdfSxcIilcIl1dXSxcIm5hbWVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDcsMTg3XX0sXCJhIG5hbWVcIixbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgsMTg3XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4LDE3N119LFwibmFtZUZpcnN0XCIsW11dLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNzgsMTg3XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTc4LDE4Nl19LFwibmFtZVJlc3RcIixbXV1dXV0sXCJuYW1lRmlyc3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTEsMjIzXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDcsMjIzXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDcsMjEwXX0sXCJfXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxNywyMjNdfSxcImxldHRlclwiLFtdXV1dLFwibmFtZVJlc3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjcsMjU3XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDIsMjU3XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDIsMjQ1XX0sXCJfXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MiwyNTddfSxcImFsbnVtXCIsW11dXV19XSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCcuLi9zcmMvY29tbW9uJykuYXNzZXJ0O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gSGVscGVyc1xuXG5mdW5jdGlvbiBnZXRQcm9wKG5hbWUsIHRoaW5nLCBmbikge1xuICByZXR1cm4gZm4odGhpbmdbbmFtZV0pO1xufVxuXG5mdW5jdGlvbiBtYXBQcm9wKG5hbWUsIHRoaW5nLCBmbikge1xuICByZXR1cm4gdGhpbmdbbmFtZV0ubWFwKGZuKTtcbn1cblxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB3YWxrIGEgc2luZ2xlIHByb3BlcnR5IG9mIGEgbm9kZS5cbi8vIGBkZXNjcmlwdG9yYCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBwcm9wZXJ0eSBuYW1lLCBvcHRpb25hbGx5IGVuZGluZ1xuLy8gd2l0aCAnW10nIChlLmcuLCAnY2hpbGRyZW5bXScpLlxuZnVuY3Rpb24gZ2V0UHJvcFdhbGtGbihkZXNjcmlwdG9yKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVzY3JpcHRvci5zcGxpdCgvID9cXFtcXF0vKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBtYXBQcm9wLmJpbmQobnVsbCwgcGFydHNbMF0pO1xuICB9XG4gIHJldHVybiBnZXRQcm9wLmJpbmQobnVsbCwgZGVzY3JpcHRvcik7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BzKHdhbGtGbnMsIHRoaW5nLCBmbikge1xuICByZXR1cm4gd2Fsa0Zucy5tYXAod2Fsa0ZuID0+IHdhbGtGbih0aGluZywgZm4pKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Fsa0ZuKHNoYXBlKSB7XG4gIGlmICh0eXBlb2Ygc2hhcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGdldFByb3BzLmJpbmQobnVsbCwgW2dldFByb3BXYWxrRm4oc2hhcGUpXSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzaGFwZSkpIHtcbiAgICByZXR1cm4gZ2V0UHJvcHMuYmluZChudWxsLCBzaGFwZS5tYXAoZ2V0UHJvcFdhbGtGbikpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydCh0eXBlb2Ygc2hhcGUgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBhIHN0cmluZywgQXJyYXksIG9yIGZ1bmN0aW9uJyk7XG4gICAgYXNzZXJ0KHNoYXBlLmxlbmd0aCA9PT0gMiwgJ0V4cGVjdGVkIGEgZnVuY3Rpb24gb2YgYXJpdHkgMiwgZ290ICcgKyBzaGFwZS5sZW5ndGgpO1xuICAgIHJldHVybiBzaGFwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1Jlc3RyaWN0ZWRJZGVudGlmaWVyKHN0cikge1xuICByZXR1cm4gL15bYS16QS1aX11bMC05YS16QS1aX10qJC8udGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiB0cmltKHMpIHtcbiAgcmV0dXJuIHMudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNpZ25hdHVyZShzaWcpIHtcbiAgY29uc3QgcGFydHMgPSBzaWcuc3BsaXQoL1soKV0vKS5tYXAodHJpbSk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDMgJiYgcGFydHNbMl0gPT09ICcnKSB7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzWzBdO1xuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBpZiAocGFydHNbMV0ubGVuZ3RoID4gMCkge1xuICAgICAgcGFyYW1zID0gcGFydHNbMV0uc3BsaXQoJywnKS5tYXAodHJpbSk7XG4gICAgfVxuICAgIGlmIChpc1Jlc3RyaWN0ZWRJZGVudGlmaWVyKG5hbWUpICYmIHBhcmFtcy5ldmVyeShpc1Jlc3RyaWN0ZWRJZGVudGlmaWVyKSkge1xuICAgICAgcmV0dXJuIHtuYW1lLCBmb3JtYWxzOiBwYXJhbXN9O1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmF0aW9uIHNpZ25hdHVyZTogJyArIHNpZyk7XG59XG5cbi8qXG4gIEEgVmlzaXRvckZhbWlseSBjb250YWlucyBhIHNldCBvZiByZWN1cnNpdmUgb3BlcmF0aW9ucyB0aGF0IGFyZSBkZWZpbmVkIG92ZXIgc29tZSBraW5kIG9mXG4gIHRyZWUgc3RydWN0dXJlLiBUaGUgYGNvbmZpZ2AgcGFyYW1ldGVyIHNwZWNpZmllcyBob3cgdG8gd2FsayB0aGUgdHJlZTpcbiAgLSAnZ2V0VGFnJyBpcyBmdW5jdGlvbiB3aGljaCwgZ2l2ZW4gYSBub2RlIGluIHRoZSB0cmVlLCByZXR1cm5zIHRoZSBub2RlJ3MgJ3RhZycgKHR5cGUpXG4gIC0gJ3NoYXBlcycgYW4gb2JqZWN0IHRoYXQgbWFwcyBmcm9tIGEgdGFnIHRvIGEgdmFsdWUgdGhhdCBkZXNjcmliZXMgaG93IHRvIHJlY3Vyc2l2ZWx5XG4gICAgZXZhbHVhdGUgdGhlIG9wZXJhdGlvbiBmb3Igbm9kZXMgb2YgdGhhdCB0eXBlLiBUaGUgdmFsdWUgY2FuIGJlOlxuICAgICogYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgcHJvcGVydHkgbmFtZSB0aGF0IGhvbGRzIHRoYXQgbm9kZSdzIG9ubHkgY2hpbGRcbiAgICAqIGFuIEFycmF5IG9mIHByb3BlcnR5IG5hbWVzIChvciBhbiBlbXB0eSBhcnJheSBpbmRpY2F0aW5nIGEgbGVhZiB0eXBlKSwgb3JcbiAgICAqIGEgZnVuY3Rpb24gdGFraW5nIHR3byBhcmd1bWVudHMgKG5vZGUsIGZuKSwgYW5kIHJldHVybmluZyBhbiBBcnJheSB3aGljaCBpcyB0aGUgcmVzdWx0XG4gICAgICBvZiBhcHBseSBgZm5gIHRvIGVhY2ggb2YgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gVmlzaXRvckZhbWlseShjb25maWcpIHtcbiAgdGhpcy5fc2hhcGVzID0gY29uZmlnLnNoYXBlcztcbiAgdGhpcy5fZ2V0VGFnID0gY29uZmlnLmdldFRhZztcblxuICB0aGlzLkFkYXB0ZXIgPSBmdW5jdGlvbih0aGluZywgZmFtaWx5KSB7XG4gICAgdGhpcy5fYWRhcHRlZSA9IHRoaW5nO1xuICAgIHRoaXMuX2ZhbWlseSA9IGZhbWlseTtcbiAgfTtcbiAgdGhpcy5BZGFwdGVyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoZWVleSEnKTtcbiAgfTtcbiAgdGhpcy5vcGVyYXRpb25zID0ge307XG5cbiAgdGhpcy5fYXJpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2dldENoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgT2JqZWN0LmtleXModGhpcy5fc2hhcGVzKS5mb3JFYWNoKGsgPT4ge1xuICAgIGNvbnN0IHNoYXBlID0gc2VsZi5fc2hhcGVzW2tdO1xuICAgIHNlbGYuX2dldENoaWxkcmVuW2tdID0gZ2V0V2Fsa0ZuKHNoYXBlKTtcblxuICAgIC8vIEEgZnVuY3Rpb24gbWVhbnMgdGhlIGFyaXR5IGlzbid0IGZpeGVkLCBzbyBkb24ndCBwdXQgYW4gZW50cnkgaW4gdGhlIGFyaXR5IG1hcC5cbiAgICBpZiAodHlwZW9mIHNoYXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmLl9hcml0aWVzW2tdID0gQXJyYXkuaXNBcnJheShzaGFwZSkgPyBzaGFwZS5sZW5ndGggOiAxO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuX3dyYXAgPSBmdW5jdGlvbih0aGluZykgeyByZXR1cm4gbmV3IHNlbGYuQWRhcHRlcih0aGluZywgc2VsZik7IH07XG59XG5cblZpc2l0b3JGYW1pbHkucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbih0aGluZykge1xuICByZXR1cm4gdGhpcy5fd3JhcCh0aGluZyk7XG59O1xuXG5WaXNpdG9yRmFtaWx5LnByb3RvdHlwZS5fY2hlY2tBY3Rpb25EaWN0ID0gZnVuY3Rpb24oZGljdCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgT2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChrID0+IHtcbiAgICBhc3NlcnQoayBpbiBzZWxmLl9nZXRDaGlsZHJlbiwgXCJVbnJlY29nbml6ZWQgYWN0aW9uIG5hbWUgJ1wiICsgayArIFwiJ1wiKTtcbiAgICBjb25zdCBhY3Rpb24gPSBkaWN0W2tdO1xuICAgIGFzc2VydCh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nLCBcIktleSAnXCIgKyBrICsgXCInOiBleHBlY3RlZCBmdW5jdGlvbiwgZ290IFwiICsgYWN0aW9uKTtcbiAgICBpZiAoayBpbiBzZWxmLl9hcml0aWVzKSB7XG4gICAgICBjb25zdCBleHBlY3RlZCA9IHNlbGYuX2FyaXRpZXNba107XG4gICAgICBjb25zdCBhY3R1YWwgPSBkaWN0W2tdLmxlbmd0aDtcbiAgICAgIGFzc2VydChhY3R1YWwgPT09IGV4cGVjdGVkLFxuICAgICAgICAgIFwiQWN0aW9uICdcIiArIGsgKyBcIicgaGFzIHRoZSB3cm9uZyBhcml0eTogZXhwZWN0ZWQgXCIgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsKTtcbiAgICB9XG4gIH0pO1xufTtcblxuVmlzaXRvckZhbWlseS5wcm90b3R5cGUuYWRkT3BlcmF0aW9uID0gZnVuY3Rpb24oc2lnbmF0dXJlLCBhY3Rpb25zKSB7XG4gIGNvbnN0IHNpZyA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIGNvbnN0IG5hbWUgPSBzaWcubmFtZTtcbiAgdGhpcy5fY2hlY2tBY3Rpb25EaWN0KGFjdGlvbnMpO1xuICB0aGlzLm9wZXJhdGlvbnNbbmFtZV0gPSB7XG4gICAgbmFtZSxcbiAgICBmb3JtYWxzOiBzaWcuZm9ybWFscyxcbiAgICBhY3Rpb25zXG4gIH07XG5cbiAgY29uc3QgZmFtaWx5ID0gdGhpcztcbiAgdGhpcy5BZGFwdGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHRhZyA9IGZhbWlseS5fZ2V0VGFnKHRoaXMuX2FkYXB0ZWUpO1xuICAgIGFzc2VydCh0YWcgaW4gZmFtaWx5Ll9nZXRDaGlsZHJlbiwgXCJnZXRUYWcgcmV0dXJuZWQgdW5yZWNvZ25pemVkIHRhZyAnXCIgKyB0YWcgKyBcIidcIik7XG4gICAgYXNzZXJ0KHRhZyBpbiBhY3Rpb25zLCBcIk5vIGFjdGlvbiBmb3IgJ1wiICsgdGFnICsgXCInIGluIG9wZXJhdGlvbiAnXCIgKyBuYW1lICsgXCInXCIpO1xuXG4gICAgLy8gQ3JlYXRlIGFuIFwiYXJndW1lbnRzIG9iamVjdFwiIGZyb20gdGhlIGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoaXNcbiAgICAvLyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUuXG4gICAgY29uc3QgYXJncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3Nbc2lnLmZvcm1hbHNbaV1dID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZEFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICBjb25zdCBhbnMgPSBhY3Rpb25zW3RhZ10uYXBwbHkodGhpcywgZmFtaWx5Ll9nZXRDaGlsZHJlblt0YWddKHRoaXMuX2FkYXB0ZWUsIGZhbWlseS5fd3JhcCkpO1xuICAgIHRoaXMuYXJncyA9IG9sZEFyZ3M7XG4gICAgcmV0dXJuIGFucztcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBWaXNpdG9yRmFtaWx5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVmlzaXRvckZhbWlseTogcmVxdWlyZSgnLi9WaXNpdG9yRmFtaWx5JyksXG4gIHNlbWFudGljc0ZvclRvQVNUOiByZXF1aXJlKCcuL3NlbWFudGljcy10b0FTVCcpLnNlbWFudGljcyxcbiAgdG9BU1Q6IHJlcXVpcmUoJy4vc2VtYW50aWNzLXRvQVNUJykuaGVscGVyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi4vc3JjL3BleHBycycpO1xuY29uc3QgTWF0Y2hSZXN1bHQgPSByZXF1aXJlKCcuLi9zcmMvTWF0Y2hSZXN1bHQnKTtcbmNvbnN0IEdyYW1tYXIgPSByZXF1aXJlKCcuLi9zcmMvR3JhbW1hcicpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgndXRpbC1leHRlbmQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGRlZmF1bHRPcGVyYXRpb24gPSB7XG4gIF90ZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmltaXRpdmVWYWx1ZTtcbiAgfSxcblxuICBfbm9udGVybWluYWwoY2hpbGRyZW4pIHtcbiAgICBjb25zdCBjdG9yTmFtZSA9IHRoaXMuX25vZGUuY3Rvck5hbWU7XG4gICAgY29uc3QgbWFwcGluZyA9IHRoaXMuYXJncy5tYXBwaW5nO1xuXG4gICAgLy8gd2l0aG91dCBjdXN0b21pemF0aW9uXG4gICAgaWYgKCFtYXBwaW5nLmhhc093blByb3BlcnR5KGN0b3JOYW1lKSkge1xuICAgICAgLy8gaW50ZXJtZWRpYXRlIG5vZGVcbiAgICAgIGlmICh0aGlzLl9ub2RlIGluc3RhbmNlb2YgcGV4cHJzLkFsdCB8fCB0aGlzLl9ub2RlIGluc3RhbmNlb2YgcGV4cHJzLkFwcGx5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXS50b0FTVChtYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgLy8gbGV4aWNhbCBydWxlXG4gICAgICBpZiAodGhpcy5pc0xleGljYWwoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIHNpbmd1bGFyIG5vZGUgKGUuZy4gb25seSBzdXJyb3VuZGVkIGJ5IGxpdGVyYWxzIG9yIGxvb2thaGVhZHMpXG4gICAgICBjb25zdCByZWFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gIWNoaWxkLmlzVGVybWluYWwoKSk7XG4gICAgICBpZiAocmVhbENoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcmVhbENoaWxkcmVuWzBdLnRvQVNUKG1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0OiB0ZXJtcyB3aXRoIG11bHRpcGxlIGNoaWxkcmVuXG4gICAgfVxuXG4gICAgLy8gZGlyZWN0IGZvcndhcmRcbiAgICBpZiAodHlwZW9mIG1hcHBpbmdbY3Rvck5hbWVdID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW21hcHBpbmdbY3Rvck5hbWVdXS50b0FTVChtYXBwaW5nKTtcbiAgICB9XG5cbiAgICAvLyBuYW1lZC9tYXBwZWQgY2hpbGRyZW4gb3IgdW5uYW1lZCBjaGlsZHJlbiAoJzAnLCAnMScsICcyJywgLi4uKVxuICAgIGNvbnN0IHByb3BNYXAgPSBtYXBwaW5nW2N0b3JOYW1lXSB8fCBjaGlsZHJlbjtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogY3Rvck5hbWVcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wTWFwKSB7XG4gICAgICBjb25zdCBtYXBwZWRQcm9wID0gbWFwcGluZ1tjdG9yTmFtZV0gJiYgbWFwcGluZ1tjdG9yTmFtZV1bcHJvcF07XG4gICAgICBpZiAodHlwZW9mIG1hcHBlZFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIGRpcmVjdCBmb3J3YXJkXG4gICAgICAgIG5vZGVbcHJvcF0gPSBjaGlsZHJlblttYXBwZWRQcm9wXS50b0FTVChtYXBwaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnc3RyaW5nJykgfHwgKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnYm9vbGVhbicpIHx8XG4gICAgICAgICAgKG1hcHBlZFByb3AgPT09IG51bGwpKSB7XG4gICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICBub2RlW3Byb3BdID0gbWFwcGVkUHJvcDtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnb2JqZWN0JykgJiYgKG1hcHBlZFByb3AgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgIC8vIHByaW1pdGl2ZSBudW1iZXIgKG11c3QgYmUgdW5ib3hlZClcbiAgICAgICAgbm9kZVtwcm9wXSA9IE51bWJlcihtYXBwZWRQcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcHBlZFByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gY29tcHV0ZWQgdmFsdWVcbiAgICAgICAgbm9kZVtwcm9wXSA9IG1hcHBlZFByb3AuY2FsbCh0aGlzLCBjaGlsZHJlbik7XG4gICAgICB9IGVsc2UgaWYgKG1hcHBlZFByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bcHJvcF0gJiYgIWNoaWxkcmVuW3Byb3BdLmlzVGVybWluYWwoKSkge1xuICAgICAgICAgIG5vZGVbcHJvcF0gPSBjaGlsZHJlbltwcm9wXS50b0FTVChtYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWxldGUgcHJlZGVmaW5lZCAndHlwZScgcHJvcGVydGllcywgbGlrZSAndHlwZScsIGlmIGV4cGxpY2l0ZWx5IHJlbW92ZWRcbiAgICAgICAgICBkZWxldGUgbm9kZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBfaXRlcihjaGlsZHJlbikge1xuICAgIGlmICh0aGlzLl9ub2RlLmlzT3B0aW9uYWwoKSkge1xuICAgICAgaWYgKHRoaXMubnVtQ2hpbGRyZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF0udG9BU1QodGhpcy5hcmdzLm1hcHBpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC50b0FTVCh0aGlzLmFyZ3MubWFwcGluZyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgTm9uZW1wdHlMaXN0T2YoZmlyc3QsIHNlcCwgcmVzdCkge1xuICAgIHJldHVybiBbZmlyc3QudG9BU1QodGhpcy5hcmdzLm1hcHBpbmcpXS5jb25jYXQocmVzdC50b0FTVCh0aGlzLmFyZ3MubWFwcGluZykpO1xuICB9LFxuXG4gIEVtcHR5TGlzdE9mKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLy8gUmV0dXJucyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgaW5jbHVkZXMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgKEFTVClcbi8vIGZvciB0aGUgZ2l2ZW4gbWF0Y2ggcmVzdWx0IGByZXNgIGNvbnRhaW5nIGEgY29uY3JldGUgc3ludGF4IHRyZWUgKENTVCkgYW5kIGdyYW1tYXIuXG4vLyBUaGUgb3B0aW9uYWwgYG1hcHBpbmdgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBjdXN0b21pemUgaG93IHRoZSBub2RlcyBvZiB0aGUgQ1NUXG4vLyBhcmUgbWFwcGVkIHRvIHRoZSBBU1QgKHNlZSAvZG9jL2V4dHJhcy5tZCN0b2FzdG1hdGNocmVzdWx0LW1hcHBpbmcpLlxuZnVuY3Rpb24gdG9BU1QocmVzLCBtYXBwaW5nKSB7XG4gIGlmICghKHJlcyBpbnN0YW5jZW9mIE1hdGNoUmVzdWx0KSB8fCByZXMuZmFpbGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvQVNUKCkgZXhwZWN0cyBhIHN1Y2Nlc2Z1bGwgTWF0Y2hSZXN1bHQgYXMgZmlyc3QgcGFyYW1ldGVyJyk7XG4gIH1cblxuICBtYXBwaW5nID0gZXh0ZW5kKHt9LCBtYXBwaW5nKTtcbiAgY29uc3Qgb3BlcmF0aW9uID0gZXh0ZW5kKHt9LCBkZWZhdWx0T3BlcmF0aW9uKTtcbiAgZm9yIChjb25zdCB0ZXJtTmFtZSBpbiBtYXBwaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBwaW5nW3Rlcm1OYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3BlcmF0aW9uW3Rlcm1OYW1lXSA9IG1hcHBpbmdbdGVybU5hbWVdO1xuICAgICAgZGVsZXRlIG1hcHBpbmdbdGVybU5hbWVdO1xuICAgIH1cbiAgfVxuICBjb25zdCBnID0gcmVzLl9jc3QuZ3JhbW1hcjtcbiAgY29uc3QgcyA9IGcuY3JlYXRlU2VtYW50aWNzKCkuYWRkT3BlcmF0aW9uKCd0b0FTVChtYXBwaW5nKScsIG9wZXJhdGlvbik7XG4gIHJldHVybiBzKHJlcykudG9BU1QobWFwcGluZyk7XG59XG5cbi8vIFJldHVybnMgYSBzZW1hbnRpY3MgY29udGFpbmcgdGhlIHRvQVNUKG1hcHBpbmcpIG9wZXJhdGlvbiBmb3IgdGhlIGdpdmVuIGdyYW1tYXIgZy5cbmZ1bmN0aW9uIHNlbWFudGljc0ZvclRvQVNUKGcpIHtcbiAgaWYgKCEoZyBpbnN0YW5jZW9mIEdyYW1tYXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZW1hbnRpY3NUb0FTVCgpIGV4cGVjdHMgYSBHcmFtbWFyIGFzIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgcmV0dXJuIGcuY3JlYXRlU2VtYW50aWNzKCkuYWRkT3BlcmF0aW9uKCd0b0FTVChtYXBwaW5nKScsIGRlZmF1bHRPcGVyYXRpb24pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaGVscGVyOiB0b0FTVCxcbiAgc2VtYW50aWNzOiBzZW1hbnRpY3NGb3JUb0FTVFxufTtcbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEdyYW1tYXJEZWNsID0gcmVxdWlyZSgnLi9HcmFtbWFyRGVjbCcpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEJ1aWxkZXIoKSB7fVxuXG5CdWlsZGVyLnByb3RvdHlwZSA9IHtcbiAgY3VycmVudERlY2w6IG51bGwsXG4gIGN1cnJlbnRSdWxlTmFtZTogbnVsbCxcblxuICBuZXdHcmFtbWFyKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEdyYW1tYXJEZWNsKG5hbWUpO1xuICB9LFxuXG4gIGdyYW1tYXIobWV0YUluZm8sIG5hbWUsIHN1cGVyR3JhbW1hciwgZGVmYXVsdFN0YXJ0UnVsZSwgcnVsZXMpIHtcbiAgICBjb25zdCBnRGVjbCA9IG5ldyBHcmFtbWFyRGVjbChuYW1lKTtcbiAgICBpZiAoc3VwZXJHcmFtbWFyKSB7XG4gICAgICBnRGVjbC53aXRoU3VwZXJHcmFtbWFyKHRoaXMuZnJvbVJlY2lwZShzdXBlckdyYW1tYXIpKTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTdGFydFJ1bGUpIHtcbiAgICAgIGdEZWNsLndpdGhEZWZhdWx0U3RhcnRSdWxlKGRlZmF1bHRTdGFydFJ1bGUpO1xuICAgIH1cbiAgICBpZiAobWV0YUluZm8gJiYgbWV0YUluZm8uc291cmNlKSB7XG4gICAgICBnRGVjbC53aXRoU291cmNlKG1ldGFJbmZvLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RGVjbCA9IGdEZWNsO1xuICAgIE9iamVjdC5rZXlzKHJ1bGVzKS5mb3JFYWNoKHJ1bGVOYW1lID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgICBjb25zdCBydWxlUmVjaXBlID0gcnVsZXNbcnVsZU5hbWVdO1xuXG4gICAgICBjb25zdCBhY3Rpb24gPSBydWxlUmVjaXBlWzBdOyAvLyBkZWZpbmUvZXh0ZW5kL292ZXJyaWRlXG4gICAgICBjb25zdCBtZXRhSW5mbyA9IHJ1bGVSZWNpcGVbMV07XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHJ1bGVSZWNpcGVbMl07XG4gICAgICBjb25zdCBmb3JtYWxzID0gcnVsZVJlY2lwZVszXTtcbiAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmZyb21SZWNpcGUocnVsZVJlY2lwZVs0XSk7XG5cbiAgICAgIGxldCBzb3VyY2U7XG4gICAgICBpZiAoZ0RlY2wuc291cmNlICYmIG1ldGFJbmZvICYmIG1ldGFJbmZvLnNvdXJjZUludGVydmFsKSB7XG4gICAgICAgIHNvdXJjZSA9IGdEZWNsLnNvdXJjZS5zdWJJbnRlcnZhbChcbiAgICAgICAgICAgIG1ldGFJbmZvLnNvdXJjZUludGVydmFsWzBdLFxuICAgICAgICAgICAgbWV0YUluZm8uc291cmNlSW50ZXJ2YWxbMV0gLSBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbFswXSk7XG4gICAgICB9XG4gICAgICBnRGVjbFthY3Rpb25dKHJ1bGVOYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjcmlwdGlvbiwgc291cmNlKTtcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbnRSdWxlTmFtZSA9IHRoaXMuY3VycmVudERlY2wgPSBudWxsO1xuICAgIHJldHVybiBnRGVjbC5idWlsZCgpO1xuICB9LFxuXG4gIHRlcm1pbmFsKHgpIHtcbiAgICByZXR1cm4gbmV3IHBleHBycy5UZXJtaW5hbCh4KTtcbiAgfSxcblxuICByYW5nZShmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgcGV4cHJzLlJhbmdlKGZyb20sIHRvKTtcbiAgfSxcblxuICBwYXJhbShpbmRleCkge1xuICAgIHJldHVybiBuZXcgcGV4cHJzLlBhcmFtKGluZGV4KTtcbiAgfSxcblxuICBhbHQoLyogdGVybTEsIHRlcm0yLCAuLi4gKi8pIHtcbiAgICBsZXQgdGVybXMgPSBbXTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcmd1bWVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3VtZW50c1tpZHhdO1xuICAgICAgaWYgKCEoYXJnIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgICBhcmcgPSB0aGlzLmZyb21SZWNpcGUoYXJnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBwZXhwcnMuQWx0KSB7XG4gICAgICAgIHRlcm1zID0gdGVybXMuY29uY2F0KGFyZy50ZXJtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXJtcy5wdXNoKGFyZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXJtcy5sZW5ndGggPT09IDEgPyB0ZXJtc1swXSA6IG5ldyBwZXhwcnMuQWx0KHRlcm1zKTtcbiAgfSxcblxuICBzZXEoLyogZmFjdG9yMSwgZmFjdG9yMiwgLi4uICovKSB7XG4gICAgbGV0IGZhY3RvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcmd1bWVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgbGV0IGFyZyA9IGFyZ3VtZW50c1tpZHhdO1xuICAgICAgaWYgKCEoYXJnIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgICBhcmcgPSB0aGlzLmZyb21SZWNpcGUoYXJnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBwZXhwcnMuU2VxKSB7XG4gICAgICAgIGZhY3RvcnMgPSBmYWN0b3JzLmNvbmNhdChhcmcuZmFjdG9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3JzLnB1c2goYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY3RvcnMubGVuZ3RoID09PSAxID8gZmFjdG9yc1swXSA6IG5ldyBwZXhwcnMuU2VxKGZhY3RvcnMpO1xuICB9LFxuXG4gIHN0YXIoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5TdGFyKGV4cHIpO1xuICB9LFxuXG4gIHBsdXMoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5QbHVzKGV4cHIpO1xuICB9LFxuXG4gIG9wdChleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLk9wdChleHByKTtcbiAgfSxcblxuICBub3QoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5Ob3QoZXhwcik7XG4gIH0sXG5cbiAgbGEoZXhwcikge1xuICAgIC8vIFRPRE86IHRlbXBvcmFyeSB0byBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgb2xkIHJlY2lwZXNcbiAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQoZXhwcik7XG4gIH0sXG5cbiAgbG9va2FoZWFkKGV4cHIpIHtcbiAgICBpZiAoIShleHByIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgZXhwciA9IHRoaXMuZnJvbVJlY2lwZShleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuTG9va2FoZWFkKGV4cHIpO1xuICB9LFxuXG4gIGxleChleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLkxleChleHByKTtcbiAgfSxcblxuICBhcHAocnVsZU5hbWUsIG9wdFBhcmFtcykge1xuICAgIGlmIChvcHRQYXJhbXMgJiYgb3B0UGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIG9wdFBhcmFtcyA9IG9wdFBhcmFtcy5tYXAoZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByID8gcGFyYW0gOlxuICAgICAgICAgIHRoaXMuZnJvbVJlY2lwZShwYXJhbSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuQXBwbHkocnVsZU5hbWUsIG9wdFBhcmFtcyk7XG4gIH0sXG5cbiAgLy8gTm90ZSB0aGF0IHVubGlrZSBvdGhlciBtZXRob2RzIGluIHRoaXMgY2xhc3MsIHRoaXMgbWV0aG9kIGNhbm5vdCBiZSB1c2VkIGFzIGFcbiAgLy8gY29udmVuaWVuY2UgY29uc3RydWN0b3IuIEl0IG9ubHkgd29ya3Mgd2l0aCByZWNpcGVzLCBiZWNhdXNlIGl0IHJlbGllcyBvblxuICAvLyBgdGhpcy5jdXJyZW50RGVjbGAgYW5kIGB0aGlzLmN1cnJlbnRSdWxlTmFtZWAgYmVpbmcgc2V0LlxuICBzcGxpY2UoYmVmb3JlVGVybXMsIGFmdGVyVGVybXMpIHtcbiAgICByZXR1cm4gbmV3IHBleHBycy5TcGxpY2UoXG4gICAgICAgIHRoaXMuY3VycmVudERlY2wuc3VwZXJHcmFtbWFyLFxuICAgICAgICB0aGlzLmN1cnJlbnRSdWxlTmFtZSxcbiAgICAgICAgYmVmb3JlVGVybXMubWFwKHRlcm0gPT4gdGhpcy5mcm9tUmVjaXBlKHRlcm0pKSxcbiAgICAgICAgYWZ0ZXJUZXJtcy5tYXAodGVybSA9PiB0aGlzLmZyb21SZWNpcGUodGVybSkpKTtcbiAgfSxcblxuICBmcm9tUmVjaXBlKHJlY2lwZSkge1xuICAgIC8vIHRoZSBtZXRhLWluZm8gb2YgJ2dyYW1tYXInIGlzIHByb2Nlc3NlZCBpbiBCdWlsZGVyLmdyYW1tYXJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzW3JlY2lwZVswXV0uYXBwbHkodGhpcyxcbiAgICAgIHJlY2lwZVswXSA9PT0gJ2dyYW1tYXInID8gcmVjaXBlLnNsaWNlKDEpIDogcmVjaXBlLnNsaWNlKDIpKTtcblxuICAgIGNvbnN0IG1ldGFJbmZvID0gcmVjaXBlWzFdO1xuICAgIGlmIChtZXRhSW5mbykge1xuICAgICAgaWYgKG1ldGFJbmZvLnNvdXJjZUludGVydmFsICYmIHRoaXMuY3VycmVudERlY2wpIHtcbiAgICAgICAgcmVzdWx0LndpdGhTb3VyY2UoXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREZWNsLnNvdXJjZUludGVydmFsLmFwcGx5KHRoaXMuY3VycmVudERlY2wsIG1ldGFJbmZvLnNvdXJjZUludGVydmFsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRmFpbHVyZSA9IHJlcXVpcmUoJy4vRmFpbHVyZScpO1xuY29uc3QgVGVybWluYWxOb2RlID0gcmVxdWlyZSgnLi9ub2RlcycpLlRlcm1pbmFsTm9kZTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJy4vY29tbW9uJykuYXNzZXJ0O1xuY29uc3Qge1BFeHByLCBUZXJtaW5hbH0gPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG5jbGFzcyBDYXNlSW5zZW5zaXRpdmVUZXJtaW5hbCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IocGFyYW0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JqID0gcGFyYW07XG4gIH1cblxuICBfZ2V0U3RyaW5nKHN0YXRlKSB7XG4gICAgY29uc3QgdGVybWluYWwgPSBzdGF0ZS5jdXJyZW50QXBwbGljYXRpb24oKS5hcmdzW3RoaXMub2JqLmluZGV4XTtcbiAgICBhc3NlcnQodGVybWluYWwgaW5zdGFuY2VvZiBUZXJtaW5hbCwgJ2V4cGVjdGVkIGEgVGVybWluYWwgZXhwcmVzc2lvbicpO1xuICAgIHJldHVybiB0ZXJtaW5hbC5vYmo7XG4gIH1cblxuICAvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgUEV4cHIgQVBJXG5cbiAgYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV2YWwoc3RhdGUpIHtcbiAgICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICAgIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gICAgY29uc3QgbWF0Y2hTdHIgPSB0aGlzLl9nZXRTdHJpbmcoc3RhdGUpO1xuICAgIGlmICghaW5wdXRTdHJlYW0ubWF0Y2hTdHJpbmcobWF0Y2hTdHIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCBtYXRjaFN0ciksIG9yaWdQb3MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgZXhhbXBsZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVGVybWluYWwuLi5cbiAgICBjb25zdCBzdHIgPSB0aGlzLm9iai5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykudmFsdWU7XG5cbiAgICAvLyAuLi5hbmQgcmFuZG9tbHkgc3dpdGNoIGNoYXJhY3RlcnMgdG8gdXBwZXJjYXNlL2xvd2VyY2FzZS5cbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsdWUgKz0gTWF0aC5yYW5kb20oKSA8IDAuNSA/IHN0cltpXS50b0xvY2FsZUxvd2VyQ2FzZSgpIDogc3RyW2ldLnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB7dmFsdWV9O1xuICB9XG5cbiAgZ2V0QXJpdHkoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBzdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpIHtcbiAgICByZXR1cm4gbmV3IENhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsKHRoaXMub2JqLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykpO1xuICB9XG5cbiAgdG9EaXNwbGF5U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm9iai50b0Rpc3BsYXlTdHJpbmcoKSArICcgKGNhc2UtaW5zZW5zaXRpdmUpJztcbiAgfVxuXG4gIHRvRmFpbHVyZShncmFtbWFyKSB7XG4gICAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIHRoaXMub2JqLnRvRmFpbHVyZShncmFtbWFyKSArICcgKGNhc2UtaW5zZW5zaXRpdmUpJywgJ2Rlc2NyaXB0aW9uJyk7XG4gIH1cblxuICBfaXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqLl9pc051bGxhYmxlKGdyYW1tYXIsIG1lbW8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FzZUluc2Vuc2l0aXZlVGVybWluYWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBgRmFpbHVyZWBzIHJlcHJlc2VudCBleHByZXNzaW9ucyB0aGF0IHdlcmVuJ3QgbWF0Y2hlZCB3aGlsZSBwYXJzaW5nLiBUaGV5IGFyZSB1c2VkIHRvIGdlbmVyYXRlXG4gIGVycm9yIG1lc3NhZ2VzIGF1dG9tYXRpY2FsbHkuIFRoZSBpbnRlcmZhY2Ugb2YgYEZhaWx1cmVgcyBpbmNsdWRlcyB0aGUgY29sbG93aW5nIG1ldGhvZHM6XG5cbiAgLSBnZXRUZXh0KCkgOiBTdHJpbmdcbiAgLSBnZXRUeXBlKCkgOiBTdHJpbmcgIChvbmUgb2Yge1wiZGVzY3JpcHRpb25cIiwgXCJzdHJpbmdcIiwgXCJjb2RlXCJ9KVxuICAtIGlzRGVzY3JpcHRpb24oKSA6IGJvb2xcbiAgLSBpc1N0cmluZ1Rlcm1pbmFsKCkgOiBib29sXG4gIC0gaXNDb2RlKCkgOiBib29sXG4gIC0gaXNGbHVmZnkoKSA6IGJvb2xcbiAgLSBtYWtlRmx1ZmZ5KCkgOiB2b2lkXG4gIC0gc3Vic3VtZXMoRmFpbHVyZSkgOiBib29sXG4qL1xuXG5mdW5jdGlvbiBpc1ZhbGlkVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSAnZGVzY3JpcHRpb24nIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdjb2RlJztcbn1cblxuZnVuY3Rpb24gRmFpbHVyZShwZXhwciwgdGV4dCwgdHlwZSkge1xuICBpZiAoIWlzVmFsaWRUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEZhaWx1cmUgdHlwZTogJyArIHR5cGUpO1xuICB9XG4gIHRoaXMucGV4cHIgPSBwZXhwcjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5mbHVmZnkgPSBmYWxzZTtcbn1cblxuRmFpbHVyZS5wcm90b3R5cGUuZ2V0UEV4cHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGV4cHI7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRleHQ7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGU7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5pc0Rlc2NyaXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09ICdkZXNjcmlwdGlvbic7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5pc1N0cmluZ1Rlcm1pbmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09ICdzdHJpbmcnO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuaXNDb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09ICdjb2RlJztcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmlzRmx1ZmZ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZsdWZmeTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLm1ha2VGbHVmZnkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mbHVmZnkgPSB0cnVlO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuY2xlYXJGbHVmZnkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mbHVmZnkgPSBmYWxzZTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLnN1YnN1bWVzID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gdGhpcy5nZXRUZXh0KCkgPT09IHRoYXQuZ2V0VGV4dCgpICYmXG4gICAgICB0aGlzLnR5cGUgPT09IHRoYXQudHlwZSAmJlxuICAgICAgKCF0aGlzLmlzRmx1ZmZ5KCkgfHwgdGhpcy5pc0ZsdWZmeSgpICYmIHRoYXQuaXNGbHVmZnkoKSk7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSAnc3RyaW5nJyA/XG4gICAgSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRUZXh0KCkpIDpcbiAgICB0aGlzLmdldFRleHQoKTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGZhaWx1cmUgPSBuZXcgRmFpbHVyZSh0aGlzLnBleHByLCB0aGlzLnRleHQsIHRoaXMudHlwZSk7XG4gIGlmICh0aGlzLmlzRmx1ZmZ5KCkpIHtcbiAgICBmYWlsdXJlLm1ha2VGbHVmZnkoKTtcbiAgfVxuICByZXR1cm4gZmFpbHVyZTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLnRvS2V5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCkgKyAnIycgKyB0aGlzLnR5cGU7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBGYWlsdXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgQ2FzZUluc2Vuc2l0aXZlVGVybWluYWwgPSByZXF1aXJlKCcuL0Nhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsJyk7XG5jb25zdCBNYXRjaGVyID0gcmVxdWlyZSgnLi9NYXRjaGVyJyk7XG5jb25zdCBTZW1hbnRpY3MgPSByZXF1aXJlKCcuL1NlbWFudGljcycpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZ2V0U29ydGVkUnVsZVZhbHVlcyhncmFtbWFyKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhncmFtbWFyLnJ1bGVzKS5zb3J0KCkubWFwKG5hbWUgPT4gZ3JhbW1hci5ydWxlc1tuYW1lXSk7XG59XG5cbmZ1bmN0aW9uIEdyYW1tYXIoXG4gICAgbmFtZSxcbiAgICBzdXBlckdyYW1tYXIsXG4gICAgcnVsZXMsXG4gICAgb3B0RGVmYXVsdFN0YXJ0UnVsZSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnN1cGVyR3JhbW1hciA9IHN1cGVyR3JhbW1hcjtcbiAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICBpZiAob3B0RGVmYXVsdFN0YXJ0UnVsZSkge1xuICAgIGlmICghKG9wdERlZmF1bHRTdGFydFJ1bGUgaW4gcnVsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXJ0IHJ1bGU6ICdcIiArIG9wdERlZmF1bHRTdGFydFJ1bGUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiJyBpcyBub3QgYSBydWxlIGluIGdyYW1tYXIgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0U3RhcnRSdWxlID0gb3B0RGVmYXVsdFN0YXJ0UnVsZTtcbiAgfVxufVxuXG5sZXQgb2htR3JhbW1hcjtcbmxldCBidWlsZEdyYW1tYXI7XG5cbi8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBmcm9tIG1haW4uanMgb25jZSBPaG0gaGFzIGxvYWRlZC5cbkdyYW1tYXIuaW5pdEFwcGxpY2F0aW9uUGFyc2VyID0gZnVuY3Rpb24oZ3JhbW1hciwgYnVpbGRlckZuKSB7XG4gIG9obUdyYW1tYXIgPSBncmFtbWFyO1xuICBidWlsZEdyYW1tYXIgPSBidWlsZGVyRm47XG59O1xuXG5HcmFtbWFyLnByb3RvdHlwZSA9IHtcbiAgbWF0Y2hlcigpIHtcbiAgICByZXR1cm4gbmV3IE1hdGNoZXIodGhpcyk7XG4gIH0sXG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIGdyYW1tYXIgaXMgYSBidWlsdC1pbiBncmFtbWFyLCBvdGhlcndpc2UgZmFsc2UuXG4gIC8vIE5PVEU6IFRoaXMgbWlnaHQgZ2l2ZSBhbiB1bmV4cGVjdGVkIHJlc3VsdCBpZiBjYWxsZWQgYmVmb3JlIEJ1aWx0SW5SdWxlcyBpcyBkZWZpbmVkIVxuICBpc0J1aWx0SW4oKSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IEdyYW1tYXIuUHJvdG9CdWlsdEluUnVsZXMgfHwgdGhpcyA9PT0gR3JhbW1hci5CdWlsdEluUnVsZXM7XG4gIH0sXG5cbiAgZXF1YWxzKGcpIHtcbiAgICBpZiAodGhpcyA9PT0gZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERvIHRoZSBjaGVhcGVzdCBjb21wYXJpc29ucyBmaXJzdC5cbiAgICBpZiAoZyA9PSBudWxsIHx8XG4gICAgICAgIHRoaXMubmFtZSAhPT0gZy5uYW1lIHx8XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSAhPT0gZy5kZWZhdWx0U3RhcnRSdWxlIHx8XG4gICAgICAgICEodGhpcy5zdXBlckdyYW1tYXIgPT09IGcuc3VwZXJHcmFtbWFyIHx8IHRoaXMuc3VwZXJHcmFtbWFyLmVxdWFscyhnLnN1cGVyR3JhbW1hcikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG15UnVsZXMgPSBnZXRTb3J0ZWRSdWxlVmFsdWVzKHRoaXMpO1xuICAgIGNvbnN0IG90aGVyUnVsZXMgPSBnZXRTb3J0ZWRSdWxlVmFsdWVzKGcpO1xuICAgIHJldHVybiBteVJ1bGVzLmxlbmd0aCA9PT0gb3RoZXJSdWxlcy5sZW5ndGggJiYgbXlSdWxlcy5ldmVyeSgocnVsZSwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJ1bGUuZGVzY3JpcHRpb24gPT09IG90aGVyUnVsZXNbaV0uZGVzY3JpcHRpb24gJiZcbiAgICAgICAgICAgICBydWxlLmZvcm1hbHMuam9pbignLCcpID09PSBvdGhlclJ1bGVzW2ldLmZvcm1hbHMuam9pbignLCcpICYmXG4gICAgICAgICAgICAgcnVsZS5ib2R5LnRvU3RyaW5nKCkgPT09IG90aGVyUnVsZXNbaV0uYm9keS50b1N0cmluZygpO1xuICAgIH0pO1xuICB9LFxuXG4gIG1hdGNoKGlucHV0LCBvcHRTdGFydEFwcGxpY2F0aW9uKSB7XG4gICAgY29uc3QgbSA9IHRoaXMubWF0Y2hlcigpO1xuICAgIG0ucmVwbGFjZUlucHV0UmFuZ2UoMCwgMCwgaW5wdXQpO1xuICAgIHJldHVybiBtLm1hdGNoKG9wdFN0YXJ0QXBwbGljYXRpb24pO1xuICB9LFxuXG4gIHRyYWNlKGlucHV0LCBvcHRTdGFydEFwcGxpY2F0aW9uKSB7XG4gICAgY29uc3QgbSA9IHRoaXMubWF0Y2hlcigpO1xuICAgIG0ucmVwbGFjZUlucHV0UmFuZ2UoMCwgMCwgaW5wdXQpO1xuICAgIHJldHVybiBtLnRyYWNlKG9wdFN0YXJ0QXBwbGljYXRpb24pO1xuICB9LFxuXG4gIHNlbWFudGljcygpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBldmVudHVhbGx5ISBEZXByZWNhdGVkIGluIHYwLjEyLlxuICAgIHRocm93IG5ldyBFcnJvcignc2VtYW50aWNzKCkgaXMgZGVwcmVjYXRlZCAtLSB1c2UgY3JlYXRlU2VtYW50aWNzKCkgaW5zdGVhZC4nKTtcbiAgfSxcblxuICBjcmVhdGVTZW1hbnRpY3MoKSB7XG4gICAgcmV0dXJuIFNlbWFudGljcy5jcmVhdGVTZW1hbnRpY3ModGhpcyk7XG4gIH0sXG5cbiAgZXh0ZW5kU2VtYW50aWNzKHN1cGVyU2VtYW50aWNzKSB7XG4gICAgcmV0dXJuIFNlbWFudGljcy5jcmVhdGVTZW1hbnRpY3ModGhpcywgc3VwZXJTZW1hbnRpY3MuX2dldFNlbWFudGljcygpKTtcbiAgfSxcblxuICAvLyBDaGVjayB0aGF0IGV2ZXJ5IGtleSBpbiBgYWN0aW9uRGljdGAgY29ycmVzcG9uZHMgdG8gYSBzZW1hbnRpYyBhY3Rpb24sIGFuZCB0aGF0IGl0IG1hcHMgdG9cbiAgLy8gYSBmdW5jdGlvbiBvZiB0aGUgY29ycmVjdCBhcml0eS4gSWYgbm90LCB0aHJvdyBhbiBleGNlcHRpb24uXG4gIF9jaGVja1RvcERvd25BY3Rpb25EaWN0KHdoYXQsIG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBmdW5jdGlvbiBpc1NwZWNpYWxBY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGEgPT09ICdfaXRlcicgfHwgYSA9PT0gJ190ZXJtaW5hbCcgfHwgYSA9PT0gJ19ub250ZXJtaW5hbCcgfHwgYSA9PT0gJ19kZWZhdWx0JztcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ibGVtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBhY3Rpb25EaWN0KSB7XG4gICAgICBjb25zdCB2ID0gYWN0aW9uRGljdFtrXTtcbiAgICAgIGlmICghaXNTcGVjaWFsQWN0aW9uKGspICYmICEoayBpbiB0aGlzLnJ1bGVzKSkge1xuICAgICAgICBwcm9ibGVtcy5wdXNoKFwiJ1wiICsgayArIFwiJyBpcyBub3QgYSB2YWxpZCBzZW1hbnRpYyBhY3Rpb24gZm9yICdcIiArIHRoaXMubmFtZSArIFwiJ1wiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvYmxlbXMucHVzaChcbiAgICAgICAgICAgIFwiJ1wiICsgayArIFwiJyBtdXN0IGJlIGEgZnVuY3Rpb24gaW4gYW4gYWN0aW9uIGRpY3Rpb25hcnkgZm9yICdcIiArIHRoaXMubmFtZSArIFwiJ1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbCA9IHYubGVuZ3RoO1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IHRoaXMuX3RvcERvd25BY3Rpb25Bcml0eShrKTtcbiAgICAgICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICBwcm9ibGVtcy5wdXNoKFxuICAgICAgICAgICAgICBcIlNlbWFudGljIGFjdGlvbiAnXCIgKyBrICsgXCInIGhhcyB0aGUgd3JvbmcgYXJpdHk6IFwiICtcbiAgICAgICAgICAgICAgJ2V4cGVjdGVkICcgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvYmxlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcHJldHR5UHJvYmxlbXMgPSBwcm9ibGVtcy5tYXAocHJvYmxlbSA9PiAnLSAnICsgcHJvYmxlbSk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkZvdW5kIGVycm9ycyBpbiB0aGUgYWN0aW9uIGRpY3Rpb25hcnkgb2YgdGhlICdcIiArIG5hbWUgKyBcIicgXCIgKyB3aGF0ICsgJzpcXG4nICtcbiAgICAgICAgICBwcmV0dHlQcm9ibGVtcy5qb2luKCdcXG4nKSk7XG4gICAgICBlcnJvci5wcm9ibGVtcyA9IHByb2JsZW1zO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybiB0aGUgZXhwZWN0ZWQgYXJpdHkgZm9yIGEgc2VtYW50aWMgYWN0aW9uIG5hbWVkIGBhY3Rpb25OYW1lYCwgd2hpY2hcbiAgLy8gaXMgZWl0aGVyIGEgcnVsZSBuYW1lIG9yIGEgc3BlY2lhbCBhY3Rpb24gbmFtZSBsaWtlICdfbm9udGVybWluYWwnLlxuICBfdG9wRG93bkFjdGlvbkFyaXR5KGFjdGlvbk5hbWUpIHtcbiAgICBpZiAoYWN0aW9uTmFtZSA9PT0gJ19pdGVyJyB8fCBhY3Rpb25OYW1lID09PSAnX25vbnRlcm1pbmFsJyB8fCBhY3Rpb25OYW1lID09PSAnX2RlZmF1bHQnKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbk5hbWUgPT09ICdfdGVybWluYWwnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucnVsZXNbYWN0aW9uTmFtZV0uYm9keS5nZXRBcml0eSgpO1xuICB9LFxuXG4gIF9pbmhlcml0c0Zyb20oZ3JhbW1hcikge1xuICAgIGxldCBnID0gdGhpcy5zdXBlckdyYW1tYXI7XG4gICAgd2hpbGUgKGcpIHtcbiAgICAgIGlmIChnLmVxdWFscyhncmFtbWFyLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGcgPSBnLnN1cGVyR3JhbW1hcjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHRvUmVjaXBlKG9wdFZhck5hbWUpIHtcbiAgICBjb25zdCBtZXRhSW5mbyA9IHt9O1xuICAgIC8vIEluY2x1ZGUgdGhlIGdyYW1tYXIgc291cmNlIGlmIGl0IGlzIGF2YWlsYWJsZS5cbiAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgIG1ldGFJbmZvLnNvdXJjZSA9IHRoaXMuc291cmNlLmNvbnRlbnRzO1xuICAgIH1cblxuICAgIGxldCBzdXBlckdyYW1tYXIgPSBudWxsO1xuICAgIGlmICh0aGlzLnN1cGVyR3JhbW1hciAmJiAhdGhpcy5zdXBlckdyYW1tYXIuaXNCdWlsdEluKCkpIHtcbiAgICAgIHN1cGVyR3JhbW1hciA9IEpTT04ucGFyc2UodGhpcy5zdXBlckdyYW1tYXIudG9SZWNpcGUoKSk7XG4gICAgfVxuXG4gICAgbGV0IHN0YXJ0UnVsZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSkge1xuICAgICAgc3RhcnRSdWxlID0gdGhpcy5kZWZhdWx0U3RhcnRSdWxlO1xuICAgIH1cblxuICAgIGNvbnN0IHJ1bGVzID0ge307XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcy5ydWxlcykuZm9yRWFjaChydWxlTmFtZSA9PiB7XG4gICAgICBjb25zdCBydWxlSW5mbyA9IHNlbGYucnVsZXNbcnVsZU5hbWVdO1xuICAgICAgY29uc3QgYm9keSA9IHJ1bGVJbmZvLmJvZHk7XG4gICAgICBjb25zdCBpc0RlZmluaXRpb24gPSAhc2VsZi5zdXBlckdyYW1tYXIgfHwgIXNlbGYuc3VwZXJHcmFtbWFyLnJ1bGVzW3J1bGVOYW1lXTtcblxuICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgIGlmIChpc0RlZmluaXRpb24pIHtcbiAgICAgICAgb3BlcmF0aW9uID0gJ2RlZmluZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVyYXRpb24gPSBib2R5IGluc3RhbmNlb2YgcGV4cHJzLkV4dGVuZCA/ICdleHRlbmQnIDogJ292ZXJyaWRlJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0YUluZm8gPSB7fTtcbiAgICAgIGlmIChydWxlSW5mby5zb3VyY2UgJiYgc2VsZi5zb3VyY2UpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWQgPSBydWxlSW5mby5zb3VyY2UucmVsYXRpdmVUbyhzZWxmLnNvdXJjZSk7XG4gICAgICAgIG1ldGFJbmZvLnNvdXJjZUludGVydmFsID0gW2FkanVzdGVkLnN0YXJ0SWR4LCBhZGp1c3RlZC5lbmRJZHhdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGlzRGVmaW5pdGlvbiA/IHJ1bGVJbmZvLmRlc2NyaXB0aW9uIDogbnVsbDtcbiAgICAgIGNvbnN0IGJvZHlSZWNpcGUgPSBib2R5Lm91dHB1dFJlY2lwZShydWxlSW5mby5mb3JtYWxzLCBzZWxmLnNvdXJjZSk7XG5cbiAgICAgIHJ1bGVzW3J1bGVOYW1lXSA9IFtcbiAgICAgICAgb3BlcmF0aW9uLCAvLyBcImRlZmluZVwiL1wiZXh0ZW5kXCIvXCJvdmVycmlkZVwiXG4gICAgICAgIG1ldGFJbmZvLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgcnVsZUluZm8uZm9ybWFscyxcbiAgICAgICAgYm9keVJlY2lwZVxuICAgICAgXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShbXG4gICAgICAnZ3JhbW1hcicsXG4gICAgICBtZXRhSW5mbyxcbiAgICAgIHRoaXMubmFtZSxcbiAgICAgIHN1cGVyR3JhbW1hcixcbiAgICAgIHN0YXJ0UnVsZSxcbiAgICAgIHJ1bGVzXG4gICAgXSk7XG4gIH0sXG5cbiAgLy8gVE9ETzogQ29tZSB1cCB3aXRoIGJldHRlciBuYW1lcyBmb3IgdGhlc2UgbWV0aG9kcy5cbiAgLy8gVE9ETzogV3JpdGUgdGhlIGFuYWxvZyBvZiB0aGVzZSBtZXRob2RzIGZvciBpbmhlcml0ZWQgYXR0cmlidXRlcy5cbiAgdG9PcGVyYXRpb25BY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvT3BlcmF0aW9uT3JBdHRyaWJ1dGVBY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKTtcbiAgfSxcbiAgdG9BdHRyaWJ1dGVBY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvT3BlcmF0aW9uT3JBdHRyaWJ1dGVBY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKTtcbiAgfSxcblxuICBfdG9PcGVyYXRpb25PckF0dHJpYnV0ZUFjdGlvbkRpY3Rpb25hcnlUZW1wbGF0ZSgpIHtcbiAgICAvLyBUT0RPOiBhZGQgdGhlIHN1cGVyLWdyYW1tYXIncyB0ZW1wbGF0ZXMgYXQgdGhlIHJpZ2h0IHBsYWNlLCBlLmcuLCBhIGNhc2UgZm9yIEFkZEV4cHJfcGx1c1xuICAgIC8vIHNob3VsZCBhcHBlYXIgbmV4dCB0byBvdGhlciBjYXNlcyBvZiBBZGRFeHByLlxuXG4gICAgY29uc3Qgc2IgPSBuZXcgY29tbW9uLlN0cmluZ0J1ZmZlcigpO1xuICAgIHNiLmFwcGVuZCgneycpO1xuXG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJ1bGVOYW1lIGluIHRoaXMucnVsZXMpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnJ1bGVzW3J1bGVOYW1lXS5ib2R5O1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzYi5hcHBlbmQoJywnKTtcbiAgICAgIH1cbiAgICAgIHNiLmFwcGVuZCgnXFxuJyk7XG4gICAgICBzYi5hcHBlbmQoJyAgJyk7XG4gICAgICB0aGlzLmFkZFNlbWFudGljQWN0aW9uVGVtcGxhdGUocnVsZU5hbWUsIGJvZHksIHNiKTtcbiAgICB9XG5cbiAgICBzYi5hcHBlbmQoJ1xcbn0nKTtcbiAgICByZXR1cm4gc2IuY29udGVudHMoKTtcbiAgfSxcblxuICBhZGRTZW1hbnRpY0FjdGlvblRlbXBsYXRlKHJ1bGVOYW1lLCBib2R5LCBzYikge1xuICAgIHNiLmFwcGVuZChydWxlTmFtZSk7XG4gICAgc2IuYXBwZW5kKCc6IGZ1bmN0aW9uKCcpO1xuICAgIGNvbnN0IGFyaXR5ID0gdGhpcy5fdG9wRG93bkFjdGlvbkFyaXR5KHJ1bGVOYW1lKTtcbiAgICBzYi5hcHBlbmQoY29tbW9uLnJlcGVhdCgnXycsIGFyaXR5KS5qb2luKCcsICcpKTtcbiAgICBzYi5hcHBlbmQoJykge1xcbicpO1xuICAgIHNiLmFwcGVuZCgnICB9Jyk7XG4gIH0sXG5cbiAgLy8gUGFyc2UgYSBzdHJpbmcgd2hpY2ggZXhwcmVzc2VzIGEgcnVsZSBhcHBsaWNhdGlvbiBpbiB0aGlzIGdyYW1tYXIsIGFuZCByZXR1cm4gdGhlXG4gIC8vIHJlc3VsdGluZyBBcHBseSBub2RlLlxuICBwYXJzZUFwcGxpY2F0aW9uKHN0cikge1xuICAgIGxldCBhcHA7XG4gICAgaWYgKHN0ci5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAvLyBzaW1wbGUgYXBwbGljYXRpb25cbiAgICAgIGFwcCA9IG5ldyBwZXhwcnMuQXBwbHkoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyYW1ldGVyaXplZCBhcHBsaWNhdGlvblxuICAgICAgY29uc3QgY3N0ID0gb2htR3JhbW1hci5tYXRjaChzdHIsICdCYXNlX2FwcGxpY2F0aW9uJyk7XG4gICAgICBhcHAgPSBidWlsZEdyYW1tYXIoY3N0LCB7fSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIGFwcGxpY2F0aW9uIGlzIHZhbGlkLlxuICAgIGlmICghKGFwcC5ydWxlTmFtZSBpbiB0aGlzLnJ1bGVzKSkge1xuICAgICAgdGhyb3cgZXJyb3JzLnVuZGVjbGFyZWRSdWxlKGFwcC5ydWxlTmFtZSwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybWFscyA9IHRoaXMucnVsZXNbYXBwLnJ1bGVOYW1lXS5mb3JtYWxzO1xuICAgIGlmIChmb3JtYWxzLmxlbmd0aCAhPT0gYXBwLmFyZ3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJ1bGVzW2FwcC5ydWxlTmFtZV0uc291cmNlO1xuICAgICAgdGhyb3cgZXJyb3JzLndyb25nTnVtYmVyT2ZQYXJhbWV0ZXJzKGFwcC5ydWxlTmFtZSwgZm9ybWFscy5sZW5ndGgsIGFwcC5hcmdzLmxlbmd0aCwgc291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbiAgfVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyBncmFtbWFyIGNvbnRhaW5zIGEgZmV3IHJ1bGVzIHRoYXQgY291bGRuJ3QgYmUgd3JpdHRlbiAgaW4gXCJ1c2VybGFuZFwiLlxuLy8gQXQgdGhlIGJvdHRvbSBvZiBzcmMvbWFpbi5qcywgd2UgY3JlYXRlIGEgc3ViLWdyYW1tYXIgb2YgdGhpcyBncmFtbWFyIHRoYXQncyBjYWxsZWRcbi8vIGBCdWlsdEluUnVsZXNgLiBUaGF0IGdyYW1tYXIgY29udGFpbnMgc2V2ZXJhbCBjb252ZW5pZW5jZSBydWxlcywgZS5nLiwgYGxldHRlcmAgYW5kXG4vLyBgZGlnaXRgLCBhbmQgaXMgaW1wbGljaXRseSB0aGUgc3VwZXItZ3JhbW1hciBvZiBhbnkgZ3JhbW1hciB3aG9zZSBzdXBlci1ncmFtbWFyXG4vLyBpc24ndCBzcGVjaWZpZWQuXG5HcmFtbWFyLlByb3RvQnVpbHRJblJ1bGVzID0gbmV3IEdyYW1tYXIoXG4gICAgJ1Byb3RvQnVpbHRJblJ1bGVzJywgLy8gbmFtZVxuICAgIHVuZGVmaW5lZCwgLy8gc3VwZXJncmFtbWFyXG4gICAge1xuICAgICAgYW55OiB7XG4gICAgICAgIGJvZHk6IHBleHBycy5hbnksXG4gICAgICAgIGZvcm1hbHM6IFtdLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2FueSBjaGFyYWN0ZXInLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgYm9keTogcGV4cHJzLmVuZCxcbiAgICAgICAgZm9ybWFsczogW10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnZW5kIG9mIGlucHV0JyxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBjYXNlSW5zZW5zaXRpdmU6IHtcbiAgICAgICAgYm9keTogbmV3IENhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsKG5ldyBwZXhwcnMuUGFyYW0oMCkpLFxuICAgICAgICBmb3JtYWxzOiBbJ3N0ciddLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsb3dlcjoge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlVuaWNvZGVDaGFyKCdMbCcpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhIGxvd2VyY2FzZSBsZXR0ZXInLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cHBlcjoge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlVuaWNvZGVDaGFyKCdMdScpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhbiB1cHBlcmNhc2UgbGV0dGVyJyxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gVW5pb24gb2YgTHQgKHRpdGxlY2FzZSksIExtIChtb2RpZmllciksIGFuZCBMbyAob3RoZXIpLCBpLmUuIGFueSBsZXR0ZXIgbm90IGluIExsIG9yIEx1LlxuICAgICAgdW5pY29kZUx0bW86IHtcbiAgICAgICAgYm9keTogbmV3IHBleHBycy5Vbmljb2RlQ2hhcignTHRtbycpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhIFVuaWNvZGUgY2hhcmFjdGVyIGluIEx0LCBMbSwgb3IgTG8nLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIC8vIFRoZXNlIHJ1bGVzIGFyZSBub3QgdHJ1bHkgcHJpbWl0aXZlICh0aGV5IGNvdWxkIGJlIHdyaXR0ZW4gaW4gdXNlcmxhbmQpIGJ1dCBhcmUgZGVmaW5lZFxuICAgICAgLy8gaGVyZSBmb3IgYm9vdHN0cmFwcGluZyBwdXJwb3Nlcy5cbiAgICAgIHNwYWNlczoge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlN0YXIobmV3IHBleHBycy5BcHBseSgnc3BhY2UnKSksXG4gICAgICAgIGZvcm1hbHM6IFtdXG4gICAgICB9LFxuICAgICAgc3BhY2U6IHtcbiAgICAgICAgYm9keTogbmV3IHBleHBycy5SYW5nZSgnXFx4MDAnLCAnICcpLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhIHNwYWNlJ1xuICAgICAgfVxuICAgIH1cbik7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYW1tYXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBHcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyJyk7XG5jb25zdCBJbnB1dFN0cmVhbSA9IHJlcXVpcmUoJy4vSW5wdXRTdHJlYW0nKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgU3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIENvbnN0cnVjdG9yc1xuXG5mdW5jdGlvbiBHcmFtbWFyRGVjbChuYW1lKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG59XG5cbi8vIEhlbHBlcnNcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLnNvdXJjZUludGVydmFsID0gZnVuY3Rpb24oc3RhcnRJZHgsIGVuZElkeCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2Uuc3ViSW50ZXJ2YWwoc3RhcnRJZHgsIGVuZElkeCAtIHN0YXJ0SWR4KTtcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5lbnN1cmVTdXBlckdyYW1tYXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnN1cGVyR3JhbW1hcikge1xuICAgIHRoaXMud2l0aFN1cGVyR3JhbW1hcihcbiAgICAgICAgLy8gVE9ETzogVGhlIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24gYmVsb3cgaXMgYW4gdWdseSBoYWNrLiBJdCdzIGtpbmQgb2Ygb2sgYmVjYXVzZVxuICAgICAgICAvLyBJIGRvdWJ0IGFueW9uZSB3aWxsIGV2ZXIgdHJ5IHRvIGRlY2xhcmUgYSBncmFtbWFyIGNhbGxlZCBgQnVpbHRJblJ1bGVzYC4gU3RpbGwsXG4gICAgICAgIC8vIHdlIHNob3VsZCB0cnkgdG8gZmluZCBhIGJldHRlciB3YXkgdG8gZG8gdGhpcy5cbiAgICAgICAgdGhpcy5uYW1lID09PSAnQnVpbHRJblJ1bGVzJyA/XG4gICAgICAgICAgICBHcmFtbWFyLlByb3RvQnVpbHRJblJ1bGVzIDpcbiAgICAgICAgICAgIEdyYW1tYXIuQnVpbHRJblJ1bGVzKTtcbiAgfVxuICByZXR1cm4gdGhpcy5zdXBlckdyYW1tYXI7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuZW5zdXJlU3VwZXJHcmFtbWFyUnVsZUZvck92ZXJyaWRpbmcgPSBmdW5jdGlvbihuYW1lLCBzb3VyY2UpIHtcbiAgY29uc3QgcnVsZUluZm8gPSB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hcigpLnJ1bGVzW25hbWVdO1xuICBpZiAoIXJ1bGVJbmZvKSB7XG4gICAgdGhyb3cgZXJyb3JzLmNhbm5vdE92ZXJyaWRlVW5kZWNsYXJlZFJ1bGUobmFtZSwgdGhpcy5zdXBlckdyYW1tYXIubmFtZSwgc291cmNlKTtcbiAgfVxuICByZXR1cm4gcnVsZUluZm87XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuaW5zdGFsbE92ZXJyaWRkZW5PckV4dGVuZGVkUnVsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGJvZHksIHNvdXJjZSkge1xuICBjb25zdCBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyA9IGNvbW1vbi5nZXREdXBsaWNhdGVzKGZvcm1hbHMpO1xuICBpZiAoZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IGVycm9ycy5kdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyhuYW1lLCBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcywgc291cmNlKTtcbiAgfVxuICBjb25zdCBydWxlSW5mbyA9IHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyKCkucnVsZXNbbmFtZV07XG4gIGNvbnN0IGV4cGVjdGVkRm9ybWFscyA9IHJ1bGVJbmZvLmZvcm1hbHM7XG4gIGNvbnN0IGV4cGVjdGVkTnVtRm9ybWFscyA9IGV4cGVjdGVkRm9ybWFscyA/IGV4cGVjdGVkRm9ybWFscy5sZW5ndGggOiAwO1xuICBpZiAoZm9ybWFscy5sZW5ndGggIT09IGV4cGVjdGVkTnVtRm9ybWFscykge1xuICAgIHRocm93IGVycm9ycy53cm9uZ051bWJlck9mUGFyYW1ldGVycyhuYW1lLCBleHBlY3RlZE51bUZvcm1hbHMsIGZvcm1hbHMubGVuZ3RoLCBzb3VyY2UpO1xuICB9XG4gIHJldHVybiB0aGlzLmluc3RhbGwobmFtZSwgZm9ybWFscywgYm9keSwgcnVsZUluZm8uZGVzY3JpcHRpb24sIHNvdXJjZSk7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGJvZHksIGRlc2NyaXB0aW9uLCBzb3VyY2UpIHtcbiAgdGhpcy5ydWxlc1tuYW1lXSA9IHtcbiAgICBib2R5OiBib2R5LmludHJvZHVjZVBhcmFtcyhmb3JtYWxzKSxcbiAgICBmb3JtYWxzLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHNvdXJjZVxuICB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFN0dWZmIHRoYXQgeW91IHNob3VsZCBvbmx5IGRvIG9uY2VcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLndpdGhTdXBlckdyYW1tYXIgPSBmdW5jdGlvbihzdXBlckdyYW1tYXIpIHtcbiAgaWYgKHRoaXMuc3VwZXJHcmFtbWFyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgc3VwZXIgZ3JhbW1hciBvZiBhIEdyYW1tYXJEZWNsIGNhbm5vdCBiZSBzZXQgbW9yZSB0aGFuIG9uY2UnKTtcbiAgfVxuICB0aGlzLnN1cGVyR3JhbW1hciA9IHN1cGVyR3JhbW1hcjtcbiAgdGhpcy5ydWxlcyA9IE9iamVjdC5jcmVhdGUoc3VwZXJHcmFtbWFyLnJ1bGVzKTtcblxuICAvLyBHcmFtbWFycyB3aXRoIGFuIGV4cGxpY2l0IHN1cGVyZ3JhbW1hciBpbmhlcml0IGEgZGVmYXVsdCBzdGFydCBydWxlLlxuICBpZiAoIXN1cGVyR3JhbW1hci5pc0J1aWx0SW4oKSkge1xuICAgIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSA9IHN1cGVyR3JhbW1hci5kZWZhdWx0U3RhcnRSdWxlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLndpdGhEZWZhdWx0U3RhcnRSdWxlID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgdGhpcy5kZWZhdWx0U3RhcnRSdWxlID0gcnVsZU5hbWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLndpdGhTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgdGhpcy5zb3VyY2UgPSBuZXcgSW5wdXRTdHJlYW0oc291cmNlKS5pbnRlcnZhbCgwLCBzb3VyY2UubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBDcmVhdGVzIGEgR3JhbW1hciBpbnN0YW5jZSwgYW5kIGlmIGl0IHBhc3NlcyB0aGUgc2FuaXR5IGNoZWNrcywgcmV0dXJucyBpdC5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBncmFtbWFyID0gbmV3IEdyYW1tYXIoXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hcigpLFxuICAgICAgdGhpcy5ydWxlcyxcbiAgICAgIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSk7XG5cbiAgLy8gVE9ETzogY2hhbmdlIHRoZSBwZXhwci5wcm90b3R5cGUuYXNzZXJ0Li4uIG1ldGhvZHMgdG8gbWFrZSB0aGVtIGFkZFxuICAvLyBleGNlcHRpb25zIHRvIGFuIGFycmF5IHRoYXQncyBwcm92aWRlZCBhcyBhbiBhcmcuIFRoZW4gd2UnbGwgYmUgYWJsZSB0b1xuICAvLyBzaG93IG1vcmUgdGhhbiBvbmUgZXJyb3Igb2YgdGhlIHNhbWUgdHlwZSBhdCBhIHRpbWUuXG4gIC8vIFRPRE86IGluY2x1ZGUgdGhlIG9mZmVuZGluZyBwZXhwciBpbiB0aGUgZXJyb3JzLCB0aGF0IHdheSB3ZSBjYW4gc2hvd1xuICAvLyB0aGUgcGFydCBvZiB0aGUgc291cmNlIHRoYXQgY2F1c2VkIGl0LlxuICBjb25zdCBncmFtbWFyRXJyb3JzID0gW107XG4gIGxldCBncmFtbWFySGFzSW52YWxpZEFwcGxpY2F0aW9ucyA9IGZhbHNlO1xuICBPYmplY3Qua2V5cyhncmFtbWFyLnJ1bGVzKS5mb3JFYWNoKHJ1bGVOYW1lID0+IHtcbiAgICBjb25zdCBib2R5ID0gZ3JhbW1hci5ydWxlc1tydWxlTmFtZV0uYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eShydWxlTmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZ3JhbW1hckVycm9ycy5wdXNoKGUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYm9keS5hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZ3JhbW1hckVycm9ycy5wdXNoKGUpO1xuICAgICAgZ3JhbW1hckhhc0ludmFsaWRBcHBsaWNhdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGlmICghZ3JhbW1hckhhc0ludmFsaWRBcHBsaWNhdGlvbnMpIHtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGNhbiBvbmx5IGJlIGRvbmUgaWYgdGhlIGdyYW1tYXIgaGFzIG5vIGludmFsaWQgYXBwbGljYXRpb25zLlxuICAgIE9iamVjdC5rZXlzKGdyYW1tYXIucnVsZXMpLmZvckVhY2gocnVsZU5hbWUgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IGdyYW1tYXIucnVsZXNbcnVsZU5hbWVdLmJvZHk7XG4gICAgICB0cnkge1xuICAgICAgICBib2R5LmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyLCBbXSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGdyYW1tYXJFcnJvcnMucHVzaChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoZ3JhbW1hckVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgZXJyb3JzLnRocm93RXJyb3JzKGdyYW1tYXJFcnJvcnMpO1xuICB9XG4gIGlmICh0aGlzLnNvdXJjZSkge1xuICAgIGdyYW1tYXIuc291cmNlID0gdGhpcy5zb3VyY2U7XG4gIH1cblxuICByZXR1cm4gZ3JhbW1hcjtcbn07XG5cbi8vIFJ1bGUgZGVjbGFyYXRpb25zXG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbihuYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjcmlwdGlvbiwgc291cmNlKSB7XG4gIHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyKCk7XG4gIGlmICh0aGlzLnN1cGVyR3JhbW1hci5ydWxlc1tuYW1lXSkge1xuICAgIHRocm93IGVycm9ycy5kdXBsaWNhdGVSdWxlRGVjbGFyYXRpb24obmFtZSwgdGhpcy5uYW1lLCB0aGlzLnN1cGVyR3JhbW1hci5uYW1lLCBzb3VyY2UpO1xuICB9IGVsc2UgaWYgKHRoaXMucnVsZXNbbmFtZV0pIHtcbiAgICB0aHJvdyBlcnJvcnMuZHVwbGljYXRlUnVsZURlY2xhcmF0aW9uKG5hbWUsIHRoaXMubmFtZSwgdGhpcy5uYW1lLCBzb3VyY2UpO1xuICB9XG4gIGNvbnN0IGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzID0gY29tbW9uLmdldER1cGxpY2F0ZXMoZm9ybWFscyk7XG4gIGlmIChkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgZXJyb3JzLmR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzKG5hbWUsIGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzLCBzb3VyY2UpO1xuICB9XG4gIHJldHVybiB0aGlzLmluc3RhbGwobmFtZSwgZm9ybWFscywgYm9keSwgZGVzY3JpcHRpb24sIHNvdXJjZSk7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbihuYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjSWdub3JlZCwgc291cmNlKSB7XG4gIHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyUnVsZUZvck92ZXJyaWRpbmcobmFtZSwgc291cmNlKTtcbiAgdGhpcy5pbnN0YWxsT3ZlcnJpZGRlbk9yRXh0ZW5kZWRSdWxlKG5hbWUsIGZvcm1hbHMsIGJvZHksIHNvdXJjZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGZyYWdtZW50LCBkZXNjSWdub3JlZCwgc291cmNlKSB7XG4gIGNvbnN0IHJ1bGVJbmZvID0gdGhpcy5lbnN1cmVTdXBlckdyYW1tYXIoKS5ydWxlc1tuYW1lXTtcbiAgaWYgKCFydWxlSW5mbykge1xuICAgIHRocm93IGVycm9ycy5jYW5ub3RFeHRlbmRVbmRlY2xhcmVkUnVsZShuYW1lLCB0aGlzLnN1cGVyR3JhbW1hci5uYW1lLCBzb3VyY2UpO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBuZXcgcGV4cHJzLkV4dGVuZCh0aGlzLnN1cGVyR3JhbW1hciwgbmFtZSwgZnJhZ21lbnQpO1xuICBib2R5LnNvdXJjZSA9IGZyYWdtZW50LnNvdXJjZTtcbiAgdGhpcy5pbnN0YWxsT3ZlcnJpZGRlbk9yRXh0ZW5kZWRSdWxlKG5hbWUsIGZvcm1hbHMsIGJvZHksIHNvdXJjZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gR3JhbW1hckRlY2w7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWwnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIElucHV0U3RyZWFtKHNvdXJjZSkge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLmV4YW1pbmVkTGVuZ3RoID0gMDtcbn1cblxuSW5wdXRTdHJlYW0ucHJvdG90eXBlID0ge1xuICBhdEVuZCgpIHtcbiAgICBjb25zdCBhbnMgPSB0aGlzLnBvcyA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuZXhhbWluZWRMZW5ndGggPSBNYXRoLm1heCh0aGlzLmV4YW1pbmVkTGVuZ3RoLCB0aGlzLnBvcyArIDEpO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgbmV4dCgpIHtcbiAgICBjb25zdCBhbnMgPSB0aGlzLnNvdXJjZVt0aGlzLnBvcysrXTtcbiAgICB0aGlzLmV4YW1pbmVkTGVuZ3RoID0gTWF0aC5tYXgodGhpcy5leGFtaW5lZExlbmd0aCwgdGhpcy5wb3MpO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgbWF0Y2hTdHJpbmcocywgb3B0SWdub3JlQ2FzZSkge1xuICAgIGxldCBpZHg7XG4gICAgaWYgKG9wdElnbm9yZUNhc2UpIHtcbiAgICAgIC8qXG4gICAgICAgIENhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvbiBpcyBhIHRyaWNreSBidXNpbmVzcy4gU29tZSBub3RhYmxlIGdvdGNoYXMgaW5jbHVkZSB0aGVcbiAgICAgICAgXCJUdXJraXNoIElcIiBwcm9ibGVtIChodHRwOi8vd3d3LmkxOG5ndXkuY29tL3VuaWNvZGUvdHVya2lzaC1pMThuLmh0bWwpIGFuZCB0aGUgZmFjdFxuICAgICAgICB0aGF0IHRoZSBHZXJtYW4gRXNzemV0ICjDnykgdHVybnMgaW50byBcIlNTXCIgaW4gdXBwZXIgY2FzZS5cblxuICAgICAgICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgbG9jYWxlLWludmFyaWFudCBjb21wYXJpc29uLCB3aGljaCBtZWFucyBpdCBtYXkgbm90IG9iZXlcbiAgICAgICAgbG9jYWxlLXNwZWNpZmljIGV4cGVjdGF0aW9ucyAoZS5nLiBcImlcIiA9PiBcIsSwXCIpLlxuICAgICAgICovXG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBhY3R1YWwgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBzW2lkeF07XG4gICAgICAgIGlmIChhY3R1YWwgPT0gbnVsbCB8fCBhY3R1YWwudG9VcHBlckNhc2UoKSAhPT0gZXhwZWN0ZWQudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgaXMgY2FzZS1zZW5zaXRpdmUgY29tcGFyaXNvbi5cbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKHRoaXMubmV4dCgpICE9PSBzW2lkeF0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNvdXJjZVNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gIH0sXG5cbiAgaW50ZXJ2YWwoc3RhcnRJZHgsIG9wdEVuZElkeCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2UsIHN0YXJ0SWR4LCBvcHRFbmRJZHggPyBvcHRFbmRJZHggOiB0aGlzLnBvcyk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0U3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jb21tb24nKS5hc3NlcnQ7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gSW50ZXJ2YWwoc291cmNlU3RyaW5nLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gIHRoaXMuc291cmNlU3RyaW5nID0gc291cmNlU3RyaW5nO1xuICB0aGlzLnN0YXJ0SWR4ID0gc3RhcnRJZHg7XG4gIHRoaXMuZW5kSWR4ID0gZW5kSWR4O1xufVxuXG5JbnRlcnZhbC5jb3ZlcmFnZSA9IGZ1bmN0aW9uKC8qIGludGVydmFsMSwgaW50ZXJ2YWwyLCAuLi4gKi8pIHtcbiAgY29uc3Qgc291cmNlU3RyaW5nID0gYXJndW1lbnRzWzBdLnNvdXJjZVN0cmluZztcbiAgbGV0IHN0YXJ0SWR4ID0gYXJndW1lbnRzWzBdLnN0YXJ0SWR4O1xuICBsZXQgZW5kSWR4ID0gYXJndW1lbnRzWzBdLmVuZElkeDtcbiAgZm9yIChsZXQgaWR4ID0gMTsgaWR4IDwgYXJndW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IGFyZ3VtZW50c1tpZHhdO1xuICAgIGlmIChpbnRlcnZhbC5zb3VyY2VTdHJpbmcgIT09IHNvdXJjZVN0cmluZykge1xuICAgICAgdGhyb3cgZXJyb3JzLmludGVydmFsU291cmNlc0RvbnRNYXRjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydElkeCA9IE1hdGgubWluKHN0YXJ0SWR4LCBhcmd1bWVudHNbaWR4XS5zdGFydElkeCk7XG4gICAgICBlbmRJZHggPSBNYXRoLm1heChlbmRJZHgsIGFyZ3VtZW50c1tpZHhdLmVuZElkeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgSW50ZXJ2YWwoc291cmNlU3RyaW5nLCBzdGFydElkeCwgZW5kSWR4KTtcbn07XG5cbkludGVydmFsLnByb3RvdHlwZSA9IHtcbiAgY292ZXJhZ2VXaXRoKC8qIGludGVydmFsMSwgaW50ZXJ2YWwyLCAuLi4gKi8pIHtcbiAgICBjb25zdCBpbnRlcnZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGludGVydmFscy5wdXNoKHRoaXMpO1xuICAgIHJldHVybiBJbnRlcnZhbC5jb3ZlcmFnZS5hcHBseSh1bmRlZmluZWQsIGludGVydmFscyk7XG4gIH0sXG5cbiAgY29sbGFwc2VkTGVmdCgpIHtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLnN0YXJ0SWR4LCB0aGlzLnN0YXJ0SWR4KTtcbiAgfSxcblxuICBjb2xsYXBzZWRSaWdodCgpIHtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLmVuZElkeCwgdGhpcy5lbmRJZHgpO1xuICB9LFxuXG4gIGdldExpbmVBbmRDb2x1bW4oKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0TGluZUFuZENvbHVtbih0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCk7XG4gIH0sXG5cbiAgZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBbdGhpcy5zdGFydElkeCwgdGhpcy5lbmRJZHhdO1xuICAgIHJldHVybiB1dGlsLmdldExpbmVBbmRDb2x1bW5NZXNzYWdlKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLnN0YXJ0SWR4LCByYW5nZSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiAwLCAxLCBvciAyIGludGVydmFscyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiB0aGVcbiAgLy8gaW50ZXJ2YWwgZGlmZmVyZW5jZSBvcGVyYXRpb24uXG4gIG1pbnVzKHRoYXQpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VTdHJpbmcgIT09IHRoYXQuc291cmNlU3RyaW5nKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW50ZXJ2YWxTb3VyY2VzRG9udE1hdGNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0SWR4ID09PSB0aGF0LnN0YXJ0SWR4ICYmIHRoaXMuZW5kSWR4ID09PSB0aGF0LmVuZElkeCkge1xuICAgICAgLy8gYHRoaXNgIGFuZCBgdGhhdGAgYXJlIHRoZSBzYW1lIGludGVydmFsIVxuICAgICAgcmV0dXJuIFtcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0SWR4IDwgdGhhdC5zdGFydElkeCAmJiB0aGF0LmVuZElkeCA8IHRoaXMuZW5kSWR4KSB7XG4gICAgICAvLyBgdGhhdGAgc3BsaXRzIGB0aGlzYCBpbnRvIHR3byBpbnRlcnZhbHNcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCwgdGhhdC5zdGFydElkeCksXG4gICAgICAgIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhhdC5lbmRJZHgsIHRoaXMuZW5kSWR4KVxuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRJZHggPCB0aGF0LmVuZElkeCAmJiB0aGF0LmVuZElkeCA8IHRoaXMuZW5kSWR4KSB7XG4gICAgICAvLyBgdGhhdGAgY29udGFpbnMgYSBwcmVmaXggb2YgYHRoaXNgXG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHRoYXQuZW5kSWR4LCB0aGlzLmVuZElkeClcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0SWR4IDwgdGhhdC5zdGFydElkeCAmJiB0aGF0LnN0YXJ0SWR4IDwgdGhpcy5lbmRJZHgpIHtcbiAgICAgIC8vIGB0aGF0YCBjb250YWlucyBhIHN1ZmZpeCBvZiBgdGhpc2BcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCwgdGhhdC5zdGFydElkeClcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGB0aGF0YCBhbmQgYHRoaXNgIGRvIG5vdCBvdmVybGFwXG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzXG4gICAgICBdO1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgbmV3IEludGVydmFsIHRoYXQgaGFzIHRoZSBzYW1lIGV4dGVudCBhcyB0aGlzIG9uZSwgYnV0IHdoaWNoIGlzIHJlbGF0aXZlXG4gIC8vIHRvIGB0aGF0YCwgYW4gSW50ZXJ2YWwgdGhhdCBmdWxseSBjb3ZlcnMgdGhpcyBvbmUuXG4gIHJlbGF0aXZlVG8odGhhdCkge1xuICAgIGlmICh0aGlzLnNvdXJjZVN0cmluZyAhPT0gdGhhdC5zb3VyY2VTdHJpbmcpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbnRlcnZhbFNvdXJjZXNEb250TWF0Y2goKTtcbiAgICB9XG4gICAgYXNzZXJ0KHRoaXMuc3RhcnRJZHggPj0gdGhhdC5zdGFydElkeCAmJiB0aGlzLmVuZElkeCA8PSB0aGF0LmVuZElkeCxcbiAgICAgICAgJ290aGVyIGludGVydmFsIGRvZXMgbm90IGNvdmVyIHRoaXMgb25lJyk7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZyxcbiAgICAgICAgdGhpcy5zdGFydElkeCAtIHRoYXQuc3RhcnRJZHgsXG4gICAgICAgIHRoaXMuZW5kSWR4IC0gdGhhdC5zdGFydElkeCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIG5ldyBJbnRlcnZhbCB3aGljaCBjb250YWlucyB0aGUgc2FtZSBjb250ZW50cyBhcyB0aGlzIG9uZSxcbiAgLy8gYnV0IHdpdGggd2hpdGVzcGFjZSB0cmltbWVkIGZyb20gYm90aCBlbmRzLiAoVGhpcyBvbmx5IG1ha2VzIHNlbnNlIHdoZW5cbiAgLy8gdGhlIGlucHV0IHN0cmVhbSBpcyBhIHN0cmluZy4pXG4gIHRyaW1tZWQoKSB7XG4gICAgY29uc3QgY29udGVudHMgPSB0aGlzLmNvbnRlbnRzO1xuICAgIGNvbnN0IHN0YXJ0SWR4ID0gdGhpcy5zdGFydElkeCArIGNvbnRlbnRzLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBjb25zdCBlbmRJZHggPSB0aGlzLmVuZElkeCAtIGNvbnRlbnRzLm1hdGNoKC9cXHMqJC8pWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCBzdGFydElkeCwgZW5kSWR4KTtcbiAgfSxcblxuICBzdWJJbnRlcnZhbChvZmZzZXQsIGxlbikge1xuICAgIGNvbnN0IG5ld1N0YXJ0SWR4ID0gdGhpcy5zdGFydElkeCArIG9mZnNldDtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCBuZXdTdGFydElkeCwgbmV3U3RhcnRJZHggKyBsZW4pO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbnRlcnZhbC5wcm90b3R5cGUsIHtcbiAgY29udGVudHM6IHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fY29udGVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9jb250ZW50cyA9IHRoaXMuc291cmNlU3RyaW5nLnNsaWNlKHRoaXMuc3RhcnRJZHgsIHRoaXMuZW5kSWR4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50cztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgbGVuZ3RoOiB7XG4gICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5lbmRJZHggLSB0aGlzLnN0YXJ0SWR4OyB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfVxufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVydmFsO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBNYXRjaFJlc3VsdChcbiAgICBtYXRjaGVyLFxuICAgIGlucHV0LFxuICAgIHN0YXJ0RXhwcixcbiAgICBjc3QsXG4gICAgY3N0T2Zmc2V0LFxuICAgIHJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbixcbiAgICBvcHRSZWNvcmRlZEZhaWx1cmVzKSB7XG5cbiAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB0aGlzLnN0YXJ0RXhwciA9IHN0YXJ0RXhwcjtcbiAgdGhpcy5fY3N0ID0gY3N0O1xuICB0aGlzLl9jc3RPZmZzZXQgPSBjc3RPZmZzZXQ7XG4gIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IHJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbjtcbiAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZXMgPSBvcHRSZWNvcmRlZEZhaWx1cmVzO1xuXG4gIGlmICh0aGlzLmZhaWxlZCgpKSB7XG4gICAgY29tbW9uLmRlZmluZUxhenlQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGV0YWlsID0gJ0V4cGVjdGVkICcgKyB0aGlzLmdldEV4cGVjdGVkVGV4dCgpO1xuICAgICAgcmV0dXJuIHV0aWwuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UodGhpcy5pbnB1dCwgdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSkgKyBkZXRhaWw7XG4gICAgfSk7XG4gICAgY29tbW9uLmRlZmluZUxhenlQcm9wZXJ0eSh0aGlzLCAnc2hvcnRNZXNzYWdlJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBkZXRhaWwgPSAnZXhwZWN0ZWQgJyArIHRoaXMuZ2V0RXhwZWN0ZWRUZXh0KCk7XG4gICAgICBjb25zdCBlcnJvckluZm8gPSB1dGlsLmdldExpbmVBbmRDb2x1bW4odGhpcy5pbnB1dCwgdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSk7XG4gICAgICByZXR1cm4gJ0xpbmUgJyArIGVycm9ySW5mby5saW5lTnVtICsgJywgY29sICcgKyBlcnJvckluZm8uY29sTnVtICsgJzogJyArIGRldGFpbDtcbiAgICB9KTtcbiAgfVxufVxuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuc3VjY2VlZGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuX2NzdDtcbn07XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS5mYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnN1Y2NlZWRlZCgpO1xufTtcblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uO1xufTtcblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmdldFJpZ2h0bW9zdEZhaWx1cmVzID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmlnaHRtb3N0RmFpbHVyZXMpIHtcbiAgICB0aGlzLm1hdGNoZXIuc2V0SW5wdXQodGhpcy5pbnB1dCk7XG4gICAgY29uc3QgbWF0Y2hSZXN1bHRXaXRoRmFpbHVyZXMgPVxuICAgICAgICB0aGlzLm1hdGNoZXIuX21hdGNoKHRoaXMuc3RhcnRFeHByLCBmYWxzZSwgdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSk7XG4gICAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZXMgPSBtYXRjaFJlc3VsdFdpdGhGYWlsdXJlcy5nZXRSaWdodG1vc3RGYWlsdXJlcygpO1xuICB9XG4gIHJldHVybiB0aGlzLl9yaWdodG1vc3RGYWlsdXJlcztcbn07XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zdWNjZWVkZWQoKSA/XG4gICAgICAnW21hdGNoIHN1Y2NlZWRlZF0nIDpcbiAgICAgICdbbWF0Y2ggZmFpbGVkIGF0IHBvc2l0aW9uICcgKyB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpICsgJ10nO1xufTtcblxuLy8gUmV0dXJuIGEgc3RyaW5nIHN1bW1hcml6aW5nIHRoZSBleHBlY3RlZCBjb250ZW50cyBvZiB0aGUgaW5wdXQgc3RyZWFtIHdoZW5cbi8vIHRoZSBtYXRjaCBmYWlsdXJlIG9jY3VycmVkLlxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmdldEV4cGVjdGVkVGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdWNjZWVkZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBleHBlY3RlZCB0ZXh0IG9mIGEgc3VjY2Vzc2Z1bCBNYXRjaFJlc3VsdCcpO1xuICB9XG5cbiAgY29uc3Qgc2IgPSBuZXcgY29tbW9uLlN0cmluZ0J1ZmZlcigpO1xuICBsZXQgZmFpbHVyZXMgPSB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVzKCk7XG5cbiAgLy8gRmlsdGVyIG91dCB0aGUgZmx1ZmZ5IGZhaWx1cmVzIHRvIG1ha2UgdGhlIGRlZmF1bHQgZXJyb3IgbWVzc2FnZXMgbW9yZSB1c2VmdWxcbiAgZmFpbHVyZXMgPSBmYWlsdXJlcy5maWx0ZXIoZmFpbHVyZSA9PiAhZmFpbHVyZS5pc0ZsdWZmeSgpKTtcblxuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBmYWlsdXJlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgaWYgKGlkeCA+IDApIHtcbiAgICAgIGlmIChpZHggPT09IGZhaWx1cmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc2IuYXBwZW5kKGZhaWx1cmVzLmxlbmd0aCA+IDIgPyAnLCBvciAnIDogJyBvciAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNiLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2IuYXBwZW5kKGZhaWx1cmVzW2lkeF0udG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIHNiLmNvbnRlbnRzKCk7XG59O1xuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcG9zID0gdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKTtcbiAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLmlucHV0LCBwb3MsIHBvcyk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaFJlc3VsdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IElucHV0U3RyZWFtID0gcmVxdWlyZSgnLi9JbnB1dFN0cmVhbScpO1xuY29uc3QgTWF0Y2hSZXN1bHQgPSByZXF1aXJlKCcuL01hdGNoUmVzdWx0Jyk7XG5jb25zdCBQb3NJbmZvID0gcmVxdWlyZSgnLi9Qb3NJbmZvJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vVHJhY2UnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhcHBseVNwYWNlcyA9IG5ldyBwZXhwcnMuQXBwbHkoJ3NwYWNlcycpO1xuXG5mdW5jdGlvbiBNYXRjaFN0YXRlKG1hdGNoZXIsIHN0YXJ0RXhwciwgb3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gIHRoaXMuc3RhcnRFeHByID0gc3RhcnRFeHByO1xuXG4gIHRoaXMuZ3JhbW1hciA9IG1hdGNoZXIuZ3JhbW1hcjtcbiAgdGhpcy5pbnB1dCA9IG1hdGNoZXIuaW5wdXQ7XG4gIHRoaXMuaW5wdXRTdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0obWF0Y2hlci5pbnB1dCk7XG4gIHRoaXMubWVtb1RhYmxlID0gbWF0Y2hlci5tZW1vVGFibGU7XG5cbiAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgdGhpcy5fYmluZGluZ09mZnNldHMgPSBbXTtcbiAgdGhpcy5fYXBwbGljYXRpb25TdGFjayA9IFtdO1xuICB0aGlzLl9wb3NTdGFjayA9IFswXTtcbiAgdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrID0gW2ZhbHNlXTtcblxuICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IC0xO1xuICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb25TdGFjayA9IFtdO1xuICB0aGlzLl9yZWNvcmRlZEZhaWx1cmVzU3RhY2sgPSBbXTtcblxuICBpZiAob3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcyA9IG9wdFBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcztcbiAgICB0aGlzLnJlY29yZGVkRmFpbHVyZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG59XG5cbk1hdGNoU3RhdGUucHJvdG90eXBlID0ge1xuICBwb3NUb09mZnNldChwb3MpIHtcbiAgICByZXR1cm4gcG9zIC0gdGhpcy5fcG9zU3RhY2tbdGhpcy5fcG9zU3RhY2subGVuZ3RoIC0gMV07XG4gIH0sXG5cbiAgZW50ZXJBcHBsaWNhdGlvbihwb3NJbmZvLCBhcHApIHtcbiAgICB0aGlzLl9wb3NTdGFjay5wdXNoKHRoaXMuaW5wdXRTdHJlYW0ucG9zKTtcbiAgICB0aGlzLl9hcHBsaWNhdGlvblN0YWNrLnB1c2goYXBwKTtcbiAgICB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2sucHVzaChmYWxzZSk7XG4gICAgcG9zSW5mby5lbnRlcihhcHApO1xuICAgIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvblN0YWNrLnB1c2godGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24pO1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gLTE7XG4gIH0sXG5cbiAgZXhpdEFwcGxpY2F0aW9uKHBvc0luZm8sIG9wdE5vZGUpIHtcbiAgICBjb25zdCBvcmlnUG9zID0gdGhpcy5fcG9zU3RhY2sucG9wKCk7XG4gICAgdGhpcy5fYXBwbGljYXRpb25TdGFjay5wb3AoKTtcbiAgICB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2sucG9wKCk7XG4gICAgcG9zSW5mby5leGl0KCk7XG5cbiAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IE1hdGgubWF4KFxuICAgICAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbixcbiAgICAgICAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uU3RhY2sucG9wKCkpO1xuXG4gICAgaWYgKG9wdE5vZGUpIHtcbiAgICAgIHRoaXMucHVzaEJpbmRpbmcob3B0Tm9kZSwgb3JpZ1Bvcyk7XG4gICAgfVxuICB9LFxuXG4gIGVudGVyTGV4aWZpZWRDb250ZXh0KCkge1xuICAgIHRoaXMuaW5MZXhpZmllZENvbnRleHRTdGFjay5wdXNoKHRydWUpO1xuICB9LFxuXG4gIGV4aXRMZXhpZmllZENvbnRleHQoKSB7XG4gICAgdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrLnBvcCgpO1xuICB9LFxuXG4gIGN1cnJlbnRBcHBsaWNhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25TdGFja1t0aGlzLl9hcHBsaWNhdGlvblN0YWNrLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIGluU3ludGFjdGljQ29udGV4dCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuaW5wdXRTdHJlYW0uc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50QXBwbGljYXRpb24gPSB0aGlzLmN1cnJlbnRBcHBsaWNhdGlvbigpO1xuICAgIGlmIChjdXJyZW50QXBwbGljYXRpb24pIHtcbiAgICAgIHJldHVybiBjdXJyZW50QXBwbGljYXRpb24uaXNTeW50YWN0aWMoKSAmJiAhdGhpcy5pbkxleGlmaWVkQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgdG9wLWxldmVsIGNvbnRleHQgaXMgc3ludGFjdGljIGlmIHRoZSBzdGFydCBhcHBsaWNhdGlvbiBpcy5cbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0RXhwci5mYWN0b3JzWzBdLmlzU3ludGFjdGljKCk7XG4gICAgfVxuICB9LFxuXG4gIGluTGV4aWZpZWRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2tbdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIHNraXBTcGFjZXMoKSB7XG4gICAgdGhpcy5wdXNoRmFpbHVyZXNJbmZvKCk7XG4gICAgdGhpcy5ldmFsKGFwcGx5U3BhY2VzKTtcbiAgICB0aGlzLnBvcEJpbmRpbmcoKTtcbiAgICB0aGlzLnBvcEZhaWx1cmVzSW5mbygpO1xuICAgIHJldHVybiB0aGlzLmlucHV0U3RyZWFtLnBvcztcbiAgfSxcblxuICBza2lwU3BhY2VzSWZJblN5bnRhY3RpY0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5TeW50YWN0aWNDb250ZXh0KCkgP1xuICAgICAgICB0aGlzLnNraXBTcGFjZXMoKSA6XG4gICAgICAgIHRoaXMuaW5wdXRTdHJlYW0ucG9zO1xuICB9LFxuXG4gIG1heWJlU2tpcFNwYWNlc0JlZm9yZShleHByKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuQXBwbHkgJiYgZXhwci5pc1N5bnRhY3RpYygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5za2lwU3BhY2VzKCk7XG4gICAgfSBlbHNlIGlmIChleHByLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UoKSAmJiBleHByICE9PSBhcHBseVNwYWNlcykge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcFNwYWNlc0lmSW5TeW50YWN0aWNDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0U3RyZWFtLnBvcztcbiAgICB9XG4gIH0sXG5cbiAgcHVzaEJpbmRpbmcobm9kZSwgb3JpZ1Bvcykge1xuICAgIHRoaXMuX2JpbmRpbmdzLnB1c2gobm9kZSk7XG4gICAgdGhpcy5fYmluZGluZ09mZnNldHMucHVzaCh0aGlzLnBvc1RvT2Zmc2V0KG9yaWdQb3MpKTtcbiAgfSxcblxuICBwb3BCaW5kaW5nKCkge1xuICAgIHRoaXMuX2JpbmRpbmdzLnBvcCgpO1xuICAgIHRoaXMuX2JpbmRpbmdPZmZzZXRzLnBvcCgpO1xuICB9LFxuXG4gIG51bUJpbmRpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gIH0sXG5cbiAgdHJ1bmNhdGVCaW5kaW5ncyhuZXdMZW5ndGgpIHtcbiAgICAvLyBZZXMsIHRoaXMgaXMgdGhpcyByZWFsbHkgZmFzdGVyIHRoYW4gc2V0dGluZyB0aGUgYGxlbmd0aGAgcHJvcGVydHkgKHRlc3RlZCB3aXRoXG4gICAgLy8gYmluL2VzNWJlbmNoIG9uIE5vZGUgdjYuMS4wKS5cbiAgICB3aGlsZSAodGhpcy5fYmluZGluZ3MubGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB0aGlzLnBvcEJpbmRpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Q3VycmVudFBvc0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9zSW5mbyh0aGlzLmlucHV0U3RyZWFtLnBvcyk7XG4gIH0sXG5cbiAgZ2V0UG9zSW5mbyhwb3MpIHtcbiAgICBsZXQgcG9zSW5mbyA9IHRoaXMubWVtb1RhYmxlW3Bvc107XG4gICAgaWYgKCFwb3NJbmZvKSB7XG4gICAgICBwb3NJbmZvID0gdGhpcy5tZW1vVGFibGVbcG9zXSA9IG5ldyBQb3NJbmZvKCk7XG4gICAgfVxuICAgIHJldHVybiBwb3NJbmZvO1xuICB9LFxuXG4gIHByb2Nlc3NGYWlsdXJlKHBvcywgZXhwcikge1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gTWF0aC5tYXgodGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sIHBvcyk7XG5cbiAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzICYmIHBvcyA9PT0gdGhpcy5wb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY3VycmVudEFwcGxpY2F0aW9uKCk7XG4gICAgICBpZiAoYXBwKSB7XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgcGFyYW1ldGVycyB3aXRoIHRoZSBhY3R1YWwgcGV4cHJzIHRoYXQgd2VyZSBwYXNzZWQgdG9cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgcnVsZS5cbiAgICAgICAgZXhwciA9IGV4cHIuc3Vic3RpdHV0ZVBhcmFtcyhhcHAuYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGJyYW5jaCBpcyBvbmx5IHJlYWNoZWQgZm9yIHRoZSBcImVuZC1jaGVja1wiIHRoYXQgaXNcbiAgICAgICAgLy8gcGVyZm9ybWVkIGFmdGVyIHRoZSB0b3AtbGV2ZWwgYXBwbGljYXRpb24uIEluIHRoYXQgY2FzZSxcbiAgICAgICAgLy8gZXhwciA9PT0gcGV4cHJzLmVuZCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHN1YnN0aXR1dGVcbiAgICAgICAgLy8gcGFyYW1ldGVycy5cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNvcmRGYWlsdXJlKGV4cHIudG9GYWlsdXJlKHRoaXMuZ3JhbW1hciksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVjb3JkRmFpbHVyZShmYWlsdXJlLCBzaG91bGRDbG9uZUlmTmV3KSB7XG4gICAgY29uc3Qga2V5ID0gZmFpbHVyZS50b0tleSgpO1xuICAgIGlmICghdGhpcy5yZWNvcmRlZEZhaWx1cmVzW2tleV0pIHtcbiAgICAgIHRoaXMucmVjb3JkZWRGYWlsdXJlc1trZXldID0gc2hvdWxkQ2xvbmVJZk5ldyA/IGZhaWx1cmUuY2xvbmUoKSA6IGZhaWx1cmU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXNba2V5XS5pc0ZsdWZmeSgpICYmICFmYWlsdXJlLmlzRmx1ZmZ5KCkpIHtcbiAgICAgIHRoaXMucmVjb3JkZWRGYWlsdXJlc1trZXldLmNsZWFyRmx1ZmZ5KCk7XG4gICAgfVxuICB9LFxuXG4gIHJlY29yZEZhaWx1cmVzKGZhaWx1cmVzLCBzaG91bGRDbG9uZUlmTmV3KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoZmFpbHVyZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHNlbGYucmVjb3JkRmFpbHVyZShmYWlsdXJlc1trZXldLCBzaG91bGRDbG9uZUlmTmV3KTtcbiAgICB9KTtcbiAgfSxcblxuICBjbG9uZVJlY29yZGVkRmFpbHVyZXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlY29yZGVkRmFpbHVyZXMpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgYW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLnJlY29yZGVkRmFpbHVyZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGFuc1trZXldID0gc2VsZi5yZWNvcmRlZEZhaWx1cmVzW2tleV0uY2xvbmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIGdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb247XG4gIH0sXG5cbiAgX2dldFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID49IDAgP1xuICAgICAgICB0aGlzLnBvc1RvT2Zmc2V0KHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKSA6XG4gICAgICAgIC0xO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIG1lbW9pemVkIHRyYWNlIGVudHJ5IGZvciBgZXhwcmAgYXQgYHBvc2AsIGlmIG9uZSBleGlzdHMsIGBudWxsYCBvdGhlcndpc2UuXG4gIGdldE1lbW9pemVkVHJhY2VFbnRyeShwb3MsIGV4cHIpIHtcbiAgICBjb25zdCBwb3NJbmZvID0gdGhpcy5tZW1vVGFibGVbcG9zXTtcbiAgICBpZiAocG9zSW5mbyAmJiBleHByLnJ1bGVOYW1lKSB7XG4gICAgICBjb25zdCBtZW1vUmVjID0gcG9zSW5mby5tZW1vW2V4cHIudG9NZW1vS2V5KCldO1xuICAgICAgaWYgKG1lbW9SZWMgJiYgbWVtb1JlYy50cmFjZUVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbWVtb1JlYy50cmFjZUVudHJ5LmNsb25lV2l0aEV4cHIoZXhwcik7XG4gICAgICAgIGVudHJ5LmlzTWVtb2l6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBuZXcgdHJhY2UgZW50cnksIHdpdGggdGhlIGN1cnJlbnRseSBhY3RpdmUgdHJhY2UgYXJyYXkgYXMgaXRzIGNoaWxkcmVuLlxuICBnZXRUcmFjZUVudHJ5KHBvcywgZXhwciwgc3VjY2VlZGVkLCBiaW5kaW5ncykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgcGV4cHJzLkFwcGx5KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzLmN1cnJlbnRBcHBsaWNhdGlvbigpO1xuICAgICAgY29uc3QgYWN0dWFscyA9IGFwcCA/IGFwcC5hcmdzIDogW107XG4gICAgICBleHByID0gZXhwci5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRNZW1vaXplZFRyYWNlRW50cnkocG9zLCBleHByKSB8fFxuICAgICAgICAgICBuZXcgVHJhY2UodGhpcy5pbnB1dCwgcG9zLCB0aGlzLmlucHV0U3RyZWFtLnBvcywgZXhwciwgc3VjY2VlZGVkLCBiaW5kaW5ncywgdGhpcy50cmFjZSk7XG4gIH0sXG5cbiAgaXNUcmFjaW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMudHJhY2U7XG4gIH0sXG5cbiAgaGFzTmVjZXNzYXJ5SW5mbyhtZW1vUmVjKSB7XG4gICAgaWYgKHRoaXMudHJhY2UgJiYgIW1lbW9SZWMudHJhY2VFbnRyeSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMgJiZcbiAgICAgICAgdGhpcy5pbnB1dFN0cmVhbS5wb3MgKyBtZW1vUmVjLnJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPT09IHRoaXMucG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gICAgICByZXR1cm4gISFtZW1vUmVjLmZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuXG4gIHVzZU1lbW9pemVkUmVzdWx0KG9yaWdQb3MsIG1lbW9SZWMpIHtcbiAgICBpZiAodGhpcy50cmFjZSkge1xuICAgICAgdGhpcy50cmFjZS5wdXNoKG1lbW9SZWMudHJhY2VFbnRyeSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVtb1JlY1JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IHRoaXMuaW5wdXRTdHJlYW0ucG9zICsgbWVtb1JlYy5yaWdodG1vc3RGYWlsdXJlT2Zmc2V0O1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID1cbiAgICAgICAgTWF0aC5tYXgodGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sIG1lbW9SZWNSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24pO1xuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMgJiZcbiAgICAgICAgdGhpcy5wb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMgPT09IG1lbW9SZWNSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gJiZcbiAgICAgICAgbWVtb1JlYy5mYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb24pIHtcbiAgICAgIHRoaXMucmVjb3JkRmFpbHVyZXMobWVtb1JlYy5mYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb24sIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGggPVxuICAgICAgICBNYXRoLm1heCh0aGlzLmlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoLCBtZW1vUmVjLmV4YW1pbmVkTGVuZ3RoICsgb3JpZ1Bvcyk7XG5cbiAgICBpZiAobWVtb1JlYy52YWx1ZSkge1xuICAgICAgdGhpcy5pbnB1dFN0cmVhbS5wb3MgKz0gbWVtb1JlYy5tYXRjaExlbmd0aDtcbiAgICAgIHRoaXMucHVzaEJpbmRpbmcobWVtb1JlYy52YWx1ZSwgb3JpZ1Bvcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8vIEV2YWx1YXRlIGBleHByYCBhbmQgcmV0dXJuIGB0cnVlYCBpZiBpdCBzdWNjZWVkZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBPbiBzdWNjZXNzLCBgYmluZGluZ3NgXG4gIC8vIHdpbGwgaGF2ZSBgZXhwci5nZXRBcml0eSgpYCBtb3JlIGVsZW1lbnRzIHRoYW4gYmVmb3JlLCBhbmQgdGhlIGlucHV0IHN0cmVhbSdzIHBvc2l0aW9uIG1heVxuICAvLyBoYXZlIGluY3JlYXNlZC4gT24gZmFpbHVyZSwgYGJpbmRpbmdzYCBhbmQgcG9zaXRpb24gd2lsbCBiZSB1bmNoYW5nZWQuXG4gIGV2YWwoZXhwcikge1xuICAgIGNvbnN0IGlucHV0U3RyZWFtID0gdGhpcy5pbnB1dFN0cmVhbTtcbiAgICBjb25zdCBvcmlnTnVtQmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG5cbiAgICBsZXQgb3JpZ1JlY29yZGVkRmFpbHVyZXM7XG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcykge1xuICAgICAgb3JpZ1JlY29yZGVkRmFpbHVyZXMgPSB0aGlzLnJlY29yZGVkRmFpbHVyZXM7XG4gICAgICB0aGlzLnJlY29yZGVkRmFpbHVyZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gICAgY29uc3QgbWVtb1BvcyA9IHRoaXMubWF5YmVTa2lwU3BhY2VzQmVmb3JlKGV4cHIpO1xuXG4gICAgbGV0IG9yaWdUcmFjZTtcbiAgICBpZiAodGhpcy50cmFjZSkge1xuICAgICAgb3JpZ1RyYWNlID0gdGhpcy50cmFjZTtcbiAgICAgIHRoaXMudHJhY2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBEbyB0aGUgYWN0dWFsIGV2YWx1YXRpb24uXG4gICAgY29uc3QgYW5zID0gZXhwci5ldmFsKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMudHJhY2UpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3Muc2xpY2Uob3JpZ051bUJpbmRpbmdzKTtcbiAgICAgIGNvbnN0IHRyYWNlRW50cnkgPSB0aGlzLmdldFRyYWNlRW50cnkobWVtb1BvcywgZXhwciwgYW5zLCBiaW5kaW5ncyk7XG4gICAgICB0cmFjZUVudHJ5LmlzSW1wbGljaXRTcGFjZXMgPSBleHByID09PSBhcHBseVNwYWNlcztcbiAgICAgIHRyYWNlRW50cnkuaXNSb290Tm9kZSA9IGV4cHIgPT09IHRoaXMuc3RhcnRFeHByO1xuICAgICAgb3JpZ1RyYWNlLnB1c2godHJhY2VFbnRyeSk7XG4gICAgICB0aGlzLnRyYWNlID0gb3JpZ1RyYWNlO1xuICAgIH1cblxuICAgIGlmIChhbnMpIHtcbiAgICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMgJiYgaW5wdXRTdHJlYW0ucG9zID09PSB0aGlzLnBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5yZWNvcmRlZEZhaWx1cmVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgc2VsZi5yZWNvcmRlZEZhaWx1cmVzW2tleV0ubWFrZUZsdWZmeSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIGFuZCB0aGUgYmluZGluZ3MuXG4gICAgICBpbnB1dFN0cmVhbS5wb3MgPSBvcmlnUG9zO1xuICAgICAgdGhpcy50cnVuY2F0ZUJpbmRpbmdzKG9yaWdOdW1CaW5kaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcykge1xuICAgICAgdGhpcy5yZWNvcmRGYWlsdXJlcyhvcmlnUmVjb3JkZWRGYWlsdXJlcywgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgZ2V0TWF0Y2hSZXN1bHQoKSB7XG4gICAgdGhpcy5ldmFsKHRoaXMuc3RhcnRFeHByKTtcbiAgICBsZXQgcmlnaHRtb3N0RmFpbHVyZXM7XG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByaWdodG1vc3RGYWlsdXJlcyA9IE9iamVjdC5rZXlzKHRoaXMucmVjb3JkZWRGYWlsdXJlcykubWFwKGtleSA9PiBzZWxmLnJlY29yZGVkRmFpbHVyZXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWF0Y2hSZXN1bHQoXG4gICAgICAgIHRoaXMubWF0Y2hlcixcbiAgICAgICAgdGhpcy5pbnB1dCxcbiAgICAgICAgdGhpcy5zdGFydEV4cHIsXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzWzBdLFxuICAgICAgICB0aGlzLl9iaW5kaW5nT2Zmc2V0c1swXSxcbiAgICAgICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sXG4gICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzKTtcbiAgfSxcblxuICBnZXRUcmFjZSgpIHtcbiAgICB0aGlzLnRyYWNlID0gW107XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSB0aGlzLmdldE1hdGNoUmVzdWx0KCk7XG5cbiAgICAvLyBUaGUgdHJhY2Ugbm9kZSBmb3IgdGhlIHN0YXJ0IHJ1bGUgaXMgYWx3YXlzIHRoZSBsYXN0IGVudHJ5LiBJZiBpdCBpcyBhIHN5bnRhY3RpYyBydWxlLFxuICAgIC8vIHRoZSBmaXJzdCBlbnRyeSBpcyBmb3IgYW4gYXBwbGljYXRpb24gb2YgJ3NwYWNlcycuXG4gICAgLy8gVE9ETyhwZHVicm95KTogQ2xlYW4gdGhpcyB1cCBieSBpbnRyb2R1Y2luZyBhIHNwZWNpYWwgYE1hdGNoPHN0YXJ0QXBwbD5gIHJ1bGUsIHdoaWNoIHdpbGxcbiAgICAvLyBlbnN1cmUgdGhhdCB0aGVyZSBpcyBhbHdheXMgYSBzaW5nbGUgcm9vdCB0cmFjZSBub2RlLlxuICAgIGNvbnN0IHJvb3RUcmFjZSA9IHRoaXMudHJhY2VbdGhpcy50cmFjZS5sZW5ndGggLSAxXTtcbiAgICByb290VHJhY2UucmVzdWx0ID0gbWF0Y2hSZXN1bHQ7XG4gICAgcmV0dXJuIHJvb3RUcmFjZTtcbiAgfSxcblxuICBwdXNoRmFpbHVyZXNJbmZvKCkge1xuICAgIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvblN0YWNrLnB1c2godGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24pO1xuICAgIHRoaXMuX3JlY29yZGVkRmFpbHVyZXNTdGFjay5wdXNoKHRoaXMucmVjb3JkZWRGYWlsdXJlcyk7XG4gIH0sXG5cbiAgcG9wRmFpbHVyZXNJbmZvKCkge1xuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uU3RhY2sucG9wKCk7XG4gICAgdGhpcy5yZWNvcmRlZEZhaWx1cmVzID0gdGhpcy5fcmVjb3JkZWRGYWlsdXJlc1N0YWNrLnBvcCgpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaFN0YXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgTWF0Y2hTdGF0ZSA9IHJlcXVpcmUoJy4vTWF0Y2hTdGF0ZScpO1xuXG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gTWF0Y2hlcihncmFtbWFyKSB7XG4gIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG4gIHRoaXMubWVtb1RhYmxlID0gW107XG4gIHRoaXMuaW5wdXQgPSAnJztcbn1cblxuTWF0Y2hlci5wcm90b3R5cGUuZ2V0SW5wdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW5wdXQ7XG59O1xuXG5NYXRjaGVyLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAodGhpcy5pbnB1dCAhPT0gc3RyKSB7XG4gICAgdGhpcy5yZXBsYWNlSW5wdXRSYW5nZSgwLCB0aGlzLmlucHV0Lmxlbmd0aCwgc3RyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLnJlcGxhY2VJbnB1dFJhbmdlID0gZnVuY3Rpb24oc3RhcnRJZHgsIGVuZElkeCwgc3RyKSB7XG4gIGNvbnN0IGN1cnJlbnRJbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIGlmIChzdGFydElkeCA8IDAgfHwgc3RhcnRJZHggPiBjdXJyZW50SW5wdXQubGVuZ3RoIHx8XG4gICAgICBlbmRJZHggPCAwIHx8IGVuZElkeCA+IGN1cnJlbnRJbnB1dC5sZW5ndGggfHxcbiAgICAgIHN0YXJ0SWR4ID4gZW5kSWR4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGljZXM6ICcgKyBzdGFydElkeCArICcgYW5kICcgKyBlbmRJZHgpO1xuICB9XG5cbiAgLy8gdXBkYXRlIGlucHV0XG4gIHRoaXMuaW5wdXQgPSBjdXJyZW50SW5wdXQuc2xpY2UoMCwgc3RhcnRJZHgpICsgc3RyICsgY3VycmVudElucHV0LnNsaWNlKGVuZElkeCk7XG5cbiAgLy8gdXBkYXRlIG1lbW8gdGFibGUgKHNpbWlsYXIgdG8gdGhlIGFib3ZlKVxuICBjb25zdCByZXN0T2ZNZW1vVGFibGUgPSB0aGlzLm1lbW9UYWJsZS5zbGljZShlbmRJZHgpO1xuICB0aGlzLm1lbW9UYWJsZS5sZW5ndGggPSBzdGFydElkeDtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc3RyLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLm1lbW9UYWJsZS5wdXNoKHVuZGVmaW5lZCk7XG4gIH1cbiAgcmVzdE9mTWVtb1RhYmxlLmZvckVhY2goXG4gICAgICBmdW5jdGlvbihwb3NJbmZvKSB7IHRoaXMubWVtb1RhYmxlLnB1c2gocG9zSW5mbyk7IH0sXG4gICAgICB0aGlzKTtcblxuICAvLyBJbnZhbGlkYXRlIG1lbW9SZWNzXG4gIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXJ0SWR4OyBwb3MrKykge1xuICAgIGNvbnN0IHBvc0luZm8gPSB0aGlzLm1lbW9UYWJsZVtwb3NdO1xuICAgIGlmIChwb3NJbmZvKSB7XG4gICAgICBwb3NJbmZvLmNsZWFyT2Jzb2xldGVFbnRyaWVzKHBvcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvcHRTdGFydEFwcGxpY2F0aW9uU3RyKSB7XG4gIHJldHVybiB0aGlzLl9tYXRjaCh0aGlzLl9nZXRTdGFydEV4cHIob3B0U3RhcnRBcHBsaWNhdGlvblN0ciksIGZhbHNlKTtcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24ob3B0U3RhcnRBcHBsaWNhdGlvblN0cikge1xuICByZXR1cm4gdGhpcy5fbWF0Y2godGhpcy5fZ2V0U3RhcnRFeHByKG9wdFN0YXJ0QXBwbGljYXRpb25TdHIpLCB0cnVlKTtcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLl9tYXRjaCA9IGZ1bmN0aW9uKHN0YXJ0RXhwciwgdHJhY2luZywgb3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gIGNvbnN0IHN0YXRlID0gbmV3IE1hdGNoU3RhdGUodGhpcywgc3RhcnRFeHByLCBvcHRQb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpO1xuICByZXR1cm4gdHJhY2luZyA/IHN0YXRlLmdldFRyYWNlKCkgOiBzdGF0ZS5nZXRNYXRjaFJlc3VsdCgpO1xufTtcblxuLypcbiAgUmV0dXJucyB0aGUgc3RhcnRpbmcgZXhwcmVzc2lvbiBmb3IgdGhpcyBNYXRjaGVyJ3MgYXNzb2NpYXRlZCBncmFtbWFyLiBJZiBgb3B0U3RhcnRBcHBsaWNhdGlvblN0cmBcbiAgaXMgc3BlY2lmaWVkLCBpdCBpcyBhIHN0cmluZyBleHByZXNzaW5nIGEgcnVsZSBhcHBsaWNhdGlvbiBpbiB0aGUgZ3JhbW1hci4gSWYgbm90IHNwZWNpZmllZCwgdGhlXG4gIGdyYW1tYXIncyBkZWZhdWx0IHN0YXJ0IHJ1bGUgd2lsbCBiZSB1c2VkLlxuKi9cbk1hdGNoZXIucHJvdG90eXBlLl9nZXRTdGFydEV4cHIgPSBmdW5jdGlvbihvcHRTdGFydEFwcGxpY2F0aW9uU3RyKSB7XG4gIGNvbnN0IGFwcGxpY2F0aW9uU3RyID0gb3B0U3RhcnRBcHBsaWNhdGlvblN0ciB8fCB0aGlzLmdyYW1tYXIuZGVmYXVsdFN0YXJ0UnVsZTtcbiAgaWYgKCFhcHBsaWNhdGlvblN0cikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzdGFydCBydWxlIGFyZ3VtZW50IC0tIHRoZSBncmFtbWFyIGhhcyBubyBkZWZhdWx0IHN0YXJ0IHJ1bGUuJyk7XG4gIH1cblxuICBjb25zdCBzdGFydEFwcCA9IHRoaXMuZ3JhbW1hci5wYXJzZUFwcGxpY2F0aW9uKGFwcGxpY2F0aW9uU3RyKTtcbiAgcmV0dXJuIG5ldyBwZXhwcnMuU2VxKFtzdGFydEFwcCwgcGV4cHJzLmVuZF0pO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0Y2hlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3V0aWwtZXh0ZW5kJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBOYW1lc3BhY2UoKSB7XG59XG5OYW1lc3BhY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuTmFtZXNwYWNlLmFzTmFtZXNwYWNlID0gZnVuY3Rpb24ob2JqT3JOYW1lc3BhY2UpIHtcbiAgaWYgKG9iak9yTmFtZXNwYWNlIGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIG9iak9yTmFtZXNwYWNlO1xuICB9XG4gIHJldHVybiBOYW1lc3BhY2UuY3JlYXRlTmFtZXNwYWNlKG9iak9yTmFtZXNwYWNlKTtcbn07XG5cbi8vIENyZWF0ZSBhIG5ldyBuYW1lc3BhY2UuIElmIGBvcHRQcm9wc2AgaXMgc3BlY2lmaWVkLCBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbi8vIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgbmFtZXNwYWNlLlxuTmFtZXNwYWNlLmNyZWF0ZU5hbWVzcGFjZSA9IGZ1bmN0aW9uKG9wdFByb3BzKSB7XG4gIHJldHVybiBOYW1lc3BhY2UuZXh0ZW5kKE5hbWVzcGFjZS5wcm90b3R5cGUsIG9wdFByb3BzKTtcbn07XG5cbi8vIENyZWF0ZSBhIG5ldyBuYW1lc3BhY2Ugd2hpY2ggZXh0ZW5kcyBhbm90aGVyIG5hbWVzcGFjZS4gSWYgYG9wdFByb3BzYCBpc1xuLy8gc3BlY2lmaWVkLCBhbGwgb2YgaXRzIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBuYW1lc3BhY2UuXG5OYW1lc3BhY2UuZXh0ZW5kID0gZnVuY3Rpb24obmFtZXNwYWNlLCBvcHRQcm9wcykge1xuICBpZiAobmFtZXNwYWNlICE9PSBOYW1lc3BhY2UucHJvdG90eXBlICYmICEobmFtZXNwYWNlIGluc3RhbmNlb2YgTmFtZXNwYWNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIE5hbWVzcGFjZSBvYmplY3Q6ICcgKyBuYW1lc3BhY2UpO1xuICB9XG4gIGNvbnN0IG5zID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IE5hbWVzcGFjZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXh0ZW5kKG5zLCBvcHRQcm9wcyk7XG59O1xuXG4vLyBUT0RPOiBTaG91bGQgdGhpcyBiZSBhIHJlZ3VsYXIgbWV0aG9kP1xuTmFtZXNwYWNlLnRvU3RyaW5nID0gZnVuY3Rpb24obnMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChucyk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBOYW1lc3BhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBQb3NJbmZvKCkge1xuICB0aGlzLmFwcGxpY2F0aW9uTWVtb0tleVN0YWNrID0gW107IC8vIGFjdGl2ZSBhcHBsaWNhdGlvbnMgYXQgdGhpcyBwb3NpdGlvblxuICB0aGlzLm1lbW8gPSB7fTtcbiAgdGhpcy5tYXhFeGFtaW5lZExlbmd0aCA9IDA7XG4gIHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9IC0xO1xuICB0aGlzLmN1cnJlbnRMZWZ0UmVjdXJzaW9uID0gdW5kZWZpbmVkO1xufVxuXG5Qb3NJbmZvLnByb3RvdHlwZSA9IHtcbiAgaXNBY3RpdmUoYXBwbGljYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5pbmRleE9mKGFwcGxpY2F0aW9uLnRvTWVtb0tleSgpKSA+PSAwO1xuICB9LFxuXG4gIGVudGVyKGFwcGxpY2F0aW9uKSB7XG4gICAgdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5wdXNoKGFwcGxpY2F0aW9uLnRvTWVtb0tleSgpKTtcbiAgfSxcblxuICBleGl0KCkge1xuICAgIHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2sucG9wKCk7XG4gIH0sXG5cbiAgc3RhcnRMZWZ0UmVjdXJzaW9uKGhlYWRBcHBsaWNhdGlvbiwgbWVtb1JlYykge1xuICAgIG1lbW9SZWMuaXNMZWZ0UmVjdXJzaW9uID0gdHJ1ZTtcbiAgICBtZW1vUmVjLmhlYWRBcHBsaWNhdGlvbiA9IGhlYWRBcHBsaWNhdGlvbjtcbiAgICBtZW1vUmVjLm5leHRMZWZ0UmVjdXJzaW9uID0gdGhpcy5jdXJyZW50TGVmdFJlY3Vyc2lvbjtcbiAgICB0aGlzLmN1cnJlbnRMZWZ0UmVjdXJzaW9uID0gbWVtb1JlYztcblxuICAgIGNvbnN0IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrID0gdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjaztcbiAgICBjb25zdCBpbmRleE9mRmlyc3RJbnZvbHZlZFJ1bGUgPVxuICAgICAgICBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5pbmRleE9mKGhlYWRBcHBsaWNhdGlvbi50b01lbW9LZXkoKSkgKyAxO1xuICAgIGNvbnN0IGludm9sdmVkQXBwbGljYXRpb25NZW1vS2V5cyA9IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLnNsaWNlKGluZGV4T2ZGaXJzdEludm9sdmVkUnVsZSk7XG5cbiAgICBtZW1vUmVjLmlzSW52b2x2ZWQgPSBmdW5jdGlvbihhcHBsaWNhdGlvbk1lbW9LZXkpIHtcbiAgICAgIHJldHVybiBpbnZvbHZlZEFwcGxpY2F0aW9uTWVtb0tleXMuaW5kZXhPZihhcHBsaWNhdGlvbk1lbW9LZXkpID49IDA7XG4gICAgfTtcblxuICAgIG1lbW9SZWMudXBkYXRlSW52b2x2ZWRBcHBsaWNhdGlvbk1lbW9LZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKGxldCBpZHggPSBpbmRleE9mRmlyc3RJbnZvbHZlZFJ1bGU7IGlkeCA8IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb25NZW1vS2V5ID0gYXBwbGljYXRpb25NZW1vS2V5U3RhY2tbaWR4XTtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW52b2x2ZWQoYXBwbGljYXRpb25NZW1vS2V5KSkge1xuICAgICAgICAgIGludm9sdmVkQXBwbGljYXRpb25NZW1vS2V5cy5wdXNoKGFwcGxpY2F0aW9uTWVtb0tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGVuZExlZnRSZWN1cnNpb24oKSB7XG4gICAgdGhpcy5jdXJyZW50TGVmdFJlY3Vyc2lvbiA9IHRoaXMuY3VycmVudExlZnRSZWN1cnNpb24ubmV4dExlZnRSZWN1cnNpb247XG4gIH0sXG5cbiAgLy8gTm90ZTogdGhpcyBtZXRob2QgZG9lc24ndCBnZXQgY2FsbGVkIGZvciB0aGUgXCJoZWFkXCIgb2YgYSBsZWZ0IHJlY3Vyc2lvbiAtLSBmb3IgTFIgaGVhZHMsXG4gIC8vIHRoZSBtZW1vaXplZCByZXN1bHQgKHdoaWNoIHN0YXJ0cyBvdXQgYmVpbmcgYSBmYWlsdXJlKSBpcyBhbHdheXMgdXNlZC5cbiAgc2hvdWxkVXNlTWVtb2l6ZWRSZXN1bHQobWVtb1JlYykge1xuICAgIGlmICghbWVtb1JlYy5pc0xlZnRSZWN1cnNpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjayA9IHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2s7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYXBwbGljYXRpb25NZW1vS2V5U3RhY2subGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29uc3QgYXBwbGljYXRpb25NZW1vS2V5ID0gYXBwbGljYXRpb25NZW1vS2V5U3RhY2tbaWR4XTtcbiAgICAgIGlmIChtZW1vUmVjLmlzSW52b2x2ZWQoYXBwbGljYXRpb25NZW1vS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIG1lbW9pemUobWVtb0tleSwgbWVtb1JlYykge1xuICAgIHRoaXMubWVtb1ttZW1vS2V5XSA9IG1lbW9SZWM7XG4gICAgdGhpcy5tYXhFeGFtaW5lZExlbmd0aCA9IE1hdGgubWF4KHRoaXMubWF4RXhhbWluZWRMZW5ndGgsIG1lbW9SZWMuZXhhbWluZWRMZW5ndGgpO1xuICAgIHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9XG4gICAgICAgIE1hdGgubWF4KHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCwgbWVtb1JlYy5yaWdodG1vc3RGYWlsdXJlT2Zmc2V0KTtcbiAgICByZXR1cm4gbWVtb1JlYztcbiAgfSxcblxuICBjbGVhck9ic29sZXRlRW50cmllcyhwb3MsIGludmFsaWRhdGVkSWR4KSB7XG4gICAgaWYgKHBvcyArIHRoaXMubWF4RXhhbWluZWRMZW5ndGggPD0gaW52YWxpZGF0ZWRJZHgpIHtcbiAgICAgIC8vIE9wdGltaXphdGlvbjogbm9uZSBvZiB0aGUgcnVsZSBhcHBsaWNhdGlvbnMgdGhhdCB3ZXJlIG1lbW9pemVkIGhlcmUgZXhhbWluZWQgdGhlXG4gICAgICAvLyBpbnRlcnZhbCBvZiB0aGUgaW5wdXQgdGhhdCBjaGFuZ2VkLCBzbyBub3RoaW5nIGhhcyB0byBiZSBpbnZhbGlkYXRlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZW1vID0gdGhpcy5tZW1vO1xuICAgIHRoaXMubWF4RXhhbWluZWRMZW5ndGggPSAwO1xuICAgIHRoaXMubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9IC0xO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKG1lbW8pLmZvckVhY2goayA9PiB7XG4gICAgICBjb25zdCBtZW1vUmVjID0gbWVtb1trXTtcbiAgICAgIGlmIChwb3MgKyBtZW1vUmVjLmV4YW1pbmVkTGVuZ3RoID4gaW52YWxpZGF0ZWRJZHgpIHtcbiAgICAgICAgZGVsZXRlIG1lbW9ba107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLm1heEV4YW1pbmVkTGVuZ3RoID0gTWF0aC5tYXgoc2VsZi5tYXhFeGFtaW5lZExlbmd0aCwgbWVtb1JlYy5leGFtaW5lZExlbmd0aCk7XG4gICAgICAgIHNlbGYubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9XG4gICAgICAgICAgICBNYXRoLm1heChzZWxmLm1heFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQsIG1lbW9SZWMucmlnaHRtb3N0RmFpbHVyZU9mZnNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc0luZm87XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBJbnB1dFN0cmVhbSA9IHJlcXVpcmUoJy4vSW5wdXRTdHJlYW0nKTtcbmNvbnN0IEl0ZXJhdGlvbk5vZGUgPSByZXF1aXJlKCcuL25vZGVzJykuSXRlcmF0aW9uTm9kZTtcbmNvbnN0IE1hdGNoUmVzdWx0ID0gcmVxdWlyZSgnLi9NYXRjaFJlc3VsdCcpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBnbG9iYWxBY3Rpb25TdGFjayA9IFtdO1xubGV0IHByb3RvdHlwZUdyYW1tYXI7XG5sZXQgcHJvdG90eXBlR3JhbW1hclNlbWFudGljcztcblxuLy8gSlNPTiBpcyBub3QgYSB2YWxpZCBzdWJzZXQgb2YgSmF2YVNjcmlwdCBiZWNhdXNlIHRoZXJlIGFyZSB0d28gcG9zc2libGUgbGluZSB0ZXJtaW5hdG9ycyxcbi8vIFUrMjAyOCAobGluZSBzZXBhcmF0b3IpIGFuZCBVKzIwMjkgKHBhcmFncmFwaCBzZXBhcmF0b3IpIHRoYXQgYXJlIGFsbG93ZWQgaW4gSlNPTiBzdHJpbmdzXG4vLyBidXQgbm90IGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGpzb25Ub0pTKCkgcHJvcGVybHkgZW5jb2RlcyB0aG9zZSB0d28gY2hhcmFjdGVycyBpbiBKU09OIHNvIHRoYXQgaXQgY2FuIHNlYW1sZXNzbHkgYmVcbi8vIGluc2VydGVkIGludG8gSmF2YVNjcmlwdCBjb2RlIChwbHVzIHRoZSBlbmNvZGVkIHZlcnNpb24gaXMgc3RpbGwgdmFsaWQgSlNPTilcbmZ1bmN0aW9uIGpzb25Ub0pTKHN0cikge1xuICBjb25zdCBvdXRwdXQgPSBzdHIucmVwbGFjZSgvW1xcdTIwMjhcXHUyMDI5XS9nLCAoY2hhciwgcG9zLCBzdHIpID0+IHtcbiAgICBjb25zdCBoZXggPSBjaGFyLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gJ1xcXFx1JyArICcwMDAwJy5zbGljZShoZXgubGVuZ3RoKSArIGhleDtcbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIFdyYXBwZXJzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFdyYXBwZXJzIGRlY29yYXRlIENTVCBub2RlcyB3aXRoIGFsbCBvZiB0aGUgZnVuY3Rpb25hbGl0eSAoaS5lLiwgb3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcylcbi8vIHByb3ZpZGVkIGJ5IGEgU2VtYW50aWNzIChzZWUgYmVsb3cpLiBgV3JhcHBlcmAgaXMgdGhlIGFic3RyYWN0IHN1cGVyY2xhc3Mgb2YgYWxsIHdyYXBwZXJzLiBBXG4vLyBgV3JhcHBlcmAgbXVzdCBoYXZlIGBfbm9kZWAgYW5kIGBfc2VtYW50aWNzYCBpbnN0YW5jZSB2YXJpYWJsZXMsIHdoaWNoIHJlZmVyIHRvIHRoZSBDU1Qgbm9kZSBhbmRcbi8vIFNlbWFudGljcyAocmVzcC4pIGZvciB3aGljaCBpdCB3YXMgY3JlYXRlZCwgYW5kIGEgYF9jaGlsZFdyYXBwZXJzYCBpbnN0YW5jZSB2YXJpYWJsZSB3aGljaCBpc1xuLy8gdXNlZCB0byBjYWNoZSB0aGUgd3JhcHBlciBpbnN0YW5jZXMgdGhhdCBhcmUgY3JlYXRlZCBmb3IgaXRzIGNoaWxkIG5vZGVzLiBTZXR0aW5nIHRoZXNlIGluc3RhbmNlXG4vLyB2YXJpYWJsZXMgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjb25zdHJ1Y3RvciBvZiBlYWNoIFNlbWFudGljcy1zcGVjaWZpYyBzdWJjbGFzcyBvZlxuLy8gYFdyYXBwZXJgLlxuY2xhc3MgV3JhcHBlciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIHNvdXJjZUludGVydmFsLCBiYXNlSW50ZXJ2YWwpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZUludGVydmFsO1xuXG4gICAgLy8gVGhlIGludGVydmFsIHRoYXQgdGhlIGNoaWxkT2Zmc2V0cyBvZiBgbm9kZWAgYXJlIHJlbGF0aXZlIHRvLiBJdCBzaG91bGQgYmUgdGhlIHNvdXJjZVxuICAgIC8vIG9mIHRoZSBjbG9zZXN0IE5vbnRlcm1pbmFsIG5vZGUuXG4gICAgdGhpcy5fYmFzZUludGVydmFsID0gYmFzZUludGVydmFsO1xuXG4gICAgaWYgKG5vZGUuaXNOb250ZXJtaW5hbCgpKSB7XG4gICAgICBjb21tb24uYXNzZXJ0KHNvdXJjZUludGVydmFsID09PSBiYXNlSW50ZXJ2YWwpO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZFdyYXBwZXJzID0gW107XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tzZW1hbnRpY3Mgd3JhcHBlciBmb3IgJyArIHRoaXMuX25vZGUuZ3JhbW1hci5uYW1lICsgJ10nO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgdXNlZCBieSBvaG0gZWRpdG9yIHRvIGRpc3BsYXkgYSBub2RlIHdyYXBwZXIgYXBwcm9wcmlhdGVseS5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICBfZm9yZ2V0TWVtb2l6ZWRSZXN1bHRGb3IoYXR0cmlidXRlTmFtZSkge1xuICAgIC8vIFJlbW92ZSB0aGUgbWVtb2l6ZWQgYXR0cmlidXRlIGZyb20gdGhlIGNzdE5vZGUgYW5kIGFsbCBpdHMgY2hpbGRyZW4uXG4gICAgZGVsZXRlIHRoaXMuX25vZGVbdGhpcy5fc2VtYW50aWNzLmF0dHJpYnV0ZUtleXNbYXR0cmlidXRlTmFtZV1dO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC5fZm9yZ2V0TWVtb2l6ZWRSZXN1bHRGb3IoYXR0cmlidXRlTmFtZSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB3cmFwcGVyIG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQgbm9kZS4gQ2hpbGQgd3JhcHBlcnMgYXJlIGNyZWF0ZWQgbGF6aWx5IGFuZFxuICAvLyBjYWNoZWQgaW4gdGhlIHBhcmVudCB3cmFwcGVyJ3MgYF9jaGlsZFdyYXBwZXJzYCBpbnN0YW5jZSB2YXJpYWJsZS5cbiAgY2hpbGQoaWR4KSB7XG4gICAgaWYgKCEoMCA8PSBpZHggJiYgaWR4IDwgdGhpcy5fbm9kZS5udW1DaGlsZHJlbigpKSkge1xuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIGhlcmUuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgY2hpbGRXcmFwcGVyID0gdGhpcy5fY2hpbGRXcmFwcGVyc1tpZHhdO1xuICAgIGlmICghY2hpbGRXcmFwcGVyKSB7XG4gICAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLl9ub2RlLmNoaWxkQXQoaWR4KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25vZGUuY2hpbGRPZmZzZXRzW2lkeF07XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX2Jhc2VJbnRlcnZhbC5zdWJJbnRlcnZhbChvZmZzZXQsIGNoaWxkTm9kZS5tYXRjaExlbmd0aCk7XG4gICAgICBjb25zdCBiYXNlID0gY2hpbGROb2RlLmlzTm9udGVybWluYWwoKSA/IHNvdXJjZSA6IHRoaXMuX2Jhc2VJbnRlcnZhbDtcbiAgICAgIGNoaWxkV3JhcHBlciA9IHRoaXMuX2NoaWxkV3JhcHBlcnNbaWR4XSA9IHRoaXMuX3NlbWFudGljcy53cmFwKGNoaWxkTm9kZSwgc291cmNlLCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkV3JhcHBlcjtcbiAgfVxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgd3JhcHBlcnMgb2YgYWxsIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZSBhc3NvY2lhdGVkXG4gIC8vIHdpdGggdGhpcyB3cmFwcGVyLlxuICBfY2hpbGRyZW4oKSB7XG4gICAgLy8gRm9yY2UgdGhlIGNyZWF0aW9uIG9mIGFsbCBjaGlsZCB3cmFwcGVyc1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX25vZGUubnVtQ2hpbGRyZW4oKTsgaWR4KyspIHtcbiAgICAgIHRoaXMuY2hpbGQoaWR4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkV3JhcHBlcnM7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBjb3JyZXNwb25kcyB0byBhbiBpdGVyYXRpb25cbiAgLy8gZXhwcmVzc2lvbiwgaS5lLiwgYSBLbGVlbmUtKiwgS2xlZW5lLSssIG9yIGFuIG9wdGlvbmFsLiBSZXR1cm5zIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICBpc0l0ZXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5pc0l0ZXJhdGlvbigpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgaXMgYSB0ZXJtaW5hbCBub2RlLCBgZmFsc2VgXG4gIC8vIG90aGVyd2lzZS5cbiAgaXNUZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5pc1Rlcm1pbmFsKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBpcyBhIG5vbnRlcm1pbmFsIG5vZGUsIGBmYWxzZWBcbiAgLy8gb3RoZXJ3aXNlLlxuICBpc05vbnRlcm1pbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLmlzTm9udGVybWluYWwoKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3cmFwcGVyIGlzIGEgbm9udGVybWluYWwgbm9kZVxuICAvLyBjb3JyZXNwb25kaW5nIHRvIGEgc3ludGFjdGljIHJ1bGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICBpc1N5bnRhY3RpYygpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vbnRlcm1pbmFsKCkgJiYgdGhpcy5fbm9kZS5pc1N5bnRhY3RpYygpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgaXMgYSBub250ZXJtaW5hbCBub2RlXG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gYSBsZXhpY2FsIHJ1bGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICBpc0xleGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb250ZXJtaW5hbCgpICYmIHRoaXMuX25vZGUuaXNMZXhpY2FsKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBpcyBhbiBpdGVyYXRvciBub2RlXG4gIC8vIGhhdmluZyBlaXRoZXIgb25lIG9yIG5vIGNoaWxkICg/IG9wZXJhdG9yKSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vIE90aGVyd2lzZSwgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5pc09wdGlvbmFsKCk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgX2l0ZXIgd3JhcHBlciBpbiB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgdGhpcyB3cmFwcGVyLlxuICBpdGVyYXRpb24ob3B0Q2hpbGRXcmFwcGVycykge1xuICAgIGNvbnN0IGNoaWxkV3JhcHBlcnMgPSBvcHRDaGlsZFdyYXBwZXJzIHx8IFtdO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IGNoaWxkV3JhcHBlcnMubWFwKGMgPT4gYy5fbm9kZSk7XG4gICAgY29uc3QgaXRlciA9IG5ldyBJdGVyYXRpb25Ob2RlKHRoaXMuX25vZGUuZ3JhbW1hciwgY2hpbGROb2RlcywgW10sIC0xLCBmYWxzZSk7XG5cbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5fc2VtYW50aWNzLndyYXAoaXRlciwgbnVsbCwgbnVsbCk7XG4gICAgd3JhcHBlci5fY2hpbGRXcmFwcGVycyA9IGNoaWxkV3JhcHBlcnM7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvLyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIG9mIHRoaXMgQ1NUIG5vZGUuXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4oKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG5hbWUgb2YgZ3JhbW1hciBydWxlIHRoYXQgY3JlYXRlZCB0aGlzIENTVCBub2RlLlxuICBnZXQgY3Rvck5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuY3Rvck5hbWU7XG4gIH1cblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBldmVudHVhbGx5IChkZXByZWNhdGVkIGluIHYwLjEyKS5cbiAgZ2V0IGludGVydmFsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBpbnRlcnZhbGAgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCAtLSB1c2UgYHNvdXJjZWAgaW5zdGVhZCcpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIG9mIHRoaXMgQ1NUIG5vZGUuXG4gIGdldCBudW1DaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5udW1DaGlsZHJlbigpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcHJpbWl0aXZlIHZhbHVlIG9mIHRoaXMgQ1NUIG5vZGUsIGlmIGl0J3MgYSB0ZXJtaW5hbCBub2RlLiBPdGhlcndpc2UsXG4gIC8vIHRocm93cyBhbiBleGNlcHRpb24uXG4gIGdldCBwcmltaXRpdmVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5pc1Rlcm1pbmFsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ub2RlLnByaW1pdGl2ZVZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcInRyaWVkIHRvIGFjY2VzcyB0aGUgJ3ByaW1pdGl2ZVZhbHVlJyBhdHRyaWJ1dGUgb2YgYSBub24tdGVybWluYWwgQ1NUIG5vZGVcIik7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgaW5wdXQgc3RyZWFtIGNvbnN1bWVkIGJ5IHRoaXMgQ1NUIG5vZGUuXG4gIGdldCBzb3VyY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbnRlbnRzO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIFNlbWFudGljcyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBIFNlbWFudGljcyBpcyBhIGNvbnRhaW5lciBmb3IgYSBmYW1pbHkgb2YgT3BlcmF0aW9ucyBhbmQgQXR0cmlidXRlcyBmb3IgYSBnaXZlbiBncmFtbWFyLlxuLy8gU2VtYW50aWNzIGVuYWJsZSBtb2R1bGFyaXR5IChkaWZmZXJlbnQgY2xpZW50cyBvZiBhIGdyYW1tYXIgY2FuIGNyZWF0ZSB0aGVpciBzZXQgb2Ygb3BlcmF0aW9uc1xuLy8gYW5kIGF0dHJpYnV0ZXMgaW4gaXNvbGF0aW9uKSBhbmQgZXh0ZW5zaWJpbGl0eSBldmVuIHdoZW4gb3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcyBhcmUgbXV0dWFsbHktXG4vLyByZWN1cnNpdmUuIFRoaXMgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgZXhjZXB0IGZyb21cbi8vIGBTZW1hbnRpY3MuY3JlYXRlU2VtYW50aWNzYC4gVGhlIG5vcm1hbCB3YXlzIHRvIGNyZWF0ZSBhIFNlbWFudGljcywgZ2l2ZW4gYSBncmFtbWFyICdnJywgYXJlXG4vLyBgZy5jcmVhdGVTZW1hbnRpY3MoKWAgYW5kIGBnLmV4dGVuZFNlbWFudGljcyhwYXJlbnRTZW1hbnRpY3MpYC5cbmZ1bmN0aW9uIFNlbWFudGljcyhncmFtbWFyLCBzdXBlclNlbWFudGljcykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgdGhpcy5jaGVja2VkQWN0aW9uRGljdHMgPSBmYWxzZTtcblxuICAvLyBDb25zdHJ1Y3RvciBmb3Igd3JhcHBlciBpbnN0YW5jZXMsIHdoaWNoIGFyZSBwYXNzZWQgYXMgdGhlIGFyZ3VtZW50cyB0byB0aGUgc2VtYW50aWMgYWN0aW9uc1xuICAvLyBvZiBhbiBvcGVyYXRpb24gb3IgYXR0cmlidXRlLiBPcGVyYXRpb25zIGFuZCBhdHRyaWJ1dGVzIHJlcXVpcmUgZG91YmxlIGRpc3BhdGNoOiB0aGUgc2VtYW50aWNcbiAgLy8gYWN0aW9uIGlzIGNob3NlbiBiYXNlZCBvbiBib3RoIHRoZSBub2RlJ3MgdHlwZSBhbmQgdGhlIHNlbWFudGljcy4gV3JhcHBlcnMgZW5zdXJlIHRoYXRcbiAgLy8gdGhlIGBleGVjdXRlYCBtZXRob2QgaXMgY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgKG1vc3Qgc3BlY2lmaWMpIHNlbWFudGljcyBvYmplY3QgYXMgYW5cbiAgLy8gYXJndW1lbnQuXG4gIHRoaXMuV3JhcHBlciA9IGNsYXNzIGV4dGVuZHMgKHN1cGVyU2VtYW50aWNzID8gc3VwZXJTZW1hbnRpY3MuV3JhcHBlciA6IFdyYXBwZXIpIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzb3VyY2VJbnRlcnZhbCwgYmFzZUludGVydmFsKSB7XG4gICAgICBzdXBlcihub2RlLCBzb3VyY2VJbnRlcnZhbCwgYmFzZUludGVydmFsKTtcbiAgICAgIHNlbGYuY2hlY2tBY3Rpb25EaWN0c0lmSGF2ZW50QWxyZWFkeSgpO1xuICAgICAgdGhpcy5fc2VtYW50aWNzID0gc2VsZjtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5zdXBlciA9IHN1cGVyU2VtYW50aWNzO1xuICBpZiAoc3VwZXJTZW1hbnRpY3MpIHtcbiAgICBpZiAoIShncmFtbWFyLmVxdWFscyh0aGlzLnN1cGVyLmdyYW1tYXIpIHx8IGdyYW1tYXIuX2luaGVyaXRzRnJvbSh0aGlzLnN1cGVyLmdyYW1tYXIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IGV4dGVuZCBhIHNlbWFudGljcyBmb3IgZ3JhbW1hciAnXCIgKyB0aGlzLnN1cGVyLmdyYW1tYXIubmFtZSArXG4gICAgICAgICAgXCInIGZvciB1c2Ugd2l0aCBncmFtbWFyICdcIiArIGdyYW1tYXIubmFtZSArIFwiJyAobm90IGEgc3ViLWdyYW1tYXIpXCIpO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBPYmplY3QuY3JlYXRlKHRoaXMuc3VwZXIub3BlcmF0aW9ucyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnN1cGVyLmF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuYXR0cmlidXRlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBBc3NpZ24gdW5pcXVlIHN5bWJvbHMgZm9yIGVhY2ggb2YgdGhlIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGZyb20gdGhlIHN1cGVyLXNlbWFudGljcyBzbyB0aGF0XG4gICAgLy8gdGhleSBhcmUgbWVtb2l6ZWQgaW5kZXBlbmRlbnRseS5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5hdHRyaWJ1dGVLZXlzLCBhdHRyaWJ1dGVOYW1lLCB7XG4gICAgICAgIHZhbHVlOiB1dGlsLnVuaXF1ZUlkKGF0dHJpYnV0ZU5hbWUpXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYXR0cmlidXRlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbn1cblxuU2VtYW50aWNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ1tzZW1hbnRpY3MgZm9yICcgKyB0aGlzLmdyYW1tYXIubmFtZSArICddJztcbn07XG5cblNlbWFudGljcy5wcm90b3R5cGUuY2hlY2tBY3Rpb25EaWN0c0lmSGF2ZW50QWxyZWFkeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY2hlY2tlZEFjdGlvbkRpY3RzKSB7XG4gICAgdGhpcy5jaGVja0FjdGlvbkRpY3RzKCk7XG4gICAgdGhpcy5jaGVja2VkQWN0aW9uRGljdHMgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBDaGVja3MgdGhhdCB0aGUgYWN0aW9uIGRpY3Rpb25hcmllcyBmb3IgYWxsIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgaW4gdGhpcyBzZW1hbnRpY3MsXG4vLyBpbmNsdWRpbmcgdGhlIG9uZXMgdGhhdCB3ZXJlIGluaGVyaXRlZCBmcm9tIHRoZSBzdXBlci1zZW1hbnRpY3MsIGFncmVlIHdpdGggdGhlIGdyYW1tYXIuXG4vLyBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIG9uZSBvciBtb3JlIG9mIHRoZW0gZG9lc24ndC5cblNlbWFudGljcy5wcm90b3R5cGUuY2hlY2tBY3Rpb25EaWN0cyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgbmFtZTtcbiAgZm9yIChuYW1lIGluIHRoaXMub3BlcmF0aW9ucykge1xuICAgIHRoaXMub3BlcmF0aW9uc1tuYW1lXS5jaGVja0FjdGlvbkRpY3QodGhpcy5ncmFtbWFyKTtcbiAgfVxuICBmb3IgKG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdLmNoZWNrQWN0aW9uRGljdCh0aGlzLmdyYW1tYXIpO1xuICB9XG59O1xuXG5TZW1hbnRpY3MucHJvdG90eXBlLnRvUmVjaXBlID0gZnVuY3Rpb24oc2VtYW50aWNzT25seSkge1xuICBmdW5jdGlvbiBoYXNTdXBlclNlbWFudGljcyhzKSB7XG4gICAgcmV0dXJuIHMuc3VwZXIgIT09IFNlbWFudGljcy5CdWlsdEluU2VtYW50aWNzLl9nZXRTZW1hbnRpY3MoKTtcbiAgfVxuXG4gIGxldCBzdHIgPSAnKGZ1bmN0aW9uKGcpIHtcXG4nO1xuICBpZiAoaGFzU3VwZXJTZW1hbnRpY3ModGhpcykpIHtcbiAgICBzdHIgKz0gJyAgdmFyIHNlbWFudGljcyA9ICcgKyB0aGlzLnN1cGVyLnRvUmVjaXBlKHRydWUpICsgJyhnJztcblxuICAgIGNvbnN0IHN1cGVyU2VtYW50aWNzR3JhbW1hciA9IHRoaXMuc3VwZXIuZ3JhbW1hcjtcbiAgICBsZXQgcmVsYXRlZEdyYW1tYXIgPSB0aGlzLmdyYW1tYXI7XG4gICAgd2hpbGUgKHJlbGF0ZWRHcmFtbWFyICE9PSBzdXBlclNlbWFudGljc0dyYW1tYXIpIHtcbiAgICAgIHN0ciArPSAnLnN1cGVyR3JhbW1hcic7XG4gICAgICByZWxhdGVkR3JhbW1hciA9IHJlbGF0ZWRHcmFtbWFyLnN1cGVyR3JhbW1hcjtcbiAgICB9XG5cbiAgICBzdHIgKz0gJyk7XFxuJztcbiAgICBzdHIgKz0gJyAgcmV0dXJuIGcuZXh0ZW5kU2VtYW50aWNzKHNlbWFudGljcyknO1xuICB9IGVsc2Uge1xuICAgIHN0ciArPSAnICByZXR1cm4gZy5jcmVhdGVTZW1hbnRpY3MoKSc7XG4gIH1cbiAgWydPcGVyYXRpb24nLCAnQXR0cmlidXRlJ10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjb25zdCBzZW1hbnRpY09wZXJhdGlvbnMgPSB0aGlzW3R5cGUudG9Mb3dlckNhc2UoKSArICdzJ107XG4gICAgT2JqZWN0LmtleXMoc2VtYW50aWNPcGVyYXRpb25zKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29uc3Qge2FjdGlvbkRpY3QsIGZvcm1hbHMsIGJ1aWx0SW5EZWZhdWx0fSA9IHNlbWFudGljT3BlcmF0aW9uc1tuYW1lXTtcblxuICAgICAgbGV0IHNpZ25hdHVyZSA9IG5hbWU7XG4gICAgICBpZiAoZm9ybWFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNpZ25hdHVyZSArPSAnKCcgKyBmb3JtYWxzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIGxldCBtZXRob2Q7XG4gICAgICBpZiAoaGFzU3VwZXJTZW1hbnRpY3ModGhpcykgJiYgdGhpcy5zdXBlclt0eXBlLnRvTG93ZXJDYXNlKCkgKyAncyddW25hbWVdKSB7XG4gICAgICAgIG1ldGhvZCA9ICdleHRlbmQnICsgdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9ICdhZGQnICsgdHlwZTtcbiAgICAgIH1cbiAgICAgIHN0ciArPSAnXFxuICAgIC4nICsgbWV0aG9kICsgJygnICsgSlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlKSArICcsIHsnO1xuXG4gICAgICBjb25zdCBzcmNBcnJheSA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMoYWN0aW9uRGljdCkuZm9yRWFjaChhY3Rpb25OYW1lID0+IHtcbiAgICAgICAgaWYgKGFjdGlvbkRpY3RbYWN0aW9uTmFtZV0gIT09IGJ1aWx0SW5EZWZhdWx0KSB7XG4gICAgICAgICAgbGV0IHNvdXJjZSA9IGFjdGlvbkRpY3RbYWN0aW9uTmFtZV0udG9TdHJpbmcoKS50cmltKCk7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG1ldGhvZCBzaG9ydGhhbmQgdG8gcGxhaW4gb2xkIGZ1bmN0aW9uIHN5bnRheC5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGFyYy9vaG0vaXNzdWVzLzI2M1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC9eLipcXCgvLCAnZnVuY3Rpb24oJyk7XG5cbiAgICAgICAgICBzcmNBcnJheS5wdXNoKCdcXG4gICAgICAnICsgSlNPTi5zdHJpbmdpZnkoYWN0aW9uTmFtZSkgKyAnOiAnICsgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzdHIgKz0gc3JjQXJyYXkuam9pbignLCcpICsgJ1xcbiAgICB9KSc7XG4gICAgfSk7XG4gIH0pO1xuICBzdHIgKz0gJztcXG4gIH0pJztcblxuICBpZiAoIXNlbWFudGljc09ubHkpIHtcbiAgICBzdHIgPVxuICAgICAgJyhmdW5jdGlvbigpIHtcXG4nICtcbiAgICAgICcgIHZhciBncmFtbWFyID0gdGhpcy5mcm9tUmVjaXBlKCcgKyBqc29uVG9KUyh0aGlzLmdyYW1tYXIudG9SZWNpcGUoKSkgKyAnKTtcXG4nICtcbiAgICAgICcgIHZhciBzZW1hbnRpY3MgPSAnICsgc3RyICsgJyhncmFtbWFyKTtcXG4nICtcbiAgICAgICcgIHJldHVybiBzZW1hbnRpY3M7XFxuJyArXG4gICAgICAnfSk7XFxuJztcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHR5cGUpIHtcbiAgaWYgKCFwcm90b3R5cGVHcmFtbWFyKSB7XG4gICAgLy8gVGhlIE9wZXJhdGlvbnMgYW5kIEF0dHJpYnV0ZXMgZ3JhbW1hciB3b24ndCBiZSBhdmFpbGFibGUgd2hpbGUgT2htIGlzIGxvYWRpbmcsXG4gICAgLy8gYnV0IHdlIGNhbiBnZXQgYXdheSB0aGUgZm9sbG93aW5nIHNpbXBsaWZpY2F0aW9uIGIvYyBub25lIG9mIHRoZSBvcGVyYXRpb25zXG4gICAgLy8gdGhhdCBhcmUgdXNlZCB3aGlsZSBsb2FkaW5nIHRha2UgYXJndW1lbnRzLlxuICAgIGNvbW1vbi5hc3NlcnQoc2lnbmF0dXJlLmluZGV4T2YoJygnKSA9PT0gLTEpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBzaWduYXR1cmUsXG4gICAgICBmb3JtYWxzOiBbXVxuICAgIH07XG4gIH1cblxuICBjb25zdCByID0gcHJvdG90eXBlR3JhbW1hci5tYXRjaChcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHR5cGUgPT09ICdvcGVyYXRpb24nID8gJ09wZXJhdGlvblNpZ25hdHVyZScgOiAnQXR0cmlidXRlU2lnbmF0dXJlJyk7XG4gIGlmIChyLmZhaWxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHIubWVzc2FnZSk7XG4gIH1cblxuICByZXR1cm4gcHJvdG90eXBlR3JhbW1hclNlbWFudGljcyhyKS5wYXJzZSgpO1xufVxuXG5mdW5jdGlvbiBuZXdEZWZhdWx0QWN0aW9uKHR5cGUsIG5hbWUsIGRvSXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgdGhpc1RoaW5nID0gdGhpcy5fc2VtYW50aWNzLm9wZXJhdGlvbnNbbmFtZV0gfHwgdGhpcy5fc2VtYW50aWNzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgY29uc3QgYXJncyA9IHRoaXNUaGluZy5mb3JtYWxzLm1hcChmb3JtYWwgPT4gc2VsZi5hcmdzW2Zvcm1hbF0pO1xuXG4gICAgaWYgKHRoaXMuaXNJdGVyYXRpb24oKSkge1xuICAgICAgLy8gVGhpcyBDU1Qgbm9kZSBjb3JyZXNwb25kcyB0byBhbiBpdGVyYXRpb24gZXhwcmVzc2lvbiBpbiB0aGUgZ3JhbW1hciAoKiwgKywgb3IgPykuIFRoZVxuICAgICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyB0byBtYXAgdGhpcyBvcGVyYXRpb24gb3IgYXR0cmlidXRlIG92ZXIgYWxsIG9mIGl0cyBjaGlsZCBub2Rlcy5cbiAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoY2hpbGQgPT4gZG9JdC5hcHBseShjaGlsZCwgYXJncykpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgQ1NUIG5vZGUgY29ycmVzcG9uZHMgdG8gYSBub24tdGVybWluYWwgaW4gdGhlIGdyYW1tYXIgKGUuZy4sIEFkZEV4cHIpLiBUaGUgZmFjdCB0aGF0XG4gICAgLy8gd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGlzIGFjdGlvbiBkaWN0aW9uYXJ5IGRvZXNuJ3QgaGF2ZSBhbiBhY3Rpb24gZm9yIHRoaXMgcGFydGljdWxhclxuICAgIC8vIG5vbi10ZXJtaW5hbCBvciBhIGdlbmVyaWMgYF9ub250ZXJtaW5hbGAgYWN0aW9uLlxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIEFzIGEgY29udmVuaWVuY2UsIGlmIHRoaXMgbm9kZSBvbmx5IGhhcyBvbmUgY2hpbGQsIHdlIGp1c3QgcmV0dXJuIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vIGFwcGx5aW5nIHRoaXMgb3BlcmF0aW9uIC8gYXR0cmlidXRlIHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgcmV0dXJuIGRvSXQuYXBwbHkoY2hpbGRyZW5bMF0sIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHdlIHRocm93IGFuIGV4Y2VwdGlvbiB0byBsZXQgdGhlIHByb2dyYW1tZXIga25vdyB0aGF0IHdlIGRvbid0IGtub3cgd2hhdFxuICAgICAgLy8gdG8gZG8gd2l0aCB0aGlzIG5vZGUuXG4gICAgICB0aHJvdyBlcnJvcnMubWlzc2luZ1NlbWFudGljQWN0aW9uKHRoaXMuY3Rvck5hbWUsIG5hbWUsIHR5cGUsIGdsb2JhbEFjdGlvblN0YWNrKTtcbiAgICB9XG4gIH07XG59XG5cblNlbWFudGljcy5wcm90b3R5cGUuYWRkT3BlcmF0aW9uT3JBdHRyaWJ1dGUgPSBmdW5jdGlvbih0eXBlLCBzaWduYXR1cmUsIGFjdGlvbkRpY3QpIHtcbiAgY29uc3QgdHlwZVBsdXJhbCA9IHR5cGUgKyAncyc7XG5cbiAgY29uc3QgcGFyc2VkTmFtZUFuZEZvcm1hbEFyZ3MgPSBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHR5cGUpO1xuICBjb25zdCBuYW1lID0gcGFyc2VkTmFtZUFuZEZvcm1hbEFyZ3MubmFtZTtcbiAgY29uc3QgZm9ybWFscyA9IHBhcnNlZE5hbWVBbmRGb3JtYWxBcmdzLmZvcm1hbHM7XG5cbiAgLy8gVE9ETzogY2hlY2sgdGhhdCB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIGZvcm1hbCBhcmd1bWVudHNcblxuICB0aGlzLmFzc2VydE5ld05hbWUobmFtZSwgdHlwZSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBhY3Rpb24gZGljdGlvbmFyeSBmb3IgdGhpcyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUgdGhhdCBjb250YWlucyBhIGBfZGVmYXVsdGAgYWN0aW9uXG4gIC8vIHdoaWNoIGRlZmluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgaXRlcmF0aW9uLCB0ZXJtaW5hbCwgYW5kIG5vbi10ZXJtaW5hbCBub2Rlcy4uLlxuICBjb25zdCBidWlsdEluRGVmYXVsdCA9IG5ld0RlZmF1bHRBY3Rpb24odHlwZSwgbmFtZSwgZG9JdCk7XG4gIGNvbnN0IHJlYWxBY3Rpb25EaWN0ID0ge19kZWZhdWx0OiBidWlsdEluRGVmYXVsdH07XG4gIC8vIC4uLiBhbmQgYWRkIGluIHRoZSBhY3Rpb25zIHN1cHBsaWVkIGJ5IHRoZSBwcm9ncmFtbWVyLCB3aGljaCBtYXkgb3ZlcnJpZGUgc29tZSBvciBhbGwgb2YgdGhlXG4gIC8vIGRlZmF1bHQgb25lcy5cbiAgT2JqZWN0LmtleXMoYWN0aW9uRGljdCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICByZWFsQWN0aW9uRGljdFtuYW1lXSA9IGFjdGlvbkRpY3RbbmFtZV07XG4gIH0pO1xuXG4gIGNvbnN0IGVudHJ5ID0gdHlwZSA9PT0gJ29wZXJhdGlvbicgP1xuICAgICAgbmV3IE9wZXJhdGlvbihuYW1lLCBmb3JtYWxzLCByZWFsQWN0aW9uRGljdCwgYnVpbHRJbkRlZmF1bHQpIDpcbiAgICAgIG5ldyBBdHRyaWJ1dGUobmFtZSwgcmVhbEFjdGlvbkRpY3QsIGJ1aWx0SW5EZWZhdWx0KTtcblxuICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgKGl0IHdpbGwgaGFwcGVuIGxhdGVyIGFueXdheSkgYnV0IGl0J3MgYmV0dGVyIHRvXG4gIC8vIGNhdGNoIGVycm9ycyBlYXJseS5cbiAgZW50cnkuY2hlY2tBY3Rpb25EaWN0KHRoaXMuZ3JhbW1hcik7XG5cbiAgdGhpc1t0eXBlUGx1cmFsXVtuYW1lXSA9IGVudHJ5O1xuXG4gIGZ1bmN0aW9uIGRvSXQoKSB7XG4gICAgLy8gRGlzcGF0Y2ggdG8gbW9zdCBzcGVjaWZpYyB2ZXJzaW9uIG9mIHRoaXMgb3BlcmF0aW9uIC8gYXR0cmlidXRlIC0tIGl0IG1heSBoYXZlIGJlZW5cbiAgICAvLyBvdmVycmlkZGVuIGJ5IGEgc3ViLXNlbWFudGljcy5cbiAgICBjb25zdCB0aGlzVGhpbmcgPSB0aGlzLl9zZW1hbnRpY3NbdHlwZVBsdXJhbF1bbmFtZV07XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBjYWxsZXIgcGFzc2VkIHRoZSBjb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IHRoaXNUaGluZy5mb3JtYWxzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkIHRvICcgKyBuYW1lICsgJyAnICsgdHlwZSArICcgKGV4cGVjdGVkICcgK1xuICAgICAgICAgIHRoaXNUaGluZy5mb3JtYWxzLmxlbmd0aCArICcsIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcpJyk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIFwiYXJndW1lbnRzIG9iamVjdFwiIGZyb20gdGhlIGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoaXNcbiAgICAvLyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUuXG4gICAgY29uc3QgYXJncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYXJndW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IGZvcm1hbCA9IHRoaXNUaGluZy5mb3JtYWxzW2lkeF07XG4gICAgICBhcmdzW2Zvcm1hbF0gPSBhcmd1bWVudHNbaWR4XTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRBcmdzID0gdGhpcy5hcmdzO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgY29uc3QgYW5zID0gdGhpc1RoaW5nLmV4ZWN1dGUodGhpcy5fc2VtYW50aWNzLCB0aGlzKTtcbiAgICB0aGlzLmFyZ3MgPSBvbGRBcmdzO1xuICAgIHJldHVybiBhbnM7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ29wZXJhdGlvbicpIHtcbiAgICB0aGlzLldyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZG9JdDtcbiAgICB0aGlzLldyYXBwZXIucHJvdG90eXBlW25hbWVdLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1snICsgbmFtZSArICcgb3BlcmF0aW9uXSc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5XcmFwcGVyLnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBkb0l0LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlIC8vIFNvIHRoZSBwcm9wZXJ0eSBjYW4gYmUgZGVsZXRlZC5cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5hdHRyaWJ1dGVLZXlzLCBuYW1lLCB7XG4gICAgICB2YWx1ZTogdXRpbC51bmlxdWVJZChuYW1lKVxuICAgIH0pO1xuICB9XG59O1xuXG5TZW1hbnRpY3MucHJvdG90eXBlLmV4dGVuZE9wZXJhdGlvbk9yQXR0cmlidXRlID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgYWN0aW9uRGljdCkge1xuICBjb25zdCB0eXBlUGx1cmFsID0gdHlwZSArICdzJztcblxuICAvLyBNYWtlIHN1cmUgdGhhdCBgbmFtZWAgcmVhbGx5IGlzIGp1c3QgYSBuYW1lLCBpLmUuLCB0aGF0IGl0IGRvZXNuJ3QgYWxzbyBjb250YWluIGZvcm1hbHMuXG4gIHBhcnNlU2lnbmF0dXJlKG5hbWUsICdhdHRyaWJ1dGUnKTtcblxuICBpZiAoISh0aGlzLnN1cGVyICYmIG5hbWUgaW4gdGhpcy5zdXBlclt0eXBlUGx1cmFsXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICtcbiAgICAgICAgXCInOiBkaWQgbm90IGluaGVyaXQgYW4gXCIgKyB0eXBlICsgJyB3aXRoIHRoYXQgbmFtZScpO1xuICB9XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpc1t0eXBlUGx1cmFsXSwgbmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICsgXCInIGFnYWluXCIpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IG9wZXJhdGlvbiAvIGF0dHJpYnV0ZSB3aG9zZSBhY3Rpb25EaWN0IGRlbGVnYXRlcyB0byB0aGUgc3VwZXIgb3BlcmF0aW9uIC9cbiAgLy8gYXR0cmlidXRlJ3MgYWN0aW9uRGljdCwgYW5kIHdoaWNoIGhhcyBhbGwgdGhlIGtleXMgZnJvbSBgaW5oZXJpdGVkQWN0aW9uRGljdGAuXG4gIGNvbnN0IGluaGVyaXRlZEZvcm1hbHMgPSB0aGlzW3R5cGVQbHVyYWxdW25hbWVdLmZvcm1hbHM7XG4gIGNvbnN0IGluaGVyaXRlZEFjdGlvbkRpY3QgPSB0aGlzW3R5cGVQbHVyYWxdW25hbWVdLmFjdGlvbkRpY3Q7XG4gIGNvbnN0IG5ld0FjdGlvbkRpY3QgPSBPYmplY3QuY3JlYXRlKGluaGVyaXRlZEFjdGlvbkRpY3QpO1xuICBPYmplY3Qua2V5cyhhY3Rpb25EaWN0KS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIG5ld0FjdGlvbkRpY3RbbmFtZV0gPSBhY3Rpb25EaWN0W25hbWVdO1xuICB9KTtcblxuICB0aGlzW3R5cGVQbHVyYWxdW25hbWVdID0gdHlwZSA9PT0gJ29wZXJhdGlvbicgP1xuICAgICAgbmV3IE9wZXJhdGlvbihuYW1lLCBpbmhlcml0ZWRGb3JtYWxzLCBuZXdBY3Rpb25EaWN0KSA6XG4gICAgICBuZXcgQXR0cmlidXRlKG5hbWUsIG5ld0FjdGlvbkRpY3QpO1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgaXMgbm90IHN0cmljdGx5IG5lY2Vzc2FyeSAoaXQgd2lsbCBoYXBwZW4gbGF0ZXIgYW55d2F5KSBidXQgaXQncyBiZXR0ZXIgdG9cbiAgLy8gY2F0Y2ggZXJyb3JzIGVhcmx5LlxuICB0aGlzW3R5cGVQbHVyYWxdW25hbWVdLmNoZWNrQWN0aW9uRGljdCh0aGlzLmdyYW1tYXIpO1xufTtcblxuU2VtYW50aWNzLnByb3RvdHlwZS5hc3NlcnROZXdOYW1lID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICBpZiAoV3JhcHBlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgYWRkICcgKyB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJzogdGhhdCdzIGEgcmVzZXJ2ZWQgbmFtZVwiKTtcbiAgfVxuICBpZiAobmFtZSBpbiB0aGlzLm9wZXJhdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgYWRkICcgKyB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJzogYW4gb3BlcmF0aW9uIHdpdGggdGhhdCBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICB9XG4gIGlmIChuYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBhZGQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICsgXCInOiBhbiBhdHRyaWJ1dGUgd2l0aCB0aGF0IG5hbWUgYWxyZWFkeSBleGlzdHNcIik7XG4gIH1cbn07XG5cbi8vIFJldHVybnMgYSB3cmFwcGVyIGZvciB0aGUgZ2l2ZW4gQ1NUIGBub2RlYCBpbiB0aGlzIHNlbWFudGljcy5cbi8vIElmIGBub2RlYCBpcyBhbHJlYWR5IGEgd3JhcHBlciwgcmV0dXJucyBgbm9kZWAgaXRzZWxmLiAgLy8gVE9ETzogd2h5IGlzIHRoaXMgbmVlZGVkP1xuU2VtYW50aWNzLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24obm9kZSwgc291cmNlLCBvcHRCYXNlSW50ZXJ2YWwpIHtcbiAgY29uc3QgYmFzZUludGVydmFsID0gb3B0QmFzZUludGVydmFsIHx8IHNvdXJjZTtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0aGlzLldyYXBwZXIgPyBub2RlIDogbmV3IHRoaXMuV3JhcHBlcihub2RlLCBzb3VyY2UsIGJhc2VJbnRlcnZhbCk7XG59O1xuXG4vLyBDcmVhdGVzIGEgbmV3IFNlbWFudGljcyBpbnN0YW5jZSBmb3IgYGdyYW1tYXJgLCBpbmhlcml0aW5nIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgZnJvbVxuLy8gYG9wdFN1cGVyU2VtYW50aWNzYCwgaWYgaXQgaXMgc3BlY2lmaWVkLiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY3RzIGFzIGEgcHJveHkgZm9yIHRoZSBuZXdcbi8vIFNlbWFudGljcyBpbnN0YW5jZS4gV2hlbiB0aGF0IGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCBhIENTVCBub2RlIGFzIGFuIGFyZ3VtZW50LCBpdCByZXR1cm5zXG4vLyBhIHdyYXBwZXIgZm9yIHRoYXQgbm9kZSB3aGljaCBnaXZlcyBhY2Nlc3MgdG8gdGhlIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgcHJvdmlkZWQgYnkgdGhpc1xuLy8gc2VtYW50aWNzLlxuU2VtYW50aWNzLmNyZWF0ZVNlbWFudGljcyA9IGZ1bmN0aW9uKGdyYW1tYXIsIG9wdFN1cGVyU2VtYW50aWNzKSB7XG4gIGNvbnN0IHMgPSBuZXcgU2VtYW50aWNzKFxuICAgICAgZ3JhbW1hcixcbiAgICAgIG9wdFN1cGVyU2VtYW50aWNzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIG9wdFN1cGVyU2VtYW50aWNzIDpcbiAgICAgICAgICBTZW1hbnRpY3MuQnVpbHRJblNlbWFudGljcy5fZ2V0U2VtYW50aWNzKCkpO1xuXG4gIC8vIFRvIGVuYWJsZSBjbGllbnRzIHRvIGludm9rZSBhIHNlbWFudGljcyBsaWtlIGEgZnVuY3Rpb24sIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWN0cyBhcyBhIHByb3h5XG4gIC8vIGZvciBgc2AsIHdoaWNoIGlzIHRoZSByZWFsIGBTZW1hbnRpY3NgIGluc3RhbmNlLlxuICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIEFTZW1hbnRpY3MobWF0Y2hSZXN1bHQpIHtcbiAgICBpZiAoIShtYXRjaFJlc3VsdCBpbnN0YW5jZW9mIE1hdGNoUmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnU2VtYW50aWNzIGV4cGVjdGVkIGEgTWF0Y2hSZXN1bHQsIGJ1dCBnb3QgJyArIGNvbW1vbi51bmV4cGVjdGVkT2JqVG9TdHJpbmcobWF0Y2hSZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKG1hdGNoUmVzdWx0LmZhaWxlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwbHkgU2VtYW50aWNzIHRvICcgKyBtYXRjaFJlc3VsdC50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjc3QgPSBtYXRjaFJlc3VsdC5fY3N0O1xuICAgIGlmIChjc3QuZ3JhbW1hciAhPT0gZ3JhbW1hcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHVzZSBhIE1hdGNoUmVzdWx0IGZyb20gZ3JhbW1hciAnXCIgKyBjc3QuZ3JhbW1hci5uYW1lICtcbiAgICAgICAgICBcIicgd2l0aCBhIHNlbWFudGljcyBmb3IgJ1wiICsgZ3JhbW1hci5uYW1lICsgXCInXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFN0cmVhbSA9IG5ldyBJbnB1dFN0cmVhbShtYXRjaFJlc3VsdC5pbnB1dCk7XG4gICAgcmV0dXJuIHMud3JhcChjc3QsIGlucHV0U3RyZWFtLmludGVydmFsKG1hdGNoUmVzdWx0Ll9jc3RPZmZzZXQsIG1hdGNoUmVzdWx0LmlucHV0Lmxlbmd0aCkpO1xuICB9O1xuXG4gIC8vIEZvcndhcmQgcHVibGljIG1ldGhvZHMgZnJvbSB0aGUgcHJveHkgdG8gdGhlIHNlbWFudGljcyBpbnN0YW5jZS5cbiAgcHJveHkuYWRkT3BlcmF0aW9uID0gZnVuY3Rpb24oc2lnbmF0dXJlLCBhY3Rpb25EaWN0KSB7XG4gICAgcy5hZGRPcGVyYXRpb25PckF0dHJpYnV0ZSgnb3BlcmF0aW9uJywgc2lnbmF0dXJlLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5LmV4dGVuZE9wZXJhdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBzLmV4dGVuZE9wZXJhdGlvbk9yQXR0cmlidXRlKCdvcGVyYXRpb24nLCBuYW1lLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5LmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBzLmFkZE9wZXJhdGlvbk9yQXR0cmlidXRlKCdhdHRyaWJ1dGUnLCBuYW1lLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5LmV4dGVuZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgICBzLmV4dGVuZE9wZXJhdGlvbk9yQXR0cmlidXRlKCdhdHRyaWJ1dGUnLCBuYW1lLCBhY3Rpb25EaWN0KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHByb3h5Ll9nZXRBY3Rpb25EaWN0ID0gZnVuY3Rpb24ob3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgYWN0aW9uID0gcy5vcGVyYXRpb25zW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV0gfHwgcy5hdHRyaWJ1dGVzW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV07XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lICsgJ1wiIGlzIG5vdCBhIHZhbGlkIG9wZXJhdGlvbiBvciBhdHRyaWJ1dGUgJyArXG4gICAgICAgICduYW1lIGluIHRoaXMgc2VtYW50aWNzIGZvciBcIicgKyBncmFtbWFyLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbi5hY3Rpb25EaWN0O1xuICB9O1xuICBwcm94eS5fcmVtb3ZlID0gZnVuY3Rpb24ob3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lKSB7XG4gICAgbGV0IHNlbWFudGljO1xuICAgIGlmIChvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWUgaW4gcy5vcGVyYXRpb25zKSB7XG4gICAgICBzZW1hbnRpYyA9IHMub3BlcmF0aW9uc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgICAgZGVsZXRlIHMub3BlcmF0aW9uc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lIGluIHMuYXR0cmlidXRlcykge1xuICAgICAgc2VtYW50aWMgPSBzLmF0dHJpYnV0ZXNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGRlbGV0ZSBzLmF0dHJpYnV0ZXNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICB9XG4gICAgZGVsZXRlIHMuV3JhcHBlci5wcm90b3R5cGVbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICByZXR1cm4gc2VtYW50aWM7XG4gIH07XG4gIHByb3h5LmdldE9wZXJhdGlvbk5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMub3BlcmF0aW9ucyk7XG4gIH07XG4gIHByb3h5LmdldEF0dHJpYnV0ZU5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMuYXR0cmlidXRlcyk7XG4gIH07XG4gIHByb3h5LmdldEdyYW1tYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcy5ncmFtbWFyO1xuICB9O1xuICBwcm94eS50b1JlY2lwZSA9IGZ1bmN0aW9uKHNlbWFudGljc09ubHkpIHtcbiAgICByZXR1cm4gcy50b1JlY2lwZShzZW1hbnRpY3NPbmx5KTtcbiAgfTtcblxuICAvLyBNYWtlIHRoZSBwcm94eSdzIHRvU3RyaW5nKCkgd29yay5cbiAgcHJveHkudG9TdHJpbmcgPSBzLnRvU3RyaW5nLmJpbmQocyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgc2VtYW50aWNzIGZvciB0aGUgcHJveHkuXG4gIHByb3h5Ll9nZXRTZW1hbnRpY3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcztcbiAgfTtcblxuICByZXR1cm4gcHJveHk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBPcGVyYXRpb24gLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQW4gT3BlcmF0aW9uIHJlcHJlc2VudHMgYSBmdW5jdGlvbiB0byBiZSBhcHBsaWVkIHRvIGEgY29uY3JldGUgc3ludGF4IHRyZWUgKENTVCkgLS0gaXQncyB2ZXJ5XG4vLyBzaW1pbGFyIHRvIGEgVmlzaXRvciAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WaXNpdG9yX3BhdHRlcm4pLiBBbiBvcGVyYXRpb24gaXMgZXhlY3V0ZWQgYnlcbi8vIHJlY3Vyc2l2ZWx5IHdhbGtpbmcgdGhlIENTVCwgYW5kIGF0IGVhY2ggbm9kZSwgaW52b2tpbmcgdGhlIG1hdGNoaW5nIHNlbWFudGljIGFjdGlvbiBmcm9tXG4vLyBgYWN0aW9uRGljdGAuIFNlZSBgT3BlcmF0aW9uLnByb3RvdHlwZS5leGVjdXRlYCBmb3IgZGV0YWlscyBvZiBob3cgYSBDU1Qgbm9kZSdzIG1hdGNoaW5nIHNlbWFudGljXG4vLyBhY3Rpb24gaXMgZm91bmQuXG5jbGFzcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBmb3JtYWxzLCBhY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5mb3JtYWxzID0gZm9ybWFscztcbiAgICB0aGlzLmFjdGlvbkRpY3QgPSBhY3Rpb25EaWN0O1xuICAgIHRoaXMuYnVpbHRJbkRlZmF1bHQgPSBidWlsdEluRGVmYXVsdDtcbiAgfVxuXG4gIGNoZWNrQWN0aW9uRGljdChncmFtbWFyKSB7XG4gICAgZ3JhbW1hci5fY2hlY2tUb3BEb3duQWN0aW9uRGljdCh0aGlzLnR5cGVOYW1lLCB0aGlzLm5hbWUsIHRoaXMuYWN0aW9uRGljdCk7XG4gIH1cblxuICAvLyBFeGVjdXRlIHRoaXMgb3BlcmF0aW9uIG9uIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggYG5vZGVXcmFwcGVyYCBpbiB0aGUgY29udGV4dCBvZiB0aGVcbiAgLy8gZ2l2ZW4gU2VtYW50aWNzIGluc3RhbmNlLlxuICBleGVjdXRlKHNlbWFudGljcywgbm9kZVdyYXBwZXIpIHtcbiAgICB0cnkge1xuICAgICAgLy8gTG9vayBmb3IgYSBzZW1hbnRpYyBhY3Rpb24gd2hvc2UgbmFtZSBtYXRjaGVzIHRoZSBub2RlJ3MgY29uc3RydWN0b3IgbmFtZSwgd2hpY2ggaXMgZWl0aGVyXG4gICAgICAvLyB0aGUgbmFtZSBvZiBhIHJ1bGUgaW4gdGhlIGdyYW1tYXIsIG9yICdfdGVybWluYWwnIChmb3IgYSB0ZXJtaW5hbCBub2RlKSwgb3IgJ19pdGVyJyAoZm9yIGFuXG4gICAgICAvLyBpdGVyYXRpb24gbm9kZSkuIEluIHRoZSBsYXR0ZXIgY2FzZSwgdGhlIGFjdGlvbiBmdW5jdGlvbiByZWNlaXZlcyBhIHNpbmdsZSBhcmd1bWVudCwgd2hpY2hcbiAgICAgIC8vIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgQ1NUIG5vZGUuXG4gICAgICBjb25zdCBjdG9yTmFtZSA9IG5vZGVXcmFwcGVyLl9ub2RlLmN0b3JOYW1lO1xuICAgICAgbGV0IGFjdGlvbkZuID0gdGhpcy5hY3Rpb25EaWN0W2N0b3JOYW1lXTtcbiAgICAgIGxldCBhbnM7XG4gICAgICBpZiAoYWN0aW9uRm4pIHtcbiAgICAgICAgZ2xvYmFsQWN0aW9uU3RhY2sucHVzaChbdGhpcywgY3Rvck5hbWVdKTtcbiAgICAgICAgYW5zID0gdGhpcy5kb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCBhY3Rpb25Gbiwgbm9kZVdyYXBwZXIuaXNJdGVyYXRpb24oKSk7XG4gICAgICAgIHJldHVybiBhbnM7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBhY3Rpb24gZGljdGlvbmFyeSBkb2VzIG5vdCBjb250YWluIGEgc2VtYW50aWMgYWN0aW9uIGZvciB0aGlzIHNwZWNpZmljIHR5cGUgb2Ygbm9kZS5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBub250ZXJtaW5hbCBub2RlIGFuZCB0aGUgcHJvZ3JhbW1lciBoYXMgcHJvdmlkZWQgYSBgX25vbnRlcm1pbmFsYCBzZW1hbnRpY1xuICAgICAgLy8gYWN0aW9uLCB3ZSBpbnZva2UgaXQ6XG4gICAgICBpZiAobm9kZVdyYXBwZXIuaXNOb250ZXJtaW5hbCgpKSB7XG4gICAgICAgIGFjdGlvbkZuID0gdGhpcy5hY3Rpb25EaWN0Ll9ub250ZXJtaW5hbDtcbiAgICAgICAgaWYgKGFjdGlvbkZuKSB7XG4gICAgICAgICAgZ2xvYmFsQWN0aW9uU3RhY2sucHVzaChbdGhpcywgJ19ub250ZXJtaW5hbCcsIGN0b3JOYW1lXSk7XG4gICAgICAgICAgYW5zID0gdGhpcy5kb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCBhY3Rpb25GbiwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIGFucztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGludm9rZSB0aGUgJ19kZWZhdWx0JyBzZW1hbnRpYyBhY3Rpb24uXG4gICAgICBnbG9iYWxBY3Rpb25TdGFjay5wdXNoKFt0aGlzLCAnZGVmYXVsdCBhY3Rpb24nLCBjdG9yTmFtZV0pO1xuICAgICAgYW5zID0gdGhpcy5kb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCB0aGlzLmFjdGlvbkRpY3QuX2RlZmF1bHQsIHRydWUpO1xuICAgICAgcmV0dXJuIGFucztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZ2xvYmFsQWN0aW9uU3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlIGBhY3Rpb25GbmAgb24gdGhlIENTVCBub2RlIHRoYXQgY29ycmVzcG9uZHMgdG8gYG5vZGVXcmFwcGVyYCwgaW4gdGhlIGNvbnRleHQgb2ZcbiAgLy8gYHNlbWFudGljc2AuIElmIGBvcHRQYXNzQ2hpbGRyZW5Bc0FycmF5YCBpcyB0cnV0aHksIGBhY3Rpb25GbmAgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZVxuICAvLyBhcmd1bWVudCwgd2hpY2ggaXMgYW4gYXJyYXkgb2Ygd3JhcHBlcnMuIE90aGVyd2lzZSwgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYGFjdGlvbkZuYCB3aWxsXG4gIC8vIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhlIENTVCBub2RlLlxuICBkb0FjdGlvbihzZW1hbnRpY3MsIG5vZGVXcmFwcGVyLCBhY3Rpb25Gbiwgb3B0UGFzc0NoaWxkcmVuQXNBcnJheSkge1xuICAgIHJldHVybiBvcHRQYXNzQ2hpbGRyZW5Bc0FycmF5ID9cbiAgICAgICAgYWN0aW9uRm4uY2FsbChub2RlV3JhcHBlciwgbm9kZVdyYXBwZXIuX2NoaWxkcmVuKCkpIDpcbiAgICAgICAgYWN0aW9uRm4uYXBwbHkobm9kZVdyYXBwZXIsIG5vZGVXcmFwcGVyLl9jaGlsZHJlbigpKTtcbiAgfVxufVxuXG5PcGVyYXRpb24ucHJvdG90eXBlLnR5cGVOYW1lID0gJ29wZXJhdGlvbic7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIEF0dHJpYnV0ZSAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBdHRyaWJ1dGVzIGFyZSBPcGVyYXRpb25zIHdob3NlIHJlc3VsdHMgYXJlIG1lbW9pemVkLiBUaGlzIG1lYW5zIHRoYXQsIGZvciBhbnkgZ2l2ZW4gc2VtYW50aWNzLFxuLy8gdGhlIHNlbWFudGljIGFjdGlvbiBmb3IgYSBDU1Qgbm9kZSB3aWxsIGJlIGludm9rZWQgbm8gbW9yZSB0aGFuIG9uY2UuXG5jbGFzcyBBdHRyaWJ1dGUgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBhY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCkge1xuICAgIHN1cGVyKG5hbWUsIFtdLCBhY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCk7XG4gIH1cblxuICBleGVjdXRlKHNlbWFudGljcywgbm9kZVdyYXBwZXIpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZVdyYXBwZXIuX25vZGU7XG4gICAgY29uc3Qga2V5ID0gc2VtYW50aWNzLmF0dHJpYnV0ZUtleXNbdGhpcy5uYW1lXTtcbiAgICBpZiAoIW5vZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIHN1cGVyLXNlbmQgLS0gaXNuJ3QgSlMgYmVhdXRpZnVsPyA6L1xuICAgICAgbm9kZVtrZXldID0gT3BlcmF0aW9uLnByb3RvdHlwZS5leGVjdXRlLmNhbGwodGhpcywgc2VtYW50aWNzLCBub2RlV3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiBub2RlW2tleV07XG4gIH1cbn1cblxuQXR0cmlidXRlLnByb3RvdHlwZS50eXBlTmFtZSA9ICdhdHRyaWJ1dGUnO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIERlZmVycmVkIGluaXRpYWxpemF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tXG5cbnV0aWwuYXdhaXRCdWlsdEluUnVsZXMoYnVpbHRJblJ1bGVzID0+IHtcbiAgY29uc3Qgb3BlcmF0aW9uc0FuZEF0dHJpYnV0ZXNHcmFtbWFyID0gcmVxdWlyZSgnLi4vZGlzdC9vcGVyYXRpb25zLWFuZC1hdHRyaWJ1dGVzJyk7XG4gIGluaXRCdWlsdEluU2VtYW50aWNzKGJ1aWx0SW5SdWxlcyk7XG4gIGluaXRQcm90b3R5cGVQYXJzZXIob3BlcmF0aW9uc0FuZEF0dHJpYnV0ZXNHcmFtbWFyKTsgLy8gcmVxdWlyZXMgQnVpbHRJblNlbWFudGljc1xufSk7XG5cbmZ1bmN0aW9uIGluaXRCdWlsdEluU2VtYW50aWNzKGJ1aWx0SW5SdWxlcykge1xuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIGVtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0aW9uKCk7XG4gICAgfSxcbiAgICBub25FbXB0eShmaXJzdCwgXywgcmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0aW9uKFtmaXJzdF0uY29uY2F0KHJlc3QuY2hpbGRyZW4pKTtcbiAgICB9XG4gIH07XG5cbiAgU2VtYW50aWNzLkJ1aWx0SW5TZW1hbnRpY3MgPSBTZW1hbnRpY3NcbiAgICAgIC5jcmVhdGVTZW1hbnRpY3MoYnVpbHRJblJ1bGVzLCBudWxsKVxuICAgICAgLmFkZE9wZXJhdGlvbignYXNJdGVyYXRpb24nLCB7XG4gICAgICAgIGVtcHR5TGlzdE9mOiBhY3Rpb25zLmVtcHR5LFxuICAgICAgICBub25lbXB0eUxpc3RPZjogYWN0aW9ucy5ub25FbXB0eSxcbiAgICAgICAgRW1wdHlMaXN0T2Y6IGFjdGlvbnMuZW1wdHksXG4gICAgICAgIE5vbmVtcHR5TGlzdE9mOiBhY3Rpb25zLm5vbkVtcHR5XG4gICAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3RvdHlwZVBhcnNlcihncmFtbWFyKSB7XG4gIHByb3RvdHlwZUdyYW1tYXJTZW1hbnRpY3MgPSBncmFtbWFyLmNyZWF0ZVNlbWFudGljcygpLmFkZE9wZXJhdGlvbigncGFyc2UnLCB7XG4gICAgQXR0cmlidXRlU2lnbmF0dXJlKG5hbWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUucGFyc2UoKSxcbiAgICAgICAgZm9ybWFsczogW11cbiAgICAgIH07XG4gICAgfSxcbiAgICBPcGVyYXRpb25TaWduYXR1cmUobmFtZSwgb3B0Rm9ybWFscykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZS5wYXJzZSgpLFxuICAgICAgICBmb3JtYWxzOiBvcHRGb3JtYWxzLnBhcnNlKClbMF0gfHwgW11cbiAgICAgIH07XG4gICAgfSxcbiAgICBGb3JtYWxzKG9wYXJlbiwgZnMsIGNwYXJlbikge1xuICAgICAgcmV0dXJuIGZzLmFzSXRlcmF0aW9uKCkucGFyc2UoKTtcbiAgICB9LFxuICAgIG5hbWUoZmlyc3QsIHJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVN0cmluZztcbiAgICB9XG4gIH0pO1xuICBwcm90b3R5cGVHcmFtbWFyID0gZ3JhbW1hcjtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbWFudGljcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEludGVydmFsID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGFyZSB1c2VkIGluIHRoZSBgdG9TdHJpbmdgIG91dHB1dC5cbmNvbnN0IEJBTExPVF9YID0gJ1xcdTI3MTcnO1xuY29uc3QgQ0hFQ0tfTUFSSyA9ICdcXHUyNzEzJztcbmNvbnN0IERPVF9PUEVSQVRPUiA9ICdcXHUyMkM1JztcbmNvbnN0IFJJR0hUV0FSRFNfRE9VQkxFX0FSUk9XID0gJ1xcdTIxRDInO1xuY29uc3QgU1lNQk9MX0ZPUl9IT1JJWk9OVEFMX1RBQlVMQVRJT04gPSAnXFx1MjQwOSc7XG5jb25zdCBTWU1CT0xfRk9SX0xJTkVfRkVFRCA9ICdcXHUyNDBBJztcbmNvbnN0IFNZTUJPTF9GT1JfQ0FSUklBR0VfUkVUVVJOID0gJ1xcdTI0MEQnO1xuXG5jb25zdCBGbGFncyA9IHtcbiAgc3VjY2VlZGVkOiAxIDw8IDAsXG4gIGlzUm9vdE5vZGU6IDEgPDwgMSxcbiAgaXNJbXBsaWNpdFNwYWNlczogMSA8PCAyLFxuICBpc01lbW9pemVkOiAxIDw8IDMsXG4gIGlzSGVhZE9mTGVmdFJlY3Vyc2lvbjogMSA8PCA0LFxuICB0ZXJtaW5hdGVzTFI6IDEgPDwgNVxufTtcblxuZnVuY3Rpb24gc3BhY2VzKG4pIHtcbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBuKS5qb2luKCcnKTtcbn1cblxuLy8gUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcG9ydGlvbiBvZiBgaW5wdXRgIGF0IG9mZnNldCBgcG9zYC5cbi8vIFRoZSByZXN1bHQgd2lsbCBjb250YWluIGV4YWN0bHkgYGxlbmAgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIGdldElucHV0RXhjZXJwdChpbnB1dCwgcG9zLCBsZW4pIHtcbiAgY29uc3QgZXhjZXJwdCA9IGFzRXNjYXBlZFN0cmluZyhpbnB1dC5zbGljZShwb3MsIHBvcyArIGxlbikpO1xuXG4gIC8vIFBhZCB0aGUgb3V0cHV0IGlmIG5lY2Vzc2FyeS5cbiAgaWYgKGV4Y2VycHQubGVuZ3RoIDwgbGVuKSB7XG4gICAgcmV0dXJuIGV4Y2VycHQgKyBjb21tb24ucmVwZWF0KCcgJywgbGVuIC0gZXhjZXJwdC5sZW5ndGgpLmpvaW4oJycpO1xuICB9XG4gIHJldHVybiBleGNlcnB0O1xufVxuXG5mdW5jdGlvbiBhc0VzY2FwZWRTdHJpbmcob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFJlcGxhY2Ugbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzIHdpdGggdmlzaWJsZSBzeW1ib2xzLlxuICAgIHJldHVybiBvYmpcbiAgICAgICAgLnJlcGxhY2UoLyAvZywgRE9UX09QRVJBVE9SKVxuICAgICAgICAucmVwbGFjZSgvXFx0L2csIFNZTUJPTF9GT1JfSE9SSVpPTlRBTF9UQUJVTEFUSU9OKVxuICAgICAgICAucmVwbGFjZSgvXFxuL2csIFNZTUJPTF9GT1JfTElORV9GRUVEKVxuICAgICAgICAucmVwbGFjZSgvXFxyL2csIFNZTUJPTF9GT1JfQ0FSUklBR0VfUkVUVVJOKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIFRyYWNlIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIFRyYWNlKGlucHV0LCBwb3MxLCBwb3MyLCBleHByLCBzdWNjZWVkZWQsIGJpbmRpbmdzLCBvcHRDaGlsZHJlbikge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MxID0gcG9zMTtcbiAgdGhpcy5wb3MyID0gcG9zMjtcbiAgdGhpcy5zb3VyY2UgPSBuZXcgSW50ZXJ2YWwoaW5wdXQsIHBvczEsIHBvczIpO1xuICB0aGlzLmV4cHIgPSBleHByO1xuICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gIHRoaXMuY2hpbGRyZW4gPSBvcHRDaGlsZHJlbiB8fCBbXTtcbiAgdGhpcy50ZXJtaW5hdGluZ0xSRW50cnkgPSBudWxsO1xuXG4gIHRoaXMuX2ZsYWdzID0gc3VjY2VlZGVkID8gRmxhZ3Muc3VjY2VlZGVkIDogMDtcbn1cblxuLy8gQSB2YWx1ZSB0aGF0IGNhbiBiZSByZXR1cm5lZCBmcm9tIHZpc2l0b3IgZnVuY3Rpb25zIHRvIGluZGljYXRlIHRoYXQgYVxuLy8gbm9kZSBzaG91bGQgbm90IGJlIHJlY3Vyc2VkIGludG8uXG5UcmFjZS5wcm90b3R5cGUuU0tJUCA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2UucHJvdG90eXBlLCAnZGlzcGxheVN0cmluZycsIHtcbiAgZ2V0KCkgeyByZXR1cm4gdGhpcy5leHByLnRvRGlzcGxheVN0cmluZygpOyB9XG59KTtcblxuLy8gRm9yIGNvbnZlbmllbmNlLCBjcmVhdGUgYSBnZXR0ZXIgYW5kIHNldHRlciBmb3IgdGhlIGJvb2xlYW4gZmxhZ3MgaW4gYEZsYWdzYC5cbk9iamVjdC5rZXlzKEZsYWdzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICBjb25zdCBtYXNrID0gRmxhZ3NbbmFtZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFjZS5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgbWFzaykgIT09IDA7XG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzIHw9IG1hc2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mbGFncyAmPSB+bWFzaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSk7XG5cblRyYWNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jbG9uZVdpdGhFeHByKHRoaXMuZXhwcik7XG59O1xuXG5UcmFjZS5wcm90b3R5cGUuY2xvbmVXaXRoRXhwciA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgY29uc3QgYW5zID0gbmV3IFRyYWNlKFxuICAgICAgdGhpcy5pbnB1dCwgdGhpcy5wb3MsIHRoaXMucG9zMiwgZXhwciwgdGhpcy5zdWNjZWVkZWQsIHRoaXMuYmluZGluZ3MsIHRoaXMuY2hpbGRyZW4pO1xuXG4gIGFucy5pc0hlYWRPZkxlZnRSZWN1cnNpb24gPSB0aGlzLmlzSGVhZE9mTGVmdFJlY3Vyc2lvbjtcbiAgYW5zLmlzSW1wbGljaXRTcGFjZXMgPSB0aGlzLmlzSW1wbGljaXRTcGFjZXM7XG4gIGFucy5pc01lbW9pemVkID0gdGhpcy5pc01lbW9pemVkO1xuICBhbnMuaXNSb290Tm9kZSA9IHRoaXMuaXNSb290Tm9kZTtcbiAgYW5zLnRlcm1pbmF0ZXNMUiA9IHRoaXMudGVybWluYXRlc0xSO1xuICBhbnMudGVybWluYXRpbmdMUkVudHJ5ID0gdGhpcy50ZXJtaW5hdGluZ0xSRW50cnk7XG4gIHJldHVybiBhbnM7XG59O1xuXG4vLyBSZWNvcmQgdGhlIHRyYWNlIGluZm9ybWF0aW9uIGZvciB0aGUgdGVybWluYXRpbmcgY29uZGl0aW9uIG9mIHRoZSBMUiBsb29wLlxuVHJhY2UucHJvdG90eXBlLnJlY29yZExSVGVybWluYXRpb24gPSBmdW5jdGlvbihydWxlQm9keVRyYWNlLCB2YWx1ZSkge1xuICB0aGlzLnRlcm1pbmF0aW5nTFJFbnRyeSA9XG4gICAgICBuZXcgVHJhY2UodGhpcy5pbnB1dCwgdGhpcy5wb3MsIHRoaXMucG9zMiwgdGhpcy5leHByLCBmYWxzZSwgW3ZhbHVlXSwgW3J1bGVCb2R5VHJhY2VdKTtcbiAgdGhpcy50ZXJtaW5hdGluZ0xSRW50cnkudGVybWluYXRlc0xSID0gdHJ1ZTtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoaXMgdHJhY2Ugbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kZW50cywgY2FsbGluZyBhIHZpc2l0b3IgZnVuY3Rpb25cbi8vIGZvciBlYWNoIG5vZGUgdGhhdCBpcyB2aXNpdGVkLiBJZiBgdmlzdG9yT2JqT3JGbmAgaXMgYW4gb2JqZWN0LCB0aGVuIGl0cyAnZW50ZXInIHByb3BlcnR5XG4vLyBpcyBhIGZ1bmN0aW9uIHRvIGNhbGwgYmVmb3JlIHZpc2l0aW5nIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUsIGFuZCBpdHMgJ2V4aXQnIHByb3BlcnR5IGlzXG4vLyBhIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXJ3YXJkcy4gSWYgYHZpc2l0b3JPYmpPckZuYCBpcyBhIGZ1bmN0aW9uLCBpdCByZXByZXNlbnRzIHRoZSAnZW50ZXInXG4vLyBmdW5jdGlvbi5cbi8vXG4vLyBUaGUgZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IHRoZSBUcmFjZSBub2RlLCBpdHMgcGFyZW50IFRyYWNlLCBhbmQgYSBudW1iZXJcbi8vIHJlcHJlc2VudGluZyB0aGUgZGVwdGggb2YgdGhlIG5vZGUgaW4gdGhlIHRyZWUuIChUaGUgcm9vdCBub2RlIGhhcyBkZXB0aCAwLikgYG9wdFRoaXNBcmdgLCBpZlxuLy8gc3BlY2lmaWVkLCBpcyB0aGUgdmFsdWUgdG8gdXNlIGZvciBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHZpc2l0b3IgZnVuY3Rpb25zLlxuVHJhY2UucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbih2aXNpdG9yT2JqT3JGbiwgb3B0VGhpc0FyZykge1xuICBsZXQgdmlzaXRvciA9IHZpc2l0b3JPYmpPckZuO1xuICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2aXNpdG9yID0ge2VudGVyOiB2aXNpdG9yfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF93YWxrKG5vZGUsIHBhcmVudCwgZGVwdGgpIHtcbiAgICBsZXQgcmVjdXJzZSA9IHRydWU7XG4gICAgaWYgKHZpc2l0b3IuZW50ZXIpIHtcbiAgICAgIGlmICh2aXNpdG9yLmVudGVyLmNhbGwob3B0VGhpc0FyZywgbm9kZSwgcGFyZW50LCBkZXB0aCkgPT09IFRyYWNlLnByb3RvdHlwZS5TS0lQKSB7XG4gICAgICAgIHJlY3Vyc2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIF93YWxrKGNoaWxkLCBub2RlLCBkZXB0aCArIDEpO1xuICAgICAgfSk7XG4gICAgICBpZiAodmlzaXRvci5leGl0KSB7XG4gICAgICAgIHZpc2l0b3IuZXhpdC5jYWxsKG9wdFRoaXNBcmcsIG5vZGUsIHBhcmVudCwgZGVwdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodGhpcy5pc1Jvb3ROb2RlKSB7XG4gICAgLy8gRG9uJ3QgdmlzaXQgdGhlIHJvb3Qgbm9kZSBpdHNlbGYsIG9ubHkgaXRzIGNoaWxkcmVuLlxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjID0+IHsgX3dhbGsoYywgbnVsbCwgMCk7IH0pO1xuICB9IGVsc2Uge1xuICAgIF93YWxrKHRoaXMsIG51bGwsIDApO1xuICB9XG59O1xuXG4vLyBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYWNlLlxuLy8gU2FtcGxlOlxuLy8gICAgIDEy4ouFK+KLhTLii4Uq4ouFMyDinJMgZXhwIOKHkiAgXCIxMlwiXG4vLyAgICAgMTLii4Ur4ouFMuKLhSrii4UzICAg4pyTIGFkZEV4cCAoTFIpIOKHkiAgXCIxMlwiXG4vLyAgICAgMTLii4Ur4ouFMuKLhSrii4UzICAgICAgIOKclyBhZGRFeHBfcGx1c1xuVHJhY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNiID0gbmV3IGNvbW1vbi5TdHJpbmdCdWZmZXIoKTtcbiAgdGhpcy53YWxrKChub2RlLCBwYXJlbnQsIGRlcHRoKSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5TS0lQO1xuICAgIH1cbiAgICBjb25zdCBjdG9yTmFtZSA9IG5vZGUuZXhwci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIC8vIERvbid0IHByaW50IGFueXRoaW5nIGZvciBBbHQgbm9kZXMuXG4gICAgaWYgKGN0b3JOYW1lID09PSAnQWx0Jykge1xuICAgICAgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgfVxuICAgIHNiLmFwcGVuZChnZXRJbnB1dEV4Y2VycHQobm9kZS5pbnB1dCwgbm9kZS5wb3MsIDEwKSArIHNwYWNlcyhkZXB0aCAqIDIgKyAxKSk7XG4gICAgc2IuYXBwZW5kKChub2RlLnN1Y2NlZWRlZCA/IENIRUNLX01BUksgOiBCQUxMT1RfWCkgKyAnICcgKyBub2RlLmRpc3BsYXlTdHJpbmcpO1xuICAgIGlmIChub2RlLmlzSGVhZE9mTGVmdFJlY3Vyc2lvbikge1xuICAgICAgc2IuYXBwZW5kKCcgKExSKScpO1xuICAgIH1cbiAgICBpZiAobm9kZS5zdWNjZWVkZWQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXNFc2NhcGVkU3RyaW5nKG5vZGUuc291cmNlLmNvbnRlbnRzKTtcbiAgICAgIHNiLmFwcGVuZCgnICcgKyBSSUdIVFdBUkRTX0RPVUJMRV9BUlJPVyArICcgICcpO1xuICAgICAgc2IuYXBwZW5kKHR5cGVvZiBjb250ZW50cyA9PT0gJ3N0cmluZycgPyAnXCInICsgY29udGVudHMgKyAnXCInIDogY29udGVudHMpO1xuICAgIH1cbiAgICBzYi5hcHBlbmQoJ1xcbicpO1xuICB9KTtcbiAgcmV0dXJuIHNiLmNvbnRlbnRzKCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3V0aWwtZXh0ZW5kJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIFN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBIZWxwZXJzXG5cbmNvbnN0IGVzY2FwZVN0cmluZ0ZvciA9IHt9O1xuZm9yIChsZXQgYyA9IDA7IGMgPCAxMjg7IGMrKykge1xuICBlc2NhcGVTdHJpbmdGb3JbY10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuZXNjYXBlU3RyaW5nRm9yW1wiJ1wiLmNoYXJDb2RlQXQoMCldID0gXCJcXFxcJ1wiO1xuZXNjYXBlU3RyaW5nRm9yWydcIicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXFwiJztcbmVzY2FwZVN0cmluZ0ZvclsnXFxcXCcuY2hhckNvZGVBdCgwKV0gPSAnXFxcXFxcXFwnO1xuZXNjYXBlU3RyaW5nRm9yWydcXGInLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxiJztcbmVzY2FwZVN0cmluZ0ZvclsnXFxmJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcZic7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcbicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXG4nO1xuZXNjYXBlU3RyaW5nRm9yWydcXHInLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxyJztcbmVzY2FwZVN0cmluZ0ZvclsnXFx0Jy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcdCc7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcdTAwMGInLmNoYXJDb2RlQXQoMCldID0gJ1xcXFx2JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMuYWJzdHJhY3QgPSBmdW5jdGlvbihvcHRNZXRob2ROYW1lKSB7XG4gIGNvbnN0IG1ldGhvZE5hbWUgPSBvcHRNZXRob2ROYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndGhpcyBtZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnIGlzIGFic3RyYWN0ISAnICtcbiAgICAgICcoaXQgaGFzIG5vIGltcGxlbWVudGF0aW9uIGluIGNsYXNzICcgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnKScpO1xuICB9O1xufTtcblxuZXhwb3J0cy5hc3NlcnQgPSBmdW5jdGlvbihjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGEgbGF6aWx5LWNvbXB1dGVkLCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lZCBgcHJvcE5hbWVgXG4vLyBvbiB0aGUgb2JqZWN0IGBvYmpgLiBgZ2V0dGVyRm5gIHdpbGwgYmUgY2FsbGVkIHRvIGNvbXB1dGUgdGhlIHZhbHVlIHRoZVxuLy8gZmlyc3QgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQuXG5leHBvcnRzLmRlZmluZUxhenlQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcE5hbWUsIGdldHRlckZuKSB7XG4gIGxldCBtZW1vO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wTmFtZSwge1xuICAgIGdldCgpIHtcbiAgICAgIGlmICghbWVtbykge1xuICAgICAgICBtZW1vID0gZ2V0dGVyRm4uY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmopIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBvYmopO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblxuZXhwb3J0cy5yZXBlYXRGbiA9IGZ1bmN0aW9uKGZuLCBuKSB7XG4gIGNvbnN0IGFyciA9IFtdO1xuICB3aGlsZSAobi0tID4gMCkge1xuICAgIGFyci5wdXNoKGZuKCkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5leHBvcnRzLnJlcGVhdFN0ciA9IGZ1bmN0aW9uKHN0ciwgbikge1xuICByZXR1cm4gbmV3IEFycmF5KG4gKyAxKS5qb2luKHN0cik7XG59O1xuXG5leHBvcnRzLnJlcGVhdCA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgcmV0dXJuIGV4cG9ydHMucmVwZWF0Rm4oKCkgPT4geCwgbik7XG59O1xuXG5leHBvcnRzLmdldER1cGxpY2F0ZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICBjb25zdCBkdXBsaWNhdGVzID0gW107XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFycmF5Lmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCB4ID0gYXJyYXlbaWR4XTtcbiAgICBpZiAoYXJyYXkubGFzdEluZGV4T2YoeCkgIT09IGlkeCAmJiBkdXBsaWNhdGVzLmluZGV4T2YoeCkgPCAwKSB7XG4gICAgICBkdXBsaWNhdGVzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXBsaWNhdGVzO1xufTtcblxuZXhwb3J0cy5jb3B5V2l0aG91dER1cGxpY2F0ZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICBjb25zdCBub0R1cGxpY2F0ZXMgPSBbXTtcbiAgYXJyYXkuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgaWYgKG5vRHVwbGljYXRlcy5pbmRleE9mKGVudHJ5KSA8IDApIHtcbiAgICAgIG5vRHVwbGljYXRlcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9EdXBsaWNhdGVzO1xufTtcblxuZXhwb3J0cy5pc1N5bnRhY3RpYyA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGZpcnN0Q2hhciA9IHJ1bGVOYW1lWzBdO1xuICByZXR1cm4gZmlyc3RDaGFyID09PSBmaXJzdENoYXIudG9VcHBlckNhc2UoKTtcbn07XG5cbmV4cG9ydHMuaXNMZXhpY2FsID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgcmV0dXJuICFleHBvcnRzLmlzU3ludGFjdGljKHJ1bGVOYW1lKTtcbn07XG5cbmV4cG9ydHMucGFkTGVmdCA9IGZ1bmN0aW9uKHN0ciwgbGVuLCBvcHRDaGFyKSB7XG4gIGNvbnN0IGNoID0gb3B0Q2hhciB8fCAnICc7XG4gIGlmIChzdHIubGVuZ3RoIDwgbGVuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmVwZWF0U3RyKGNoLCBsZW4gLSBzdHIubGVuZ3RoKSArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuLy8gU3RyaW5nQnVmZmVyXG5cbmV4cG9ydHMuU3RyaW5nQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RyaW5ncyA9IFtdO1xufTtcblxuZXhwb3J0cy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLnN0cmluZ3MucHVzaChzdHIpO1xufTtcblxuZXhwb3J0cy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbnRlbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN0cmluZ3Muam9pbignJyk7XG59O1xuXG4vLyBDaGFyYWN0ZXIgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmdcblxuZXhwb3J0cy5lc2NhcGVDaGFyID0gZnVuY3Rpb24oYywgb3B0RGVsaW0pIHtcbiAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gIGlmICgoYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIikgJiYgb3B0RGVsaW0gJiYgYyAhPT0gb3B0RGVsaW0pIHtcbiAgICByZXR1cm4gYztcbiAgfSBlbHNlIGlmIChjaGFyQ29kZSA8IDEyOCkge1xuICAgIHJldHVybiBlc2NhcGVTdHJpbmdGb3JbY2hhckNvZGVdO1xuICB9IGVsc2UgaWYgKDEyOCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8IDI1Nikge1xuICAgIHJldHVybiAnXFxcXHgnICsgZXhwb3J0cy5wYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KSwgMiwgJzAnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ1xcXFx1JyArIGV4cG9ydHMucGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNiksIDQsICcwJyk7XG4gIH1cbn07XG5cbmV4cG9ydHMudW5lc2NhcGVDaGFyID0gZnVuY3Rpb24ocykge1xuICBpZiAocy5jaGFyQXQoMCkgPT09ICdcXFxcJykge1xuICAgIHN3aXRjaCAocy5jaGFyQXQoMSkpIHtcbiAgICAgIGNhc2UgJ2InOiByZXR1cm4gJ1xcYic7XG4gICAgICBjYXNlICdmJzogcmV0dXJuICdcXGYnO1xuICAgICAgY2FzZSAnbic6IHJldHVybiAnXFxuJztcbiAgICAgIGNhc2UgJ3InOiByZXR1cm4gJ1xccic7XG4gICAgICBjYXNlICd0JzogcmV0dXJuICdcXHQnO1xuICAgICAgY2FzZSAndic6IHJldHVybiAnXFx2JztcbiAgICAgIGNhc2UgJ3gnOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzLnN1YnN0cmluZygyLCA0KSwgMTYpKTtcbiAgICAgIGNhc2UgJ3UnOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzLnN1YnN0cmluZygyLCA2KSwgMTYpKTtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBzLmNoYXJBdCgxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmb3IgcHJvZHVjaW5nIGEgZGVzY3JpcHRpb24gb2YgYW4gdW5rbm93biBvYmplY3QgaW4gYSBzYWZlIHdheS5cbi8vIEVzcGVjaWFsbHkgdXNlZnVsIGZvciBlcnJvciBtZXNzYWdlcyB3aGVyZSBhbiB1bmV4cGVjdGVkIHR5cGUgb2Ygb2JqZWN0IHdhcyBlbmNvdW50ZXJlZC5cbmV4cG9ydHMudW5leHBlY3RlZE9ialRvU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbiAgfVxuICBjb25zdCBiYXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgdHJ5IHtcbiAgICBsZXQgdHlwZU5hbWU7XG4gICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgdHlwZU5hbWUgPSBvYmouY29uc3RydWN0b3IubmFtZTtcbiAgICB9IGVsc2UgaWYgKGJhc2VUb1N0cmluZy5pbmRleE9mKCdbb2JqZWN0ICcpID09PSAwKSB7XG4gICAgICB0eXBlTmFtZSA9IGJhc2VUb1N0cmluZy5zbGljZSg4LCAtMSk7IC8vIEV4dHJhY3QgZS5nLiBcIkFycmF5XCIgZnJvbSBcIltvYmplY3QgQXJyYXldXCIuXG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOYW1lID0gdHlwZW9mIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVOYW1lICsgJzogJyArIEpTT04uc3RyaW5naWZ5KFN0cmluZyhvYmopKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBiYXNlVG9TdHJpbmc7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG5jb25zdCBOYW1lc3BhY2UgPSByZXF1aXJlKCcuL05hbWVzcGFjZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgb3B0SW50ZXJ2YWwpIHtcbiAgbGV0IGU7XG4gIGlmIChvcHRJbnRlcnZhbCkge1xuICAgIGUgPSBuZXcgRXJyb3Iob3B0SW50ZXJ2YWwuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UoKSArIG1lc3NhZ2UpO1xuICAgIGUuc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICBlLmludGVydmFsID0gb3B0SW50ZXJ2YWw7XG4gIH0gZWxzZSB7XG4gICAgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gZXJyb3JzIGFib3V0IGludGVydmFscyAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpbnRlcnZhbFNvdXJjZXNEb250TWF0Y2goKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcIkludGVydmFsIHNvdXJjZXMgZG9uJ3QgbWF0Y2hcIik7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIGVycm9ycyBhYm91dCBncmFtbWFycyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBHcmFtbWFyIHN5bnRheCBlcnJvclxuXG5mdW5jdGlvbiBncmFtbWFyU3ludGF4RXJyb3IobWF0Y2hGYWlsdXJlKSB7XG4gIGNvbnN0IGUgPSBuZXcgRXJyb3IoKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdtZXNzYWdlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG1hdGNoRmFpbHVyZS5tZXNzYWdlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnc2hvcnRNZXNzYWdlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuICdFeHBlY3RlZCAnICsgbWF0Y2hGYWlsdXJlLmdldEV4cGVjdGVkVGV4dCgpO1xuICAgIH1cbiAgfSk7XG4gIGUuaW50ZXJ2YWwgPSBtYXRjaEZhaWx1cmUuZ2V0SW50ZXJ2YWwoKTtcbiAgcmV0dXJuIGU7XG59XG5cbi8vIFVuZGVjbGFyZWQgZ3JhbW1hclxuXG5mdW5jdGlvbiB1bmRlY2xhcmVkR3JhbW1hcihncmFtbWFyTmFtZSwgbmFtZXNwYWNlLCBpbnRlcnZhbCkge1xuICBjb25zdCBtZXNzYWdlID0gbmFtZXNwYWNlID9cbiAgICAgICdHcmFtbWFyICcgKyBncmFtbWFyTmFtZSArICcgaXMgbm90IGRlY2xhcmVkIGluIG5hbWVzcGFjZSAnICsgTmFtZXNwYWNlLnRvU3RyaW5nKG5hbWVzcGFjZSkgOlxuICAgICAgJ1VuZGVjbGFyZWQgZ3JhbW1hciAnICsgZ3JhbW1hck5hbWU7XG4gIHJldHVybiBjcmVhdGVFcnJvcihtZXNzYWdlLCBpbnRlcnZhbCk7XG59XG5cbi8vIER1cGxpY2F0ZSBncmFtbWFyIGRlY2xhcmF0aW9uXG5cbmZ1bmN0aW9uIGR1cGxpY2F0ZUdyYW1tYXJEZWNsYXJhdGlvbihncmFtbWFyLCBuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKCdHcmFtbWFyICcgKyBncmFtbWFyLm5hbWUgKyAnIGlzIGFscmVhZHkgZGVjbGFyZWQgaW4gdGhpcyBuYW1lc3BhY2UnKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gcnVsZXMgLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVW5kZWNsYXJlZCBydWxlXG5cbmZ1bmN0aW9uIHVuZGVjbGFyZWRSdWxlKHJ1bGVOYW1lLCBncmFtbWFyTmFtZSwgb3B0SW50ZXJ2YWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ1J1bGUgJyArIHJ1bGVOYW1lICsgJyBpcyBub3QgZGVjbGFyZWQgaW4gZ3JhbW1hciAnICsgZ3JhbW1hck5hbWUsXG4gICAgICBvcHRJbnRlcnZhbCk7XG59XG5cbi8vIENhbm5vdCBvdmVycmlkZSB1bmRlY2xhcmVkIHJ1bGVcblxuZnVuY3Rpb24gY2Fubm90T3ZlcnJpZGVVbmRlY2xhcmVkUnVsZShydWxlTmFtZSwgZ3JhbW1hck5hbWUsIG9wdFNvdXJjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnQ2Fubm90IG92ZXJyaWRlIHJ1bGUgJyArIHJ1bGVOYW1lICsgJyBiZWNhdXNlIGl0IGlzIG5vdCBkZWNsYXJlZCBpbiAnICsgZ3JhbW1hck5hbWUsXG4gICAgICBvcHRTb3VyY2UpO1xufVxuXG4vLyBDYW5ub3QgZXh0ZW5kIHVuZGVjbGFyZWQgcnVsZVxuXG5mdW5jdGlvbiBjYW5ub3RFeHRlbmRVbmRlY2xhcmVkUnVsZShydWxlTmFtZSwgZ3JhbW1hck5hbWUsIG9wdFNvdXJjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnQ2Fubm90IGV4dGVuZCBydWxlICcgKyBydWxlTmFtZSArICcgYmVjYXVzZSBpdCBpcyBub3QgZGVjbGFyZWQgaW4gJyArIGdyYW1tYXJOYW1lLFxuICAgICAgb3B0U291cmNlKTtcbn1cblxuLy8gRHVwbGljYXRlIHJ1bGUgZGVjbGFyYXRpb25cblxuZnVuY3Rpb24gZHVwbGljYXRlUnVsZURlY2xhcmF0aW9uKHJ1bGVOYW1lLCBncmFtbWFyTmFtZSwgZGVjbEdyYW1tYXJOYW1lLCBvcHRTb3VyY2UpIHtcbiAgbGV0IG1lc3NhZ2UgPSBcIkR1cGxpY2F0ZSBkZWNsYXJhdGlvbiBmb3IgcnVsZSAnXCIgKyBydWxlTmFtZSArXG4gICAgICBcIicgaW4gZ3JhbW1hciAnXCIgKyBncmFtbWFyTmFtZSArIFwiJ1wiO1xuICBpZiAoZ3JhbW1hck5hbWUgIT09IGRlY2xHcmFtbWFyTmFtZSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgKG9yaWdpbmFsbHkgZGVjbGFyZWQgaW4gJ1wiICsgZGVjbEdyYW1tYXJOYW1lICsgXCInKVwiO1xuICB9XG4gIHJldHVybiBjcmVhdGVFcnJvcihtZXNzYWdlLCBvcHRTb3VyY2UpO1xufVxuXG4vLyBXcm9uZyBudW1iZXIgb2YgcGFyYW1ldGVyc1xuXG5mdW5jdGlvbiB3cm9uZ051bWJlck9mUGFyYW1ldGVycyhydWxlTmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCwgc291cmNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdXcm9uZyBudW1iZXIgb2YgcGFyYW1ldGVycyBmb3IgcnVsZSAnICsgcnVsZU5hbWUgK1xuICAgICAgICAgICcgKGV4cGVjdGVkICcgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsICsgJyknLFxuICAgICAgc291cmNlKTtcbn1cblxuLy8gV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xuXG5mdW5jdGlvbiB3cm9uZ051bWJlck9mQXJndW1lbnRzKHJ1bGVOYW1lLCBleHBlY3RlZCwgYWN0dWFsLCBleHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBydWxlICcgKyBydWxlTmFtZSArXG4gICAgICAgICAgJyAoZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJywgZ290ICcgKyBhY3R1YWwgKyAnKScsXG4gICAgICBleHByLnNvdXJjZSk7XG59XG5cbi8vIER1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXNcblxuZnVuY3Rpb24gZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMocnVsZU5hbWUsIGR1cGxpY2F0ZXMsIHNvdXJjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnRHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcyBpbiBydWxlICcgKyBydWxlTmFtZSArICc6ICcgKyBkdXBsaWNhdGVzLmpvaW4oJywgJyksXG4gICAgICBzb3VyY2UpO1xufVxuXG4vLyBJbnZhbGlkIHBhcmFtZXRlciBleHByZXNzaW9uXG5cbmZ1bmN0aW9uIGludmFsaWRQYXJhbWV0ZXIocnVsZU5hbWUsIGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ0ludmFsaWQgcGFyYW1ldGVyIHRvIHJ1bGUgJyArIHJ1bGVOYW1lICsgJzogJyArIGV4cHIgKyAnIGhhcyBhcml0eSAnICsgZXhwci5nZXRBcml0eSgpICtcbiAgICAgICAgICcsIGJ1dCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgbXVzdCBoYXZlIGFyaXR5IDEnLFxuICAgICAgZXhwci5zb3VyY2UpO1xufVxuXG4vLyBBcHBsaWNhdGlvbiBvZiBzeW50YWN0aWMgcnVsZSBmcm9tIGxleGljYWwgcnVsZVxuXG5mdW5jdGlvbiBhcHBsaWNhdGlvbk9mU3ludGFjdGljUnVsZUZyb21MZXhpY2FsQ29udGV4dChydWxlTmFtZSwgYXBwbHlFeHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdDYW5ub3QgYXBwbHkgc3ludGFjdGljIHJ1bGUgJyArIHJ1bGVOYW1lICsgJyBmcm9tIGhlcmUgKGluc2lkZSBhIGxleGljYWwgY29udGV4dCknLFxuICAgICAgYXBwbHlFeHByLnNvdXJjZSk7XG59XG5cbi8vIEluY29ycmVjdCBhcmd1bWVudCB0eXBlXG5cbmZ1bmN0aW9uIGluY29ycmVjdEFyZ3VtZW50VHlwZShleHBlY3RlZFR5cGUsIGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKCdJbmNvcnJlY3QgYXJndW1lbnQgdHlwZTogZXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZSwgZXhwci5zb3VyY2UpO1xufVxuXG4vLyBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIHN1cGVyLXNwbGljZSBvcGVyYXRvciAoYC4uLmApIGluIHRoZSBydWxlIGJvZHkuXG5cbmZ1bmN0aW9uIG11bHRpcGxlU3VwZXJTcGxpY2VzKGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFwiJy4uLicgY2FuIGFwcGVhciBhdCBtb3N0IG9uY2UgaW4gYSBydWxlIGJvZHlcIiwgZXhwci5zb3VyY2UpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBLbGVlbmUgb3BlcmF0b3JzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGtsZWVuZUV4cHJIYXNOdWxsYWJsZU9wZXJhbmQoa2xlZW5lRXhwciwgYXBwbGljYXRpb25TdGFjaykge1xuICBjb25zdCBhY3R1YWxzID0gYXBwbGljYXRpb25TdGFjay5sZW5ndGggPiAwID9cbiAgICBhcHBsaWNhdGlvblN0YWNrW2FwcGxpY2F0aW9uU3RhY2subGVuZ3RoIC0gMV0uYXJncyA6XG4gICAgW107XG4gIGNvbnN0IGV4cHIgPSBrbGVlbmVFeHByLmV4cHIuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKTtcbiAgbGV0IG1lc3NhZ2UgPVxuICAgICdOdWxsYWJsZSBleHByZXNzaW9uICcgKyBleHByICsgXCIgaXMgbm90IGFsbG93ZWQgaW5zaWRlICdcIiArXG4gICAga2xlZW5lRXhwci5vcGVyYXRvciArIFwiJyAocG9zc2libGUgaW5maW5pdGUgbG9vcClcIjtcbiAgaWYgKGFwcGxpY2F0aW9uU3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBhcHBsaWNhdGlvblN0YWNrXG4gICAgICAgIC5tYXAoYXBwID0+IG5ldyBwZXhwcnMuQXBwbHkoYXBwLnJ1bGVOYW1lLCBhcHAuYXJncykpXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICBtZXNzYWdlICs9ICdcXG5BcHBsaWNhdGlvbiBzdGFjayAobW9zdCByZWNlbnQgYXBwbGljYXRpb24gbGFzdCk6XFxuJyArIHN0YWNrVHJhY2U7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGtsZWVuZUV4cHIuZXhwci5zb3VyY2UpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBhcml0eSAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpbmNvbnNpc3RlbnRBcml0eShydWxlTmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCwgZXhwcikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnUnVsZSAnICsgcnVsZU5hbWUgKyAnIGludm9sdmVzIGFuIGFsdGVybmF0aW9uIHdoaWNoIGhhcyBpbmNvbnNpc3RlbnQgYXJpdHkgJyArXG4gICAgICAgICAgJyhleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnLCBnb3QgJyArIGFjdHVhbCArICcpJyxcbiAgICAgIGV4cHIuc291cmNlKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gcHJvcGVydGllcyAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBkdXBsaWNhdGVQcm9wZXJ0eU5hbWVzKGR1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKCdPYmplY3QgcGF0dGVybiBoYXMgZHVwbGljYXRlIHByb3BlcnR5IG5hbWVzOiAnICsgZHVwbGljYXRlcy5qb2luKCcsICcpKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gY29uc3RydWN0b3JzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGludmFsaWRDb25zdHJ1Y3RvckNhbGwoZ3JhbW1hciwgY3Rvck5hbWUsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdBdHRlbXB0IHRvIGludm9rZSBjb25zdHJ1Y3RvciAnICsgY3Rvck5hbWUgKyAnIHdpdGggaW52YWxpZCBvciB1bmV4cGVjdGVkIGFyZ3VtZW50cycpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBjb252ZW5pZW5jZSAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBtdWx0aXBsZUVycm9ycyhlcnJvcnMpIHtcbiAgY29uc3QgbWVzc2FnZXMgPSBlcnJvcnMubWFwKGUgPT4gZS5tZXNzYWdlKTtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgWydFcnJvcnM6J10uY29uY2F0KG1lc3NhZ2VzKS5qb2luKCdcXG4tICcpLFxuICAgICAgZXJyb3JzWzBdLmludGVydmFsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gc2VtYW50aWMgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gbWlzc2luZ1NlbWFudGljQWN0aW9uKGN0b3JOYW1lLCBuYW1lLCB0eXBlLCBzdGFjaykge1xuICBsZXQgc3RhY2tUcmFjZSA9IHN0YWNrLnNsaWNlKDAsIC0xKS5tYXAoaW5mbyA9PiB7XG4gICAgY29uc3QgYW5zID0gJyAgJyArIGluZm9bMF0ubmFtZSArICcgPiAnICsgaW5mb1sxXTtcbiAgICByZXR1cm4gaW5mby5sZW5ndGggPT09IDNcbiAgICAgICAgPyBhbnMgKyBcIiBmb3IgJ1wiICsgaW5mb1syXSArIFwiJ1wiXG4gICAgICAgIDogYW5zO1xuICB9KS5qb2luKCdcXG4nKTtcbiAgc3RhY2tUcmFjZSArPSAnXFxuICAnICsgbmFtZSArICcgPiAnICsgY3Rvck5hbWU7XG5cbiAgY29uc3Qgd2hlcmUgPSB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICBjb25zdCBtZXNzYWdlID0gXCJNaXNzaW5nIHNlbWFudGljIGFjdGlvbiBmb3IgJ1wiICsgY3Rvck5hbWUgKyBcIicgaW4gXCIgKyB3aGVyZSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnQWN0aW9uIHN0YWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpOlxcbicgKyBzdGFja1RyYWNlO1xuXG4gIGNvbnN0IGUgPSBjcmVhdGVFcnJvcihtZXNzYWdlKTtcbiAgZS5uYW1lID0gJ21pc3NpbmdTZW1hbnRpY0FjdGlvbic7XG4gIHJldHVybiBlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFwcGxpY2F0aW9uT2ZTeW50YWN0aWNSdWxlRnJvbUxleGljYWxDb250ZXh0LFxuICBjYW5ub3RFeHRlbmRVbmRlY2xhcmVkUnVsZSxcbiAgY2Fubm90T3ZlcnJpZGVVbmRlY2xhcmVkUnVsZSxcbiAgZHVwbGljYXRlR3JhbW1hckRlY2xhcmF0aW9uLFxuICBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyxcbiAgZHVwbGljYXRlUHJvcGVydHlOYW1lcyxcbiAgZHVwbGljYXRlUnVsZURlY2xhcmF0aW9uLFxuICBpbmNvbnNpc3RlbnRBcml0eSxcbiAgaW5jb3JyZWN0QXJndW1lbnRUeXBlLFxuICBpbnRlcnZhbFNvdXJjZXNEb250TWF0Y2gsXG4gIGludmFsaWRDb25zdHJ1Y3RvckNhbGwsXG4gIGludmFsaWRQYXJhbWV0ZXIsXG4gIGdyYW1tYXJTeW50YXhFcnJvcixcbiAga2xlZW5lRXhwckhhc051bGxhYmxlT3BlcmFuZCxcbiAgbWlzc2luZ1NlbWFudGljQWN0aW9uLFxuICBtdWx0aXBsZVN1cGVyU3BsaWNlcyxcbiAgdW5kZWNsYXJlZEdyYW1tYXIsXG4gIHVuZGVjbGFyZWRSdWxlLFxuICB3cm9uZ051bWJlck9mQXJndW1lbnRzLFxuICB3cm9uZ051bWJlck9mUGFyYW1ldGVycyxcblxuICB0aHJvd0Vycm9ycyhlcnJvcnMpIHtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgIH1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG11bHRpcGxlRXJyb3JzKGVycm9ycyk7XG4gICAgfVxuICB9XG59O1xuIiwiLyogZ2xvYmFsIGRvY3VtZW50LCBYTUxIdHRwUmVxdWVzdCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBCdWlsZGVyID0gcmVxdWlyZSgnLi9CdWlsZGVyJyk7XG5jb25zdCBHcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyJyk7XG5jb25zdCBOYW1lc3BhY2UgPSByZXF1aXJlKCcuL05hbWVzcGFjZScpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5jb25zdCBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVGhlIG1ldGFncmFtbWFyLCBpLmUuIHRoZSBncmFtbWFyIGZvciBPaG0gZ3JhbW1hcnMuIEluaXRpYWxpemVkIGF0IHRoZVxuLy8gYm90dG9tIG9mIHRoaXMgZmlsZSBiZWNhdXNlIGxvYWRpbmcgdGhlIGdyYW1tYXIgcmVxdWlyZXMgT2htIGl0c2VsZi5cbmxldCBvaG1HcmFtbWFyO1xuXG4vLyBBbiBvYmplY3Qgd2hpY2ggbWFrZXMgaXQgcG9zc2libGUgdG8gc3R1YiBvdXQgdGhlIGRvY3VtZW50IEFQSSBmb3IgdGVzdGluZy5cbmxldCBkb2N1bWVudEludGVyZmFjZSA9IHtcbiAgcXVlcnlTZWxlY3RvcihzZWwpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbChzZWwpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKTsgfVxufTtcblxuY29uc3Qgc3VwZXJTcGxpY2VQbGFjZWhvbGRlciA9IE9iamVjdC5jcmVhdGUocGV4cHJzLlBFeHByLnByb3RvdHlwZSk7XG5cbi8vIENoZWNrIGlmIGBvYmpgIGlzIGEgRE9NIGVsZW1lbnQuXG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby12b2lkXG59XG5cbmNvbnN0IE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG59XG5cbi8vIFRPRE86IGp1c3QgdXNlIHRoZSBqUXVlcnkgdGhpbmdcbmZ1bmN0aW9uIGxvYWQodXJsKSB7XG4gIGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gIHRyeSB7XG4gICAgcmVxLnNlbmQoKTtcbiAgICBpZiAocmVxLnN0YXR1cyA9PT0gMCB8fCByZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJldHVybiByZXEucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cbiAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9hZCB1cmwgJyArIHVybCk7XG59XG5cbi8vIFJldHVybnMgYSBHcmFtbWFyIGluc3RhbmNlIChpLmUuLCBhbiBvYmplY3Qgd2l0aCBhIGBtYXRjaGAgbWV0aG9kKSBmb3Jcbi8vIGB0cmVlYCwgd2hpY2ggaXMgdGhlIGNvbmNyZXRlIHN5bnRheCB0cmVlIG9mIGEgdXNlci13cml0dGVuIGdyYW1tYXIuXG4vLyBUaGUgZ3JhbW1hciB3aWxsIGJlIGFzc2lnbmVkIGludG8gYG5hbWVzcGFjZWAgdW5kZXIgdGhlIG5hbWUgb2YgdGhlIGdyYW1tYXJcbi8vIGFzIHNwZWNpZmllZCBpbiB0aGUgc291cmNlLlxuZnVuY3Rpb24gYnVpbGRHcmFtbWFyKG1hdGNoLCBuYW1lc3BhY2UsIG9wdE9obUdyYW1tYXJGb3JUZXN0aW5nKSB7XG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICBsZXQgZGVjbDtcbiAgbGV0IGN1cnJlbnRSdWxlTmFtZTtcbiAgbGV0IGN1cnJlbnRSdWxlRm9ybWFscztcbiAgbGV0IG92ZXJyaWRpbmcgPSBmYWxzZTtcbiAgY29uc3QgbWV0YUdyYW1tYXIgPSBvcHRPaG1HcmFtbWFyRm9yVGVzdGluZyB8fCBvaG1HcmFtbWFyO1xuXG4gIC8vIEEgdmlzaXRvciB0aGF0IHByb2R1Y2VzIGEgR3JhbW1hciBpbnN0YW5jZSBmcm9tIHRoZSBDU1QuXG4gIGNvbnN0IGhlbHBlcnMgPSBtZXRhR3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKS5hZGRPcGVyYXRpb24oJ3Zpc2l0Jywge1xuICAgIEdyYW1tYXIobiwgcywgb3BlbiwgcnMsIGNsb3NlKSB7XG4gICAgICBjb25zdCBncmFtbWFyTmFtZSA9IG4udmlzaXQoKTtcbiAgICAgIGRlY2wgPSBidWlsZGVyLm5ld0dyYW1tYXIoZ3JhbW1hck5hbWUsIG5hbWVzcGFjZSk7XG4gICAgICBzLnZpc2l0KCk7XG4gICAgICBycy52aXNpdCgpO1xuICAgICAgY29uc3QgZyA9IGRlY2wuYnVpbGQoKTtcbiAgICAgIGcuc291cmNlID0gdGhpcy5zb3VyY2UudHJpbW1lZCgpO1xuICAgICAgaWYgKGdyYW1tYXJOYW1lIGluIG5hbWVzcGFjZSkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuZHVwbGljYXRlR3JhbW1hckRlY2xhcmF0aW9uKGcsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgICBuYW1lc3BhY2VbZ3JhbW1hck5hbWVdID0gZztcbiAgICAgIHJldHVybiBnO1xuICAgIH0sXG5cbiAgICBTdXBlckdyYW1tYXIoXywgbikge1xuICAgICAgY29uc3Qgc3VwZXJHcmFtbWFyTmFtZSA9IG4udmlzaXQoKTtcbiAgICAgIGlmIChzdXBlckdyYW1tYXJOYW1lID09PSAnbnVsbCcpIHtcbiAgICAgICAgZGVjbC53aXRoU3VwZXJHcmFtbWFyKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2UgfHwgIShzdXBlckdyYW1tYXJOYW1lIGluIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcnMudW5kZWNsYXJlZEdyYW1tYXIoc3VwZXJHcmFtbWFyTmFtZSwgbmFtZXNwYWNlLCBuLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjbC53aXRoU3VwZXJHcmFtbWFyKG5hbWVzcGFjZVtzdXBlckdyYW1tYXJOYW1lXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFJ1bGVfZGVmaW5lKG4sIGZzLCBkLCBfLCBiKSB7XG4gICAgICBjdXJyZW50UnVsZU5hbWUgPSBuLnZpc2l0KCk7XG4gICAgICBjdXJyZW50UnVsZUZvcm1hbHMgPSBmcy52aXNpdCgpWzBdIHx8IFtdO1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGVmYXVsdCBzdGFydCBydWxlIHlldCwgc2V0IGl0IG5vdy4gVGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHZpc2l0aW5nXG4gICAgICAvLyB0aGUgYm9keSwgYmVjYXVzZSBpdCBtaWdodCBjb250YWluIGFuIGlubGluZSBydWxlIGRlZmluaXRpb24uXG4gICAgICBpZiAoIWRlY2wuZGVmYXVsdFN0YXJ0UnVsZSAmJiBkZWNsLmVuc3VyZVN1cGVyR3JhbW1hcigpICE9PSBHcmFtbWFyLlByb3RvQnVpbHRJblJ1bGVzKSB7XG4gICAgICAgIGRlY2wud2l0aERlZmF1bHRTdGFydFJ1bGUoY3VycmVudFJ1bGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBiLnZpc2l0KCk7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGQudmlzaXQoKVswXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLnRyaW1tZWQoKTtcbiAgICAgIHJldHVybiBkZWNsLmRlZmluZShjdXJyZW50UnVsZU5hbWUsIGN1cnJlbnRSdWxlRm9ybWFscywgYm9keSwgZGVzY3JpcHRpb24sIHNvdXJjZSk7XG4gICAgfSxcbiAgICBSdWxlX292ZXJyaWRlKG4sIGZzLCBfLCBiKSB7XG4gICAgICBjdXJyZW50UnVsZU5hbWUgPSBuLnZpc2l0KCk7XG4gICAgICBjdXJyZW50UnVsZUZvcm1hbHMgPSBmcy52aXNpdCgpWzBdIHx8IFtdO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICBkZWNsLmVuc3VyZVN1cGVyR3JhbW1hclJ1bGVGb3JPdmVycmlkaW5nKGN1cnJlbnRSdWxlTmFtZSwgc291cmNlKTtcblxuICAgICAgb3ZlcnJpZGluZyA9IHRydWU7XG4gICAgICBjb25zdCBib2R5ID0gYi52aXNpdCgpO1xuICAgICAgb3ZlcnJpZGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGRlY2wub3ZlcnJpZGUoY3VycmVudFJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIG51bGwsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBSdWxlX2V4dGVuZChuLCBmcywgXywgYikge1xuICAgICAgY3VycmVudFJ1bGVOYW1lID0gbi52aXNpdCgpO1xuICAgICAgY3VycmVudFJ1bGVGb3JtYWxzID0gZnMudmlzaXQoKVswXSB8fCBbXTtcbiAgICAgIGNvbnN0IGJvZHkgPSBiLnZpc2l0KCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICByZXR1cm4gZGVjbC5leHRlbmQoY3VycmVudFJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIG51bGwsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBSdWxlQm9keShfLCB0ZXJtcykge1xuICAgICAgY29uc3QgYXJncyA9IHRlcm1zLnZpc2l0KCk7XG4gICAgICByZXR1cm4gYnVpbGRlci5hbHQuYXBwbHkoYnVpbGRlciwgYXJncykud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBPdmVycmlkZVJ1bGVCb2R5KF8sIHRlcm1zKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGVybXMudmlzaXQoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN1cGVyLXNwbGljZSBvcGVyYXRvciAoYC4uLmApIGFwcGVhcnMgaW4gdGhlIHRlcm1zLlxuICAgICAgY29uc3QgZXhwYW5zaW9uUG9zID0gYXJncy5pbmRleE9mKHN1cGVyU3BsaWNlUGxhY2Vob2xkZXIpO1xuICAgICAgaWYgKGV4cGFuc2lvblBvcyA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGJlZm9yZVRlcm1zID0gYXJncy5zbGljZSgwLCBleHBhbnNpb25Qb3MpO1xuICAgICAgICBjb25zdCBhZnRlclRlcm1zID0gYXJncy5zbGljZShleHBhbnNpb25Qb3MgKyAxKTtcblxuICAgICAgICAvLyBFbnN1cmUgaXQgYXBwZWFycyBubyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgYWZ0ZXJUZXJtcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGlmICh0ID09PSBzdXBlclNwbGljZVBsYWNlaG9sZGVyKSB0aHJvdyBlcnJvcnMubXVsdGlwbGVTdXBlclNwbGljZXModCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgcGV4cHJzLlNwbGljZShcbiAgICAgICAgICAgIGRlY2wuc3VwZXJHcmFtbWFyLCBjdXJyZW50UnVsZU5hbWUsIGJlZm9yZVRlcm1zLCBhZnRlclRlcm1zKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmFsdC5hcHBseShidWlsZGVyLCBhcmdzKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEZvcm1hbHMob3BvaW50eSwgZnMsIGNwb2ludHkpIHtcbiAgICAgIHJldHVybiBmcy52aXNpdCgpO1xuICAgIH0sXG5cbiAgICBQYXJhbXMob3BvaW50eSwgcHMsIGNwb2ludHkpIHtcbiAgICAgIHJldHVybiBwcy52aXNpdCgpO1xuICAgIH0sXG5cbiAgICBBbHQoc2Vxcykge1xuICAgICAgY29uc3QgYXJncyA9IHNlcXMudmlzaXQoKTtcbiAgICAgIHJldHVybiBidWlsZGVyLmFsdC5hcHBseShidWlsZGVyLCBhcmdzKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuXG4gICAgVG9wTGV2ZWxUZXJtX2lubGluZShiLCBuKSB7XG4gICAgICBjb25zdCBpbmxpbmVSdWxlTmFtZSA9IGN1cnJlbnRSdWxlTmFtZSArICdfJyArIG4udmlzaXQoKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBiLnZpc2l0KCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICBjb25zdCBpc05ld1J1bGVEZWNsYXJhdGlvbiA9XG4gICAgICAgICAgIShkZWNsLnN1cGVyR3JhbW1hciAmJiBkZWNsLnN1cGVyR3JhbW1hci5ydWxlc1tpbmxpbmVSdWxlTmFtZV0pO1xuICAgICAgaWYgKG92ZXJyaWRpbmcgJiYgIWlzTmV3UnVsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgIGRlY2wub3ZlcnJpZGUoaW5saW5lUnVsZU5hbWUsIGN1cnJlbnRSdWxlRm9ybWFscywgYm9keSwgbnVsbCwgc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuZGVmaW5lKGlubGluZVJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIG51bGwsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJhbXMgPSBjdXJyZW50UnVsZUZvcm1hbHMubWFwKGZvcm1hbCA9PiBidWlsZGVyLmFwcChmb3JtYWwpKTtcbiAgICAgIHJldHVybiBidWlsZGVyLmFwcChpbmxpbmVSdWxlTmFtZSwgcGFyYW1zKS53aXRoU291cmNlKGJvZHkuc291cmNlKTtcbiAgICB9LFxuICAgIE92ZXJyaWRlVG9wTGV2ZWxUZXJtX3N1cGVyU3BsaWNlKF8pIHtcbiAgICAgIHJldHVybiBzdXBlclNwbGljZVBsYWNlaG9sZGVyO1xuICAgIH0sXG5cbiAgICBTZXEoZXhwcikge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuc2VxLmFwcGx5KGJ1aWxkZXIsIGV4cHIudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIEl0ZXJfc3Rhcih4LCBfKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5zdGFyKHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBJdGVyX3BsdXMoeCwgXykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIucGx1cyh4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgSXRlcl9vcHQoeCwgXykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIub3B0KHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIFByZWRfbm90KF8sIHgpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLm5vdCh4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgUHJlZF9sb29rYWhlYWQoXywgeCkge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIubG9va2FoZWFkKHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIExleF9sZXgoXywgeCkge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIubGV4KHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIEJhc2VfYXBwbGljYXRpb24ocnVsZSwgcHMpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLmFwcChydWxlLnZpc2l0KCksIHBzLnZpc2l0KClbMF0gfHwgW10pLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgQmFzZV9yYW5nZShmcm9tLCBfLCB0bykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIucmFuZ2UoZnJvbS52aXNpdCgpLCB0by52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIEJhc2VfdGVybWluYWwoZXhwcikge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIudGVybWluYWwoZXhwci52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIEJhc2VfcGFyZW4ob3BlbiwgeCwgY2xvc2UpIHtcbiAgICAgIHJldHVybiB4LnZpc2l0KCk7XG4gICAgfSxcblxuICAgIHJ1bGVEZXNjcihvcGVuLCB0LCBjbG9zZSkge1xuICAgICAgcmV0dXJuIHQudmlzaXQoKTtcbiAgICB9LFxuICAgIHJ1bGVEZXNjclRleHQoXykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3RyaW5nLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgY2FzZU5hbWUoXywgc3BhY2UxLCBuLCBzcGFjZTIsIGVuZCkge1xuICAgICAgcmV0dXJuIG4udmlzaXQoKTtcbiAgICB9LFxuXG4gICAgbmFtZShmaXJzdCwgcmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3RyaW5nO1xuICAgIH0sXG4gICAgbmFtZUZpcnN0KGV4cHIpIHt9LFxuICAgIG5hbWVSZXN0KGV4cHIpIHt9LFxuXG4gICAgdGVybWluYWwob3BlbiwgY3MsIGNsb3NlKSB7XG4gICAgICByZXR1cm4gY3MudmlzaXQoKS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgb25lQ2hhclRlcm1pbmFsKG9wZW4sIGMsIGNsb3NlKSB7XG4gICAgICByZXR1cm4gYy52aXNpdCgpO1xuICAgIH0sXG5cbiAgICB0ZXJtaW5hbENoYXIoXykge1xuICAgICAgcmV0dXJuIGNvbW1vbi51bmVzY2FwZUNoYXIodGhpcy5zb3VyY2VTdHJpbmcpO1xuICAgIH0sXG5cbiAgICBlc2NhcGVDaGFyKF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVN0cmluZztcbiAgICB9LFxuXG4gICAgTm9uZW1wdHlMaXN0T2YoeCwgXywgeHMpIHtcbiAgICAgIHJldHVybiBbeC52aXNpdCgpXS5jb25jYXQoeHMudmlzaXQoKSk7XG4gICAgfSxcbiAgICBFbXB0eUxpc3RPZigpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgX3Rlcm1pbmFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhlbHBlcnMobWF0Y2gpLnZpc2l0KCk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVBbmRMb2FkKHNvdXJjZSwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IG0gPSBvaG1HcmFtbWFyLm1hdGNoKHNvdXJjZSwgJ0dyYW1tYXJzJyk7XG4gIGlmIChtLmZhaWxlZCgpKSB7XG4gICAgdGhyb3cgZXJyb3JzLmdyYW1tYXJTeW50YXhFcnJvcihtKTtcbiAgfVxuICByZXR1cm4gYnVpbGRHcmFtbWFyKG0sIG5hbWVzcGFjZSk7XG59XG5cbi8vIFJldHVybiB0aGUgY29udGVudHMgb2YgYSBzY3JpcHQgZWxlbWVudCwgZmV0Y2hpbmcgaXQgdmlhIFhIUiBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiBnZXRTY3JpcHRFbGVtZW50Q29udGVudHMoZWwpIHtcbiAgaWYgKCFpc0VsZW1lbnQoZWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBET00gTm9kZSwgZ290ICcgKyBjb21tb24udW5leHBlY3RlZE9ialRvU3RyaW5nKGVsKSk7XG4gIH1cbiAgaWYgKGVsLnR5cGUgIT09ICd0ZXh0L29obS1qcycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc2NyaXB0IHRhZyB3aXRoIHR5cGU9XCJ0ZXh0L29obS1qc1wiLCBnb3QgJyArIGVsKTtcbiAgfVxuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdzcmMnKSA/IGxvYWQoZWwuZ2V0QXR0cmlidXRlKCdzcmMnKSkgOiBlbC5pbm5lckhUTUw7XG59XG5cbmZ1bmN0aW9uIGdyYW1tYXIoc291cmNlLCBvcHROYW1lc3BhY2UpIHtcbiAgY29uc3QgbnMgPSBncmFtbWFycyhzb3VyY2UsIG9wdE5hbWVzcGFjZSk7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHNvdXJjZSBjb250YWluZWQgbm8gbW9yZSB0aGFuIG9uZSBncmFtbWFyIGRlZmluaXRpb24uXG4gIGNvbnN0IGdyYW1tYXJOYW1lcyA9IE9iamVjdC5rZXlzKG5zKTtcbiAgaWYgKGdyYW1tYXJOYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ3JhbW1hciBkZWZpbml0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZ3JhbW1hck5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzZWNvbmRHcmFtbWFyID0gbnNbZ3JhbW1hck5hbWVzWzFdXTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNlY29uZEdyYW1tYXIuc291cmNlO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgdXRpbC5nZXRMaW5lQW5kQ29sdW1uTWVzc2FnZShpbnRlcnZhbC5zb3VyY2VTdHJpbmcsIGludGVydmFsLnN0YXJ0SWR4KSArXG4gICAgICAgICdGb3VuZCBtb3JlIHRoYW4gb25lIGdyYW1tYXIgZGVmaW5pdGlvbiAtLSB1c2Ugb2htLmdyYW1tYXJzKCkgaW5zdGVhZC4nKTtcbiAgfVxuICByZXR1cm4gbnNbZ3JhbW1hck5hbWVzWzBdXTsgLy8gUmV0dXJuIHRoZSBvbmUgYW5kIG9ubHkgZ3JhbW1hci5cbn1cblxuZnVuY3Rpb24gZ3JhbW1hcnMoc291cmNlLCBvcHROYW1lc3BhY2UpIHtcbiAgY29uc3QgbnMgPSBOYW1lc3BhY2UuZXh0ZW5kKE5hbWVzcGFjZS5hc05hbWVzcGFjZShvcHROYW1lc3BhY2UpKTtcbiAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRm9yIGNvbnZlbmllbmNlLCBkZXRlY3QgTm9kZS5qcyBCdWZmZXIgb2JqZWN0cyBhbmQgYXV0b21hdGljYWxseSBjYWxsIHRvU3RyaW5nKCkuXG4gICAgaWYgKGlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCBzdHJpbmcgYXMgZmlyc3QgYXJndW1lbnQsIGdvdCAnICsgY29tbW9uLnVuZXhwZWN0ZWRPYmpUb1N0cmluZyhzb3VyY2UpKTtcbiAgICB9XG4gIH1cbiAgY29tcGlsZUFuZExvYWQoc291cmNlLCBucyk7XG4gIHJldHVybiBucztcbn1cblxuZnVuY3Rpb24gZ3JhbW1hckZyb21TY3JpcHRFbGVtZW50KG9wdE5vZGUpIHtcbiAgbGV0IG5vZGUgPSBvcHROb2RlO1xuICBpZiAoaXNVbmRlZmluZWQobm9kZSkpIHtcbiAgICBjb25zdCBub2RlTGlzdCA9IGRvY3VtZW50SW50ZXJmYWNlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFt0eXBlPVwidGV4dC9vaG0tanNcIl0nKTtcbiAgICBpZiAobm9kZUxpc3QubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGV4YWN0bHkgb25lIHNjcmlwdCB0YWcgd2l0aCB0eXBlPVwidGV4dC9vaG0tanNcIiwgZm91bmQgJyArIG5vZGVMaXN0Lmxlbmd0aCk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlTGlzdFswXTtcbiAgfVxuICByZXR1cm4gZ3JhbW1hcihnZXRTY3JpcHRFbGVtZW50Q29udGVudHMobm9kZSkpO1xufVxuXG5mdW5jdGlvbiBncmFtbWFyc0Zyb21TY3JpcHRFbGVtZW50cyhvcHROb2RlT3JOb2RlTGlzdCkge1xuICAvLyBTaW1wbGUgY2FzZTogdGhlIGFyZ3VtZW50IGlzIGEgRE9NIG5vZGUuXG4gIGlmIChpc0VsZW1lbnQob3B0Tm9kZU9yTm9kZUxpc3QpKSB7XG4gICAgcmV0dXJuIGdyYW1tYXJzKG9wdE5vZGVPck5vZGVMaXN0KTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGl0IG11c3QgYmUgZWl0aGVyIHVuZGVmaW5lZCBvciBhIE5vZGVMaXN0LlxuICBsZXQgbm9kZUxpc3QgPSBvcHROb2RlT3JOb2RlTGlzdDtcbiAgaWYgKGlzVW5kZWZpbmVkKG5vZGVMaXN0KSkge1xuICAgIC8vIEZpbmQgYWxsIHNjcmlwdCBlbGVtZW50cyB3aXRoIHR5cGU9XCJ0ZXh0L29obS1qc1wiLlxuICAgIG5vZGVMaXN0ID0gZG9jdW1lbnRJbnRlcmZhY2UucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W3R5cGU9XCJ0ZXh0L29obS1qc1wiXScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlTGlzdCA9PT0gJ3N0cmluZycgfHwgKCFpc0VsZW1lbnQobm9kZUxpc3QpICYmICFpc0FycmF5TGlrZShub2RlTGlzdCkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBOb2RlLCBOb2RlTGlzdCwgb3IgQXJyYXksIGJ1dCBnb3QgJyArIG5vZGVMaXN0KTtcbiAgfVxuICBjb25zdCBucyA9IE5hbWVzcGFjZS5jcmVhdGVOYW1lc3BhY2UoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIC8vIENvcHkgdGhlIG5ldyBncmFtbWFycyBpbnRvIGBuc2AgdG8ga2VlcCB0aGUgbmFtZXNwYWNlIGZsYXQuXG4gICAgY29tbW9uLmV4dGVuZChucywgZ3JhbW1hcnMoZ2V0U2NyaXB0RWxlbWVudENvbnRlbnRzKG5vZGVMaXN0W2ldKSwgbnMpKTtcbiAgfVxuICByZXR1cm4gbnM7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZWNpcGUocmVjaXBlKSB7XG4gIGlmICh0eXBlb2YgcmVjaXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlY2lwZS5jYWxsKG5ldyBCdWlsZGVyKCkpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgcmVjaXBlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gc3RyaW5naWZpZWQgSlNPTiByZWNpcGVcbiAgICAgIHJlY2lwZSA9IEpTT04ucGFyc2UocmVjaXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZXcgQnVpbGRlcigpKS5mcm9tUmVjaXBlKHJlY2lwZSk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFN0dWZmIHRoYXQgdXNlcnMgc2hvdWxkIGtub3cgYWJvdXRcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVOYW1lc3BhY2U6IE5hbWVzcGFjZS5jcmVhdGVOYW1lc3BhY2UsXG4gIGdyYW1tYXIsXG4gIGdyYW1tYXJzLFxuICBncmFtbWFyRnJvbVNjcmlwdEVsZW1lbnQsXG4gIGdyYW1tYXJzRnJvbVNjcmlwdEVsZW1lbnRzLFxuICBtYWtlUmVjaXBlLFxuICBvaG1HcmFtbWFyOiBudWxsLCAvLyBJbml0aWFsaXplZCBiZWxvdywgYWZ0ZXIgR3JhbW1hci5CdWlsdEluUnVsZXMuXG4gIHBleHBycyxcbiAgdXRpbCxcbiAgZXh0cmFzOiByZXF1aXJlKCcuLi9leHRyYXMnKSxcbiAgdmVyc2lvblxufTtcblxuLy8gU3R1ZmYgZm9yIHRlc3RpbmcsIGV0Yy5cbm1vZHVsZS5leHBvcnRzLl9idWlsZEdyYW1tYXIgPSBidWlsZEdyYW1tYXI7XG5tb2R1bGUuZXhwb3J0cy5fc2V0RG9jdW1lbnRJbnRlcmZhY2VGb3JUZXN0aW5nID0gZnVuY3Rpb24oZG9jKSB7IGRvY3VtZW50SW50ZXJmYWNlID0gZG9jOyB9O1xuXG4vLyBMYXRlIGluaXRpYWxpemF0aW9uIGZvciBzdHVmZiB0aGF0IGlzIGJvb3RzdHJhcHBlZC5cblxuR3JhbW1hci5CdWlsdEluUnVsZXMgPSByZXF1aXJlKCcuLi9kaXN0L2J1aWx0LWluLXJ1bGVzJyk7XG51dGlsLmFubm91bmNlQnVpbHRJblJ1bGVzKEdyYW1tYXIuQnVpbHRJblJ1bGVzKTtcblxubW9kdWxlLmV4cG9ydHMub2htR3JhbW1hciA9IG9obUdyYW1tYXIgPSByZXF1aXJlKCcuLi9kaXN0L29obS1ncmFtbWFyJyk7XG5HcmFtbWFyLmluaXRBcHBsaWNhdGlvblBhcnNlcihvaG1HcmFtbWFyLCBidWlsZEdyYW1tYXIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY2xhc3MgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYW1tYXIsIGN0b3JOYW1lLCBtYXRjaExlbmd0aCkge1xuICAgIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG4gICAgdGhpcy5jdG9yTmFtZSA9IGN0b3JOYW1lO1xuICAgIHRoaXMubWF0Y2hMZW5ndGggPSBtYXRjaExlbmd0aDtcbiAgfVxuXG4gIG51bUNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlbi5sZW5ndGggOiAwO1xuICB9XG5cbiAgY2hpbGRBdChpZHgpIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baWR4XTtcbiAgICB9XG4gIH1cblxuICBpbmRleE9mQ2hpbGQoYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uaW5kZXhPZihhcmcpO1xuICB9XG5cbiAgaGFzQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtQ2hpbGRyZW4oKSA+IDE7XG4gIH1cblxuICBoYXNOb0NoaWxkcmVuKCkge1xuICAgIHJldHVybiAhdGhpcy5oYXNDaGlsZHJlbigpO1xuICB9XG5cbiAgb25seUNoaWxkKCkge1xuICAgIGlmICh0aGlzLm51bUNoaWxkcmVuKCkgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IGdldCBvbmx5IGNoaWxkIG9mIGEgbm9kZSBvZiB0eXBlICcgKyB0aGlzLmN0b3JOYW1lICtcbiAgICAgICAgICAnIChpdCBoYXMgJyArIHRoaXMubnVtQ2hpbGRyZW4oKSArICcgY2hpbGRyZW4pJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpcnN0Q2hpbGQoKTtcbiAgICB9XG4gIH1cblxuICBmaXJzdENoaWxkKCkge1xuICAgIGlmICh0aGlzLmhhc05vQ2hpbGRyZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdjYW5ub3QgZ2V0IGZpcnN0IGNoaWxkIG9mIGEgJyArIHRoaXMuY3Rvck5hbWUgKyAnIG5vZGUsIHdoaWNoIGhhcyBubyBjaGlsZHJlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZEF0KDApO1xuICAgIH1cbiAgfVxuXG4gIGxhc3RDaGlsZCgpIHtcbiAgICBpZiAodGhpcy5oYXNOb0NoaWxkcmVuKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IGdldCBsYXN0IGNoaWxkIG9mIGEgJyArIHRoaXMuY3Rvck5hbWUgKyAnIG5vZGUsIHdoaWNoIGhhcyBubyBjaGlsZHJlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZEF0KHRoaXMubnVtQ2hpbGRyZW4oKSAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIGNoaWxkQmVmb3JlKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRJZHggPSB0aGlzLmluZGV4T2ZDaGlsZChjaGlsZCk7XG4gICAgaWYgKGNoaWxkSWR4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlLmNoaWxkQmVmb3JlKCkgY2FsbGVkIHcvIGFuIGFyZ3VtZW50IHRoYXQgaXMgbm90IGEgY2hpbGQnKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkSWR4ID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgY2hpbGQgYmVmb3JlIGZpcnN0IGNoaWxkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoY2hpbGRJZHggLSAxKTtcbiAgICB9XG4gIH1cblxuICBjaGlsZEFmdGVyKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRJZHggPSB0aGlzLmluZGV4T2ZDaGlsZChjaGlsZCk7XG4gICAgaWYgKGNoaWxkSWR4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlLmNoaWxkQWZ0ZXIoKSBjYWxsZWQgdy8gYW4gYXJndW1lbnQgdGhhdCBpcyBub3QgYSBjaGlsZCcpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRJZHggPT09IHRoaXMubnVtQ2hpbGRyZW4oKSAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBjaGlsZCBhZnRlciBsYXN0IGNoaWxkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoY2hpbGRJZHggKyAxKTtcbiAgICB9XG4gIH1cblxuICBpc1Rlcm1pbmFsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzTm9udGVybWluYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtbdGhpcy5jdG9yTmFtZV06IHRoaXMuY2hpbGRyZW59O1xuICB9XG59XG5cbi8vIFRlcm1pbmFsc1xuXG5jbGFzcyBUZXJtaW5hbE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZ3JhbW1hciwgdmFsdWUpIHtcbiAgICBjb25zdCBtYXRjaExlbmd0aCA9IHZhbHVlID8gdmFsdWUubGVuZ3RoIDogMDtcbiAgICBzdXBlcihncmFtbWFyLCAnX3Rlcm1pbmFsJywgbWF0Y2hMZW5ndGgpO1xuICAgIHRoaXMucHJpbWl0aXZlVmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGlzVGVybWluYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtbdGhpcy5jdG9yTmFtZV06IHRoaXMucHJpbWl0aXZlVmFsdWV9O1xuICB9XG59XG5cbi8vIE5vbnRlcm1pbmFsc1xuXG5jbGFzcyBOb250ZXJtaW5hbE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZ3JhbW1hciwgcnVsZU5hbWUsIGNoaWxkcmVuLCBjaGlsZE9mZnNldHMsIG1hdGNoTGVuZ3RoKSB7XG4gICAgc3VwZXIoZ3JhbW1hciwgcnVsZU5hbWUsIG1hdGNoTGVuZ3RoKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5jaGlsZE9mZnNldHMgPSBjaGlsZE9mZnNldHM7XG4gIH1cblxuICBpc05vbnRlcm1pbmFsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNMZXhpY2FsKCkge1xuICAgIHJldHVybiBjb21tb24uaXNMZXhpY2FsKHRoaXMuY3Rvck5hbWUpO1xuICB9XG5cbiAgaXNTeW50YWN0aWMoKSB7XG4gICAgcmV0dXJuIGNvbW1vbi5pc1N5bnRhY3RpYyh0aGlzLmN0b3JOYW1lKTtcbiAgfVxufVxuXG4vLyBJdGVyYXRpb25zXG5cbmNsYXNzIEl0ZXJhdGlvbk5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZ3JhbW1hciwgY2hpbGRyZW4sIGNoaWxkT2Zmc2V0cywgbWF0Y2hMZW5ndGgsIGlzT3B0aW9uYWwpIHtcbiAgICBzdXBlcihncmFtbWFyLCAnX2l0ZXInLCBtYXRjaExlbmd0aCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2hpbGRPZmZzZXRzID0gY2hpbGRPZmZzZXRzO1xuICAgIHRoaXMub3B0aW9uYWwgPSBpc09wdGlvbmFsO1xuICB9XG5cbiAgaXNJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc09wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTm9kZSxcbiAgVGVybWluYWxOb2RlLFxuICBOb250ZXJtaW5hbE5vZGUsXG4gIEl0ZXJhdGlvbk5vZGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIFJldHVybiB0cnVlIGlmIHdlIHNob3VsZCBza2lwIHNwYWNlcyBwcmVjZWRpbmcgdGhpcyBleHByZXNzaW9uIGluIGEgc3ludGFjdGljIGNvbnRleHQuXG4qL1xucGV4cHJzLlBFeHByLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID0gY29tbW9uLmFic3RyYWN0KFxuICAgICdhbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlJ1xuKTtcblxuLypcbiAgR2VuZXJhbGx5LCB0aGVzZSBhcmUgYWxsIGZpcnN0LW9yZGVyIGV4cHJlc3Npb25zIGFuZCAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIEFwcGx5KVxuICBkaXJlY3RseSByZWFkIGZyb20gdGhlIGlucHV0IHN0cmVhbS5cbiovXG5wZXhwcnMuYW55LmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLmVuZC5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5BcHBseS5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qXG4gIEhpZ2hlci1vcmRlciBleHByZXNzaW9ucyB0aGF0IGRvbid0IGRpcmVjdGx5IGNvbnN1bWUgaW5wdXQuXG4qL1xucGV4cHJzLkFsdC5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuSXRlci5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLlNlcS5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgQnVpbHRJblJ1bGVzO1xuXG51dGlsLmF3YWl0QnVpbHRJblJ1bGVzKGcgPT4geyBCdWlsdEluUnVsZXMgPSBnOyB9KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBsZXhpZnlDb3VudDtcblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGxleGlmeUNvdW50ID0gMDtcbiAgdGhpcy5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xufTtcblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBjb21tb24uYWJzdHJhY3QoXG4gICAgJ19hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCdcbik7XG5cbnBleHBycy5hbnkuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5lbmQuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgLy8gbm8tb3Bcbn07XG5cbnBleHBycy5MZXgucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGxleGlmeUNvdW50Kys7XG4gIHRoaXMuZXhwci5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xuICBsZXhpZnlDb3VudC0tO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy50ZXJtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy50ZXJtc1tpZHhdLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG4gIH1cbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuZmFjdG9ycy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy5mYWN0b3JzW2lkeF0uX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbiAgfVxufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgdGhpcy5leHByLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGNvbnN0IHJ1bGVJbmZvID0gZ3JhbW1hci5ydWxlc1t0aGlzLnJ1bGVOYW1lXTtcblxuICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcnVsZSBleGlzdHMuLi5cbiAgaWYgKCFydWxlSW5mbykge1xuICAgIHRocm93IGVycm9ycy51bmRlY2xhcmVkUnVsZSh0aGlzLnJ1bGVOYW1lLCBncmFtbWFyLm5hbWUsIHRoaXMuc291cmNlKTtcbiAgfVxuXG4gIC8vIC4uLmFuZCB0aGF0IHRoaXMgYXBwbGljYXRpb24gaXMgYWxsb3dlZFxuICBpZiAoY29tbW9uLmlzU3ludGFjdGljKHRoaXMucnVsZU5hbWUpICYmICghY29tbW9uLmlzU3ludGFjdGljKHJ1bGVOYW1lKSB8fCBsZXhpZnlDb3VudCA+IDApKSB7XG4gICAgdGhyb3cgZXJyb3JzLmFwcGxpY2F0aW9uT2ZTeW50YWN0aWNSdWxlRnJvbUxleGljYWxDb250ZXh0KHRoaXMucnVsZU5hbWUsIHRoaXMpO1xuICB9XG5cbiAgLy8gLi4uYW5kIHRoYXQgdGhpcyBhcHBsaWNhdGlvbiBoYXMgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICBjb25zdCBhY3R1YWwgPSB0aGlzLmFyZ3MubGVuZ3RoO1xuICBjb25zdCBleHBlY3RlZCA9IHJ1bGVJbmZvLmZvcm1hbHMubGVuZ3RoO1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIHRocm93IGVycm9ycy53cm9uZ051bWJlck9mQXJndW1lbnRzKHRoaXMucnVsZU5hbWUsIGV4cGVjdGVkLCBhY3R1YWwsIHRoaXMuc291cmNlKTtcbiAgfVxuXG4gIC8vIC4uLmFuZCB0aGF0IGFsbCBvZiB0aGUgYXJndW1lbnQgZXhwcmVzc2lvbnMgb25seSBoYXZlIHZhbGlkIGFwcGxpY2F0aW9ucyBhbmQgaGF2ZSBhcml0eSAxLlxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5hcmdzLmZvckVhY2goYXJnID0+IHtcbiAgICBhcmcuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbiAgICBpZiAoYXJnLmdldEFyaXR5KCkgIT09IDEpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbnZhbGlkUGFyYW1ldGVyKHNlbGYucnVsZU5hbWUsIGFyZyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBFeHRyYSBjaGVja3MgZm9yIFwic3BlY2lhbFwiIGFwcGxpY2F0aW9uc1xuXG4gIC8vIElmIGl0J3MgYW4gYXBwbGljYXRpb24gb2YgJ2Nhc2VJbnNlbnNpdGl2ZScsIGVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhIFRlcm1pbmFsLlxuICBpZiAoQnVpbHRJblJ1bGVzICYmIHJ1bGVJbmZvID09PSBCdWlsdEluUnVsZXMucnVsZXMuY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgaWYgKCEodGhpcy5hcmdzWzBdIGluc3RhbmNlb2YgcGV4cHJzLlRlcm1pbmFsKSkge1xuICAgICAgdGhyb3cgZXJyb3JzLmluY29ycmVjdEFyZ3VtZW50VHlwZSgnYSBUZXJtaW5hbCAoZS5nLiBcXFwiYWJjXFxcIiknLCB0aGlzLmFyZ3NbMF0pO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBjb21tb24uYWJzdHJhY3QoXG4gICAgJ2Fzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5J1xuKTtcblxucGV4cHJzLmFueS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuZW5kLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5MZXgucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICAvLyBuby1vcFxufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICBpZiAodGhpcy50ZXJtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYXJpdHkgPSB0aGlzLnRlcm1zWzBdLmdldEFyaXR5KCk7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMudGVybXMubGVuZ3RoOyBpZHgrKykge1xuICAgIGNvbnN0IHRlcm0gPSB0aGlzLnRlcm1zW2lkeF07XG4gICAgdGVybS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSgpO1xuICAgIGNvbnN0IG90aGVyQXJpdHkgPSB0ZXJtLmdldEFyaXR5KCk7XG4gICAgaWYgKGFyaXR5ICE9PSBvdGhlckFyaXR5KSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW5jb25zaXN0ZW50QXJpdHkocnVsZU5hbWUsIGFyaXR5LCBvdGhlckFyaXR5LCB0ZXJtKTtcbiAgICB9XG4gIH1cbn07XG5cbnBleHBycy5FeHRlbmQucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgLy8gRXh0ZW5kIGlzIGEgc3BlY2lhbCBjYXNlIG9mIEFsdCB0aGF0J3MgZ3VhcmFudGVlZCB0byBoYXZlIGV4YWN0bHkgdHdvXG4gIC8vIGNhc2VzOiBbZXh0ZW5zaW9ucywgb3JpZ0JvZHldLlxuICBjb25zdCBhY3R1YWxBcml0eSA9IHRoaXMudGVybXNbMF0uZ2V0QXJpdHkoKTtcbiAgY29uc3QgZXhwZWN0ZWRBcml0eSA9IHRoaXMudGVybXNbMV0uZ2V0QXJpdHkoKTtcbiAgaWYgKGFjdHVhbEFyaXR5ICE9PSBleHBlY3RlZEFyaXR5KSB7XG4gICAgdGhyb3cgZXJyb3JzLmluY29uc2lzdGVudEFyaXR5KHJ1bGVOYW1lLCBleHBlY3RlZEFyaXR5LCBhY3R1YWxBcml0eSwgdGhpcy50ZXJtc1swXSk7XG4gIH1cbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLmZhY3RvcnNbaWR4XS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eShydWxlTmFtZSk7XG4gIH1cbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIHRoaXMuZXhwci5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eShydWxlTmFtZSk7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIC8vIG5vLW9wIChub3QgcmVxdWlyZWQgYi9jIHRoZSBuZXN0ZWQgZXhwciBkb2Vzbid0IHNob3cgdXAgaW4gdGhlIENTVClcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgdGhpcy5leHByLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5KHJ1bGVOYW1lKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICAvLyBUaGUgYXJpdGllcyBvZiB0aGUgcGFyYW1ldGVyIGV4cHJlc3Npb25zIGlzIHJlcXVpcmVkIHRvIGJlIDEgYnlcbiAgLy8gYGFzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKClgLlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gY29tbW9uLmFic3RyYWN0KFxuICAgICdhc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUnXG4pO1xuXG5wZXhwcnMuYW55LmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuZW5kLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgLy8gbm8tb3Bcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy50ZXJtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy50ZXJtc1tpZHhdLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbiAgfVxufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXMuZmFjdG9yc1tpZHhdLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbiAgfVxufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgLy8gTm90ZTogdGhpcyBpcyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZm9yIGBTdGFyYCBhbmQgYFBsdXNgIGV4cHJlc3Npb25zLlxuICAvLyBJdCBpcyBvdmVycmlkZGVuIGZvciBgT3B0YCBiZWxvdy5cbiAgdGhpcy5leHByLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbiAgaWYgKHRoaXMuZXhwci5pc051bGxhYmxlKGdyYW1tYXIpKSB7XG4gICAgdGhyb3cgZXJyb3JzLmtsZWVuZUV4cHJIYXNOdWxsYWJsZU9wZXJhbmQodGhpcywgW10pO1xuICB9XG59O1xuXG5wZXhwcnMuT3B0LnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHRoaXMuZXhwci5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUoZ3JhbW1hcik7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgdGhpcy5hcmdzLmZvckVhY2goYXJnID0+IHtcbiAgICBhcmcuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlKGdyYW1tYXIpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3Qgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5jaGVjayA9IGNvbW1vbi5hYnN0cmFjdCgnY2hlY2snKTtcblxucGV4cHJzLmFueS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHMubGVuZ3RoID49IDE7XG59O1xuXG5wZXhwcnMuZW5kLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgIHZhbHNbMF0uaXNUZXJtaW5hbCgpICYmXG4gICAgICAgICB2YWxzWzBdLnByaW1pdGl2ZVZhbHVlID09PSB1bmRlZmluZWQ7XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgIHZhbHNbMF0uaXNUZXJtaW5hbCgpICYmXG4gICAgICAgICB2YWxzWzBdLnByaW1pdGl2ZVZhbHVlID09PSB0aGlzLm9iajtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB2YWxzWzBdIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSAmJlxuICAgICAgICAgdmFsc1swXS5pc1Rlcm1pbmFsKCkgJiZcbiAgICAgICAgIHR5cGVvZiB2YWxzWzBdLnByaW1pdGl2ZVZhbHVlID09PSB0eXBlb2YgdGhpcy5mcm9tO1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHMubGVuZ3RoID49IDE7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRlcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGVybSA9IHRoaXMudGVybXNbaV07XG4gICAgaWYgKHRlcm0uY2hlY2soZ3JhbW1hciwgdmFscykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gdGhpcy5mYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IuY2hlY2soZ3JhbW1hciwgdmFscy5zbGljZShwb3MpKSkge1xuICAgICAgcG9zICs9IGZhY3Rvci5nZXRBcml0eSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICBjb25zdCBhcml0eSA9IHRoaXMuZ2V0QXJpdHkoKTtcbiAgY29uc3QgY29sdW1ucyA9IHZhbHMuc2xpY2UoMCwgYXJpdHkpO1xuICBpZiAoY29sdW1ucy5sZW5ndGggIT09IGFyaXR5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvd0NvdW50ID0gY29sdW1uc1swXS5sZW5ndGg7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxOyBpIDwgYXJpdHk7IGkrKykge1xuICAgIGlmIChjb2x1bW5zW2ldLmxlbmd0aCAhPT0gcm93Q291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJpdHk7IGorKykge1xuICAgICAgcm93LnB1c2goY29sdW1uc1tqXVtpXSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5leHByLmNoZWNrKGdyYW1tYXIsIHJvdykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmNoZWNrID1cbnBleHBycy5MZXgucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdGhpcy5leHByLmNoZWNrKGdyYW1tYXIsIHZhbHMpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgaWYgKCEodmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgdmFsc1swXS5ncmFtbWFyID09PSBncmFtbWFyICYmXG4gICAgICAgIHZhbHNbMF0uY3Rvck5hbWUgPT09IHRoaXMucnVsZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVE9ETzogdGhpbmsgYWJvdXQgKm5vdCogZG9pbmcgdGhlIGZvbGxvd2luZyBjaGVja3MsIGkuZS4sIHRydXN0aW5nIHRoYXQgdGhlIHJ1bGVcbiAgLy8gd2FzIGNvcnJlY3RseSBjb25zdHJ1Y3RlZC5cbiAgY29uc3QgcnVsZU5vZGUgPSB2YWxzWzBdO1xuICBjb25zdCBib2R5ID0gZ3JhbW1hci5ydWxlc1t0aGlzLnJ1bGVOYW1lXS5ib2R5O1xuICByZXR1cm4gYm9keS5jaGVjayhncmFtbWFyLCBydWxlTm9kZS5jaGlsZHJlbikgJiYgcnVsZU5vZGUubnVtQ2hpbGRyZW4oKSA9PT0gYm9keS5nZXRBcml0eSgpO1xufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHNbMF0gaW5zdGFuY2VvZiBub2Rlcy5Ob2RlICYmXG4gICAgICAgICB2YWxzWzBdLmlzVGVybWluYWwoKSAmJlxuICAgICAgICAgdHlwZW9mIHZhbHNbMF0ucHJpbWl0aXZlVmFsdWUgPT09ICdzdHJpbmcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFRyYWNlID0gcmVxdWlyZSgnLi9UcmFjZScpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbmNvbnN0IFRlcm1pbmFsTm9kZSA9IG5vZGVzLlRlcm1pbmFsTm9kZTtcbmNvbnN0IE5vbnRlcm1pbmFsTm9kZSA9IG5vZGVzLk5vbnRlcm1pbmFsTm9kZTtcbmNvbnN0IEl0ZXJhdGlvbk5vZGUgPSBub2Rlcy5JdGVyYXRpb25Ob2RlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgRXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gYW5kIHJldHVybiBgdHJ1ZWAgaWYgaXQgc3VjY2VlZHMsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGlzIG1ldGhvZCBzaG91bGRcbiAgb25seSBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgYFN0YXRlLnByb3RvdHlwZS5ldmFsKGV4cHIpYCwgd2hpY2ggYWxzbyB1cGRhdGVzIHRoZSBkYXRhIHN0cnVjdHVyZXNcbiAgdGhhdCBhcmUgdXNlZCBmb3IgdHJhY2luZy4gKE1ha2luZyB0aG9zZSB1cGRhdGVzIGluIGEgbWV0aG9kIG9mIGBTdGF0ZWAgZW5hYmxlcyB0aGUgdHJhY2Utc3BlY2lmaWNcbiAgZGF0YSBzdHJ1Y3R1cmVzIHRvIGJlIFwic2VjcmV0c1wiIG9mIHRoYXQgY2xhc3MsIHdoaWNoIGlzIGdvb2QgZm9yIG1vZHVsYXJpdHkuKVxuXG4gIFRoZSBjb250cmFjdCBvZiB0aGlzIG1ldGhvZCBpcyBhcyBmb2xsb3dzOlxuICAqIFdoZW4gdGhlIHJldHVybiB2YWx1ZSBpcyBgdHJ1ZWAsXG4gICAgLSB0aGUgc3RhdGUgb2JqZWN0IHdpbGwgaGF2ZSBgZXhwci5nZXRBcml0eSgpYCBtb3JlIGJpbmRpbmdzIHRoYW4gaXQgZGlkIGJlZm9yZSB0aGUgY2FsbC5cbiAgKiBXaGVuIHRoZSByZXR1cm4gdmFsdWUgaXMgYGZhbHNlYCxcbiAgICAtIHRoZSBzdGF0ZSBvYmplY3QgbWF5IGhhdmUgbW9yZSBiaW5kaW5ncyB0aGFuIGl0IGRpZCBiZWZvcmUgdGhlIGNhbGwsIGFuZFxuICAgIC0gaXRzIGlucHV0IHN0cmVhbSdzIHBvc2l0aW9uIG1heSBiZSBhbnl3aGVyZS5cblxuICBOb3RlIHRoYXQgYFN0YXRlLnByb3RvdHlwZS5ldmFsKGV4cHIpYCwgdW5saWtlIHRoaXMgbWV0aG9kLCBndWFyYW50ZWVzIHRoYXQgbmVpdGhlciB0aGUgc3RhdGVcbiAgb2JqZWN0J3MgYmluZGluZ3Mgbm9yIGl0cyBpbnB1dCBzdHJlYW0ncyBwb3NpdGlvbiB3aWxsIGNoYW5nZSBpZiB0aGUgZXhwcmVzc2lvbiBmYWlscyB0byBtYXRjaC5cbiovXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmV2YWwgPSBjb21tb24uYWJzdHJhY3QoJ2V2YWwnKTsgLy8gZnVuY3Rpb24oc3RhdGUpIHsgLi4uIH1cblxucGV4cHJzLmFueS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3QgY2ggPSBpbnB1dFN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCkge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgY2gpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5lbmQuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGlmIChpbnB1dFN0cmVhbS5hdEVuZCgpKSB7XG4gICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCB1bmRlZmluZWQpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGlmICghaW5wdXRTdHJlYW0ubWF0Y2hTdHJpbmcodGhpcy5vYmopKSB7XG4gICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgdGhpcy5vYmopLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3QgY2ggPSBpbnB1dFN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCAmJiB0aGlzLmZyb20gPD0gY2ggJiYgY2ggPD0gdGhpcy50bykge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgY2gpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5ldmFsKHN0YXRlLmN1cnJlbnRBcHBsaWNhdGlvbigpLmFyZ3NbdGhpcy5pbmRleF0pO1xufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmVudGVyTGV4aWZpZWRDb250ZXh0KCk7XG4gIGNvbnN0IGFucyA9IHN0YXRlLmV2YWwodGhpcy5leHByKTtcbiAgc3RhdGUuZXhpdExleGlmaWVkQ29udGV4dCgpO1xuICByZXR1cm4gYW5zO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMudGVybXMubGVuZ3RoOyBpZHgrKykge1xuICAgIGlmIChzdGF0ZS5ldmFsKHRoaXMudGVybXNbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSB0aGlzLmZhY3RvcnNbaWR4XTtcbiAgICBpZiAoIXN0YXRlLmV2YWwoZmFjdG9yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3QgYXJpdHkgPSB0aGlzLmdldEFyaXR5KCk7XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgY29uc3QgY29sT2Zmc2V0cyA9IFtdO1xuICB3aGlsZSAoY29scy5sZW5ndGggPCBhcml0eSkge1xuICAgIGNvbHMucHVzaChbXSk7XG4gICAgY29sT2Zmc2V0cy5wdXNoKFtdKTtcbiAgfVxuXG4gIGxldCBudW1NYXRjaGVzID0gMDtcbiAgbGV0IHByZXZQb3MgPSBvcmlnUG9zO1xuICBsZXQgaWR4O1xuICB3aGlsZSAobnVtTWF0Y2hlcyA8IHRoaXMubWF4TnVtTWF0Y2hlcyAmJiBzdGF0ZS5ldmFsKHRoaXMuZXhwcikpIHtcbiAgICBpZiAoaW5wdXRTdHJlYW0ucG9zID09PSBwcmV2UG9zKSB7XG4gICAgICB0aHJvdyBlcnJvcnMua2xlZW5lRXhwckhhc051bGxhYmxlT3BlcmFuZCh0aGlzLCBzdGF0ZS5fYXBwbGljYXRpb25TdGFjayk7XG4gICAgfVxuICAgIHByZXZQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gICAgbnVtTWF0Y2hlcysrO1xuICAgIGNvbnN0IHJvdyA9IHN0YXRlLl9iaW5kaW5ncy5zcGxpY2Uoc3RhdGUuX2JpbmRpbmdzLmxlbmd0aCAtIGFyaXR5LCBhcml0eSk7XG4gICAgY29uc3Qgcm93T2Zmc2V0cyA9IHN0YXRlLl9iaW5kaW5nT2Zmc2V0cy5zcGxpY2Uoc3RhdGUuX2JpbmRpbmdPZmZzZXRzLmxlbmd0aCAtIGFyaXR5LCBhcml0eSk7XG4gICAgZm9yIChpZHggPSAwOyBpZHggPCByb3cubGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29sc1tpZHhdLnB1c2gocm93W2lkeF0pO1xuICAgICAgY29sT2Zmc2V0c1tpZHhdLnB1c2gocm93T2Zmc2V0c1tpZHhdKTtcbiAgICB9XG4gIH1cbiAgaWYgKG51bU1hdGNoZXMgPCB0aGlzLm1pbk51bU1hdGNoZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IG9mZnNldCA9IHN0YXRlLnBvc1RvT2Zmc2V0KG9yaWdQb3MpO1xuICBsZXQgbWF0Y2hMZW5ndGggPSAwO1xuICBpZiAobnVtTWF0Y2hlcyA+IDApIHtcbiAgICBjb25zdCBsYXN0Q29sID0gY29sc1thcml0eSAtIDFdO1xuICAgIGNvbnN0IGxhc3RDb2xPZmZzZXRzID0gY29sT2Zmc2V0c1thcml0eSAtIDFdO1xuXG4gICAgY29uc3QgZW5kT2Zmc2V0ID1cbiAgICAgICAgbGFzdENvbE9mZnNldHNbbGFzdENvbE9mZnNldHMubGVuZ3RoIC0gMV0gKyBsYXN0Q29sW2xhc3RDb2wubGVuZ3RoIC0gMV0ubWF0Y2hMZW5ndGg7XG4gICAgb2Zmc2V0ID0gY29sT2Zmc2V0c1swXVswXTtcbiAgICBtYXRjaExlbmd0aCA9IGVuZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuICBjb25zdCBpc09wdGlvbmFsID0gdGhpcyBpbnN0YW5jZW9mIHBleHBycy5PcHQ7XG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgY29scy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgc3RhdGUuX2JpbmRpbmdzLnB1c2goXG4gICAgICAgIG5ldyBJdGVyYXRpb25Ob2RlKHN0YXRlLmdyYW1tYXIsIGNvbHNbaWR4XSwgY29sT2Zmc2V0c1tpZHhdLCBtYXRjaExlbmd0aCwgaXNPcHRpb25hbCkpO1xuICAgIHN0YXRlLl9iaW5kaW5nT2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgLypcbiAgICBUT0RPOlxuICAgIC0gUmlnaHQgbm93IHdlJ3JlIGp1c3QgdGhyb3dpbmcgYXdheSBhbGwgb2YgdGhlIGZhaWx1cmVzIHRoYXQgaGFwcGVuIGluc2lkZSBhIGBub3RgLCBhbmRcbiAgICAgIHJlY29yZGluZyBgdGhpc2AgYXMgYSBmYWlsZWQgZXhwcmVzc2lvbi5cbiAgICAtIERvdWJsZSBuZWdhdGlvbiBzaG91bGQgYmUgZXF1aXZhbGVudCB0byBsb29rYWhlYWQsIGJ1dCB0aGF0J3Mgbm90IHRoZSBjYXNlIHJpZ2h0IG5vdyB3cnRcbiAgICAgIGZhaWx1cmVzLiBFLmcuLCB+fidmb28nIHByb2R1Y2VzIGEgZmFpbHVyZSBmb3Igfn4nZm9vJywgYnV0IG1heWJlIGl0IHNob3VsZCBwcm9kdWNlXG4gICAgICBhIGZhaWx1cmUgZm9yICdmb28nIGluc3RlYWQuXG4gICovXG5cbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgc3RhdGUucHVzaEZhaWx1cmVzSW5mbygpO1xuXG4gIGNvbnN0IGFucyA9IHN0YXRlLmV2YWwodGhpcy5leHByKTtcblxuICBzdGF0ZS5wb3BGYWlsdXJlc0luZm8oKTtcbiAgaWYgKGFucykge1xuICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3M7XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGlmIChzdGF0ZS5ldmFsKHRoaXMuZXhwcikpIHtcbiAgICBpbnB1dFN0cmVhbS5wb3MgPSBvcmlnUG9zO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgY2FsbGVyID0gc3RhdGUuY3VycmVudEFwcGxpY2F0aW9uKCk7XG4gIGNvbnN0IGFjdHVhbHMgPSBjYWxsZXIgPyBjYWxsZXIuYXJncyA6IFtdO1xuICBjb25zdCBhcHAgPSB0aGlzLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscyk7XG5cbiAgY29uc3QgcG9zSW5mbyA9IHN0YXRlLmdldEN1cnJlbnRQb3NJbmZvKCk7XG4gIGlmIChwb3NJbmZvLmlzQWN0aXZlKGFwcCkpIHtcbiAgICAvLyBUaGlzIHJ1bGUgaXMgYWxyZWFkeSBhY3RpdmUgYXQgdGhpcyBwb3NpdGlvbiwgaS5lLiwgaXQgaXMgbGVmdC1yZWN1cnNpdmUuXG4gICAgcmV0dXJuIGFwcC5oYW5kbGVDeWNsZShzdGF0ZSk7XG4gIH1cblxuICBjb25zdCBtZW1vS2V5ID0gYXBwLnRvTWVtb0tleSgpO1xuICBjb25zdCBtZW1vUmVjID0gcG9zSW5mby5tZW1vW21lbW9LZXldO1xuXG4gIGlmIChtZW1vUmVjICYmIHBvc0luZm8uc2hvdWxkVXNlTWVtb2l6ZWRSZXN1bHQobWVtb1JlYykpIHtcbiAgICBpZiAoc3RhdGUuaGFzTmVjZXNzYXJ5SW5mbyhtZW1vUmVjKSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnVzZU1lbW9pemVkUmVzdWx0KHN0YXRlLmlucHV0U3RyZWFtLnBvcywgbWVtb1JlYyk7XG4gICAgfVxuICAgIGRlbGV0ZSBwb3NJbmZvLm1lbW9bbWVtb0tleV07XG4gIH1cbiAgcmV0dXJuIGFwcC5yZWFsbHlFdmFsKHN0YXRlKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuaGFuZGxlQ3ljbGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBwb3NJbmZvID0gc3RhdGUuZ2V0Q3VycmVudFBvc0luZm8oKTtcbiAgY29uc3QgY3VycmVudExlZnRSZWN1cnNpb24gPSBwb3NJbmZvLmN1cnJlbnRMZWZ0UmVjdXJzaW9uO1xuICBjb25zdCBtZW1vS2V5ID0gdGhpcy50b01lbW9LZXkoKTtcbiAgbGV0IG1lbW9SZWMgPSBwb3NJbmZvLm1lbW9bbWVtb0tleV07XG5cbiAgaWYgKGN1cnJlbnRMZWZ0UmVjdXJzaW9uICYmIGN1cnJlbnRMZWZ0UmVjdXJzaW9uLmhlYWRBcHBsaWNhdGlvbi50b01lbW9LZXkoKSA9PT0gbWVtb0tleSkge1xuICAgIC8vIFdlIGFscmVhZHkga25vdyBhYm91dCB0aGlzIGxlZnQgcmVjdXJzaW9uLCBidXQgaXQncyBwb3NzaWJsZSB0aGVyZSBhcmUgXCJpbnZvbHZlZFxuICAgIC8vIGFwcGxpY2F0aW9uc1wiIHRoYXQgd2UgZG9uJ3QgYWxyZWFkeSBrbm93IGFib3V0LCBzby4uLlxuICAgIG1lbW9SZWMudXBkYXRlSW52b2x2ZWRBcHBsaWNhdGlvbk1lbW9LZXlzKCk7XG4gIH0gZWxzZSBpZiAoIW1lbW9SZWMpIHtcbiAgICAvLyBOZXcgbGVmdCByZWN1cnNpb24gZGV0ZWN0ZWQhIE1lbW9pemUgYSBmYWlsdXJlIHRvIHRyeSB0byBnZXQgYSBzZWVkIHBhcnNlLlxuICAgIG1lbW9SZWMgPSBwb3NJbmZvLm1lbW9pemUoXG4gICAgICAgIG1lbW9LZXksXG4gICAgICAgIHttYXRjaExlbmd0aDogMCwgZXhhbWluZWRMZW5ndGg6IDAsIHZhbHVlOiBmYWxzZSwgcmlnaHRtb3N0RmFpbHVyZU9mZnNldDogLTF9KTtcbiAgICBwb3NJbmZvLnN0YXJ0TGVmdFJlY3Vyc2lvbih0aGlzLCBtZW1vUmVjKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudXNlTWVtb2l6ZWRSZXN1bHQoc3RhdGUuaW5wdXRTdHJlYW0ucG9zLCBtZW1vUmVjKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUucmVhbGx5RXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGNvbnN0IG9yaWdQb3NJbmZvID0gc3RhdGUuZ2V0Q3VycmVudFBvc0luZm8oKTtcbiAgY29uc3QgcnVsZUluZm8gPSBzdGF0ZS5ncmFtbWFyLnJ1bGVzW3RoaXMucnVsZU5hbWVdO1xuICBjb25zdCBib2R5ID0gcnVsZUluZm8uYm9keTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBydWxlSW5mby5kZXNjcmlwdGlvbjtcblxuICBzdGF0ZS5lbnRlckFwcGxpY2F0aW9uKG9yaWdQb3NJbmZvLCB0aGlzKTtcblxuICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICBzdGF0ZS5wdXNoRmFpbHVyZXNJbmZvKCk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgaW5wdXQgc3RyZWFtJ3MgZXhhbWluZWRMZW5ndGggcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gdHJhY2tcbiAgLy8gdGhlIGV4YW1pbmVkIGxlbmd0aCBvZiB0aGlzIHBhcnRpY3VsYXIgYXBwbGljYXRpb24uXG4gIGNvbnN0IG9yaWdJbnB1dFN0cmVhbUV4YW1pbmVkTGVuZ3RoID0gaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGg7XG4gIGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoID0gMDtcblxuICBsZXQgdmFsdWUgPSB0aGlzLmV2YWxPbmNlKGJvZHksIHN0YXRlKTtcbiAgY29uc3QgY3VycmVudExSID0gb3JpZ1Bvc0luZm8uY3VycmVudExlZnRSZWN1cnNpb247XG4gIGNvbnN0IG1lbW9LZXkgPSB0aGlzLnRvTWVtb0tleSgpO1xuICBjb25zdCBpc0hlYWRPZkxlZnRSZWN1cnNpb24gPSBjdXJyZW50TFIgJiYgY3VycmVudExSLmhlYWRBcHBsaWNhdGlvbi50b01lbW9LZXkoKSA9PT0gbWVtb0tleTtcbiAgbGV0IG1lbW9SZWM7XG5cbiAgaWYgKGlzSGVhZE9mTGVmdFJlY3Vyc2lvbikge1xuICAgIHZhbHVlID0gdGhpcy5ncm93U2VlZFJlc3VsdChib2R5LCBzdGF0ZSwgb3JpZ1BvcywgY3VycmVudExSLCB2YWx1ZSk7XG4gICAgb3JpZ1Bvc0luZm8uZW5kTGVmdFJlY3Vyc2lvbigpO1xuICAgIG1lbW9SZWMgPSBjdXJyZW50TFI7XG4gICAgbWVtb1JlYy5leGFtaW5lZExlbmd0aCA9IGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoIC0gb3JpZ1BvcztcbiAgICBtZW1vUmVjLnJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPSBzdGF0ZS5fZ2V0UmlnaHRtb3N0RmFpbHVyZU9mZnNldCgpO1xuICAgIG9yaWdQb3NJbmZvLm1lbW9pemUobWVtb0tleSwgbWVtb1JlYyk7IC8vIHVwZGF0ZXMgb3JpZ1Bvc0luZm8ncyBtYXhFeGFtaW5lZExlbmd0aFxuICB9IGVsc2UgaWYgKCFjdXJyZW50TFIgfHwgIWN1cnJlbnRMUi5pc0ludm9sdmVkKG1lbW9LZXkpKSB7XG4gICAgLy8gVGhpcyBhcHBsaWNhdGlvbiBpcyBub3QgaW52b2x2ZWQgaW4gbGVmdCByZWN1cnNpb24sIHNvIGl0J3Mgb2sgdG8gbWVtb2l6ZSBpdC5cbiAgICBtZW1vUmVjID0gb3JpZ1Bvc0luZm8ubWVtb2l6ZShtZW1vS2V5LCB7XG4gICAgICBtYXRjaExlbmd0aDogaW5wdXRTdHJlYW0ucG9zIC0gb3JpZ1BvcyxcbiAgICAgIGV4YW1pbmVkTGVuZ3RoOiBpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCAtIG9yaWdQb3MsXG4gICAgICB2YWx1ZSxcbiAgICAgIGZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbjogc3RhdGUuY2xvbmVSZWNvcmRlZEZhaWx1cmVzKCksXG4gICAgICByaWdodG1vc3RGYWlsdXJlT2Zmc2V0OiBzdGF0ZS5fZ2V0UmlnaHRtb3N0RmFpbHVyZU9mZnNldCgpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc3VjY2VlZGVkID0gISF2YWx1ZTtcblxuICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICBzdGF0ZS5wb3BGYWlsdXJlc0luZm8oKTtcbiAgICBpZiAoIXN1Y2NlZWRlZCkge1xuICAgICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZW1vUmVjKSB7XG4gICAgICBtZW1vUmVjLmZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbiA9IHN0YXRlLmNsb25lUmVjb3JkZWRGYWlsdXJlcygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlY29yZCB0cmFjZSBpbmZvcm1hdGlvbiBpbiB0aGUgbWVtbyB0YWJsZSwgc28gdGhhdCBpdCBpcyBhdmFpbGFibGUgaWYgdGhlIG1lbW9pemVkIHJlc3VsdFxuICAvLyBpcyB1c2VkIGxhdGVyLlxuICBpZiAoc3RhdGUuaXNUcmFjaW5nKCkgJiYgbWVtb1JlYykge1xuICAgIGNvbnN0IGVudHJ5ID0gc3RhdGUuZ2V0VHJhY2VFbnRyeShvcmlnUG9zLCB0aGlzLCBzdWNjZWVkZWQsIHN1Y2NlZWRlZCA/IFt2YWx1ZV0gOiBbXSk7XG4gICAgaWYgKGlzSGVhZE9mTGVmdFJlY3Vyc2lvbikge1xuICAgICAgY29tbW9uLmFzc2VydChlbnRyeS50ZXJtaW5hdGluZ0xSRW50cnkgIT0gbnVsbCB8fCAhc3VjY2VlZGVkKTtcbiAgICAgIGVudHJ5LmlzSGVhZE9mTGVmdFJlY3Vyc2lvbiA9IHRydWU7XG4gICAgfVxuICAgIG1lbW9SZWMudHJhY2VFbnRyeSA9IGVudHJ5O1xuICB9XG5cbiAgLy8gRml4IHRoZSBpbnB1dCBzdHJlYW0ncyBleGFtaW5lZExlbmd0aCAtLSBpdCBzaG91bGQgYmUgdGhlIG1heGltdW0gZXhhbWluZWQgbGVuZ3RoXG4gIC8vIGFjcm9zcyBhbGwgYXBwbGljYXRpb25zLCBub3QganVzdCB0aGlzIG9uZS5cbiAgaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGggPSBNYXRoLm1heChpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCwgb3JpZ0lucHV0U3RyZWFtRXhhbWluZWRMZW5ndGgpO1xuXG4gIHN0YXRlLmV4aXRBcHBsaWNhdGlvbihvcmlnUG9zSW5mbywgdmFsdWUpO1xuXG4gIHJldHVybiBzdWNjZWVkZWQ7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmV2YWxPbmNlID0gZnVuY3Rpb24oZXhwciwgc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcblxuICBpZiAoc3RhdGUuZXZhbChleHByKSkge1xuICAgIGNvbnN0IGFyaXR5ID0gZXhwci5nZXRBcml0eSgpO1xuICAgIGNvbnN0IGJpbmRpbmdzID0gc3RhdGUuX2JpbmRpbmdzLnNwbGljZShzdGF0ZS5fYmluZGluZ3MubGVuZ3RoIC0gYXJpdHksIGFyaXR5KTtcbiAgICBjb25zdCBvZmZzZXRzID0gc3RhdGUuX2JpbmRpbmdPZmZzZXRzLnNwbGljZShzdGF0ZS5fYmluZGluZ09mZnNldHMubGVuZ3RoIC0gYXJpdHksIGFyaXR5KTtcbiAgICByZXR1cm4gbmV3IE5vbnRlcm1pbmFsTm9kZShcbiAgICAgICAgc3RhdGUuZ3JhbW1hciwgdGhpcy5ydWxlTmFtZSwgYmluZGluZ3MsIG9mZnNldHMsIGlucHV0U3RyZWFtLnBvcyAtIG9yaWdQb3MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5ncm93U2VlZFJlc3VsdCA9IGZ1bmN0aW9uKGJvZHksIHN0YXRlLCBvcmlnUG9zLCBsck1lbW9SZWMsIG5ld1ZhbHVlKSB7XG4gIGlmICghbmV3VmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbHJNZW1vUmVjLm1hdGNoTGVuZ3RoID0gaW5wdXRTdHJlYW0ucG9zIC0gb3JpZ1BvcztcbiAgICBsck1lbW9SZWMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBsck1lbW9SZWMuZmFpbHVyZXNBdFJpZ2h0bW9zdFBvc2l0aW9uID0gc3RhdGUuY2xvbmVSZWNvcmRlZEZhaWx1cmVzKCk7XG5cbiAgICBpZiAoc3RhdGUuaXNUcmFjaW5nKCkpIHtcbiAgICAgIC8vIEJlZm9yZSBldmFsdWF0aW5nIHRoZSBib2R5IGFnYWluLCBhZGQgYSB0cmFjZSBub2RlIGZvciB0aGlzIGFwcGxpY2F0aW9uIHRvIHRoZSBtZW1vIGVudHJ5LlxuICAgICAgLy8gSXRzIG9ubHkgY2hpbGQgaXMgYSBjb3B5IG9mIHRoZSB0cmFjZSBub2RlIGZyb20gYG5ld1ZhbHVlYCwgd2hpY2ggd2lsbCBhbHdheXMgYmUgdGhlIGxhc3RcbiAgICAgIC8vIGVsZW1lbnQgaW4gYHN0YXRlLnRyYWNlYC5cbiAgICAgIGNvbnN0IHNlZWRUcmFjZSA9IHN0YXRlLnRyYWNlW3N0YXRlLnRyYWNlLmxlbmd0aCAtIDFdO1xuICAgICAgbHJNZW1vUmVjLnRyYWNlRW50cnkgPSBuZXcgVHJhY2UoXG4gICAgICAgICAgc3RhdGUuaW5wdXQsIG9yaWdQb3MsIGlucHV0U3RyZWFtLnBvcywgdGhpcywgdHJ1ZSwgW25ld1ZhbHVlXSwgW3NlZWRUcmFjZS5jbG9uZSgpXSk7XG4gICAgfVxuICAgIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3M7XG4gICAgbmV3VmFsdWUgPSB0aGlzLmV2YWxPbmNlKGJvZHksIHN0YXRlKTtcbiAgICBpZiAoaW5wdXRTdHJlYW0ucG9zIC0gb3JpZ1BvcyA8PSBsck1lbW9SZWMubWF0Y2hMZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaXNUcmFjaW5nKCkpIHtcbiAgICAgIHN0YXRlLnRyYWNlLnNwbGljZSgtMiwgMSk7IC8vIERyb3AgdGhlIHRyYWNlIGZvciB0aGUgb2xkIHNlZWQuXG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5pc1RyYWNpbmcoKSkge1xuICAgIC8vIFRoZSBsYXN0IGVudHJ5IGlzIGZvciBhbiB1bnVzZWQgcmVzdWx0IC0tIHBvcCBpdCBhbmQgc2F2ZSBpdCBpbiB0aGUgXCJyZWFsXCIgZW50cnkuXG4gICAgbHJNZW1vUmVjLnRyYWNlRW50cnkucmVjb3JkTFJUZXJtaW5hdGlvbihzdGF0ZS50cmFjZS5wb3AoKSwgbmV3VmFsdWUpO1xuICB9XG4gIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3MgKyBsck1lbW9SZWMubWF0Y2hMZW5ndGg7XG4gIHJldHVybiBsck1lbW9SZWMudmFsdWU7XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBjb25zdCBjaCA9IGlucHV0U3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoICYmIHRoaXMucGF0dGVybi50ZXN0KGNoKSkge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgY2gpLCBvcmlnUG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGZsYXR0ZW4obGlzdE9mTGlzdHMpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGxpc3RPZkxpc3RzKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gY29tbW9uLmFic3RyYWN0KCdnZW5lcmF0ZUV4YW1wbGUnKTtcblxuZnVuY3Rpb24gY2F0ZWdvcml6ZUV4YW1wbGVzKGV4YW1wbGVzKSB7XG4gIC8vIEEgbGlzdCBvZiBydWxlcyB0aGF0IHRoZSBzeXN0ZW0gbmVlZHMgZXhhbXBsZXMgb2YsIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIGV4YW1wbGVcbiAgLy8gICBmb3IgdGhlIGN1cnJlbnQgcnVsZVxuICBsZXQgZXhhbXBsZXNOZWVkZWQgPSBleGFtcGxlcy5maWx0ZXIoZXhhbXBsZSA9PiBleGFtcGxlLmhhc093blByb3BlcnR5KCdleGFtcGxlc05lZWRlZCcpKVxuICAgICAgLm1hcChleGFtcGxlID0+IGV4YW1wbGUuZXhhbXBsZXNOZWVkZWQpO1xuXG4gIGV4YW1wbGVzTmVlZGVkID0gZmxhdHRlbihleGFtcGxlc05lZWRlZCk7XG5cbiAgY29uc3QgdW5pcXVlRXhhbXBsZXNOZWVkZWQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGFtcGxlc05lZWRlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRFeGFtcGxlTmVlZGVkID0gZXhhbXBsZXNOZWVkZWRbaV07XG4gICAgdW5pcXVlRXhhbXBsZXNOZWVkZWRbY3VycmVudEV4YW1wbGVOZWVkZWRdID0gdHJ1ZTtcbiAgfVxuICBleGFtcGxlc05lZWRlZCA9IE9iamVjdC5rZXlzKHVuaXF1ZUV4YW1wbGVzTmVlZGVkKTtcblxuICAvLyBBIGxpc3Qgb2Ygc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCBleGFtcGxlc1xuICBjb25zdCBzdWNjZXNzZnVsRXhhbXBsZXMgPSBleGFtcGxlcy5maWx0ZXIoZXhhbXBsZSA9PiBleGFtcGxlLmhhc093blByb3BlcnR5KCd2YWx1ZScpKVxuICAgICAgLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuXG4gIC8vIFRoaXMgZmxhZyByZXR1cm5zIHRydWUgaWYgdGhlIHN5c3RlbSBjYW5ub3QgZ2VuZXJhdGUgdGhlIHJ1bGUgaXQgaXMgY3VycmVudGx5XG4gIC8vICAgYXR0ZW1wdGluZyB0byBnZW5lcmF0ZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCBpdCBoYXMgdGhlIGV4YW1wbGVzIGl0IG5lZWRzLlxuICAvLyAgIEN1cnJlbnRseSwgdGhpcyBpcyBvbmx5IHVzZWQgaW4gb3ZlcnJpZGluZyBnZW5lcmF0b3JzIHRvIHByZXZlbnQgdGhlIHN5c3RlbSBmcm9tXG4gIC8vICAgZ2VuZXJhdGluZyBleGFtcGxlcyBmb3IgY2VydGFpbiBydWxlcyAoZS5nLiAnaWRlbnQnKS5cbiAgY29uc3QgbmVlZEhlbHAgPSBleGFtcGxlcy5zb21lKGl0ZW0gPT4gaXRlbS5uZWVkSGVscCk7XG5cbiAgcmV0dXJuIHtcbiAgICBleGFtcGxlc05lZWRlZCxcbiAgICBzdWNjZXNzZnVsRXhhbXBsZXMsXG4gICAgbmVlZEhlbHBcbiAgfTtcbn1cblxucGV4cHJzLmFueS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIHJldHVybiB7dmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KSl9O1xufTtcblxuLy8gQXNzdW1lcyB0aGF0IHRlcm1pbmFsJ3Mgb2JqZWN0IGlzIGFsd2F5cyBhIHN0cmluZ1xucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0KSB7XG4gIHJldHVybiB7dmFsdWU6IHRoaXMub2JqfTtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCkge1xuICBjb25zdCByYW5nZVNpemUgPSB0aGlzLnRvLmNoYXJDb2RlQXQoMCkgLSB0aGlzLmZyb20uY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIHt2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgIHRoaXMuZnJvbS5jaGFyQ29kZUF0KDApICsgTWF0aC5mbG9vcihyYW5nZVNpemUgKiBNYXRoLnJhbmRvbSgpKVxuICApfTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICByZXR1cm4gYWN0dWFsc1t0aGlzLmluZGV4XS5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscyk7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIC8vIGl0ZW1zIC0+IHRlcm1FeGFtcGxlc1xuICBjb25zdCB0ZXJtRXhhbXBsZXMgPSB0aGlzLnRlcm1zLm1hcCh0ZXJtID0+IHtcbiAgICByZXR1cm4gdGVybS5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscyk7XG4gIH0pO1xuXG4gIGNvbnN0IGNhdGVnb3JpemVkRXhhbXBsZXMgPSBjYXRlZ29yaXplRXhhbXBsZXModGVybUV4YW1wbGVzKTtcblxuICBjb25zdCBleGFtcGxlc05lZWRlZCA9IGNhdGVnb3JpemVkRXhhbXBsZXMuZXhhbXBsZXNOZWVkZWQ7XG4gIGNvbnN0IHN1Y2Nlc3NmdWxFeGFtcGxlcyA9IGNhdGVnb3JpemVkRXhhbXBsZXMuc3VjY2Vzc2Z1bEV4YW1wbGVzO1xuICBjb25zdCBuZWVkSGVscCA9IGNhdGVnb3JpemVkRXhhbXBsZXMubmVlZEhlbHA7XG5cbiAgY29uc3QgYW5zID0ge307XG5cbiAgLy8gQWx0IGNhbiBjb250YWluIGJvdGggYW4gZXhhbXBsZSBhbmQgYSByZXF1ZXN0IGZvciBleGFtcGxlc1xuICBpZiAoc3VjY2Vzc2Z1bEV4YW1wbGVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc3VjY2Vzc2Z1bEV4YW1wbGVzLmxlbmd0aCk7XG4gICAgYW5zLnZhbHVlID0gc3VjY2Vzc2Z1bEV4YW1wbGVzW2ldO1xuICB9XG4gIGlmIChleGFtcGxlc05lZWRlZC5sZW5ndGggPiAwKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gZXhhbXBsZXNOZWVkZWQ7XG4gIH1cbiAgYW5zLm5lZWRIZWxwID0gbmVlZEhlbHA7XG5cbiAgcmV0dXJuIGFucztcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgY29uc3QgZmFjdG9yRXhhbXBsZXMgPSB0aGlzLmZhY3RvcnMubWFwKGZhY3RvciA9PiB7XG4gICAgcmV0dXJuIGZhY3Rvci5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscyk7XG4gIH0pO1xuICBjb25zdCBjYXRlZ29yaXplZEV4YW1wbGVzID0gY2F0ZWdvcml6ZUV4YW1wbGVzKGZhY3RvckV4YW1wbGVzKTtcblxuICBjb25zdCBleGFtcGxlc05lZWRlZCA9IGNhdGVnb3JpemVkRXhhbXBsZXMuZXhhbXBsZXNOZWVkZWQ7XG4gIGNvbnN0IHN1Y2Nlc3NmdWxFeGFtcGxlcyA9IGNhdGVnb3JpemVkRXhhbXBsZXMuc3VjY2Vzc2Z1bEV4YW1wbGVzO1xuICBjb25zdCBuZWVkSGVscCA9IGNhdGVnb3JpemVkRXhhbXBsZXMubmVlZEhlbHA7XG5cbiAgY29uc3QgYW5zID0ge307XG5cbiAgLy8gSW4gYSBTZXEsIGFsbCBwaWVjZXMgbXVzdCBzdWNjZWVkIGluIG9yZGVyIHRvIGhhdmUgYSBzdWNjZXNzZnVsIGV4YW1wbGUuXG4gIGlmIChleGFtcGxlc05lZWRlZC5sZW5ndGggPiAwIHx8IG5lZWRIZWxwKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gZXhhbXBsZXNOZWVkZWQ7XG4gICAgYW5zLm5lZWRIZWxwID0gbmVlZEhlbHA7XG4gIH0gZWxzZSB7XG4gICAgYW5zLnZhbHVlID0gc3VjY2Vzc2Z1bEV4YW1wbGVzLmpvaW4oaW5TeW50YWN0aWNDb250ZXh0ID8gJyAnIDogJycpO1xuICB9XG5cbiAgcmV0dXJuIGFucztcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIGNvbnN0IHJhbmdlVGltZXMgPSBNYXRoLm1pbih0aGlzLm1heE51bU1hdGNoZXMgLSB0aGlzLm1pbk51bU1hdGNoZXMsIDMpO1xuICBjb25zdCBudW1UaW1lcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChyYW5nZVRpbWVzICsgMSkgKyB0aGlzLm1pbk51bU1hdGNoZXMpO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXM7IGkrKykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5leHByLmdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSk7XG4gIH1cblxuICBjb25zdCBjYXRlZ29yaXplZEV4YW1wbGVzID0gY2F0ZWdvcml6ZUV4YW1wbGVzKGl0ZW1zKTtcblxuICBjb25zdCBleGFtcGxlc05lZWRlZCA9IGNhdGVnb3JpemVkRXhhbXBsZXMuZXhhbXBsZXNOZWVkZWQ7XG4gIGNvbnN0IHN1Y2Nlc3NmdWxFeGFtcGxlcyA9IGNhdGVnb3JpemVkRXhhbXBsZXMuc3VjY2Vzc2Z1bEV4YW1wbGVzO1xuXG4gIGNvbnN0IGFucyA9IHt9O1xuXG4gIC8vIEl0J3MgYWx3YXlzIGVpdGhlciBvbmUgb3IgdGhlIG90aGVyLlxuICAvLyBUT0RPOiBpbnN0ZWFkIG9mICcgJywgY2FsbCAnc3BhY2VzLmdlbmVyYXRlRXhhbXBsZSgpJ1xuICBhbnMudmFsdWUgPSBzdWNjZXNzZnVsRXhhbXBsZXMuam9pbihpblN5bnRhY3RpY0NvbnRleHQgPyAnICcgOiAnJyk7XG4gIGlmIChleGFtcGxlc05lZWRlZC5sZW5ndGggPiAwKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gZXhhbXBsZXNOZWVkZWQ7XG4gIH1cblxuICByZXR1cm4gYW5zO1xufTtcblxuLy8gUmlnaHQgbm93LCAnTm90JyBhbmQgJ0xvb2thaGVhZCcgZ2VuZXJhdGUgbm90aGluZyBhbmQgYXNzdW1lIHRoYXQgd2hhdGV2ZXIgZm9sbG93cyB3aWxsXG4vLyAgIHdvcmsgYWNjb3JkaW5nIHRvIHRoZSBlbmNvZGVkIGNvbnN0cmFpbnRzLlxucGV4cHJzLk5vdC5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCkge1xuICByZXR1cm4ge3ZhbHVlOiAnJ307XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0KSB7XG4gIHJldHVybiB7dmFsdWU6ICcnfTtcbn07XG5cbnBleHBycy5MZXgucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgcmV0dXJuIHRoaXMuZXhwci5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGZhbHNlLCBhY3R1YWxzKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICBjb25zdCBhbnMgPSB7fTtcblxuICBjb25zdCBydWxlTmFtZSA9IHRoaXMuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKS50b1N0cmluZygpO1xuXG4gIGlmICghZXhhbXBsZXMuaGFzT3duUHJvcGVydHkocnVsZU5hbWUpKSB7XG4gICAgYW5zLmV4YW1wbGVzTmVlZGVkID0gW3J1bGVOYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWxldmFudEV4YW1wbGVzID0gZXhhbXBsZXNbcnVsZU5hbWVdO1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZWxldmFudEV4YW1wbGVzLmxlbmd0aCk7XG4gICAgYW5zLnZhbHVlID0gcmVsZXZhbnRFeGFtcGxlc1tpXTtcbiAgfVxuXG4gIHJldHVybiBhbnM7XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKFxuICAgIGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgbGV0IGNoYXI7XG4gIHN3aXRjaCAodGhpcy5jYXRlZ29yeSkge1xuICAgIGNhc2UgJ0x1JzogY2hhciA9ICfDgSc7IGJyZWFrO1xuICAgIGNhc2UgJ0xsJzogY2hhciA9ICfFjyc7IGJyZWFrO1xuICAgIGNhc2UgJ0x0JzogY2hhciA9ICfHhSc7IGJyZWFrO1xuICAgIGNhc2UgJ0xtJzogY2hhciA9ICfLric7IGJyZWFrO1xuICAgIGNhc2UgJ0xvJzogY2hhciA9ICfGuyc7IGJyZWFrO1xuXG4gICAgY2FzZSAnTmwnOiBjaGFyID0gJ+KGgic7IGJyZWFrO1xuICAgIGNhc2UgJ05kJzogY2hhciA9ICfCvSc7IGJyZWFrO1xuXG4gICAgY2FzZSAnTW4nOiBjaGFyID0gJ1xcdTA0ODcnOyBicmVhaztcbiAgICBjYXNlICdNYyc6IGNoYXIgPSAn4KS/JzsgYnJlYWs7XG5cbiAgICBjYXNlICdQYyc6IGNoYXIgPSAn4oGAJzsgYnJlYWs7XG5cbiAgICBjYXNlICdacyc6IGNoYXIgPSAnXFx1MjAwMSc7IGJyZWFrO1xuXG4gICAgY2FzZSAnTCc6IGNoYXIgPSAnw4EnOyBicmVhaztcbiAgICBjYXNlICdMdG1vJzogY2hhciA9ICfHhSc7IGJyZWFrO1xuICB9XG4gIHJldHVybiB7dmFsdWU6IGNoYXJ9OyAvLyDwn5KpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmdldEFyaXR5ID0gY29tbW9uLmFic3RyYWN0KCdnZXRBcml0eScpO1xuXG5wZXhwcnMuYW55LmdldEFyaXR5ID1cbnBleHBycy5lbmQuZ2V0QXJpdHkgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5nZXRBcml0eSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmdldEFyaXR5ID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuZ2V0QXJpdHkgPVxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5nZXRBcml0eSA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgLy8gVGhpcyBpcyBvayBiL2MgYWxsIHRlcm1zIG11c3QgaGF2ZSB0aGUgc2FtZSBhcml0eSAtLSB0aGlzIHByb3BlcnR5IGlzXG4gIC8vIGNoZWNrZWQgYnkgdGhlIEdyYW1tYXIgY29uc3RydWN0b3IuXG4gIHJldHVybiB0aGlzLnRlcm1zLmxlbmd0aCA9PT0gMCA/IDAgOiB0aGlzLnRlcm1zWzBdLmdldEFyaXR5KCk7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5nZXRBcml0eSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgYXJpdHkgPSAwO1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpZHgrKykge1xuICAgIGFyaXR5ICs9IHRoaXMuZmFjdG9yc1tpZHhdLmdldEFyaXR5KCk7XG4gIH1cbiAgcmV0dXJuIGFyaXR5O1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmV4cHIuZ2V0QXJpdHkoKTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuZ2V0QXJpdHkgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZXhwci5nZXRBcml0eSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgQ2FsbGVkIGF0IGdyYW1tYXIgY3JlYXRpb24gdGltZSB0byByZXdyaXRlIGEgcnVsZSBib2R5LCByZXBsYWNpbmcgZWFjaCByZWZlcmVuY2UgdG8gYSBmb3JtYWxcbiAgcGFyYW1ldGVyIHdpdGggYSBgUGFyYW1gIG5vZGUuIFJldHVybnMgYSBQRXhwciAtLSBlaXRoZXIgYSBuZXcgb25lLCBvciB0aGUgb3JpZ2luYWwgb25lIGlmXG4gIGl0IHdhcyBtb2RpZmllZCBpbiBwbGFjZS5cbiovXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGNvbW1vbi5hYnN0cmFjdCgnaW50cm9kdWNlUGFyYW1zJyk7XG5cbnBleHBycy5hbnkuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5lbmQuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID0gZnVuY3Rpb24oZm9ybWFscykge1xuICByZXR1cm4gdGhpcztcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGZ1bmN0aW9uKGZvcm1hbHMpIHtcbiAgdGhpcy50ZXJtcy5mb3JFYWNoKCh0ZXJtLCBpZHgsIHRlcm1zKSA9PiB7XG4gICAgdGVybXNbaWR4XSA9IHRlcm0uaW50cm9kdWNlUGFyYW1zKGZvcm1hbHMpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIHRoaXMuZmFjdG9ycy5mb3JFYWNoKChmYWN0b3IsIGlkeCwgZmFjdG9ycykgPT4ge1xuICAgIGZhY3RvcnNbaWR4XSA9IGZhY3Rvci5pbnRyb2R1Y2VQYXJhbXMoZm9ybWFscyk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIHRoaXMuZXhwciA9IHRoaXMuZXhwci5pbnRyb2R1Y2VQYXJhbXMoZm9ybWFscyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIGNvbnN0IGluZGV4ID0gZm9ybWFscy5pbmRleE9mKHRoaXMucnVsZU5hbWUpO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIGlmICh0aGlzLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYmUgc3VwcG9ydGVkPyBTZWUgaXNzdWUgIzY0LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJpemVkIHJ1bGVzIGNhbm5vdCBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIGFub3RoZXIgcnVsZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuUGFyYW0oaW5kZXgpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXJncy5mb3JFYWNoKChhcmcsIGlkeCwgYXJncykgPT4ge1xuICAgICAgYXJnc1tpZHhdID0gYXJnLmludHJvZHVjZVBhcmFtcyhmb3JtYWxzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBwYXJzaW5nIGV4cHJlc3Npb24gbWF5IGFjY2VwdCB3aXRob3V0IGNvbnN1bWluZyBhbnkgaW5wdXQuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmlzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiB0aGlzLl9pc051bGxhYmxlKGdyYW1tYXIsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufTtcblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGNvbW1vbi5hYnN0cmFjdCgnX2lzTnVsbGFibGUnKTtcblxucGV4cHJzLmFueS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLlBsdXMucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnBleHBycy5lbmQuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzLm9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUaGlzIGlzIGFuIG92ZXItc2ltcGxpZmljYXRpb246IGl0J3Mgb25seSBjb3JyZWN0IGlmIHRoZSBpbnB1dCBpcyBhIHN0cmluZy4gSWYgaXQncyBhbiBhcnJheVxuICAgIC8vIG9yIGFuIG9iamVjdCwgdGhlbiB0aGUgZW1wdHkgc3RyaW5nIHBhcnNpbmcgZXhwcmVzc2lvbiBpcyBub3QgbnVsbGFibGUuXG4gICAgcmV0dXJuIHRoaXMub2JqID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICByZXR1cm4gdGhpcy50ZXJtcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIHRoaXMudGVybXMuc29tZSh0ZXJtID0+IHRlcm0uX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbykpO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0aGlzLmZhY3RvcnMuZXZlcnkoZmFjdG9yID0+IGZhY3Rvci5faXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKSk7XG59O1xuXG5wZXhwcnMuU3Rhci5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLk9wdC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0aGlzLmV4cHIuX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbyk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICBjb25zdCBrZXkgPSB0aGlzLnRvTWVtb0tleSgpO1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZW1vLCBrZXkpKSB7XG4gICAgY29uc3QgYm9keSA9IGdyYW1tYXIucnVsZXNbdGhpcy5ydWxlTmFtZV0uYm9keTtcbiAgICBjb25zdCBpbmxpbmVkID0gYm9keS5zdWJzdGl0dXRlUGFyYW1zKHRoaXMuYXJncyk7XG4gICAgbWVtb1trZXldID0gZmFsc2U7IC8vIFByZXZlbnQgaW5maW5pdGUgcmVjdXJzaW9uIGZvciByZWN1cnNpdmUgcnVsZXMuXG4gICAgbWVtb1trZXldID0gaW5saW5lZC5faXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKTtcbiAgfVxuICByZXR1cm4gbWVtb1trZXldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZ2V0TWV0YUluZm8oZXhwciwgZ3JhbW1hckludGVydmFsKSB7XG4gIGNvbnN0IG1ldGFJbmZvID0ge307XG4gIGlmIChleHByLnNvdXJjZSAmJiBncmFtbWFySW50ZXJ2YWwpIHtcbiAgICBjb25zdCBhZGp1c3RlZCA9IGV4cHIuc291cmNlLnJlbGF0aXZlVG8oZ3JhbW1hckludGVydmFsKTtcbiAgICBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbCA9IFthZGp1c3RlZC5zdGFydElkeCwgYWRqdXN0ZWQuZW5kSWR4XTtcbiAgfVxuICByZXR1cm4gbWV0YUluZm87XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGNvbW1vbi5hYnN0cmFjdCgnb3V0cHV0UmVjaXBlJyk7XG5cbnBleHBycy5hbnkub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbJ2FueScsIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCldO1xufTtcblxucGV4cHJzLmVuZC5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFsnZW5kJywgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKV07XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICd0ZXJtaW5hbCcsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLm9ialxuICBdO1xufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAncmFuZ2UnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgdGhpcy5mcm9tLFxuICAgIHRoaXMudG9cbiAgXTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ3BhcmFtJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMuaW5kZXhcbiAgXTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICdhbHQnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbClcbiAgXS5jb25jYXQodGhpcy50ZXJtcy5tYXAodGVybSA9PiB0ZXJtLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpKSk7XG59O1xuXG5wZXhwcnMuRXh0ZW5kLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy50ZXJtc1swXTsgLy8gW2V4dGVuc2lvbiwgb3JpZ2luYWxdXG4gIHJldHVybiBleHRlbnNpb24ub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCk7XG59O1xuXG5wZXhwcnMuU3BsaWNlLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgY29uc3QgYmVmb3JlVGVybXMgPSB0aGlzLnRlcm1zLnNsaWNlKDAsIHRoaXMuZXhwYW5zaW9uUG9zKTtcbiAgY29uc3QgYWZ0ZXJUZXJtcyA9IHRoaXMudGVybXMuc2xpY2UodGhpcy5leHBhbnNpb25Qb3MgKyAxKTtcbiAgcmV0dXJuIFtcbiAgICAnc3BsaWNlJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIGJlZm9yZVRlcm1zLm1hcCh0ZXJtID0+IHRlcm0ub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkpLFxuICAgIGFmdGVyVGVybXMubWFwKHRlcm0gPT4gdGVybS5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKSlcbiAgXTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICdzZXEnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbClcbiAgXS5jb25jYXQodGhpcy5mYWN0b3JzLm1hcChmYWN0b3IgPT4gZmFjdG9yLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpKSk7XG59O1xuXG5wZXhwcnMuU3Rhci5wcm90b3R5cGUub3V0cHV0UmVjaXBlID1cbnBleHBycy5QbHVzLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPVxucGV4cHJzLk9wdC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID1cbnBleHBycy5Ob3QucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPVxucGV4cHJzLkxleC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLmV4cHIub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbClcbiAgXTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ2FwcCcsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLnJ1bGVOYW1lLFxuICAgIHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKSlcbiAgXTtcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ3VuaWNvZGVDaGFyJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMuY2F0ZWdvcnlcbiAgXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIFJldHVybnMgYSBQRXhwciB0aGF0IHJlc3VsdHMgZnJvbSByZWN1cnNpdmVseSByZXBsYWNpbmcgZXZlcnkgZm9ybWFsIHBhcmFtZXRlciAoaS5lLiwgaW5zdGFuY2VcbiAgb2YgYFBhcmFtYCkgaW5zaWRlIHRoaXMgUEV4cHIgd2l0aCBpdHMgYWN0dWFsIHZhbHVlIGZyb20gYGFjdHVhbHNgIChhbiBBcnJheSkuXG5cbiAgVGhlIHJlY2VpdmVyIG11c3Qgbm90IGJlIG1vZGlmaWVkOyBhIG5ldyBQRXhwciBtdXN0IGJlIHJldHVybmVkIGlmIGFueSByZXBsYWNlbWVudCBpcyBuZWNlc3NhcnkuXG4qL1xuLy8gZnVuY3Rpb24oYWN0dWFscykgeyAuLi4gfVxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gY29tbW9uLmFic3RyYWN0KCdzdWJzdGl0dXRlUGFyYW1zJyk7XG5cbnBleHBycy5hbnkuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuZW5kLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICByZXR1cm4gYWN0dWFsc1t0aGlzLmluZGV4XTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiBuZXcgcGV4cHJzLkFsdChcbiAgICAgIHRoaXMudGVybXMubWFwKHRlcm0gPT4gdGVybS5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpKSk7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICByZXR1cm4gbmV3IHBleHBycy5TZXEoXG4gICAgICB0aGlzLmZhY3RvcnMubWFwKGZhY3RvciA9PiBmYWN0b3Iuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSkpO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5MZXgucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmV4cHIuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIGlmICh0aGlzLmFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQXZvaWQgbWFraW5nIGEgY29weSBvZiB0aGlzIGFwcGxpY2F0aW9uLCBhcyBhbiBvcHRpbWl6YXRpb25cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdzLm1hcChhcmcgPT4gYXJnLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykpO1xuICAgIHJldHVybiBuZXcgcGV4cHJzLkFwcGx5KHRoaXMucnVsZU5hbWUsIGFyZ3MpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbmNvbnN0IHtjb3B5V2l0aG91dER1cGxpY2F0ZXN9ID0gY29tbW9uO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaXNSZXN0cmljdGVkSlNJZGVudGlmaWVyKHN0cikge1xuICByZXR1cm4gL15bYS16QS1aXyRdWzAtOWEtekEtWl8kXSokLy50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEdXBsaWNhdGVkTmFtZXMoYXJndW1lbnROYW1lTGlzdCkge1xuICAvLyBgY291bnRgIGlzIHVzZWQgdG8gcmVjb3JkIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBhcmd1bWVudCBuYW1lIG9jY3VycyBpbiB0aGUgbGlzdCxcbiAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIGNoZWNraW5nIGR1cGxpY2F0ZWQgYXJndW1lbnQgbmFtZS4gSXQgbWFwcyBhcmd1bWVudCBuYW1lcyB0byBpbnRzLlxuICBjb25zdCBjb3VudCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGFyZ3VtZW50TmFtZUxpc3QuZm9yRWFjaChhcmdOYW1lID0+IHtcbiAgICBjb3VudFthcmdOYW1lXSA9IChjb3VudFthcmdOYW1lXSB8fCAwKSArIDE7XG4gIH0pO1xuXG4gIC8vIEFwcGVuZCBzdWJzY3JpcHRzICgnXzEnLCAnXzInLCAuLi4pIHRvIGR1cGxpY2F0ZSBhcmd1bWVudCBuYW1lcy5cbiAgT2JqZWN0LmtleXMoY291bnQpLmZvckVhY2goZHVwQXJnTmFtZSA9PiB7XG4gICAgaWYgKGNvdW50W2R1cEFyZ05hbWVdIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIG5hbWUgc2hvd3MgdXAgbW9yZSB0aGFuIG9uY2UsIHNvIGFkZCBzdWJzY3JpcHRzLlxuICAgIGxldCBzdWJzY3JpcHQgPSAxO1xuICAgIGFyZ3VtZW50TmFtZUxpc3QuZm9yRWFjaCgoYXJnTmFtZSwgaWR4KSA9PiB7XG4gICAgICBpZiAoYXJnTmFtZSA9PT0gZHVwQXJnTmFtZSkge1xuICAgICAgICBhcmd1bWVudE5hbWVMaXN0W2lkeF0gPSBhcmdOYW1lICsgJ18nICsgc3Vic2NyaXB0Kys7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgUmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgZGVmYXVsdCBhcmd1bWVudCBuYW1lcyBmb3IgaXRzIHJlY2VpdmVyXG4gIChhIHBleHByKSBpbiBhIHNlbWFudGljIGFjdGlvbi4gVGhpcyBpcyB1c2VkIGV4Y2x1c2l2ZWx5IGJ5IHRoZSBTZW1hbnRpY3MgRWRpdG9yLlxuXG4gIGBmaXJzdEFyZ0luZGV4YCBpcyB0aGUgMS1iYXNlZCBpbmRleCBvZiB0aGUgZmlyc3QgYXJndW1lbnQgbmFtZSB0aGF0IHdpbGwgYmUgZ2VuZXJhdGVkIGZvciB0aGlzXG4gIHBleHByLiBJdCBlbmFibGVzIHVzIHRvIG5hbWUgYXJndW1lbnRzIHBvc2l0aW9uYWxseSwgZS5nLiwgaWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhXG4gIG5vbi1hbHBoYW51bWVyaWMgdGVybWluYWwgbGlrZSBcIitcIiwgaXQgd2lsbCBiZSBuYW1lZCAnJDInLlxuXG4gIGBub0R1cENoZWNrYCBpcyB0cnVlIGlmIHRoZSBjYWxsZXIgb2YgYHRvQXJndW1lbnROYW1lTGlzdGAgaXMgbm90IGEgdG9wIGxldmVsIGNhbGxlci4gSXQgZW5hYmxlc1xuICB1cyB0byBhdm9pZCBuZXN0ZWQgZHVwbGljYXRpb24gc3Vic2NyaXB0cyBhcHBlbmRpbmcsIGUuZy4sICdfMV8xJywgJ18xXzInLCBieSBvbmx5IGNoZWNraW5nXG4gIGR1cGxpY2F0ZXMgYXQgdGhlIHRvcCBsZXZlbC5cblxuICBIZXJlIGlzIGEgbW9yZSBlbGFib3JhdGUgZXhhbXBsZSB0aGF0IGlsbHVzdHJhdGVzIGhvdyB0aGlzIG1ldGhvZCB3b3JrczpcbiAgYChhIFwiK1wiIGIpLnRvQXJndW1lbnROYW1lTGlzdCgxKWAgZXZhbHVhdGVzIHRvIGBbJ2EnLCAnJDInLCAnYiddYCB3aXRoIHRoZSBmb2xsb3dpbmcgcmVjdXJzaXZlXG4gIGNhbGxzOlxuXG4gICAgKGEpLnRvQXJndW1lbnROYW1lTGlzdCgxKSAtPiBbJ2EnXSxcbiAgICAoXCIrXCIpLnRvQXJndW1lbnROYW1lTGlzdCgyKSAtPiBbJyQyJ10sXG4gICAgKGIpLnRvQXJndW1lbnROYW1lTGlzdCgzKSAtPiBbJ2InXVxuXG4gIE5vdGVzOlxuICAqIFRoaXMgbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgb24gd2VsbC1mb3JtZWQgZXhwcmVzc2lvbnMsIGUuZy4sIHRoZSByZWNlaXZlciBtdXN0XG4gICAgbm90IGhhdmUgYW55IEFsdCBzdWItZXhwcmVzc2lvbnMgd2l0aCBpbmNvbnNpc3RlbnQgYXJpdGllcy5cbiAgKiBlLmdldEFyaXR5KCkgPT09IGUudG9Bcmd1bWVudE5hbWVMaXN0KDEpLmxlbmd0aFxuKi9cbi8vIGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHsgLi4uIH1cbnBleHBycy5QRXhwci5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gY29tbW9uLmFic3RyYWN0KCd0b0FyZ3VtZW50TmFtZUxpc3QnKTtcblxucGV4cHJzLmFueS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbJ2FueSddO1xufTtcblxucGV4cHJzLmVuZC50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbJ2VuZCddO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5vYmogPT09ICdzdHJpbmcnICYmIC9eW19hLXpBLVowLTldKyQvLnRlc3QodGhpcy5vYmopKSB7XG4gICAgLy8gSWYgdGhpcyB0ZXJtaW5hbCBpcyBhIHZhbGlkIHN1ZmZpeCBmb3IgYSBKUyBpZGVudGlmaWVyLCBqdXN0IHByZXBlbmQgaXQgd2l0aCAnXydcbiAgICByZXR1cm4gWydfJyArIHRoaXMub2JqXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIG5hbWUgaXQgcG9zaXRpb25hbGx5LlxuICAgIHJldHVybiBbJyQnICsgZmlyc3RBcmdJbmRleF07XG4gIH1cbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICBsZXQgYXJnTmFtZSA9IHRoaXMuZnJvbSArICdfdG9fJyArIHRoaXMudG87XG4gIC8vIElmIHRoZSBgYXJnTmFtZWAgaXMgbm90IHZhbGlkIHRoZW4gdHJ5IHRvIHByZXBlbmQgYSBgX2AuXG4gIGlmICghaXNSZXN0cmljdGVkSlNJZGVudGlmaWVyKGFyZ05hbWUpKSB7XG4gICAgYXJnTmFtZSA9ICdfJyArIGFyZ05hbWU7XG4gIH1cbiAgLy8gSWYgdGhlIGBhcmdOYW1lYCBzdGlsbCBub3QgdmFsaWQgYWZ0ZXIgcHJlcGVuZGluZyBhIGBfYCwgdGhlbiBuYW1lIGl0IHBvc2l0aW9uYWxseS5cbiAgaWYgKCFpc1Jlc3RyaWN0ZWRKU0lkZW50aWZpZXIoYXJnTmFtZSkpIHtcbiAgICBhcmdOYW1lID0gJyQnICsgZmlyc3RBcmdJbmRleDtcbiAgfVxuICByZXR1cm4gW2FyZ05hbWVdO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICAvLyBgdGVybUFyZ05hbWVMaXN0c2AgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIHdoZXJlIGVhY2ggcm93IGlzIHRoZVxuICAvLyBhcmd1bWVudCBuYW1lIGxpc3QgdGhhdCBjb3JyZXNwb25kcyB0byBhIHRlcm0gaW4gdGhpcyBhbHRlcm5hdGlvbi5cbiAgY29uc3QgdGVybUFyZ05hbWVMaXN0cyA9IHRoaXMudGVybXMubWFwKHRlcm0gPT4gdGVybS50b0FyZ3VtZW50TmFtZUxpc3QoZmlyc3RBcmdJbmRleCwgdHJ1ZSkpO1xuXG4gIGNvbnN0IGFyZ3VtZW50TmFtZUxpc3QgPSBbXTtcbiAgY29uc3QgbnVtQXJncyA9IHRlcm1BcmdOYW1lTGlzdHNbMF0ubGVuZ3RoO1xuICBmb3IgKGxldCBjb2xJZHggPSAwOyBjb2xJZHggPCBudW1BcmdzOyBjb2xJZHgrKykge1xuICAgIGNvbnN0IGNvbCA9IFtdO1xuICAgIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRoaXMudGVybXMubGVuZ3RoOyByb3dJZHgrKykge1xuICAgICAgY29sLnB1c2godGVybUFyZ05hbWVMaXN0c1tyb3dJZHhdW2NvbElkeF0pO1xuICAgIH1cbiAgICBjb25zdCB1bmlxdWVOYW1lcyA9IGNvcHlXaXRob3V0RHVwbGljYXRlcyhjb2wpO1xuICAgIGFyZ3VtZW50TmFtZUxpc3QucHVzaCh1bmlxdWVOYW1lcy5qb2luKCdfb3JfJykpO1xuICB9XG5cbiAgaWYgKCFub0R1cENoZWNrKSB7XG4gICAgcmVzb2x2ZUR1cGxpY2F0ZWROYW1lcyhhcmd1bWVudE5hbWVMaXN0KTtcbiAgfVxuICByZXR1cm4gYXJndW1lbnROYW1lTGlzdDtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgLy8gR2VuZXJhdGUgdGhlIGFyZ3VtZW50IG5hbWUgbGlzdCwgd2l0aG91dCB3b3JyeWluZyBhYm91dCBkdXBsaWNhdGVzLlxuICBsZXQgYXJndW1lbnROYW1lTGlzdCA9IFtdO1xuICB0aGlzLmZhY3RvcnMuZm9yRWFjaChmYWN0b3IgPT4ge1xuICAgIGNvbnN0IGZhY3RvckFyZ3VtZW50TmFtZUxpc3QgPSBmYWN0b3IudG9Bcmd1bWVudE5hbWVMaXN0KGZpcnN0QXJnSW5kZXgsIHRydWUpO1xuICAgIGFyZ3VtZW50TmFtZUxpc3QgPSBhcmd1bWVudE5hbWVMaXN0LmNvbmNhdChmYWN0b3JBcmd1bWVudE5hbWVMaXN0KTtcblxuICAgIC8vIFNoaWZ0IHRoZSBmaXJzdEFyZ0luZGV4IHRvIHRha2UgdGhpcyBmYWN0b3IncyBhcmd1bWVudCBuYW1lcyBpbnRvIGFjY291bnQuXG4gICAgZmlyc3RBcmdJbmRleCArPSBmYWN0b3JBcmd1bWVudE5hbWVMaXN0Lmxlbmd0aDtcbiAgfSk7XG4gIGlmICghbm9EdXBDaGVjaykge1xuICAgIHJlc29sdmVEdXBsaWNhdGVkTmFtZXMoYXJndW1lbnROYW1lTGlzdCk7XG4gIH1cbiAgcmV0dXJuIGFyZ3VtZW50TmFtZUxpc3Q7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICBjb25zdCBhcmd1bWVudE5hbWVMaXN0ID0gdGhpcy5leHByLnRvQXJndW1lbnROYW1lTGlzdChmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKVxuICAgICAgLm1hcChleHByQXJndW1lbnRTdHJpbmcgPT4gZXhwckFyZ3VtZW50U3RyaW5nW2V4cHJBcmd1bWVudFN0cmluZy5sZW5ndGggLSAxXSA9PT0gJ3MnID9cbiAgICAgICAgICBleHByQXJndW1lbnRTdHJpbmcgKyAnZXMnIDpcbiAgICAgICAgICBleHByQXJndW1lbnRTdHJpbmcgKyAncycpO1xuICBpZiAoIW5vRHVwQ2hlY2spIHtcbiAgICByZXNvbHZlRHVwbGljYXRlZE5hbWVzKGFyZ3VtZW50TmFtZUxpc3QpO1xuICB9XG4gIHJldHVybiBhcmd1bWVudE5hbWVMaXN0O1xufTtcblxucGV4cHJzLk9wdC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gdGhpcy5leHByLnRvQXJndW1lbnROYW1lTGlzdChmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKS5tYXAoYXJnTmFtZSA9PiB7XG4gICAgcmV0dXJuICdvcHQnICsgYXJnTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgYXJnTmFtZS5zbGljZSgxKTtcbiAgfSk7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbXTtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiB0aGlzLmV4cHIudG9Bcmd1bWVudE5hbWVMaXN0KGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbdGhpcy5ydWxlTmFtZV07XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIFsnJCcgKyBmaXJzdEFyZ0luZGV4XTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gWydwYXJhbScgKyB0aGlzLmluZGV4XTtcbn07XG5cbi8vIFwiVmFsdWUgcGV4cHJzXCIgKFZhbHVlLCBTdHIsIEFyciwgT2JqKSBhcmUgZ29pbmcgYXdheSBzb29uLCBzbyB3ZSBkb24ndCB3b3JyeSBhYm91dCB0aGVtIGhlcmUuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBQRXhwciwgZm9yIHVzZSBhcyBhIFVJIGxhYmVsLCBldGMuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGNvbW1vbi5hYnN0cmFjdCgndG9EaXNwbGF5U3RyaW5nJyk7XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuU2VxLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnRyaW1tZWQoKS5jb250ZW50cztcbiAgfVxuICByZXR1cm4gJ1snICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJ10nO1xufTtcblxucGV4cHJzLmFueS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLmVuZC50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLkl0ZXIucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5MZXgucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcHMgPSB0aGlzLmFyZ3MubWFwKGFyZyA9PiBhcmcudG9EaXNwbGF5U3RyaW5nKCkpO1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lICsgJzwnICsgcHMuam9pbignLCcpICsgJz4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICB9XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ1VuaWNvZGUgWycgKyB0aGlzLmNhdGVnb3J5ICsgJ10gY2hhcmFjdGVyJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBGYWlsdXJlID0gcmVxdWlyZSgnLi9GYWlsdXJlJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUudG9GYWlsdXJlID0gY29tbW9uLmFic3RyYWN0KCd0b0ZhaWx1cmUnKTtcblxucGV4cHJzLmFueS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCAnYW55IG9iamVjdCcsICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLmVuZC50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCAnZW5kIG9mIGlucHV0JywgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIHRoaXMub2JqLCAnc3RyaW5nJyk7XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgLy8gVE9ETzogY29tZSB1cCB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIEpTT04uc3RyaW5naWZ5KHRoaXMuZnJvbSkgKyAnLi4nICsgSlNPTi5zdHJpbmdpZnkodGhpcy50byksICdjb2RlJyk7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5leHByID09PSBwZXhwcnMuYW55ID9cbiAgICAgICdub3RoaW5nJyA6XG4gICAgICAnbm90ICcgKyB0aGlzLmV4cHIudG9GYWlsdXJlKGdyYW1tYXIpO1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgZGVzY3JpcHRpb24sICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gdGhpcy5leHByLnRvRmFpbHVyZShncmFtbWFyKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBsZXQgZGVzY3JpcHRpb24gPSBncmFtbWFyLnJ1bGVzW3RoaXMucnVsZU5hbWVdLmRlc2NyaXB0aW9uO1xuICBpZiAoIWRlc2NyaXB0aW9uKSB7XG4gICAgY29uc3QgYXJ0aWNsZSA9ICgvXlthZWlvdUFFSU9VXS8udGVzdCh0aGlzLnJ1bGVOYW1lKSA/ICdhbicgOiAnYScpO1xuICAgIGRlc2NyaXB0aW9uID0gYXJ0aWNsZSArICcgJyArIHRoaXMucnVsZU5hbWU7XG4gIH1cbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIGRlc2NyaXB0aW9uLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgJ2EgVW5pY29kZSBbJyArIHRoaXMuY2F0ZWdvcnkgKyAnXSBjaGFyYWN0ZXInLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgY29uc3QgZnMgPSB0aGlzLnRlcm1zLm1hcCh0ID0+IHQudG9GYWlsdXJlKGdyYW1tYXIpKTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSAnKCcgKyBmcy5qb2luKCcgb3IgJykgKyAnKSc7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBkZXNjcmlwdGlvbiwgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGNvbnN0IGZzID0gdGhpcy5mYWN0b3JzLm1hcChmID0+IGYudG9GYWlsdXJlKGdyYW1tYXIpKTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSAnKCcgKyBmcy5qb2luKCcgJykgKyAnKSc7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBkZXNjcmlwdGlvbiwgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9ICcoJyArIHRoaXMuZXhwci50b0ZhaWx1cmUoZ3JhbW1hcikgKyB0aGlzLm9wZXJhdG9yICsgJyknO1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgZGVzY3JpcHRpb24sICdkZXNjcmlwdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgZTEudG9TdHJpbmcoKSA9PT0gZTIudG9TdHJpbmcoKSA9PT4gZTEgYW5kIGUyIGFyZSBzZW1hbnRpY2FsbHkgZXF1aXZhbGVudC5cbiAgTm90ZSB0aGF0IHRoaXMgaXMgbm90IGFuIGlmZiAoPD09Pik6IGUuZy4sXG4gICh+XCJiXCIgXCJhXCIpLnRvU3RyaW5nKCkgIT09IChcImFcIikudG9TdHJpbmcoKSwgZXZlbiB0aG91Z2hcbiAgflwiYlwiIFwiYVwiIGFuZCBcImFcIiBhcmUgaW50ZXJjaGFuZ2VhYmxlIGluIGFueSBncmFtbWFyLFxuICBib3RoIGluIHRlcm1zIG9mIHRoZSBsYW5ndWFnZXMgdGhleSBhY2NlcHQgYW5kIHRoZWlyIGFyaXRpZXMuXG4qL1xucGV4cHJzLlBFeHByLnByb3RvdHlwZS50b1N0cmluZyA9IGNvbW1vbi5hYnN0cmFjdCgndG9TdHJpbmcnKTtcblxucGV4cHJzLmFueS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ2FueSc7XG59O1xuXG5wZXhwcnMuZW5kLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnZW5kJztcbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMub2JqKTtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZnJvbSkgKyAnLi4nICsgSlNPTi5zdHJpbmdpZnkodGhpcy50byk7XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJCcgKyB0aGlzLmluZGV4O1xufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcjKCcgKyB0aGlzLmV4cHIudG9TdHJpbmcoKSArICcpJztcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRlcm1zLmxlbmd0aCA9PT0gMSA/XG4gICAgdGhpcy50ZXJtc1swXS50b1N0cmluZygpIDpcbiAgICAnKCcgKyB0aGlzLnRlcm1zLm1hcCh0ZXJtID0+IHRlcm0udG9TdHJpbmcoKSkuam9pbignIHwgJykgKyAnKSc7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5mYWN0b3JzLmxlbmd0aCA9PT0gMSA/XG4gICAgdGhpcy5mYWN0b3JzWzBdLnRvU3RyaW5nKCkgOlxuICAgICcoJyArIHRoaXMuZmFjdG9ycy5tYXAoZmFjdG9yID0+IGZhY3Rvci50b1N0cmluZygpKS5qb2luKCcgJykgKyAnKSc7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZXhwciArIHRoaXMub3BlcmF0b3I7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ34nICsgdGhpcy5leHByO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcmJyArIHRoaXMuZXhwcjtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcHMgPSB0aGlzLmFyZ3MubWFwKGFyZyA9PiBhcmcudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWUgKyAnPCcgKyBwcy5qb2luKCcsJykgKyAnPic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWU7XG4gIH1cbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdcXFxccHsnICsgdGhpcy5jYXRlZ29yeSArICd9Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBVbmljb2RlQ2F0ZWdvcmllcyA9IHJlcXVpcmUoJy4uL3RoaXJkX3BhcnR5L1VuaWNvZGVDYXRlZ29yaWVzJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gR2VuZXJhbCBzdHVmZlxuXG5jbGFzcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBQRXhwcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEV4cHIgY2Fubm90IGJlIGluc3RhbnRpYXRlZCAtLSBpdCdzIGFic3RyYWN0XCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gdGhlIGludGVydmFsIGNvbnRhaW5pbmcgdGhlIHNvdXJjZSBmb3IgdGhpcyBleHByZXNzaW9uLlxuICB3aXRoU291cmNlKGludGVydmFsKSB7XG4gICAgaWYgKGludGVydmFsKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IGludGVydmFsLnRyaW1tZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLy8gQW55XG5cbmNvbnN0IGFueSA9IE9iamVjdC5jcmVhdGUoUEV4cHIucHJvdG90eXBlKTtcblxuLy8gRW5kXG5cbmNvbnN0IGVuZCA9IE9iamVjdC5jcmVhdGUoUEV4cHIucHJvdG90eXBlKTtcblxuLy8gVGVybWluYWxzXG5cbmNsYXNzIFRlcm1pbmFsIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JqID0gb2JqO1xuICB9XG59XG5cbi8vIFJhbmdlc1xuXG5jbGFzcyBSYW5nZSBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy50byA9IHRvO1xuICB9XG59XG5cbi8vIFBhcmFtZXRlcnNcblxuY2xhc3MgUGFyYW0gZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGluZGV4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cblxuLy8gQWx0ZXJuYXRpb25cblxuY2xhc3MgQWx0IGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3Rvcih0ZXJtcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZXJtcyA9IHRlcm1zO1xuICB9XG59XG5cbi8vIEV4dGVuZCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgcnVsZSBleHRlbnNpb25cblxuY2xhc3MgRXh0ZW5kIGV4dGVuZHMgQWx0IHtcbiAgY29uc3RydWN0b3Ioc3VwZXJHcmFtbWFyLCBuYW1lLCBib2R5KSB7XG4gICAgY29uc3Qgb3JpZ0JvZHkgPSBzdXBlckdyYW1tYXIucnVsZXNbbmFtZV0uYm9keTtcbiAgICBzdXBlcihbYm9keSwgb3JpZ0JvZHldKTtcblxuICAgIHRoaXMuc3VwZXJHcmFtbWFyID0gc3VwZXJHcmFtbWFyO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgfVxufVxuXG4vLyBTcGxpY2UgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIHJ1bGUgb3ZlcnJpZGluZyB3aXRoIHRoZSBgLi4uYCBvcGVyYXRvci5cbmNsYXNzIFNwbGljZSBleHRlbmRzIEFsdCB7XG4gIGNvbnN0cnVjdG9yKHN1cGVyR3JhbW1hciwgcnVsZU5hbWUsIGJlZm9yZVRlcm1zLCBhZnRlclRlcm1zKSB7XG4gICAgY29uc3Qgb3JpZ0JvZHkgPSBzdXBlckdyYW1tYXIucnVsZXNbcnVsZU5hbWVdLmJvZHk7XG4gICAgc3VwZXIoWy4uLmJlZm9yZVRlcm1zLCBvcmlnQm9keSwgLi4uYWZ0ZXJUZXJtc10pO1xuXG4gICAgdGhpcy5zdXBlckdyYW1tYXIgPSBzdXBlckdyYW1tYXI7XG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICAgIHRoaXMuZXhwYW5zaW9uUG9zID0gYmVmb3JlVGVybXMubGVuZ3RoO1xuICB9XG59XG5cbi8vIFNlcXVlbmNlc1xuXG5jbGFzcyBTZXEgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZmFjdG9ycyA9IGZhY3RvcnM7XG4gIH1cbn1cblxuLy8gSXRlcmF0b3JzIGFuZCBvcHRpb25hbHNcblxuY2xhc3MgSXRlciBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZXhwcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgfVxufVxuXG5jbGFzcyBTdGFyIGV4dGVuZHMgSXRlciB7fVxuY2xhc3MgUGx1cyBleHRlbmRzIEl0ZXIge31cbmNsYXNzIE9wdCBleHRlbmRzIEl0ZXIge31cblxuU3Rhci5wcm90b3R5cGUub3BlcmF0b3IgPSAnKic7XG5QbHVzLnByb3RvdHlwZS5vcGVyYXRvciA9ICcrJztcbk9wdC5wcm90b3R5cGUub3BlcmF0b3IgPSAnPyc7XG5cblN0YXIucHJvdG90eXBlLm1pbk51bU1hdGNoZXMgPSAwO1xuUGx1cy5wcm90b3R5cGUubWluTnVtTWF0Y2hlcyA9IDE7XG5PcHQucHJvdG90eXBlLm1pbk51bU1hdGNoZXMgPSAwO1xuXG5TdGFyLnByb3RvdHlwZS5tYXhOdW1NYXRjaGVzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuUGx1cy5wcm90b3R5cGUubWF4TnVtTWF0Y2hlcyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbk9wdC5wcm90b3R5cGUubWF4TnVtTWF0Y2hlcyA9IDE7XG5cbi8vIFByZWRpY2F0ZXNcblxuY2xhc3MgTm90IGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihleHByKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICB9XG59XG5cbmNsYXNzIExvb2thaGVhZCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZXhwcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgfVxufVxuXG4vLyBcIkxleGlmaWNhdGlvblwiXG5cbmNsYXNzIExleCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZXhwcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgfVxufVxuXG4vLyBSdWxlIGFwcGxpY2F0aW9uXG5cbmNsYXNzIEFwcGx5IGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihydWxlTmFtZSwgYXJncz1bXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICBpc1N5bnRhY3RpYygpIHtcbiAgICByZXR1cm4gY29tbW9uLmlzU3ludGFjdGljKHRoaXMucnVsZU5hbWUpO1xuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QganVzdCBjYWNoZXMgdGhlIHJlc3VsdCBvZiBgdGhpcy50b1N0cmluZygpYCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICB0b01lbW9LZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9tZW1vS2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19tZW1vS2V5Jywge3ZhbHVlOiB0aGlzLnRvU3RyaW5nKCl9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21lbW9LZXk7XG4gIH1cbn1cblxuLy8gVW5pY29kZSBjaGFyYWN0ZXJcblxuY2xhc3MgVW5pY29kZUNoYXIgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGNhdGVnb3J5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgdGhpcy5wYXR0ZXJuID0gVW5pY29kZUNhdGVnb3JpZXNbY2F0ZWdvcnldO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLlBFeHByID0gUEV4cHI7XG5leHBvcnRzLmFueSA9IGFueTtcbmV4cG9ydHMuZW5kID0gZW5kO1xuZXhwb3J0cy5UZXJtaW5hbCA9IFRlcm1pbmFsO1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZXhwb3J0cy5QYXJhbSA9IFBhcmFtO1xuZXhwb3J0cy5BbHQgPSBBbHQ7XG5leHBvcnRzLkV4dGVuZCA9IEV4dGVuZDtcbmV4cG9ydHMuU3BsaWNlID0gU3BsaWNlO1xuZXhwb3J0cy5TZXEgPSBTZXE7XG5leHBvcnRzLkl0ZXIgPSBJdGVyO1xuZXhwb3J0cy5TdGFyID0gU3RhcjtcbmV4cG9ydHMuUGx1cyA9IFBsdXM7XG5leHBvcnRzLk9wdCA9IE9wdDtcbmV4cG9ydHMuTm90ID0gTm90O1xuZXhwb3J0cy5Mb29rYWhlYWQgPSBMb29rYWhlYWQ7XG5leHBvcnRzLkxleCA9IExleDtcbmV4cG9ydHMuQXBwbHkgPSBBcHBseTtcbmV4cG9ydHMuVW5pY29kZUNoYXIgPSBVbmljb2RlQ2hhcjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuc2lvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnJlcXVpcmUoJy4vcGV4cHJzLWFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWFzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkJyk7XG5yZXF1aXJlKCcuL3BleHBycy1hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eScpO1xucmVxdWlyZSgnLi9wZXhwcnMtYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlJyk7XG5yZXF1aXJlKCcuL3BleHBycy1jaGVjaycpO1xucmVxdWlyZSgnLi9wZXhwcnMtZXZhbCcpO1xucmVxdWlyZSgnLi9wZXhwcnMtZ2V0QXJpdHknKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWdlbmVyYXRlRXhhbXBsZScpO1xucmVxdWlyZSgnLi9wZXhwcnMtb3V0cHV0UmVjaXBlJyk7XG5yZXF1aXJlKCcuL3BleHBycy1pbnRyb2R1Y2VQYXJhbXMnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWlzTnVsbGFibGUnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXN1YnN0aXR1dGVQYXJhbXMnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXRvRGlzcGxheVN0cmluZycpO1xucmVxdWlyZSgnLi9wZXhwcnMtdG9Bcmd1bWVudE5hbWVMaXN0Jyk7XG5yZXF1aXJlKCcuL3BleHBycy10b0ZhaWx1cmUnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXRvU3RyaW5nJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycyBgYXJyYCwgcmV0dXJuIGFuIGFycmF5IG9mIHRoZSBudW1iZXJzIGFzIHN0cmluZ3MsXG4vLyByaWdodC1qdXN0aWZpZWQgYW5kIHBhZGRlZCB0byB0aGUgc2FtZSBsZW5ndGguXG5mdW5jdGlvbiBwYWROdW1iZXJzVG9FcXVhbExlbmd0aChhcnIpIHtcbiAgbGV0IG1heExlbiA9IDA7XG4gIGNvbnN0IHN0cmluZ3MgPSBhcnIubWFwKG4gPT4ge1xuICAgIGNvbnN0IHN0ciA9IG4udG9TdHJpbmcoKTtcbiAgICBtYXhMZW4gPSBNYXRoLm1heChtYXhMZW4sIHN0ci5sZW5ndGgpO1xuICAgIHJldHVybiBzdHI7XG4gIH0pO1xuICByZXR1cm4gc3RyaW5ncy5tYXAocyA9PiBjb21tb24ucGFkTGVmdChzLCBtYXhMZW4pKTtcbn1cblxuLy8gUHJvZHVjZSBhIG5ldyBzdHJpbmcgdGhhdCB3b3VsZCBiZSB0aGUgcmVzdWx0IG9mIGNvcHlpbmcgdGhlIGNvbnRlbnRzXG4vLyBvZiB0aGUgc3RyaW5nIGBzcmNgIG9udG8gYGRlc3RgIGF0IG9mZnNldCBgb2ZmZXN0YC5cbmZ1bmN0aW9uIHN0cmNweShkZXN0LCBzcmMsIG9mZnNldCkge1xuICBjb25zdCBvcmlnRGVzdExlbiA9IGRlc3QubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IGRlc3Quc2xpY2UoMCwgb2Zmc2V0KTtcbiAgY29uc3QgZW5kID0gZGVzdC5zbGljZShvZmZzZXQgKyBzcmMubGVuZ3RoKTtcbiAgcmV0dXJuIChzdGFydCArIHNyYyArIGVuZCkuc3Vic3RyKDAsIG9yaWdEZXN0TGVuKTtcbn1cblxuLy8gQ2FzdHMgdGhlIHVuZGVybHlpbmcgbGluZUFuZENvbCBvYmplY3QgdG8gYSBmb3JtYXR0ZWQgbWVzc2FnZSBzdHJpbmcsXG4vLyBoaWdobGlnaHRpbmcgYHJhbmdlc2AuXG5mdW5jdGlvbiBsaW5lQW5kQ29sdW1uVG9NZXNzYWdlKC4uLnJhbmdlcykge1xuICBjb25zdCBsaW5lQW5kQ29sID0gdGhpcztcbiAgY29uc3Qgb2Zmc2V0ID0gbGluZUFuZENvbC5vZmZzZXQ7XG4gIGNvbnN0IHJlcGVhdFN0ciA9IGNvbW1vbi5yZXBlYXRTdHI7XG5cbiAgY29uc3Qgc2IgPSBuZXcgY29tbW9uLlN0cmluZ0J1ZmZlcigpO1xuICBzYi5hcHBlbmQoJ0xpbmUgJyArIGxpbmVBbmRDb2wubGluZU51bSArICcsIGNvbCAnICsgbGluZUFuZENvbC5jb2xOdW0gKyAnOlxcbicpO1xuXG4gIC8vIEFuIGFycmF5IG9mIHRoZSBwcmV2aW91cywgY3VycmVudCwgYW5kIG5leHQgbGluZSBudW1iZXJzIGFzIHN0cmluZ3Mgb2YgZXF1YWwgbGVuZ3RoLlxuICBjb25zdCBsaW5lTnVtYmVycyA9IHBhZE51bWJlcnNUb0VxdWFsTGVuZ3RoKFtcbiAgICBsaW5lQW5kQ29sLnByZXZMaW5lID09IG51bGwgPyAwIDogbGluZUFuZENvbC5saW5lTnVtIC0gMSxcbiAgICBsaW5lQW5kQ29sLmxpbmVOdW0sXG4gICAgbGluZUFuZENvbC5uZXh0TGluZSA9PSBudWxsID8gMCA6IGxpbmVBbmRDb2wubGluZU51bSArIDFcbiAgXSk7XG5cbiAgLy8gSGVscGVyIGZvciBhcHBlbmRpbmcgZm9ybWF0dGluZyBpbnB1dCBsaW5lcyB0byB0aGUgYnVmZmVyLlxuICBjb25zdCBhcHBlbmRMaW5lID0gKG51bSwgY29udGVudCwgcHJlZml4KSA9PiB7XG4gICAgc2IuYXBwZW5kKHByZWZpeCArIGxpbmVOdW1iZXJzW251bV0gKyAnIHwgJyArIGNvbnRlbnQgKyAnXFxuJyk7XG4gIH07XG5cbiAgLy8gSW5jbHVkZSB0aGUgcHJldmlvdXMgbGluZSBmb3IgY29udGV4dCBpZiBwb3NzaWJsZS5cbiAgaWYgKGxpbmVBbmRDb2wucHJldkxpbmUgIT0gbnVsbCkge1xuICAgIGFwcGVuZExpbmUoMCwgbGluZUFuZENvbC5wcmV2TGluZSwgJyAgJyk7XG4gIH1cbiAgLy8gTGluZSB0aGF0IHRoZSBlcnJvciBvY2N1cnJlZCBvbi5cbiAgYXBwZW5kTGluZSgxLCBsaW5lQW5kQ29sLmxpbmUsICc+ICcpO1xuXG4gIC8vIEJ1aWxkIHVwIHRoZSBsaW5lIHRoYXQgcG9pbnRzIHRvIHRoZSBvZmZzZXQgYW5kIHBvc3NpYmxlIGluZGljYXRlcyBvbmUgb3IgbW9yZSByYW5nZXMuXG4gIC8vIFN0YXJ0IHdpdGggYSBibGFuayBsaW5lLCBhbmQgaW5kaWNhdGUgZWFjaCByYW5nZSBieSBvdmVybGF5aW5nIGEgc3RyaW5nIG9mIGB+YCBjaGFycy5cbiAgY29uc3QgbGluZUxlbiA9IGxpbmVBbmRDb2wubGluZS5sZW5ndGg7XG4gIGxldCBpbmRpY2F0aW9uTGluZSA9IHJlcGVhdFN0cignICcsIGxpbmVMZW4gKyAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgc3RhcnRJZHggPSByYW5nZXNbaV1bMF07XG4gICAgbGV0IGVuZElkeCA9IHJhbmdlc1tpXVsxXTtcbiAgICBjb21tb24uYXNzZXJ0KHN0YXJ0SWR4ID49IDAgJiYgc3RhcnRJZHggPD0gZW5kSWR4LCAncmFuZ2Ugc3RhcnQgbXVzdCBiZSA+PSAwIGFuZCA8PSBlbmQnKTtcblxuICAgIGNvbnN0IGxpbmVTdGFydE9mZnNldCA9IG9mZnNldCAtIGxpbmVBbmRDb2wuY29sTnVtICsgMTtcbiAgICBzdGFydElkeCA9IE1hdGgubWF4KDAsIHN0YXJ0SWR4IC0gbGluZVN0YXJ0T2Zmc2V0KTtcbiAgICBlbmRJZHggPSBNYXRoLm1pbihlbmRJZHggLSBsaW5lU3RhcnRPZmZzZXQsIGxpbmVMZW4pO1xuXG4gICAgaW5kaWNhdGlvbkxpbmUgPSBzdHJjcHkoaW5kaWNhdGlvbkxpbmUsIHJlcGVhdFN0cignficsIGVuZElkeCAtIHN0YXJ0SWR4KSwgc3RhcnRJZHgpO1xuICB9XG4gIGNvbnN0IGd1dHRlcldpZHRoID0gMiArIGxpbmVOdW1iZXJzWzFdLmxlbmd0aCArIDM7XG4gIHNiLmFwcGVuZChyZXBlYXRTdHIoJyAnLCBndXR0ZXJXaWR0aCkpO1xuICBpbmRpY2F0aW9uTGluZSA9IHN0cmNweShpbmRpY2F0aW9uTGluZSwgJ14nLCBsaW5lQW5kQ29sLmNvbE51bSAtIDEpO1xuICBzYi5hcHBlbmQoaW5kaWNhdGlvbkxpbmUucmVwbGFjZSgvICskLywgJycpICsgJ1xcbicpO1xuXG4gIC8vIEluY2x1ZGUgdGhlIG5leHQgbGluZSBmb3IgY29udGV4dCBpZiBwb3NzaWJsZS5cbiAgaWYgKGxpbmVBbmRDb2wubmV4dExpbmUgIT0gbnVsbCkge1xuICAgIGFwcGVuZExpbmUoMiwgbGluZUFuZENvbC5uZXh0TGluZSwgJyAgJyk7XG4gIH1cbiAgcmV0dXJuIHNiLmNvbnRlbnRzKCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubGV0IGJ1aWx0SW5SdWxlc0NhbGxiYWNrcyA9IFtdO1xuXG4vLyBTaW5jZSBHcmFtbWFyLkJ1aWx0SW5SdWxlcyBpcyBib290c3RyYXBwZWQsIG1vc3Qgb2YgT2htIGNhbid0IGRpcmVjdGx5IGRlcGVuZCBpdC5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIG1vZHVsZXMgdGhhdCBkbyBkZXBlbmQgb24gdGhlIGJ1aWx0LWluIHJ1bGVzIHRvIHJlZ2lzdGVyIGEgY2FsbGJhY2tcbi8vIHRoYXQgd2lsbCBiZSBjYWxsZWQgbGF0ZXIgaW4gdGhlIGluaXRpYWxpemF0aW9uIHByb2Nlc3MuXG5leHBvcnRzLmF3YWl0QnVpbHRJblJ1bGVzID0gY2IgPT4ge1xuICBidWlsdEluUnVsZXNDYWxsYmFja3MucHVzaChjYik7XG59O1xuXG5leHBvcnRzLmFubm91bmNlQnVpbHRJblJ1bGVzID0gZ3JhbW1hciA9PiB7XG4gIGJ1aWx0SW5SdWxlc0NhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICBjYihncmFtbWFyKTtcbiAgfSk7XG4gIGJ1aWx0SW5SdWxlc0NhbGxiYWNrcyA9IG51bGw7XG59O1xuXG4vLyBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdpdmVuXG4vLyBvZmZzZXQgaW4gYHN0cmAuXG5leHBvcnRzLmdldExpbmVBbmRDb2x1bW4gPSAoc3RyLCBvZmZzZXQpID0+IHtcbiAgbGV0IGxpbmVOdW0gPSAxO1xuICBsZXQgY29sTnVtID0gMTtcblxuICBsZXQgY3Vyck9mZnNldCA9IDA7XG4gIGxldCBsaW5lU3RhcnRPZmZzZXQgPSAwO1xuXG4gIGxldCBuZXh0TGluZSA9IG51bGw7XG4gIGxldCBwcmV2TGluZSA9IG51bGw7XG4gIGxldCBwcmV2TGluZVN0YXJ0T2Zmc2V0ID0gLTE7XG5cbiAgd2hpbGUgKGN1cnJPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICBjb25zdCBjID0gc3RyLmNoYXJBdChjdXJyT2Zmc2V0KyspO1xuICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgbGluZU51bSsrO1xuICAgICAgY29sTnVtID0gMTtcbiAgICAgIHByZXZMaW5lU3RhcnRPZmZzZXQgPSBsaW5lU3RhcnRPZmZzZXQ7XG4gICAgICBsaW5lU3RhcnRPZmZzZXQgPSBjdXJyT2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAoYyAhPT0gJ1xccicpIHtcbiAgICAgIGNvbE51bSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGVuZCBvZiB0aGUgdGFyZ2V0IGxpbmUuXG4gIGxldCBsaW5lRW5kT2Zmc2V0ID0gc3RyLmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydE9mZnNldCk7XG4gIGlmIChsaW5lRW5kT2Zmc2V0ID09PSAtMSkge1xuICAgIGxpbmVFbmRPZmZzZXQgPSBzdHIubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBsaW5lLlxuICAgIGNvbnN0IG5leHRMaW5lRW5kT2Zmc2V0ID0gc3RyLmluZGV4T2YoJ1xcbicsIGxpbmVFbmRPZmZzZXQgKyAxKTtcbiAgICBuZXh0TGluZSA9IG5leHRMaW5lRW5kT2Zmc2V0ID09PSAtMSA/IHN0ci5zbGljZShsaW5lRW5kT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3RyLnNsaWNlKGxpbmVFbmRPZmZzZXQsIG5leHRMaW5lRW5kT2Zmc2V0KTtcbiAgICAvLyBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBFT0wgY2hhcihzKS5cbiAgICBuZXh0TGluZSA9IG5leHRMaW5lLnJlcGxhY2UoL15cXHI/XFxuLywgJycpLnJlcGxhY2UoL1xcciQvLCAnJyk7XG4gIH1cblxuICAvLyBHZXQgdGhlIHByZXZpb3VzIGxpbmUuXG4gIGlmIChwcmV2TGluZVN0YXJ0T2Zmc2V0ID49IDApIHtcbiAgICBwcmV2TGluZSA9IHN0ci5zbGljZShwcmV2TGluZVN0YXJ0T2Zmc2V0LCBsaW5lU3RhcnRPZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKC9cXHI/XFxuJC8sICcnKTsgLy8gU3RyaXAgdHJhaWxpbmcgRU9MIGNoYXIocykuXG4gIH1cblxuICAvLyBHZXQgdGhlIHRhcmdldCBsaW5lLCBzdHJpcHBpbmcgYSB0cmFpbGluZyBjYXJyaWFnZSByZXR1cm4gaWYgbmVjZXNzYXJ5LlxuICBjb25zdCBsaW5lID0gc3RyLnNsaWNlKGxpbmVTdGFydE9mZnNldCwgbGluZUVuZE9mZnNldCkucmVwbGFjZSgvXFxyJC8sICcnKTtcblxuICByZXR1cm4ge1xuICAgIG9mZnNldCxcbiAgICBsaW5lTnVtLFxuICAgIGNvbE51bSxcbiAgICBsaW5lLFxuICAgIHByZXZMaW5lLFxuICAgIG5leHRMaW5lLFxuICAgIHRvU3RyaW5nOiBsaW5lQW5kQ29sdW1uVG9NZXNzYWdlXG4gIH07XG59O1xuXG4vLyBSZXR1cm4gYSBuaWNlbHktZm9ybWF0dGVkIHN0cmluZyBkZXNjcmliaW5nIHRoZSBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoZVxuLy8gZ2l2ZW4gb2Zmc2V0IGluIGBzdHJgIGhpZ2hsaWdodGluZyBgcmFuZ2VzYC5cbmV4cG9ydHMuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UgPSBmdW5jdGlvbihzdHIsIG9mZnNldCwgLi4ucmFuZ2VzKSB7XG4gIHJldHVybiBleHBvcnRzLmdldExpbmVBbmRDb2x1bW4oc3RyLCBvZmZzZXQpLnRvU3RyaW5nKC4uLnJhbmdlcyk7XG59O1xuXG5leHBvcnRzLnVuaXF1ZUlkID0gKCgpID0+IHtcbiAgbGV0IGlkQ291bnRlciA9IDA7XG4gIHJldHVybiBwcmVmaXggPT4gJycgKyBwcmVmaXggKyBpZENvdW50ZXIrKztcbn0pKCk7XG4iLCIvKiBnbG9iYWwgX19HTE9CQUxfT0hNX1ZFUlNJT05fXyAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFdoZW4gcnVubmluZyB1bmRlciBOb2RlLCByZWFkIHRoZSB2ZXJzaW9uIGZyb20gcGFja2FnZS5qc29uLiBGb3IgdGhlIGJyb3dzZXIsXG4vLyB1c2UgYSBzcGVjaWFsIGdsb2JhbCB2YXJpYWJsZSBkZWZpbmVkIGluIHRoZSBidWlsZCBwcm9jZXNzIChzZWUgd2VicGFjay5jb25maWcuanMpLlxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgX19HTE9CQUxfT0hNX1ZFUlNJT05fXyA9PT0gJ3N0cmluZydcbiAgICA/IF9fR0xPQkFMX09ITV9WRVJTSU9OX19cbiAgICA6IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4iLCIvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTkuMC4wLlxuLy8gVGhlc2UgYXJlIGp1c3QgY2F0ZWdvcmllcyB0aGF0IGFyZSB1c2VkIGluIEVTNS9FUzIwMTUuXG4vLyBUaGUgZnVsbCBsaXN0IG9mIFVuaWNvZGUgY2F0ZWdvcmllcyBpcyBoZXJlOiBodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9pbmZvL3VuaWNvZGUvY2F0ZWdvcnkvaW5kZXguaHRtLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIExldHRlcnNcbiAgTHU6IC9bQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE4M1xcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FFXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQV18XFx1RDgwMVtcXHVEQzAwLVxcdURDMjdcXHVEQ0IwLVxcdURDRDNdfFxcdUQ4MDNbXFx1REM4MC1cXHVEQ0IyXXxcXHVEODA2W1xcdURDQTAtXFx1RENCRl18XFx1RDgzNVtcXHVEQzAwLVxcdURDMTlcXHVEQzM0LVxcdURDNERcXHVEQzY4LVxcdURDODFcXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjVcXHVEQ0QwLVxcdURDRTlcXHVERDA0XFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMzhcXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENkMtXFx1REQ4NVxcdUREQTAtXFx1RERCOVxcdURERDQtXFx1RERFRFxcdURFMDgtXFx1REUyMVxcdURFM0MtXFx1REU1NVxcdURFNzAtXFx1REU4OVxcdURFQTgtXFx1REVDMFxcdURFRTItXFx1REVGQVxcdURGMUMtXFx1REYzNFxcdURGNTYtXFx1REY2RVxcdURGOTAtXFx1REZBOFxcdURGQ0FdfFxcdUQ4M0FbXFx1REQwMC1cXHVERDIxXS8sXG4gIExsOiAvW2EtelxceEI1XFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJBRlxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0ItXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxQzgwLVxcdTFDODhcXHUxRDAwLVxcdTFEMkJcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEOUFcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTg0XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdCXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2RlxcdUE3NzEtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI2MC1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBXXxcXHVEODAxW1xcdURDMjgtXFx1REM0RlxcdURDRDgtXFx1RENGQl18XFx1RDgwM1tcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDZbXFx1RENDMC1cXHVEQ0RGXXxcXHVEODM1W1xcdURDMUEtXFx1REMzM1xcdURDNEUtXFx1REM1NFxcdURDNTYtXFx1REM2N1xcdURDODItXFx1REM5QlxcdURDQjYtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdURDQ0ZcXHVEQ0VBLVxcdUREMDNcXHVERDFFLVxcdUREMzdcXHVERDUyLVxcdURENkJcXHVERDg2LVxcdUREOUZcXHVEREJBLVxcdURERDNcXHVEREVFLVxcdURFMDdcXHVERTIyLVxcdURFM0JcXHVERTU2LVxcdURFNkZcXHVERThBLVxcdURFQTVcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRTFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMUJcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNTVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGOEZcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQzlcXHVERkNCXXxcXHVEODNBW1xcdUREMjItXFx1REQ0M10vLFxuICBMdDogL1tcXHUwMUM1XFx1MDFDOFxcdTAxQ0JcXHUwMUYyXFx1MUY4OC1cXHUxRjhGXFx1MUY5OC1cXHUxRjlGXFx1MUZBOC1cXHUxRkFGXFx1MUZCQ1xcdTFGQ0NcXHUxRkZDXS8sXG4gIExtOiAvW1xcdTAyQjAtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3NFxcdTAzN0FcXHUwNTU5XFx1MDY0MFxcdTA2RTVcXHUwNkU2XFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDk3MVxcdTBFNDZcXHUwRUM2XFx1MTBGQ1xcdTE3RDdcXHUxODQzXFx1MUFBN1xcdTFDNzgtXFx1MUM3RFxcdTFEMkMtXFx1MUQ2QVxcdTFENzhcXHUxRDlCLVxcdTFEQkZcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTJDN0NcXHUyQzdEXFx1MkQ2RlxcdTJFMkZcXHUzMDA1XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwOURcXHUzMDlFXFx1MzBGQy1cXHUzMEZFXFx1QTAxNVxcdUE0RjgtXFx1QTRGRFxcdUE2MENcXHVBNjdGXFx1QTY5Q1xcdUE2OURcXHVBNzE3LVxcdUE3MUZcXHVBNzcwXFx1QTc4OFxcdUE3RjhcXHVBN0Y5XFx1QTlDRlxcdUE5RTZcXHVBQTcwXFx1QUFERFxcdUFBRjNcXHVBQUY0XFx1QUI1Qy1cXHVBQjVGXFx1RkY3MFxcdUZGOUVcXHVGRjlGXXxcXHVEODFBW1xcdURGNDAtXFx1REY0M118XFx1RDgxQltcXHVERjkzLVxcdURGOUZcXHVERkUwXS8sXG4gIExvOiAvW1xceEFBXFx4QkFcXHUwMUJCXFx1MDFDMC1cXHUwMUMzXFx1MDI5NFxcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDYzRlxcdTA2NDEtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDgwMC1cXHUwODE1XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcyLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDVcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwRDAtXFx1MTBGQVxcdTEwRkQtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEQ1xcdTE4MjAtXFx1MTg0MlxcdTE4NDQtXFx1MTg3N1xcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3N1xcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MjEzNS1cXHUyMTM4XFx1MkQzMC1cXHUyRDY3XFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTAxNFxcdUEwMTYtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGN1xcdUE1MDAtXFx1QTYwQlxcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY2RVxcdUE2QTAtXFx1QTZFNVxcdUE3OEZcXHVBN0Y3XFx1QTdGQi1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUUwLVxcdUE5RTRcXHVBOUU3LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNkZcXHVBQTcxLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCXFx1QUFEQ1xcdUFBRTAtXFx1QUFFQVxcdUFBRjJcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjY2LVxcdUZGNkZcXHVGRjcxLVxcdUZGOURcXHVGRkEwLVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MDFbXFx1REM1MC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4Rl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuXG4gIC8vIE51bWJlcnNcbiAgTmw6IC9bXFx1MTZFRS1cXHUxNkYwXFx1MjE2MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg4XFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdUE2RTYtXFx1QTZFRl18XFx1RDgwMFtcXHVERDQwLVxcdURENzRcXHVERjQxXFx1REY0QVxcdURGRDEtXFx1REZENV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVdLyxcbiAgTmQ6IC9bMC05XFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEJFNi1cXHUwQkVGXFx1MEM2Ni1cXHUwQzZGXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDZGXFx1MERFNi1cXHUwREVGXFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTdFMC1cXHUxN0U5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOUQ5XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1QTYyMC1cXHVBNjI5XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QTlGMC1cXHVBOUY5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5XXxcXHVEODAxW1xcdURDQTAtXFx1RENBOV18XFx1RDgwNFtcXHVEQzY2LVxcdURDNkZcXHVEQ0YwLVxcdURDRjlcXHVERDM2LVxcdUREM0ZcXHVEREQwLVxcdURERDlcXHVERUYwLVxcdURFRjldfFtcXHVEODA1XFx1RDgwN11bXFx1REM1MC1cXHVEQzU5XFx1RENEMC1cXHVEQ0Q5XFx1REU1MC1cXHVERTU5XFx1REVDMC1cXHVERUM5XFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDRTAtXFx1RENFOV18XFx1RDgxQVtcXHVERTYwLVxcdURFNjlcXHVERjUwLVxcdURGNTldfFxcdUQ4MzVbXFx1REZDRS1cXHVERkZGXXxcXHVEODNBW1xcdURENTAtXFx1REQ1OV0vLFxuXG4gIC8vIE1hcmtzXG4gIE1uOiAvW1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RTJcXHUwOUUzXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBCMDFcXHUwQjNDXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU2XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJDMFxcdTBCQ0RcXHUwQzAwXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRTJcXHUwQ0UzXFx1MEQwMVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDYyXFx1MEQ2M1xcdTBEQ0FcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQjlcXHUwRUJCXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCMDNcXHUxQjM0XFx1MUIzNi1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGNVxcdTFERkItXFx1MURGRlxcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJEXFx1MzA5OVxcdTMwOUFcXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVERENBLVxcdUREQ0NcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQ1xcdURGNDBcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjhGLVxcdURGOTJdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2Ny1cXHVERDY5XFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1REI0MFtcXHVERDAwLVxcdURERUZdLyxcbiAgTWM6IC9bXFx1MDkwMy1cXHUwOTAzXXxbXFx1MDkzRS1cXHUwOTQwXXxbXFx1MDk0OS1cXHUwOTRDXXxbXFx1MDk4Mi1cXHUwOTgzXXxbXFx1MDlCRS1cXHUwOUMwXXxbXFx1MDlDNy1cXHUwOUM4XXxbXFx1MDlDQi1cXHUwOUNDXXxbXFx1MDlENy1cXHUwOUQ3XXxbXFx1MEEzRS1cXHUwQTQwXXxbXFx1MEE4My1cXHUwQTgzXXxbXFx1MEFCRS1cXHUwQUMwXXxbXFx1MEFDOS1cXHUwQUM5XXxbXFx1MEFDQi1cXHUwQUNDXXxbXFx1MEIwMi1cXHUwQjAzXXxbXFx1MEIzRS1cXHUwQjNFXXxbXFx1MEI0MC1cXHUwQjQwXXxbXFx1MEI0Ny1cXHUwQjQ4XXxbXFx1MEI0Qi1cXHUwQjRDXXxbXFx1MEI1Ny1cXHUwQjU3XXxbXFx1MEI4My1cXHUwQjgzXXxbXFx1MEJCRS1cXHUwQkJGXXxbXFx1MEJDMS1cXHUwQkMyXXxbXFx1MEJDNi1cXHUwQkM4XXxbXFx1MEJDQS1cXHUwQkNDXXxbXFx1MEJENy1cXHUwQkQ3XXxbXFx1MEMwMS1cXHUwQzAzXXxbXFx1MEM0MS1cXHUwQzQ0XXxbXFx1MEM4Mi1cXHUwQzgzXXxbXFx1MENCRS1cXHUwQ0JFXXxbXFx1MENDMC1cXHUwQ0M0XXxbXFx1MENDNy1cXHUwQ0M4XXxbXFx1MENDQS1cXHUwQ0NCXXxbXFx1MENENS1cXHUwQ0Q2XXxbXFx1MEQwMi1cXHUwRDAzXXxbXFx1MEQzRS1cXHUwRDQwXXxbXFx1MEQ0Ni1cXHUwRDQ4XXxbXFx1MEQ0QS1cXHUwRDRDXXxbXFx1MEQ1Ny1cXHUwRDU3XXxbXFx1MEYzRS1cXHUwRjNGXXxbXFx1MEY3Ri1cXHUwRjdGXS8sXG5cbiAgLy8gUHVuY3R1YXRpb24sIENvbm5lY3RvclxuICBQYzogL1tfXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRjNGXS8sXG5cbiAgLy8gU2VwYXJhdG9yLCBTcGFjZVxuICBaczogL1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS8sXG5cbiAgLy8gVGhlc2UgdHdvIGFyZSBub3QgcmVhbCBVbmljb2RlIGNhdGVnb3JpZXMsIGJ1dCBvdXIgdXNlZnVsIGZvciBPaG0uXG4gIC8vIEwgaXMgYSBjb21iaW5hdGlvbiBvZiBhbGwgdGhlIGxldHRlciBjYXRlZ29yaWVzLlxuICAvLyBMdG1vIGlzIGEgY29tYmluYXRpb24gb2YgTHQsIExtLCBhbmQgTG8uXG4gIEw6IC9bQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTgzXFx1MjE4NFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDVcXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFNVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXG4gIEx0bW86IC9bXFx1MDFDNVxcdTAxQzhcXHUwMUNCXFx1MDFGMlxcdTFGODgtXFx1MUY4RlxcdTFGOTgtXFx1MUY5RlxcdTFGQTgtXFx1MUZBRlxcdTFGQkNcXHUxRkNDXFx1MUZGQ118W1xcdTAyQjAtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3NFxcdTAzN0FcXHUwNTU5XFx1MDY0MFxcdTA2RTVcXHUwNkU2XFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDk3MVxcdTBFNDZcXHUwRUM2XFx1MTBGQ1xcdTE3RDdcXHUxODQzXFx1MUFBN1xcdTFDNzgtXFx1MUM3RFxcdTFEMkMtXFx1MUQ2QVxcdTFENzhcXHUxRDlCLVxcdTFEQkZcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTJDN0NcXHUyQzdEXFx1MkQ2RlxcdTJFMkZcXHUzMDA1XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwOURcXHUzMDlFXFx1MzBGQy1cXHUzMEZFXFx1QTAxNVxcdUE0RjgtXFx1QTRGRFxcdUE2MENcXHVBNjdGXFx1QTY5Q1xcdUE2OURcXHVBNzE3LVxcdUE3MUZcXHVBNzcwXFx1QTc4OFxcdUE3RjhcXHVBN0Y5XFx1QTlDRlxcdUE5RTZcXHVBQTcwXFx1QUFERFxcdUFBRjNcXHVBQUY0XFx1QUI1Qy1cXHVBQjVGXFx1RkY3MFxcdUZGOUVcXHVGRjlGXXxcXHVEODFBW1xcdURGNDAtXFx1REY0M118XFx1RDgxQltcXHVERjkzLVxcdURGOUZcXHVERkUwXXxbXFx4QUFcXHhCQVxcdTAxQkJcXHUwMUMwLVxcdTAxQzNcXHUwMjk0XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjNGXFx1MDY0MS1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwODAwLVxcdTA4MTVcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzItXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBEMC1cXHUxMEZBXFx1MTBGRC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0RDXFx1MTgyMC1cXHUxODQyXFx1MTg0NC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzc3XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUyMTM1LVxcdTIxMzhcXHUyRDMwLVxcdTJENjdcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA2XFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBMDE0XFx1QTAxNi1cXHVBNDhDXFx1QTREMC1cXHVBNEY3XFx1QTUwMC1cXHVBNjBCXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjZFXFx1QTZBMC1cXHVBNkU1XFx1QTc4RlxcdUE3RjdcXHVBN0ZCLVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5RTAtXFx1QTlFNFxcdUE5RTctXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE2RlxcdUFBNzEtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREJcXHVBQURDXFx1QUFFMC1cXHVBQUVBXFx1QUFGMlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGNjYtXFx1RkY2RlxcdUZGNzEtXFx1RkY5RFxcdUZGQTAtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwMVtcXHVEQzUwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OF18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS9cbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5mdW5jdGlvbiBleHRlbmQob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCB0eXBlb2YgYWRkICE9PSAnb2JqZWN0JykgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn1cbiIsInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcbnZhciB2NCA9IHJlcXVpcmUoJy4vdjQnKTtcblxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW1xuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXG4gIF0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG52YXIgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgdmFyIHNlZWRCeXRlcyA9IHJuZygpO1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbXG4gICAgICAgIHNlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgICAgIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH1cblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgPyBidWYgOiBieXRlc1RvVXVpZChiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2MTtcbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iLCJjb25zdCBtZXJyaWFtID0ge1xuICAgIG5hbWU6IFwiTWVycmlhbUFQSVwiLFxuICAgIGxvYWQ6IGZ1bmN0aW9uKHVybCl7XG4gICAgICAgIHRoaXMuc3JjID0gdXJsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHJlc3BvbnNlOiBudWxsLFxuICAgIGNhY2hlOiBudWxsLFxuICAgIGNhY2hlTmV4dEl0ZW06IG51bGwsXG4gICAgY3VycmVudFJlc3BvbnNlSXRlbUluZGV4OiAtMSxcbiAgICBzcmM6IG51bGwsXG4gICAgZ2V0OiBhc3luYyBmdW5jdGlvbihwcmVyZXF1aXNpdGUsIGFyZyl7XG4gICAgICAgIGlmKGFyZyl7XG4gICAgICAgICAgICBpZighdGhpcy5jYWNoZSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJObyByZXN1bHQgaGFzIGJlZW4gZmV0Y2hlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFyZyA9PSBcIm5leHRcIil7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSB0aGlzLmNhY2hlLnJlc3VsdHM7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzcG9uc2VJdGVtSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleCA+PSByZXN1bHRzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlSXRlbUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMuY2FjaGUucmVzdWx0c1t0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleF07XG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSByZXN1bHQgaW4gdGhlIG5leHQgaXRlbSBjYWNoZVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVOZXh0SXRlbSA9IHRoaXMuY2FjaGUucmVzdWx0c1t0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucmVzcG9uc2UsIG51bGwsICdcXHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlcmUgd2UgYXNzdW1lIHRoYXQgdGhlIGFyZyBpcyBhIGtleSBpbiB0aGUgbmV4dCBpdGVtIGNhY2hlXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5jYWNoZU5leHRJdGVtW2FyZ107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VQcmVyZXF1aXNpdGUocHJlcmVxdWlzaXRlKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgICAgICBcImhlYWRlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJib2R5XCI6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuc3JjLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHsgLy8gaWYgSFRUUC1zdGF0dXMgaXMgMjAwLTI5OVxuICAgICAgICAgICAgLy8gZ2V0IHRoZSByZXNwb25zZSBib2R5ICh0aGUgbWV0aG9kIGV4cGxhaW5lZCBiZWxvdylcbiAgICAgICAgICAgIGxldCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IGpzb247XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0ganNvbjtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJlc3BvbnNlLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSFRUUC1FcnJvcjogXCIgKyByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG5sZXQgcGFyc2VQcmVyZXF1aXNpdGUgPSAocCkgPT4ge1xuICAgIGxldCBwTGlzdCA9IHAuc3BsaXQoXCI7XCIpO1xuICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgcExpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBsZXQga2V5ID0gaXRlbS5zcGxpdChcIjpcIilbMF07XG4gICAgICAgIGxldCB2YWx1ZSA9IGl0ZW0ucmVwbGFjZShgJHtrZXl9OmAsIFwiXCIpO1xuICAgICAgICBzd2l0Y2goa2V5KXtcbiAgICAgICAgY2FzZSBcImZpZWxkc1wiOlxuICAgICAgICAgICAgcGF5bG9hZFtcImZpZWxkc1wiXSA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndlaWdodHNcIjpcbiAgICAgICAgICAgIGxldCB3ZWlnaHRzID0ge307XG4gICAgICAgICAgICB2YWx1ZS5zcGxpdChcIixcIikuZm9yRWFjaCgodykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBbd19uYW1lLCB3X3ZhbHVlXSA9IHcuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgIHdlaWdodHNbd19uYW1lXSA9IE51bWJlcih3X3ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGF5bG9hZFtcIndlaWdodHNcIl0gPSB3ZWlnaHRzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkb2NfaWRzXCI6XG4gICAgICAgICAgICBwYXlsb2FkW1wiZG9jX2lkc1wiXSA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGltaXRcIjpcbiAgICAgICAgICAgIHBheWxvYWRbXCJsaW1pdFwiXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXlsb2FkO1xufVxuXG5cbmV4cG9ydCB7XG4gICAgbWVycmlhbSxcbiAgICBtZXJyaWFtIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgVGVzdCBmcm9tICcuL3Rlc3RBUEkuanMnO1xuaW1wb3J0IE1lcnJpYW0gZnJvbSAnLi9tZXJyaWFtLmpzJztcblxuY29uc3QgcGx1Z2lucyA9IHtcbiAgICBcIk1lcnJpYW1BUElcIjogTWVycmlhbSxcbiAgICBcIlRlc3RBUElcIjogVGVzdFxufVxuXG5leHBvcnQge1xuICAgIHBsdWdpbnMsXG4gICAgcGx1Z2lucyBhcyBkZWZhdWx0XG59XG4iLCJjb25zdCB0ZXN0ID0ge1xuICAgIG5hbWU6IFwiVGVzdEFQSVwiLFxuICAgIGxvYWQ6IGZ1bmN0aW9uKHVybCl7XG4gICAgICAgIHRoaXMuc3JjID0gdXJsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHJlc3BvbnNlOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBnZXQ6IGFzeW5jIGZ1bmN0aW9uKHByZXJlcXVpc2l0ZSwga2V5KXtcbiAgICAgICAgaWYoa2V5KXtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlc3BvbnNlKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vIHJlc3VsdCBoYXMgYmVlbiBmZXRjaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3JjID0gdGhpcy5zcmM7XG4gICAgICAgIGlmKHByZXJlcXVpc2l0ZSl7XG4gICAgICAgICAgICBzcmMgPSBzcmMgKyBcIi9cIiArIHByZXJlcXVpc2l0ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzcmMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHsgLy8gaWYgSFRUUC1zdGF0dXMgaXMgMjAwLTI5OVxuICAgICAgICAgICAgLy8gZ2V0IHRoZSByZXNwb25zZSBib2R5ICh0aGUgbWV0aG9kIGV4cGxhaW5lZCBiZWxvdylcbiAgICAgICAgICAgIGxldCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IGpzb247XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSFRUUC1FcnJvcjogXCIgKyByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQge1xuICAgIHRlc3QsXG4gICAgdGVzdCBhcyBkZWZhdWx0XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==