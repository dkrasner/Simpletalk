/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/objects/System.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/objects/ExecutionStack.js":
/*!**************************************!*\
  !*** ./js/objects/ExecutionStack.js ***!
  \**************************************/
/*! exports provided: ExecutionStack, ActivationContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExecutionStack", function() { return ExecutionStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivationContext", function() { return ActivationContext; });
/**
 * ExecutionStack
 * ---------------------------------
 * I am an object that manages a stack of
 * ActivationContext objects.
 * I am designed to be used by System as the
 * global execution stack.
 *
 */

class ExecutionStack {
    constructor(){
        this._stack = [];
        this._globals = {};

        // Bound methods
        this.pop = this.pop.bind(this);
        this.push = this.push.bind(this);
        this.setGlobal = this.setGlobal.bind(this);
        this.getGlobal = this.getGlobal.bind(this);
    }

    pop(){
        if(!this._stack.length){
            return null;
        }
        return this._stack.pop();
    }

    push(anActivation){
        this._stack.push(anActivation);
    }

    setGlobal(varName, value){
        this._globals[varName] = value;
    }

    getGlobal(varName){
        return this._globals[varName];
    }

    get current(){
        if(!this._stack.length){
            return null;
        }
        return this._stack[this._stack.length - 1];
    }

    get previous(){
        if(!this._stack.length >= 2){
            return null;
        }
        return this._stack[this._stack.length - 2];
    }
};

class ActivationContext {
    constructor(messageName, part, incomingMessage, handlerFunction){
        this.part = part;
        this.messageName = messageName;
        this.message = incomingMessage;
        this.handlerFunction = handlerFunction;
        this._locals = {};

        // Bound methods
        this.get = this.get.bind(this);
        this.getLocal = this.getLocal.bind(this);
        this.setLocal = this.setLocal.bind(this);
    }

    get(varName){
        let localValue = this.getLocal(varName);
        if(localValue !== undefined){
            return localValue;
        };
        // otherwise try to return a global
        // variable
        return window.System.executionStack.getGlobal(varName);
    }

    getLocal(varName){
        return this._locals[varName];
    }

    setLocal(varName, value){
        this._locals[varName] = value;
    }
}




/***/ }),

/***/ "./js/objects/System.js":
/*!******************************!*\
  !*** ./js/objects/System.js ***!
  \******************************/
/*! exports provided: System, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return System; });
/* harmony import */ var _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parts/Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parts/Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parts/Button.js */ "./js/objects/parts/Button.js");
/* harmony import */ var _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parts/Field.js */ "./js/objects/parts/Field.js");
/* harmony import */ var _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parts/WorldStack.js */ "./js/objects/parts/WorldStack.js");
/* harmony import */ var _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parts/Window.js */ "./js/objects/parts/Window.js");
/* harmony import */ var _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parts/Drawing.js */ "./js/objects/parts/Drawing.js");
/* harmony import */ var _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parts/Audio.js */ "./js/objects/parts/Audio.js");
/* harmony import */ var _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parts/Browser.js */ "./js/objects/parts/Browser.js");
/* harmony import */ var _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parts/Resource.js */ "./js/objects/parts/Resource.js");
/* harmony import */ var _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parts/Image.js */ "./js/objects/parts/Image.js");
/* harmony import */ var _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parts/Area.js */ "./js/objects/parts/Area.js");
/* harmony import */ var _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./views/WorldView.js */ "./js/objects/views/WorldView.js");
/* harmony import */ var _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./views/StackView.js */ "./js/objects/views/StackView.js");
/* harmony import */ var _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./views/ButtonView.js */ "./js/objects/views/ButtonView.js");
/* harmony import */ var _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./views/CardView.js */ "./js/objects/views/CardView.js");
/* harmony import */ var _views_WindowView__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./views/WindowView */ "./js/objects/views/WindowView.js");
/* harmony import */ var _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./views/FieldView.js */ "./js/objects/views/FieldView.js");
/* harmony import */ var _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./views/drawing/DrawingView.js */ "./js/objects/views/drawing/DrawingView.js");
/* harmony import */ var _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./views/ImageView.js */ "./js/objects/views/ImageView.js");
/* harmony import */ var _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./views/AreaView.js */ "./js/objects/views/AreaView.js");
/* harmony import */ var _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./views/AudioView.js */ "./js/objects/views/AudioView.js");
/* harmony import */ var _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./views/BrowserView.js */ "./js/objects/views/BrowserView.js");
/* harmony import */ var _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./views/ResourceView.js */ "./js/objects/views/ResourceView.js");
/* harmony import */ var _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./views/Halo.js */ "./js/objects/views/Halo.js");
/* harmony import */ var _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./views/navigator/Navigator.js */ "./js/objects/views/navigator/Navigator.js");
/* harmony import */ var _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./views/editors/Editor.js */ "./js/objects/views/editors/Editor.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ohm-js */ "./node_modules/ohm-js/src/main.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(ohm_js__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./utils/clipboard.js */ "./js/objects/utils/clipboard.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./utils/handInterface.js */ "./js/objects/utils/handInterface.js");
/* harmony import */ var _utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./utils/merriamInterface.js */ "./js/objects/utils/merriamInterface.js");
/* harmony import */ var _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./utils/serialization.js */ "./js/objects/utils/serialization.js");
/* harmony import */ var _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../../plugins/plugins.js */ "./plugins/plugins.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * System Object
 * -------------------------------------
 * I am an object representing the "top" of the
 * sytem. I am the point of communication between
 * Models and Views.
 */
















































const DOMparser = new DOMParser();




const System = {
    name: "System",
    id: -1,
    isLoaded: false,
    partsById: {},
    _commandHandlers: {},
    _functionHandlers: {},
    _deserializer: null,

    // A dictionary mapping available ST resource (such as plugin) names
    availableResources: {},

    // A dictionary mapping part types like
    // 'button' to their classes (Button)
    availableParts: {},

    // A dictionary mapping part types like
    // 'button' to their view classes (ButtonView)
    availableViews: {},

    // A registry that keeps all system messages from
    // beginnign of time; TODO in the future we might want
    // to note keep all this in memory
    // each log consists of:
    // [aMessage, (sourceName, sourceId), (targetName, targetId)]
    messageLog: [],

    // Will be called when a page loads.
    // Checks for any view elements in the
    // page and attempts to find serialized
    // model state for each of them. If present,
    // deserializes the model and attaches it
    // to the view.
    initialLoad: function(){
        // load the available resources
        // these might be needed down the line
        this.loadResources();

        // If we have a serialization script tag
        // containing JSON of serialized information,
        // attempt to load from it
        let serializationEl = document.getElementById('serialization');
        if(serializationEl && serializationEl.text != ""){
            this.deserialize()
                .then(() => {
                    this.sendInitialOpenMessages();
                    System.navigator.setModel(
                        System.partsById['world']
                    );

                    // By default, we render the World in the
                    // Comprehensive Editor
                    this.editor.render(this.world);
                });
        } else {
            this.loadFromEmpty();
 
            // By default, we render the World in the
            // Comprehensive Editor
            this.editor.render(this.world);
        }

        // Attach a new clipboard instance
        this.clipboard = new _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__["default"](this);

        // By this point we should have a WorldView with
        // a model attached.
        this.isLoaded = true;
    },

    loadResources: function() {
        Object.keys(_plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"]).forEach((k) => {
            this.availableResources[k] = _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"][k];
        });
    },

    loadFromEmpty: function(){
        let worldModel = new this.availableParts['world']();
        this.partsById[worldModel.id] = worldModel;
        let worldView = document.createElement(
            this.tagNameForViewNamed('world')
        );
        worldView.setModel(worldModel);
        document.body.appendChild(worldView);

        // Create initial stack model
        let initStack = this.newModel('stack', worldModel.id);

        // Create initial card model for that stack
        let initCard = this.newModel('card', initStack.id);

        // Update current stack and card ids 
        worldModel.partProperties.setPropertyNamed(
            worldModel,
            'current',
            initStack.id
        );
        initStack.partProperties.setPropertyNamed(
            initStack,
            'current',
            initCard.id
        );
        // Update serialization
        this.serialize();

        this.sendInitialOpenMessages();
        System.navigator.setModel(
            System.partsById['world']
        );
    },

    sendInitialOpenMessages: function(){
        // Send the openWorld message to the WorldStack
        let world = this.partsById['world'];
        world.sendMessage({
            type: 'command',
            commandName: 'openWorld',
            args: [],
            shouldIgnore: true
        }, world);
        world.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, world.currentStack);
        world.currentStack.sendMessage({
            type: 'command',
            commandName: 'openCard',
            args: [],
            shouldIgnore: true
        }, world.currentStack.currentCard);
    },

    sendMessage: function(aMessage, source, target){
        if(!target || target == undefined){
            throw new Error('Messages must be sent with target receivers specified!');
        }

        // keep track of all sources which pass this message
        if (!("senders" in aMessage)) {
            aMessage["senders"] = [];
        }
        aMessage.senders.push({
            name: source.name,
            id: source.id,
        });

        return target.receiveMessage(aMessage);
    },

    receiveMessage: function(aMessage){
        switch(aMessage.type){
            case 'newView':
                return this.newView(
                    aMessage.viewType,
                    aMessage.modelId
                );
            case 'compile':
                return this.compile(aMessage);
            case 'command':
                return this.receiveCommand(aMessage);
            default:
                return this.doesNotUnderstand(aMessage);
        }
    },

    doesNotUnderstand: function(aMessage){
        // If the message has the shouldIgnore property
        // set to true, it means we should just swallow
        // this message if we don't understand it. This is
        // useful for messages like mouse events on buttons
        // which are not captured by default and would otherwise
        // end up arriving to this System object via the
        // message delegation chain.
        if(aMessage.shouldIgnore){
            return;
        }
        let originalSender = this.partsById[aMessage.senders[0].id];
        let msg = {
            type: "error",
            name: "MessageNotUnderstood",
            message: aMessage
        };
        originalSender.sendMessage(msg, originalSender);
    },

    compile: function(aMessage){
        let targetObject = this.partsById[aMessage.targetId];
        if(!targetObject || targetObject == undefined){
            throw new Error(`System could not compile target object ${aMessage.targetId}`);
        }


        // Attempt to parse the incoming SimpleTalk script string.
        // If there are grammatical errors, report them and bail.
        // Otherwise, create a new semantics on the targetPart, add
        // the required semantic operations, and interpret the top
        // level of the script, which will create the JS handler functions
        let parsedScript = languageGrammar.match(aMessage.codeString);
        if(parsedScript.failed()){
            // consider using the parse data from trace
            // example: let tracedScript = languageGrammar.trace(aMessage.codeString);
            // let tree = tracedScript.toString();
            let msg = {
                type: "error",
                name: "GrammarMatchError",
                parsedScript: parsedScript,
                partId: aMessage.targetId
            };
            targetObject.sendMessage(msg, targetObject);
        } else {
            // First, clear out any currently compiled handlers
            // since the incoming script might get rid of them
            targetObject._commandHandlers = {};

            // Create a semantics object whose partContext
            // attribute is set to be the target object.
            targetObject._semantics = languageGrammar.createSemantics();
            targetObject._semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(targetObject, this)
            );
            targetObject._semantics(parsedScript).interpret();
        }


        // Be sure to then update the
        // serialization for the target
        // part, thus adding the script to
        // its serialization
        if(aMessage.serialize){
            this.serialize();
        }
    },

    receiveCommand: function(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            let boundHandler = handler.bind(this);
            let activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            this.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            this.executionStack.pop();
            return result;
        } else {
            return this.doesNotUnderstand(aMessage);
        }
    },

    newModel: function(kind, ownerId, name, buildView=true){
        // Lookup the instance of the model that
        // matches the owner's id
        let ownerPart = this.partsById[ownerId];
        if(!ownerPart || ownerPart == undefined){
            throw new Error(`System could not locate owner part with id ${ownerId}`);
        }

        // Find the class constructor for the kind of
        // part requested as a new model. If not known,
        // throw an error
        let modelClass = this.availableParts[kind];
        if(!modelClass){
            throw new Error(`Cannot create unknown part type: ${kind}`);
        }
        let model = new modelClass(ownerPart);
        if(name){
            model.partProperties.setPropertyNamed(model, 'name', name);
        }
        this.partsById[model.id] = model;

        // Any created part might initialize its
        // own subparts. We need to let the System know
        // about those too
        model.subparts.forEach(subpart => {
            this.partsById[subpart.id] = subpart;
        });

        // If there is a valid owner part for
        // the newly created part model,
        // add the new model to the owner's
        // subparts list
        if(ownerPart){
            ownerPart.addPart(model);
        }

        // Add the System as a property subscriber to
        // the new model. This will send a message to
        // this System object whenever any of this model's
        // properties have changed
        model.addPropertySubscriber(this);

        if(buildView){
            // See if there is already a view for the model.
            // If not, create and attach it.
            let viewForModel = this.findViewById(model.id);
            if(!viewForModel){
                this.newView(model.type, model.id);
            }
        }

        // If the owner part is either a world or a stack
        // and has only one stack or card child, respectively, set
        // that child to be the current
        if(ownerPart.type == "world" || ownerPart.type == "stack"){
            let currentId = ownerPart.partProperties.getPropertyNamed(ownerPart, "current");
            if(!currentId){
                ownerPart.partProperties.setPropertyNamed(ownerPart, "current", model.id);
            }
        }

        // Finally send the model a message to announce that it is new
        // to the world, but don't 
        this.sendMessage({
            type: 'command',
            commandName: 'newModel',
            args: [],
            shouldNotDelegate: true,
            shouldIgnore: true
        }, this, model);

        return model;
    },

    newProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find newProperty target!`);
        }

        if(target.partProperties.findPropertyNamed(propName)){
            // TODO this should be a ST error
            throw new Error(`Part ${target.id} already has property "${propName}"`);
        }
        // we only add basic property and the default value is null
        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__["BasicProperty"](propName, null);
        customProp.add(newProp);
    },

    deleteProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find deleteProperty target!`);
        }

        // Note: this will only delete custom properties which is what we want
        let prop = target.partProperties.findPropertyNamed(propName);

        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        customProp.delete(prop);
    },

    setProperty(senders, propName, value, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find setProperty target!`);
        }

        target.partProperties.setPropertyNamed(
            target,
            propName,
            value
        );
    },

    // Remove the model with the given ID from
    // the System's registry, as well as from the subparts
    // array of any owners
    deleteModel: function(modelId){
        let foundModel = this.partsById[modelId];
        if(!foundModel){
            return false;
        }
        // When removing a card or a stack be sure it is not the only one
        // and if it is the current card or stack we should go to the next one
        // before removing it
        if(foundModel.type == "card" || foundModel.type == "stack"){
            let sameTypeSubparts = foundModel._owner.subparts.filter((p) => {return p.type == foundModel.type;});
            if(sameTypeSubparts.length == 1){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the only ${foundModel.type}`);
            } else if(modelId == this.getCurrentStackModel().id  || modelId == this.getCurrentCardModel().id){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the current ${foundModel.type}`);
            }
        }

        // Make sure to stop all stepping
        // on the Part, otherwise stepping
        // intervals will error infinitely
        foundModel.stopStepping();

        // make sure the editor is closed
        foundModel.closeEditorCmdHandler();

        let ownerModel = foundModel._owner;
        if(ownerModel){
            ownerModel.removePart(foundModel);
        }

        delete this.partsById[modelId];
        this.removeViews(modelId);

        // Serialize the state
        this.serialize();
        return true;
    },

    // Remove all views with the corresponding
    // model id from the DOM
    removeViews: function(modelId){
        let views = Array.from(this.findViewsById(modelId));
        views.forEach(view => {
            let parentEl = view.parentElement;
            view.parentElement.removeChild(view);
            // Dispatch a CustomEvent on the parentElement
            // indicating that this part has been removed, and
            // any view utilities that care can be notified.
            let event = new CustomEvent('st-view-removed', {
                detail: {
                    partType: view.model.type,
                    partId: modelId,
                    ownerId: null
                } 
            });
            parentEl.dispatchEvent(event);
        });
        let lenses = this.findLensViewsById(modelId);
        lenses.forEach(lensView => {
            lensView.parentElement.removeChild(lensView);
        });
    },

    newView: function(partName, modelId, parentId){
        let model = this.partsById[modelId];
        if(!model || model == undefined){
            throw new Error(`System does not know part ${partName}[${modelId}]`);
        }
        if(!partName){
            partName = model.type;
        }

        // Find the parent model id. This will
        // help us find the parent view element for
        // appending the new element.
        if (!parentId){
            parentId = model._owner.id;
        }
        let parentElement = this.findViewById(parentId);
        if(!parentElement){
            throw new Error(`Could not find parent element for ${partName}[${modelId}] (model owner id: ${model._owner.id})`);
        }

        // Create the new view instance,
        // append to parent, and set the model
        let newView = document.createElement(
            this.tagNameForViewNamed(partName)
        );
        newView.setModel(model);
        this.sendMessage({
            type: "viewChanged",
            changeName: "subpart-new",
            args: [newView]
        }, model._owner, parentElement);

        // Dispatch a CustomEvent on the parentElement
        // indicating that this part has been created, and
        // any view utilities that care can be notified.
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: model.type,
                partId: model.id,
                ownerId: model._owner.id || null
            } 
        });
        parentElement.dispatchEvent(event);

        // See if there are lens views and update
        // those as well
        let lensViews = this.findLensViewsById(parentId);
        lensViews.forEach(lensView => {
            let newLensView = document.createElement(
                this.tagNameForViewNamed(partName)
            );
            newLensView.setModel(model);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', modelId);
            newLensView.setAttribute('role', 'lens');
            lensView.appendChild(newLensView);
        });

        // TODO do we want to allow the possibiliy of a view on an
        // element but no subpart of that view on the element?

        // For all subparts of this model, call
        // the newView method recursively
        model.subparts.forEach(subpart => {
            this.newView(subpart.type, subpart.id);
        });

        return newView;
    },

    registerPart: function(name, cls){
        this.availableParts[name] = cls;
    },

    registerView: function(name, cls){
        this.availableViews[name] = cls;
    },

    tagNameForViewNamed: function(name){
        return `st-${name}`;
    },

    // Find the first matching view element
    // with the given id
    findViewById: function(id){
        return document.querySelector(`[part-id="${id}"]`);
    },

    findLensViewsById: function(id){
        return Array.from(document.querySelectorAll(`[lens-part-id="${id}"]`));
    },

    // Find all matching view elements with
    // the given part id
    findViewsById: function(id){
        return document.querySelectorAll(`[part-id="${id}"]`);
    },

    // return the model corresponding to the current stack
    getCurrentStackModel: function(){
        let world = this.getWorldStackModel();
        return world.currentStack;
    },

    // return the model corresponding to the current card
    getCurrentCardModel: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.currentCard;
    },

    // return the model corresponding to the world stack
    getWorldStackModel: function(){
        return this.partsById['world'];
    },

    // return the model corresponding script editor st-field
    // Note: we use the window.model.target to locate the corresponding window
    // but return its st-field subpart
    findScriptEditorByTargetId: function(id){
        let scriptEditorField;
        let windows = document.querySelectorAll("st-window");
        windows.forEach((w) => {
            let target = w.model.target;
            if(target && target.id === id){
                scriptEditorField = w.querySelector("st-field");
            }
        });
        return scriptEditorField;
    },

    serialize: function(){
        let world = this.partsById['world'];
        if(!world){
            throw new Error(`No world found!`);
        }
        let serializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STSerializer"](this);
        let serialString = serializer.serialize(this.partsById['world'], true);

        // If there is not a script tag in the
        // body for the serialization, create it
        let serializationScriptEl = document.getElementById('serialization');
        if(!serializationScriptEl){
            serializationScriptEl = document.createElement('script');
            serializationScriptEl.id = 'serialization';
            serializationScriptEl.type = 'application/json';
            document.body.append(serializationScriptEl);
        }
        serializationScriptEl.textContent = serialString;
    },

    deserialize: function(){
        let serializationEl = document.getElementById('serialization');
        if(!serializationEl){
            throw new Error(`No serialization found for this page`);
        }
        this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
        return this._deserializer.deserialize(serializationEl.textContent);
    },

    // Return a *complete* HTML
    // representation of the current application
    // that can later be saved to a file
    getFullHTMLString: function(){
        let clonedDocument = document.cloneNode(true);
        let world = clonedDocument.querySelector('st-world');
        let nav = clonedDocument.querySelector('st-navigator');
        if(world){
            world.remove();
        }
        if(nav){
            nav.remove();
        }

        return clonedDocument.documentElement.outerHTML;
    },


    /** Navigation of Current World **/
    goToNextStack: function(){
        let world = this.partsById['world'];
        return world.goToNextStack();
    },

    goToPrevStack: function(){
        let world = this.partsById['world'];
        return world.goToPrevStack();
    },

    goToStackById: function(stackId){
        let world = this.partsById['world'];
        return world.goToStackById(stackId);
    },

    /** Navigation of Current Stack **/
    goToNextCard: function(){
        let currentStack = this.getCurrentStackModel(); 
        return currentStack.goToNextCard();
    },

    goToPrevCard: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToPrevCard();
    },

    goToCardById: function(cardId){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToCardById(cardId);
    },

    openEditorForPart: function(partId){
        this.editor.render(
            this.partsById[partId]
        );
        this.editor.open();
    },

    closeEditorForPart: function(partId){
        this.editor.close();
    }
};

/** Add Default System Command Handlers **/
//System._commandHandlers['deleteModel'] = System.deleteModel;
System._commandHandlers['deleteModel'] = function(senders, ...rest){
    System.deleteModel(...rest);
};
//System._commandHandlers['newModel'] = System.newModel;
System._commandHandlers['newModel'] = function(senders, ...rest){
    System.newModel(...rest);
    this.serialize();
};
//System._commandHandlers['newView'] = System.newView;
System._commandHandlers['newView'] = function(senders, ...rest){
    System.newView(...rest);
};
System._commandHandlers['newProperty'] = System.newProperty;
System._commandHandlers['setProperty'] = System.setProperty;
System._commandHandlers['deleteProperty'] = System.deleteProperty;

System._commandHandlers['ask'] = function(senders, question){
    // Use the native JS prompt function to ask the question
    // and return its value.
    // By returning here, we expect the implicit variable
    // "it" to be set inside any calling script
    return prompt(question);
};

System._commandHandlers['putInto'] = function(senders, value, variableName, global){
    if(global){
        System.executionStack.setGlobal(variableName, value);
        return;
    }
    // Because we push all handlers onto the execution stack,
    // the putInto handler is currently at the top of the stack.
    // In order to modify the caller's variables, we need to
    // find the context that is one previous on the stack
    if(System.executionStack.previous){
        System.executionStack.previous.setLocal(variableName, value);
    } else {
        throw new Error(`ExecutionStack Error: #putInto on top of empty stack!`);
    }
};

System._commandHandlers['answer'] = function(senders, value){
    alert(value.toString());
};

System._commandHandlers['go to direction'] = function(senders, directive, objectName){
    switch(objectName) {
        case 'card':
            switch(directive){
                case 'next':
                    this.goToNextCard();
                    break;

                case 'previous':
                    this.goToPrevCard();
                    break;
            }
            break;

        case 'stack':
            switch(directive){
                case 'next':
                    this.goToNextStack();
                    break;

                case 'previous':
                    this.goToPrevStack();
                    break;
            }
            break;

        default:
            alert(`"go to" not implemented for ${objectName}`);

    }
};

System._commandHandlers['go to'] = function(senders, id){
    let model = this.partsById[id];
    if(!model){
        alert(`"go to" target not found`);
    }
    switch(model.type) {
    case 'card':
        this.goToCardById(id);
        break;

    case 'stack':
        this.goToStackById(id);
        break;

    default:
        alert(`"go to" not implemented for ${model.type}`);

    }
};

System._commandHandlers['go to website'] = function(senders, url){
    window.location.href = url;
};

//Import a world, i.e. its stacks from another source
System._commandHandlers['importWorld'] = function(sender, sourceUrl){
    if(!sourceUrl){
        sourceUrl = window.prompt("Choose World location");
    }
    fetch(sourceUrl)
        .then(response => {
            let contentType = response.headers.get('content-type');
            if(!contentType.startsWith('text/html')){
                throw new Error(`Invalid content type: ${contentType}`);
            }
            return response.blob().then(blob => {
                let reader = new FileReader();
                reader.readAsText(blob);
                reader.onloadend = () => {
                    let parsedDocument = DOMparser.parseFromString(reader.result, "text/html");
                    // there is no .getElementById() for a node HTML parsed document!
                    let serializationEl = parsedDocument.querySelector('#serialization');
                    if(!serializationEl){
                        console.log(`No serialization found for ${sourceUrl}`);
                        alert(`World "${sourceUrl}" not found`);
                        return;
                    }
                    this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
                    this._deserializer.targetId = 'world'; // We will insert the stacks into the world
                    return this._deserializer.importFromSerialization(
                        serializationEl.textContent,
                        (part) => {
                            // Return only Stacks that are direct subparts
                            // of the world.
                            let isStack = part.type == 'stack';
                            let isWorldSubpart = part._owner && part._owner.type == 'world';
                            return isStack && isWorldSubpart;
                        }
                    );
                };
            });
        })
        .then(() => {
            // Manually set the _src.
            // This ensures that we don't infinitely
            // call the load operation
            this._src = sourceUrl;
            /*
            // Stop and restart hand interface if it's running.
            if (handInterface.handDetectionRunning) {
                handInterface.stop();
                handInterface.start();
            }
            */
        })
        .catch(err => {
            alert("Could not load world");
            console.error(err);
        });
};

System._commandHandlers['openScriptEditor'] = function(senders, targetId){
    let target = this.partsById[targetId];
    let targetName = target.partProperties.getPropertyNamed(target, "name");
    if(targetName){
        targetName = `"${targetName}"`;
    }
    let name = `Script For ${target.name} ${targetName}`;

    // If there is already a dinwo opened with this name, then
    // we return without creating anything new.
    let found = Object.values(System.partsById).filter(part => {
        let partName;
        if(part.type == 'window'){
            partName = part.partProperties.getPropertyNamed(
                part,
                'title'
            );
        }
        return (part.type == 'window' && name == partName);
    });
    if(found.length){
        return;
    }

    let currentCard = this.getCurrentCardModel();
    let window = this.newModel('window', currentCard.id);
    let area = this.newModel('area', window.id);
    let scriptField = this.newModel('field', area.id);
    let saveButton = this.newModel('button', area.id);


    // setup the window and stack properties
    window.setTarget(target);
    window.partProperties.setPropertyNamed(window, "title", name);
    window.partProperties.setPropertyNamed(window, "height", 200);
    window.partProperties.setPropertyNamed(window, "width", 500);
    window.partProperties.setPropertyNamed(window, 'top', 100);
    window.partProperties.setPropertyNamed(window, 'left', 100);

    area.partProperties.setPropertyNamed(area, "layout", "list");
    area.partProperties.setPropertyNamed(area, "list-direction", "column");
    area.partProperties.setPropertyNamed(area, "width", "fill");
    area.partProperties.setPropertyNamed(area, "height", "fill");

    // script field
    let targetScript = target.partProperties.getPropertyNamed(target, "script"); 
    scriptField.partProperties.setPropertyNamed(scriptField, "text", targetScript);
    scriptField.partProperties.setPropertyNamed(scriptField, "height", "fill");
    scriptField.partProperties.setPropertyNamed(scriptField, "width", "fill");

    // Setup syntax highlight
    scriptField.sendMessage({
        type: "command",
        commandName: "highlightSyntax",
        args: []
    }, scriptField);


    // setup up the save button properties
    saveButton.partProperties.setPropertyNamed(saveButton, "name", "Save Script");
    saveButton.partProperties.setPropertyNamed(saveButton, "width", "fill");
    saveButton.partProperties.setPropertyNamed(saveButton, "text-size", 20);
    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);

    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);
    let saveScript = `on click\n\ttell target to set "script" to the "text" of first field\nend click`; 
    saveButton.partProperties.setPropertyNamed(saveButton, "script", saveScript);
};

System._commandHandlers['SimpleTalk'] = function(senders){
    return System.grammar.source.sourceString;
}

System._commandHandlers['openDebugger'] = function(senders, partId){
    let target = this.partsById[partId];
    // Create the Field model and attach to current card
    let currentCard = this.getCurrentCardModel();
    let fieldModel = this.newModel('field', currentCard.id);
    let text = `Available Commands for ${target.name} (id ${target.id})\n\n`;
    Object.keys(target.commandHandlerRegistry).forEach((name) =>{
        let info = target.commandHandlerRegistry[name];
        text += `${name}: ${JSON.stringify(info)}\n`;
    });
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'text',
        text
    );
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'editable',
        false
    );
};

System._commandHandlers['saveHTML'] = function(senders){
    // Stop hand recognition if it's running.
    let handRecognitionOriginallyRunning = _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionRunning;
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
    this.serialize();

    let stamp = Date.now().toString();
    let serializedPage = this.getFullHTMLString();
    let typeInfo = "data:text/plain;charset=utf-8";
    let url = `${typeInfo},${encodeURIComponent(serializedPage)}`;

    let anchor = document.createElement('a');
    anchor.style.display = "none";
    document.body.append(anchor);
    anchor.href = url;
    anchor.download = `SimpleTalkSnapshot_${stamp}.html`;
    anchor.click();
    window.URL.revokeObjectURL(url);
    anchor.parentElement.removeChild(anchor);
    // Start hand recognition if it was running.
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    }
};

System._commandHandlers['tell'] = (senders, targetId, deferredMessage) => {
    let targetPart = System.partsById[targetId];
    if(!targetPart){
        throw new Error(`Attempted to tell part id ${targetId}: no such part!`);
    }
    targetPart.sendMessage(deferredMessage, targetPart);
};

System._commandHandlers['toggleHandDetection'] = () => {
    if (_utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionModel === null) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    } else {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
};

System._commandHandlers['merriam'] = (senders, docId) => {
    const sender = System.partsById[senders[0].id];
    Object(_utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__["default"])(sender, docId);
};

System._commandHandlers['globalInterrupt'] = () => {
    // cycle through all the parts and set the "stepping" property to false
    Object.values(System.partsById).forEach((part) => {
        if(part.isStepping){
            part.partProperties.setPropertyNamed(part, "stepping", false);
        }
    });
};


/** Register the initial set of parts in the system **/
System.registerPart('card', _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
System.registerPart('stack', _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('button', _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
System.registerPart('world', _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
System.registerPart('window', _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('drawing', _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
System.registerPart('image', _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
System.registerPart('area', _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
System.registerPart('audio', _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
System.registerPart('browser', _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
System.registerPart('resource', _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/** Register the initial set of views in the system **/
System.registerView('button', _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
System.registerView('stack', _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
System.registerView('world', _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
System.registerView('card', _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__["default"]);
System.registerView('window', _views_WindowView__WEBPACK_IMPORTED_MODULE_16__["default"]);
System.registerView('field', _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__["default"]);
System.registerView('drawing', _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__["default"]);
System.registerView('image', _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__["default"]);
System.registerView('area', _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__["default"]);
System.registerView('audio', _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__["default"]);
System.registerView('browser', _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__["default"]);
System.registerView('resource', _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__["default"]);


// Convenience method for adding all of the
// available custom elements to the window object's
// customElements registry
System.registerCustomElements = function(){
    Object.keys(System.availableViews).forEach(partName => {
        let viewClass = System.availableViews[partName];
        let elementName = System.tagNameForViewNamed(partName);
        window.customElements.define(elementName, viewClass);
    });
};

// iniitalize the compiler and add it to the system
// Instantiate the grammar.
let languageGrammar;
if (window.grammar){
    // for testing it is sometimes convenient to load the grammar and add to window
    // see ./tests/preload.js for example
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammar(window.grammar);
} else {
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammarFromScriptElement();
}

System.grammar = languageGrammar;

// Set the exection stack on the
// System
System.executionStack = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ExecutionStack"]();

// Add a dynamic getter for the World for convenience
Object.defineProperty(System, 'world', {
    get: function(){
        return this.partsById['world'];
    }
});

document.addEventListener('DOMContentLoaded', () => {
    // Add the System object to window so
    // that it is global on the page. We do this
    // for both debugging and testing.
    window.System = System;
    // Add the possible views as webcomponents
    // in the custom element registry
    System.registerCustomElements();

    // Add any other non-part view CustomElements,
    // like the halo
    window.customElements.define('st-halo', _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__["default"]);
    window.customElements.define('st-navigator', _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__["default"]);
    window.customElements.define('st-editor', _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__["default"]);

    // Add nav
    System.navigator = document.createElement('st-navigator');
    document.body.appendChild(System.navigator);

    // Add comprehensive editor pane
    // if one is not already present in the markup
    let existingEditors = Array.from(document.querySelectorAll('st-editor'));
    existingEditors.forEach(editorEl => {
        editorEl.remove();
    });
    System.editor = document.createElement('st-editor');
    document.body.appendChild(System.editor);

    // Perform the initial setup of
    // the system
    System.initialLoad();
});

// add a message listener on window
// these can include message from a browser part
// for now filter those not coming from the origin
window.addEventListener("message", (event) => {
    if (event.origin !== window.origin)
        return;
    console.log(`Message to browser`);
    // TODO: maybe we need to deal with quote escapes directly
    // in the grammar
    let script = event.data.replaceAll("'", '"');
    // only statements are accepted for now
    let parsedScript = languageGrammar.match(script, "Statement");
    if(parsedScript.failed()){
        // for now just log that it failed
        console.log("failed to parse script for browser");
    } else {
        let semantics = languageGrammar.createSemantics();
        let world = System.partsById["world"];
        semantics.addOperation(
            'interpret',
            Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(world, System)
        );
        let msg = semantics(parsedScript).interpret();
        System.sendMessage(msg, world, System);
    }
});

// global interrupt
document.addEventListener('keydown', (event) => {
    if(event.ctrlKey && event.key == 'c'){
        System.sendMessage({
            type: "command",
            commandName: "globalInterrupt",
            args: []
        }, System, System);
    }
});





/***/ }),

/***/ "./js/objects/parts/Area.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Area.js ***!
  \**********************************/
/*! exports provided: Area, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Area", function() { return Area; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Area; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Area
 * ----------------------------------
 * I am a Area Part.
 * I represent a 'grouping' of subparts within
 * my owner part.
 * I contain the Layout properties set, and therefore
 * can display my contained subparts according to 
 * different layout properties than my ancestor
 * Card.
 *
 */



const sides = ["top", "bottom", "left", "right"];

class Area extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(...args){
        super(...args);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
            "browser",
            "window"
        ];

        // Add style props
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addLayoutStyleProps"])(this);

        // Set default width and height
        // for an empty area
        this.partProperties.setPropertyNamed(
            this,
            'width',
            50
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            50
        );
        this.partProperties.newBasicProp(
            'clipping',
            false
        );
        this.partProperties.newBasicProp(
            'allow-scrolling',
            false
        );
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
    }


    get type(){
        return 'area';
    }
};




/***/ }),

/***/ "./js/objects/parts/Audio.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Audio.js ***!
  \***********************************/
/*! exports provided: Audio, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Audio; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Audio extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadAudioFromSource", this.loadAudioFromSource);
        this.setPrivateCommandHandler("play", () => {this.play(true);});
        this.setPrivateCommandHandler("pause", () => {this.play(false);});
        this.setPrivateCommandHandler("stop", this.stop);

        // Bind component methods
        this.loadAudioFromSource = this.loadAudioFromSource.bind(this);
        this.play = this.play.bind(this);
        this.stop = this.stop.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'audio';
    }

    loadAudioFromSource(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    play(value){
        this.partProperties.setPropertyNamed(this, "play", value);
        this.partProperties.setPropertyNamed(this, "stop", false);
    }

    stop(){
        this.partProperties.setPropertyNamed(this, "play", false);
        this.partProperties.setPropertyNamed(this, "stop", true);
    }
};




/***/ }),

/***/ "./js/objects/parts/Browser.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Browser.js ***!
  \*************************************/
/*! exports provided: Browser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Browser", function() { return Browser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Browser; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Browser extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;
        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("setURLTo", this.setURL);
        this.setPrivateCommandHandler("forward", this.sendMessageToBrowser);

        // Bind component methods
        this.setURL = this.setURL.bind(this);
        this.sendMessageToBrowser = this.sendMessageToBrowser.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                5
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );
    }

    get type(){
        return 'browser';
    }

    setURL(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    sendMessageToBrowser(senders, message){
        let views = window.System.findViewsById(this.id);
        views.forEach((v) => {
            let iframe = v._shadowRoot.querySelector("iframe");
            iframe.contentWindow.postMessage(message, window.origin);
        });
    }
};




/***/ }),

/***/ "./js/objects/parts/Button.js":
/*!************************************!*\
  !*** ./js/objects/parts/Button.js ***!
  \************************************/
/*! exports provided: Button, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Button; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Button
 * ----------------------------------
 * I am a Button Part.
 * My owner is always a Card.
 * I am a clickable point of interaction on a Card,
 * whose functionality can be customized by the author.
 */




class Button extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner){
        super(owner);

        this.isButton = true;

        // Add Button-specific part properties
        this.partProperties.newDynamicProp(
            'selectedText',
            null, // readOnly (for now)
            this.getSelectedText,
            true, // readOnly,
        );

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 234, 149)", // var(--palette-yellow)
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-top-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-bottom-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-left-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-right-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-left',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-top',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );

    }

    get type(){
        return 'button';
    }

    //TODO: implement this property
    // getter for real
    getSelectedText(propName, propVal){
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Card.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Card.js ***!
  \**********************************/
/*! exports provided: Card, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Card", function() { return Card; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Card; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Card
 * --------------------------
 * I am a Card Part.
 * I represent a collection of Parts that is
 * displayed on the screen. My owner is always
 * a Stack Part.
 * I can contain any kind of Part, including
 * buttons and fields.
 */





class Card extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, name){
        super(owner);
        this.stack = this._owner;
        this.acceptedSubpartTypes = [
            "window", "button",
            "field", "area", "drawing",
            "image", "audio", "browser", "resource"
        ];
        this.isCard = true;

        // Add Card-specific part
        // properties
        this.partProperties.newBasicProp(
            'marked',
            false
        );
        this.partProperties.newBasicProp(
            'cantDelete',
            false
        );
        this.partProperties.newBasicProp(
            'dontSearch',
            false
        );
        this.partProperties.newBasicProp(
            'showPict',
            false
        );

        // If we are initializing with a name
        // set the name property
        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addLayoutStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(0, 75, 103)" // palette-blue
        );
    }

    get type(){
        return 'card';
    }
};




/***/ }),

/***/ "./js/objects/parts/Drawing.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Drawing.js ***!
  \*************************************/
/*! exports provided: Drawing, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Drawing", function() { return Drawing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Drawing; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Basic User Drawing Part
 */



const sides = ["top", "bottom", "left", "right"];

class Drawing extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner){
        super(owner);

        // Set new properties for this
        // part type
        this.partProperties.newBasicProp(
            'image',
            null
        );
        this.partProperties.newBasicProp(
            'mode',
            'drawing'
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)", //grey
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            'width',
            300
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            200
        );

        // We are using a distinct show-border
        // property to deal with being able to see
        // a drawing that is empty
        this.partProperties.newBasicProp(
            'show-border',
            true
        );

        // When drawing from a script/commands,
        // we will use this as the open canvas
        // whose image bytes will be set to the
        // image property
        this.activeCanvas = null;

        // Set up the drawing commands
        this.setupDrawingCommands();


        // Bind component methods
        this.setupDrawingCommands = this.setupDrawingCommands.bind(this);
        this.stroke = this.stroke.bind(this);
        this.moveTo = this.moveTo.bind(this);
        this.lineTo = this.lineTo.bind(this);
        this.beginDraw = this.beginDraw.bind(this);
        this.endDraw = this.endDraw.bind(this);
        this.clear = this.clear.bind(this);
        this.coordsFromString = this.coordsFromString.bind(this);
    }

    get type(){
        return 'drawing';
    }

    setupDrawingCommands(){
        this.setPrivateCommandHandler('lineTo', (senders, ...args) => {
            this.lineTo(...args);
        });
        this.setPrivateCommandHandler('moveTo', (senders, ...args) => {
            this.moveTo(...args);
        });
        this.setPrivateCommandHandler('beginDraw', (senders, ...args) => {
            this.beginDraw(...args);
        });
        this.setPrivateCommandHandler('finishDraw', (senders, ...args) => {
            this.endDraw(...args);
        });
        this.setPrivateCommandHandler('stroke', (senders, ...args) => {
            this.stroke(...args);
        });
        this.setPrivateCommandHandler('clear', (senders, ...args) => {
            this.clear(...args);
        });
    }

    /* Scriptable Drawing Commands */
    stroke(){
        if(this.isDrawing){
            // Hard-coded. Get from props
            // and link to views
            this.activeContext.strokeWidth = 10;
            this.activeContext.stroke();
        }
    }
    moveTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.moveTo(
                x,
                y
            );
        }
    }

    lineTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.lineTo(
                x,
                y
            );
        }
    }

    beginDraw(){
        if(this.isDrawing){
            return;
        }
        this.isDrawing = true;
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');

        // If there is currently image data set to the
        // image part property, we need to draw that image
        // onto the canvas first.
        let currentImage = this.partProperties.getPropertyNamed(
            this,
            'image'
        );
        if(currentImage){
            let img = new Image();
            img.onload = () => {
                this.activeContext.drawImage(img, 0, 0);
            };
            img.src = currentImage;
        }

        // Begin a drawing path
        this.activeContext.beginPath();
    }

    endDraw(){
        if(this.isDrawing){
            this.activeContext.closePath();
            this.activeContext.stroke();

            // Update the image property to be the
            // serialized version of the current image.
            // This will update any subscribed views
            this.partProperties.setPropertyNamed(
                this,
                'image',
                this.activeCanvas.toDataURL()
            );
            this.activeCanvas = null;
            this.activeContext = null;
            this.isDrawing = false;
        }
    }

    clear(){
        if(this.isDrawing){
            return;
        }
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');
        this.partProperties.setPropertyNamed(
            this,
            'image',
            this.activeCanvas.toDataURL()
        );
        this.activeCanvas = null;
        this.activeContext = null;
    }

    /* Utility Methods for Scriptable Drawing */
    coordsFromString(coordString){
        let pair = coordString.split(",");
        let x = parseInt(pair[0]);
        let y = parseInt(pair[1]);
        return {x, y};
    }
};




/***/ }),

/***/ "./js/objects/parts/Field.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Field.js ***!
  \***********************************/
/*! exports provided: Field, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return Field; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Field
 * -----------------------------------------
 * I am a Field Part.
 * I am a container that holds text. I also allow
 * a user to edit my text.
 */





const sides = ["top", "bottom", "left", "right"];

class Field extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name){
        super(owner);

        this.acceptedSubpartTypes = ["field"];

        this.isField = true;

        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Set the Field-specific
        // Part Properties
        this.partProperties.newBasicProp(
            'mode',
            'editing' //TODO this should be either "bravo" or "simpletalk"
        );

        this.partProperties.newBasicProp(
            'innerHTML',
            ''
        );

        this.partProperties.newBasicProp(
            'targetRangeId',
            null
        );

        // 'text' is a DynamicProperty configured to also set the innerHTML
        // BasicProperty when changed. The basic idea is that 'text' will be
        // the property that ST will interface with and everytime it
        // is changed the 'innerHTML' property should follow.
        this.partProperties.newDynamicProp(
            'text',
            (owner, prop, value, notify) => {
                prop._value = value;
                if(notify){
                    /*
                    if(!value){
                        value = "<br>";
                    }
                    // replace all newline characters with <br>
                    value = value.replace(/\n/g, "<br>");
                    */
                    owner.partProperties.setPropertyNamed(owner, 'innerHTML', value, notify);
                }
            },
            (owner, prop) => {
                return prop._value;
            },
            false, // not read only
            ''     // default is empty string
        );

        this.partProperties.newBasicProp(
            'editable',
            true
        );


        // A number of the props deal with direct text editing,
        // and so they are like commands. Examples include "undo"
        // "redo" "clear" etc. Here we use dynami props which the
        // view can respond to accordingly, but having these props have
        // no actual 'state'
        /** TODO: these should be private commands
        this.partProperties.newDynamicProp(
            "undo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "redo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "remove-format",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        **/

        // Styling
        // setting width and height to null
        // effectively forces to the default size
        // of the button to fit the button name
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 248, 220)", // var(--palette-cornsik)
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "medium",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-style`,
                "solid",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "black",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "1",
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );

        // Private command handlers

        this.insertRange = this.insertRange.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.setPrivateCommandHandler("insertRange", this.insertRange);
        this.setPrivateCommandHandler("setSelection", this.setSelection);
        this.setPrivateCommandHandler("highlightSyntax", this.highlightSyntax);
        this.setPrivateCommandHandler("unhighlightSyntax", this.unhighlightSyntax);
    }

    insertRange(senders, rangeId, html, css){
        window.System.findViewsById(this.id).forEach((view) => {
            view.insertRange(rangeId, html, css);
        });
    }

    setSelection(senders, propertyName, propertyValue){
        // for now just allow properties of type "text-*" to be set
        if(propertyName.startsWith("text-")){
            window.System.findViewsById(this.id).forEach((view) => {
                view.setSelection(propertyName, propertyValue);
            });
        }
    }

    highlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.highlightSyntax();
        }
    }

    unhighlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.unhighlightSyntax();
        }
    }

    get type(){
        return 'field';
    }
};




/***/ }),

/***/ "./js/objects/parts/Image.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Image.js ***!
  \***********************************/
/*! exports provided: Image, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return Image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Image; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");




class Image extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newDynamicProp(
            "src",
            this.setSource,
            this.getSource
        );

        this._src = src;

        this.partProperties.newBasicProp(
            "mimeType",
            "unknown"
        );

        this.partProperties.newBasicProp(
            "imageData",
            null
        );

        this.partProperties.newBasicProp(
            'draggable',
            false
        );

        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "black"
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadImageFrom", this.loadImageFromSource);
        this.setPrivateCommandHandler("loadImageFromFile", this.loadImageFromFile);

        // Bind component methods
        this.loadImageFromSource = this.loadImageFromSource.bind(this);
        this.loadImageFromFile = this.loadImageFromFile.bind(this);
    }


    loadImageFromSource(senders, sourceUrl){
        fetch(sourceUrl)
            .then(response => {
                let contentType = response.headers.get('content-type');
                if(!contentType.startsWith('image')){
                    throw new Error(`Invalid image mimeType: ${contentType}`);
                }
                this.partProperties.setPropertyNamed(
                    this,
                    "mimeType",
                    contentType
                );
                if(contentType.startsWith("image/svg")){
                    return response.text().then(text => {
                        this.partProperties.setPropertyNamed(
                            this,
                            'imageData',
                            text
                        );
                    });
                } else {
                    return response.blob().then(blob => {
                        let reader = new FileReader();
                        reader.onloadend = () => {
                            this.partProperties.setPropertyNamed(
                                this,
                                'imageData',
                                reader.result // will be the base64 encoded data
                            );
                        };
                        reader.readAsDataURL(blob);
                    });
                }
            })
            .then(() => {
                // Manually set the _src.
                // This ensures that we don't infinitely
                // call the load operation
                this._src = sourceUrl;
            })
            .catch(err => {
                console.error(err);
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    null
                );
            });
    }

    loadImageFromFile(){
        let filePicker = document.createElement('input');
        filePicker.type = 'file';
        filePicker.setAttribute('accept', 'image/*');
        filePicker.style.display = 'none';
        filePicker.addEventListener('change', (event) => {
            // Handle the file here
            let reader = new FileReader();
            reader.onloadend = () => {
                this.partProperties.setPropertyNamed(
                    this,
                    'mimeType',
                    filePicker.files[0].type
                );
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    reader.result
                );
            };
            let imageFile = filePicker.files[0];
            if(imageFile.type.includes('svg')){
                reader.readAsText(imageFile);
            } else {
                reader.readAsDataURL(imageFile);
            }
            filePicker.remove();
        });
        document.body.append(filePicker);
        filePicker.click();
    }

    setSource(owner, property, value){
        owner._src = value;
        if(value){
            owner.loadImageFromSource([this], value);
        }
    }

    getSource(owner, property){
        return owner._src;
    }

    get type(){
        return 'image';
    }

    get isSvg(){
        let mimeType = this.partProperties.getPropertyNamed(
            this,
            "mimeType"
        );
        if(!mimeType){
            return false;
        }

        return mimeType.startsWith('image/svg');
    }
};




/***/ }),

/***/ "./js/objects/parts/Part.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Part.js ***!
  \**********************************/
/*! exports provided: Part, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Part", function() { return Part; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Part; });
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/errorHandler.js */ "./js/objects/utils/errorHandler.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/**
 * Part
 * -------------------------------
 * I represent the prototype object for all
 * SimpleTalk parts.
 */







class Part {
    constructor(anOwnerPart, name, deserializing=false){

        this.name = this.constructor.name;

        // An array of child parts
        this.subparts = [];
        // a list of all accepted subparts by type
        // By default this is null and each Part subclcass should
        // specify if otherwise
        this.acceptedSubpartTypes = [];

        this.partProperties = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["PartProperties"]();
        this._owner = anOwnerPart;
        this._commandHandlers = {};
        this._privateCommandHandlers = {};
        this._functionHandlers = {};
        this._scriptSemantics = {};
        this._propertySubscribers = new Set();
        this._viewSubscribers = new Set();
        this._stepIntervalId = null;

        this.isPart = true;

        // Bind methods
        this.setupProperties = this.setupProperties.bind(this);
        this.setupStyleProperties = this.setupStyleProperties.bind(this);

        this.addPart = this.addPart.bind(this);
        this.removePart = this.removePart.bind(this);
        this.acceptsSubpart = this.acceptsSubpart.bind(this);
        this.setPrivateCommandHandler = this.setPrivateCommandHandler.bind(this);
        this.removePrivateCommandHandler = this.removePrivateCommandHandler.bind(this);
        this.setFuncHandler = this.setFuncHandler.bind(this);
        this.receiveCmd = this.receiveCmd.bind(this);
        this.receiveFunc = this.receiveFunc.bind(this);
        this.receiveError = this.receiveError.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.delegateMessage = this.delegateMessage.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.addPropertySubscriber = this.addPropertySubscriber.bind(this);
        this.removePropertySubscriber = this.removePropertySubscriber.bind(this);
        this.addViewSubscriber = this.addViewSubscriber.bind(this);
        this.removeViewSubscriber = this.removeViewSubscriber.bind(this);
        this.serialize = this.serialize.bind(this);
        this.toJSON = this.toJSON.bind(this);
        this.setPropsFromDeserializer = this.setPropsFromDeserializer.bind(this);
        this.findAncestorOfType = this.findAncestorOfType.bind(this);
        this.openEditorCmdHandler = this.openEditorCmdHandler.bind(this);
        this.closeEditorCmdHandler = this.closeEditorCmdHandler.bind(this);
        this.copyCmdHandler = this.copyCmdHandler.bind(this);
        this.pasteCmdHandler = this.pasteCmdHandler.bind(this);
        this.isSubpartOfCurrentCard = this.isSubpartOfCurrentCard.bind(this);
        this.isSubpartOfCurrentStack = this.isSubpartOfCurrentStack.bind(this);
        this.getOwnerBranch = this.getOwnerBranch.bind(this);
        this.startStepping = this.startStepping.bind(this);
        this.stopStepping = this.stopStepping.bind(this);
        this.setTargetProp = this.setTargetProp.bind(this);
        this.move = this.move.bind(this);
        this.moveSubpartUp = this.moveSubpartUp.bind(this);
        this.moveSubpartDown = this.moveSubpartDown.bind(this);
        this.moveSubpartToFirst = this.moveSubpartToFirst.bind(this);
        this.moveSubpartToLast = this.moveSubpartToLast.bind(this);



        // Finally, we finish initialization
        this.setupProperties();

        // command handlers
        this.setPrivateCommandHandler("openEditor", this.openEditorCmdHandler);
        this.setPrivateCommandHandler("closeEditor", this.closeEditorCmdHandler);
        this.setPrivateCommandHandler("setTargetTo", this.setTargetProp);
        this.setPrivateCommandHandler("copy", this.copyCmdHandler);
        this.setPrivateCommandHandler("paste", this.pasteCmdHandler);
        this.setPrivateCommandHandler("move", this.move);
        this.setPrivateCommandHandler("moveUp", () => {this._owner.moveSubpartUp(this);});
        this.setPrivateCommandHandler("moveDown", () => {this._owner.moveSubpartDown(this);});
        this.setPrivateCommandHandler("moveToFirst", () => {this._owner.moveSubpartToFirst(this);});
        this.setPrivateCommandHandler("moveToLast", () => {this._owner.moveSubpartToLast(this);});
    }

    // Convenience getter to get the id
    // from the partProperties
    get id(){
        return this.partProperties.getPropertyNamed(this, 'id');
    }

    set id(val){
        return this.partProperties.setPropertyNamed(this, 'id', val);
    }


    // Return an array of names of all of my and my ancestors' handlers
    // for the moment this is just names, type, id and whether the handler overrides
    // an owner's, but could be richer info, such as arguments, documentation etc
    get commandHandlerRegistry(){
        let handlersInfo = {};
        let ownerBranch = this.getOwnerBranch();
        for(let i = 1; i <= ownerBranch.length; i++){
            let part = ownerBranch[ownerBranch.length - i];
            let partType = part.type;
            if(part.id === -1){
                partType = "System";
            } else {
                // System doesn't have private command handlers
                Object.keys(part._privateCommandHandlers).forEach((h) => {
                    let override = false;
                    if(handlersInfo[h]){
                        override = true;
                    }
                    handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: true};
                });
            }
            Object.keys(part._commandHandlers).forEach((h) => {
                let override = false;
                if(handlersInfo[h]){
                    override = true;
                }
                handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: false};
            });
        }
        return handlersInfo;
    }

    // returns the this.part -> System branch by part id
    getOwnerBranch(branch){
        if(!branch){
            branch = [this];
        }
        if(this.type === "world"){
            branch.push(window.System);
            return branch;
        } else {
            branch.push(this._owner);
        };
        return this._owner.getOwnerBranch(branch);
    }

    // Configures the specific properties that the
    // given part can expect, along with any default
    // values.
    // Descendant Parts should override this method
    // in their own constructor after calling super,
    // so that they get the parent's general properties
    // too.
    setupProperties(){
        // Here, we set up properties common
        // to ALL Parts in the system.
        let basicProps = [
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'target',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'contents',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'enabled',
                true
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'wants-move',
                false
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'id',
                _utils_id_js__WEBPACK_IMPORTED_MODULE_0__["idMaker"].new()
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'name',
                `New ${this.type}`
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'rectangle',
                "0, 0, 0, 0",
                true,
                ['rect']
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'script',
                null // For now
            ),

            // Styling
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssStyle',
                {},
                false,
            ),
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssTextStyle',
                {},
                false,
            )
        ];
        basicProps.forEach(prop => {
            this.partProperties.addProperty(prop);
        });

        // the index number of the part in part._owner.subpart
        // array. Note: this is 1-indexed
        this.partProperties.newDynamicProp(
            'number',
            null, // no setter
            function(propOwner, propObject){
                if(propOwner.type == "world"){
                    return 1;
                }
                return propOwner._owner.subparts.indexOf(propOwner) + 1;
            },
            true // readonly
        );

        this.partProperties.newDynamicProp(
            'target',
            function(propOwner, propObject, val){
                // check to see if the target is a non-ID
                let id = Object(_utils_id_js__WEBPACK_IMPORTED_MODULE_0__["isValidId"])(val);
                if(id){
                    // if it is an ID insert "part" since our
                    // grammar doesn't handle ID without system object
                    // prefixes
                    propObject._value = `part id ${val}`;
                } else {
                    propObject._value = val;
                }
            },
            function(propOwner, propObject){
                return propObject._value;
            },
            false,
            null,
        ),

        // Custom Properties store props defined within the
        // ST environment
        this.partProperties.newCustomProp(
        ),

        // Stepping related props

        this.partProperties.newDynamicProp(
            // The time in milliseconds between
            // sends of the step command if the
            // stepping property is set to true
            'stepTime',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(propOwner.isStepping){
                    // Interrupt the current interval
                    // and restart with new stepTime
                    propOwner.stopStepping();
                    this._value = value;
                    propOwner.startStepping();
                } else{
                    this._value = value;
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                return this._value;
            },
            false, // can read and write
            500 // Default to half a second
        );

        this.partProperties.newDynamicProp(
            'stepping',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(value === false && propOwner.isStepping){
                    propOwner.stopStepping();
                } else if(value === true && !propOwner.isStepping){
                    propOwner.startStepping();
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                // If the intervalId is set, then
                // the Part is currently stepping
                return propOwner.isStepping;
            },
        );

    }

    // To be called in each sub-class that has StyleProperties
    // called after the style props are configured
    setupStyleProperties(){
        this.partProperties._properties.forEach((prop) => {
            if(prop.constructor.name === "StyleProperty"){
                // setting the value on itself ensures that the cssStyle
                // BasicProperty is updated with the appropriate styler
                // conversion css key-val
                prop.setValue(this, prop._value);
            }
        });
    }

    /** Subpart Access **/
    /**
     * Each subclass will implement its own set of checks,
     * and throw an approprite error if the subpart type is invalid.
     */
    acceptsSubpart(aPartType){
        if (this.acceptedSubpartTypes[0] === "*"){
            return true;
        }
        return this.acceptedSubpartTypes.includes(aPartType.toLowerCase());
    }

    /**
     * Adds a part to this part's subparts
     * collection, if not already present.
     * It will also set the owner of the
     * added part to be this part.
     */
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            this.subparts.push(aPart);
            aPart._owner = this;
        }
    }

    /**
     * Removes the given part from this
     * part's list of subparts (if present).
     * It will also unset the owner of the
     * given part.
     */
    removePart(aPart){
        let partIndex = this.subparts.indexOf(aPart);
        if(partIndex >= 0){
            this.subparts.splice(partIndex, 1);
            aPart._owner = null;
        }
    }

    /** Checks whether the Part instance is a subpart of the current
     * Card.
     */
    isSubpartOfCurrentCard(){
    }

    /** Checks whether the Part instance is a subpart of the current
     * Stack.
     */
    isSubpartOfCurrentStack(){
    }

    /** Logging and Reporting **/
    shouldBeImplemented(functionName){
        let msg = `${this.constructor.name} should implement ${functionName}`;
        throw new Error(msg);
    }

    /** Message Handling and Delegation **/
    delegateMessage(aMessage){
        return this.sendMessage(
            aMessage,
            this._owner
        );
    }

    sendMessage(aMessage, target){
        return window.System.sendMessage(aMessage, this, target);
    }

    receiveMessage(aMessage){
        // By default, Parts will only handle
        // messages of type 'command' and 'function'
        switch(aMessage.type){
            case 'command':
                return this.receiveCmd(aMessage);
                //break;
            case 'function':
                return this.receiveFunc(aMessage);
                //break;
            case 'error':
                return this.receiveError(aMessage);
            default:
                return this.delegateMessage(aMessage);
        }
    }

    receiveError(aMessage){
        return _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].handle(aMessage);
    }

    receiveCmd(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = handler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        let privateHandler = this._privateCommandHandlers[aMessage.commandName];
        if(privateHandler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = privateHandler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        // Otherwise, we have no handler for
        // it. Unless the message indicates shouldNotDelegate
        // we delegate along the
        // message delegation chain. It is up
        // to Parts to properly implement delegation
        // for themselves!
        if(aMessage.shouldNotDelegate){
            return aMessage;
        }
        return this.delegateMessage(aMessage);
    }

    receiveFunc(aMessage){
        let handler = this._functionHandlers[aMessage.functionName];

        if(handler){
            let boundHandler = handler.bind(this);
            return boundHandler();
        } else {
            return this.delegateMessage(aMessage);
        }
    }

    setPrivateCommandHandler(commandName, handler){
        this._privateCommandHandlers[commandName] = handler;
    }

    removePrivateCommandHandler(commandName){
        delete this._privateCommandHandlers[commandName];
    }

    setFuncHandler(funcName, handler){
        this._functionHandlers[funcName] = handler;
    }

    /** Command Handlers
        ----------------
        Command handlers which are invoked at the Part level
        which are not immediately delegaed to the Part._owner
    **/

    openEditorCmdHandler(){
        let editor = document.querySelector('st-editor');
        editor.render(this);
        if(!editor.isOpen){
            editor.open();
        }
    }

    closeEditorCmdHandler(){
        let editor = document.querySelector('st-editor.open');
        if(editor){
            editor.close();
        }
    }

    setTargetProp(senders, ...args){
        let target = args.join(" ");
        this.partProperties.setPropertyNamed(this, "target", target);
    }

    copyCmdHandler(){
        window.System.clipboard.copyPart(this);
    }

    pasteCmdHandler(){
        if(!window.System.clipboard.isEmpty){
            let item = window.System.clipboard.contents[0];
            if(item.type == 'simpletalk/json' && this.acceptsSubpart(item.partType)){
                window.System.clipboard.pasteContentsInto(this);
            }
        }
    }

    move(senders, movementX, movementY){
        if(!this.partProperties.getPropertyNamed(this, "wants-move")){
            throw Error(`Part ${this.id} trying to move with 'wants-move' property false`);
        }
        let top = this.partProperties.getPropertyNamed(this, "top");
        top += movementY;
        this.partProperties.setPropertyNamed(this, "top", top);
        let left = this.partProperties.getPropertyNamed(this, "left");
        left += movementX;
        this.partProperties.setPropertyNamed(this, "left", left);
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex < this.subparts.length - 1){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex > 0){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    // Note: moveSubpartToFirst means move to first in the view
    // i.e. last as a subaprt
    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, 0);
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, this.subparts.length - 1);
    }

    /** Property Subscribers
        ------------------------
        Objects added as property subscribers
        will be 'notified' whenever one of this
        Part's properties changes
    **/
    addPropertySubscriber(anObject){
        this._propertySubscribers.add(anObject);
    }

    removePropertySubscriber(anObject){
        this._propertySubscribers.delete(anObject);
    }

    propertyChanged(propertyName, newValue){
        let message = {
            type: 'propertyChanged',
            propertyName: propertyName,
            value: newValue,
            partId: this.id
        };
        this._propertySubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    /** View Subscribers
        ------------------------
        Objects added as view subscribers
        will be 'notified' whenever this Part
        incurrs a view change (add, delete subparts, reorder etc)
    **/
    addViewSubscriber(anObject){
        this._viewSubscribers.add(anObject);
    }

    removeViewSubscriber(anObject){
        this._viewSubscribers.delete(anObject);
    }

    viewChanged(changeName, ...args){
        let message = {
            type: 'viewChanged',
            changeName: changeName,
            partId: this.id,
            args: args
        };
        this._viewSubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpart = this.subparts.splice(currentIndex, 1)[0];
        this.subparts.splice(newIndex, 0, subpart);
        this.viewChanged("subpart-order", id, currentIndex, newIndex);
    }

    startStepping(){
        if(this._stepIntervalId){
            this.stopStepping();
        }
        let stepTime = this.partProperties.getPropertyNamed(
            this,
            'stepTime'
        );
        if(stepTime > 0){
            this._stepIntervalId = setInterval(() => {
                this.sendMessage({
                    type: 'command',
                    commandName: 'step',
                    args: []
                }, this);
            }, stepTime);
        }
    }

    stopStepping(){
        clearInterval(this._stepIntervalId);
        this._stepIntervalId = null;
    }

    get isStepping(){
        // We know the Part is currently stepping
        // of the stored intervalId is set to
        // something besides null
        return this._stepIntervalId !== null;
    }

    /**
     * Serialize this Part's state as JSON.
     * By default, we do not serialize specific
     * PartCollection information (recursively),
     * and only include basics including the current
     * state of all properties.
     */
    serialize(){
        let ownerId = null;
        if(this._owner){
            ownerId = this._owner.id;
        }
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: ownerId
        };
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    /**
     * Set the properties and other
     * attributes of this Part model
     * from a deserialized JSON object.
     */
    setPropsFromDeserializer(incomingProps, deserializer){
        Object.keys(incomingProps).forEach(propName => {
            let property = this.partProperties.findPropertyNamed(propName);
            if(!property){
                // If some old or invalid property is
                // present in the deserialization, simply provide
                // a warning and then skip this one.
                console.warn(`Deserialized property "${propName}" is not a valid property name for ${this.type} (id ${this.id}) and will be ignored`);
            } else if(propName == "custom-properties"){
                // custom properties are serialized as an object like other props
                // and we need to create properties from these and set their respective
                // values. Then we need to set the value of "custom-properties" prop
                // itself to be the object containing all of these
                let customPropsData = incomingProps[propName];
                let newCustomPropsObject = {};
                Object.values(customPropsData).forEach((propData) => {
                    let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](propData.name, null);
                    newProp.setValue(this, propData._value, false); // no need to notify
                    newCustomPropsObject[propData.name] = newProp;
                });
                property.setValue(this, newCustomPropsObject, false); // no need to notify
            } else if(!property.readOnly){
                // Last arg is false, which tells the property
                // not to notify its owner's subscribers of
                // property changes. We don't need that when
                // deserializing
                property.setValue(this, incomingProps[propName], false);
            }
        });
    }

    toJSON(){
        return this.serialize();
    }

    findAncestorOfType(aPartType){
        let owner = this._owner;
        while(owner){
            if(owner.type == aPartType){
                return owner;
            }
            owner = owner._owner;
        }
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Resource.js":
/*!**************************************!*\
  !*** ./js/objects/parts/Resource.js ***!
  \**************************************/
/*! exports provided: Resource, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return Resource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Resource; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Resource extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);
        this.resource = null;

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "notReady"
        );

        this.partProperties.newBasicProp(
            "prerequisite",
            null
        );

        this.partProperties.newBasicProp(
            "resourceName",
            null
        );

        this.partProperties.newBasicProp(
            "response",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadResource", this.loadResource);
        this.setPrivateCommandHandler("setSourceTo", this.setSourceTo);
        this.setPrivateCommandHandler("get", this.get);

        // Bind component methods
        this.loadResource = this.loadResource.bind(this);
        this.get = this.get.bind(this);
        this.reset = this.reset.bind(this);

        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'resource';
    }

    loadResource(senders, resourceName){
        if(!window.System.availableResources || !window.System.availableResources[resourceName]){
            // TODO this should be a ST error
            throw Error(`resource ${resourceName} not found`);
        }
        this.resource = window.System.availableResources[resourceName];
        this.partProperties.setPropertyNamed(this, "resourceName", resourceName);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();
    }

    setSourceTo(senders, sourceUrl){
        if(!this.resource){
            // TODO this should be a ST error
            throw Error(`no resource loaded for resource part id ${this.id}`);
        }
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
        this.resource.load(sourceUrl);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();

    }

    get(senders, ...args){
        this.partProperties.setPropertyNamed(this, "readyState", "fetching");
        let prerequisite = this.partProperties.getPropertyNamed(this, "prerequisite");
        this.resource.get(prerequisite, ...args).then((response) => {
            this.partProperties.setPropertyNamed(this, "response", response);
            this.partProperties.setPropertyNamed(this, "readyState", "ready");
            this.sendMessage({
                type: "command",
                commandName: "responded",
                args: [this.id, this.resource.name],
                shouldIgnore: true
            }, this);
        }, (error) => {
            this.partProperties.setPropertyNamed(this, "readyState", "error");
            this.partProperties.setPropertyNamed(this, "response", null);
            this.sendMessage({
                type: "command",
                commandName: "errored",
                args: [this.id, this.resource.name, error.message],
                shouldIgnore: true
            }, this);
        });
    }

    reset(){
        this.partProperties.setPropertyNamed(this, "readyState", "notReady");
        this.partProperties.setPropertyNamed(this, "response", null);
    }
};




/***/ }),

/***/ "./js/objects/parts/Stack.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Stack.js ***!
  \***********************************/
/*! exports provided: Stack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Card_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/**
 * Stack
 * ----------------------------
 * I am the Stack Part.
 * I represent a collection of Card parts,
 * along with some extra configurability.
 */




class Stack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, deserializing=false){
        super(owner);
        this.acceptedSubpartTypes = [
            "card", "window", "button", "area", "field",
            "drawing", "image", "audio", "browser"
        ];

        // Set up Stack specific
        // PartProperties
        this.partProperties.newBasicProp(
            'cantPeek',
            false
        );
        this.partProperties.newBasicProp(
            'resizable',
            false
        );


        // Will hold the card-based index,
        // which here is zero-indexed, of the
        // card that is the current card for this
        // Stack.
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Bind general methods
        this.sendOpenCardTo = this.sendOpenCardTo.bind(this);
        this.sendCloseCardTo = this.sendCloseCardTo.bind(this);

        // Bind stack navigation methods
        this.goToNextCard = this.goToNextCard.bind(this);
        this.goToPrevCard = this.goToPrevCard.bind(this);
        this.goToCardById = this.goToCardById.bind(this);
        this.goToNthCard = this.goToNthCard.bind(this);
    }

    goToNextCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= cards.length){
            nextIdx = (nextIdx % cards.length);
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToCardById(anId){
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let cards = Object.values(window.System.partsById).filter((part) => {
            return part.type == "card";
        });
        let nextCard = cards.find(card => {
            return card.id == anId;
        });
        if(!nextCard){
            throw new Error(`The card id: ${anId} cant be found stack`);
        }
        // if the card is not on this stack we should go to the corresponding stack
        if(nextCard._owner != this){
            this._owner.goToStackById(nextCard._owner.id);
        }
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToPrevCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);

        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = cards.length + nextIdx;
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToNthCard(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(trueIndex < 0 || trueIndex > cards.length -1){
            console.warn(`Cannot navigate to card number ${anIndex} -- out of bounds`);
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let nextCard = cards[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
           nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    sendCloseCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    sendOpenCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    get type(){
        return 'stack';
    }

    get currentCardId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentCard(){
        return window.System.partsById[this.currentCardId];
    }

    // override the base class methods
    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a card then append after the last card
            if(aPart.type == "card"){
                let allCards = this.subparts.filter((part) => {
                    return part.type == "card";
                });
                this.subparts.splice(allCards.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }
};




/***/ }),

/***/ "./js/objects/parts/Window.js":
/*!************************************!*\
  !*** ./js/objects/parts/Window.js ***!
  \************************************/
/*! exports provided: Window, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Window", function() { return Window; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Window; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Window Part
 * ------------------------
 * A Window is a Part that wraps another
 * Part of type Card, Stack, or WorldStack
 * in a moveable window.
 * I can also optionally hold a reference
 * to a target Part that I do not own. I call
 * this JS property target and I store the
 * target part's id as a HyperTalk property
 * called targetId.
 * When my owner part is the current view, I
 * will be visible on top of everything else.
 */




class Window extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, target, deserializing=false){
        super(owner, name);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
        ];

        // If we pass in a target,
        // set it.
        if(target){
            this.setTarget(target);
        }

        // Set up Window specific
        // part ptoperties
        this.partProperties.newBasicProp(
            'targetId',
            null
        );

        this.partProperties.newBasicProp(
            'title',
            "New Window Title"
        );

        this.partProperties.newBasicProp(
            'isResizable',
            true
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );

        // Bind methods
        this.setTarget = this.setTarget.bind(this);
        this.onWindowClose = this.onWindowClose.bind(this);

        // Add private handlers
        this.setPrivateCommandHandler('windowClose', this.onWindowClose);
    }

    setTarget(aPart){
        this.target = aPart;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            this.target.id
        );
    }

    unsetTarget(){
        this.target = null;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            null
        );
    }

    /**
     * Override
     * Unlike other kinds of Parts, a window
     * has only one subpart, which should be
     * Card, Stack, or WorldStack.
     */
    addPart(aPart){
        let isValid = this.acceptsSubpart(aPart.type);
        if(!isValid){
            // Consider replacing this generic exception
            // with a message based approach that sends
            // these sorts of non-fatal errors to System
            // as a kind of message. This way we can display
            // errors in SimpltTalk objects.
            throw new Error(`Windows cannot wrap parts of type ${aPart.type}`);
        }
        this.subparts.forEach(subpart => {
            this.removePart(subpart);
        });
        this.subparts.push(aPart);
        aPart._owner = this;
    }

    onWindowClose(senders, ...args){
        // Default behavior is to delete
        // the window model from the System.
        // Scripts can override this handler
        this.sendMessage(
            {
                type: 'command',
                commandName: 'deleteModel',
                args: [ this.id ]
            },
            window.System
        );
    }

    get type(){
        return 'window';
    }
}




/***/ }),

/***/ "./js/objects/parts/WorldStack.js":
/*!****************************************!*\
  !*** ./js/objects/parts/WorldStack.js ***!
  \****************************************/
/*! exports provided: WorldStack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldStack", function() { return WorldStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldStack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/**
 * WorldStack
 * ---------------------------------------------------
 * I am a Stack part that represents the root of a
 * hierarchy of parts. I am the end of the ownership
 * chain for any given configuration of Parts.
 * I am also the final resolver of all unhandled
 * messages sent along the delegation chain for parts.
 * All parts can eventually resolve to me via the delegation
 * chain or ownership hierarchy.
 * There should only be one instance of me in any given
 * SimpleTalk environment.
 */



class WorldStack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super(null);

        this.acceptedSubpartTypes = ["stack", "image"];

        this.isWorld = true;

        // This property specifies the stack
        // id of the current stack
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Set the id property to always
        // be 'world'
        this.id = 'world';

        // Bind general methods
        this.sendOpenStackTo = this.sendOpenStackTo.bind(this);
        this.sendCloseStackTo = this.sendCloseStackTo.bind(this);

        // Bind navigation methods
        this.goToNextStack = this.goToNextStack.bind(this);
        this.goToPrevStack = this.goToPrevStack.bind(this);
        this.goToNthStack = this.goToNthStack.bind(this);
        this.goToStackById = this.goToStackById.bind(this);

        // remove command handlers which are not needed for world
        this.removePrivateCommandHandler("moveUp");
        this.removePrivateCommandHandler("moveDown");
        this.removePrivateCommandHandler("moveToFirst");
        this.removePrivateCommandHandler("moveToLast");
    }

    goToNextStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= stacks.length){
            nextIdx = (nextIdx % stacks.length);
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToStackById(anId){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        let nextStack = stacks.find(stack => {
            return stack.id == anId;
        });
        if(!nextStack){
            throw new Error(`The stack id: ${anId} cant be found on this stack`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToPrevStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = stacks.length + nextIdx;
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToNthStack(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(trueIndex < 0 || trueIndex > stacks.length -1){
            throw new Error(`Cannot navigate to stack number ${anIndex} -- out of bounds`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let nextStack = stacks[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    sendCloseStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'closeStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    sendOpenStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command', 
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    get type(){
        return 'world';
    }

    get loadedStacks(){
        return this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
    }

    // Override normal Part serialization.
    // Here we need to also include an array of ids of
    // loaded stacks and the id of the current stack
    serialize(){
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: null,
            loadedStacks: (this.loadedStacks.map(stack => {
                return stack.id;
            })),
        };

        // Serialize current part properties
        // values
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    // Override for delegation.
    // We send any messages that should be delegated
    // to the global System object, which has any
    // 'handlers of last resort'
    delegateMessage(aMessage){
        return this.sendMessage(aMessage, window.System);
    }

    get currentStackId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentStack(){
        return window.System.partsById[this.currentStackId];
    }

    // override the base class methods
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a stack then append after the last stack
            if(aPart.type == "stack"){
                let allStacks = this.subparts.filter((part) => {
                    return part.type == "stack";
                });
                this.subparts.splice(allStacks.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

};




/***/ }),

/***/ "./js/objects/properties/PartProperties.js":
/*!*************************************************!*\
  !*** ./js/objects/properties/PartProperties.js ***!
  \*************************************************/
/*! exports provided: PartProperties, BasicProperty, CustomProperty, DynamicProperty, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartProperties", function() { return PartProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicProperty", function() { return BasicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomProperty", function() { return CustomProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicProperty", function() { return DynamicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartProperties; });
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");


/**
 * PartProperties
 * ------------------------------------
 * I am an object representing the base
 * Part Properties for all Parts.
 * I also include some convenience methods
 * on my prototype that should be used by
 * other Parts when they inherit from me.
 * For now, we use Object.create() for inheritance.
 */

class BasicProperty {
    constructor(name, defaultValue, readOnly=false, aliases=[]){
        this.name = name;
        this._value = defaultValue;
        this.readOnly = readOnly;
        this.aliases = aliases;

        // Bound methods
        this.getValue = this.getValue.bind(this);
        this.setValue = this.setValue.bind(this);
        this.hasAlias = this.hasAlias.bind(this);
        this.matches = this.matches.bind(this);
        this.matchesNameOrAlias = this.matchesNameOrAlias.bind(this);
    }

    // For basic properties, we return
    // the set/stored value
    getValue(owner){
        return this._value;
    }

    // For the basic properties, we set
    // based on the incoming desired value
    // alone (nothing is computed)
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }

    // Returns true if this property
    // goes by the given alias
    hasAlias(anAlias){
        return this.aliases.includes(anAlias);
    }

    // Returns true if the given name is
    // either an alias or the exact name
    // for this property
    matchesNameOrAlias(aNameOrAlias){
        if(this.hasAlias(aNameOrAlias)){
            return true;
        } else if(aNameOrAlias == this.name){
            return true;
        }
        return false;
    }

    // Returns true if the incoming Property
    // has the same name and/or one of the same
    // aliases as this Property
    matches(aProperty){
        if(aProperty.name == this.name){
            return true;
        } else {
            for(let i = 0; i < this.aliases.length; i++){
                let myAlias = this.aliases[i];
                if(aProperty.hasAlias(myAlias)){
                    return true;
                }
            }
        }
        return false;
    }
};


/** Custom Properties are similar to dynamic props, except that
  * under the hood they store an object of properties
  * storing props defined within the ST environment. The find()
  * add() delete() methods find, add, or remove properties from the
  * this.customProperties object.
 **/
class CustomProperty extends BasicProperty {
    constructor(name="custom-properties", defaultValue={}, readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly=false, aliases);
    }

    find(name){
        let prop = this._value[name];
        if(prop){
            return prop;
        }
        return null;
    }

    add(aProperty){
        // NOTE: aliases are completed ignored for now
        if(!this.find(aProperty.name)){
            this._value[aProperty.name] = aProperty;
        }
    }

    delete(aProperty){
        delete this._value[aProperty.name];
    }



};

class DynamicProperty extends BasicProperty {
    constructor(name, setter, getter, readOnly=false, defaultValue=null, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.valueSetter = setter;
        this.valueGetter = getter;
    }

    // In this override, we use the getter
    // if available, to dynamically get the
    // incoming value.
    getValue(owner){
        return this.valueGetter(owner, this);
    }

    // In this override, we use the setter
    // if available, to dynamically set the
    // incoming value
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this.valueSetter(owner, this, val, notify);
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};


/** I am a special property which handles interfacing with the
  * the cssStyle basic property. Whenever I am updated I make
  * sure to update the cssStyle property via the styler utility
  * function. I can be used to create different and indepent
  * styling options.
  **/
class StyleProperty extends BasicProperty {
    constructor(name, defaultValue,  propName='cssStyle', styler=_utils_styler_js__WEBPACK_IMPORTED_MODULE_0__["default"], readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.propName = propName;
        this.styler = styler;
    }

    // In this override, we update the cssStyle property
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            let styleProperty = owner.partProperties.findPropertyNamed(this.propName);
            let style = styleProperty.getValue(owner);
            let newStyle = this.styler(style, this.name, val);
            styleProperty.setValue(owner, newStyle, notify);

            // set my value as well
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};

class PartProperties {
    constructor(){
        this._properties = [];

        // Bound methods
        this.hasProperty = this.hasProperty.bind(this);
        this.addProperty = this.addProperty.bind(this);
        this.removeProperty = this.removeProperty.bind(this);
        this.findPropertyNamed = this.findPropertyNamed.bind(this);
        this.setPropertyNamed = this.setPropertyNamed.bind(this);
        this.getPropertyNamed = this.getPropertyNamed.bind(this);
        this.newBasicProp = this.newBasicProp.bind(this);
        this.newStyleProp = this.newStyleProp.bind(this);
        this.newDynamicProp = this.newDynamicProp.bind(this);
        this._indexOfProperty = this._indexOfProperty.bind(this);
    }

    get all(){
        return this._properties;
    }

    // This collection 'has' a property if it contains
    // a Property object with matching name or alias
    // of the incoming property.
    hasProperty(aProperty){
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return true;
            }
        }
        return false;
    }

    // Find one of my Properties by
    // a name or alias. Returns null
    // if no match found. Perhaps we should
    // throw an error
    findPropertyNamed(aName){
        let found = null;
        let customPropertiesProp;
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(prop.matchesNameOrAlias(aName)){
                found = prop;
            }
            // grab the custom properties prop, as we might need it
            // for later
            if(prop.matchesNameOrAlias("custom-properties")){
                customPropertiesProp = prop;
            }
        }
        // see if the property is custom
        if(!found && customPropertiesProp){
            found = customPropertiesProp.find(aName);
        }
        return found;
    }

    // Attempts to get the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    getPropertyNamed(owner, aName){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.getValue(owner);
    }

    // Attempts to set the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    setPropertyNamed(owner, aName, aValue, notify=true){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.setValue(owner, aValue, notify);
    }

    // If you add a property with a name or alias
    // that is already present in the collection,
    // then we 'overwrite' it by removing the exising
    // property and replacing it with the incoming one.
    // Otherwise, we just add the property
    addProperty(aProperty){
        if(this.hasProperty(aProperty)){
            this.removeProperty(aProperty);
        }
        this._properties.push(aProperty);
    }

    // Removing a property here means removing
    // it from the stored array. If the property
    // is not in the array, we do NOT throw an error.
    // We just go on with our lives, because who cares?
    removeProperty(aProperty){
        let propIndex = this._indexOfProperty(aProperty);
        if(propIndex >= 0){
            this._properties.splice(propIndex, 1);
        }
    }

    // Convenience method for creating a new basic
    // property.
    newBasicProp(...args){
        let newProp = new BasicProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new custom
    // property.
    newCustomProp(...args){
        let newProp = new CustomProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new style
    // property.
    newStyleProp(...args){
        let newProp = new StyleProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new
    // dynamic prop
    newDynamicProp(...args){
        let newProp = new DynamicProperty(...args);
        this.addProperty(newProp);
    }

    // Private method. Finds the first occurring
    // index of the given Property in the array
    // of properties in this collection. Returns
    // -1 if not found, per JS implementation.
    _indexOfProperty(aProperty){
        for(let i = 0; this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return i;
            }
        }
        return -1;
    }
};




/***/ }),

/***/ "./js/objects/utils/AltSyntaxHighlighter.js":
/*!**************************************************!*\
  !*** ./js/objects/utils/AltSyntaxHighlighter.js ***!
  \**************************************************/
/*! exports provided: createHighlighter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHighlighter", function() { return createHighlighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createHighlighter; });
/** Second pass at syntax highlighter semantics **/
const syntaxSpan = (ruleName) => {
    let span = document.createElement('span');
    span.classList.add('st-syntax');
    span.setAttribute('data-st-rule', ruleName);
    return span;
}

const createHighlighter = (fieldElement) => {
    return {
        MessageHandlerOpen: function(literalOn, messageName, optionalParamList){
            let span = syntaxSpan("MessageHandlerOpen");
            let onSpan = syntaxSpan("keyword");
            onSpan.append("on ");
            span.append(onSpan);

            // Append sub-rules
            span.append(messageName.highlightSyntax());
            span.append(...optionalParamList.highlightSyntax());

            return span;
        },

        MessageHandlerClose(literalEnd, messageName){
            let span = syntaxSpan("MessageHandlerClose");
            let endSpan = syntaxSpan("keyword");
            endSpan.append("end ");
            span.append(endSpan);

            // Add the parts
            span.append(messageName.highlightSyntax());

            return span;
        },

        ParameterList: function(paramString){
            let outer = syntaxSpan("ParameterList");
            let innerItems = paramString.asIteration().children.map(paramName => {
                let span = syntaxSpan("ParameterList-item");
                span.append(paramName.sourceString);
                return span.outerHTML;
            });
            outer.innerHTML = innerItems.join(", ");
            return outer;
            
        },

        messageName: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'messageName');
            span.append(string.sourceString + " ");
            return span;
        },

        keyword: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'keyword');
            span.append(string.sourceString);
            return span;
        }
    };
};




/***/ }),

/***/ "./js/objects/utils/clipboard.js":
/*!***************************************!*\
  !*** ./js/objects/utils/clipboard.js ***!
  \***************************************/
/*! exports provided: STClipboard, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STClipboard", function() { return STClipboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STClipboard; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _serialization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serialization.js */ "./js/objects/utils/serialization.js");
/**
 * Utilities for Clipboard Functionality
 * ------------------------------------------
 * For the moment we use a very primitive stand-in
 * since the Clipboard API is not standardized across
 * browser implementations.
 **/



class STClipboard {
    constructor(aSystem){
        this.system = aSystem;
        this.contents = [];

        // Bound methods
        this.copyPart = this.copyPart.bind(this);
        this.pasteContentsInto = this.pasteContentsInto.bind(this);
        this._createLensedChildren = this._createLensedChildren.bind(this);
    }

    copyPart(aPart){
        let serializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STSerializer"](this.system);
        let rootSerialization = serializer.serialize(aPart, false);
        let item = new STClipboardItem(
            'simpletalk/json',
            rootSerialization,
            aPart.type
        );
        this.contents = [item];
    }

    pasteContentsInto(aTargetPart){
        let promises = this.contents.map(clipboardContent => {
            let serializedContent = clipboardContent.data;
            let deserializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STDeserializer"](this.system);
            deserializer.targetId = aTargetPart.id;
            return deserializer.deserialize(serializedContent)
                .then(() => {
                    // Reset the top and left values to that
                    // the pasted part doesn't run outside of the new
                    // relative bounds in which it has been pasted
                    let newPart = deserializer.rootParts[0];
                    let hasTop = newPart.partProperties.findPropertyNamed('top');
                    let hasLeft = newPart.partProperties.findPropertyNamed('left');
                    if(hasTop){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'top',
                            10
                        );
                    }
                    if(hasLeft){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'left',
                            10
                        );
                    }
                    
                    // Open Halo on the new view
                    deserializer.rootViews[0].openHalo();

                    // Dispatch the CustomEvent that notifies listeners
                    // that a new view was added (used by Nav etc)
                    let event = new CustomEvent('st-view-added', {
                        detail: {
                            partType: newPart.type,
                            partId: newPart.id,
                            ownerId: newPart._owner.id
                        }
                    });
                    deserializer.rootViews[0].dispatchEvent(event);

                    // Add any lensed views that might be needed
                    let rootLensViews = this.system.findLensViewsById(newPart._owner.id);
                    rootLensViews.forEach(lensView => {
                        let newLensView = document.createElement(
                            this.system.tagNameForViewNamed(newPart.type)
                        );
                        newLensView.setModel(newPart);
                        newLensView.removeAttribute('part-id');
                        newLensView.setAttribute('lens-part-id', newPart.id);
                        newLensView.setAttribute('role', 'lens');
                        lensView.appendChild(newLensView);
                        this._createLensedChildren(newLensView, newPart.subparts);
                    });
                    
                    return;
                })
                .catch(err => {
                    throw err;
                });
        });
        return Promise.all(promises);
    }

    _createLensedChildren(aLensView, subparts){
        subparts.forEach(subpart => {
            let newLensView = document.createElement(
                this.system.tagNameForViewNamed(subpart.type)
            );
            newLensView.setModel(subpart);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', subpart.id);
            newLensView.setAttribute('role', 'lens');
            aLensView.appendChild(newLensView);
            this._createLensedChildren(newLensView, subpart.subparts);
        });
    }
    
    get isEmpty(){
        return this.contents.length <= 0;
    }
}

class STClipboardItem {
    constructor(mimeType, data, partType){
        if(mimeType){
            this.type = mimeType;
        }
        if(partType){
            this._partType = partType;
        }
        if(data){
            this.data = data;
        }
    }

    get partType(){
        if(this.type == 'simpletalk/json'){
            return this._partType;
        }
        return null;
    }

    set partType(val){
        this._partType = val;
    }
};




/***/ }),

/***/ "./js/objects/utils/errorHandler.js":
/*!******************************************!*\
  !*** ./js/objects/utils/errorHandler.js ***!
  \******************************************/
/*! exports provided: errorHandler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorHandler", function() { return errorHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return errorHandler; });
/**
 * Error Handler
 * ------------------------------------
 * I am responsible for handler all
 * System-wide errors
 */

const errorHandler = {

    handle: function(aMessage){
        switch(aMessage.name){
            case 'GrammarMatchError':
                return this.handleGrammarMatchError(aMessage);
            case 'MessageNotUnderstood':
                return this.handleMessageNotUnderstood(aMessage);
            default:
                // if I don't know what to do with this message
                // I send it along to the System
                return window.System.receiveMessage(aMessage);
        }
    },

    handleGrammarMatchError: function(aMessage){
        // TODO is there a more structured way to get this out of ohm?
        let regex = /Line (?<line>\d), col (?<column>\d)/;
        let match = aMessage.parsedScript.message.match(regex);
        let errorLineNum = parseInt(match.groups["line"]) - 1; // ohm lines start with 1 
        // see if the grammar rule has been identified
        let ruleName;
        let rightMostFailures = aMessage.parsedScript.getRightmostFailures();
        if(rightMostFailures[1]){
            ruleName = rightMostFailures[1].pexpr.ruleName;
        }
        // get some more info about what the parser expected
        let expectedText = aMessage.parsedScript.getExpectedText();
        // get the original script
        let text = aMessage.parsedScript.input;
        let textLines = text.split("\n");
        // replace said text line with an error marker
        textLines[errorLineNum] += ` --<<<[Expected:${expectedText}; ruleName: "${ruleName}"]`;
        text = textLines.join("\n");
        // if the first message in the parsed script is "doIt" then the statementLines are
        // located in the corresponding field text, not the script, property and
        // we want the error to be marked up in the field textarea
        if(aMessage.parsedScript.input.startsWith("on doIt")){
            let originalSenderModel = window.System.partsById[aMessage.partId];
            // we need to get the original text so as not to completely replace it
            // then insert the markup in the appropriate line
            let fieldText = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, "text");
            let script = aMessage.parsedScript.input;
            script = this._cleanDoItSCript(script);
            // we don't want the "doIt" handler inserted back in, since it's just a hidden wrapper for the
            // statement lines
            text = this._cleanDoItSCript(text);
            fieldText = fieldText.replace(script, text);
            originalSenderModel.partProperties.setPropertyNamed(originalSenderModel, "text", fieldText);
        } else {
            // first locate the script editor in question
            let scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            if(!scriptEditor){
                this._openScriptEditor(aMessage.partId);
                scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            }
            scriptEditor.model.partProperties.setPropertyNamed(scriptEditor.model, "text", text);
        }
        // open the grammar if there is not one open already
        let currentCard = window.System.getCurrentCardModel();
        let grammar = currentCard.subparts.filter((part) => {
            return (part.type == "field") && (part.partProperties.getPropertyNamed(part, "name") == "SimpleTalk");
        });
        if(grammar.length == 0){
            this._openGrammar(aMessage.partId, ruleName);
        }
    },

    handleMessageNotUnderstood(aMessage){
        let offendingMessage = aMessage.message;
        let originalSender = offendingMessage.senders[0];
        // Are we ever going to have MNU errors on messages that
        // are not type: command?
        if(offendingMessage.type === "command"){
            let commandName = offendingMessage.commandName;
            let originalSenderModel = window.System.partsById[originalSender.id];
            let regex = new RegExp(`\\s*${commandName}(\s|\n|$)`, 'g');
            let text;
            let target;
            let executionStack = window.System.executionStack._stack;
            // if the first message in the execution stack is "doIt" then the statementLines are
            // located in the corresponding field text, not the script, property and
            // we want the error to be marked up in the field textarea
            if(executionStack[0] && executionStack[0].messageName == "doIt"){
                target = executionStack[0].part;
                text = target.partProperties.getPropertyNamed(originalSenderModel, 'text');
            } else {
                text = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, 'script');
                let scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                if(!scriptEditor){
                    this._openScriptEditor(originalSender.id);
                    scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                }
                if(scriptEditor){
                    target = scriptEditor.model;
                }
            }
            // TODO Sort this out
            if(target){
                let textLines = text.split("\n");
                // offending command text line with an error marker
                for(let i = 0; i < textLines.length; i++){
                    let line = textLines[i];
                    if(line.match(regex)){
                        textLines[i] = line += ` --<<<[MessageNotUnderstood: command; commandName: "${commandName}"]`;
                    }
                }
                text = textLines.join("\n");
                target.partProperties.setPropertyNamed(target, "text", text);

            }
            // finally open the debugger (or current version thereof)
            // NOTE: this is a bit dangerous, b/c if the System doesn't
            // handle the `openDebugger` command anywhere it will throw
            // a MNU error, which will then invoke this handler cuasing
            // an infinite loop!
            this._openDebugger(originalSender.id);
        }
    },

    _cleanDoItSCript(script){
        // clean up the DoIt script by removing the handler
        // newlines, tabs and spaces
        script = script.replace("on doIt", "");
        script = script.replace("end doIt", "");
        script = script.replace(/^[\n\t ]+/, "");
        script = script.replace(/[\n\t ]+$/, "");
        return script;
    },

    _openScriptEditor: function(partId){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openScriptEditor",
            args: [partId]
        };
        target.sendMessage(msg, target);
    },

    _openGrammar: function(partId, ruleName){
        let target = window.System.partsById[partId];
        let statementLines = [
            'if there is not a field "SimpleTalk" of current card',
            'then',
            'add field "SimpleTalk" to current card',
            'tell field "SimpleTalk" of current card to set "editable" to false',
            'SimpleTalk',
            'tell field "SimpleTalk"of current card to set "text" to it',
            'end if'
        ];
        let script = `on doIt\n   ${statementLines.join('\n')}\nend doIt`;
        target.sendMessage(
            {
                type: "compile",
                codeString: script,
                targetId: target.id
            },
            target
        );
        target.sendMessage(
            {
                type: "command",
                commandName: "doIt",
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            },
            target
        );
    },

    // At the moment this simply opens a st-window st-field with
    // information about the available commands for said parts
    _openDebugger: function(partId){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openDebugger",
            args: [partId]
        };
        target.sendMessage(msg, target);
    }
};




/***/ }),

/***/ "./js/objects/utils/handInterface.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/handInterface.js ***!
  \*******************************************/
/*! exports provided: Testables, handInterface, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Testables", function() { return Testables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handInterface", function() { return handInterface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return handInterface; });
const video = document.createElement('video');
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

const scaleDim = (dim) => {
    const scale = 0.7;
    const stride = 16;
    const evenRes = dim * scale - 1;
    return evenRes - (evenRes % stride) + 1;
};

const detectHands = async () => {
    if (!handInterface.handDetectionRunning) {
        return;
    }
    const scaledWidth = scaleDim(canvas.width);
    const scaledHeight = scaleDim(canvas.height);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const image = tf.tidy(() => {
        return tf.fromPixels(canvas).resizeBilinear([scaledHeight, scaledWidth]).expandDims(0);
    });
    const [scores, tboxes] = await handInterface.handDetectionModel.executeAsync(image);
    image.dispose();
    const handsDetected = tf.tidy(() => {
        const indices = tf.image.nonMaxSuppression(
            tboxes.reshape([tboxes.shape[1], tboxes.shape[3]]),
            scores.reshape([scores.shape[1]]),
            20,
            0.5,
            0.85).dataSync();
        var boxes = [];
        var idx;
        for (let i = 0; i < indices.length; i++) {
            idx = indices[i];
            var score = scores.get(0, idx, 0);
            // Original order is [minY, minX, maxY, maxX] so we reorder.
            var box = {
                upperLeft: [tboxes.get(0, idx, 0, 1), tboxes.get(0, idx, 0, 0)],
                lowerRight: [tboxes.get(0, idx, 0, 3), tboxes.get(0, idx, 0, 2)]
            };
            boxes.push({score: score, box: box});
        }
        return {boxes: boxes, timestamp: Date.now()};
    });
    scores.dispose();
    tboxes.dispose();
    if (handsDetected.boxes.length !== 1) {
        if (handInterface.handDetectionRunning) {
            window.requestAnimationFrame(detectHands);
        }
        return;
    }
    const box = handsDetected.boxes[0].box;
    const [x1, y1] = box.upperLeft;
    const [x2, y2] = box.lowerRight;
    const area = {area: (x2 - x1) * (y2 - y1), timestamp: Date.now()};
    handInterface.handDetectionAreas = [].concat(handInterface.handDetectionAreas.slice(-2), [area]);
    // Update hand location
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
    const p = [0.5 * (x1 + x2) * vw, 0.5 * (y1 + y2) * vh];
    handInterface.positions = [].concat(handInterface.positions.slice(-2), [p]);
    var target = handInterface.targetElement;
    if (target === null) {
        target = handInterface.leninHand;
    }
    // Compute average position
    const [p1, p2, p3] = handInterface.positions;
    const [ap1, ap2] = [(1/3)*(p1[0] + p2[0] + p3[0]), (1/3)*(p1[1] + p2[1] + p3[1])];
    target.partProperties.setPropertyNamed(target, "left", ap1);
    target.partProperties.setPropertyNamed(target, "top", ap2);
    // Extract area information without any timestamps
    var justAreas = [];
    for (var i = 0; i < handInterface.handDetectionAreas.length; ++i) {
        justAreas.push(handInterface.handDetectionAreas[i].area);
    }
    var justAreas = [].concat(Array(3 - justAreas.length).fill(0), justAreas);
    // Check if hand is pushing in
    const [a1, a2, a3] = justAreas;
    const aveArea = (1/3) * (a1 + a2 + a3);
    if (aveArea > 0.25) {
        if (!handInterface.handMasked) {
            handInterface.handMasked = true;
            setTimeout(() => { handInterface.handMasked = false; }, 3000);
            if (handInterface.targetElement === null) {
                let closestView = findClosestView([p1, p2]);
                if (closestView !== null) {
                    handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", true);
                    handInterface.targetElement = closestView.model;
                }
            } else {
                handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", false);
                handInterface.targetElement = null;
            }
        }
    }
    if (handInterface.handDetectionRunning) {
        window.requestAnimationFrame(detectHands);
    }
};

const findClosestView = (point) => {
    let views = [];
    window.System.getCurrentCardModel().subparts.forEach((part) => {
        let partViews = window.System.findViewsById(part.id);
        partViews.forEach((view) => {
            views.push(view);
        })
    });
    var [closestDist, closestView] = [Infinity, null];
    views.forEach((view) => {
        let viewDist = dist(point, getVertices(view));
        if (viewDist < closestDist) {
            closestDist = viewDist;
            closestView = view;
        }
    });
    return closestView;
}

// https://aaronsmith.online/easily-load-an-external-script-using-javascript/
const loadScript = src => {
    return new Promise((resolve, reject) => {
        if (typeof window.tf !== 'undefined') {
            console.log("tensorflowjs already loaded");
            resolve();
            return;
        }
        console.log("loading tensorflowjs");
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.onload = resolve;
        script.onerror = reject;
        script.src = src;
        document.head.append(script);
    });
};

const loadHandDetectionModel = () => {
    handInterface.handDetectionAreas = [];
    loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.5/dist/tf.js").then(() => {
        window.tf.loadFrozenModel(
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/tensorflowjs_model.pb",
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/weights_manifest.json"
        ).then(model => {
            console.log("hand detection model loaded");
            handInterface.handDetectionModel = model;
        }).then(() => {
            return navigator.mediaDevices.getUserMedia({ video: true });
        }).then(stream => {
            video.srcObject = stream;
            return video.play();
        }).then(() => {
            console.log("video started");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0); // Mirror incoming video
            handInterface.handDetectionRunning = true;
            handInterface.leninHand = window.System.newModel('image', window.System.getWorldStackModel().id, "/images/leninHand.png");
            handInterface.targetElement = null;
            window.requestAnimationFrame(detectHands);
        }).catch(err => {
            console.log("error loading hand detection model");
            console.log(err);
        });
    });
}

const unloadHandDetectionModel = () => {
    handInterface.handDetectionRunning = false;
    window.System.deleteModel(handInterface.leninHand.id)
    handInterface.leninHand = null;
    video.pause();
    const tracks = video.srcObject.getTracks();
    for (var i = 0; i < tracks.length; i++) {
        tracks[i].stop();
    }
    video.srcObject = null;
    console.log("video stopped");
    handInterface.handDetectionModel = null;
    console.log("unloading hand detection model");
}

const getVertices = (element) => {
    const rect = element.getBoundingClientRect();
    const upperLeft = [rect.x, rect.y];
    const upperRight = [rect.x + rect.width, rect.y];
    const lowerLeft = [rect.x, rect.y + rect.height];
    const lowerRight = [rect.x + rect.width, rect.y + rect.height];
    return {
        upperLeft: upperLeft,
        upperRight: upperRight,
        lowerLeft: lowerLeft,
        lowerRight: lowerRight
    };
}

const dist = (point, vertices) => {
    const [p1, p2] = point;
    const [ul1, ul2] = vertices.upperLeft;
    const [ll1, ll2] = vertices.lowerLeft;
    const [ur1, ur2] = vertices.upperRight;
    const [lr1, lr2] = vertices.lowerRight;
    // First check if the point is inside the rectangle
    // Next we compute the vector pointing from the point to the closest point
    // on the rectangle. There are 9 cases. The first is when the poinst is
    // inside the rectangle. The next four cases are if the point in one of
    // the four corners and the final four cases are when the point is on one
    // of the four sides.
    var [v1, v2] = [null, null];
    if ((ul1 <= p1) && (p1 <= lr1) && (ul2 <= p2) && (p2 <= lr2)) {
        // Case 0: inside the rectangle
        [v1, v2] = [0, 0];
    } else if ((p1 <= ul1) && (p2 <= ul2)) {
        // Case 1: upper left
        [v1, v2] = [ul1 - p1, ul2 - p2];
    } else if ((p1 >= ur1) && (p2 <= ur2)) {
        // Case 2: upper right
        [v1, v2] = [ur1 - p1, ur2 - p2];
    } else if ((p1 <= ll1) && (p2 >= ll2)) {
        // Case 3: lower left
        [v1, v2] = [ll1 - p1, ll2 - p2];
    } else if ((p1 >= lr1) && (p2 >= lr2)) {
        // Case 4: lower right
        [v1, v2] = [lr1 - p1, lr2 - p2];
    } else if (p1 <= ul1) {
        // Case 5: side left
        [v1, v2] = [ul1 - p1, 0];
    } else if (p1 >= lr1) {
        // Case 6: side right
        [v1, v2] = [lr1 - p1, 0];
    } else if (p2 <= ul2) {
        // Case 7: side top
        [v1, v2] = [0, ul2 - p2];
    } else if (p2 >= lr2) {
        // Case 8: side bottom
        [v1, v2] = [0, lr2 - p2];
    } else {
        // Case 9: inside
        [v1, v2] = [0, 0];
    }
    return Math.sqrt(v1*v1 + v2*v2);
}

class HandInterface {
    constructor() {
        this.handDetectionModel = null;
        this.handDetectionRunning = false;
        this.leninHand = null;
        this.handMasked = false;
        this.targetElement = null;
        this.handDetectionAreas = [];
        this.positions = [[0, 0], [0, 0], [0, 0]];
        // XXX - Only here to ignore the tensorflow warnings
        console.warn = () => {};
    }

    start() {
        loadHandDetectionModel();
    }

    stop() {
        unloadHandDetectionModel();
    }
}

const Testables = {
    dist: dist
}

const handInterface = new HandInterface();




/***/ }),

/***/ "./js/objects/utils/icons.js":
/*!***********************************!*\
  !*** ./js/objects/utils/icons.js ***!
  \***********************************/
/*! exports provided: partIcons, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partIcons", function() { return partIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return partIcons; });
let partIcons = {};

partIcons.world = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-world" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <line x1="3.6" y1="9" x2="20.4" y2="9" />
  <line x1="3.6" y1="15" x2="20.4" y2="15" />
  <path d="M11.5 3a17 17 0 0 0 0 18" />
  <path d="M12.5 3a17 17 0 0 1 0 18" />
</svg>
`;

partIcons.stack = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="12 4 4 8 12 12 20 8 12 4" />
  <polyline points="4 12 12 16 20 12" />
  <polyline points="4 16 12 20 20 16" />
</svg>
`;

partIcons.card = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>
`;

partIcons.button = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hand-finger" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M8 13v-8.5a1.5 1.5 0 0 1 3 0v7.5" />
  <path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0v2.5" />
  <path d="M14 10.5a1.5 1.5 0 0 1 3 0v1.5" />
  <path d="M17 11.5a1.5 1.5 0 0 1 3 0v4.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" />
</svg>
`;

partIcons.window = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-window" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3c-3.866 0 -7 3.272 -7 7v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1 -1v-10c0 -3.728 -3.134 -7 -7 -7z" />
  <line x1="5" y1="13" x2="19" y2="13" />
  <line x1="12" y1="3" x2="12" y2="21" />
</svg>
`;

partIcons.area = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-shape" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="5" cy="5" r="2" />
  <circle cx="19" cy="5" r="2" />
  <circle cx="5" cy="19" r="2" />
  <circle cx="19" cy="19" r="2" />
  <line x1="5" y1="7" x2="5" y2="17" />
  <line x1="7" y1="5" x2="17" y2="5" />
  <line x1="7" y1="19" x2="17" y2="19" />
  <line x1="19" y1="7" x2="19" y2="17" />
</svg>
`;

partIcons.field = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-forms" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3a3 3 0 0 0 -3 3v12a3 3 0 0 0 3 3" />
  <path d="M6 3a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3" />
  <path d="M13 7h7a1 1 0 0 1 1 1v8a1 1 0 0 1 -1 1h-7" />
  <path d="M5 7h-1a1 1 0 0 0 -1 1v8a1 1 0 0 0 1 1h1" />
  <path d="M17 12h.01" />
  <path d="M13 12h.01" />
</svg>
`;

partIcons.drawing = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-palette" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 21a9 9 0 1 1 0 -18a9 8 0 0 1 9 8a4.5 4 0 0 1 -4.5 4h-2.5a2 2 0 0 0 -1 3.75a1.3 1.3 0 0 1 -1 2.25" />
  <circle cx="7.5" cy="10.5" r=".5" fill="currentColor" />
  <circle cx="12" cy="7.5" r=".5" fill="currentColor" />
  <circle cx="16.5" cy="10.5" r=".5" fill="currentColor" />
</svg>
`;

partIcons.image = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="15" y1="8" x2="15.01" y2="8" />
  <rect x="4" y="4" width="16" height="16" rx="3" />
  <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5" />
  <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2" />
</svg>
`;

partIcons.generic = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-puzzle" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 7h3a1 1 0 0 0 1 -1v-1a2 2 0 0 1 4 0v1a1 1 0 0 0 1 1h3a1 1 0 0 1 1 1v3a1 1 0 0 0 1 1h1a2 2 0 0 1 0 4h-1a1 1 0 0 0 -1 1v3a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-1a2 2 0 0 0 -4 0v1a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1h1a2 2 0 0 0 0 -4h-1a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1" />
</svg>
`;




/***/ }),

/***/ "./js/objects/utils/id.js":
/*!********************************!*\
  !*** ./js/objects/utils/id.js ***!
  \********************************/
/*! exports provided: idMaker, isValidId, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idMaker", function() { return idMaker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidId", function() { return isValidId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return idMaker; });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_0__);
// ID related utilities



/**
 * ID Maker
 * ------------------------------------
 * I am responsible for creating globally
 * unique ID values for Parts in the SimpleTalk
 * world.
 * HC requires that all Parts have unique ids and
 * that these should not be repeated in any given
 * "application" instance.
 * We need to determine what an "application" is
 * in our context, but regardless we can use this
 * module as a drop in replacement, implementing
 * UUIDs or URLs or whatever we want.
 * For now we just increment an integer.
 */
const idMaker = {
    new: function(){
        let id = Object(uuid__WEBPACK_IMPORTED_MODULE_0__["v4"])();
        return id.replace(/-/g, '');
    }
};

/* ID checker
 * --------------------------------------
 * I am responsible for checking whether an id is
 * is valid and returning it if so
 */
const isValidId = function(id) {
    if(id === null || id === undefined || id === ""){
        return false;
    }
    if(id.length != 32 || id.match('[a-z0-9]*')[0].length != 32) {
        return false;
    }
    return id;
};




/***/ }),

/***/ "./js/objects/utils/merriamInterface.js":
/*!**********************************************!*\
  !*** ./js/objects/utils/merriamInterface.js ***!
  \**********************************************/
/*! exports provided: merriamSimScore, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriamSimScore", function() { return merriamSimScore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriamSimScore; });
const merriamSimScore = async (sender, docId) => {
    const url = "https://patents.merriamtech.com/_api/merriam/"
    const payload = {
        "fields": [
            "title",
            "date_publ"
        ],
        "weights": {
            "merriam":0.7,
            "date":0.3,
            "hierarchy":0.1
        },
        "doc_ids": [
            docId
        ],
        "limit": 5}
    const params = {
        "method": "POST",
        "headers": {
            "content-type": "application/json"
        },
        "body": JSON.stringify(payload)
    }
    fetch(url, params).then(data => {
        return data.json();
    }).then(json => {
        const msg = {
            type: 'command',
            commandName: 'merriamresult',
            args: [
                JSON.stringify(json)
            ]
        };
        sender.sendMessage(msg, sender);
    });
}




/***/ }),

/***/ "./js/objects/utils/serialization.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/serialization.js ***!
  \*******************************************/
/*! exports provided: STSerializer, STDeserializer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STSerializer", function() { return STSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STDeserializer", function() { return STDeserializer; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/**
 * Serialization and Deserialization Utility Classes
 */


const version = "0.0.2";

class STDeserializer {
    constructor(aSystem){
        this.system = aSystem;

        // These caches are used during the process
        // as optimizations
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];

        // The targetId is the id of
        // the Part that we wish to append any
        // deserialized subpart tree into.
        // By default we assume the whole system,
        // ie full deserialization.
        this.targetId = 'system';
        // the root id is the id of the root part instance
        // being attached
        this.rootId = null;

        // Bound methods
        this.deserialize = this.deserialize.bind(this);
        this.deserializeData = this.deserializeData.bind(this);
        this.deserializePart = this.deserializePart.bind(this);
        this.attachSubparts = this.attachSubparts.bind(this);
        this.setProperties = this.setProperties.bind(this);
        this.createView = this.createView.bind(this);
        this.attachView = this.attachView.bind(this);
        this.setViewModel = this.setViewModel.bind(this);
        this.compilePartScript = this.compilePartScript.bind(this);
        this.refreshWorld = this.refreshWorld.bind(this);
        this.appendWorld = this.appendWorld.bind(this);
        this.addPartsToSystem = this.addPartsToSystem.bind(this);
        this.compileScripts = this.compileScripts.bind(this);
        this.getFlattenedPartTree = this.getFlattenedPartTree.bind(this);
        this.getModelClass = this.getModelClass.bind(this);
        this.handleId = this.handleId.bind(this);
        this.throwError = this.throwError.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
        this.dispatchViewAdded = this.dispatchViewAdded.bind(this);
    }

    deserialize(aJSONString){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        return this.deserializeData()
            .then(() => {
                // Add all deserialized Parts to the System dict,
                // including the new World.
                this.addPartsToSystem(this._instanceCache);
            })
            .then(() => {
                // Compile the scripts on *all* deserialized
                // parts
                this.compileScripts(this._instanceCache);
            })
            .then(() => {
                // Insert the root Part into whatever
                // target it should go into.
                let rootPart = this.rootParts[0];
                let rootView = this.rootViews[0];
                if(this.targetId == 'system'){
                    this.refreshWorld();
                } else {
                    target.addPart(rootPart);
                }

                // Finally, append the PartView root node
                // where it should go in the view tree.
                if(this.targetId == 'system'){
                    this.appendWorld();
                } else {
                    let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
                    targetView.appendChild(rootView);
                    this.dispatchViewAdded(rootView);
                    rootPart.sendMessage({
                        type: 'command',
                        commandName: 'newModel',
                        args: [],
                        shouldNotDelegate: true,
                        shouldIgnore: true
                    }, rootPart);
                }
                return this;
            });
    }

    deserializeData(){
        return new Promise((resolve, reject) => {
            this.flushCaches();
            // First, we ensure that the target we
            // should be deserializing into actually exists
            let target = this.system.partsById[this.targetId];
            if(!target && this.targetId != 'system'){
                this.throwError(`Target id ${this.targetId} does not exist in System`);
            }

            // Second, we create instances of all models in the serialization
            // but we do not yet attach their subparts.
            Object.values(this.data.parts).forEach(partData => {
                this.deserializePart(Object.assign({}, partData));
            });

            // Translate targets
            for (let modelId in this._propsCache) {
                let props = this._propsCache[modelId];
                if (props.target !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        if (props.target === 'part id ' + oldId) {
                            props.target = 'part id ' + newId;
                            break;
                        }
                    }
                }
            }
            // Translate scripts
            for (let modelId in this._scriptCache) {
                let script = this._scriptCache[modelId];
                if (script !== null && script.match('part id') !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        let oldRe = 'part id ' + oldId;
                        let newRe = 'part id ' + newId;
                        if (this._scriptCache[modelId].match(oldRe) !== null) {
                            console.log(modelId);
                            let re = new RegExp(oldRe, "g");
                            this._scriptCache[modelId] = script.replace(re, newRe);
                        }
                    }
                }
            }

            // Third, we go through each created Part instance
            // and add any subparts to it. Note that this is not
            // recursive
            this._instanceCache.forEach(partInstance => {
                this.attachSubparts(partInstance);
            });

            // Forth and fifth. Create and attach views
            // Note this is recursive to preserve the subpart + view children order
            let root = this._instanceCache.filter((part) => {
                return part.partProperties.getPropertyNamed(part, "id") == this.rootId;
            })[0];
            this.createAndAttachViews(root);

            // Sixth, we set all properties on each created
            // Part model from the deserialized data.
            // We do this using a visitor method on the instances
            // themselves.
            // This gives the in-memory views the ability to
            // react to any initial changes to their models.
            this._instanceCache.forEach(partInstance => {
                this.setProperties(partInstance);
                // We need to translate new ids to old ones
                if (partInstance.name == "WorldStack") {
                    let world = partInstance;
                    world.partProperties.setPropertyNamed(
                        world,
                        "current",
                        this._idCache[world.currentStackId]
                    );
                }
                if (partInstance.name == "Stack") {
                    let stack = partInstance;
                    stack.partProperties.setPropertyNamed(
                        stack,
                        "current",
                        this._idCache[stack.currentCardId]
                    );
                }
                this.setViewModel(partInstance);
            });

            // We determine which of the instances is a "root",
            // meaning that it has, at this point, no owner in
            // the deserialized data. There can be multiple roots
            // (and therefore multiple trees) in a single deserialization
            this._rootsCache = this._instanceCache.filter(instance => {
                return instance._owner == null || instance._owner == undefined;
            });

            // Insertion should be handled by composed
            // promises elsewhere (see imports and deserialize()
            // for examples)

            return resolve(this);
        });
    }

    createAndAttachViews(partInstance){
        this.createView(partInstance);
        this.attachView(partInstance);
        if(partInstance.subparts.length){
            partInstance.subparts.forEach((subpartInstance) => {
                this.createAndAttachViews(subpartInstance);
            });
        }
    }

    importFromSerialization(aJSONString, filterFunction){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
        return this.deserializeData()
            .then(() => {
                // The caller will provide a filter function over
                // all deserialized part instances, returning only
                // those that should be inserted into the target.
                // For example, all Stacks in the WorldStack.
                return this._instanceCache.filter(filterFunction);
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.addPartsToSystem(allTreeParts);
                });
                return rootParts;

            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.compileScripts(allTreeParts);
                });
                return rootParts;
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let view = this._viewsCache[rootPart.id];
                    target.addPart(rootPart);
                    targetView.appendChild(view);
                    this.dispatchViewAdded(view);
                });
            });
    }

    deserializePart(partData){
        let partClass = this.getModelClass(partData.type);
        let instance = new partClass();

        // We create a new ID for this part, since we cannot
        // guarantee ID clashes with the existing System.
        // Exception is if the useOriginalids flag is set,
        // such as at load time
        let {newId, oldId} = this.handleId(instance, partData);
        instance.id = newId;
        // cache the new root ID if this is a root instance
        if(this.data.rootId == oldId){
            this.rootId = newId;
        }

        // Add to our caches and also to the System
        this._idCache[oldId] = newId;
        this._scriptCache[newId] = partData.properties.script;
        this._propsCache[newId] = partData.properties;
        this._modelCache[newId] = instance;
        this._subpartMapCache[newId] = partData.subparts;
        this._instanceCache.push(instance);
    }

    handleId(aPart, partData){
        let newId, oldId;
        oldId = partData.id;
        newId = aPart.id;
        if(aPart.type !== 'world'){
            newId = _id_js__WEBPACK_IMPORTED_MODULE_0__["default"].new();
        }
        return {
            newId,
            oldId
        };
    }

    addPartsToSystem(aListOfParts){
        aListOfParts.forEach(part => {
            this.system.partsById[part.id] = part;
        });
    }

    compileScripts(aListOfParts){
        aListOfParts.forEach(part => {
            this.compilePartScript(part);
        });
    }

    attachSubparts(aPart){
        // At this point, the _subpartMapCache should
        // have an entry mapping from this aPart's (new)
        // id to an array of ids of also-initialized
        // subpart models
        let subpartIds = this._subpartMapCache[aPart.id];
        subpartIds.forEach(subpartId => {
            let newId = this._idCache[subpartId];
            let subpartModel = this._modelCache[newId];
            if(!subpartModel){
                debugger;
            }
            aPart.addPart(subpartModel);
        });
    }

    setProperties(aPart){
        let props = this._propsCache[aPart.id];
        delete props['id'];
        aPart.setPropsFromDeserializer(props, this);
    }

    createView(aPart){
        let newView = document.createElement(
            this.system.tagNameForViewNamed(aPart.type)
        );
        // we need to set the part-id attribute since these
        // are used for queries needed for things like
        // current stack and card
        newView.setAttribute("part-id", aPart.id);
        this._viewsCache[aPart.id] = newView;
    }

    setViewModel(aPart){
        let view = this._viewsCache[aPart.id];
        view.setModel(aPart);
    }
    
    attachView(aPart){
        let owner = aPart._owner;
        if(owner){
            let ownerView = this._viewsCache[owner.id];
            let partView = this._viewsCache[aPart.id];
            owner.sendMessage({
                type: "viewChanged",
                changeName: "subpart-new",
                args: [partView]
            }, ownerView);
        }
    }

    compilePartScript(aPart){
        let scriptString = this._scriptCache[aPart.id];
        if(scriptString && scriptString != ""){
            this.system.compile({
                type: 'compile',
                targetId: aPart.id,
                codeString: scriptString,
                serialize: false
            });
        }
    }

    refreshWorld(){
        // We assume a single root part was deserialized and
        // attach it as the World accordingly
        let newWorld = this.rootParts[0];
        if(newWorld.type !== 'world'){
            this.throwError(`Found ${this.rootParts.length} roots, but no world!`);
        }
        this.system.partsById['world'] = this.rootParts[0];
    }

    appendWorld(){
        // We assume a single root view that is an st-world.
        let found = document.querySelector('st-world');
        if(found){
            document.body.replaceChild(this.rootViews[0], found);
        } else {
            document.body.prepend(this.rootViews[0]);
        }
        this.dispatchViewAdded(document.querySelector('st-world'));
    }

    getFlattenedPartTree(aPart, list=[]){
        list.push(aPart);
        aPart.subparts.forEach(subpart => {
            this.getFlattenedPartTree(subpart, list);
        });
        return list;
    }

    throwError(message){
        throw new Error(`Deserialization Error: ${message}`);
    }

    getModelClass(aPartTypeStr){
        let cls = this.system.availableParts[aPartTypeStr];
        if(!cls){
            this.throwError(`Part type "${aPartTypeStr}" does not exist in system`);
        }
        return cls;
    }

    flushCaches(){
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];
    }

    dispatchViewAdded(aView){
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: aView.model.type,
                partId: aView.model.id,
                //ownerId: aView.model._owner.id || null
            } 
        });
        aView.parentElement.dispatchEvent(event);
    }

    get rootParts(){
        return this._rootsCache;
    }

    get rootViews(){
        return this.rootParts.map(part => {
            return this._viewsCache[part.id];
        });
    }
}


class STSerializer {
    constructor(aSystem){
        this.system = aSystem;
        this._objectCache = {};

        // Bound methods
        this.serializePart = this.serializePart.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
    }

    serialize(aRootPart, pretty=true){
        this.flushCaches();
        let result = {
            version: version,
            rootId: aRootPart.id,
            type: aRootPart.type,
            id: aRootPart.id
        };

        // Recursively serialize Parts and
        // store in flat list
        this.serializePart(aRootPart);

        // We set the result objects parts
        // dict to be the same as the cache
        result.parts = this._objectCache;

        // Finally, we convert to a string and
        // return
        if(pretty){
            return JSON.stringify(result, null, 4);
        } else {
            return JSON.stringify(result);
        }
    }

    serializePart(aPart){
        // We use the serialize method available on
        // base Parts, passing in this serializer instance
        // as the sole arg
        this._objectCache[aPart.id] = aPart.serialize(this);
        aPart.subparts.forEach(subpart => {
            this.serializePart(subpart);
        });
    }

    flushCaches(){
        this._objectCache = {};
    }
}




/***/ }),

/***/ "./js/objects/utils/styleProperties.js":
/*!*********************************************!*\
  !*** ./js/objects/utils/styleProperties.js ***!
  \*********************************************/
/*! exports provided: addBasicStyleProps, addPositioningStyleProps, addTextStyleProps, addLayoutStyleProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addBasicStyleProps", function() { return addBasicStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPositioningStyleProps", function() { return addPositioningStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTextStyleProps", function() { return addTextStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLayoutStyleProps", function() { return addLayoutStyleProps; });
/**
 * Helpers for setting up various
 * style properties
 */


/**
 * Basic style properties are those
 * common to all (visual) Parts
 */
const sides = ["top", "bottom", "left", "right"];

const addBasicStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'background-transparency',
        1,
    );
    target.partProperties.newStyleProp(
        'background-color',
        "rgb(255, 255, 255)", // white 
    );
    target.partProperties.newStyleProp(
        'transparency',
        1.0,
    );
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-style`,
            'solid'
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-width`,
            0,
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-color`,
            "rgb(0, 0, 0)", // black
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-transparency`,
            1
        );
    });
    target.partProperties.newStyleProp(
        'shadow-left',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-top',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-blur',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-spread',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-color',
        "rgb(238, 238, 238)", // grey
    );
    target.partProperties.newStyleProp(
        'shadow-transparency',
        1
    );
    target.partProperties.newStyleProp(
        'corner-top-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-top-right-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-right-round',
        0
    );
};

/**
 * Style properties for Parts that can
 * be moved and that can have explicit
 * dimensions. Examples: buttons, fields.
 * Examples of those that can't: Cards, Stacks
 */
const addPositioningStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'hide',
        false,
    );
    // setting width and height to null
    // effectively forces to the default size
    // of the button to fit the button name
    target.partProperties.newStyleProp(
        'width',
        100,
    );
    target.partProperties.newStyleProp(
        'height',
        null,
    );
    target.partProperties.newStyleProp(
        'top',
        0,
    );
    target.partProperties.newStyleProp(
        'left',
        0,
    );
    target.partProperties.newStyleProp(
        'rotate',
        null,
    );

    // horizontal-resizing specifies a strategy
    // for how this Part should adjust its
    // horizontal axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // horizontal axis in the parent Part.
    target.partProperties.newStyleProp(
        'horizontal-resizing',
        'rigid'
    );

    // vertical-resizing specifies a strategy
    // for how this Part should adjust its
    // vertical axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // vertical axis in the parent Part.
    target.partProperties.newStyleProp(
        'vertical-resizing',
        'rigid'
    );

    // Margin specifies some space between the
    // target Part and any other Parts that might
    // be adjacent to it in a common Owner. It will
    // not be in effect when the owner is using a
    // strict layout.
    target.partProperties.newStyleProp(
        'top-margin',
        null
    );
    target.partProperties.newStyleProp(
        'right-margin',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-margin',
        null
    );
    target.partProperties.newStyleProp(
        'left-margin',
        null
    );

    // Pinning specifies whether or not
    // a given part should "stick" to a
    // particular side of its owner Part.
    // Pinning properties only have effect
    // inside of Parts with a strict layout
    target.partProperties.newDynamicProp(
        'pinning-top',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-left',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-bottom',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        'pinning-right',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        // Possible values for the compound
        // 'pinning' property are:
        // *"none" or null
        // *top
        // *top-right
        // *top-left
        // *bottom
        // *bottom-right
        // *bottom-left
        // *left
        // *right
        'pinning',
        // Setter
        function(propOwner, propObject, value){
            if(!value || value == "none"){
                ['top', 'left', 'right', 'bottom'].forEach(side => {
                    let pin = `pinning-${side}`;
                    propOwner.partProperties.setPropertyNamed(
                        propOwner,
                        pin,
                        false
                    );
                });
                return;
            }
            pinningAdjust(propOwner, value);
        },

        // Getter
        function(propOwner, propObject){
            let top = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-top'
            );
            let bottom = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-bottom'
            );
            let left = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-left'
            );
            let right = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-right'
            );
            let result = [];
            if(top){
                result.push('top');
            } else if(bottom){
                result.push('bottom');
            }
            if(left){
                result.push('left');
            } else if(right){
                result.push('right');
            }

            return result.join('-');
        }
    );
};

/**
 * Style properties for Parts that display
 * text
 */
const addTextStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'text-align',
        'left',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-font',
        'default',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-color',
        "rgb(0, 0, 0)", // black
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-transparency',
        1,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-style',
        'plain',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-bold',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-italic',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-size',
        15,
        'cssTextStyle'
    );
};

/**
 * Basic layout styles are those pertaining
 * to the positioning and resizing of subparts.
 * Examples include Cards and Area
 */
const addLayoutStyleProps = (target) => {
    // The 'layout' property is
    // one of two strings:
    // strict - Equivalent to the absolute
    // layout based strictly on coordinates
    // list - Will force items into either a row
    // or column list, based on the pairing with
    // the 'listDirection' property
    target.partProperties.newBasicProp(
        'layout',
        'strict'
    );

    // list-direction specifies row or column
    // and will only have an effect whent the
    // layout property is set to 'list'
    target.partProperties.newBasicProp(
        'list-direction',
        'row'
    );

    // Wrapping specifies whether a list should
    // wrap along its dominant dimension (row or column)
    target.partProperties.newBasicProp(
        'list-wrapping',
        false
    );

    // Padding specifies some space from the
    // border of the target Part to the beginning
    // of the layout of any subparts.
    target.partProperties.newStyleProp(
        'top-padding',
        null
    );
    target.partProperties.newStyleProp(
        'right-padding',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-padding',
        null
    );
    target.partProperties.newStyleProp(
        'left-padding',
        null
    );

    // List alignment describes how elements in
    // a list layout should align themselves along
    // the dominant dimension (row or column)
    // They are essentially proxies for align-items
    target.partProperties.newBasicProp(
        'list-alignment',
        null
    );

    // List distribution describes how elements
    // in a list layout should distribute themselves
    // across or along the dominant dimension
    // (row or column)
    // This is essentially a wrapper for justify-content
    target.partProperties.newBasicProp(
        'list-distribution',
        null
    );
};

/**
  * HELPERS
 **/

const pinningSetter = (propOwner, propObject, value) => {
    let side = propObject.name.split("-")[1];
    let topLeft;
    switch (side){
    case "right":
        topLeft = "left";
        break;
    case "bottom":
        topLeft = "top";
        break;
    default:
        topLeft = side;
    }
    // we'll need to fix and un-fix the corresponding top or left property depending
    // on whether value is true of false, respectively
    let prop = propOwner.partProperties.findPropertyNamed(
        topLeft 
    );
    let oppositeSide;
    switch (side){
    case "left":
        oppositeSide = "right";
        break;
    case "right":
        oppositeSide = "left";
        break;
    case "top":
        oppositeSide = "bottom";
        break;
    case "bottom":
        oppositeSide = "top";
        break;
    }
    if(value){
        // first make sure that pinning-bottom is false
        propOwner.partProperties.setPropertyNamed(
            propOwner,
            `pinning-${oppositeSide}`,
            false
        );
        prop.readOnly = true;
    } else {
        // reset the value back to trigger a notification
        prop.setValue(propOwner, prop._value);
        prop.readOnly = false;
    }
    propObject._value = value;
};

const pinningAdjust = (owner, value) => {
    let sides = ['top', 'left', 'right', 'bottom'];
    sides.forEach(side => {
        if(value.startsWith(side)){
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                true
            );
        } else {
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                false
            );
        }
    });

    if(value.includes("-")){
        if(value.endsWith('left')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                true
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                false
            );
        } else if(value.endsWith('right')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                false
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                true
            );
        }
    }
};




/***/ }),

/***/ "./js/objects/utils/styler.js":
/*!************************************!*\
  !*** ./js/objects/utils/styler.js ***!
  \************************************/
/*! exports provided: cssStyler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssStyler", function() { return cssStyler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cssStyler; });
/**
 * Styler
 * ------------------------------------
 * I am responsible for converting
 * SimpleTalk visual styling to a dict
 * Object of CSS JavaScript type key-value pairs
 */

/** I style the styleObj
 * styleObj: css JavaScript key:value pairs
 * propertyName: (SimpleTalk) styling property name
 * propertyValue: (SimpleTalk) styling property value
 */

const cssStyler = (styleObj, propertyName, propertyValue) => {
    switch(propertyName){

    case "background-color":
        _setOrNot(styleObj, "backgroundColor",  _colorToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "background-transparency":
        // here we set the Alpha value of the current styleObj["backgroundColor"] rgba
        _setOrNot(styleObj, "backgroundColor",  _colorTransparencyToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "border-top-style":
    case "border-bottom-style":
    case "border-left-style":
    case "border-right-style": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-style`,  propertyValue);
        break;
    }

    case "border-top-width":
    case "border-bottom-width":
    case "border-left-width":
    case "border-right-width": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-width`,  _intToPx(propertyValue));
        break;
    }

    case "border-top-color":
    case "border-bottom-color":
    case "border-top-color":
    case "border-right-color": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "border-top-transparency":
    case "border-bottom-transparency":
    case "border-left-transparency":
    case "border-right-transparency": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorTransparencyToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "corner-top-left-round":
    case "corner-top-right-round":
    case "corner-bottom-left-round":
    case "corner-bottom-right-round":{
        let c1 = propertyName.split("-")[1];
        let c2 = propertyName.split("-")[2];
        _setOrNot(styleObj, `border-${c1}-${c2}-radius`,  _intToPx(propertyValue));
        break;
    }

    case "shadow-left":
    case "shadow-top":
    case "shadow-blur":
    case "shadow-spread":
    case "shadow-color":
    case "shadow-transparency":
        let shadowProp = propertyName.split("-")[1];
        let [left, top, blur, spread, color] = _cssBoxShadow(styleObj["box-shadow"]);
        switch(shadowProp){
        case "color":
            color = _colorToRGBA(color, propertyValue);
            break;
        case "transparency":
            color = _colorTransparencyToRGBA(color, propertyValue);
            break;
        case "left":
            left = _intToPx(propertyValue);
            break;
        case "top":
            top = _intToPx(propertyValue);
            break;
        case "blur":
            blur = _intToPx(propertyValue);
            break;
        case "spread":
            spread = _intToPx(propertyValue);
            break;
        }
        _setOrNot(styleObj, "box-shadow", `${left} ${top} ${blur} ${spread} ${color}`);
        break;

    case "text-color":
        _setOrNot(styleObj, "color",  _colorToRGBA(styleObj["color"], propertyValue));
        break;

    case "text-font":
        _setOrNot(styleObj, "fontFamily",  propertyValue);
        break;

    case "text-size":
        _setOrNot(styleObj, "fontSize", propertyValue);
        break;

    case "text-align":
        _setOrNot(styleObj, "textAlign",  propertyValue);
        break;

    case "text-bold":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-weight",  "bold");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-weight",  "normal");
        }
        break;

    case "text-italic":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-style",  "italic");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-style",  "normal");
        }
        break;

    case "text-underline":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "underline");
        }
        break;

    case "text-strikethrough":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "line-through");
        }
        break;

    case "text-transparency":
        // here we set the Alpha value of the current styleObj["color"] rgba
        _setOrNot(styleObj, "color",  _colorTransparencyToRGBA(styleObj["color"], propertyValue));
        break;

    case "top":
        _setOrNot(styleObj, "top",  _intToPx(propertyValue));
        break;

    case "left":
        _setOrNot(styleObj, "left",  _intToPx(propertyValue));
        break;

    case "width":
        _setOrNot(styleObj, "width",  _intToPx(propertyValue));
        break;

    case "height":
        _setOrNot(styleObj, "height",  _intToPx(propertyValue));
        break;

    case "left-margin":
    case "right-margin":
    case "bottom-margin":
    case "top-margin":
        let marginSide = propertyName.split("-")[0];
        marginSide = `${marginSide[0].toUpperCase()}${marginSide.slice(1)}`;
        _setOrNot(styleObj, `margin${marginSide}`, _intToPx(propertyValue));
        break;

    case "left-padding":
    case "right-padding":
    case "bottom-padding":
    case "top-padding":
        let paddingSide = propertyName.split("-")[0];
        paddingSide = `${paddingSide[0].toUpperCase()}${paddingSide.slice(1)}`;
        _setOrNot(styleObj, `padding${paddingSide}`, _intToPx(propertyValue));
        break;

    case "text-style":
        _setOrNot(styleObj, "textStyle",  propertyValue);
        break;

    case "rotate":
        _setOrNot(styleObj, "transform",  _intToRotateDeg(propertyValue));
        break;

    case "transparency":
        _setOrNot(styleObj, "opacity",  propertyValue);
        break;

    case "hide":
        if(propertyValue === true){
            styleObj["display"] = "none";
        } else if(propertyValue === false){
            styleObj["display"] = null;
        }
        break;


    default:
        // for the default we simply allow ST style names to map 1-1
        // to CSS/JS style names. This is only somewhat safe, since the DOM
        // will simply ignore nonsense names without throwing an error. But it
        // does allow us to avoid writing a rule for every term (example: width,
        // height, top, left etc)
        _setOrNot(styleObj, propertyName,  propertyValue);
    }
    return styleObj;

};

// In order to avoid clashing with views interacting
// the style attribute directly we ignore everything that
// is either null or undefined
// TODO review this decision!
const _setOrNot = (styleObj, name, value) => {
    if(value !== null && value !== undefined){
        styleObj[name] = value;
    }
};

const _intToRotateDeg = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            n = n.split("deg")[0];
        }
        return `rotate(${n}deg)`;
    }
};


const _intToPx = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            if(n == "fill"){
                return "100%";
            } else if(["thin", "medium", "thick"].indexOf(n) > -1){
                return n;
            }
            n = n.split("px")[0];
        }
        return `${n}px`;
    }
};

// Convert colors to rgba
// change a css color RGB values, preserving the A(lpha) value
const _colorToRGBA = (cssColor, STColor) => {
    if(!STColor){
        return;
    }
    let r, g, b, a, _;
    // ST colors are RGB
    if(STColor.startsWith("rgb")){
        [r, g, b] = STColor.match(/\d+/g);
    } else {
        let colorInfo = basicCSSColors[STColor];
        if(colorInfo){
            r = colorInfo["r"];
            g = colorInfo["g"];
            b = colorInfo["b"];
        } else {
            return;
        }
    }
    if(cssColor){
        [_, _, _, a] = cssColor.match(/[\d\.]+/g);
        // if Alpha is not defined then we set it to 1
        // default for browsers
    }
    if(!a){
        a = 1;
    }
    return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// change the A(alpha) value, preserving the RGB values
const _colorTransparencyToRGBA = (cssColor, tValue) => {
    if(!cssColor){
        return;
    }

    let r, g, b;
    let mappedColor = basicCSSColors[cssColor];
    if(mappedColor){
        r = mappedColor.r;
        g = mappedColor.g;
        b = mappedColor.b;
    } else {
        [r, g, b] = cssColor.match(/\d+/g);
    }
    
    return `rgba(${r}, ${g}, ${b}, ${tValue})`;
}

// Add more colors as needed
const basicCSSColors = {
    black: {hex: "#000000", r: 0, g: 0, b: 0},
		silver: {hex: "#C0C0C0", r: 192, g: 192, b: 192},
		gray: {hex: "#808080", r: 128, g: 128, b: 128},
		white: {hex: "#FFFFFF", r: 255, g: 255, b: 255},
		maroon: {hex: "#800000", r: 128, g: 0, b: 0},
		red: {hex: "#FF0000", r: 255, g: 0, b: 0},
		purple: {hex: "#800080", r: 128, g: 0, b: 128},
		fuchsia: {hex: "#FF00FF", r: 255, g: 0, b: 255},
		green: {hex: "#008000", r: 0, g: 128, b: 0},
		lime: {hex: "#00FF00", r: 0, g: 255, b: 0},
		olive: {hex: "#808000", r: 128, g: 128, b: 0},
		yellow: {hex: "#FFFF00", r: 255, g: 255, b: 0},
		navy: {hex: "#000080", r: 0, g: 0, b: 128},
		blue: {hex: "#0000FF", r: 0, g: 0, b: 255},
		teal: {hex: "#008080", r: 0, g: 128, b: 128},
		aqua: {hex: "#00FFFF", r: 0, g: 255, b: 255},
};

// take the css box-shadow property and return its
// components (offset-y, offset-x, blur, spread and color)
// if the value is not defined return a default
const _cssBoxShadow = (cssPropValue) =>{
    if(!cssPropValue){
        return ["0px", "0px", "0px", "0px", "rgba(0, 0, 0, 1)"];
    }
    let [intValues, rgba] = cssPropValue.split(" rgba");
    let [left, top, blur, spread] = intValues.split(" ");
    return [left, top, blur, spread, `rgba${rgba}`];
}




/***/ }),

/***/ "./js/objects/views/AreaView.js":
/*!**************************************!*\
  !*** ./js/objects/views/AreaView.js ***!
  \**************************************/
/*! exports provided: AreaView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaView", function() { return AreaView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AreaView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * AreaView
 * -------------------------------
 * I am a webcomponent representation
 * of an Area, which is a grouping of
 * Parts that have some kind of layout
 * specified
 */


const templateString = `
                <style>
                #area-wrapper {
                    display: inherit;
                    flex-direction: inherit;
                    flex-wrap: inherit;
                    align-items: inherit;
                    align-content: inherit;
                    justify-content: inherit;
                    position: relative; 
                    width: 100%;
                    height: 100%;
                    border-radius: inherit;
                }
                .clip {
                    overflow: hidden;  
                }
                .allow-scroll {
                    overflow: auto;
                }
                </style>
                <div id="area-wrapper">
                <slot></slot>
                </div>
`;

class AreaView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.clippingChanged = this.clippingChanged.bind(this);
        this.allowScrollingChanged = this.allowScrollingChanged.bind(this);

        // Prop change handlers
        this.onPropChange('clipping', this.clippingChanged);
        this.onPropChange('allow-scrolling', this.allowScrollingChanged);
    }

    afterModelSet(){
        let clipping = this.model.partProperties.getPropertyNamed(
            this.model,
            "clipping"
        );
        let allowScrolling = this.model.partProperties.getPropertyNamed(
            this.model,
            "allow-scrolling"
        );
        this.clippingChanged(clipping, this.model.id);
        this.allowScrollingChanged(allowScrolling, this.model.id);
    }

    clippingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('allow-scroll');
            wrapper.classList.add('clip');
        } else {
            wrapper.classList.remove('clip');
        }
    }

    allowScrollingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('clip');
            wrapper.classList.add('allow-scroll');
            // this.classList.add('outer-allow-scroll');
        } else {
            // this.classList.remove('outer-allow-scroll');
            wrapper.classList.remove('allow-scroll');
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        let layout = this.model.partProperties.getPropertyNamed(
            this.model,
            'layout'
        );
        let direction = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-direction'
        );
        if(layout != 'list'){
            contextMenu.addListItem(
                "Set Layout to List",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'list'
                    );
                }
            );
        } else {
            contextMenu.addListItem(
                "Set Layout to Strict",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'strict'
                    );
                }
            );
            if(direction == 'row'){
                contextMenu.addListItem(
                    "Set List Direction to Column",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'column'
                        );
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Set List Direction to Row",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'row'
                        );
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/AudioView.js":
/*!***************************************!*\
  !*** ./js/objects/views/AudioView.js ***!
  \***************************************/
/*! exports provided: AudioView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioView", function() { return AudioView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AudioView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <audio></audio>
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-music" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="6" cy="17" r="3"></circle>
    <circle cx="16" cy="17" r="3"></circle>
    <polyline points="9 17 9 4 19 4 19 17"></polyline>
    <line x1="9" y1="8" x2="19" y2="8"></line>
    </svg>
</div>
`;

// HTMLMediaElementStates copied from
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
const mediaStates = {
    0: "HAVE_NOTHING",
    1: "HAVE_METADATA",
    2: "HAVE_CURRENT_DATA",
    3: "HAVE_FUTURE_DATA",
    4: "HAVE_ENOUGH_DATA"
};

class AudioView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateAudioLink = this.updateAudioLink.bind(this);
        this.play = this.play.bind(this);
        this.pause = this.pause.bind(this);
    }

    afterConnected(){
        let audio = this._shadowRoot.querySelector("audio");
        audio.addEventListener('loadeddata', () => {
            let stateCode = audio.readyState;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "readyState",
                mediaStates[stateCode]
            );
        });

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        this.model.partProperties.setPropertyNamed(
            this.model,
            "readyState",
           "HAVE_NOTHING"
        );
        let audio = this._shadowRoot.querySelector("audio");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            audio.src = src;
        }
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", (value) => {
            let borderColor = "red";
            if(value == "HAVE_FUTURE_DATA" || value == "HAVE_ENOUGH_DATA"){
                borderColor = "green";
            };
            ["right", "left", "top", "bottom"].forEach((side) => {
                this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
            });
        });
        this.onPropChange("play", (value) => {
            if(value === true){
                this.play();
            } else if (value === false){
                this.pause();
            }
        });
        this.onPropChange("stop", (value) => {
            if(value === true){
                audio.currentTime = 0;
            }
        });
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <audio> element
                audio.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "audio",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    play(){
        // first make sure that the resource is ready
        let audio = this._shadowRoot.querySelector("audio");
        let readyState = this.model.partProperties.getPropertyNamed(this.model, "readyState");
        if(readyState == "HAVE_FUTURE_DATA" || readyState == "HAVE_ENOUGH_DATA"){
            audio.play();
        } else {
            alert(`audio is not ready; current state: ${readyState}`);
        }
    }

    pause(){
        this._shadowRoot.querySelector("audio").pause();
    }

    // re-loads the media, setting it back to the beggning
    stop(){
        this._shadowRoot.querySelector("audio").load();
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-audio-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for audio source');
        this.haloButton.addEventListener('click', this.updateAudioLink);
    }

    updateAudioLink(event){
        // Tells the model to update its
        // src link for the audio
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for audio:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadAudioFromSource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/BrowserView.js":
/*!*****************************************!*\
  !*** ./js/objects/views/BrowserView.js ***!
  \*****************************************/
/*! exports provided: BrowserView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserView", function() { return BrowserView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BrowserView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}
iframe {
    width: 100%;
    height: 100%;
}
</style>
<iframe frameborder="0" allowfullscreen></iframe>
`;

class BrowserView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateBrowserLink = this.updateBrowserLink.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let iframe = this._shadowRoot.querySelector("iframe");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            iframe.src = src;
        }
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <browser> element
                iframe.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "browser",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-browser-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for browser source');
        this.haloButton.addEventListener('click', this.updateBrowserLink);
    }

    updateBrowserLink(event){
        // Tells the model to update its
        // src link for the browser
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for browser:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'setURLTo',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/ButtonView.js":
/*!****************************************!*\
  !*** ./js/objects/views/ButtonView.js ***!
  \****************************************/
/*! exports provided: ButtonView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonView", function() { return ButtonView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ButtonView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * ButtonView
 * ---------------------------------------------------
 * I am a webcomponent representing a Button.
 */


const templateString = `
                <style>
                 .st-button-label {
                     user-select: none;
                     pointer-events: none;
                     text-overflow: ellipsis;
                     overflow: hidden;
                     max-width: 95%;
                     white-space: nowrap;
                 }
                </style>
                <span class="st-button-label">
                    <slot></slot><!-- Text of the Name -->
                </span>
`;

class ButtonView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bound methods
        this.setupPropHandlers = this.setupPropHandlers.bind(this);

        // Setup prop change handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('name', (value, partId) => {
            this.innerText = value;
        });
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let buttonName = this.model.partProperties.getPropertyNamed(this, "name");
        if(buttonName){
            this.innerText = buttonName;
        };
    }

    // override the base class implementation
    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }
};




/***/ }),

/***/ "./js/objects/views/CardView.js":
/*!**************************************!*\
  !*** ./js/objects/views/CardView.js ***!
  \**************************************/
/*! exports provided: CardView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardView", function() { return CardView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * CardView
 * --------------------------------------------------
 * I am a webcomponent representation of a Card.
 */



const templateString = `
                <style>
                </style>
                <slot></slot>
`;

class CardView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Bind component methods
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    // override the default class method
    onClick(event){
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            event.stopPropagation();
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        // Toolbox toggle hide/unhide
        let currentStack = window.System.getCurrentStackModel();
        let toolbox = currentStack.subparts.filter((part) => {
            let name = part.partProperties.getPropertyNamed(part, "name");
            return name == "Toolbox";
        })[0];
        // if there is no toolbox at all, that's weird but don't do anything
        if(toolbox){
            let hidden = toolbox.partProperties.getPropertyNamed(toolbox, "hide");
            if(hidden){
                contextMenu.addListItem(
                    "Unhide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", false);
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Hide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", true);
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/FieldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/FieldView.js ***!
  \***************************************/
/*! exports provided: FieldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldView", function() { return FieldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FieldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");
/* harmony import */ var _drawing_ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing/ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * FieldView
 * ---------------------------------
 * I am the view of an Field part.
 * I am an "interim" view intended to display
 * and edit plain text on a Card.
 * I should be replaced with a more comprehensive
 * implementation of Field/FieldView in the future.
 */






const haloEditButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tools" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M3 21h4l13 -13a1.5 1.5 0 0 0 -4 -4l-13 13v4" />
  <line x1="14.5" y1="5.5" x2="18.5" y2="9.5" />
  <polyline points="12 8 7 3 3 7 8 12" />
  <line x1="7" y1="8" x2="5.5" y2="9.5" />
  <polyline points="16 12 21 17 17 21 12 16" />
  <line x1="16" y1="17" x2="14.5" y2="18.5" />
</svg>
`;

const haloLockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-4a4 4 0 0 1 8 0v4"></path>
</svg>
`;

const haloUnlockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock-open" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-5a4 4 0 0 1 8 0"></path>
</svg>
`;

const fieldTemplateString = `
      <style>
        .field {
            display: flex;
            align-items: center;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: auto;
        }

        .field color-wheel {
            position: absolute;
        }

        .field-textarea {
            width: calc(100% - 5px);
            height: 100%;
            width: 100%;
            white-space: pre-wrap;
            overflow-wrap: anywhere;
        }

        /* Syntax Highlighting
 *---------------------------------------------------*/
span[data-st-rule="messageName"]{
    text-decoration: underline;
}

span[data-st-rule="keyword"]{
    font-weight: bold;
}

span[data-st-rule="ParameterList-item"]{
    font-style: italic;
    color: grey;
}


    </style>
    <div class="field">
        <div class="field-textarea" spellcheck="false"></div>
    </div>`;


function formatDoc(sCmd, sValue) {
  document.execCommand(sCmd, false, sValue); oDoc.focus();
}

class FieldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // this.editorCompleter = this.simpleTalkCompleter;
        this.textStyler = _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__["default"];  // we might want to consider a more programmatic way to set this
        this.editorCompleter = null;
        this.contextMenuOpen = false;
        this.haloLockUnlockButton = null;
        this.selectionRanges = {};
        this.wantsContextMenu = false;

        // Presets for syntax highlighting.
        // When highlighting is enabled, we will check
        // each line of the text for the following
        // grammatical rules:
        this._syntaxRules = [
            "MessageHandlerOpen",
            "MessageHandlerClose"
        ];

        this.template = document.createElement('template');
        this.template.innerHTML = fieldTemplateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onInput = this.onInput.bind(this);
        this.onBeforeInput = this.onBeforeInput.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onKeydown = this.onKeydown.bind(this);
        this.onMousedown = this.onMousedown.bind(this);
        this.openContextMenu = this.openContextMenu.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);
        this.doIt = this.doIt.bind(this);
        this.handleSelection = this.handleSelection.bind(this);
        this.openField = this.openField.bind(this);
        this.textToHtml = this.textToHtml.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.simpleTalkCompleter = this.simpleTalkCompleter.bind(this);
        this.initCustomHaloButtons = this.initCustomHaloButtons.bind(this);
        this.insertRange = this.insertRange.bind(this);
        this.setRangeInTarget = this.setRangeInTarget.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.highlightSyntax = this.highlightSyntax.bind(this);
        this.unhighlightSyntax = this.unhighlightSyntax.bind(this);

        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('editable', (value, id) => {
            this.textarea.setAttribute('contenteditable', value);
            if(value === true){
                this.haloLockUnlockButton = this.haloLockButton;
                this.classList.add("editable");
            } else if (value === false){
                this.haloLockUnlockButton = this.haloUnlockButton;
                this.classList.remove("editable");
            }
        });
        // 'text' is a DynamicProp whose setter will set the corresponding
        // value for `innerHTML`. This way we can have programmatic content
        // setting and still allow to not loose markup.
        // 'innerHTML' is a BasicProp. See how these are set, without
        // notification in this.onInput()
        this.onPropChange('innerHTML', (value, id) => {
            this.textarea.innerHTML = value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "text",
                this.textarea.innerText,
                false // do not notify, to avoid an infinite loop
            );
        });
    }

    afterConnected(){
        // The events here are added via the .addEventListener() API which is
        // distinct from the this.eventRespond() which uses the DOM element
        // element.onEvent API. This allows us to distnguish between "core"
        // system-web events that we don't want meddled with at the moment, like
        // entering text in a field, and ones exposed in the environemnt for scripting
        this.textarea = this._shadowRoot.querySelector('.field-textarea');

        this.textarea.addEventListener('input', this.onInput);
        //this.textarea.addEventListener('beforeinput', this.onBeforeInput);
        this.textarea.addEventListener('keydown', this.onKeydown);
        this.textarea.addEventListener('mousedown', this.onMousedown);
        // No need to add a click listener as the base PartView class does that

        // in order to deal with range insertions (for styling text fragments within
        // the textarea), we need to have the default paragraph tag = </br>. Otherwise
        // the insert new line is of the form <div></br><div> which causes the appearance
        // of newlines when nodes are inserted into a range
        //document.execCommand("defaultParagraphSeparator", false, "st-line");
    }

    afterDisconnected(){
        this.textarea.removeEventListener('input', this.onInput);
        //this.textarea.removeEventListener('beforeinput', this.onBeforeInput);
        this.textarea.removeEventListener('keydown', this.onKeydown);
        this.textarea.removeEventListener('mousedown', this.onMousedown);
    }

    afterModelSet(){
        this.textarea = this._shadowRoot.querySelector('.field-textarea');
        // If we have a model, set the value of the textarea
        // to the current html of the field model
        let innerHTML = this.model.partProperties.getPropertyNamed(
            this.model,
            'innerHTML'
        );
        this.textarea.innerHTML = innerHTML;

        let isEditable = this.model.partProperties.getPropertyNamed(this.model, "editable");
        this.textarea.setAttribute('contenteditable', isEditable);

        // setup the lock/unlock halo button
        this.initCustomHaloButtons();
        let editable = this.model.partProperties.getPropertyNamed(
            this.model,
            'editable'
        );
        if(editable === true){
            this.haloLockUnlockButton = this.haloLockButton;
            this.classList.add("editable");
        } else if (editable === false){
            this.haloLockUnlockButton = this.haloUnlockButton;
            this.classList.remove("editable");
        }
    }

    simpleTalkCompleter(element){
        let textContent = this.htmlToText(element);
        let startOfHandlerRegex = /^on\s(\w+)(\s|\n)+$/;
        let match = textContent.match(startOfHandlerRegex);
        if(match){
            let messageName = match[1];
            // if input break is a new line then an extra
            // <div></br></div> has beed added into the elemen already
            let tabLine = "\t\n";
            if(match[2] === "\n"){
                tabLine= "";
            }
            textContent = `${tabLine}end ${messageName}`;
            let innerHTML = this.textToHtml(textContent);
            element.insertAdjacentHTML("beforeend", innerHTML);
        }
        return element.innerHTML;
    }

    /*
     * I override my base-class's implementation to handle target related functionality
     */
    styleTextCSS(){
        let textarea = this._shadowRoot.querySelector('.field-textarea');
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            textarea.style[key] = value;
        });
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, this.textarea.innerHTML, cssStyle);
        }
    }

    /*
     * set a text-* property on selection to style the selected text
     * Note: this is done for every current selection, i.e. everthing
     * in this.selectionRanges
     */
    setSelection(propName, value){
        Object.values(this.selectionRanges).forEach((range) => {
            let currentStyle = {};
            // // if the document fragment has one child node and it's a span
            // // we should style that directly. This avoids unncessary DOM elements
            // // being created to wrap the contents, such as when styling is continually
            // // applied ot the same selection
            // let span;
            // if(docFragment.childNodes.length == 1 && docFragment.childNodes[0].nodeName == "SPAN"){
            //     span = docFragment.childNodes[0];
            //     // Note the use of Obejct.values here for the DOM style attribute object
            //     // that's weird
            //     Object.values(span.style).forEach((key) => {
            //         currentStyle[key] = span.style[key];
            //     });
            // } else {
            //     // we need to create a span element to wrap the contents in style
            //     span = document.createElement('span');
            //     // While tempting to use range.surroundContents() avoid this
            //     // since it will fail with a non-informative error if the range
            //     // includes partial nodes (ex text across various nodes)
            //     while (docFragment.childNodes.length){
            //         span.appendChild(docFragment.childNodes[0]);
            //     }
            // }
            let span = document.createElement('span');
            let cssObject = this.textStyler(currentStyle, propName, value);
            Object.keys(cssObject).forEach((key) => {
                span.style[key] = cssObject[key];
            });

            span.append(range.extractContents());
            range.insertNode(span);
            
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
            // if there is a target and range set then send the target an update message
            let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
            if(target){
                this.setRangeInTarget(target, this.textarea.innerHTML);
            }
        });
    }

    onBeforeInput(event){
        let selection = document.getSelection();
        let selectedRange = selection.getRangeAt(0);
        let range = selectedRange.cloneRange();

        let innerHTML = event.target.innerHTML;
        if(!innerHTML.endsWith("<div><br></div>")){
            innerHTML += "<div><br></div>";
            event.target.innerHTML = innerHTML;
        }
        
        if(event.inputType == "insertParagraph"){
            //event.stopPropagation();
            event.preventDefault();

            let br = document.createElement('br');
            let br2 = document.createElement('br');
            range.insertNode(br);
            range.collapse(false);
            range.insertNode(br2);
            range.setStartAfter(br2);
            range.setEndAfter(br2);
        }
    }

    onInput(event){
        let innerHTML = event.target.innerHTML;
        /*
        if(!innerHTML.endsWith("<br>")){
            innerHTML += "<br>";
            event.target.innerHTML = innerHTML;
        }
        */

        if(this.editorCompleter){
            // TODO sort out how this would work
            let innerHTML = event.target.innerHTML;
            innerHTML = this.editorCompleter(event.target);
        }

        this.model.partProperties.setPropertyNamed(
            this.model,
            'text',
            event.target.innerText,
            false // do not notify, to preserve contenteditable context
        );
        this.model.partProperties.setPropertyNamed(
            this.model,
            'innerHTML',
            event.target.innerHTML,
            false // do not notify
        );
        // Since we update the 'text' property without notification, the part/model
        // is not sent the "propertyChanged" message so we do so manually
        this.model.propertyChanged("text", event.target.innerText);
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, event.target.innerHTML);
        }
    }

    onKeydown(event){
        // prevent the default tab key to leave focus on the field
        if(event.key==="Tab"){
            event.preventDefault();
            //document.execCommand('insertHTML', false, '&#x9');
            let sel = document.getSelection();
            let range = sel.getRangeAt(0);

            let tabNodeValue = '\t';
            let tabNode = document.createTextNode(tabNodeValue);

            range.insertNode(tabNode);

            range.setStartAfter(tabNode);
            range.setEndAfter(tabNode);
        };
    }

    onMousedown(event){
        // clear all selections
        this.selectionRanges = {};
    }
    onClick(event){
        event.preventDefault();
        event.stopPropagation();
        if(event.button == 0){
            // if the shift key is pressed we toggle the halo
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else{
                let text = window.getSelection().toString();
                // if no text is selected we do nothing
                if(text){
                    // if the altKey is pressed we open the context ("do it") menu
                    if(event.altKey){
                        if(!this.contextMenuOpen){
                            this.openContextMenu();
                        }
                    } else {
                        this.handleSelection(event.metaKey);
                    }
                } else {
                    // make sure no context menu is open
                    if(this.contextMenuOpen){
                        this.closeContextMenu();
                    }
                    // clear all the selections
                    this.selectionRanges = {};
                }
            }
        }
    }

    /* I handle selected text, creating a new field model/view
     * for every range in the selection, keeping track of every range
     * in this.selection Object/dict so that modification can be inserted
     * back into the corresponding ranges.
     */
    handleSelection(openNewField){
        let selection = window.getSelection();
        for(let i=0; i < selection.rangeCount; i++){
            // make sure this is not a continuing selection
            // and that the range is not already registered
            let range = selection.getRangeAt(i);
            let currentRanges = Object.values(this.selectionRanges);
            if(currentRanges.indexOf(range) >= 0){
                continue;
            }
            // we generate our own range ids, since we want this to correspond to
            // selection order which is not respected by the browser selection object
            // to ensure we don't hit on other views' ranges by accident we need unique id's
            let rangeId = Date.now(); //TODO we need a better random id
            this.selectionRanges[rangeId] = range;
            if(openNewField){
                // open a field for each new selection and populate it with the range html
                this.openField(range, rangeId);
            }
        }
    }

    openField(range, rangeId){
        // create an HTML document fragment from the range to avoid dealing wiht start/end
        // and offset calculations
        // fragments don't have the full html DOM element API so we need to create one
        let span = document.createElement('span');
        span.appendChild(range.cloneContents());

        // TODO these should all be messages and correspnding command handler definitions
        // should be part of the field's own script
        let fieldModel = window.System.newModel("field", this.model._owner.id, `selection ${rangeId}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "innerHTML", span.innerHTML);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "target", `field id ${this.model.id}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "targetRangeId", rangeId);
    }

    /**
      * Given a tagrget specifier and html
      * I first look up to make sure that the target has the corresponding
      * range (coming from the targetRangeId property), and then set it with my
      * innerHTML. Note, since the target property value is an object specifier I
      * create a semantics objects and interpret the value resulting in a valid
      * part id.
      */
    setRangeInTarget(targetSpecifier, html, css){
        let targetRangeId = this.model.partProperties.getPropertyNamed(this.model, 'targetRangeId');
        let match = window.System.grammar.match(targetSpecifier, "ObjectSpecifier");
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation('interpret', Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this.model, window.System));
        let targetId = semantics(match).interpret();

        this.model.sendMessage({
            type: "command",
            commandName: "insertRange",
            args: [targetRangeId, html, css]
        }, window.System.partsById[targetId]);
    }

    /*
     * I insert the html (string) into the specified range (by id)
     */
    insertRange(rangeId, html, cssObj){
        let range = this.selectionRanges[rangeId];
        if(range){
            let span = document.createElement('span');
            span.innerHTML = html;
            if(cssObj){
                Object.keys(cssObj).forEach((key) => {
                    let value = cssObj[key];
                    span.style[key] = value;
                });
            }
            range.deleteContents();
            range.insertNode(span);
            // update the text and innerHTML properties without notification
            // to prevent unnecessary setting of the text/html
            this.model.partProperties.setPropertyNamed(
                this.model,
                'text',
                this.textarea.innerText,
                false // do not notify, to preserve contenteditable context
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
        }
    }

    openContextMenu(){
        let text = document.getSelection().toString();
        let focusNode = document.getSelection().focusNode;
        let button = document.createElement("button");
        button.id = "doIt";
        button.style.marginLeft = "10px";
        button.style.backgroundColor = "var(--palette-green)";
        button.textContent = "Do it!";
        button.addEventListener("click", this.doIt);
        focusNode.after(button);
        this.contextMenuOpen = true;
    };

    closeContextMenu(){
        let button = this._shadowRoot.querySelector('#doIt');
        if(button){
            button.remove();
        }
        // clear the selection and set the context menu to closed
        document.getSelection().removeAllRanges();
        this.contextMenuOpen = false;
    }

    doIt(event){
        event.stopPropagation();
        let text = document.getSelection().toString();
        // clean up the text to make sure no newlines or spaces made it in
        text = text.replace(/^[\t\n ]+/, "");
        text = text.replace(/[\t\n ]+$/, "");
        this.closeContextMenu();
        // send message to compile the prepped script
        let script = `on doIt\n   ${text}\nend doIt`;
        // send these messages from the model (not the view)
        // since if there is an error the original sender will
        // have an id
        this.model.sendMessage(
            {
                type: "compile",
                codeString: script,
                targetId: this.model.id
            },
            this.model
        );
        this.model.sendMessage(
            {
                type: "command",
                commandName: "doIt",
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            },
            this.model
        );
    }

    initCustomHaloButtons(){
        this.haloLockButton = document.createElement('div');
        this.haloLockButton.id = "halo-field-lock-editor";
        this.haloLockButton.classList.add('halo-button');
        this.haloLockButton.innerHTML = haloLockButtonSVG;
        this.haloLockButton.style.marginRight = "6px";
        this.haloLockButton.setAttribute('slot', 'bottom-row');
        this.haloLockButton.setAttribute('title', 'Lock Editing');
        this.haloLockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", false],
            }, this.model);
            this.closeHalo();
            this.openHalo();
            // close/open the halo to update the editing state toggle button
        });
        this.haloUnlockButton = document.createElement('div');
        this.haloUnlockButton.id = "halo-field-unlock-editor";
        this.haloUnlockButton.classList.add('halo-button');
        this.haloUnlockButton.innerHTML = haloUnlockButtonSVG;
        this.haloUnlockButton.style.marginRight = "6px";
        this.haloUnlockButton.setAttribute('slot', 'bottom-row');
        this.haloUnlockButton.setAttribute('title', 'Unlock Editing');
        this.haloUnlockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", true],
            }, this.model);
            // close/open the halo to update the editing state toogle button
            this.closeHalo();
            this.openHalo();
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloLockUnlockButton);
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }


    /*
     * I convert raw text to html respecting the Firefox
     * contenteditable attribute guidelnes.
     * This means that single lins of text are left as is;
     * multiline text, i.e. text which includes "\n", is
     * wrapped in <div></div> for every line; and the last
     * line gets a <br> tag inserted before the </div> to reflect
     * the "on-enter-key" behavior.
     */
    textToHtml(text){
        if(text){
            let textLines = text.split("\n");
            if(textLines.length > 1){
                let html = "";
                textLines.forEach((line) => {
                    if(line){
                        html += `<div>${line}</div>`;
                    } else {
                        html += "<div><br></div>";
                    }
                });
                return  `<div>${html}<br></div>`;
            } else {
                return text;
            }
        } else {
            return "";
        }
    }

    htmlToText(element){
        // TODO this is very naive and ignores most possible structure
        if(element.innerHTML){
            // first replace all the "</div><div>" with line breaks
            let cleanHTML =  element.innerHTML.replace(/<\/div><div>/g, "\n");
            // then remove all html
            let tempElement = document.createElement("div");
            tempElement.innerHTML = cleanHTML;
            let cleanText = tempElement.textContent;
            tempElement.remove();
            return cleanText;
        } else {
            return "";
        }
    }

    highlightSyntax(){
        let current = this.getAttribute("syntax");
        if(current && current !== "false"){
            this.unhighlightSyntax();
        }
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation(
            "highlightSyntax",
            Object(_utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
        );
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let newHTML = text.split("\n").map(line => {
            // Loop through each rule and try to match
            for(let i = 0; i < this._syntaxRules.length; i++){
                let rule = this._syntaxRules[i];
                let match = window.System.grammar.match(line, rule);
                if(match.succeeded()){
                    return semantics(match).highlightSyntax().outerHTML;
                }
            }
            return line;
        }).join("\n");

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", true);
    }

    unhighlightSyntax(){
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let plainElements = text.split("\n").map(line => {
            let div = document.createElement("div");
            div.innerText = line;
            return div;
        });
        let finalLine = document.createElement("div");
        finalLine.append(document.createElement("br"));
        plainElements.push(finalLine);

        let newHTML = "";
        plainElements.forEach(element => {
            newHTML += element.outerHTML;
        });

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", false);
    }
};




/***/ }),

/***/ "./js/objects/views/Halo.js":
/*!**********************************!*\
  !*** ./js/objects/views/Halo.js ***!
  \**********************************/
/*! exports provided: Halo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Halo", function() { return Halo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Halo; });
/**
 * New Halo
 */

/** Note: Icons are from 
*** https://tablericons.com/
**/
const deleteIcon =`
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-trash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="4" y1="7" x2="20" y2="7" />
  <line x1="10" y1="11" x2="10" y2="17" />
  <line x1="14" y1="11" x2="14" y2="17" />
  <path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" />
  <path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" />
</svg>
`;
const editIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-edit" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 7h-3a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-3" />
  <path d="M9 15h3l8.5 -8.5a1.5 1.5 0 0 0 -3 -3l-8.5 8.5v3" />
  <line x1="16" y1="5" x2="19" y2="8" />
</svg>
`;
const growIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrows-diagonal-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="16 20 20 20 20 16" />
  <line x1="14" y1="14" x2="20" y2="20" />
  <polyline points="8 4 4 4 4 8" />
  <line x1="4" y1="4" x2="10" y2="10" />
</svg>
`;

const copyIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="8" y="8" width="12" height="12" rx="2"></rect>
   <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path>
</svg>
`;

const pasteIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2"></path>
   <rect x="9" y="3" width="6" height="4" rx="2"></rect>
   <path d="M9 14l2 2l4 -4"></path>
</svg>
`;

const targetIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-focus" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <circle cx="12" cy="12" r=".5" fill="currentColor"></circle>
   <circle cx="12" cy="12" r="9"></circle>
</svg>
`;

const settingsIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-settings" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z" />
  <circle cx="12" cy="12" r="3" />
</svg>
`;

const rotateIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rotate-clockwise" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M4.05 11a8 8 0 1 1 .5 4m-.5 5v-5h5"></path>
</svg>
`;

const templateString = `
<style>
 :host {
     --halo-button-height: 25px;
     --halo-button-width: 25px;
     --halo-rim-margin: 10px;
     --halo-button-width-padded: calc(var(--halo-button-width) + var(--halo-rim-margin));
     --halo-button-height-padded: calc(var(--halo-button-height) + var(--halo-rim-margin));
     position: absolute;
     box-sizing: border-box;
     top: calc(-1 * var(--halo-button-height-padded));
     left: calc(-1 * var(--halo-button-width-padded));
     width: calc(100% + (2 * var(--halo-button-width-padded)));
     height: calc(100% + (2 * var(--halo-button-height-padded)));
     color: initial;
     z-index: 10;
 }


 .halo-row,
 .halo-column {
     display: flex;
     position: absolute;
 }

 .halo-column {
     flex-direction: column;
 }

 #halo-top-row,
 #halo-bottom-row {
     width: calc(100% - var(--halo-button-width-padded));
     height: var(--halo-button-height-padded);
 }

 #halo-top-row {
     left: 0;
     top: 0;
 }

 #halo-bottom-row {
     right: 0;
     bottom: 0;
     flex-direction: row-reverse;
     align-items: flex-end;
 }

 #halo-right-column,
 #halo-left-column {
     height: calc(100% - var(--halo-button-height-padded));
     width: var(--halo-button-width-padded);
 }

 #halo-right-column {
     right: 0;
     top: 0;
     align-items: flex-end;
 }

 #halo-left-column {
     left: 0;
     top: var(--halo-button-height-padded);
 }

 .halo-button,
 ::slotted(*) {
     display: block;
     border: 1px solid rgba(100, 100, 100, 0.8);
     width: var(--halo-button-width);
     height: var(--halo-button-height);
     background-color: rgb(220, 220, 220);
 }

 .halo-button:hover
 ::slotted(*).halo-button:hover {
     cursor: pointer;
 }

 .halo-button:active
 ::slotted(*).halo-button:active {
     border: 1px solid black;
 }

 .halo-button.hidden
 ::slotted(*).halo-button.hidden {
     display: none;
 }

</style>

<div id="halo-top-row" class="halo-row">
    <div id="halo-delete" class="halo-button" title="Delete this part">
        ${deleteIcon}
    </div>
    <slot name="top-row"></slot>
</div>

<div id="halo-bottom-row" class="halo-row">
    <div id="halo-resize" class="halo-button" title="Resize this part">
        ${growIcon}
    </div>
    <div id="halo-script-edit" class="halo-button" title="Edit this part's script">
        ${editIcon}
    </div>
    <div id="halo-edit" class="halo-button" title="Edit this part">
        ${settingsIcon}
    </div>
    <slot name="bottom-row"></slot>
</div>

<div id="halo-left-column" class="halo-column">
    <div id="halo-copy" class="halo-button" title="Copy this Part">
        ${copyIcon}
    </div>
    <div id="halo-paste" class="halo-button" title="Paste the contents of clipboard into this Part">
        ${pasteIcon}
    </div>
    <div id="halo-target" class="halo-button" title="Select this Part's target">
        ${targetIcon}
    </div>
    <slot name="left-column"></slot>
</div>

<div id="halo-right-column" class="halo-column">
    <div id="halo-rotate" class="halo-button" title="Rotate this part">
        ${rotateIcon}
    </div>
    <slot name="right-column"></slot>
</div>

`;

class Halo extends HTMLElement {
    constructor(){
        super();

        // Configure the Shadow DOM and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind component methods


        // Bind event listeners
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onResizeMouseDown = this.onResizeMouseDown.bind(this);
        this.onResizeMouseUp = this.onResizeMouseUp.bind(this);
        this.onResizeMouseMove = this.onResizeMouseMove.bind(this);
        this.onRotateMouseDown = this.onRotateMouseDown.bind(this);
        this.onRotateMouseUp = this.onRotateMouseUp.bind(this);
        this.onRotateMouseMove = this.onRotateMouseMove.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.targetElement = this.getRootNode().host;
            this.targetElement.classList.add('editing');
            this.targetElement.hasOpenHalo = true;

            // Add event listeners
            this.addEventListener('mousedown', this.onMouseDown);

            // Resize button
            this.resizer = this.shadowRoot.getElementById('halo-resize');
            this.resizer.addEventListener('mousedown', this.onResizeMouseDown);
            if(!this.targetElement.wantsHaloResize){
                this.resizer.style.visibility = 'hidden';
            }

            // Rotate button
            this.rotater = this.shadowRoot.getElementById('halo-rotate');
            this.rotater.addEventListener('mousedown', this.onRotateMouseDown);
            if(!this.targetElement.wantsHaloRotate){
                this.rotater.style.visibility = 'hidden';
            }
            // Delete button
            this.deleter = this.shadowRoot.getElementById('halo-delete');
            this.deleter.addEventListener('click', this.targetElement.onHaloDelete);
            if(!this.targetElement.wantsHaloDelete){
                this.deleter.style.visibility = 'hidden';
            }

            // Edit button
            this.scriptEditor = this.shadowRoot.getElementById('halo-script-edit');
            this.scriptEditor.addEventListener('click', this.targetElement.onHaloOpenScriptEditor);
            if(!this.targetElement.wantsHaloScriptEdit){
                this.scriptEditor.style.visibility = 'hidden';
            }

            // Comprehensive editor button
            this.editor = this.shadowRoot.getElementById('halo-edit');
            this.editor.addEventListener('click', this.targetElement.onHaloOpenEditor);
            if(!this.targetElement.wantsHaloEdit){
                this.editor.style.visibility = 'hidden';
            }

            // Copy button
            this.copier = this.shadowRoot.getElementById('halo-copy');
            this.copier.addEventListener('click', this.targetElement.onHaloCopy);


            // Paste button
            this.paster = this.shadowRoot.getElementById('halo-paste');
            this.paster.addEventListener('click', this.targetElement.onHaloPaste);

            // Target button
            this.targeter = this.shadowRoot.getElementById('halo-target');
            this.targeter.addEventListener('click', this.targetElement.onHaloTarget);
            this.targeter.addEventListener('mouseenter', this.targetElement.onHaloTargetButtonMouseEnter);
            this.targeter.addEventListener('mouseleave', this.targetElement.onHaloTargetButtonMouseLeave);
        }
    }

    disconnectedCallback(){
        this.targetElement.classList.remove('editing');
        this.targetElement.hasOpenHalo = false;

        // Remove event listeners
        this.removeEventListener('mousedown', this.onMouseDown);
        this.resizer.removeEventListener('mousedown', this.onResizeMouseDown);
    }


    /* Event Handling */
    onMouseDown(event){
        if(event.button == 0 && this.targetElement.wantsHaloMove){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        let currentTop = parseInt(this.targetElement.style.top);
        let currentLeft = parseInt(this.targetElement.style.left);
        let newTop = event.movementY + currentTop;
        let newLeft = event.movementX + currentLeft;

        let model = this.targetElement.model;
        model.partProperties.setPropertyNamed(model, "top", newTop);
        model.partProperties.setPropertyNamed(model, "left", newLeft);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    onResizeMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onResizeMouseMove);
        document.addEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseUp(event){
        document.removeEventListener('mousemove', this.onResizeMouseMove);
        document.removeEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseMove(event){
        this.targetElement.onHaloResize(
            event.movementX,
            event.movementY
        );
    }

    onRotateMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onRotateMouseMove);
        document.addEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseUp(event){
        document.removeEventListener('mousemove', this.onRotateMouseMove);
        document.removeEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseMove(event){
        this.targetElement.onHaloRotate(
            event.movementX,
            event.movementY
        );
    }
};




/***/ }),

/***/ "./js/objects/views/ImageView.js":
/*!***************************************!*\
  !*** ./js/objects/views/ImageView.js ***!
  \***************************************/
/*! exports provided: ImageView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageView", function() { return ImageView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const pictureIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <line x1="15" y1="8" x2="15.01" y2="8"></line>
   <rect x="4" y="4" width="16" height="16" rx="3"></rect>
   <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5"></path>
   <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2"></path>
</svg>
`;

const templateString = `
<img id="wrapped-image" class="hidden" />
<svg class="hidden" id="wrapped-svg" xmlns="http://www.w3.org/2000/svg">
</svg>
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    user-select: none;
}

.hidden {
    display: none;
}
img {
    width: 100%;
    height: auto;
    display: block;
}

.currently-wrapped {
    width: 100%;
    height: 100%;
}
</style>
`;

class ImageView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.updateImageData = this.updateImageData.bind(this);
        this.updateSvgImage = this.updateSvgImage.bind(this);
        this.updateBinaryImage = this.updateBinaryImage.bind(this);
        this.setDefaultImage = this.setDefaultImage.bind(this);
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateImageLink = this.updateImageLink.bind(this);
        this.updateSizingForViewport = this.updateSizingForViewport.bind(this);
    }

    afterModelSet(){
        // prop changes
        this.onPropChange("imageData", (imageData) => {
            if(!imageData){
                this.setDefaultImage();
            }
            this.updateImageData(imageData);
        });

        // Make sure we have imageData. If not, try
        // to load from a src.
        let currentImageData = this.model.partProperties.getPropertyNamed(
            this.model,
            "imageData"
        );
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            "src"
        );
        if(!currentImageData){
            if(currentSrc){
                let msg = {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ currentSrc ]
                };
                this.model.sendMessage(msg, this.model);
            } else {
                this.setDefaultImage();
            }
        } else {
            this.updateImageData(currentImageData);
        }
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    setDefaultImage(){
        this.model.partProperties.setPropertyNamed(this.model, "imageData", pictureIcon);
        this.model.partProperties.setPropertyNamed(this.model, "mimeType", "image/svg");
        this.model.partProperties.setPropertyNamed(this.model, "src", "");
        this.updateImageData(pictureIcon);
    }

    updateImageData(imageData){
        if(this.model.isSvg){
            this.updateSvgImage(imageData);
        } else {
            this.updateBinaryImage(imageData);
        }
    }

    updateBinaryImage(imageData){
        // In this case, the imageData is
        // a base64 encoded data url describing
        // the bits of the image.
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let svgEl = this._shadowRoot.getElementById('wrapped-svg');
        svgEl.classList.add('hidden');
        svgEl.classList.remove('currently-wrapped');
        imgEl.classList.add('currently-wrapped');
        imgEl.src = imageData;
        imgEl.onload = () => {
            //this.updateSizingForViewport();
        };
        this.preserveAspectOnResize = true;
        imgEl.classList.remove('hidden');
    }

    updateSvgImage(imageData){
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let currentSvgEl = this._shadowRoot.getElementById('wrapped-svg');
        let parser = new DOMParser();
        let xmlDocument = parser.parseFromString(imageData, 'application/xml');
        let newSvgEl = xmlDocument.documentElement;

        // Ensure that the SVG has some width and height attributes
        // set so we have initial dimensions to display. If not present,
        // pull from viewbox.
        if(!newSvgEl.hasAttribute('width') || !newSvgEl.hasAttribute('height')){
            let viewBox = newSvgEl.getAttribute('viewBox');
            if(viewBox){
                viewBox = viewBox.split(" ");
                let viewBoxWidth = parseInt(viewBox[2]);
                let viewBoxHeight = parseInt(viewBox[3]);
                newSvgEl.setAttribute('height', viewBoxHeight);
                newSvgEl.setAttribute('width', viewBoxWidth);
            }
        } 
        newSvgEl.id = 'wrapped-svg';
        newSvgEl.classList.add('currently-wrapped');
        imgEl.classList.add('hidden');
        imgEl.classList.remove('currently-wrapped');
        currentSvgEl.remove();
        this._shadowRoot.appendChild(newSvgEl);
        this.updateSizingForViewport();
        this.preserveAspectOnResize = false;
    }

    updateImageLink(event){
        // Tells the model to update its
        // src link for the image
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for image:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ result ]
                },
                this.model
            );
        }
    }

    updateSizingForViewport(){
        // Ensure that this component does not display larger
        // than the current remaining subrectangle of its origin
        // and the corner of the viewport
        let padding = 40;
        // First, we need to find the absolute top corner
        // locations for the element
        let el = this._shadowRoot.querySelector('.currently-wrapped');
        let top = 0;
        let left = 0;
        while(el){
            top += el.offsetTop;
            left += el.offsetLeft;
            el = el.offsetParent;
        }

        let rect = this.getBoundingClientRect();
        let heightLimit = document.documentElement.clientHeight - padding;
        if((rect.height + top) > heightLimit){
            let ratio = (heightLimit - top) / rect.height;
            // this.style.height = `${rect.height * ratio}px`;
            // this.style.width = `${rect.width * ratio}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                (rect.width * ratio)
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                (rect.height * ratio)
            );
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    onHaloResize(movementX, movementY){
        // Override default behavior.
        // We resize the wrapped svg or img instead
        // and have the outer component simply react to
        // the change.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let wrappedImage = this._shadowRoot.querySelector('.currently-wrapped');
        let rect = wrappedImage.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let maxWidth = rect.width + movementX;
            let maxHeight = rect.height + movementY;
            let ratio = Math.min(maxWidth / rect.width, maxHeight / rect.height);
            newHeight = rect.height * ratio;
            newWidth = rect.width * ratio;
        } else {
            newWidth = rect.width + movementX;
            newHeight = rect.height + movementY;
        }

        if(newWidth && newHeight){
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight
            );
        }
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-image-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for image file');
        this.haloButton.addEventListener('click', this.updateImageLink);
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        contextMenu.addListItem(
            'Edit Image URL',
            this.updateImageLink
        );
    }
};




/***/ }),

/***/ "./js/objects/views/PartView.js":
/*!**************************************!*\
  !*** ./js/objects/views/PartView.js ***!
  \**************************************/
/*! exports provided: PartView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartView", function() { return PartView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartView; });
/* harmony import */ var _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contextmenu/ContextMenu.js */ "./js/objects/views/contextmenu/ContextMenu.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/**
 * PartView
 * ----------------------------------------
 * I am an *abstract* webcompoent CustomElement
 * that serves as the generic view for any Part
 * models.
 * I should not be instantiated directly, nor should
 * I be added to any web page's registry of CustomElements.
 * I am indended to be extended (subclassed) by the actual
 * views for each Part kind, and therefore I contain all
 * of the common behavior, including lifecycle methods,
 * for these.
 */



window.customElements.define('st-context-menu', _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

class PartView extends HTMLElement {
    constructor(){
        super();
        this.model = null;
        this.isPartView = true;
        this.isLensed = false;
        this.name = this.constructor.name;
        this.propChangeHandlers = {};
        this.setupBasePropHandlers();
        this.viewChangeHandlers = {};
        this.setupBaseViewChangeHandlers();

        // Halo settings. All are on by default
        this.wantsHaloResize = true;
        this.wantsHaloRotate = true;
        this.wantsHaloScriptEdit = true;
        this.wantsHaloEdit = true;
        this.wantsHaloDelete = true;
        this.wantsHalo = true;
        // Note: see getter for wantsHaloMove

        // Context menu settings
        this.wantsContextMenu = true;

        // Bind component methods
        this.setModel = this.setModel.bind(this);
        this.unsetModel = this.unsetModel.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.setupBasePropHandlers = this.setupBasePropHandlers.bind(this);
        this.setupBaseViewChangeHandlers = this.setupBaseViewChangeHandlers.bind(this);
        this.initLayout = this.initLayout.bind(this);

        // Bind initial property method
        this.styleCSS = this.styleCSS.bind(this);
        this.styleTextCSS = this.styleTextCSS.bind(this);

        // Bind property change reaction methods
        this.primHandlePropChange = this.primHandlePropChange.bind(this);
        this.onPropChange = this.onPropChange.bind(this);
        this.primHandleViewChange = this.primHandleViewChange.bind(this);
        this.onViewChange = this.onViewChange.bind(this);
        this.scriptChanged = this.scriptChanged.bind(this);
        this.layoutChanged = this.layoutChanged.bind(this);
        this.listDirectionChanged = this.listDirectionChanged.bind(this);
        this.listWrappingChanged = this.listWrappingChanged.bind(this);
        this.vResizingChanged = this.vResizingChanged.bind(this);
        this.hResizingChanged = this.hResizingChanged.bind(this);
        this.pinningLeftChanged = this.pinningLeftChanged.bind(this);
        this.pinningTopChanged = this.pinningTopChanged.bind(this);
        this.pinningBottomChanged = this.pinningBottomChanged.bind(this);
        this.pinningRightChanged = this.pinningRightChanged.bind(this);
        this.listAlignmentChanged = this.listAlignmentChanged.bind(this);
        this.listDistributionChanged = this.listDistributionChanged.bind(this);

        // Bind view change reaction methods
        this.subpartOrderChanged = this.subpartOrderChanged.bind(this);
        this.newSubpartView = this.newSubpartView.bind(this);

        // Bind Halo related methods
        this.openHalo = this.openHalo.bind(this);
        this.closeHalo = this.closeHalo.bind(this);
        this.onHaloDelete = this.onHaloDelete.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onHaloOpenScriptEditor = this.onHaloOpenScriptEditor.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.onHaloRotate = this.onHaloRotate.bind(this);
        this.onHaloPaste = this.onHaloPaste.bind(this);
        this.onHaloCopy = this.onHaloCopy.bind(this);
        this.onHaloTarget = this.onHaloTarget.bind(this);
        this.endHaloTarget = this.endHaloTarget.bind(this);
        this.onHaloTargetButtonMouseEnter = this.onHaloTargetButtonMouseEnter.bind(this);
        this.onHaloTargetButtonMouseLeave = this.onHaloTargetButtonMouseLeave.bind(this);
        this.onHaloActivationClick = this.onHaloActivationClick.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onAuxClick = this.onAuxClick.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onContextMenuClick = this.onContextMenuClick.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.handleTargetKey = this.handleTargetKey.bind(this);
        this.handleTargetMouseClick = this.handleTargetMouseClick.bind(this);
        this.handleTargetMouseOver = this.handleTargetMouseOver.bind(this);
        this.handleTargetMouseOut = this.handleTargetMouseLeave.bind(this);
        this.addContextMenuItems = this.addContextMenuItems.bind(this);
        this.getCurrentTargetViews = this.getCurrentTargetViews.bind(this);

        // Bind editor related methods
        this.openEditor = this.openEditor.bind(this);
        this.closeEditor = this.closeEditor.bind(this);

        // Context menu
        this.openContextMenuAt = this.openContextMenuAt.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);

        // misc
        this.highlight = this.highlight.bind(this);
        this.unhighlight = this.unhighlight.bind(this);

        // Bind lifecycle methods
        this.afterModelSet = this.afterModelSet.bind(this);
        this.afterModelUnset = this.afterModelUnset.bind(this);
        this.afterConnected = this.afterConnected.bind(this);
        this.afterDisconnected = this.afterDisconnected.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Do some universal PartView configuration
            // when attached to a parent element, like
            // registering event listeners etc

            // Register middle mouse button click
            // to toggle the halo
            this.addEventListener('auxclick', this.onAuxClick);

            // Register default event handlers manually]
            this.addEventListener('click', this.onClick);
            this.addEventListener('contextmenu', this.onContextMenuClick);

            // Call the lifecycle method when done
            // with the above
            this.afterConnected();
        }
    }

    disconnectedCallback(){
        this.removeEventListener('auxclick', this.onAuxClick);
        this.removeEventListener('click', this.onClick);
        this.removeEventListener('contextmenu', this.onContextMenuClick);
        this.afterDisconnected();
    }

    setModel(aModel){
        this.unsetModel();
        this.model = aModel;
        aModel.addPropertySubscriber(this);
        aModel.addViewSubscriber(this);
        if(this.isLensed){
            this.removeAttribute('part-id');
            this.setAttribute('lens-part-id', aModel.id);
        } else {
            this.removeAttribute('lens-part-id');
            this.setAttribute('part-id', aModel.id);
        }
        // deal with 'special' props
        let wantsMove = this.model.partProperties.getPropertyNamed(
            this.model,
            "wants-move"
        );
        if(wantsMove){
            this.addEventListener('mousedown', this.onMouseDown);
        }

        // load all the initial styling
        this.styleCSS();
        this.styleTextCSS();
        this.initLayout();
        this.afterModelSet();
    }

    unsetModel(){
        if(this.model){
            let removedModel = this.model;
            this.model.removePropertySubscriber(this);
            this.model = null;
            this.setAttribute('part-id', "");
            this.afterModelUnset(removedModel);
        }
    }

    setupBasePropHandlers(){
        // This is where we should setup any
        // prop change handlers that are universal
        // to all PartViews. We would do this via
        // the #onPropChange method, which registers
        // a handler function.
        // Do not override this method
        // TODO: Implement the universals
        this.onPropChange('script', this.scriptChanged);
        this.onPropChange('number', this.numberChanged);
        this.onPropChange('cssStyle', this.styleCSS);
        this.onPropChange('cssTextStyle', this.styleTextCSS);
        this.onPropChange('layout', this.layoutChanged);
        this.onPropChange('list-direction', this.listDirectionChanged);
        this.onPropChange('list-wrapping', this.listWrappingChanged);
        this.onPropChange('list-alignment', this.listAlignmentChanged);
        this.onPropChange('list-distribution', this.listDistributionChanged);
        this.onPropChange('horizontal-resizing', this.hResizingChanged);
        this.onPropChange('vertical-resizing', this.vResizingChanged);
        this.onPropChange('pinning-top', this.pinningTopChanged);
        this.onPropChange('pinning-right', this.pinningRightChanged);
        this.onPropChange('pinning-left', this.pinningLeftChanged);
        this.onPropChange('pinning-bottom', this.pinningBottomChanged);
        this.onPropChange('wants-move', (value) => {
            if(value){
                this.addEventListener('mousedown', this.onMouseDown);
            } else {
                this.removeEventListener('mousedown', this.onMouseDown);
            }
        });
    }

    setupBaseViewChangeHandlers(){
        // This is where we should setup any
        // view change handlers that are universal
        // to all PartViews. We would do this via
        // the #onViewChange method, which registers
        // a handler function.
        // Do not override this method
        this.onViewChange('subpart-order', this.subpartOrderChanged);
        this.onViewChange('subpart-new', this.newSubpartView);
    }

    initLayout(){
        // Not all Part/PartView pairs have the layout
        // properties. Ensure they exist first
        let hasLayout = this.model.partProperties.findPropertyNamed('layout');
        let hasBoxResizing = this.model.partProperties.findPropertyNamed('vertical-resizing');
        let hasPinning = this.model.partProperties.findPropertyNamed('pinning');
        if(hasLayout){
            let initialLayout = this.model.partProperties.getPropertyNamed(
                this.model,
                'layout'
            );
            let initialListDirection = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-direction'
            );
            let initialListWrapping = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-wrapping'
            );
            this.layoutChanged(initialLayout);
            this.listDirectionChanged(initialListDirection);
            this.listWrappingChanged(initialListWrapping);
            this.listAlignmentChanged();
            this.listDistributionChanged();
        }

        if(hasBoxResizing){
            let initialVResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'vertical-resizing'
            );
            let initialHResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'horizontal-resizing'
            );
            this.vResizingChanged(initialVResizing);
            this.hResizingChanged(initialHResizing);
        }

        if(hasPinning){
            this.pinningTopChanged();
            this.pinningBottomChanged();
            this.pinningLeftChanged();
            this.pinningRightChanged();
        }
    }

    styleCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    styleTextCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    sendMessage(aMessage, target){
        if(!this.isLensed){
            // Lensed views should not send messages
            window.System.sendMessage(aMessage, this, target);
        }
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            this.primHandlePropChange(
                aMessage.propertyName,
                aMessage.value,
                aMessage.partId
            );
            break;
        case 'viewChanged':
            this.primHandleViewChange(
                aMessage.changeName,
                ...aMessage.args
            );
            break;
        }
    }

    primHandlePropChange(name, value, partId){
        // We notify the model that the property change so that
        // on propertyChanged command handlers could be invoked
        // but we make sure that this stops at the said model and
        // does not go up the delegation chain
        let commandMessage = {
            type: 'command',
            commandName: 'propertyChanged',
            args: [name, value],
            shouldNotDelegate:true, // do not send this up the delegation chain
            shouldIgnore: true
        };
        this.sendMessage(commandMessage, this.model);
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.propChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(value, partId);
    }


    onPropChange(name, func){
        this.propChangeHandlers[name] = func;
    }

    primHandleViewChange(name, ...args){
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.viewChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(...args);
    }

    onViewChange(name, func){
        this.viewChangeHandlers[name] = func;
    }

    scriptChanged(value, partId){
        // make sure that we are only sending the compile
        // message when dealing with a 'core' st-part views (not
        // with navigator or related views)
        if(this.tagName.split("-")[0] != "ST" || this.slot == "wrapped-view"){
            return;
        }
        this.model.sendMessage({
            type: 'compile',
            codeString: value,
            targetId: partId
        }, window.System);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        // there is no need to do anything for the wrapped views
        // CardRow and StackRow will handle the updates
        if(this.name == "WrappedView"){
            return;
        }
        let subpartNode = this.childNodes[currentIndex];
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
    }

    newSubpartView(newView){
        this.appendChild(newView);
    }

    layoutChanged(value, partId){
        if(value == 'list'){
            this.classList.add('list-layout');
        } else {
            this.classList.remove('list-layout');
        }
    }

    listDirectionChanged(value, partId){
        // Row is the default configuration
        // for a list layout, so only one extra
        // CSS class needs to be toggled
        if(value == 'row'){
            this.classList.remove('list-column');
        } else if(value == 'column'){
            this.classList.add('list-column');
        }
    }

    listWrappingChanged(value, partId){
        if(value == true){
            this.classList.add('wrap-list');
        } else {
            this.classList.remove('wrap-list');
        }
    }

    hResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('h-space-fill');
            this.classList.remove(
                'h-rigid',
                'h-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('h-shrink-wrap');
            this.classList.remove(
                'h-rigid',
                'h-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('h-rigid');
            this.classList.remove(
                'h-space-fill',
                'h-shrink-wrap'
            );
        }
    }

    vResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('v-space-fill');
            this.classList.remove(
                'v-rigid',
                'v-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('v-shrink-wrap');
            this.classList.remove(
                'v-rigid',
                'v-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('v-rigid');
            this.classList.remove(
                'v-space-fill',
                'v-shrink-wrap'
            );
        }
    }

    pinningTopChanged(){
        let top = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-top'
        );
        if(top){
            this.classList.add('pin-top');
        } else {
            this.classList.remove('pin-top');
        }
    }

    pinningLeftChanged(){
        let left = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-left'
        );
        if(left){
            this.classList.add('pin-left');
        } else {
            this.classList.remove('pin-left');
        }
    }

    pinningRightChanged(){
        let right = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-right'
        );
        if(right){
            this.classList.add('pin-right');
        } else {
            this.classList.remove('pin-right');
        }
    }

    pinningBottomChanged(){
        let bottom = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-bottom'
        );
        if(bottom){
            this.classList.add('pin-bottom');
        } else {
            this.classList.remove('pin-bottom');
        }
    }

    listAlignmentChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-alignment'
        );
        let valid = [
            'top',
            'bottom',
            'left',
            'right',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-align-${side}`);
            });
            this.classList.add(`list-align-${value}`);
        }
    }

    listDistributionChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-distribution'
        );
        let valid = [
            'start',
            'end',
            'space-between',
            'space-around',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-distribution-${side}`);
            });
            this.classList.add(`list-distribution-${value}`);
        }
    }

    /* Lifecycle Method Defaults */
    afterModelSet(){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterModelUnset(removedModel){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterConnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    afterDisconnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    /* Halo Related Methods */

    openHalo(){
        // Check to see if there's a halo in
        // the component's shadow root already
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            let newHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(newHalo);
        }
    }

    closeHalo(){
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(foundHalo){
            foundHalo.remove();
        }
    }

    toggleAntsBorder(){
        if(this.classList.contains('marching-ants')){
            this.classList.remove('marching-ants');
        } else {
            this.classList.add('marching-ants');
        }
    }

    onHaloDelete(){
        // What to do when the user clicks the
        // delete button on a halo for this partview.
        // The default implementation is to send a message
        // to the System to delete the corresponding
        // model and *all* views referencing that
        // model.
        this.sendMessage({
            type: 'command',
            commandName: 'deleteModel',
            args: [this.model.id]
        }, this.model);
    }

    onHaloOpenScriptEditor(){
        // Send the message to open a script editor
        // with this view's model as the target
        this.model.sendMessage({
            type: 'command',
            commandName: 'openScriptEditor',
            args: [this.model.id]
        }, this.model);
    }

    onHaloOpenEditor(){
        window.System.editor.render(this.model);
        window.System.editor.open();
    }

    onHaloResize(movementX, movementY){
        // Default implementation on what to do during
        // halo button resize opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // width and height style properties directly.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let rect = this.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let ratio = rect.width / rect.height;
            let hyp = Math.sqrt((movementX**2) + (movementY**2));
            if(movementX < 0 || movementY < 0){
                hyp = hyp * -1;
            }
            newHeight = rect.height + hyp;
            newWidth = rect.width + hyp;
        } else {
            newWidth = movementX + rect.width;
            newHeight = movementY + rect.height;
        }
        this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
        this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    onHaloRotate(movementX, movementY){
        // Default implementation on what to do during
        // halo button rotate opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // rotate style property directly.
        if(movementX || movementY){
            let currentAngle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
            let rect = this.getBoundingClientRect();
            if(!currentAngle){
                currentAngle = 0;
            }
            let theta1 = Math.atan((rect.height/2)/(rect.width/2));
            let theta2 = Math.atan((rect.height/2 + movementY)/(rect.width/2 + movementX));
            let changeAngle = Math.abs((theta2 - theta1)*180/Math.PI);
            let newAngle = (currentAngle + changeAngle) % 360;
            if(newAngle < 0){
                newAngle = 360 + newAngle;
            }
            if(newAngle){
                this.model.partProperties.setPropertyNamed(this.model, "rotate", newAngle);
            }
        }
    }

    onHaloCopy(){
        window.System.clipboard.copyPart(this.model);
    }

    onHaloPaste(){
        window.System.clipboard.pasteContentsInto(this.model);
        this.closeHalo();
    }

    onHaloTarget(event){
        // Add targeting receive listeners to all PartViews
        // on the current card.
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.addEventListener('keydown', this.handleTargetKey);
            partView.addEventListener('mouseover', this.handleTargetMouseOver);
            partView.addEventListener('mouseout', this.handleTargetMouseOut);
            partView.addEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.add('targeting-mode');
        event.stopPropagation();
    }

    onHaloTargetButtonMouseEnter(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); //green
        });
    }

    onHaloTargetButtonMouseLeave(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.unhighlight();
        });
    }

    highlight(color){
        if(this.name != "StackView" && this.name != "WorldView"){
            this._tempBackgroundColor = this.model.partProperties.getPropertyNamed(this.model, "background-color");
            this.model.partProperties.setPropertyNamed(this.model, "background-color", color);
            this._tempBackgroundTransparency = this.model.partProperties.getPropertyNamed(this.model, "background-transparency");
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", 1);
        }

    }

    unhighlight(){
        if(this.name != "StackView" && this.name != "WorldView"){
            this.model.partProperties.setPropertyNamed(this.model, "background-color", this._tempBackgroundColor);
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", this._tempBackgroundTransparency);
        }
    }

    endHaloTarget(){
        // Remove all targeting related event listeners
        // that were added during the onHaloTarget
        // handler
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('mouseover', this.handleTargetMouseOver);
            partView.removeEventListener('mouseout', this.handleTargetMouseOut);
            partView.removeEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.remove('targeting-mode');
    }

    handleTargetKey(event){
        if(event.key == 'Escape'){
            this.endHaloTarget();
        }
    }

    handleTargetMouseOver(event){
        if(!event.target.classList.contains('targeting')){
            event.target.classList.add('targeting');
            event.target.highlight("rgb(234, 55, 55)");
            event.target.removeEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseLeave(event){
        if(event.target.classList.contains('targeting')){
            event.target.classList.remove('targeting');
            event.target.unhighlight();
            event.target.addEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseClick(event){
        event.preventDefault();
        if(event.button == 0 && event.shiftKey){
            this.onHaloActivationClick(event);
            return;
        }
        event.target.classList.remove('targeting');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'target',
            event.target.model.id
        );
        this.endHaloTarget();
        event.stopImmediatePropagation();
        event.target.unhighlight();
        event.target.addEventListener('click', event.target.onClick);
    }

    getCurrentTargetViews(){
        // clean up the current target
        let currentTarget = this.model.partProperties.getPropertyNamed(this.model, "target");
        if(currentTarget){
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this.model, window.System)
            );
            let m = window.System.grammar.match(currentTarget, "ObjectSpecifier");
            let targetId = semantics(m).interpret();
            return window.System.findViewsById(targetId);
        }
        return [];
    }

    onContextMenuClick(event){
        if(this.wantsContextMenu){
            event.preventDefault();
            event.stopPropagation();
            if(this.contextMenuIsOpen){
                this.closeContextMenu();
            } else {
                this.openContextMenuAt(
                    event.clientX,
                    event.clientY
                );
            }
        } else {
            event.stopPropagation();
        }
    }

    onAuxClick(event){
        // Should only open halo when middle
        // mouse button is clicked
        if(event.button == 1){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onClick(event){
        if(this.contextMenuIsOpen){
            this.closeContextMenu();
        }
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onHaloActivationClick(event){
        if(this.wantsHalo){
            if(this.hasOpenHalo){
                this.closeHalo();
            } else {
                event.stopPropagation();
                // Find any other open Halos
                // and automatically close them
                let exSelector = `.editing:not([part-id="${this.model.id}"])`;
                Array.from(document.querySelectorAll(exSelector)).forEach(openHaloEl => {
                    openHaloEl.closeHalo();
                });

                // Finally, open on this view
                this.openHalo();
            }
        }
    }

    onMouseDown(event){
        if(event.button == 0 && !event.shiftKey){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        this.sendMessage({
            type: 'command',
            commandName: 'move',
            args: [event.movementX, event.movementY]
        }, this.model);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    openContextMenuAt(x, y){
        let menuEl = document.createElement('st-context-menu');
        menuEl.render(this.model);
        menuEl.style.left = `${x}px`;
        menuEl.style.top = `${y}px`;
        document.body.append(menuEl);

        // Ensure that the menu is completely
        // within the current view. If not (meaning
        // it is clipped), then adjust so it is
        // completely in the view.
        menuEl.adjustToClientView();
    }

    closeContextMenu(){
        let found = document.querySelector('st-context-menu');
        if(found){
            found.remove();
        }
    }

    addContextMenuItems(contextMenu){
        // The default implementation is to
        // do nothins.
        // Subclasses should override and use the
        // passed-in contextMenu object to construct
        // list items that are specific to their needs
        return;
    }

    get wantsHaloMove(){
        if(!this.parentElement || !this.isConnected){
            return false;
        }
        let parentModel = this.parentElement.model;
        if(!parentModel){
            return true;
        }

        let hasLayout = parentModel.partProperties.findPropertyNamed(
            parentModel,
            'layout'
        );

        if(!hasLayout){
            return true;
        }

        let parentLayout = parentModel.partProperties.getPropertyNamed(
            parentModel,
            'layout'
        );
        if(parentLayout === 'strict' | !parentLayout || parentLayout == ""){
            return true;
        }

        return false;
    }

    get contextMenuIsOpen(){
        let found = document.querySelector('st-context-menu');
        if(found){
            return true;
        }
        return false;
    }

    /* Editor related methods */
    openEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    closeEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }
};




/***/ }),

/***/ "./js/objects/views/ResourceView.js":
/*!******************************************!*\
  !*** ./js/objects/views/ResourceView.js ***!
  \******************************************/
/*! exports provided: ResourceView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceView", function() { return ResourceView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResourceView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-building-bridge-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <path d="M6 7h12a2 2 0 0 1 2 2v9a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-2a4 4 0 0 0 -8 0v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-9a2 2 0 0 1 2 -2"></path>
    </svg>
</div>
`;

class ResourceView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateResourceLink = this.updateResourceLink.bind(this);
        this.indicateReadyState = this.indicateReadyState.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        // if the resourceName property is set then make sure it is loaded
        // TODO: i don't like this view asking the model to load!
        let resourceName = this.model.partProperties.getPropertyNamed(this.model, "resourceName");
        if(resourceName){
            this.model.loadResource([this], resourceName);
        }
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            this.model.setSourceTo([this], src);
        }
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        let state = this.model.partProperties.getPropertyNamed(
            this.model,
            "readyState",
        );
        this.indicateReadyState(state);
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", this.indicateReadyState);
        this.onPropChange("src", (url) => {
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    indicateReadyState(value){
        let borderColor = "red";
        if(value == "fetching"){
            borderColor = "yellow";
        } else if(value == "ready"){
            borderColor = "green";
        };
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-resource-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for resource');
        this.haloButton.addEventListener('click', this.updateResourceLink);
    }

    updateResourceLink(event){
        // Tells the model to update its
        // src link for the resource
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for resource:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadResource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/StackView.js":
/*!***************************************!*\
  !*** ./js/objects/views/StackView.js ***!
  \***************************************/
/*! exports provided: StackView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackView", function() { return StackView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Stack.js */ "./js/objects/parts/Stack.js");
/**
 * StackView
 * ----------------------------------------------
 * I am a Webcomponent (custom element) representing
 * the view of a Stack.
 * I take up the full width of the current viewport
 * when I am being displayed.
 * My child elements are BackgroundView and CardView
 */




// by default, stacks are hidden unless they're
// the current stack, or else they have the class
// window-stack (suggesting there's window part
// who wishes to display it)
const templateString = `<slot></slot>`;

class StackView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup templating and shadow dom
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Handle current-ness prop change
        this.onPropChange('current', this.handleCurrentChange);

        // Bind methods
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
    }

    afterModelSet(){
        // Do an initial setting of the
        // current card
        this.handleCurrentChange();
    }

    handleCurrentChange(){
        // The value of the current prop is the card ID
        // of the child Card that should be the
        // current one. We remove the current-card class from
        // the previous current card and add it to the new one.
        let currentCard = this.querySelector('.current-card');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let shouldNotify = false;
        let selector = `:scope > st-card[part-id="${nextCurrentId}"]`;
        if(this.isLensed){
            selector = `:scope > st-card[lens-part-id="${nextCurrentId}"]`;
            shouldNotify = true;
        }
        let nextCurrentCard = this.querySelector(selector);
        // if there is no currentCard and no next currentCard we set it to be the first
        // card child (this can happen when new ids are created on deserialization and so
        // the current property stored id is no longer relevant)
        if(!nextCurrentCard && !currentCard){
            nextCurrentCard = this.querySelector(`:scope > st-card`);
            // if there are no cards at all, this must be a brand new stack
            if(!nextCurrentCard){
                return;
            }
            this.model.partProperties.setPropertyNamed(
                this.model,
                "current",
                nextCurrentCard.id,
                shouldNotify
            );
        }
        if(nextCurrentCard){
            nextCurrentCard.classList.add('current-card');
        } else {
            return;
        }
        if(currentCard && currentCard != nextCurrentCard){
            currentCard.classList.remove('current-card');
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "CardView"){
            let lastCardNode;
            this.childNodes.forEach((child) => {
                if(child.name == "CardView"){
                    lastCardNode = child;
                }
            });
            if(lastCardNode){
                // insert after the last card
                lastCardNode.after(newView);
            } else {
                // since there are no cards
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/WindowView.js":
/*!****************************************!*\
  !*** ./js/objects/views/WindowView.js ***!
  \****************************************/
/*! exports provided: WindowView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindowView", function() { return WindowView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WindowView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WindowView
 * -------------------------------
 * I am the view of a Window Part.
 * Windows are wrappers for Stacks/StackViews that
 * appear as the subparts of other Stacks or Cards.
 * They are examples of how we can use stack and card
 * composition to create more complex UIs.
 */


const template = document.createElement('template');
template.innerHTML = `
<style>
 * {
     box-sizing: border-box;
 }

 .st-window-bar {
     display: flex;
     flex-direction: row;
     width: 100%;
     min-height: 25px;
     background-color: rgb(218, 218, 218);
     padding-left: 8px;
     padding-right: 8px;
     align-items: center;
 }
 .st-window-button {
     display: block;
     width: 12px;
     height: 12px;
     border-radius: 100%;
     background-color: rgba(255, 150, 150);
     margin-right: 4px;
 }
 .close-button {
     background-color: rgba(255, 50, 50, 0.4);
 }
 .shade-button {
     background-color: rgba(255, 255, 0. 0.4);
 }
 .expand-button {
     background-color: rgba(150, 255, 0, 0.8);
 }
 .st-window-pane {
     display: block;
     position: relative;
     min-height: 50px;
     flex: 1;
 }
 .st-window-pane.shaded {
     display: none;
 }
 .st-window-gripper {
     display: block;
     position: absolute;
     top: calc(100% - 15px);
     width: 30px;
     height: 30px;
 }
 .st-window-title {
     user-select: none;
     text-overflow: ellipsis;
     overflow: hidden;
     white-space: nowrap;
     max-width: 70%;
 }
 .right-gripper {
     left: calc(100% - 15px);
 }
 .right-gripper:hover {
     cursor: nwse-resize;
 }
 .left-gripper {
     right: calc(100% - 15px);
 }
 .left-gripper:hover {
     cursor: nesw-resize;
 }
</style>
<div class="st-window-bar">
    <div class="st-window-button close-button"></div>
    <div class="st-window-button shade-button"></div>
    <div class="st-window-button expand-button"></div>
    <div class="st-window-title">
        <span></span>
    </div>
</div>
<div class="st-window-pane">
    <slot></slot>
</div>
<div class="st-window-gripper right-gripper" data-grip-end="right"></div>
`;

class WindowView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        var templateContent = template.content.cloneNode(true);
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(templateContent);

        this.mouseDownInBar = false;
        this.isShaded = false;
        this.isExpanded = false;
        this.expandCache = {};

        // Whether or not we are gripping the
        // bottom right corner for a resize
        this.isGripping = false;

        // Bound methods
        this.setupClickAndDrag = this.setupClickAndDrag.bind(this);
        this.setupBarButtons = this.setupBarButtons.bind(this);
        this.setupExpanderAreas = this.setupExpanderAreas.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.onMouseMoveInBar = this.onMouseMoveInBar.bind(this);
        this.onMouseDownInBar = this.onMouseDownInBar.bind(this);
        this.onMouseUpAfterDrag = this.onMouseUpAfterDrag.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onShade = this.onShade.bind(this);
        this.onExpand = this.onExpand.bind(this);
        this.onGripDown = this.onGripDown.bind(this);
        this.onGripUp = this.onGripUp.bind(this);
        this.onGripMove = this.onGripMove.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('title', this.setTitle);
    }

    afterConnected(){
        this.setupClickAndDrag();
        this.setupBarButtons();
        this.setupExpanderAreas();
    }

    afterModelSet(){
        this.setTitle(
            this.model.partProperties.getPropertyNamed(
                this.model,
                'title'
            )
        );
    }

    setupClickAndDrag(){
        let bar = this._shadowRoot.querySelector('.st-window-bar');
        bar.addEventListener('mousedown', this.onMouseDownInBar);
    }

    setupBarButtons(){
        let closeButton = this._shadowRoot.querySelector('.close-button');
        let shadeButton = this._shadowRoot.querySelector('.shade-button');
        let expandButton = this._shadowRoot.querySelector('.expand-button');

        closeButton.addEventListener('click', this.onClose);
        shadeButton.addEventListener('click', this.onShade);
        expandButton.addEventListener('click', this.onExpand);
    }

    setupExpanderAreas(){
        let lowerRight = this._shadowRoot.querySelector('.right-gripper');
        lowerRight.addEventListener('mousedown', this.onGripDown);
    }

    onExpand(event){
        if(this.isExpanded){
            this.style.width = this.expandCache.width;
            this.style.height = this.expandCache.height;
            this.style.top = this.expandCache.top;
            this.style.left = this.expandCache.left;
            this.isExpanded = false;
        } else {
            this.expandCache = {
                width: this.style.width,
                height: this.style.height,
                top: this.style.top,
                left: this.style.left
            };
            // Set new values based on window size
            this.style.top = "0px";
            this.style.left = "0px";
            this.style.width = "100vw";
            this.style.height = "100vh";
            this.isExpanded = true;
        }
    }

    onShade(event){
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        if(this.isShaded){
            pane.classList.remove('shaded');
            this.isShaded = false;
        } else {
            pane.classList.add('shaded');
            this.isShaded = true;
        }
    }

    onClose(event){
        let msg = {
            type: 'command',
            commandName: 'windowClose',
            args: []
        };
        this.model.sendMessage(msg, this.model);
    }

    onMouseDownInBar(event){
        this.mouseDownInBar = true;
        let bar = event.target;
        document.addEventListener('mousemove', this.onMouseMoveInBar);
        document.addEventListener('mouseup', this.onMouseUpAfterDrag);
    }

    onMouseUpAfterDrag(event){
        this.mouseDownInBar = false;
        let bar = event.target;
        document.removeEventListener('mouseup', this.onMouseUpAfterDrag);
        document.removeEventListener('mousemove', this.onMouseMoveInBar);
    }

    onMouseMoveInBar(event){
        let currentTop = parseInt(this.style.top);
        let currentLeft = parseInt(this.style.left);
        // let newTop = `${currentTop + event.movementY}px`;
        // let newLeft = `${currentLeft + event.movementX}px`;
        let newTop = currentTop + event.movementY;
        let newLeft = currentLeft + event.movementX;
        this.model.partProperties.setPropertyNamed(this.model, "top", newTop);
        this.model.partProperties.setPropertyNamed(this.model, "left", newLeft);
    }

    onGripUp(event){
        this.isGripping = false;
        document.removeEventListener('mousemove', this.onGripMove);
        document.removeEventListener('mouseup', this.onGripUp);
    }

    onGripDown(event){
        this.isGripping = true;
        document.addEventListener('mousemove', this.onGripMove);
        document.addEventListener('mouseup', this.onGripUp);
    }

    onGripMove(event){
        if(this.isGripping){
            // Figure out the current width and height.
            // and set the property to the new one
            let box = this.getBoundingClientRect();
            let newWidth = Math.floor(box.width) + event.movementX;
            if(newWidth){
                this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
            }
            let newHeight = Math.floor(box.height) + event.movementY;
            if(newHeight){
                this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
            }
        }
    }

    setTitle(aString){
        let titleArea = this._shadowRoot.querySelector(
            '.st-window-title > span'
        );
        titleArea.innerText = aString;
    }

    // override subclass methods
    newSubpartView(newView){
        // slot the new view into the window pane
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        pane.append(newView);
        this.appendChild(newView);
    }


};




/***/ }),

/***/ "./js/objects/views/WorldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/WorldView.js ***!
  \***************************************/
/*! exports provided: WorldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldView", function() { return WorldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WorldView
 * ---------------------------------------------
 * I am a Webcomponent (custom element) that represents
 * a view of a WorldStack model.
 * My element children should contain a single StackView representing
 * the current displayed stack (this comes from the model).
 * I am the root-level element for the SimpleTalk system in a web
 * page. There should only be one of me on any given HTML page.
 */


const templateString = `<slot></slot>`;

const NODES_TO_IGNORE_WHEN_ARROW_KEY = [
    'TEXTAREA',
    'INPUT',
    'ST-FIELD'
];

class WorldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Set up templating and shadow dom
        // TODO: Put the template definition in this
        // module as formatted text
        const template = document.createElement('template');
        template.innerHTML = templateString;
        
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // The world never wants a halo
        this.wantsHalo = false;

        // Bound methods
        this.updateCurrentStack = this.updateCurrentStack.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('current', this.updateCurrentStack);
    }

    afterConnected(){
        document.addEventListener('keydown', this.handleKeyDown);
    }

    afterDisconnected(){
        document.removeEventListener('keydown', this.handleKeyDown);
    }

    afterModelSet(){
        // Do an initial update to display
        // the model's current stack
        this.updateCurrentStack();
    }

    updateCurrentStack(){
        // The value of the current prop is the stack ID
        // of the child Stack that should be the
        // current one. We remove the current-stack class from
        // the previous current stack and add it to the new one.
        let currentStack = this.querySelector('.current-stack');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let nextCurrentStack = this.querySelector(`:scope > st-stack[part-id="${nextCurrentId}"]`);
        if(nextCurrentStack){
            nextCurrentStack.classList.add('current-stack');
        } else {
            return;
        }
        // To prevent the setting of the same id as the current stack make sure
        // next and current are not the same
        if(currentStack && currentStack != nextCurrentStack){
            currentStack.classList.remove('current-stack');
        }
    }

    handleKeyDown(event){
        if(event.altKey && event.ctrlKey && event.code == "Space"){
            let navigator = document.querySelector('st-navigator');
            navigator.toggle();
        } else {
            // Bind arrow key events if and only if
            // the focus is not in any kind of text input.
            // We send the arrowKey command to the current card
            if(event.code.startsWith('Arrow')){
                if(!NODES_TO_IGNORE_WHEN_ARROW_KEY.includes(document.activeElement.nodeName)){
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'arrowKey',
                        args: [
                            // First arg is the direction
                            event.code.split('Arrow')[1].toLowerCase(),
                            event.ctrlKey,
                            event.altKey,
                            event.shiftKey
                        ],
                        shouldIgnore: true
                    }, this.model.currentStack.currentCard);
                }
            }
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "StackView"){
            let lastStackNode;
            this.childNodes.forEach((child) => {
                if(child.name == "StackView"){
                    lastStackNode = child;
                }
            });
            if(lastStackNode){
                // insert after the last stack
                lastStackNode.after(newView);
            } else {
                // since there are no stacks
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenu.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenu.js ***!
  \*****************************************************/
/*! exports provided: ContextMenu, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenu", function() { return ContextMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenu; });
/* harmony import */ var _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContextMenuItem.js */ "./js/objects/views/contextmenu/ContextMenuItem.js");
// PREAMBLE


window.customElements.define('st-context-menu-item', _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        border: 1px solid black;
        background-color: white;
        box-shadow: 1px 2px 10px rgba(50, 50, 50, 0.7);
        z-index: 10000;
        padding-bottom: 8px;
        min-width: 200px;
        font-family: 'Helvetica', sans-serif;
    }

    :host-context(li) {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host-context(li):hover {
        display: flex;
    }

    header {
        position: relative;
        display: flex;
        border-bottom: 1px solid rgba(150, 150, 150, 0.5);
        padding-right: 16px;
        padding-left: 16px;
        padding-top: 8px;
        padding-bottom: 8px;
    }

    header > h4 {
        padding: 0;
        margin:0;
    }

    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        font-size: 0.8rem;
    }

</style>
<header>
    <h4></h4>
</header>
<ul id="list-items">
    <slot></slot>
</ul>
`;

class ContextMenu extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.addHaloToggleItem = this.addHaloToggleItem.bind(this);
        this.addNavigatorToggleItem = this.addNavigatorToggleItem.bind(this);
        this.addCopyAndPasteItems = this.addCopyAndPasteItems.bind(this);
        this.addOpenEditorItem = this.addOpenEditorItem.bind(this);
        this.addScriptEditItem = this.addScriptEditItem.bind(this);
        this.addMovementItems = this.addMovementItems.bind(this);
        this.addPartSubmenu = this.addPartSubmenu.bind(this);
        this.addListItem = this.addListItem.bind(this);
        this.addSpacer = this.addSpacer.bind(this);
        this.hideHeader = this.hideHeader.bind(this);
        this.adjustToClientView = this.adjustToClientView.bind(this);
    }

    render(aModel){
        this.innerHTML = "";
        this.model = aModel;
        let headerEl = this._shadowRoot.querySelector('header > h4');
        let headerText = `${this.model.type[0].toUpperCase()}${this.model.type.slice(1)}`;
        headerText = `a ${headerText}`;
        headerEl.textContent = headerText;

        // Render the default menu items
        this.addHaloToggleItem();
        this.addCopyAndPasteItems();
        this.addOpenEditorItem();
        this.addPartSubmenu();
        this.addScriptEditItem();
        this.addMovementItems();
        this.addNavigatorToggleItem();

        // Add View-specific items
        let view = document.querySelector(`[part-id="${this.model.id}"]`);
        view.addContextMenuItems(this);
    }

    addListItem(label, callback, submenu=null){
        let itemEl = document.createElement('st-context-menu-item');
        itemEl.textContent = label;
        itemEl.classList.add('context-menu-item');
        itemEl.addEventListener('click', callback);
        itemEl.addEventListener('click', () => {
            this.remove();
        });
        if(submenu){
            submenu.classList.add('context-submenu', 'submenu-hidden');
            submenu.setAttribute('slot', 'submenu');
            itemEl.append(submenu);
            itemEl.showCaret();
        }
        this.append(itemEl);
    }

    addHaloToggleItem(){
        let target = window.System.findViewById(this.model.id);
        // don't add halo option to cards, since you can't see those
        if(target.name != "CardView"){
            if(target.classList.contains('editing')){
                this.addListItem(
                    'Close Halo',
                    (event) => {
                        target.closeHalo();
                    }
                );
            } else {
                this.addListItem(
                    'Open Halo',
                    (event) => {
                        target.openHalo();
                    }
                );
            }
        }
    }

    addNavigatorToggleItem(){
        let nav = document.querySelector('st-navigator');
        if(nav.classList.contains('open')){
            nav.classList.toggle('open');
            this.addListItem(
                'Close Navigator',
                (event) => {
                    nav.close();
                }
            );
        } else {
            this.addListItem(
                'Open Navigator',
                (event) => {
                    nav.open();
                    nav.classList.toggle('open');
                }
            );
        }
    }

    addCopyAndPasteItems(){
        // Add copy item
        this.addListItem(
            'Copy',
            (event) => {
                window.System.clipboard.copyPart(this.model);
            }
        );

        // Add paste but only if:
        // 1. There is clipboard contents;
        // 2. The part type in the clipboard is
        //    one that is accepted by this model's part
        if(window.System.clipboard.contents.length){
            let partType = window.System.clipboard.contents[0].partType;
            if(this.model.acceptsSubpart(partType)){
                let label = `Paste (a ${partType[0].toUpperCase()}${partType.slice(1)})`;
                this.addListItem(label, (event) => {
                    window.System.clipboard.pasteContentsInto(this.model);
                });
            }
        }
    }

    addOpenEditorItem(){
        this.addListItem(
            'Open Editor',
            (event) => {
                window.System.openEditorForPart(this.model.id);
            }
        );
    }

    addScriptEditItem(){
        this.addListItem(
            'Edit Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: [this.model.id]
                }, this.model);
            }
        );

        this.addListItem(
            'Edit World Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: ['world']
                }, this.model);
            }
        );

        let windowAncestor = this.model.findAncestorOfType('window');
        if(this.model.type != 'window' && windowAncestor !== null){
            this.addListItem(
                'Edit Owning Window Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [windowAncestor.id]
                    }, this.model);
                }
            );
        }
        
        let cardAncestor = this.model.findAncestorOfType('card');
        if(this.model.type != 'card' && cardAncestor){
            this.addListItem(
                'Edit Owning Card Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [cardAncestor.id]
                    }, this.model);
                }
            );
        }

        let stackAncestor = this.model.findAncestorOfType('stack');
        if(this.model.type != 'stack' && stackAncestor){
            this.addListItem(
                'Edit Owning Stack Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [stackAncestor.id]
                    }, this.model);
                }
            );
        }
    }

    addPartSubmenu(){
        // First, we need to get a list of names
        // of subparts that this model accepts
        let subpartNames;
        if(this.model.acceptedSubpartTypes[0] == "*"){
            // This model accepts all subpart types.
            // We need to get the names for these subparts,
            // which are registered at the System level.
            subpartNames = Object.keys(window.System.availableViews);
        } else {
            subpartNames = this.model.acceptedSubpartTypes;
        }

        // If there are no subpart names (meaning
        // the given part, like a button, doesn't
        // accept any subparts), then we do nothing.
        if(subpartNames.length == 0){
            return;
        }

        // Now we construct the submenu for adding parts
        // of the given type
        let submenu = document.createElement('st-context-menu');
        submenu.hideHeader();
        subpartNames.forEach(subpartName => {
            submenu.addListItem(
                subpartName[0].toUpperCase() + subpartName.slice(1),
                () => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'newModel',
                        args: [
                            subpartName,
                            this.model.id
                        ]
                    }, this.model);
                }
            );
        });

        // Now add the list item that will "reveal"
        // the submenu
        this.addListItem(
            'Add a new part',
            null,
            submenu
        );
        
    }

    addMovementItems(){
        let index = this.model._owner.subparts.indexOf(this.model);
        let ownerLength = this.model._owner.subparts.length;
        if(ownerLength && index < ownerLength - 1){
            // Create the moveDown option
            this.addListItem(
                'Move Down',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveDown',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to Last',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToLast',
                        args: []
                    }, this.model);
                }
            );
        }
        if(index > 0){
            // Create the moveUp option
            this.addListItem(
                'Move Up',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveUp',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to First',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToFirst',
                        args: []
                    }, this.model);
                }
            );
        }
    }

    addSpacer(){
        let item = document.createElement('li');
        item.classList.add('context-menu-spacer');
        this.append(item);
    }

    hideHeader(){
        let headerEl = this._shadowRoot.querySelector('header');
        headerEl.style.display = "none";
    }

    adjustToClientView(){
        let rect = this.getBoundingClientRect();
        let padding = 10;
        let viewportWidth = document.documentElement.clientWidth;
        let viewportHeight = document.documentElement.clientHeight;
        let bottomDiff = (rect.bottom + padding) - viewportHeight;
        let rightDiff = (rect.right + padding) - viewportWidth;
        if(bottomDiff > 0){
            this.style.top = `${(rect.top - bottomDiff)}px`;

            // Reposition any hidden submenus, so they open
            // above
            Array.from(this.children).filter(childEl => {
                return childEl.children.length > 0;
            }).forEach(itemWithSubmenu => {
                let container = itemWithSubmenu._shadowRoot.querySelector('.submenu-area');
                container.style.top = `${(-1 * itemWithSubmenu.getBoundingClientRect().height)}px`;
            });
        }
        if(rightDiff > 0){
            this.style.left = `${rect.left - rightDiff}px`;

            // Reposition any hidden submenus, so they open
            // to the left (instead of right)
            Array.from(this.children).filter(childEl => {
                return childEl.children.length > 0;
            }).forEach(itemWithSubmenu => {
                let container = itemWithSubmenu._shadowRoot.querySelector('.submenu-area');
                container.style.left = `${(-1 * itemWithSubmenu.getBoundingClientRect().width)}px`;
            });
        }
    }
};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenuItem.js":
/*!*********************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenuItem.js ***!
  \*********************************************************/
/*! exports provided: ContextMenuItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenuItem", function() { return ContextMenuItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenuItem; });
const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
    }
    .submenu-area {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host(:hover) .submenu-area {
        display: flex;
    }

    .label-area {
        display: flex;
        align-items: center;
    }

    .caret.hidden {
        display: none;
    }
    .caret {
        display: block;
        margin-left: auto;
        font-size: 1.1em;
    }
</style>
<div class="label-area">
    <span class="label"><slot></slot></span>
    <div class="caret hidden">→</div>
</div>
<div class="submenu-area">
    <slot name="submenu"></slot>
</div>
`;

class ContextMenuItem extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.append(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.showCaret = this.showCaret.bind(this);
    }

    showCaret(){
        let caretEl = this._shadowRoot.querySelector('.caret');
        caretEl.classList.remove('hidden');    
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/ColorPickerTool.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/drawing/ColorPickerTool.js ***!
  \*****************************************************/
/*! exports provided: ColorPickerTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPickerTool", function() { return ColorPickerTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorPickerTool; });
/* harmony import */ var _ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/**
 * ColorPickerTool
 * I provide a color choorser capability
 * for the shadow canvas of my parent element.
 * Brushes on my parent Drawing canvas will use
 * whatever color I have currently selected.
 * I am explicitly designed for use with
 * DrawingView*/

const colorPickerSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-color-swatch" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 3h-4a2 2 0 0 0 -2 2v12a4 4 0 0 0 8 0v-12a2 2 0 0 0 -2 -2" />
  <path d="M13 7.35l-2 -2a2 2 0 0 0 -2.828 0l-2.828 2.828a2 2 0 0 0 0 2.828l9 9" />
  <path d="M7.3 13h-2.3a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h12" />
  <line x1="17" y1="17" x2="17" y2="17.01" />
</svg>
`;

const colorPickerTemplateString = `
<style>
    :host {
        display: block;
        position: relative;
        margin-bottom: 6px;
    }

    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        position: relative;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
        width: 24px;
        height: 24px;
    }

    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    color-wheel {
        display: none;
        position: absolute;
    }

    :host([active="true"]) > color-wheel {
        display: flex;
    }
</style>
<div id="tool-button">
${colorPickerSVG}
</div>
<color-wheel></color-wheel>
`;


class ColorPickerTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can be
        // toggled within its parent DrawingView.
        this.template = document.createElement('template');
        this.template.innerHTML = colorPickerTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool
        // is connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.onColorSelected = this.onColorSelected.bind(this);
        this.onTransparencyChanged = this.onTransparencyChanged.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('current-color')){
                this.setAttribute('current-color', 'rgba(0, 0, 0, 0)');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.colorWheel = this.shadowRoot.querySelector('color-wheel');
            this.colorWheel.addEventListener('color-selected', this.onColorSelected);
            this.colorWheel.addEventListener('transparency-changed', this.onTransparencyChanged);
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.colorWheel.removeEventListener('color-selected', this.onColorSelected);
        this.colorWheel.removeEventListener('transparency-changed', this.onTransparencyChanged);
    }

    start(x, y){
        // Does nothing in this tool
    }

    end(x, y){
        // Does nothing in this tool
    }

    onMove(x, y){
        // Does nothing in this tool
    }

    setContextFromAttributes(){
        // Does nothing in this tool
    }

    onColorSelected(event){
        let colorInfo = event.detail;
        let colorStr = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
        this.ctx.strokeStyle = colorStr;
        this.ctx.fillStyle = colorStr;
    }

    onTransparencyChanged(event){
        this.parentElement.model.sendMessage({
            type: "command",
            commandName: "setProperty",
            args: ["transparency", event.detail]
        }, this.parentElement.model);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};



window.customElements.define('color-picker-tool', ColorPickerTool);




/***/ }),

/***/ "./js/objects/views/drawing/ColorWheelWidget.js":
/*!******************************************************!*\
  !*** ./js/objects/views/drawing/ColorWheelWidget.js ***!
  \******************************************************/
/*! exports provided: ColorWheelWidget, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorWheelWidget", function() { return ColorWheelWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorWheelWidget; });
/**
 * ColorWheelWidget
 * I am a *generic use* webcomponent representing
 * a ColorWheel selection widget.
 * I operate as a floating modal window with a
 * circular color wheel as well as a list of
 * recently selected colors.
 * I am designed to be used by any parent element.
 * I will trigger an event called 'color-change' whenever
 * a new color has been selected from within me
 */

const colorWheelTemplate = `
<style>
  :host {
    display: initial !important;
    visibility: visible !important;
    position: relative;
    flex-direction: column;
    align-items: center;
    box-sizing: border-box;
    background-color: white;
    border: 1px solid black;
  }

  #palette-bar {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    height: 20px;
    background-color: rgba(200, 200, 200);
    width: 100%;
    box-sizing: border-box;
  }

  #palette-title {
    width: 100%;
    text-align: center;
  }

  #close-button {
    display: block;
    width: 12px;
    height: 12px;
    margin-left: 8px;
    background-color: white;
    border: 1px solid black;
    text-align: center;
    font-size: 12px;
  }

  #palette-content {
    flex: 1;
    display: block;
    position: relative;
  }
  #hover-color {
    display: block;
    width: 100%;
    height: 25px;
  }
  #options {
    display: flex;
    width: 100%;
    height: 25px;
    margin-top: 5px;
    justify-content: center;
  }

  #options > label{
    font-size: .8rem;
    display: flex;
    align-items: center;
  }

  #recent-colors {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    padding-left: 15px;
    padding-right: 15px;
    box-sizing: border-box;
    list-style: none;
  }
  .recent-color-item {
    display: block;
    width: 26px;
    height: 26px;
    box-sizing: border-box;
    border: 1px solid rgba(200, 200, 200, 0.8);
  }

  .recent-color-item.selected {
    border: 2px solid black;
  }

</style>
<div id="palette-wrapper">
  <div id="palette-bar"><div id="close-button">x</div><span id="palette-title"></span></div>
  <div id="palette-content">
    <div id="options">
      <input type="range" id="transparency" name="transparency" min="0" max="1" step="0.1" value="1">
      <!-- <label for="transparency">Transparency</label>-->
    </div>
    <ul id="recent-colors">
      <li class="recent-color-item selected"></li>
      <li class="recent-color-item"></li>
      <li class="recent-color-item"></li>
    </ul>
    <canvas id="color-wheel" width="150" height="150"></canvas>
    <div id="hover-color"></div>
  </div>
</div>
`;

class ColorWheelWidget extends HTMLElement {
    constructor(name){
        super();

        this.name = name;

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = colorWheelTemplate;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind local methods
        this.onWheelMouseEnter = this.onWheelMouseEnter.bind(this);
        this.onWheelMouseLeave = this.onWheelMouseLeave.bind(this);
        this.onWheelMouseMove = this.onWheelMouseMove.bind(this);
        this.onWheelClick = this.onWheelClick.bind(this);
        this.onItemClick = this.onItemClick.bind(this);
        this.onBarMouseDown = this.onBarMouseDown.bind(this);
        this.onBarMouseUp = this.onBarMouseUp.bind(this);
        this.onBarMouseMove = this.onBarMouseMove.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onTransparencyChange = this.onTransparencyChange.bind(this);
        this._drawWheel = this._drawWheel.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.canvas = this.shadowRoot.querySelector('canvas');
            this.bar = this.shadowRoot.getElementById('palette-bar');
            // give the widget a title if provided
            if(this.name){
                this.shadowRoot.getElementById('palette-title').innerText = this.name;
            }

            // Set events
            this.canvas.addEventListener('click', this.onWheelClick);
            this.canvas.addEventListener('mouseenter', this.onWheelMouseEnter);
            this.bar.addEventListener('mousedown', this.onBarMouseDown);
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item')).forEach(el => {
                el.addEventListener('click', this.onItemClick);
            });
            this.transparencySlider = this.shadowRoot.getElementById('transparency');
            this.transparencySlider.addEventListener("input", this.onTransparencyChange);

            // Draw the color wheel to the canvas
            this._drawWheel();
        }
    }

    disconnectedCallback(){
        this.canvas.removeEventListener('click', this.onWheelClick);
        this.canvas.removeEventListener('mouseenter', this.onWheelMouseEnter);
        this.bar.removeEventListener('mousedown', this.onBarMouseDown);
        Array.from(this.shadowRoot.querySelector('.recent-color-item')).forEach(el => {
            el.removeEventListener('click', this.onItemClick);
        });
        this.transparencySlider.removeEventListener("change", this.onTransparencyChange);
    }


    onWheelMouseEnter(event){
        // Cache the image data for the whole canvas
        let ctx = this.canvas.getContext('2d');
        this._cachedImageData = ctx.getImageData(
            0,
            0,
            this.canvas.width,
            this.canvas.height
        );
        // Bind subsequent events
        this.canvas.addEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.addEventListener('mouseleave', this.onWheelMouseLeave);
    }

    onWheelMouseLeave(event){
        this.canvas.removeEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.removeEventListener('mouseleave', this.onWheelMouseLeave);
        this._cachedImageData = null;
    }

    onWheelMouseMove(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let hoverColorArea = this.shadowRoot.getElementById('hover-color');
        let newStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;
        hoverColorArea.style.backgroundColor = newStyle;
    }

    onWheelClick(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let colorInfo = {
            r: rgb[0],
            g: rgb[1],
            b: rgb[2],
            alpha: rgb[3]
        };
        let newEvent = new CustomEvent('color-selected', {
            detail: colorInfo
        });
        this.selectedColor = colorInfo;
        this.dispatchEvent(newEvent);

        // Update the recent color swatches
        let currentSwatchSelection = this.shadowRoot.querySelector('.recent-color-item.selected');
        if(currentSwatchSelection){
            currentSwatchSelection.style.backgroundColor = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
            currentSwatchSelection.selectedColor = colorInfo;
        }
    }

    onTransparencyChange(event){
        let command = this.getAttribute("selector-command");
        // update the corresponding transparency - text or background
        // depending on what this color wheel is setup to update
        let propName = "background-transparency";
        if(command === "text-color"){
            propName = "text-transparency";
        }
        let eventDetail = {propName: propName, value: event.target.value};
        let newEvent = new CustomEvent('transparency-changed', {
            detail: eventDetail,
        });
        this.dispatchEvent(newEvent);
    }

    onItemClick(event){
        // If this element is not the currently
        // selected recent item, find the one that is
        // and toggle the selection class, then toggle
        // this item's selection class.
        if(!event.target.classList.contains('selected')){
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item.selected')).forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        if(event.target.selectedColor){
            let newEvent = new CustomEvent('color-selected', {
                detail: event.target.selectedColor
            });
            this.dispatchEvent(newEvent);
        }
    }

    onBarMouseDown(event){
        document.addEventListener('mousemove', this.onBarMouseMove);
        document.addEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseUp(event){
        document.removeEventListener('mousemove', this.onBarMouseMove);
        document.removeEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseMove(event){
        let newTop = this.offsetTop + event.movementY;
        let newLeft = this.offsetLeft + event.movementX;
        this.style.top = `${newTop}px`;
        this.style.left = `${newLeft}px`;
    }

    onClose(event){
        this.remove();
    }

    _drawWheel(){
        let ctx = this.canvas.getContext('2d');
        drawCircle(ctx, this.canvas.width / 2);
    }
};

window.customElements.define('color-wheel', ColorWheelWidget);

/** Utility Functions **/

// This function is adapted from
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const drawCircle = (ctx, radius) => {
    let image = ctx.createImageData(2*radius, 2*radius);
    let data = image.data;

    for (let x = -radius; x < radius; x++) {
        for (let y = -radius; y < radius; y++) {

            let [r, phi] = xy2polar(x, y);

            if (r > radius) {
                // skip all (x,y) coordinates that are outside of the circle
                continue;
            }

            let deg = rad2deg(phi);

            // Figure out the starting index of this pixel in the image data array.
            let rowLength = 2*radius;
            let adjustedX = x + radius; // convert x from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let adjustedY = y + radius; // convert y from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let pixelWidth = 4; // each pixel requires 4 slots in the data array
            let index = (adjustedX + (adjustedY * rowLength)) * pixelWidth;

            let hue = deg;
            let saturation = r / radius;
            let value = 1.0;

            let [red, green, blue] = hsv2rgb(hue, saturation, value);
            let alpha = 255;

            data[index] = red;
            data[index+1] = green;
            data[index+2] = blue;
            data[index+3] = alpha;
        }
    }

    ctx.putImageData(image, 0, 0);
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const xy2polar = (x, y) => {
    let r = Math.sqrt(x*x + y*y);
    let phi = Math.atan2(y, x);
    return [r, phi];
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43s
const rad2deg = (rad) => {
    return ((rad + Math.PI) / (2 * Math.PI)) * 360;
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const hsv2rgb = (hue, saturation, value) => {
    let chroma = value * saturation;
    let hue1 = hue / 60;
    let x = chroma * (1- Math.abs((hue1 % 2) - 1));
    let r1, g1, b1;
    if (hue1 >= 0 && hue1 <= 1) {
        ([r1, g1, b1] = [chroma, x, 0]);
    } else if (hue1 >= 1 && hue1 <= 2) {
        ([r1, g1, b1] = [x, chroma, 0]);
    } else if (hue1 >= 2 && hue1 <= 3) {
        ([r1, g1, b1] = [0, chroma, x]);
    } else if (hue1 >= 3 && hue1 <= 4) {
        ([r1, g1, b1] = [0, x, chroma]);
    } else if (hue1 >= 4 && hue1 <= 5) {
        ([r1, g1, b1] = [x, 0, chroma]);
    } else if (hue1 >= 5 && hue1 <= 6) {
        ([r1, g1, b1] = [chroma, 0, x]);
    }

    let m = value - chroma;
    let [r,g,b] = [r1+m, g1+m, b1+m];

    // Change r,g,b values from [0,1] to [0,255]
    return [255*r,255*g,255*b];
};

const getPositionFromEvent = (event) => {
    let target = event.target;
    let offsetX = target.offsetLeft;
    let offsetY = target.offsetTop;
    let check = target.offsetParent;
    while(check){
        offsetX += check.offsetLeft;
        offsetY += check.offsetTop;
        check = check.offsetParent;
    }
    let result = {
        x: event.clientX - offsetX,
        y: event.clientY - offsetY
    };
    return result;
};

const getRGBFromImageData = (x, y, width, data) => {
    let index = (y * width + x) * 4;
    return [
        data[index], // r
        data[index + 1], // g
        data[index + 2], // b
        data[index + 3] // alpha
    ];
};




/***/ }),

/***/ "./js/objects/views/drawing/DrawingView.js":
/*!*************************************************!*\
  !*** ./js/objects/views/drawing/DrawingView.js ***!
  \*************************************************/
/*! exports provided: DrawingView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawingView", function() { return DrawingView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DrawingView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _PencilTool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PencilTool.js */ "./js/objects/views/drawing/PencilTool.js");
/* harmony import */ var _EraserTool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EraserTool.js */ "./js/objects/views/drawing/EraserTool.js");
/* harmony import */ var _ColorPickerTool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ColorPickerTool.js */ "./js/objects/views/drawing/ColorPickerTool.js");
/**
 * DrawingView
 * Experimental.
 * This is still a pure webcomponent and is not
 * linked at all to SimpleTalk yet.
 *
 */





const haloButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tool" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 10h3v-3l-3.5 -3.5a6 6 0 0 1 8 8l6 6a2 2 0 0 1 -3 3l-6-6a6 6 0 0 1 -8 -8l3.5 3.5" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: inline-block;
        position: relative;
        box-sizing: border-box;
    }
    #tool-buttons {
        position: absolute;
        left: calc(100% + 5px);
        top: 0px;
        display: flex;
        flex-direction: column;
    }
    :host(.show-border){
        border: 1px solid black;
    }
    :host(:not([mode="drawing"])) > #tool-buttons {
        display: none;
    }
</style>
<canvas></canvas >
<div id="tool-buttons">
<slot></slot>
</div>
`;

class DrawingView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["PartView"] {
    constructor(){
        super();

        // Setup shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        this.colorPickerTool = null;

        this.isCurrentlyDrawing = false;

        // Bind component methods
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.toggleMode = this.toggleMode.bind(this);
        this.afterDrawAction = this.afterDrawAction.bind(this);
        this.restoreImageFromModel = this.restoreImageFromModel.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.modeChanged = this.modeChanged.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('mode', this.modeChanged);
        this.onPropChange('image', () => {
            let imageBits = this.model.partProperties.getPropertyNamed(
                this.model,
                'image'
            );
            this.restoreImageFromModel(imageBits);
        });
        this.onPropChange('show-border', (val) => {
            if(val){
                this.classList.add('show-border');
            } else {
                this.classList.remove('show-border');
            }
        });
        this.onPropChange('width', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("width", cssStyle.width);
        });
        this.onPropChange('height', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("height", cssStyle.height);
        });
    }

    modeChanged(value){
        this.setAttribute('mode', value);
    }

    afterConnected(){
        this.canvas = this.shadow.querySelector('canvas');
        this.canvas.addEventListener('mouseup', this.onMouseUp);
        this.canvas.addEventListener('mousedown', this.onMouseDown);

        // Set and store the drawing context
        this.drawingContext = this.canvas.getContext('2d');

        // If I don't have the default tools, add
        // them as real dom children now
        let pencilChild = this.querySelector('pencil-tool');
        if(!pencilChild){
            let newPencil = document.createElement('pencil-tool');
            this.append(newPencil);
        }
        let eraserChild = this.querySelector('eraser-tool');
        if(!eraserChild){
            let newEraser = document.createElement('eraser-tool');
            this.append(newEraser);
        }

        let colorPickerChild = this.querySelector('color-picker-tool');
        if(!colorPickerChild){
            let newColorPicker = document.createElement('color-picker-tool');
            // TODO this is a total hack since drawing does not work well with styles at the moment
            this.append(newColorPicker);
            newColorPicker.colorWheel.shadowRoot.querySelector('div#options').style.display = "none";
            this.colorPickerTool = newColorPicker;
        }

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
        this.canvas.removeEventListener('mouseup', this.onMouseUp);
        this.canvas.removeEventListener('mousedown', this.onMouseDown);
    }

    afterModelSet(){
        // setup the canvas height and width
        // Note: what we want is the calculated CSS, not the ST part property value
        let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
        let canvas = this.shadow.querySelector('canvas');
        canvas.setAttribute("height", cssStyle.height);
        canvas.setAttribute("width", cssStyle.width);
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        if(currentImage){
            this.restoreImageFromModel(currentImage);
        }

        let initialShowBorder = this.model.partProperties.getPropertyNamed(
            this.model,
            'show-border'
        );
        if(initialShowBorder){
            this.classList.add('show-border');
        }
    }

    onMouseDown(event){
        if(event.shiftKey){
            return;
        } else if(!this.inDrawingMode) {
            // Send the mouseUp command message to self
            this.model.sendMessage({
                type: 'command',
                commandName: 'mouseUp',
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            }, this.model);
        }
        this.activeTool = this.querySelector('[role="tool"][active="true"]');
        if(!this.activeTool){
            return;
        }
        this.isCurrentlyDrawing = true;
        let canvas = this.shadow.querySelector('canvas');
        canvas.addEventListener('mousemove', this.onMouseMove);
        canvas.addEventListener('mouseleave', this.onMouseLeave);
        this.activeTool.start(event.offsetX, event.offsetY);
    }

    onMouseMove(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode){
            this.activeTool.onMove(
                event.offsetX,
                event.offsetY
            );
        } else if(this.model.partProperties.getPropertyNamed(this.model, "wants-move")){
            this.sendMessage({
                type: 'command',
                commandName: 'move',
                args: [event.movementX, event.movementY]
            }, this.model);
        }
    }

    onMouseUp(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode && this.isCurrentlyDrawing){
            this.activeTool.end(event.offsetX, event.offsetY);
            this.afterDrawAction();
        }
        this.isCurrentlyDrawing = false;
        let canvas = this.shadow.querySelector('canvas');
        canvas.removeEventListener('mousemove', this.onMouseMove);
        canvas.removeEventListener('mouseleave', this.onMouseLeave);
    }


    onMouseLeave(event){
        // If this is triggered, we left the area
        // while drawing. So call the activeTool's
        // end method
        this.activeTool.end(
            event.offsetX,
            event.offsetY
        );
        this.isCurrentlyDrawing = false;
        this.afterDrawAction();
        this.canvas.removeEventListener('mouseleave', this.onMouseLeave);
        this.canvas.removeEventListener('mousemove', this.onMouseMove);
    }

    onHaloResize(movementX, movementY){
        let canvas = this.shadowRoot.querySelector('canvas');
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        // canvas.width = canvas.width + movementX;
        // canvas.height = canvas.height + movementY;
        let newWidth = canvas.width + movementX;
        let newHeight = canvas.height + movementY;
        if(newWidth && newHeight){
            // this.style.width = `${newWidth}px`;
            // this.style.height = `${newHeight}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth,
                true
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight,
                true
            );
        }
        this.restoreImageFromModel(currentImage);
    }

    afterDrawAction(){
        // Encode canvas contents as base64 png
        // and set to model's image property
        let canvas = this.shadowRoot.querySelector('canvas');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'image',
            canvas.toDataURL()
        );
        //this.setAttribute("mode", "");
    }

    restoreImageFromModel(base64ImageData){
        // Clear and draw the image to restore to
        // the canvas
        if(base64ImageData){
            let canvas = this.shadowRoot.querySelector('canvas');
            let context = canvas.getContext('2d');
            let img = new Image();
            img.onload = function(){
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(img, 0, 0);
            };
            img.src = base64ImageData;

            // Set the border to hide
            this.model.partProperties.setPropertyNamed(
                this.model,
                'show-border',
                false
            );
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = "halo-drawing-toggle-mode";
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = haloButtonSVG;
        this.haloButton.style.marginRight = "6px";
        this.haloButton.setAttribute('slot', 'bottom-row');
        this.haloButton.setAttribute('title', 'Toggle drawing tools');
        this.haloButton.addEventListener('click', this.toggleMode);
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    toggleMode(){
        let currentMode = this.getAttribute('mode');
        let nextMode = 'viewing'; // By default, set to viewing
        let isEmpty = (!currentMode || currentMode == undefined || currentMode == "");
        if(currentMode == 'viewing' || isEmpty){
            nextMode = 'drawing';
        }
        this.model.partProperties.setPropertyNamed(
            this.model,
            'mode',
            nextMode
        );
    }

    get inDrawingMode(){
        if(!this.model){
            return false;
        }
        let mode = this.getAttribute('mode');
        if(mode == 'drawing'){
            return true;
        }
        return false;
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/EraserTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/EraserTool.js ***!
  \************************************************/
/*! exports provided: EraserTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EraserTool", function() { return EraserTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EraserTool; });
/**
 * EraserTool
 * -----------------------------------
 * I provide eraser-like functionality on
 * my parent element's shadow canvas.
 * I am specifically designed for use as a
 * child of DrawingView
 */
const eraserSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-eraser" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 19h-11l-4 -4a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9 9" />
  <line x1="18" y1="12.3" x2="11.7" y2="6" />
</svg>
`;

const eraserToolTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${eraserSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class EraserTool extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = eraserToolTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool is
        // connected to a parent element that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
                this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.cachedStrokeStyle = this.ctx.strokeStyle;
        this.ctx.strokeStyle = 'red';
        this.ctx.globalCompositeOperation = 'destination-out';
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.strokeStyle = this.cachedStrokeStyle;
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};
window.customElements.define('eraser-tool', EraserTool);




/***/ }),

/***/ "./js/objects/views/drawing/PencilTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/PencilTool.js ***!
  \************************************************/
/*! exports provided: PencilTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PencilTool", function() { return PencilTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PencilTool; });
/**
 * PencilTool
 * --------------------------
 * I provide pencil-like drawing capability
 * on the shadow canvas of my parent element.
 * I am explicitly designed for use with
 * DrawingView
 */
const pencilSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
  <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
</svg>
`;

const pencilTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${pencilSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class PencilTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = pencilTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context
        // is null. This will be set
        // if and when this tool is
        // connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
            this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};

window.customElements.define('pencil-tool', PencilTool);




/***/ }),

/***/ "./js/objects/views/editors/Editor.js":
/*!********************************************!*\
  !*** ./js/objects/views/editors/Editor.js ***!
  \********************************************/
/*! exports provided: Editor, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Editor; });
/* harmony import */ var _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorTab.js */ "./js/objects/views/editors/EditorTab.js");
/* harmony import */ var _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditorPropList.js */ "./js/objects/views/editors/EditorPropList.js");
/* harmony import */ var _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditorMessenger.js */ "./js/objects/views/editors/EditorMessenger.js");
/* harmony import */ var _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditorCustomList.js */ "./js/objects/views/editors/EditorCustomList.js");
/* harmony import */ var _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditorSubpartsPane.js */ "./js/objects/views/editors/EditorSubpartsPane.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");






// PREAMBLE

// Add editor tab element
window.customElements.define('editor-tab', _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
window.customElements.define('editor-props-list', _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
window.customElements.define('editor-custom-list', _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('editor-messenger', _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('editor-subparts', _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

const closeButton = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
</svg>
`;

const scriptIcon = `
<svg id='script' xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-file-code" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M14 3v4a1 1 0 0 0 1 1h4" />
    <path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" />
    <path d="M10 13l-1 2l1 2" />
    <path d="M14 13l1 2l-1 2" />
</svg>`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        transform: translateX(-105%);
        transition: transform 150ms linear;
        width: 400px;
        height: 100%;
        background-color: white;
        padding: 8px;
        border-right: 1px solid rgba(0, 0, 0, 0.5);
        box-shadow: 0px 1px 10px 2px rgba(0, 0, 0, 0.3);
    }
    
    :host(.open){
        transform: translateX(0%);
        transition: transform 150ms linear;
        z-index: 100;
    }

    :host(::after) {
        content: " ";
        height: 100%;
        width: 5px;
        background-color: black;
        display: block;
        position: absolute;
        top: 0;
        right: -10;
        box-shadow: 0px 0px 3px 10px rgba(100, 100, 100, 0.6);
    }

    ::slotted(editor-props-list:not(.show-pane)),
    ::slotted(editor-messenger:not(.show-pane)),
    ::slotted(editor-custom-list:not(.show-pane)),
    ::slotted(editor-subparts:not(.show-pane)){
        display: none;
    }

    #tab-area {
        display: inline-flex;
        align-items: center;
        justify-content: space-around;
        width: 100%;
    }
    
    #pane-area {
        display: block;
        flex: 1;
        margin-top: 20px;
        overflow: hidden;
    }

    #header-area {
        display: flex;
        font-family: 'Helvetica', sans-serif;
        margin-bottom: 20px;
    }

    .header-side {
        flex: 1;
        margin-top: 20px;
    }

    #display-area {
        display: flex;
        align-items: center;
        margin-bottom: 30px;
    }

    #header-area h3 {
        display: inline-block;
        margin: 0;
        margin-right: 8px;
        margin-left: 5px;
        font-size: 1.7rem;
    }

    #header-left > input {
        display: inline-block;
        padding: 4px;
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.8);
        font-size: 1.1rem;
    }

    #header-right > button {
        width: 100%;
        background-color: transparent;
        border: 1px solid transparent;
        outline: none;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        font-size: 0.85em;
    }

    #header-right > button:hover {
        cursor: pointer;
        border: 1px solid rgba(150, 150, 150, 0.3);
    }

    #header-right > button:active {
        border: 1px solid rgba(150, 150, 150, 0.8);
        background-color: rgba(220, 220, 220);
    }

    #header-right > button > svg {
        height: 1.3em;
        width: auto;
        margin-right: 8px;
    }

    #header-left {
        max-width: 80%;
    }

    #header-left span {
        font-family: monospace;
        font-size: 1.1rem;
        color: rgba(0, 0, 0, 0.5);
        text-overflow: ellipsis;
        overflow: hidden;
    }

    #icon-display-area {
        width: 1.7rem;
        height: 1.7rem;
        margin-bottom: 5px;
    }
    #icon-display-area > svg {
        width: 100%;
        height: 100%;
    }

    #close-button {
        display: block;
        position: absolute;
        top: 5;
        right: 5;
    }
    #close-button:hover {
        cursor: pointer;
    }
</style>
<div id="close-button">${closeButton}</div>
<div id="header-area">
    <div id="header-left" class="header-side">
        <div id="display-area">
            <div id="icon-display-area"></div>
            <h3></h3><span></span>
        </div>
        <input type="text" id="part-name-input"/>
    </div>
    <div id="header-right" class="header-side">
        <button id="edit-script-button">
            ${scriptIcon}
            <span>Edit Script</span>
        </button>
    </div>
</div>
<div id="tab-area">
    <editor-tab active="true" name="properties">Properties</editor-tab>
    <editor-tab name="custom">Custom</editor-tab>
    <editor-tab name="messenger">Messenger</editor-tab>
    <editor-tab name="subparts">Subparts</editor-tab>
</div>
<div id="pane-area">
    <slot></slot>
</div>
`;

class Editor extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.render = this.render.bind(this);
        this.centerOnElement = this.centerOnElement.bind(this);
        this.undoCenterOnElement = this.undoCenterOnElement.bind(this);
        this.updateHeader = this.updateHeader.bind(this);
        this.checkForNavigation = this.checkForNavigation.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.onTabActivated = this.onTabActivated.bind(this);
        this.onNameInputChange = this.onNameInputChange.bind(this);
        this.onEditScriptClick = this.onEditScriptClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this._shadowRoot.addEventListener('tab-activated', this.onTabActivated);
            this._shadowRoot.getElementById('close-button').addEventListener(
                'click',
                this.close
            );

            // Events
            let nameInput = this._shadowRoot.getElementById('part-name-input');
            nameInput.addEventListener('change', this.onNameInputChange);

            let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
            editScriptButton.addEventListener('click', this.onEditScriptClick);
        }
    }

    disconnectedCallback(){
        this._shadowRoot.removeEventListener('tab-activated', this.onTabActivated);
        this._shadowRoot.getElementById('close-button').removeEventListener(
            'click',
            this.close
        );
        
        // Events
        let nameInput = this._shadowRoot.getElementById('part-name-input');
        nameInput.removeEventListener('change', this.onNameInputChange);

        let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
        editScriptButton.removeEventListener('click', this.onEditScriptClick);
    }

    toggle(){
        if(this.isOpen){
            this.close();
        } else {
            this.open();
        }
    }

    open(){
        this.classList.add('open');
        this.centerOnElement();
    }

    close(){
        this.classList.remove('open');
        this.undoCenterOnElement();
    }

    render(aModel){
        if(this.model){
            this.model.removePropertySubscriber(this);
        }
        this.model = aModel;
        this.model.addPropertySubscriber(this);

        // If the incoming model is a Card or
        // Stack that is not the current one,
        // we navigate to it
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.checkForNavigation();
        }

        // Close any open Halos.
        // If the new model wants a Halo,
        // open it on the View for that Model.
        Array.from(document.querySelectorAll(`.editing`)).forEach(el => {
            el.closeHalo();
        });
        let targetView = document.querySelector(`[part-id="${this.model.id}"]`);
        if(targetView && targetView.wantsHalo){
            targetView.openHalo();
        }
        
        this.updateHeader();

        // Clear slotted inner DOM
        this.innerHTML = "";

        // Add panes
        let propsPane = document.createElement('editor-props-list');
        propsPane.setAttribute('tab-name', 'properties');
        this.appendChild(propsPane);
        propsPane.render(this.model);

        let messengerPane = document.createElement('editor-messenger');
        messengerPane.setAttribute('tab-name', 'messenger');
        this.appendChild(messengerPane);
        messengerPane.render(this.model);

        let customPane = document.createElement('editor-custom-list');
        customPane.setAttribute('tab-name', 'custom');
        this.appendChild(customPane);
        customPane.render(this.model);

        let subpartsPane = document.createElement('editor-subparts');
        subpartsPane.setAttribute('tab-name', 'subparts');
        this.appendChild(subpartsPane);
        subpartsPane.render(this.model);

        // Find the active tab and show its corresponding pane
        let activeTab = this._shadowRoot.querySelector(`editor-tab[active="true"]`);
        if(activeTab){
            let activeName = activeTab.getAttribute('name');
            Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
                let name = pane.getAttribute('tab-name');
                if(name == activeName){
                    pane.classList.add('show-pane');
                } else {
                    pane.classList.remove('show-pane');
                }
            });
        }

        // If this pane is already open, then center
        // on the primary view element for the model
        if(this.isOpen){
            this.centerOnElement();
        }
    }

    centerOnElement(){
        // Use CSS transforms of the whole World to center on
        // the primary view element of the Part being edited,
        // if set. If not set, do nothing.
        if(this.model){
            // If we are editing a Card, Stack, or World, then
            // we uncenter and return
            let isCardStackOrWorld = ['card', 'stack', 'world'].includes(this.model.type);
            if(isCardStackOrWorld){
                return this.undoCenterOnElement();
            }
            
            let partView = window.System.findViewById(this.model.id);
            let worldView = window.System.findViewById('world');
            let current = worldView.getAttribute('centered-on');
            if(current == this.model.id.toString()){
                return;
            }

            let menuRect = this.getBoundingClientRect();
            let partRect = partView.getBoundingClientRect();

            // Get the actual viewable width, plus the editor menu
            let viewWidth = window.innerWidth + menuRect.width;
            let viewHeight = window.innerWidth - menuRect.height;

            // Calculate X translation
            let targetX = (viewWidth - partRect.width) / 2;
            let newX;
            if(targetX < partRect.left){
                newX = (partRect.left - targetX) * -1;
            } else {
                newX = targetX - partRect.left;
            }

            // Calculate Y translation
            let targetY = (viewHeight - partRect.height) / 2;
            let newY;
            if(targetY < partRect.top){
                newY = (partRect.top - targetY) * -1;
            } else {
                newY = targetY - partRect.top;
            }

            worldView.setAttribute('centered-on', this.model.id);
            
            // Set transform and transition
            worldView.style.transition = "transform 0.3s ease-out";
            worldView.style.transform = `translate(${newX}px, ${newY}px)`;
        }
    }

    undoCenterOnElement(){
        let worldView = window.System.findViewById('world');
        worldView.removeAttribute('centered-on');
        worldView.style.removeProperty('transform');
    }

    updateHeader(){
        let nameInput = this._shadowRoot.querySelector('#header-left > input');
        let typeDisplay = this._shadowRoot.querySelector('#display-area > h3');
        let idDisplay = this._shadowRoot.querySelector('#display-area > span');
        let iconDisplay = this._shadowRoot.getElementById('icon-display-area');

        let partName = this.model.partProperties.getPropertyNamed(
            this.model,
            'name'
        );

        if(partName && partName !== ""){
            nameInput.value = partName;
        } else {
            nameInput.value = "(Unnamed)";
        }

        typeDisplay.textContent = this.model.type.charAt(0).toUpperCase() + this.model.type.slice(1);
        idDisplay.textContent = `id=${this.model.id}`;
        idDisplay.title = this.model.id;

        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"]).includes(this.model.type)){
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"][this.model.type];
        } else {
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"].generic;
        }
    }

    checkForNavigation(){
        // If the model is a Card or Stack that
        // is not the current (ie, not being displayed
        // in the main window), then we should navigate
        // to it
        let currentStack = window.System.world.currentStack;
        let currentCard = currentStack.currentCard;
        if(this.model.type == 'card' && this.model.id != currentCard.id){
            currentStack.goToCardById(this.model.id);
        } else if(this.model.type == 'stack' && this.model.id != currentStack.id){
            window.System.world.goToStackById(this.model.id);
        }
        
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            // Find any nested editor-prop-item elements
            // and re-render, so they display the correct
            // values in the editor
            let queryString = `editor-prop-item[name="${aMessage.propertyName}"][owner-id="${aMessage.partId}"]`;
            Array.from(this.querySelectorAll(queryString)).forEach(el => {
                if(el.property.value !== aMessage.value){
                    el.render();
                }
            });
            break;
        }
    }

    onTabActivated(event){
        Array.from(this._shadowRoot.querySelectorAll('editor-tab'))
            .filter(tabEl => {
                return tabEl !== event.target;
            }).forEach(tabEl => {
                tabEl.removeAttribute('active');
            });

        // Get the name of the activated tab
        let targetName = event.target.getAttribute('name');
        Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
            let name = pane.getAttribute('tab-name');
            if(name == targetName){
                pane.classList.add('show-pane');
            } else {
                pane.classList.remove('show-pane');
            }
        });
    }

    onNameInputChange(event){
        if(this.model){
            let newName = event.target.value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'name',
                newName
            );
        }
    }

    onEditScriptClick(event){
        if(this.model){
            this.model.sendMessage({
                type: 'command',
                commandName: 'openScriptEditor',
                args: [
                    this.model.id
                ]
            }, this.model);
            this.close();
        }
    }

    get isOpen(){
        return this.classList.contains('open');
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorCustomList.js":
/*!******************************************************!*\
  !*** ./js/objects/views/editors/EditorCustomList.js ***!
  \******************************************************/
/*! exports provided: EditorCustomList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorCustomList", function() { return EditorCustomList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorCustomList; });


// PREAMBLE

const caretDownIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(180 12 12)" />
</svg>
`;

const caretRightIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(90 12 12)" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
    
    #new-prop-area {
        display: flex;
        flex-direction: column;
        width: 100%;
    }

    #new-prop-area.open > #new-prop-form {
        display:flex;
    }

    #new-prop-form {
        display: none;
        flex-direction: column;
        width: 100%;
    }

    .row {
        display: flex;
        flex-direction: row;
        width: 100%;
        align-items: center;
        margin-bottom: 1em;
    }

    h3 {
        padding: 0px;
        margin-bottom: 1em;
    }

    #new-prop-form > .row > * {
        margin-right: 16px;
        padding-left: 8px;
        padding-right: 8px;
    }
    #new-prop-form input {
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.7);
        font-family: monospace;
        padding: 6px;
    }

    #new-prop-name:invalid {
        border-bottom: 1px solid red;
    }
    
    select {
        font-size: 1em;
    }
    #add-prop-dropdown-control {
        align-items: center;
        user-select: none;
    }

    #add-prop-dropdown-control:hover,
    #add-prop-dropdown-control label {
        cursor: pointer;
    }

    #caret-button {
        position: relative;
        width: 1.5em;
        height: 1.5em;
        transform: rotate(0deg);
        transition: transform 0.1s linear;
    }

    #caret-button > svg {
        width: 100%;
        height: 100%;
    }
    #new-prop-area.open #caret-button {
        transform: rotate(90deg);
        transition: transform 0.1s linear;
    }

</style>
<div id="new-prop-area">
    <div class="row" id="add-prop-dropdown-control">
        <h3><label for="caret-button">Add New Property</label></h3>
        <div id="caret-button">${caretRightIcon}</div>
    </div>
    <div id="new-prop-form">
        <div class="row">
            <label for="new-prop-name">Property Name </label>
            <input type="text" id="new-prop-name" placeholder="property-name" pattern="[a-z\\-]{3,64}"/>
        </div>
        <div class="row">
            <label for="default-val-select">Default value type</label>
            <select id="default-val-select">
                <option value="" selected>None</option>
                <option value="string">Text</option>
                <option value="number">Number</option>
                <option value="boolean">True or False</option>
            </select>
        </div>
        <div class="row">
            <label for="default-value">Default value </label>
            <input type="text" id="default-value" placeholder="Default value" disabled/>
        </div>
        <div class="row" id="submit-control">
            <button id="submit-prop">Create</button>
        </div>
    </div>
</div>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

class EditorCustomList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.resetForm = this.resetForm.bind(this);
        this.onDefaultNewTypeChange = this.onDefaultNewTypeChange.bind(this);
        this.onCaretClick = this.onCaretClick.bind(this);
        this.onCreateSubmit = this.onCreateSubmit.bind(this);
        this.onFilterInput = this.onFilterInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.newPropTypeSelect = this._shadowRoot.getElementById('default-val-select');
            this.newPropNameInput = this._shadowRoot.getElementById('new-prop-name');
            this.newPropDefaultValue = this._shadowRoot.getElementById('default-value');
            this.addPropControl = this._shadowRoot.getElementById('add-prop-dropdown-control');
            this.newPropForm = this._shadowRoot.getElementById('new-prop-form');
            this.createButton = this._shadowRoot.getElementById('submit-prop');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.filterInput = this._shadowRoot.getElementById('filter-input');
            
            // Add listeners
            this.addPropControl.addEventListener('click', this.onCaretClick);
            this.createButton.addEventListener('click', this.onCreateSubmit);
            this.filterInput.addEventListener('input', this.onFilterInput);
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any main dom children
        this.innerHTML = "";

        // Create a sorted copy of the property
        // objects
        let customProps = this.model.partProperties.getPropertyNamed(
            this.model,
            'custom-properties'
        );

        // Create a sorted list of the custom properties
        // available
        this.propList = Object.values(customProps)
            .sort((first, second) => {
                return first.name.localeCompare(second.name);
            });

        // Render the property items and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });

        // Set up event listeners
        this.newPropTypeSelect.removeEventListener('change', this.onDefaultNewTypeChange);
        this.newPropTypeSelect.addEventListener('change', this.onDefaultNewTypeChange);
    }

    onDefaultNewTypeChange(event){
        let option = event.target.selectedOptions[0];
        switch(option.value){
        case 'string':
            this.newPropDefaultValue.setAttribute('type', 'text');
            this.newPropDefaultValue.setAttribute('value', "");
            break;
        case 'number':
            this.newPropDefaultValue.setAttribute('type', 'number');
            this.newPropDefaultValue.setAttribute('value', 0);
            break;
        case 'boolean':
            this.newPropDefaultValue.setAttribute('type', 'checkbox');
            break;
        default:
            this.newPropDefaultValue.setAttribute('type', 'text');
        }

        if(option.value == ""){
            this.newPropDefaultValue.setAttribute('disabled', true);
        } else {
            this.newPropDefaultValue.removeAttribute('disabled');
        }
    }

    onCaretClick(event){
        let newPropArea = this._shadowRoot.getElementById('new-prop-area');
        newPropArea.classList.toggle('open');
    }

    onCreateSubmit(event){
        if(this.model){
            let propName = this.newPropNameInput.value;
            let defaultValue = this.newPropDefaultValue.value;
            if(this.newPropDefaultValue.type == 'checkbox'){
                defaultValue = this.newPropDefaultValue.checked;
            } else if(this.newPropDefaultValue.type == 'number'){
                defaultValue = parseFloat(this.newPropDefaultValue.value);
            }

            // Send the property create message
            this.model.sendMessage({
                type: 'command',
                commandName: 'newProperty',
                args: [
                    propName,
                    this.model.id
                ]
            }, this.model);

            // Set the created prop to the default
            // value
            this.model.partProperties.setPropertyNamed(
                this.model,
                propName,
                defaultValue
            );

            // Re-render this pane
            this.resetForm();
            this.render(this.model);
        }
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onFilterInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInput.value = "";
        this.filterBy("");
    }

    resetForm(){
        this.newPropNameInput.value = null;
        this.newPropDefaultValue.value = null;
        if(this.newPropDefaultValue.type == 'checked'){
            this.newPropDefaultValue.checked = false;
        }
        this.newPropDefaultValue.type = 'text';
        this.newPropDefaultValue.setAttribute('disabled', true);
        this.newPropTypeSelect.selectedIndex = 0;
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorLocationInfo.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorLocationInfo.js ***!
  \********************************************************/
/*! exports provided: EditorLocationInfo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorLocationInfo", function() { return EditorLocationInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorLocationInfo; });
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");



// PREAMBLE
const arrowLeftIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrow-narrow-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12" />
  <line x1="5" y1="12" x2="9" y2="16" />
  <line x1="5" y1="12" x2="9" y2="8" />
</svg>
`;

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host(.hidden){
        display: none;
    }
    .button-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .button-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .button-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .button-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
</style>
<p class="part-info">
    My <button id="owner-link" class="button-link" title=""><span></span>${arrowLeftIcon}</button> is named <span class="part-name"></span> and is located at <button id="location-link" class="button-link" title="Copy location"><span></span>${clipboardIcon}</button> <button id="id-link" class="button-link" title="Copy id"><span>Copy id</span>${clipboardIcon}</button>
</p>
`;

class EditorLocationInfo extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Accepted values for the kind attribute
        this.allowedKinds = ['stack', 'card', 'owner'];

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.handleStackKind = this.handleStackKind.bind(this);
        this.handleCardKind = this.handleCardKind.bind(this);
        this.updateInfo = this.updateInfo.bind(this);
        this.getAncestorOfTypeFor = this.getAncestorOfTypeFor.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
        this.onLinkClick = this.onLinkClick.bind(this);
        this.onMouseEnter = this.onMouseEnter.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
    }

    connectedCallback(){
        // Events
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        ownerLinkButton.addEventListener('click', this.onLinkClick);
        locationLinkButton.addEventListener('click', this.onLocationClick);
        idLinkButton.addEventListener('click', this.onLocationClick);
        locationLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.addEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.addEventListener('mouseleave', this.onMouseLeave);
    }

    disconnectedCallback(){
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        locationLinkButton.removeEventListener('click', this.onLocationClick);
        idLinkButton.removeEventListener('click', this.onLocationClick);
        ownerLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
    }

    render(aModel){
        this.model = aModel;
        let kind = this.getAttribute('kind');
        if(!kind || !this.allowedKinds.includes(kind)){
            this.classList.add('hidden');
            return;
        }
        if(this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }

        this.classList.remove('hidden');

        // Update element references
        this.ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        this.ownerLinkTypeSpan = this.ownerLinkButton.querySelector('span');
        this.locationLinkButton = this._shadowRoot.getElementById('location-link');
        this.locationLinkSpan = this.locationLinkButton.querySelector('span');
        this.idLinkButton = this._shadowRoot.getElementById('id-link');
        this.idLinkSpan = this.idLinkButton.querySelector('span');
        this.nameSpan = this._shadowRoot.querySelector('p .part-name');

        if(kind == 'stack'){
            this.handleStackKind();
        } else if(kind =='card'){
            this.handleCardKind();
        } else {
            this.updateInfo();
        }
    }

    updateInfo(){
        let kind = this.getAttribute('kind');
        let ancestor = this.model._owner;
        if(kind == 'stack' || kind == 'card'){
            ancestor = this.getAncestorOfTypeFor(this.model, kind);
        }

        // If we cannot find an ancestor of the given
        // kind, then we hide this field
        if(!ancestor){
            this.classList.add('hidden');
            return;
        }

        // Update name span
        let ancestorName = ancestor.partProperties.getPropertyNamed(
            ancestor,
            'name'
        );
        if(!ancestorName){
            ancestorName = '(unnamed)';
        } else {
            ancestorName = `"${ancestorName}"`;
        }
        this.nameSpan.textContent = ancestorName;

        // Update kind span
        let kindLabel = kind[0].toUpperCase() + kind.slice(1);
        this.ownerLinkTypeSpan.textContent = kindLabel;

        // Update location link span
        this.locationLinkSpan.textContent = this.getLocationStringFor(ancestor);

        // Update button titles
        let editTitle = `Edit owning ${kindLabel}`;
        if(kind == 'owner'){
            editTitle = 'Edit Owner';
        }
        this.ownerLinkButton.setAttribute(
            'title',
            editTitle
        );

        // Add the ref-id attribute
        this.setAttribute('ref-id', ancestor.id);
    }

    handleStackKind(){
        if(this.model.type == 'stack' || this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    handleCardKind(){
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    getAncestorOfTypeFor(aPart, aType){
        let result;
        let currentOwner = aPart._owner;
        while(currentOwner){
            if(currentOwner.type == aType){
                result = currentOwner;
                break;
            }
            currentOwner = currentOwner._owner;
        }
        return result;
    }

    onLinkClick(event){
        let id = this.getAttribute('ref-id');
        if(id && this.model){
            // Re-render the editor on the Part
            // referenced by the found id
            let target = window.System.partsById[id];
            window.System.editor.render(target);
        }
    }

    onMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    getLocationViews(event){
        let targetId;
        let span = event.currentTarget.querySelector('span');
        if(span.parentElement.id == 'id-link'){
            targetId = this.getAttribute('ref-id');
        } else {
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.System.partsById['world'], window.System)
            );
            let m = window.System.grammar.match(span.textContent, "ObjectSpecifier");
            try{
                targetId = semantics(m).interpret();
            } catch(e){
                console.log(`cannot locate ${span.textContent}`);
            }
        }
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorMessenger.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/editors/EditorMessenger.js ***!
  \*****************************************************/
/*! exports provided: EditorMessenger, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorMessenger", function() { return EditorMessenger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorMessenger; });


// PREAMBLE
const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }
   
    textarea {
        resize: none;
        flex: 0.25;
    }
</style>
<h3>Send this <span></span> a Message:</h3>
<textarea placeholder="Type your Simpletalk message here..."></textarea>
<button>Send</button>
`;

class EditorMessenger extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onMessageFieldInput = this.onMessageFieldInput.bind(this);
        this.sendMessageFromText = this.sendMessageFromText.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.sendButton = this._shadowRoot.querySelector('button');
            this.sendButton.addEventListener('click', this.sendMessageFromText);
        
            this.messageField = this._shadowRoot.querySelector('textarea');
            this.messageField.addEventListener('input', this.onMessageFieldInput);
        }
    }

    disconnectedCallback(){
        this.messageField.removeEventListener('input', this.onMessageFieldInput);
        this.sendButton.removeEventListener('click', this.sendMessageFromText);
    }

    render(aModel){
        this.model = aModel;
        
        let partTypeLabel = this._shadowRoot.querySelector('h3 > span');
        partTypeLabel.textContent = this.model.type;
    }

    onMessageFieldInput(event){

    }

    sendMessageFromText(){
        let text = this.messageField.value;
        let script = `on doIt\n\t${text}\nend doIt`;
        this.model.sendMessage({
            type: 'compile',
            codeString: script,
            targetId: this.model.id
        }, this.model);
        this.model.sendMessage({
            type: 'command',
            commandName: 'doIt',
            args: [],
            shouldIgnore: true
        }, this.model);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropItem.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropItem.js ***!
  \****************************************************/
/*! exports provided: EditorPropItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropItem", function() { return EditorPropItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropItem; });
// PREAMBLE

const checkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>
`;

const cancelIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#ff2825" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M10 10l4 4m0 -4l-4 4" />
</svg>
`;

const templateString = `
<style>
    li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px;
        padding-left: 8px;
        padding-right: 8px;
        margin-top: 6px;
    }
   
    li > label {
        flex: 1;
    }

    :host {
        width: 100%;
    }

    :host(.item-hidden) {
        display:none;
    }

    button {
        outline: none;
        border: 1px solid transparent;
        background-color: transparent;
        opacity: 1.0;
        transition: opacity 0.1s linear;
    }

    button:disabled {
        opacity: 0.05;
        transition: opacity: 0.1s linear;
    }

    button:hover {
        cursor: pointer;
    }

    button.button-hidden {
        display: none;
    }

    label {
        font-family: monospace;
    }

    input {
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.5);
        outline: none;
    }
    
    input:focus {
        border: 1px solid rgba(100, 100, 100, 0.8);
    }
</style>
<li>
    <label for="prop-value"></label>
    <input id="prop-value" name="prop-value"/>
    <button id="accept" disabled>${checkIcon}</button>
    <button id="cancel" disabled>${cancelIcon}</button>
</li>
`;

class EditorPropItem extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // By default, there is no property
        this.property = null;
        this.owner = null;

        // Bound methods
        this.render = this.render.bind(this);
        this.onInputChange = this.onInputChange.bind(this);
        this.onInputInput = this.onInputInput.bind(this);
        this.onAcceptClick = this.onAcceptClick.bind(this);
        this.onCancelClick = this.onCancelClick.bind(this);
        this.onEnterKey = this.onEnterKey.bind(this);
        this.setupNumericInput = this.setupNumericInput.bind(this);
        this.enableButtons = this.enableButtons.bind(this);
        this.disableButtons = this.disableButtons.bind(this);
    }

    setProperty(aProperty, anOwner){
        // Remove any existing event handlers
        // TODO
        this.property = aProperty;
        this.owner = anOwner;

        // Update the element attributes
        this.setAttribute('name', this.property.name);
        this.setAttribute('owner-id', this.owner.id);

        // Add new event handlers

        // Render
        this.render();
        
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('keypress', this.onEnterKey);
        }
    }

    disconnectedCallback(){
        this.removeEventListener('keypress', this.onEnterKey);
    }

    render(){
        this.labelElement = this._shadowRoot.querySelector('label');
        this.inputElement = this._shadowRoot.querySelector('input');
        this.acceptButton = this._shadowRoot.getElementById('accept');
        this.cancelButton = this._shadowRoot.getElementById('cancel');

        // Remove any hide classes
        this.acceptButton.classList.remove('button-hidden');
        this.cancelButton.classList.remove('button-hidden');
        
        // Remove any bound events
        this.inputElement.removeEventListener('input', this.onInputInput);
        this.inputElement.removeEventListener('change', this.onInputChange);
        this.acceptButton.removeEventListener('click', this.onAcceptClick);
        this.cancelButton.removeEventListener('click', this.onCancelClick);

        // Add new events
        this.inputElement.addEventListener('input', this.onInputInput);
        this.inputElement.addEventListener('change', this.onInputChange);
        this.acceptButton.addEventListener('click', this.onAcceptClick);
        this.cancelButton.addEventListener('click', this.onCancelClick);
        
        this.labelElement.textContent = `${this.property.name}:`;
        let currentVal = this.property.getValue(this.owner);
        if(currentVal == null || currentVal == undefined){
            // Do something different here
        } else if(typeof(currentVal) == 'number'){
            this.setupNumericInput();
        } else if(typeof(currentVal) == 'boolean'){
            this.inputElement.setAttribute('type', 'checkbox');
            this.inputElement.checked = currentVal;
            this.acceptButton.classList.add('button-hidden');
            this.cancelButton.classList.add('button-hidden');
        } else {
            this.inputElement.setAttribute('type', 'text');
        }

        this.inputElement.setAttribute('placeholder', currentVal);
        this.inputElement.value = currentVal;
    }

    setupNumericInput(){
        if(this.property.name.endsWith('-transparency')){
            this.inputElement.setAttribute('type', 'range');
            this.inputElement.setAttribute('step', '0.05');
            this.inputElement.setAttribute('min', '0.0');
            this.inputElement.setAttribute('max', '1.0');
        } else {
            this.inputElement.setAttribute('type', 'number');
        }
    }

    onInputChange(event){
        if(event.target.type == "checkbox"){
            this.owner.partProperties.setPropertyNamed(
                this.owner,
                this.property.name,
                event.target.checked
            );
        }
    }

    onInputInput(event){
        let inputType = event.target.getAttribute('type');
        if(inputType == 'range'){
            return this.onAcceptClick();
        }
        if(event.target.value !== this.property.getValue(this.owner)){
            this.enableButtons();
        } else {
            this.disableButtons();
        }
    }

    onEnterKey(event){
        if(event.key == 'Enter'){
            this.onAcceptClick();
        }
    }

    enableButtons(){
        this.acceptButton.removeAttribute('disabled');
        this.cancelButton.removeAttribute('disabled');
    }

    disableButtons(){
        this.acceptButton.setAttribute('disabled', true);
        this.cancelButton.setAttribute('disabled', true);
    }

    onAcceptClick(event){
        let value = this.inputElement.value;
        if(this.inputElement.type == 'number'){
            value = parseFloat(value);
            if(isNaN(value)){
                // if we can't parse the value just let it go through
                // as it might be a prop style keyword such as "fill"
                // TODO: we might want to limit this to a set of prop keywords
                value = this.inputElement.value;
            }
        } else if(this.inputElement.type == 'range'){
            value = parseFloat(value);
        } else if(this.inputElement.type == 'checkbox'){
            value = this.inputElement.checked;
        }
        this.owner.partProperties.setPropertyNamed(
            this.owner,
            this.property.name,
            value
        );
        this.disableButtons();
    }

    onCancelClick(event){
        this.inputElement.value = this.owner.partProperties.getPropertyNamed(
            this.owner,
            this.property.name
        );
        this.disableButtons();
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropList.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropList.js ***!
  \****************************************************/
/*! exports provided: EditorPropList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropList", function() { return EditorPropList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropList; });
/* harmony import */ var _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorPropItem.js */ "./js/objects/views/editors/EditorPropItem.js");


// PREAMBLE
window.customElements.define('editor-prop-item', _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
</style>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

const specialProps = [
    'cssStyle',
    'cssTextStyle',
    'id',
    'name',
    'target',
    'events',
    'current',
    'script',
    'custom-properties'
];

class EditorPropList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onInput = this.onInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.filterInputElement = this._shadowRoot.getElementById('filter-input');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any existing main DOM children
        this.innerHTML = "";
        let inputEl = this._shadowRoot.getElementById('filter-input');
        inputEl.removeEventListener('input', this.onInput);
        inputEl.addEventListener('input', this.onInput);

        // Create a sorted copy of the property objects
        this.propList = this.model.partProperties.all.slice().filter(prop => {
                return !specialProps.includes(prop.name);
            });
        this.propList
            .sort((first, second) => {
            return first.name.localeCompare(second.name);
        });

        // Render the list item elements and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInputElement.value = "";
        this.filterBy("");
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorSubpartsPane.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorSubpartsPane.js ***!
  \********************************************************/
/*! exports provided: EditorSubpartsPane, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorSubpartsPane", function() { return EditorSubpartsPane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorSubpartsPane; });
/* harmony import */ var _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorLocationInfo.js */ "./js/objects/views/editors/EditorLocationInfo.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");
// PREAMBLE




window.customElements.define('editor-location-info', _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    :host() > li {
        background-color: red;
    }

    .id-link,
    .location-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .id-link:hover,
    .location-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .id-link > svg,
    .location-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .id-link:hover > svg,
    .location-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    section {
        display: flex;
        flex-direction: column;
        margin: 6px;
    }

    #button-area {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;'
    }

    #subparts-list-wrapper {
        flex: 1;
        overflow-y: hidden;
    }

    .hidden {
        display: none;
    }

    #subparts-area {
        flex: 1;
        list-style: none;
        font-family: 'Helvetica', sans-serif;
        padding: 0;
        margin: 0;
        margin-left: 32px;
        overflow-y: auto;
    }
</style>
<section id="button-area">
    <slot name="button"></slot>
</section>
<section id="location-area">
    <h3>Part Location and Owners</h3>
    <p class="part-info">
        I am located at <button class="location-link"><span></span>${clipboardIcon}</button>
        and my id is <button class="id-link"><span></span>${clipboardIcon}</button>
    </p>
    <slot name="ancestor-info"></slot>
</section>
<section id="subparts-list-wrapper">
    <h3>Subparts</h3>
    <ol id="subparts-area">
        <slot></slot>
    </ol>
</section>
`;

class EditorSubpartsPane extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.onAddSubpart = this.onAddSubpart.bind(this);
        this.onSubpartItemClick = this.onSubpartItemClick.bind(this);
        this.onSubpartItemMouseEnter = this.onSubpartItemMouseEnter.bind(this);
        this.onSubpartItemMouseLeave = this.onSubpartItemMouseLeave.bind(this);
        this.createAddPartButton = this.createAddPartButton.bind(this);
        this.createSubpartComponent = this.createSubpartComponent.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.headerEl = this._shadowRoot.getElementById('location-area');
            this.myLocationArea = this.headerEl.querySelector('p');
            this.myLocationButton = this.myLocationArea.querySelector('.location-link');
            this.myIdButton = this.myLocationArea.querySelector('.id-link');

            // Add event listener to buttons
            this.myLocationButton.addEventListener('click', this.onLocationLinkClick);
            this.myIdButton.addEventListener('click', this.onLocationLinkClick);
        }
    }

    disconnectedCallback(){
        this.myLocationButton.removeEventListener('click', this.onLocationLinkClick);
        this.myIdButton.removeEventListener('click', this.onLocationLinkClick);
    }

    render(aModel){
        this.model = aModel;
        this.headerEl = this._shadowRoot.getElementById('location-area');

        // Clear any DOM children
        this.innerHTML = "";


        // Create location link elements
        // and also the self-location element
        let myLocationText = this.getLocationStringFor(this.model);
        this.myLocationButton.querySelector('span').textContent = myLocationText;
        this.myIdButton.querySelector('span').textContent = this.model.id.toString();
        if(this.model.type == 'world'){
            this.headerEl.classList.add('hidden');
        } else {
            this.headerEl.classList.remove('hidden');

            // Create the info elements
            ['stack', 'card', 'owner'].forEach(kind => {
                let infoEl = document.createElement('editor-location-info');
                infoEl.setAttribute('slot', 'ancestor-info');
                infoEl.setAttribute('kind', kind);
                infoEl.render(this.model);
                this.appendChild(infoEl);
            });
        }

        // Create the "add subpart" buttons for parts that are accepted by the
        // current Model part.
        this.model.acceptedSubpartTypes.forEach(partType => {
            let element = this.createAddPartButton(partType);
            this.appendChild(element);
        });

        let labelHeader = this._shadowRoot.querySelector('#subparts-list-wrapper > h3');
        if(this.model.subparts.length){
            labelHeader.textContent = "Current Subparts";
        } else {
            labelHeader.textContent = "There are no subparts";
        }

        this.model.subparts.forEach(subpart => {
            let element = this.createSubpartComponent(subpart);
            this.appendChild(element);
        });
    }

    createSubpartComponent(aPart){
        let wrapper = document.createElement('li');
        wrapper.classList.add('subpart-item');
        wrapper.setAttribute('ref-id', aPart.id);
        wrapper.addEventListener('click', this.onSubpartItemClick);
        wrapper.addEventListener('mouseenter', this.onSubpartItemMouseEnter);
        wrapper.addEventListener('mouseleave', this.onSubpartItemMouseLeave);

        // Add icon area an SVG for Part
        let iconArea = document.createElement('div');
        iconArea.classList.add('icon-display-area');
        let iconImage;
        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"]).includes(aPart.type)){
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPart.type];
        } else {
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        iconArea.innerHTML = iconImage;
        wrapper.append(iconArea);

        // Add label, name, and id info
        let labelArea = document.createElement('h3');
        labelArea.textContent = `a ${aPart.type[0].toUpperCase()}${aPart.type.slice(1)}`;
        wrapper.append(labelArea);
        let name = aPart.partProperties.getPropertyNamed(
            aPart,
            'name'
        );
        if(name && name != ""){
            let nameArea = document.createElement('span');
            nameArea.classList.add('name-span');
            nameArea.textContent = `"${name}"`;
            wrapper.append(nameArea);
        }

        let idArea = document.createElement('span');
        idArea.classList.add('id-span');
        idArea.textContent = `(${aPart.id})`;
        wrapper.append(idArea);

        return wrapper;
    }

    createAddPartButton(aPartName){
        let button = document.createElement('button');
        let icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPartName];
        if(!icon){
            icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        button.setAttribute('slot', 'button');
        button.setAttribute('data-type', aPartName);
        button.setAttribute('title', `Add a ${aPartName} to this ${this.model.type}`);
        button.classList.add('add-part-button');
        button.addEventListener('click', this.onAddSubpart);
        button.innerHTML = icon;
        return button;
    }

    onSubpartItemClick(event){
        let id = event.currentTarget.getAttribute('ref-id');
        let targetPart = window.System.partsById[id];
        if(targetPart){
            window.System.editor.render(targetPart);
        }
    }

    onSubpartItemMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onSubpartItemMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    onAddSubpart(event){
        let type = event.currentTarget.getAttribute('data-type');
        if(type){
            this.model.sendMessage({
                type: 'command',
                commandName: 'newModel',
                args: [
                    type,
                    this.model.id
                ]
            }, this.model);
        }
        this.render(this.model);
    }

    getLocationViews(event){
        let targetId = event.currentTarget.getAttribute('ref-id');
        let span = event.currentTarget.querySelector('span');
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorTab.js":
/*!***********************************************!*\
  !*** ./js/objects/views/editors/EditorTab.js ***!
  \***********************************************/
/*! exports provided: EditorTab, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorTab", function() { return EditorTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorTab; });
// PREAMBLE

const templateString = `
<style>
    :host {
        display: flex;
        flex: 1;
        align-items: center;
        justify-content: center;
        padding: 6px;
        opacity: 0.5;
        border-bottom: 2px solid rgba(100, 100, 100, 0.7);
        transition: border 0.2s linear, opacity 0.2s linear;
        user-select: none;
    }

    :host([active="true"]){
        border-bottom: 2px solid rgba(200, 0, 0, 0.9);
        opacity: 1.0;
        transition: border 0.2s linear, opacity 0.2s linear;
    }

    :host(:hover){
        cursor: pointer;
    }
</style>
<span id="label">
    <slot></slot>
</span>
`;

class EditorTab extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.onClick = this.onClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('click', this.onClick);

            // If the tab is currently activated, emit
            // the tab-activaed message
            if(this.getAttribute('active') == "true"){
                let event = new CustomEvent("tab-activated", {
                    bubbles: true
                });
                this.dispatchEvent(event);
            }
        }
    }

    disconnectedCallback(){
        this.removeEventListener('click', this.onClick);
    }

    onClick(event){
        let isActive = (this.getAttribute('active') == "true");
        if(!isActive){
            this.setAttribute('active', 'true');
            let event = new CustomEvent("tab-activated", {
                bubbles: true
            });
            this.dispatchEvent(event);
        }
    }
};




/***/ }),

/***/ "./js/objects/views/editors/utils/subparts.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/utils/subparts.js ***!
  \****************************************************/
/*! exports provided: getLocationStringFor, onLocationLinkClick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocationStringFor", function() { return getLocationStringFor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onLocationLinkClick", function() { return onLocationLinkClick; });
 const getLocationStringFor = (aPart) => {
        let result = "";
        let currentPart = aPart;
        let currentOwner = aPart._owner;
        while(currentOwner){
            let indexInParent = currentOwner.subparts.filter((subpart) => {
                return subpart.type == currentPart.type;
            }).indexOf(currentPart) + 1;
            result += `${currentPart.type} ${indexInParent} of `;
            currentPart = currentPart._owner;
            currentOwner = currentOwner._owner;
        }
        result += 'this world';
        return result;
}


const onLocationLinkClick = (event) => {
        let text = event.currentTarget.querySelector('span').textContent;
        let input = document.createElement('input');
        input.style.position = 'absolute';
        input.style.opacity = 0;
        document.body.append(input);
        let currentFocus = document.activeElement;
        input.focus();
        input.value = text;
        console.log(input.value);
        input.select();
        document.execCommand('copy');
        input.remove();
        currentFocus.focus();
}




/***/ }),

/***/ "./js/objects/views/navigator/CardRow.js":
/*!***********************************************!*\
  !*** ./js/objects/views/navigator/CardRow.js ***!
  \***********************************************/
/*! exports provided: CardRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardRow", function() { return CardRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Card Row
 * --------------------------------------------
 * I am a view on a given Stack that shows each
 * subpart card item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="cards"></slot>
`;

class CardRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedCard = this.addWrappedCard.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('card-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the Stack Model's main view element.
        // We add the st-view-added/removed CustomEvent listeners
        // here so we can react only to direct stack additions
        // to the Stack (and not, say, to Windows or other nested kinds)
        let stackView = window.System.findViewById(this.model.id);
        stackView.addEventListener('st-view-added', this.handlePartAdded);
        stackView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(removedModel){
        let stackView = window.System.findViewById(removedModel.id);
        stackView.removeEventListener('st-view-added', this.handlePartAdded);
        stackView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        if(!this.model.currentCard){
            return;
        }
        let wrappers = Array.from(this.querySelectorAll('wrapped-view'));
        wrappers.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentCard.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'card'){
            let cardPart = window.System.partsById[event.detail.partId];
            this.addWrappedCard(cardPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'card'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update number display of all wrapped views in the row
            Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToCardById(event.target.getAttribute('wrapped-id'));
        }
    }

    initView(){
        // First, we clear out any existing children
        this.innerHTML = "";

        // We iterate over each card of the stack and:
        // * Create a clone of the card view element;
        // * Attach the correct model;
        // * Set it to be a lensed view;
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'card';
        }).forEach(cardPart => {
            this.addWrappedCard(cardPart);
        });

        // Update setting the current
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedCard(aCard){
        // Insert the lensed CardView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute('slot', 'cards');
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aCard);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a card and hence not
            // displayed in the CardRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

};




/***/ }),

/***/ "./js/objects/views/navigator/Navigator.js":
/*!*************************************************!*\
  !*** ./js/objects/views/navigator/Navigator.js ***!
  \*************************************************/
/*! exports provided: STNavigator, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STNavigator", function() { return STNavigator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STNavigator; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WrappedView.js */ "./js/objects/views/navigator/WrappedView.js");
/* harmony import */ var _StackRow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StackRow.js */ "./js/objects/views/navigator/StackRow.js");
/* harmony import */ var _CardRow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CardRow.js */ "./js/objects/views/navigator/CardRow.js");
/**
 * SimpleTalk Navigator Webcomponent
 * ------------------------------------------
 * This is a standalone component that allows
 * authors to navigate the WorldStack and individual
 * Stacks therein using a convenient pop-out tray from
 * the bottom of the screen.
 **/





// Add any needed customElements
window.customElements.define('nav-stack-row', _StackRow_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('nav-card-row', _CardRow_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('wrapped-view', _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

const stackIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="50" height="50" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <polyline points="12 4 4 8 12 12 20 8 12 4"></polyline>
   <polyline points="4 12 12 16 20 12"></polyline>
   <polyline points="4 16 12 20 20 16"></polyline>
</svg>
`;

const cardIcon = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   class="icon icon-tabler icon-tabler-stack"
   width="50"
   height="20.833309"
   viewBox="0 0 24 9.9999884"
   stroke-width="2"
   stroke="currentColor"
   fill="none"
   stroke-linecap="round"
   stroke-linejoin="round"
   version="1.1"
   id="svg893">
  <metadata
     id="metadata899">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs897" />
  <path
     stroke="none"
     d="M -2.7669151,-1.2564948 H 21.233085 V 22.743505 H -2.7669151 Z"
     fill="none"
     id="path885" />
  <polyline
     points="12 4 4 8 12 12 20 8 12 4"
     id="polyline887"
     transform="translate(0,-3)" />
</svg>
`;

const templateString = `
<style>
    :host {
        box-sizing: border-box;
        position: absolute;
        width: 100%;
        bottom: 0;
        min-height: 271px;
        background-color: white;
        backdrop-filter: blur(4px);
        transition: transform 0.2s ease-out;
        padding: 20px;
        transform: translateY(100%);
        border-top: 1px solid rgba(50, 50, 50, 0.4);
        overflow-y: hidden;
        overflow-x: auto;
        z-index: 1000;
    }

    .nav-display-row {
        box-sizing: border-box;
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        margin-bottom: 15px;
    }
    .nav-icon {
        color: gray;
        margin-right: 30px;
    }
</style>
<div id="stacks-display" class="nav-display-row">
    <div id="stack-icon" class="nav-icon">${stackIcon}</div>
    <slot name="stack-row"></slot>
</div>
<div id="cards-display" class="nav-display-row">
    <div id="card-icon" class="nav-icon">${cardIcon}</div>
    <slot name="card-row"></slot>
</div>
`;

class STNavigator extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.initialized = false;
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.createCardRowFor = this.createCardRowFor.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterDisconnected(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelSet(){
        this.removeAttribute('part-id');

        // Respond to the System part-added CustomEvent
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);

        // Add a StackRow view.
        this.stackRowEl = this.querySelector(':scope > nav-stack-row');
        if(!this.stackRowEl){
            this.stackRowEl = document.createElement('nav-stack-row');
            this.stackRowEl.setAttribute('slot', 'stack-row');
            this.appendChild(this.stackRowEl);
        }
        this.stackRowEl.setModel(this.model);

        // Create any needed CardRow views for all stacks
        // currently in the world
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.createCardRowFor(stackPart);
        });

        // Init the StackRow
        this.stackRowEl.initView();
        
        // Update the current card/stack values
        this.handleCurrentChange();

        // Respond to eventual current-ness prop
        // changes from the WorldStack.
        this.onPropChange('current', this.handleCurrentChange);
    }

    handleCurrentChange(){
        // If we get here, this means that the current *stack* has changed.
        // So we need to find the correct CardRow for it and set it
        // to be the slotted one in the shadow DOM
        let currentStackId = this.model.currentStack.id.toString();
        Array.from(this.querySelectorAll('nav-card-row')).forEach(cardRow => {
            let rowId = cardRow.getAttribute('stack-id');
            cardRow.removeAttribute('slot');
            if(currentStackId == rowId){
                cardRow.setAttribute('slot', 'card-row');
                Array.from(cardRow.querySelectorAll('wrapped-view')).forEach(wrapper => {
                    wrapper.updateScaling();
                });
            }
        });
    }

    handlePartAdded(event){
        // If a new stack is added, we need to create
        // a new CardRow for it.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.createCardRowFor(stackPart);
        }
    }

    handlePartRemoved(event){
        // If a stack has been removed, we need to
        // remove the corresponding CardRow
        if(event.detail.partType == 'stack'){
            let cardRow = this.querySelector(`[stack-id="${event.detail.partId}"]`);
            if(cardRow){
                cardRow.remove();
            }
        }
    }

    createCardRowFor(aStack){
        let cardRow = document.createElement('nav-card-row');
        cardRow.setAttribute('stack-id', aStack.id);
        cardRow.setModel(aStack);
        this.appendChild(cardRow);
        cardRow.initView();
    }

    toggle(){
        this.classList.toggle('open');
        if(this.classList.contains('open')){
            this.open();
        } else {
            this.close();
        }
    }

    open(){
        this.style.transform = "translateY(0)";
    }

    close(){
        this.style.transform = "translateY(100%)";
    }

    
};




/***/ }),

/***/ "./js/objects/views/navigator/StackRow.js":
/*!************************************************!*\
  !*** ./js/objects/views/navigator/StackRow.js ***!
  \************************************************/
/*! exports provided: StackRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackRow", function() { return StackRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Stack Row
 * --------------------------------------------
 * I am a view on the WorldStack that shows each
 * subpart stack item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="stacks"></slot>
`;

class StackRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedStack = this.addWrappedStack.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }


    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('stack-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the World Model's main view element.
        // We add the st-view-added CustomEvent listener
        // here so we can react only to direct stack additions
        // to the WorldStack (and not, say, to Windows or other nested kinds)
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        let currentId = this.model.currentStack.id;
        let wrappedViews = Array.from(
            this.querySelectorAll('wrapped-view')
        );
        wrappedViews.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentStack.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.addWrappedStack(stackPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'stack'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update numbers of remaining wrapped views in this StackRow
            Array.from(this.querySelectorAll('wrapped-view')).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToStackById(
                event.target.getAttribute('wrapped-id')
            );
        }
    }

    initView(){
        // Remove any existing wrapped views
        this.innerHTML = "";

        // We iterate over each corresponding Stack and:
        // * Create a clone of its view node;
        // * Attach the correct model;
        // * Set it to be a lensed view
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.addWrappedStack(stackPart);
        });

        // Setup the initial current-ness display
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedStack(aStack){  
        // Insert the lensed StackView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute("slot", "stacks");
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aStack);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a stack and hence not
            // displayed in the StackRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }
};




/***/ }),

/***/ "./js/objects/views/navigator/WrappedView.js":
/*!***************************************************!*\
  !*** ./js/objects/views/navigator/WrappedView.js ***!
  \***************************************************/
/*! exports provided: WrappedView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrappedView", function() { return WrappedView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WrappedView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * WrappedView Component
 * ---------------------------------------
 * I am a plain Webcomponent whose purpose is to
 * wrap a visual copy of an actual SimpleTalk View
 * element and display it in a scaled down format.
 * I make a cloned copy of the underlying view and
 * attach it to the same model as the original.
 **/


const templateString = `
<style>
    #number-display {
        opacity: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 100%;
        transition: opacity 0.2s ease-in;
        font-size: 2.2rem;
    }

    #number-display > span {
        transform: translateY(-10px);
        transition: transform 0.2s linear;
        pointer-events: none;
    }

    :host(:not(.current)) > #number-display {
        opacity: 0.8;
        background-color: rgba(200, 200, 200, 0.5);
        transition: opacity 0.2s ease-out;
        z-index: 1000;
    }

    :host(:not(.current)) > #number-display > span {
        transform: translateY(0px);
        transition: transform 0.2s linear;
    }
</style>
<div id="number-display">
    <span></span>
</div>
<slot name="wrapped-view"></slot>
`;


class WrappedView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template and shadowDom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onChildSlotted = this.onChildSlotted.bind(this);
        this.updateScaling = this.updateScaling.bind(this);
        this.handleNumberChange = this.handleNumberChange.bind(this);
        this.addWrappedView = this.addWrappedView.bind(this);
        this._recursivelyUpdateLensViews = this._recursivelyUpdateLensViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Bind a listener for the slot change.
            // This will be triggered whenever any
            // underlying element is slotted, so we
            // know to recompute the appropriate sizing
            // and styling
            let slotEl = this._shadowRoot.querySelector('slot');
            slotEl.addEventListener('slotchange', this.onChildSlotted);

            // we don't want the context menu to open in the nav since
            // it doens't make sense atm and will error
            this.removeEventListener('contextmenu', this.onContextMenuClick);
        }
    }

    disconnectedCallback(){
        let slotEl = this._shadowRoot.querySelector('slot');
        slotEl.removeEventListener('slotchange', this.onChildSlotted);
    }

    onChildSlotted(event){
        //this.updateScaling();
        //this.updateNumberDisplay();
    }

    afterModelSet(){
        this.onPropChange('number', this.handleNumberChange);
        this.removeAttribute('part-id');
        this.addWrappedView(this.model);
        this.updateNumberDisplay();
    }

    updateScaling(){
        let firstChild = this.children[0];
        // We need to find the element corresponding to the
        // actual view for the lens-ed part, in order to get
        // its current dimensions.
        let partId = firstChild.getAttribute('lens-part-id');
        let refElement = document.querySelector(`st-world`);
        let wrapBox = this.getBoundingClientRect();
        let innerBox = document.querySelector(`st-world`).getBoundingClientRect();
        let scalingX = (wrapBox.width / innerBox.width);
        let refElementBox = refElement.getBoundingClientRect();
        firstChild.style.width = `${refElementBox.width}px`;
        firstChild.style.height = `${refElementBox.height}px`;
        firstChild.style.transform = `scale(${scalingX})`;
        firstChild.style.transformOrigin = "0px 0px";
    }

    updateNumberDisplay(){
        let firstChild = this.children[0];
        let model = firstChild.model;
        // we only want to look at subparts of the same type (stack or card)
        let subparts = model._owner.subparts.filter((part) => {
            return model.type == part.type;
        });
        let numDisplay = this._shadowRoot.querySelector('#number-display > span');
        numDisplay.innerText = subparts.indexOf(model) + 1;
    }

    handleNumberChange(){
        // Update number display of all wrapped views in the row
        Array.from(this.parentNode.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

    addWrappedView(aPartModel){
        // First, clear out any existing
        // child elements
        this.innerHTML = "";

        // Create a lensed copy of the given
        // view and update key attributes on it
        let originalView = document.querySelector(`[part-id="${aPartModel.id}"]`);
        let lensedView = originalView.cloneNode(true);
        lensedView.setAttribute('lens-part-id', aPartModel.id);
        lensedView.setAttribute('slot', 'wrapped-view');
        lensedView.style.pointerEvents = "none";
        lensedView.wantsHalo = false;

        // Inline the initial scaling style properties.
        // We begin with an extremely small amount which will
        // be adjusted later during updateScaling();
        lensedView.style.transform = `scale(${0.001})`;
        lensedView.style.transformOrigin = "0px 0px";
        
        // Recursively create lens views of all subpart children
        // and append them in the correct places
        lensedView.isLensed = true;
        lensedView.setModel(aPartModel);
        lensedView.removeAttribute('part-id');
        if(lensedView.handleCurrentChange){
            lensedView.handleCurrentChange();
        }
        this._recursivelyUpdateLensViews(lensedView, aPartModel.id);

        // Insert the root lensed view into the wrapper
        this.setAttribute('wrapped-id', aPartModel.id);
        this.appendChild(lensedView);
        this.updateScaling();
    }

    _recursivelyUpdateLensViews(lensedView, anId){
        let subViews = Array.from(lensedView.children).filter(child => {
            return child.isPartView;
        });
        subViews.forEach(subView => {
            subView.isLensed = true;
            subView.wantsHalo = false;
            let subId = subView.getAttribute('part-id');
            subView.setAttribute('lens-part-id', subId);
            let model = window.System.partsById[subId];
            subView.setModel(model);
            subView.removeAttribute('part-id');
            this._recursivelyUpdateLensViews(subView, subId);
        });
    }

    /** PartView Overrides **/
    styleCSS(){
        // Do nothing
    }

    styleTextCSS(){
        // Do nothing
    }

    layoutChanged(){
        // Do nothing
    }
};




/***/ }),

/***/ "./js/ohm/interpreter-semantics.js":
/*!*****************************************!*\
  !*** ./js/ohm/interpreter-semantics.js ***!
  \*****************************************/
/*! exports provided: createInterpreterSemantics, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createInterpreterSemantics", function() { return createInterpreterSemantics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createInterpreterSemantics; });
/* harmony import */ var _objects_ExecutionStack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/ExecutionStack.js */ "./js/objects/ExecutionStack.js");


// Helpers
function findNearestParentOfKind(aPart, aPartType){
    let owner = aPart._owner;
    while(owner){
        if(owner.type == aPartType){
            return owner;
        }
        owner = owner._owner;
    }
    throw new Error(`'this' is a ${aPart.type}, not a ${aPartType} or does not have a parent of a ${aPartType}!`);
}

// check for possibleAncestor.acceptsSubpart(aPart.type)
// and if not go to owner and check again
function findFirstPossibleAncestor(aPart, aPartType){
    if(_subpartCheck(aPart, aPartType)){
        return aPart;
    } else {
        let owner = aPart._owner;
        while(owner){
            if(_subpartCheck(owner, aPartType)){
                return owner;
            }
            owner = owner._owner;
        }
    }
    throw new Error(`a ${aPart.type}, does not accept nor has any ancestors which accept part type ${aPartType}`);
}

function _subpartCheck(aPart, aPartType){
    if(aPartType == 'part'){
        return aPart.acceptedSubpartTypes.length > 0;
    }
    return aPart.acceptsSubpart(aPartType);
}

class STVariableReferenceError extends Error {
    constructor(...args){
        super(...args);
    }
};
Object.defineProperty(
    STVariableReferenceError.prototype,
    'name',
    {
        value: 'STVariableReferenceError'
    }
);

const createInterpreterSemantics = (partContext, systemContext) => {
    return {
        Script: function(scriptParts, _){
            return scriptParts.interpret();
        },
        MessageHandler: function(handlerOpen, lineTerm, optionalStatementList, handlerClose){
            let {messageName, parameters} = handlerOpen.interpret();
            let handlerFunction = function(senders, ...args){

                // In the grammar, the StatementList is
                // an optional rule, meaning the result of the rule
                // is an empty array (no statementlist) or a single
                // item array (the statementlist)
                if(optionalStatementList.children.length == 0){
                    return;
                }
                let statementList = optionalStatementList.children[0];

                // Next, we initialize a new ActivationContext
                // that will hold all variable information for
                // the execution of this handler.
                // We push it to the top of the current execution stack
                // and set the argument variables to locals
                args.forEach((argValue, index) => {
                    let argName = parameters[index];
                    systemContext.executionStack.current.setLocal(
                        argName,
                        argValue
                    );
                });

                // Because StatementList is both optional *and* made up
                // of iterable StatementLine rules (ie, 'StatementLine+' in grammar),
                // we need to "unwrap" these nodes without calling interpret() on them.
                // This ensures that expressions within the statements, like variable lookups,
                // are not called before any preceding statements have been interpreted and
                // the corresponding messages have already been sent. For example, statement 1 might
                // set a variable that statement 2 needs to lookup and use, so we want the lookup to
                // occur after statement 1 has been interpreted and the message for it has
                // been sent.
                statementList.children.forEach(statementLines => {
                    statementLines.children.forEach(statementLine => {
                        let message = statementLine.interpret();
                    });
                });
            };

            partContext._commandHandlers[messageName] = handlerFunction;
        },

        MessageHandlerOpen: function(literalOn, messageName, optionalParameterList){
            // Because the ParameterList here is optional, if
            // it is set it will be in the form of a size 1 array.
            // This single array item will itself be an array of the
            // parameter variable names.
            // Otherwise, an empty array indicates no params
            // are passed in for this handler
            let params = optionalParameterList.interpret();
            if(params.length > 0){
                params = params[0];
            }
            return {
                messageName: messageName.sourceString,
                parameters: params
            };
        },

        ParameterList: function(parameterString){
            return parameterString.asIteration().children.map(child => {
                return child.sourceString;
            });
        },


        InClause: function(inLiteral, objectSpecifier){
            return objectSpecifier.interpret();
        },

        Command_answer: function(answer, expression){
            let msg = {
                type: "command",
                commandName: "answer",
                args: [
                    expression.interpret()
                ]
            };
            return msg;
        },

        Command_goToDirection: function(goToLiteral, nextPrevious, systemObject){
            let args = [];
            args.push(nextPrevious.sourceString);
            if (systemObject.sourceString){
                args.push(systemObject.sourceString);
            }

            let msg = {
                type: "command",
                commandName: "go to direction",
                args: args
            };
            return msg;
        },

        Command_goToByObjectSpecifier: function(goToLiteral, objectSpecifier){
            let args = [
                objectSpecifier.interpret() // id of the object
            ];

            let msg = {
                type: "command",
                commandName: "go to",
                args: args
            };
            return msg;
        },

        Command_goToWebsite: function(goToLiteral, websiteLiteral, url){
            let args = [
                url.interpret()
            ];

            let msg = {
                type: "command",
                commandName: "go to website",
                args: args
            };
            return msg;
        },

        Command_addProperty: function(addLiteral, propertyLiteral, propNameAsLiteral, toLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "newProperty",
                args: args
            };
            return msg;
        },

        Command_addModel: function(addLiteral, newPartType, optionalPartName){
            // here no owner has been provided so we assume it is the first possible one
            let parent = findFirstPossibleAncestor(partContext, newPartType.sourceString);
            let args = [
                newPartType.sourceString,
                parent.id
            ];
            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_addModelTo: function(addLiteral, newPartType, optionalPartName, toLiteral, objectSpecifier){
            let args = [
                newPartType.sourceString, // The kind of part to add
                objectSpecifier.interpret() // id of the parent model part
            ];

            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_putVariable: function(putLiteral, value, intoLiteral, globalLiteral, destination){
            let global = false;
            if(globalLiteral.sourceString){
                global = true;
            };
            let args = [
                value.interpret(),
                destination.sourceString,
                global
            ];
            let msg = {
                type: "command",
                commandName: 'putInto',
                args
            };
            return msg;
        },

        Command_deleteProperty: function(deleteLiteral, propertyLiteral, propNameAsLiteral, fromLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "deleteProperty",
                args: args
            };
            return msg;
        },

        Command_deleteModel: function(deleteLiteral, objectSpecifier){
            let args = [
                objectSpecifier.interpret() // id of the object
            ];

            let msg = {
                type: "command",
                commandName: "deleteModel",
                args: args
            };
            return msg;
        },

        Command_setProperty: function(setLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setProperty",
                args: args
            };
            return msg;
        },

        Command_setSelection: function(setLiteral, selectionLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setSelection",
                args: args
            };
            return msg;
        },

        Command_ask: function(askLiteral, question){
            return {
                type: "command",
                commandName: "ask",
                args: [ question.interpret() ]
            };
        },

        Command_tellCommand: function(tellLiteral, objectSpecifier, toLiteral, command){
            return {
                type: 'command',
                commandName: 'tell',
                args: [
                    objectSpecifier.interpret(),
                    command.interpret()
                ]
            };
        },

        Command_arbitraryCommand: function(commandName, optionalArgumentList){
            // Because the argument list is optional here, it will
            // be either an empty array (no arguments) or a size 1
            // array (which itself will contain an array of the arguments)
            let optionalArguments = optionalArgumentList.interpret();
            if(optionalArguments.length > 0){
                optionalArguments = optionalArguments[0];
            }

            return {
                type: "command",
                commandName: commandName.sourceString,
                args: optionalArguments
            };
        },

        CommandArgumentList: function(list){
            return list.asIteration().interpret();
        },

        StatementLine: function(statement, newline){
            let message = statement.interpret();

            // Some statements, like if-then controls
            // and repeat controls, do not result in
            // messages but return null.
            // We ignore these.
            if(message && typeof(message) !== 'string'){
                let commandResult = partContext.sendMessage(message, partContext);
                systemContext.executionStack.current.setLocal('it', commandResult);
                return null;
            } else {
                return message;
            }
        },

        Statement: function(actualStatement, optionalComment){
            return actualStatement.interpret();
        },

        Expression_addExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first + second;
        },

        Expression_minusExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first - second;
        },

        Expression_divideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first / second;
        },

        Expression_moduloDivideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first % second;
        },

        Expression_timesExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first * second;
        },

        Expression_stringConcatExpr: function(firstExpression, operation, secondExpression){
            // When we encounter the "&" operator, we coerce both expressions into
            // a string
            let first = firstExpression.interpret().toString();
            let second = secondExpression.interpret().toString();
            return `${first}${second}`;
        },

        Factor_parenFactor: function(leftParen, expression, rightParen){
            return expression.interpret();
        },

        Factor_notFactor: function(notLiteral, expression){
            return !expression.interpret();
        },

        EqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first === second;
        },

        NonEqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first !== second;
        },

        Conditional_gtComparison: function(expr1, gtLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first > second;
        },

        Conditional_ltComparison: function(expr1, ltLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first < second;
        },

        Conditional_gteComparison: function(expr1, gteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first >= second;
        },

        Conditional_lteComparison: function(expr1, lteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first <= second;
        },

        ThereIsAnObjectConditional: function(thereLiteral, isLiteral, aOrAnLiteral, objectSpecifier){
            try{
                objectSpecifier.interpret();
                return true;
            } catch(e){
                return false;
            };
        },

        ThereIsNotAnObjectConditional: function(thereLiteral, isLiteral, notLiteral, aOrAnLiteral, inClause){
            try{
                objectSpecifier.interpret();
                return false;
            } catch(e){
                return true;
            };
        },

        ThereIsAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsNotAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        ThereIsNotAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        IfThenInline: function(ifLiteral, conditional, thenLiteral, statement, optionalComment){
            let shouldEvaluate = conditional.interpret();
            if(shouldEvaluate){
                return statement.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withoutElse: function(ifLine, lineTerm1, thenLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withElse: function(ifLine, lineTerm1, thenLine, lineTerm2, elseLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return elseLine.interpret();
            }
        },

        IfThenMultiline_withElse: function(ifLine, lineTerm, multiThen, multiElse, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            } else {
                return multiElse.interpret();
            }
        },

        IfThenMultiline_withoutElse: function(ifLine, lineTerm, multiThen, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            }
            return null;
        },

        IfLine: function(ifLiteral, conditional, optionalComment){
            return conditional.interpret();
        },

        ThenLine: function(thenLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ElseLine: function(elseLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ControlStatementLine: function(statementLine){
            return statementLine.interpret();
        },

        MultiThen: function(thenLiteral, optionalComment, lintTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        MultiElse: function(elseLiteral, optionalComment, lineTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        KindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return false;
        },

        NotKindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return true;
        },

        RepeatControlForm_forNumTimes: function(repeatLit, optionalForLit, intOrVar, timesLit){
            return {
                repeatType: 'forNumTimes',
                numTimes: intOrVar.interpret()
            };
        },

        RepeatControlForm_untilCondition: function(repeatLit, untilLit, conditional){
            return {
                repeatType: 'untilCondition',
                condition: conditional
            };
        },

        RepeatControlForm_whileCondition: function(repeatLit, whileLit, conditional){
            return {
                repeatType: 'whileCondition',
                condition: conditional
            };
        },

        RepeatControlForm_withStartFinish: function(repeatLit, withLit, varName, eqLit, firstVal, toLit, secondVal){
            return {
                repeatType: 'withStartFinish',
                varName: varName.sourceString,
                start: firstVal.interpret(),
                finish: secondVal.interpret()
            };
        },

        RepeatAdjust_exit: function(_){
            return 'exit repeat';
        },

        RepeatAdjust_next: function(_){
            return 'next repeat';
        },

        RepeatBlock: function(repeatControl, lineTerm, statementLineOrRepAdjustPlus, endLiteral){
            let repeatInfo = repeatControl.interpret();
            let statementLines = statementLineOrRepAdjustPlus.children;
            switch(repeatInfo.repeatType){
            case 'forNumTimes':
                for(let i = 1; i <= repeatInfo.numTimes; i++){
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == 'next repeat'){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the main for loop
                    }
                }
                break; // Break out of the switch
            case 'untilCondition':
                let untilTestCondition = repeatInfo.condition.interpret();
                while(!untilTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result){
                            if(result == 'exit repeat'){
                                shouldBreak = true;
                                break;
                            } else if(result == 'next repeat'){
                                break;
                            }
                        }
                    }
                    if(shouldBreak){
                        break; // break out of the outer while loop
                    }
                    untilTestCondition = repeatInfo.condition.interpret();
                }
                break; // Break out of the switch case
            case 'whileCondition':
                let whileTestCondition = repeatInfo.condition.interpret();
                while(whileTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldBreak){
                        break; // break out of outer while loop (end repeat)
                    }
                    whileTestCondition = repeatInfo.condition.interpret();
                }
                break; // break out of switch case
            case 'withStartFinish':
                // For now, we assume that start is less than
                // finish. We should probably throw an error if
                // otherwise
                if(repeatInfo.start > repeatInfo.finish){
                    throw new Error(`Repeat error: start greater than finish`);
                }

                for(let i = repeatInfo.start; i <= repeatInfo.finish; i++){
                    systemContext.executionStack.current.setLocal(repeatInfo.varName, i);
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == "exit repeat"){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the outer (repeat) loop
                    }
                }
            }
            return null;
        },

        PropertyValue_withSpecifier: function(theLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            return target.partProperties.getPropertyNamed(
                target,
                propName.interpret()
            );
        },

        PropertyValue_withoutSpecifier: function(theLiteral, propName){
            return partContext.partProperties.getPropertyNamed(
                partContext,
                propName.interpret()
            );
        },

        /** Object Specifiers **/


        /**
         * The partByTarget Partial Specifier
         * refers to partials that specify a part
         * specified in the "target" PartProperty
         * of the context part. The value of the
         * target property is any valid ObjectSpecifier
         * string.
         */
        PartialSpecifier_partByTarget(targetLiteral){
            return (context) => {
                let targetPropValue = context.partProperties.getPropertyNamed(context, "target");
                // use the partContext since the context object might not have any semantics set on it
                // For example, a context object/part which does not have a script which has been
                // compiled will not have had context._semantics set.
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return systemContext.partsById[targetId];
            };
        },

        /**
         * The currentCard Partial Specifier
         * refers to partials that specify the current card
         * depending on the stack context.
         */
        PartialSpecifier_currentCard: function(currentLiteral, cardLiteral){
            return function(contextPart){
                return contextPart.currentCard;
            };
        },

        /**
         * The partByIndex Partial Specifier
         * refers to partials that specify a part
         * type and an integer literal, for ex:
         *     field 3
         * The above example refers to the third
         * field part in its owner/parent part.
         */
        PartialSpecifier_partByIndex: function(objectType, integerLiteral){
            let index = integerLiteral.interpret();
            if(index < 1){
                throw new Error(`Part indices must be 1 or greater`);
            }
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    return contextPart.subparts[index-1];
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    return partsOfType[index-1];
                }
            };
        },

        /**
         * The partByNumericalIndex Partial Specifier
         * refers to partial that specify a part
         * type preceded by the English word for the
         * number. For the moment we accept first - tenth
         * Example:
         *     sixth button
         */
        PartialSpecifier_partByNumericalIndex: function(numericalKeyword, objectType){
            let index = numericalKeyword.interpret();
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return contextPart.subparts[contextPart.subparts.length - 1];
                    } else {
                        return contextPart.subparts[index-1];
                    }
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return partsOfType[partsOfType.length - 1];
                    } else {
                        return partsOfType[index-1];
                    }
                }
            };
        },

        /**
         * The partByName Partial Specifier
         * refers to a partial that specifies a part
         * by its name property. Example:
         *     card "My Custom Card"
         */
        PartialSpecifier_partByName: function(objectType, stringLiteral){
            let name = stringLiteral.interpret();
            if(objectType.sourceString == 'part'){
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return name == foundName;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part named "${name}"`);
                };
            } else {
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    }).filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return foundName == name;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} named "${name}"`);
                };
            }
        },

        /**
         * The 'this' specifier is a terminal (final)
         * specifier that refers to one of three things:
         * 1. the type of the current part executing the script,
         *    example: this button
         * 2. Card, which refers to the card that owns the
         *    part that is currently executing the script, ex:
         *    this card
         * 3. Stack, which refers to the stack that owns the
         *    part that is currently executing the script, ex:
         *    this stack
         */
        TerminalSpecifier_thisSystemObject: function(thisLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == partContext.type){
                    return partContext;
                } else {
                    return findNearestParentOfKind(partContext, targetType);
                }
            };
        },

        /**
         * The 'current' specifier is a terminal (final)
         * specifier that refers to either the current card or stack
         * being displayed to the user.
         * There are only two possible valid options:
         *     `current card`
         *     `current stack`
         */
        TerminalSpecifier_currentSystemObject: function(currentLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == 'stack'){
                    return systemContext.getCurrentStackModel();
                } else if(targetType == 'card'){
                    return systemContext.getCurrentCardModel();
                } else {
                    throw new Error(`${targetType} cannot be a 'current' system object`);
                }
            };
        },

        /**
         * The partById specifier is a terminal (final)
         * specifier that refers to a given part type
         * by its unique system id. For any kind of part,
         * we use `part id <objectId>`
         * Examples: `card id 266` `part id 5`
         */
        TerminalSpecifier_partById: function(objectType, idLiteral, objectId){
            let id = objectId.sourceString;
            let found = systemContext.partsById[id];
            if(!found){
                throw new Error(`Cannot find ${objectType.sourceString} with id ${objectId}`);
            }
            return function(context){
                return found;
            };
        },

        /**
         * A "prefixed" queried specifier is just
         * a PartialSpecifier with "of" in front of it, indicating
         * that a different partial will precede it be queried inside of it.
         * Example `of button "My Button"`
         */
        QueriedSpecifier_prefixed: function(partialSpecifier, ofLiteral){
            return partialSpecifier.interpret();
        },

        /**
         * A nested queried specifier is one that has two
         * or more prefixed specifiers. The simplest would be
         * something like:
         *     `of card "My Card" of stack "Another named stack"`
         */
        QueriedSpecifier_nested: function(firstQuery, secondQuery){
            return function(contextPart){
                let inner = secondQuery.interpret()(contextPart);
                let outer = firstQuery.interpret()(inner);
                return outer;
            };
        },

        /**
         * An ObjectSpecifier without an annotated
         * rule means it was interpreted as just
         * a TerminalSpecifier of some sort.
         * However, we need to extract the id
         * and return that result, since that is what is
         * expected of all interpreted ObjectSpecifiers
         */
        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let found = terminalSpecifier.interpret()();
            return found.id;
        },

        /**
         * A Compound with terminal specifier is a QueriedSpecifier
         * that finishes with a Terminal specifier.
         * Example: `of button 3 of card "Some named card" of current stack`
         */
        ObjectSpecifier_compoundQueryWithTerminal: function(queriedSpecifier, terminalSpecifier){
            // The terminal here is the ultimate part context
            let finalPart = terminalSpecifier.interpret()();
            let result = queriedSpecifier.interpret()(finalPart);
            return result.id;
        },

        /**
         * A Compound without terminal specifier is a QueriedSpecifier
         * that finishes with a Partial specifier.
         * Example: `of button 3 of first card` (which can continue `..of current stack` etc)
         * `first button of first area of stack 3`
         * `first button of area two of stack 3`
         */
        ObjectSpecifier_compoundQueryWithoutTerminal: function(queriedSpecifier, partialSpecifier){
            // if the partialSpecfier refers to either area, card or stack
            // then go to its owner for the context
            // if it refers to the current card then find the owner for the context
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                systemObjectString = "card";
            } else {
                children.forEach((child) => {
                    if(child.ctorName == "systemObject"){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let finalPartial = partialSpecifier.interpret()(finalPart);
            let result = queriedSpecifier.interpret()(finalPartial);
            return result.id;
        },

        /**
         * A single non-terminal ObjectSpecifier is just a Partial
         * specifier by itself. When present outside of a QueriedSpecifier,
         * it will be interpreted in the current context and treated
         * as terminal/final. For example:
         *     button 4
         * by itself as a whole specifier will be interpreted as
         * `button 4 of this card`
         */
        ObjectSpecifier_singleNonTerminal: function(partialSpecifier){
            // A single non-terminal object specifier is one
            // whose terminal object is implicitly assumed to
            // be the card or the stack in which the current context part
            // exists.
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                return systemContext.getCurrentCardModel().id;
            } else {
                children.forEach((child) => {
                    if(child.sourceString == "part" || child.sourceString == "target" || child.ctorName == 'systemObject'){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            // the systemObject is the target (defined in it's "target" part property), then we need to
            // first get the target property value (string) and interpret that
            if(systemObjectString == "target"){
                let targetPropValue = partContext.partProperties.getPropertyNamed(partContext, "target");
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return targetId;
            } else if(systemObjectString == "current card"){
                systemObjectString = "card";
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let result = partialSpecifier.interpret()(finalPart);
            return result.id;
        },

        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let result = terminalSpecifier.interpret()(partContext);
            return result.id;
        },

        anyLiteral: function(theLiteral){
            return theLiteral.interpret();
        },

        stringLiteral: function(openQuote, text, closeQuote){
            return text.sourceString;
        },

        booleanLiteral: function(text){
            if(text.sourceString == 'true'){
                return true;
            }
            if(text.sourceString == 'false'){
                return false;
            }
            throw new Error(`Invalid boolean literal: ${text}`);
        },

        integerLiteral: function(negativeSign, integer){
            let int = parseInt(integer.sourceString);
            let hasNegative = (negativeSign.sourceString == "-");
            if(hasNegative){
                return -1 * int;
            }
            return int; 
        },

        floatLiteral: function(negativeSign, onesPlace, decimal, restPlace){
            let floatString = `${onesPlace.sourceString}.${restPlace.sourceString}`;
            let hasNegative = (negativeSign.sourceString == "-");
            let result = parseFloat(floatString);
            if(hasNegative){
                return -1 * result;
            }
            return result;
        },

        numericalKeyword: function(numeralName){
            switch(numeralName.sourceString){
            case 'first':
                return 1;
            case 'second':
                return 2;
            case 'third':
                return 3;
            case 'fourth':
                return 4;
            case 'fifth':
                return 5;
            case 'sixth':
                return 6;
            case 'seventh':
                return 7;
            case 'eighth':
                return 8;
            case 'ninth':
                return 9;
            case 'tenth':
                return 10;
            }

            return -1;
        },

        variableName: function(letterPlus, optionalDigits){
            // Lookup the variable in the part's
            // current execution context
            // If the variable is not a key on the object,
            // we throw an error: this means the variable has not yet
            // been defined but is being looked up.
            let value = systemContext.executionStack.current.get(this.sourceString);
            if(value == undefined){
                throw new STVariableReferenceError(
                    `Variable ${this.sourceString} has not been defined`);
            }
            return value;
        },

        comment: function(dashesLiteral, nonLineTerminatorChars){
            // Interpret doesn't do anything
            // with comments.
            return null;
        },

        _terminal(){

        }
    };
};





/***/ }),

/***/ "./node_modules/ohm-js/dist/built-in-rules.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/dist/built-in-rules.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = \"0\"..\"9\"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | \"a\"..\"f\"\n    | \"A\"..\"F\"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n}"},"BuiltInRules",null,null,{"alnum":["define",{"sourceInterval":[18,78]},"an alpha-numeric character",[],["alt",{"sourceInterval":[60,78]},["app",{"sourceInterval":[60,66]},"letter",[]],["app",{"sourceInterval":[73,78]},"digit",[]]]],"letter":["define",{"sourceInterval":[82,142]},"a letter",[],["alt",{"sourceInterval":[107,142]},["app",{"sourceInterval":[107,112]},"lower",[]],["app",{"sourceInterval":[119,124]},"upper",[]],["app",{"sourceInterval":[131,142]},"unicodeLtmo",[]]]],"digit":["define",{"sourceInterval":[146,177]},"a digit",[],["range",{"sourceInterval":[169,177]},"0","9"]],"hexDigit":["define",{"sourceInterval":[181,254]},"a hexadecimal digit",[],["alt",{"sourceInterval":[219,254]},["app",{"sourceInterval":[219,224]},"digit",[]],["range",{"sourceInterval":[231,239]},"a","f"],["range",{"sourceInterval":[246,254]},"A","F"]]],"ListOf":["define",{"sourceInterval":[258,336]},null,["elem","sep"],["alt",{"sourceInterval":[282,336]},["app",{"sourceInterval":[282,307]},"NonemptyListOf",[["param",{"sourceInterval":[297,301]},0],["param",{"sourceInterval":[303,306]},1]]],["app",{"sourceInterval":[314,336]},"EmptyListOf",[["param",{"sourceInterval":[326,330]},0],["param",{"sourceInterval":[332,335]},1]]]]],"NonemptyListOf":["define",{"sourceInterval":[340,388]},null,["elem","sep"],["seq",{"sourceInterval":[372,388]},["param",{"sourceInterval":[372,376]},0],["star",{"sourceInterval":[377,388]},["seq",{"sourceInterval":[378,386]},["param",{"sourceInterval":[378,381]},1],["param",{"sourceInterval":[382,386]},0]]]]],"EmptyListOf":["define",{"sourceInterval":[392,434]},null,["elem","sep"],["seq",{"sourceInterval":[438,438]}]],"listOf":["define",{"sourceInterval":[438,516]},null,["elem","sep"],["alt",{"sourceInterval":[462,516]},["app",{"sourceInterval":[462,487]},"nonemptyListOf",[["param",{"sourceInterval":[477,481]},0],["param",{"sourceInterval":[483,486]},1]]],["app",{"sourceInterval":[494,516]},"emptyListOf",[["param",{"sourceInterval":[506,510]},0],["param",{"sourceInterval":[512,515]},1]]]]],"nonemptyListOf":["define",{"sourceInterval":[520,568]},null,["elem","sep"],["seq",{"sourceInterval":[552,568]},["param",{"sourceInterval":[552,556]},0],["star",{"sourceInterval":[557,568]},["seq",{"sourceInterval":[558,566]},["param",{"sourceInterval":[558,561]},1],["param",{"sourceInterval":[562,566]},0]]]]],"emptyListOf":["define",{"sourceInterval":[572,614]},null,["elem","sep"],["seq",{"sourceInterval":[616,616]}]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/ohm-grammar.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/dist/ohm-grammar.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"Ohm {\n\n  Grammars\n    = Grammar*\n\n  Grammar\n    = ident SuperGrammar? \"{\" Rule* \"}\"\n\n  SuperGrammar\n    = \"<:\" ident\n\n  Rule\n    = ident Formals? ruleDescr? \"=\"  RuleBody  -- define\n    | ident Formals?            \":=\" OverrideRuleBody  -- override\n    | ident Formals?            \"+=\" RuleBody  -- extend\n\n  RuleBody\n    = \"|\"? NonemptyListOf<TopLevelTerm, \"|\">\n\n  TopLevelTerm\n    = Seq caseName  -- inline\n    | Seq\n\n  OverrideRuleBody\n    = \"|\"? NonemptyListOf<OverrideTopLevelTerm, \"|\">\n\n  OverrideTopLevelTerm\n    = \"...\"  -- superSplice\n    | TopLevelTerm\n\n  Formals\n    = \"<\" ListOf<ident, \",\"> \">\"\n\n  Params\n    = \"<\" ListOf<Seq, \",\"> \">\"\n\n  Alt\n    = NonemptyListOf<Seq, \"|\">\n\n  Seq\n    = Iter*\n\n  Iter\n    = Pred \"*\"  -- star\n    | Pred \"+\"  -- plus\n    | Pred \"?\"  -- opt\n    | Pred\n\n  Pred\n    = \"~\" Lex  -- not\n    | \"&\" Lex  -- lookahead\n    | Lex\n\n  Lex\n    = \"#\" Base  -- lex\n    | Base\n\n  Base\n    = ident Params? ~(ruleDescr? \"=\" | \":=\" | \"+=\")  -- application\n    | oneCharTerminal \"..\" oneCharTerminal           -- range\n    | terminal                                       -- terminal\n    | \"(\" Alt \")\"                                    -- paren\n\n  ruleDescr  (a rule description)\n    = \"(\" ruleDescrText \")\"\n\n  ruleDescrText\n    = (~\")\" any)*\n\n  caseName\n    = \"--\" (~\"\\n\" space)* name (~\"\\n\" space)* (\"\\n\" | &\"}\")\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n  ident  (an identifier)\n    = name\n\n  terminal\n    = \"\\\"\" terminalChar* \"\\\"\"\n\n  oneCharTerminal\n    = \"\\\"\" terminalChar \"\\\"\"\n\n  terminalChar\n    = escapeChar\n    | ~\"\\\\\" ~\"\\\"\" ~\"\\n\" any\n\n  escapeChar  (an escape sequence)\n    = \"\\\\\\\\\"                                     -- backslash\n    | \"\\\\\\\"\"                                     -- doubleQuote\n    | \"\\\\\\'\"                                     -- singleQuote\n    | \"\\\\b\"                                      -- backspace\n    | \"\\\\n\"                                      -- lineFeed\n    | \"\\\\r\"                                      -- carriageReturn\n    | \"\\\\t\"                                      -- tab\n    | \"\\\\u\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\n    | \"\\\\x\" hexDigit hexDigit                    -- hexEscape\n\n  space\n   += comment\n\n  comment\n    = \"//\" (~\"\\n\" any)* &(\"\\n\" | end)  -- singleLine\n    | \"/*\" (~\"*/\" any)* \"*/\"  -- multiLine\n\n  tokens = token*\n\n  token = caseName | comment | ident | operator | punctuation | terminal | any\n\n  operator = \"<:\" | \"=\" | \":=\" | \"+=\" | \"*\" | \"+\" | \"?\" | \"~\" | \"&\"\n\n  punctuation = \"<\" | \">\" | \",\" | \"--\"\n}"},"Ohm",null,"Grammars",{"Grammars":["define",{"sourceInterval":[9,32]},null,[],["star",{"sourceInterval":[24,32]},["app",{"sourceInterval":[24,31]},"Grammar",[]]]],"Grammar":["define",{"sourceInterval":[36,83]},null,[],["seq",{"sourceInterval":[50,83]},["app",{"sourceInterval":[50,55]},"ident",[]],["opt",{"sourceInterval":[56,69]},["app",{"sourceInterval":[56,68]},"SuperGrammar",[]]],["terminal",{"sourceInterval":[70,73]},"{"],["star",{"sourceInterval":[74,79]},["app",{"sourceInterval":[74,78]},"Rule",[]]],["terminal",{"sourceInterval":[80,83]},"}"]]],"SuperGrammar":["define",{"sourceInterval":[87,116]},null,[],["seq",{"sourceInterval":[106,116]},["terminal",{"sourceInterval":[106,110]},"<:"],["app",{"sourceInterval":[111,116]},"ident",[]]]],"Rule_define":["define",{"sourceInterval":[131,181]},null,[],["seq",{"sourceInterval":[131,170]},["app",{"sourceInterval":[131,136]},"ident",[]],["opt",{"sourceInterval":[137,145]},["app",{"sourceInterval":[137,144]},"Formals",[]]],["opt",{"sourceInterval":[146,156]},["app",{"sourceInterval":[146,155]},"ruleDescr",[]]],["terminal",{"sourceInterval":[157,160]},"="],["app",{"sourceInterval":[162,170]},"RuleBody",[]]]],"Rule_override":["define",{"sourceInterval":[188,248]},null,[],["seq",{"sourceInterval":[188,235]},["app",{"sourceInterval":[188,193]},"ident",[]],["opt",{"sourceInterval":[194,202]},["app",{"sourceInterval":[194,201]},"Formals",[]]],["terminal",{"sourceInterval":[214,218]},":="],["app",{"sourceInterval":[219,235]},"OverrideRuleBody",[]]]],"Rule_extend":["define",{"sourceInterval":[255,305]},null,[],["seq",{"sourceInterval":[255,294]},["app",{"sourceInterval":[255,260]},"ident",[]],["opt",{"sourceInterval":[261,269]},["app",{"sourceInterval":[261,268]},"Formals",[]]],["terminal",{"sourceInterval":[281,285]},"+="],["app",{"sourceInterval":[286,294]},"RuleBody",[]]]],"Rule":["define",{"sourceInterval":[120,305]},null,[],["alt",{"sourceInterval":[131,305]},["app",{"sourceInterval":[131,170]},"Rule_define",[]],["app",{"sourceInterval":[188,235]},"Rule_override",[]],["app",{"sourceInterval":[255,294]},"Rule_extend",[]]]],"RuleBody":["define",{"sourceInterval":[309,362]},null,[],["seq",{"sourceInterval":[324,362]},["opt",{"sourceInterval":[324,328]},["terminal",{"sourceInterval":[324,327]},"|"]],["app",{"sourceInterval":[329,362]},"NonemptyListOf",[["app",{"sourceInterval":[344,356]},"TopLevelTerm",[]],["terminal",{"sourceInterval":[358,361]},"|"]]]]],"TopLevelTerm_inline":["define",{"sourceInterval":[385,408]},null,[],["seq",{"sourceInterval":[385,397]},["app",{"sourceInterval":[385,388]},"Seq",[]],["app",{"sourceInterval":[389,397]},"caseName",[]]]],"TopLevelTerm":["define",{"sourceInterval":[366,418]},null,[],["alt",{"sourceInterval":[385,418]},["app",{"sourceInterval":[385,397]},"TopLevelTerm_inline",[]],["app",{"sourceInterval":[415,418]},"Seq",[]]]],"OverrideRuleBody":["define",{"sourceInterval":[422,491]},null,[],["seq",{"sourceInterval":[445,491]},["opt",{"sourceInterval":[445,449]},["terminal",{"sourceInterval":[445,448]},"|"]],["app",{"sourceInterval":[450,491]},"NonemptyListOf",[["app",{"sourceInterval":[465,485]},"OverrideTopLevelTerm",[]],["terminal",{"sourceInterval":[487,490]},"|"]]]]],"OverrideTopLevelTerm_superSplice":["define",{"sourceInterval":[522,543]},null,[],["terminal",{"sourceInterval":[522,527]},"..."]],"OverrideTopLevelTerm":["define",{"sourceInterval":[495,562]},null,[],["alt",{"sourceInterval":[522,562]},["app",{"sourceInterval":[522,527]},"OverrideTopLevelTerm_superSplice",[]],["app",{"sourceInterval":[550,562]},"TopLevelTerm",[]]]],"Formals":["define",{"sourceInterval":[566,606]},null,[],["seq",{"sourceInterval":[580,606]},["terminal",{"sourceInterval":[580,583]},"<"],["app",{"sourceInterval":[584,602]},"ListOf",[["app",{"sourceInterval":[591,596]},"ident",[]],["terminal",{"sourceInterval":[598,601]},","]]],["terminal",{"sourceInterval":[603,606]},">"]]],"Params":["define",{"sourceInterval":[610,647]},null,[],["seq",{"sourceInterval":[623,647]},["terminal",{"sourceInterval":[623,626]},"<"],["app",{"sourceInterval":[627,643]},"ListOf",[["app",{"sourceInterval":[634,637]},"Seq",[]],["terminal",{"sourceInterval":[639,642]},","]]],["terminal",{"sourceInterval":[644,647]},">"]]],"Alt":["define",{"sourceInterval":[651,685]},null,[],["app",{"sourceInterval":[661,685]},"NonemptyListOf",[["app",{"sourceInterval":[676,679]},"Seq",[]],["terminal",{"sourceInterval":[681,684]},"|"]]]],"Seq":["define",{"sourceInterval":[689,704]},null,[],["star",{"sourceInterval":[699,704]},["app",{"sourceInterval":[699,703]},"Iter",[]]]],"Iter_star":["define",{"sourceInterval":[719,736]},null,[],["seq",{"sourceInterval":[719,727]},["app",{"sourceInterval":[719,723]},"Pred",[]],["terminal",{"sourceInterval":[724,727]},"*"]]],"Iter_plus":["define",{"sourceInterval":[743,760]},null,[],["seq",{"sourceInterval":[743,751]},["app",{"sourceInterval":[743,747]},"Pred",[]],["terminal",{"sourceInterval":[748,751]},"+"]]],"Iter_opt":["define",{"sourceInterval":[767,783]},null,[],["seq",{"sourceInterval":[767,775]},["app",{"sourceInterval":[767,771]},"Pred",[]],["terminal",{"sourceInterval":[772,775]},"?"]]],"Iter":["define",{"sourceInterval":[708,794]},null,[],["alt",{"sourceInterval":[719,794]},["app",{"sourceInterval":[719,727]},"Iter_star",[]],["app",{"sourceInterval":[743,751]},"Iter_plus",[]],["app",{"sourceInterval":[767,775]},"Iter_opt",[]],["app",{"sourceInterval":[790,794]},"Pred",[]]]],"Pred_not":["define",{"sourceInterval":[809,824]},null,[],["seq",{"sourceInterval":[809,816]},["terminal",{"sourceInterval":[809,812]},"~"],["app",{"sourceInterval":[813,816]},"Lex",[]]]],"Pred_lookahead":["define",{"sourceInterval":[831,852]},null,[],["seq",{"sourceInterval":[831,838]},["terminal",{"sourceInterval":[831,834]},"&"],["app",{"sourceInterval":[835,838]},"Lex",[]]]],"Pred":["define",{"sourceInterval":[798,862]},null,[],["alt",{"sourceInterval":[809,862]},["app",{"sourceInterval":[809,816]},"Pred_not",[]],["app",{"sourceInterval":[831,838]},"Pred_lookahead",[]],["app",{"sourceInterval":[859,862]},"Lex",[]]]],"Lex_lex":["define",{"sourceInterval":[876,892]},null,[],["seq",{"sourceInterval":[876,884]},["terminal",{"sourceInterval":[876,879]},"#"],["app",{"sourceInterval":[880,884]},"Base",[]]]],"Lex":["define",{"sourceInterval":[866,903]},null,[],["alt",{"sourceInterval":[876,903]},["app",{"sourceInterval":[876,884]},"Lex_lex",[]],["app",{"sourceInterval":[899,903]},"Base",[]]]],"Base_application":["define",{"sourceInterval":[918,979]},null,[],["seq",{"sourceInterval":[918,963]},["app",{"sourceInterval":[918,923]},"ident",[]],["opt",{"sourceInterval":[924,931]},["app",{"sourceInterval":[924,930]},"Params",[]]],["not",{"sourceInterval":[932,963]},["alt",{"sourceInterval":[934,962]},["seq",{"sourceInterval":[934,948]},["opt",{"sourceInterval":[934,944]},["app",{"sourceInterval":[934,943]},"ruleDescr",[]]],["terminal",{"sourceInterval":[945,948]},"="]],["terminal",{"sourceInterval":[951,955]},":="],["terminal",{"sourceInterval":[958,962]},"+="]]]]],"Base_range":["define",{"sourceInterval":[986,1041]},null,[],["seq",{"sourceInterval":[986,1022]},["app",{"sourceInterval":[986,1001]},"oneCharTerminal",[]],["terminal",{"sourceInterval":[1002,1006]},".."],["app",{"sourceInterval":[1007,1022]},"oneCharTerminal",[]]]],"Base_terminal":["define",{"sourceInterval":[1048,1106]},null,[],["app",{"sourceInterval":[1048,1056]},"terminal",[]]],"Base_paren":["define",{"sourceInterval":[1113,1168]},null,[],["seq",{"sourceInterval":[1113,1124]},["terminal",{"sourceInterval":[1113,1116]},"("],["app",{"sourceInterval":[1117,1120]},"Alt",[]],["terminal",{"sourceInterval":[1121,1124]},")"]]],"Base":["define",{"sourceInterval":[907,1168]},null,[],["alt",{"sourceInterval":[918,1168]},["app",{"sourceInterval":[918,963]},"Base_application",[]],["app",{"sourceInterval":[986,1022]},"Base_range",[]],["app",{"sourceInterval":[1048,1056]},"Base_terminal",[]],["app",{"sourceInterval":[1113,1124]},"Base_paren",[]]]],"ruleDescr":["define",{"sourceInterval":[1172,1231]},"a rule description",[],["seq",{"sourceInterval":[1210,1231]},["terminal",{"sourceInterval":[1210,1213]},"("],["app",{"sourceInterval":[1214,1227]},"ruleDescrText",[]],["terminal",{"sourceInterval":[1228,1231]},")"]]],"ruleDescrText":["define",{"sourceInterval":[1235,1266]},null,[],["star",{"sourceInterval":[1255,1266]},["seq",{"sourceInterval":[1256,1264]},["not",{"sourceInterval":[1256,1260]},["terminal",{"sourceInterval":[1257,1260]},")"]],["app",{"sourceInterval":[1261,1264]},"any",[]]]]],"caseName":["define",{"sourceInterval":[1270,1338]},null,[],["seq",{"sourceInterval":[1285,1338]},["terminal",{"sourceInterval":[1285,1289]},"--"],["star",{"sourceInterval":[1290,1304]},["seq",{"sourceInterval":[1291,1302]},["not",{"sourceInterval":[1291,1296]},["terminal",{"sourceInterval":[1292,1296]},"\n"]],["app",{"sourceInterval":[1297,1302]},"space",[]]]],["app",{"sourceInterval":[1305,1309]},"name",[]],["star",{"sourceInterval":[1310,1324]},["seq",{"sourceInterval":[1311,1322]},["not",{"sourceInterval":[1311,1316]},["terminal",{"sourceInterval":[1312,1316]},"\n"]],["app",{"sourceInterval":[1317,1322]},"space",[]]]],["alt",{"sourceInterval":[1326,1337]},["terminal",{"sourceInterval":[1326,1330]},"\n"],["lookahead",{"sourceInterval":[1333,1337]},["terminal",{"sourceInterval":[1334,1337]},"}"]]]]],"name":["define",{"sourceInterval":[1342,1382]},"a name",[],["seq",{"sourceInterval":[1363,1382]},["app",{"sourceInterval":[1363,1372]},"nameFirst",[]],["star",{"sourceInterval":[1373,1382]},["app",{"sourceInterval":[1373,1381]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[1386,1418]},null,[],["alt",{"sourceInterval":[1402,1418]},["terminal",{"sourceInterval":[1402,1405]},"_"],["app",{"sourceInterval":[1412,1418]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[1422,1452]},null,[],["alt",{"sourceInterval":[1437,1452]},["terminal",{"sourceInterval":[1437,1440]},"_"],["app",{"sourceInterval":[1447,1452]},"alnum",[]]]],"ident":["define",{"sourceInterval":[1456,1489]},"an identifier",[],["app",{"sourceInterval":[1485,1489]},"name",[]]],"terminal":["define",{"sourceInterval":[1493,1531]},null,[],["seq",{"sourceInterval":[1508,1531]},["terminal",{"sourceInterval":[1508,1512]},"\""],["star",{"sourceInterval":[1513,1526]},["app",{"sourceInterval":[1513,1525]},"terminalChar",[]]],["terminal",{"sourceInterval":[1527,1531]},"\""]]],"oneCharTerminal":["define",{"sourceInterval":[1535,1579]},null,[],["seq",{"sourceInterval":[1557,1579]},["terminal",{"sourceInterval":[1557,1561]},"\""],["app",{"sourceInterval":[1562,1574]},"terminalChar",[]],["terminal",{"sourceInterval":[1575,1579]},"\""]]],"terminalChar":["define",{"sourceInterval":[1583,1640]},null,[],["alt",{"sourceInterval":[1602,1640]},["app",{"sourceInterval":[1602,1612]},"escapeChar",[]],["seq",{"sourceInterval":[1619,1640]},["not",{"sourceInterval":[1619,1624]},["terminal",{"sourceInterval":[1620,1624]},"\\"]],["not",{"sourceInterval":[1625,1630]},["terminal",{"sourceInterval":[1626,1630]},"\""]],["not",{"sourceInterval":[1631,1636]},["terminal",{"sourceInterval":[1632,1636]},"\n"]],["app",{"sourceInterval":[1637,1640]},"any",[]]]]],"escapeChar_backslash":["define",{"sourceInterval":[1683,1738]},null,[],["terminal",{"sourceInterval":[1683,1689]},"\\\\"]],"escapeChar_doubleQuote":["define",{"sourceInterval":[1745,1802]},null,[],["terminal",{"sourceInterval":[1745,1751]},"\\\""]],"escapeChar_singleQuote":["define",{"sourceInterval":[1809,1866]},null,[],["terminal",{"sourceInterval":[1809,1815]},"\\'"]],"escapeChar_backspace":["define",{"sourceInterval":[1873,1928]},null,[],["terminal",{"sourceInterval":[1873,1878]},"\\b"]],"escapeChar_lineFeed":["define",{"sourceInterval":[1935,1989]},null,[],["terminal",{"sourceInterval":[1935,1940]},"\\n"]],"escapeChar_carriageReturn":["define",{"sourceInterval":[1996,2056]},null,[],["terminal",{"sourceInterval":[1996,2001]},"\\r"]],"escapeChar_tab":["define",{"sourceInterval":[2063,2112]},null,[],["terminal",{"sourceInterval":[2063,2068]},"\\t"]],"escapeChar_unicodeEscape":["define",{"sourceInterval":[2119,2178]},null,[],["seq",{"sourceInterval":[2119,2160]},["terminal",{"sourceInterval":[2119,2124]},"\\u"],["app",{"sourceInterval":[2125,2133]},"hexDigit",[]],["app",{"sourceInterval":[2134,2142]},"hexDigit",[]],["app",{"sourceInterval":[2143,2151]},"hexDigit",[]],["app",{"sourceInterval":[2152,2160]},"hexDigit",[]]]],"escapeChar_hexEscape":["define",{"sourceInterval":[2185,2240]},null,[],["seq",{"sourceInterval":[2185,2208]},["terminal",{"sourceInterval":[2185,2190]},"\\x"],["app",{"sourceInterval":[2191,2199]},"hexDigit",[]],["app",{"sourceInterval":[2200,2208]},"hexDigit",[]]]],"escapeChar":["define",{"sourceInterval":[1644,2240]},"an escape sequence",[],["alt",{"sourceInterval":[1683,2240]},["app",{"sourceInterval":[1683,1689]},"escapeChar_backslash",[]],["app",{"sourceInterval":[1745,1751]},"escapeChar_doubleQuote",[]],["app",{"sourceInterval":[1809,1815]},"escapeChar_singleQuote",[]],["app",{"sourceInterval":[1873,1878]},"escapeChar_backspace",[]],["app",{"sourceInterval":[1935,1940]},"escapeChar_lineFeed",[]],["app",{"sourceInterval":[1996,2001]},"escapeChar_carriageReturn",[]],["app",{"sourceInterval":[2063,2068]},"escapeChar_tab",[]],["app",{"sourceInterval":[2119,2160]},"escapeChar_unicodeEscape",[]],["app",{"sourceInterval":[2185,2208]},"escapeChar_hexEscape",[]]]],"space":["extend",{"sourceInterval":[2244,2263]},null,[],["app",{"sourceInterval":[2256,2263]},"comment",[]]],"comment_singleLine":["define",{"sourceInterval":[2281,2327]},null,[],["seq",{"sourceInterval":[2281,2312]},["terminal",{"sourceInterval":[2281,2285]},"//"],["star",{"sourceInterval":[2286,2298]},["seq",{"sourceInterval":[2287,2296]},["not",{"sourceInterval":[2287,2292]},["terminal",{"sourceInterval":[2288,2292]},"\n"]],["app",{"sourceInterval":[2293,2296]},"any",[]]]],["lookahead",{"sourceInterval":[2299,2312]},["alt",{"sourceInterval":[2301,2311]},["terminal",{"sourceInterval":[2301,2305]},"\n"],["app",{"sourceInterval":[2308,2311]},"end",[]]]]]],"comment_multiLine":["define",{"sourceInterval":[2334,2370]},null,[],["seq",{"sourceInterval":[2334,2356]},["terminal",{"sourceInterval":[2334,2338]},"/*"],["star",{"sourceInterval":[2339,2351]},["seq",{"sourceInterval":[2340,2349]},["not",{"sourceInterval":[2340,2345]},["terminal",{"sourceInterval":[2341,2345]},"*/"]],["app",{"sourceInterval":[2346,2349]},"any",[]]]],["terminal",{"sourceInterval":[2352,2356]},"*/"]]],"comment":["define",{"sourceInterval":[2267,2370]},null,[],["alt",{"sourceInterval":[2281,2370]},["app",{"sourceInterval":[2281,2312]},"comment_singleLine",[]],["app",{"sourceInterval":[2334,2356]},"comment_multiLine",[]]]],"tokens":["define",{"sourceInterval":[2374,2389]},null,[],["star",{"sourceInterval":[2383,2389]},["app",{"sourceInterval":[2383,2388]},"token",[]]]],"token":["define",{"sourceInterval":[2393,2469]},null,[],["alt",{"sourceInterval":[2401,2469]},["app",{"sourceInterval":[2401,2409]},"caseName",[]],["app",{"sourceInterval":[2412,2419]},"comment",[]],["app",{"sourceInterval":[2422,2427]},"ident",[]],["app",{"sourceInterval":[2430,2438]},"operator",[]],["app",{"sourceInterval":[2441,2452]},"punctuation",[]],["app",{"sourceInterval":[2455,2463]},"terminal",[]],["app",{"sourceInterval":[2466,2469]},"any",[]]]],"operator":["define",{"sourceInterval":[2473,2538]},null,[],["alt",{"sourceInterval":[2484,2538]},["terminal",{"sourceInterval":[2484,2488]},"<:"],["terminal",{"sourceInterval":[2491,2494]},"="],["terminal",{"sourceInterval":[2497,2501]},":="],["terminal",{"sourceInterval":[2504,2508]},"+="],["terminal",{"sourceInterval":[2511,2514]},"*"],["terminal",{"sourceInterval":[2517,2520]},"+"],["terminal",{"sourceInterval":[2523,2526]},"?"],["terminal",{"sourceInterval":[2529,2532]},"~"],["terminal",{"sourceInterval":[2535,2538]},"&"]]],"punctuation":["define",{"sourceInterval":[2542,2578]},null,[],["alt",{"sourceInterval":[2556,2578]},["terminal",{"sourceInterval":[2556,2559]},"<"],["terminal",{"sourceInterval":[2562,2565]},">"],["terminal",{"sourceInterval":[2568,2571]},","],["terminal",{"sourceInterval":[2574,2578]},"--"]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/operations-and-attributes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ohm-js/dist/operations-and-attributes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = \"(\" ListOf<name, \",\"> \")\"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n}"},"OperationsAndAttributes",null,"AttributeSignature",{"AttributeSignature":["define",{"sourceInterval":[29,58]},null,[],["app",{"sourceInterval":[54,58]},"name",[]]],"OperationSignature":["define",{"sourceInterval":[62,100]},null,[],["seq",{"sourceInterval":[87,100]},["app",{"sourceInterval":[87,91]},"name",[]],["opt",{"sourceInterval":[92,100]},["app",{"sourceInterval":[92,99]},"Formals",[]]]]],"Formals":["define",{"sourceInterval":[104,143]},null,[],["seq",{"sourceInterval":[118,143]},["terminal",{"sourceInterval":[118,121]},"("],["app",{"sourceInterval":[122,139]},"ListOf",[["app",{"sourceInterval":[129,133]},"name",[]],["terminal",{"sourceInterval":[135,138]},","]]],["terminal",{"sourceInterval":[140,143]},")"]]],"name":["define",{"sourceInterval":[147,187]},"a name",[],["seq",{"sourceInterval":[168,187]},["app",{"sourceInterval":[168,177]},"nameFirst",[]],["star",{"sourceInterval":[178,187]},["app",{"sourceInterval":[178,186]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[191,223]},null,[],["alt",{"sourceInterval":[207,223]},["terminal",{"sourceInterval":[207,210]},"_"],["app",{"sourceInterval":[217,223]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[227,257]},null,[],["alt",{"sourceInterval":[242,257]},["terminal",{"sourceInterval":[242,245]},"_"],["app",{"sourceInterval":[252,257]},"alnum",[]]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/extras/VisitorFamily.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/extras/VisitorFamily.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ../src/common */ "./node_modules/ohm-js/src/common.js").assert;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Helpers

function getProp(name, thing, fn) {
  return fn(thing[name]);
}

function mapProp(name, thing, fn) {
  return thing[name].map(fn);
}

// Returns a function that will walk a single property of a node.
// `descriptor` is a string indicating the property name, optionally ending
// with '[]' (e.g., 'children[]').
function getPropWalkFn(descriptor) {
  const parts = descriptor.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor);
}

function getProps(walkFns, thing, fn) {
  return walkFns.map(walkFn => walkFn(thing, fn));
}

function getWalkFn(shape) {
  if (typeof shape === 'string') {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === 'function', 'Expected a string, Array, or function');
    assert(shape.length === 2, 'Expected a function of arity 2, got ' + shape.length);
    return shape;
  }
}

function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}

function trim(s) {
  return s.trim();
}

function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === '') {
    const name = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(',').map(trim);
    }
    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {
      return {name, formals: params};
    }
  }
  throw new Error('Invalid operation signature: ' + sig);
}

/*
  A VisitorFamily contains a set of recursive operations that are defined over some kind of
  tree structure. The `config` parameter specifies how to walk the tree:
  - 'getTag' is function which, given a node in the tree, returns the node's 'tag' (type)
  - 'shapes' an object that maps from a tag to a value that describes how to recursively
    evaluate the operation for nodes of that type. The value can be:
    * a string indicating the property name that holds that node's only child
    * an Array of property names (or an empty array indicating a leaf type), or
    * a function taking two arguments (node, fn), and returning an Array which is the result
      of apply `fn` to each of the node's children.
 */
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;

  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error('heeey!');
  };
  this.operations = {};

  this._arities = Object.create(null);
  this._getChildren = Object.create(null);

  const self = this;
  Object.keys(this._shapes).forEach(k => {
    const shape = self._shapes[k];
    self._getChildren[k] = getWalkFn(shape);

    // A function means the arity isn't fixed, so don't put an entry in the arity map.
    if (typeof shape !== 'function') {
      self._arities[k] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = function(thing) { return new self.Adapter(thing, self); };
}

VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};

VisitorFamily.prototype._checkActionDict = function(dict) {
  const self = this;
  Object.keys(dict).forEach(k => {
    assert(k in self._getChildren, "Unrecognized action name '" + k + "'");
    const action = dict[k];
    assert(typeof action === 'function', "Key '" + k + "': expected function, got " + action);
    if (k in self._arities) {
      const expected = self._arities[k];
      const actual = dict[k].length;
      assert(actual === expected,
          "Action '" + k + "' has the wrong arity: expected " + expected + ', got ' + actual);
    }
  });
};

VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const name = sig.name;
  this._checkActionDict(actions);
  this.operations[name] = {
    name,
    formals: sig.formals,
    actions
  };

  const family = this;
  this.Adapter.prototype[name] = function() {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name + "'");

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let i = 0; i < arguments.length; i++) {
      args[sig.formals[i]] = arguments[i];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = actions[tag].apply(this, family._getChildren[tag](this._adaptee, family._wrap));
    this.args = oldArgs;
    return ans;
  };
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = VisitorFamily;


/***/ }),

/***/ "./node_modules/ohm-js/extras/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/extras/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  VisitorFamily: __webpack_require__(/*! ./VisitorFamily */ "./node_modules/ohm-js/extras/VisitorFamily.js"),
  semanticsForToAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").semantics,
  toAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").helper
};


/***/ }),

/***/ "./node_modules/ohm-js/extras/semantics-toAST.js":
/*!*******************************************************!*\
  !*** ./node_modules/ohm-js/extras/semantics-toAST.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ../src/pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const MatchResult = __webpack_require__(/*! ../src/MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const Grammar = __webpack_require__(/*! ../src/Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

const defaultOperation = {
  _terminal() {
    return this.primitiveValue;
  },

  _nonterminal(children) {
    const ctorName = this._node.ctorName;
    const mapping = this.args.mapping;

    // without customization
    if (!mapping.hasOwnProperty(ctorName)) {
      // intermediate node
      if (this._node instanceof pexprs.Alt || this._node instanceof pexprs.Apply) {
        return children[0].toAST(mapping);
      }

      // lexical rule
      if (this.isLexical()) {
        return this.sourceString;
      }

      // singular node (e.g. only surrounded by literals or lookaheads)
      const realChildren = children.filter(child => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }

      // rest: terms with multiple children
    }

    // direct forward
    if (typeof mapping[ctorName] === 'number') {
      return children[mapping[ctorName]].toAST(mapping);
    }

    // named/mapped children or unnamed children ('0', '1', '2', ...)
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === 'number') {
        // direct forward
        node[prop] = children[mappedProp].toAST(mapping);
      } else if ((typeof mappedProp === 'string') || (typeof mappedProp === 'boolean') ||
          (mappedProp === null)) {
        // primitive value
        node[prop] = mappedProp;
      } else if ((typeof mappedProp === 'object') && (mappedProp instanceof Number)) {
        // primitive number (must be unboxed)
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === 'function') {
        // computed value
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === undefined) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          // delete predefined 'type' properties, like 'type', if explicitely removed
          delete node[prop];
        }
      }
    }
    return node;
  },

  _iter(children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }

    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },

  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },

  EmptyListOf() {
    return [];
  }
};

// Returns a plain JavaScript object that includes an abstract syntax tree (AST)
// for the given match result `res` containg a concrete syntax tree (CST) and grammar.
// The optional `mapping` parameter can be used to customize how the nodes of the CST
// are mapped to the AST (see /doc/extras.md#toastmatchresult-mapping).
function toAST(res, mapping) {
  if (!(res instanceof MatchResult) || res.failed()) {
    throw new Error('toAST() expects a succesfull MatchResult as first parameter');
  }

  mapping = extend({}, mapping);
  const operation = extend({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === 'function') {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g = res._cst.grammar;
  const s = g.createSemantics().addOperation('toAST(mapping)', operation);
  return s(res).toAST(mapping);
}

// Returns a semantics containg the toAST(mapping) operation for the given grammar g.
function semanticsForToAST(g) {
  if (!(g instanceof Grammar)) {
    throw new Error('semanticsToAST() expects a Grammar as parameter');
  }

  return g.createSemantics().addOperation('toAST(mapping)', defaultOperation);
}

module.exports = {
  helper: toAST,
  semantics: semanticsForToAST
};


/***/ }),

/***/ "./node_modules/ohm-js/node_modules/is-buffer/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ohm-js/node_modules/is-buffer/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "./node_modules/ohm-js/package.json":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/package.json ***!
  \******************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bin, bugs, contributors, dependencies, description, devDependencies, engines, homepage, keywords, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_args\":[[\"ohm-js@15.4.1\",\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\"]],\"_from\":\"ohm-js@15.4.1\",\"_id\":\"ohm-js@15.4.1\",\"_inBundle\":false,\"_integrity\":\"sha512-ob5b6hnlg6tR73Zxd8ON/MQND36SgEDbKQYrzdDVVyTNa3d3aJ/YyobB7mItJ8YXNTZGgZ/eUiLtfo2CU0uREA==\",\"_location\":\"/ohm-js\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"ohm-js@15.4.1\",\"name\":\"ohm-js\",\"escapedName\":\"ohm-js\",\"rawSpec\":\"15.4.1\",\"saveSpec\":null,\"fetchSpec\":\"15.4.1\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/ohm-js/-/ohm-js-15.4.1.tgz\",\"_spec\":\"15.4.1\",\"_where\":\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\",\"author\":{\"name\":\"Alex Warth\",\"email\":\"alexwarth@gmail.com\",\"url\":\"http://tinlizzie.org/~awarth\"},\"bin\":{\"ohm-js\":\"src/ohm-cmd.js\"},\"bugs\":{\"url\":\"https://github.com/harc/ohm/issues\"},\"contributors\":[{\"name\":\"Patrick Dubroy\",\"email\":\"pdubroy@gmail.com\"},{\"name\":\"Meixian Li\",\"email\":\"lmeixian@gmail.com\"},{\"name\":\"Marko Röder\",\"email\":\"m.roeder@photon-software.de\"},{\"name\":\"Tony Garnock-Jones\",\"email\":\"tonygarnockjones@gmail.com\"},{\"name\":\"Saketh Kasibatla\",\"email\":\"sake.kasi@gmail.com\"},{\"name\":\"Lionel Landwerlin\",\"email\":\"llandwerlin@gmail.com\"},{\"name\":\"Jason Merrill\",\"email\":\"jwmerrill@gmail.com\"},{\"name\":\"Ray Toal\",\"email\":\"rtoal@lmu.edu\"},{\"name\":\"Yoshiki Ohshima\",\"email\":\"Yoshiki.Ohshima@acm.org\"},{\"name\":\"stagas\",\"email\":\"gstagas@gmail.com\"},{\"name\":\"Jonathan Edwards\",\"email\":\"JonathanMEdwards@gmail.com\"},{\"name\":\"Neil Jewers\",\"email\":\"njjewers@uwaterloo.ca\"},{\"name\":\"Mike Niebling\",\"email\":\"(none)\",\"url\":\"none\"},{\"name\":\"Arthur Carabott\",\"email\":\"arthurc@gmail.com\"},{\"name\":\"AngryPowman\",\"email\":\"angrypowman@qq.com\"},{\"name\":\"Luca Guzzon\",\"email\":\"luca.guzzon@gmail.com\"},{\"name\":\"Leslie Ying\",\"email\":\"acetophore@users.noreply.github.com\"},{\"name\":\"Stan Rozenraukh\",\"email\":\"stan@stanistan.com\"},{\"name\":\"Stephan Seidt\",\"email\":\"stephan.seidt@gmail.com\"},{\"name\":\"Thomas Nyberg\",\"email\":\"tomnyberg@gmail.com\"},{\"name\":\"Justin Chase\",\"email\":\"justin.m.chase@gmail.com\"},{\"name\":\"Vse Mozhet Byt\",\"email\":\"vsemozhetbyt@gmail.com\"},{\"name\":\"Wil Chung\",\"email\":\"10446+iamwilhelm@users.noreply.github.com\"},{\"name\":\"Daniel Tomlinson\",\"email\":\"DanielTomlinson@me.com\"},{\"name\":\"abego\",\"email\":\"ub@abego-software.de\"},{\"name\":\"acslk\",\"email\":\"d_vd415@hotmail.com\"},{\"name\":\"codeZeilen\",\"email\":\"codeZeilen@users.noreply.github.com\"},{\"name\":\"owch\",\"email\":\"bowenrainyday@gmail.com\"},{\"name\":\"sfinnie\",\"email\":\"scott.finnie@gmail.com\"},{\"name\":\"Milan Lajtoš\",\"email\":\"milan.lajtos@me.com\"}],\"dependencies\":{\"is-buffer\":\"^2.0.4\",\"util-extend\":\"^1.0.3\"},\"description\":\"An object-oriented language for parsing and pattern matching\",\"devDependencies\":{\"@types/tape\":\"^4.13.0\",\"eslint\":\"^7.9.0\",\"eslint-config-google\":\"^0.14.0\",\"eslint-plugin-camelcase-ohm\":\"^0.2.1\",\"eslint-plugin-no-extension-in-require\":\"^0.2.0\",\"eslint-plugin-tape\":\"^1.1.0\",\"husky\":\"^4.2.5\",\"jsdom\":\"^9.9.1\",\"json\":\"^9.0.6\",\"markscript\":\"^0.5.0\",\"node-static\":\"^0.7.11\",\"nodemon\":\"^2.0.4\",\"ohm-grammar-ecmascript\":\"^0.5.0\",\"tap-spec\":\"^5.0.0\",\"tape\":\"^5.0.1\",\"tape-catch\":\"^1.0.6\",\"ts-loader\":\"^8.0.4\",\"ts-node\":\"^9.0.0\",\"typescript\":\"^4.0.3\",\"walk-sync\":\"^2.2.0\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^3.3.12\"},\"engines\":{\"node\":\">=0.12.1\"},\"homepage\":\"https://ohmlang.github.io/\",\"keywords\":[\"parser\",\"compiler\",\"pattern matching\",\"pattern-matching\",\"ometa\",\"ometa/js\",\"ometa-js\",\"ometajs\",\"rapid\",\"prototyping\"],\"license\":\"MIT\",\"main\":\"src/main.js\",\"name\":\"ohm-js\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/harc/ohm.git\"},\"scripts\":{\"bootstrap\":\"bash bin/bootstrap --test || (echo 'Bootstrap failed.' && mv -v dist/ohm-grammar.js.old dist/ohm-grammar.js && mv -v dist/built-in-rules.js.old dist/built-in-rules.js && mv -v dist/operations-and-attributes.js.old dist/operations-and-attributes.js)\",\"build\":\"yarn build-debug && webpack --mode=production\",\"build-debug\":\"webpack --mode=development\",\"clean\":\"rm -f dist/ohm.js dist/ohm.min.js\",\"lint\":\"eslint . --ignore-path ../.eslintignore\",\"postinstall\":\"node bin/dev-setup.js\",\"postpublish\":\"rm README.md\",\"pre-commit\":\"yarn run lint && yarn run build && yarn run test\",\"prebootstrap\":\"bash bin/prebootstrap\",\"prebuild-debug\":\"bash ../bin/update-env.sh\",\"prepublishOnly\":\"cp ../README.md .\",\"pretest\":\"bash ../bin/update-env.sh\",\"test\":\"(tape 'test/**/*.js' | tap-spec) && ts-node test/test-typings.ts\",\"test-watch\":\"bash bin/test-watch\",\"unsafe-bootstrap\":\"bash bin/bootstrap\",\"version-package\":\"bash bin/version\",\"watch\":\"webpack --mode=development --watch\"},\"types\":\"index.d.ts\",\"version\":\"15.4.1\"}");

/***/ }),

/***/ "./node_modules/ohm-js/src/Builder.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Builder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const GrammarDecl = __webpack_require__(/*! ./GrammarDecl */ "./node_modules/ohm-js/src/GrammarDecl.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Builder() {}

Builder.prototype = {
  currentDecl: null,
  currentRuleName: null,

  newGrammar(name) {
    return new GrammarDecl(name);
  },

  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name);
    if (superGrammar) {
      gDecl.withSuperGrammar(this.fromRecipe(superGrammar));
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }

    this.currentDecl = gDecl;
    Object.keys(rules).forEach(ruleName => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];

      const action = ruleRecipe[0]; // define/extend/override
      const metaInfo = ruleRecipe[1];
      const description = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);

      let source;
      if (gDecl.source && metaInfo && metaInfo.sourceInterval) {
        source = gDecl.source.subInterval(
            metaInfo.sourceInterval[0],
            metaInfo.sourceInterval[1] - metaInfo.sourceInterval[0]);
      }
      gDecl[action](ruleName, formals, body, description, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },

  terminal(x) {
    return new pexprs.Terminal(x);
  },

  range(from, to) {
    return new pexprs.Range(from, to);
  },

  param(index) {
    return new pexprs.Param(index);
  },

  alt(/* term1, term2, ... */) {
    let terms = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs.Alt(terms);
  },

  seq(/* factor1, factor2, ... */) {
    let factors = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs.Seq(factors);
  },

  star(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Star(expr);
  },

  plus(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Plus(expr);
  },

  opt(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Opt(expr);
  },

  not(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Not(expr);
  },

  la(expr) {
    // TODO: temporary to still be able to read old recipes
    return this.lookahead(expr);
  },

  lookahead(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lookahead(expr);
  },

  lex(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lex(expr);
  },

  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs.PExpr ? param :
          this.fromRecipe(param);
      }, this);
    }
    return new pexprs.Apply(ruleName, optParams);
  },

  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs.Splice(
        this.currentDecl.superGrammar,
        this.currentRuleName,
        beforeTerms.map(term => this.fromRecipe(term)),
        afterTerms.map(term => this.fromRecipe(term)));
  },

  fromRecipe(recipe) {
    // the meta-info of 'grammar' is processed in Builder.grammar
    const result = this[recipe[0]].apply(this,
      recipe[0] === 'grammar' ? recipe.slice(1) : recipe.slice(2));

    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(
            this.currentDecl.sourceInterval.apply(this.currentDecl, metaInfo.sourceInterval)
        );
      }
    }
    return result;
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Builder;


/***/ }),

/***/ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/CaseInsensitiveTerminal.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const TerminalNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").TerminalNode;
const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const {PExpr, Terminal} = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

class CaseInsensitiveTerminal extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }

  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert(terminal instanceof Terminal, 'expected a Terminal expression');
    return terminal.obj;
  }

  // Implementation of the PExpr API

  allowsSkippingPrecedingSpace() {
    return true;
  }

  eval(state) {
    const inputStream = state.inputStream;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(state.grammar, matchStr), origPos);
      return true;
    }
  }

  generateExample(grammar, examples, inSyntacticContext, actuals) {
    // Start with a example generated from the Terminal...
    const str = this.obj.generateExample(grammar, examples, inSyntacticContext, actuals).value;

    // ...and randomly switch characters to uppercase/lowercase.
    let value = '';
    for (let i = 0; i < str.length; ++i) {
      value += Math.random() < 0.5 ? str[i].toLocaleLowerCase() : str[i].toLocaleUpperCase();
    }
    return {value};
  }

  getArity() {
    return 1;
  }

  substituteParams(actuals) {
    return new CaseInsensitiveTerminal(this.obj.substituteParams(actuals));
  }

  toDisplayString() {
    return this.obj.toDisplayString() + ' (case-insensitive)';
  }

  toFailure(grammar) {
    return new Failure(this, this.obj.toFailure(grammar) + ' (case-insensitive)', 'description');
  }

  _isNullable(grammar, memo) {
    return this.obj._isNullable(grammar, memo);
  }
}

module.exports = CaseInsensitiveTerminal;


/***/ }),

/***/ "./node_modules/ohm-js/src/Failure.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Failure.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

/*
  `Failure`s represent expressions that weren't matched while parsing. They are used to generate
  error messages automatically. The interface of `Failure`s includes the collowing methods:

  - getText() : String
  - getType() : String  (one of {"description", "string", "code"})
  - isDescription() : bool
  - isStringTerminal() : bool
  - isCode() : bool
  - isFluffy() : bool
  - makeFluffy() : void
  - subsumes(Failure) : bool
*/

function isValidType(type) {
  return type === 'description' || type === 'string' || type === 'code';
}

function Failure(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error('invalid Failure type: ' + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}

Failure.prototype.getPExpr = function() {
  return this.pexpr;
};

Failure.prototype.getText = function() {
  return this.text;
};

Failure.prototype.getType = function() {
  return this.type;
};

Failure.prototype.isDescription = function() {
  return this.type === 'description';
};

Failure.prototype.isStringTerminal = function() {
  return this.type === 'string';
};

Failure.prototype.isCode = function() {
  return this.type === 'code';
};

Failure.prototype.isFluffy = function() {
  return this.fluffy;
};

Failure.prototype.makeFluffy = function() {
  this.fluffy = true;
};

Failure.prototype.clearFluffy = function() {
  this.fluffy = false;
};

Failure.prototype.subsumes = function(that) {
  return this.getText() === that.getText() &&
      this.type === that.type &&
      (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};

Failure.prototype.toString = function() {
  return this.type === 'string' ?
    JSON.stringify(this.getText()) :
    this.getText();
};

Failure.prototype.clone = function() {
  const failure = new Failure(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};

Failure.prototype.toKey = function() {
  return this.toString() + '#' + this.type;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Failure;


/***/ }),

/***/ "./node_modules/ohm-js/src/Grammar.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Grammar.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const CaseInsensitiveTerminal = __webpack_require__(/*! ./CaseInsensitiveTerminal */ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js");
const Matcher = __webpack_require__(/*! ./Matcher */ "./node_modules/ohm-js/src/Matcher.js");
const Semantics = __webpack_require__(/*! ./Semantics */ "./node_modules/ohm-js/src/Semantics.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getSortedRuleValues(grammar) {
  return Object.keys(grammar.rules).sort().map(name => grammar.rules[name]);
}

function Grammar(
    name,
    superGrammar,
    rules,
    optDefaultStartRule) {
  this.name = name;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error("Invalid start rule: '" + optDefaultStartRule +
                      "' is not a rule in grammar '" + name + "'");
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}

let ohmGrammar;
let buildGrammar;

// This method is called from main.js once Ohm has loaded.
Grammar.initApplicationParser = function(grammar, builderFn) {
  ohmGrammar = grammar;
  buildGrammar = builderFn;
};

Grammar.prototype = {
  matcher() {
    return new Matcher(this);
  },

  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;
  },

  equals(g) {
    if (this === g) {
      return true;
    }
    // Do the cheapest comparisons first.
    if (g == null ||
        this.name !== g.name ||
        this.defaultStartRule !== g.defaultStartRule ||
        !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description &&
             rule.formals.join(',') === otherRules[i].formals.join(',') &&
             rule.body.toString() === otherRules[i].body.toString();
    });
  },

  match(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.match(optStartApplication);
  },

  trace(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.trace(optStartApplication);
  },

  semantics() {
    // TODO: Remove this eventually! Deprecated in v0.12.
    throw new Error('semantics() is deprecated -- use createSemantics() instead.');
  },

  createSemantics() {
    return Semantics.createSemantics(this);
  },

  extendSemantics(superSemantics) {
    return Semantics.createSemantics(this, superSemantics._getSemantics());
  },

  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name, actionDict) {
    function isSpecialAction(a) {
      return a === '_iter' || a === '_terminal' || a === '_nonterminal' || a === '_default';
    }

    const problems = [];
    for (const k in actionDict) {
      const v = actionDict[k];
      if (!isSpecialAction(k) && !(k in this.rules)) {
        problems.push("'" + k + "' is not a valid semantic action for '" + this.name + "'");
      } else if (typeof v !== 'function') {
        problems.push(
            "'" + k + "' must be a function in an action dictionary for '" + this.name + "'");
      } else {
        const actual = v.length;
        const expected = this._topDownActionArity(k);
        if (actual !== expected) {
          problems.push(
              "Semantic action '" + k + "' has the wrong arity: " +
              'expected ' + expected + ', got ' + actual);
        }
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map(problem => '- ' + problem);
      const error = new Error(
          "Found errors in the action dictionary of the '" + name + "' " + what + ':\n' +
          prettyProblems.join('\n'));
      error.problems = problems;
      throw error;
    }
  },

  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    if (actionName === '_iter' || actionName === '_nonterminal' || actionName === '_default') {
      return 1;
    } else if (actionName === '_terminal') {
      return 0;
    }
    return this.rules[actionName].body.getArity();
  },

  _inheritsFrom(grammar) {
    let g = this.superGrammar;
    while (g) {
      if (g.equals(grammar, true)) {
        return true;
      }
      g = g.superGrammar;
    }
    return false;
  },

  toRecipe(optVarName) {
    const metaInfo = {};
    // Include the grammar source if it is available.
    if (this.source) {
      metaInfo.source = this.source.contents;
    }

    let superGrammar = null;
    if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammar = JSON.parse(this.superGrammar.toRecipe());
    }

    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }

    const rules = {};
    const self = this;
    Object.keys(this.rules).forEach(ruleName => {
      const ruleInfo = self.rules[ruleName];
      const body = ruleInfo.body;
      const isDefinition = !self.superGrammar || !self.superGrammar.rules[ruleName];

      let operation;
      if (isDefinition) {
        operation = 'define';
      } else {
        operation = body instanceof pexprs.Extend ? 'extend' : 'override';
      }

      const metaInfo = {};
      if (ruleInfo.source && self.source) {
        const adjusted = ruleInfo.source.relativeTo(self.source);
        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }

      const description = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, self.source);

      rules[ruleName] = [
        operation, // "define"/"extend"/"override"
        metaInfo,
        description,
        ruleInfo.formals,
        bodyRecipe
      ];
    });

    return JSON.stringify([
      'grammar',
      metaInfo,
      this.name,
      superGrammar,
      startRule,
      rules
    ]);
  },

  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },

  _toOperationOrAttributeActionDictionaryTemplate() {
    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus
    // should appear next to other cases of AddExpr.

    const sb = new common.StringBuffer();
    sb.append('{');

    let first = true;
    for (const ruleName in this.rules) {
      const body = this.rules[ruleName].body;
      if (first) {
        first = false;
      } else {
        sb.append(',');
      }
      sb.append('\n');
      sb.append('  ');
      this.addSemanticActionTemplate(ruleName, body, sb);
    }

    sb.append('\n}');
    return sb.contents();
  },

  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(': function(');
    const arity = this._topDownActionArity(ruleName);
    sb.append(common.repeat('_', arity).join(', '));
    sb.append(') {\n');
    sb.append('  }');
  },

  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf('<') === -1) {
      // simple application
      app = new pexprs.Apply(str);
    } else {
      // parameterized application
      const cst = ohmGrammar.match(str, 'Base_application');
      app = buildGrammar(cst, {});
    }

    // Ensure that the application is valid.
    if (!(app.ruleName in this.rules)) {
      throw errors.undeclaredRule(app.ruleName, this.name);
    }
    const formals = this.rules[app.ruleName].formals;
    if (formals.length !== app.args.length) {
      const source = this.rules[app.ruleName].source;
      throw errors.wrongNumberOfParameters(app.ruleName, formals.length, app.args.length, source);
    }
    return app;
  }
};

// The following grammar contains a few rules that couldn't be written  in "userland".
// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called
// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and
// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar
// isn't specified.
Grammar.ProtoBuiltInRules = new Grammar(
    'ProtoBuiltInRules', // name
    undefined, // supergrammar
    {
      any: {
        body: pexprs.any,
        formals: [],
        description: 'any character',
        primitive: true
      },
      end: {
        body: pexprs.end,
        formals: [],
        description: 'end of input',
        primitive: true
      },

      caseInsensitive: {
        body: new CaseInsensitiveTerminal(new pexprs.Param(0)),
        formals: ['str'],
        primitive: true
      },
      lower: {
        body: new pexprs.UnicodeChar('Ll'),
        formals: [],
        description: 'a lowercase letter',
        primitive: true
      },
      upper: {
        body: new pexprs.UnicodeChar('Lu'),
        formals: [],
        description: 'an uppercase letter',
        primitive: true
      },
      // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
      unicodeLtmo: {
        body: new pexprs.UnicodeChar('Ltmo'),
        formals: [],
        description: 'a Unicode character in Lt, Lm, or Lo',
        primitive: true
      },

      // These rules are not truly primitive (they could be written in userland) but are defined
      // here for bootstrapping purposes.
      spaces: {
        body: new pexprs.Star(new pexprs.Apply('space')),
        formals: []
      },
      space: {
        body: new pexprs.Range('\x00', ' '),
        formals: [],
        description: 'a space'
      }
    }
);

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Grammar;


/***/ }),

/***/ "./node_modules/ohm-js/src/GrammarDecl.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/GrammarDecl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Constructors

function GrammarDecl(name) {
  this.name = name;
}

// Helpers

GrammarDecl.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};

GrammarDecl.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
        // TODO: The conditional expression below is an ugly hack. It's kind of ok because
        // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
        // we should try to find a better way to do this.
        this.name === 'BuiltInRules' ?
            Grammar.ProtoBuiltInRules :
            Grammar.BuiltInRules);
  }
  return this.superGrammar;
};

GrammarDecl.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
  }
  return ruleInfo;
};

GrammarDecl.prototype.installOverriddenOrExtendedRule = function(name, formals, body, source) {
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
  }
  return this.install(name, formals, body, ruleInfo.description, source);
};

GrammarDecl.prototype.install = function(name, formals, body, description, source) {
  this.rules[name] = {
    body: body.introduceParams(formals),
    formals,
    description,
    source
  };
  return this;
};

// Stuff that you should only do once

GrammarDecl.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error('the super grammar of a GrammarDecl cannot be set more than once');
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);

  // Grammars with an explicit supergrammar inherit a default start rule.
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};

GrammarDecl.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};

GrammarDecl.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};

// Creates a Grammar instance, and if it passes the sanity checks, returns it.
GrammarDecl.prototype.build = function() {
  const grammar = new Grammar(
      this.name,
      this.ensureSuperGrammar(),
      this.rules,
      this.defaultStartRule);

  // TODO: change the pexpr.prototype.assert... methods to make them add
  // exceptions to an array that's provided as an arg. Then we'll be able to
  // show more than one error of the same type at a time.
  // TODO: include the offending pexpr in the errors, that way we can show
  // the part of the source that caused it.
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar.rules).forEach(ruleName => {
    const body = grammar.rules[ruleName].body;
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    // The following check can only be done if the grammar has no invalid applications.
    Object.keys(grammar.rules).forEach(ruleName => {
      const body = grammar.rules[ruleName].body;
      try {
        body.assertIteratedExprsAreNotNullable(grammar, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar.source = this.source;
  }

  return grammar;
};

// Rule declarations

GrammarDecl.prototype.define = function(name, formals, body, description, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
  } else if (this.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.name, source);
  }
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  return this.install(name, formals, body, description, source);
};

GrammarDecl.prototype.override = function(name, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name, source);
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

GrammarDecl.prototype.extend = function(name, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
  }
  const body = new pexprs.Extend(this.superGrammar, name, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = GrammarDecl;


/***/ }),

/***/ "./node_modules/ohm-js/src/InputStream.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/InputStream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function InputStream(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}

InputStream.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },

  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },

  matchString(s, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      /*
        Case-insensitive comparison is a tricky business. Some notable gotchas include the
        "Turkish I" problem (http://www.i18nguy.com/unicode/turkish-i18n.html) and the fact
        that the German Esszet (ß) turns into "SS" in upper case.

        This is intended to be a locale-invariant comparison, which means it may not obey
        locale-specific expectations (e.g. "i" => "İ").
       */
      for (idx = 0; idx < s.length; idx++) {
        const actual = this.next();
        const expected = s[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    // Default is case-sensitive comparison.
    for (idx = 0; idx < s.length; idx++) {
      if (this.next() !== s[idx]) { return false; }
    }
    return true;
  },

  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },

  interval(startIdx, optEndIdx) {
    return new Interval(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = InputStream;


/***/ }),

/***/ "./node_modules/ohm-js/src/Interval.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/src/Interval.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Interval(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}

Interval.coverage = function(/* interval1, interval2, ... */) {
  const sourceString = arguments[0].sourceString;
  let startIdx = arguments[0].startIdx;
  let endIdx = arguments[0].endIdx;
  for (let idx = 1; idx < arguments.length; idx++) {
    const interval = arguments[idx];
    if (interval.sourceString !== sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, arguments[idx].startIdx);
      endIdx = Math.max(endIdx, arguments[idx].endIdx);
    }
  }
  return new Interval(sourceString, startIdx, endIdx);
};

Interval.prototype = {
  coverageWith(/* interval1, interval2, ... */) {
    const intervals = Array.prototype.slice.call(arguments);
    intervals.push(this);
    return Interval.coverage.apply(undefined, intervals);
  },

  collapsedLeft() {
    return new Interval(this.sourceString, this.startIdx, this.startIdx);
  },

  collapsedRight() {
    return new Interval(this.sourceString, this.endIdx, this.endIdx);
  },

  getLineAndColumn() {
    return util.getLineAndColumn(this.sourceString, this.startIdx);
  },

  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },

  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      // `this` and `that` are the same interval!
      return [
      ];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      // `that` splits `this` into two intervals
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx),
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      // `that` contains a prefix of `this`
      return [
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      // `that` contains a suffix of `this`
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx)
      ];
    } else {
      // `that` and `this` do not overlap
      return [
        this
      ];
    }
  },

  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    }
    assert(this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
        'other interval does not cover this one');
    return new Interval(this.sourceString,
        this.startIdx - that.startIdx,
        this.endIdx - that.startIdx);
  },

  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends. (This only makes sense when
  // the input stream is a string.)
  trimmed() {
    const contents = this.contents;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval(this.sourceString, startIdx, endIdx);
  },

  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval(this.sourceString, newStartIdx, newStartIdx + len);
  }
};

Object.defineProperties(Interval.prototype, {
  contents: {
    get() {
      if (this._contents === undefined) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() { return this.endIdx - this.startIdx; },
    enumerable: true
  }
});

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Interval;



/***/ }),

/***/ "./node_modules/ohm-js/src/MatchResult.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/MatchResult.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function MatchResult(
    matcher,
    input,
    startExpr,
    cst,
    cstOffset,
    rightmostFailurePosition,
    optRecordedFailures) {

  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;

  if (this.failed()) {
    common.defineLazyProperty(this, 'message', function() {
      const detail = 'Expected ' + this.getExpectedText();
      return util.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common.defineLazyProperty(this, 'shortMessage', function() {
      const detail = 'expected ' + this.getExpectedText();
      const errorInfo = util.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;
    });
  }
}

MatchResult.prototype.succeeded = function() {
  return !!this._cst;
};

MatchResult.prototype.failed = function() {
  return !this.succeeded();
};

MatchResult.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};

MatchResult.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures =
        this.matcher._match(this.startExpr, false, this.getRightmostFailurePosition());
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};

MatchResult.prototype.toString = function() {
  return this.succeeded() ?
      '[match succeeded]' :
      '[match failed at position ' + this.getRightmostFailurePosition() + ']';
};

// Return a string summarizing the expected contents of the input stream when
// the match failure occurred.
MatchResult.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error('cannot get expected text of a successful MatchResult');
  }

  const sb = new common.StringBuffer();
  let failures = this.getRightmostFailures();

  // Filter out the fluffy failures to make the default error messages more useful
  failures = failures.filter(failure => !failure.isFluffy());

  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ', or ' : ' or ');
      } else {
        sb.append(', ');
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};

MatchResult.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchResult;


/***/ }),

/***/ "./node_modules/ohm-js/src/MatchState.js":
/*!***********************************************!*\
  !*** ./node_modules/ohm-js/src/MatchState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const PosInfo = __webpack_require__(/*! ./PosInfo */ "./node_modules/ohm-js/src/PosInfo.js");
const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const applySpaces = new pexprs.Apply('spaces');

function MatchState(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;

  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream(matcher.input);
  this.memoTable = matcher.memoTable;

  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];

  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];

  if (optPositionToRecordFailures !== undefined) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = Object.create(null);
  }
}

MatchState.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },

  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },

  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();

    this.rightmostFailurePosition = Math.max(
        this.rightmostFailurePosition,
        this._rightmostFailurePositionStack.pop());

    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },

  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },

  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },

  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },

  inSyntacticContext() {
    if (typeof this.inputStream.source !== 'string') {
      return false;
    }
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      // The top-level context is syntactic if the start application is.
      return this.startExpr.factors[0].isSyntactic();
    }
  },

  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },

  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },

  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ?
        this.skipSpaces() :
        this.inputStream.pos;
  },

  maybeSkipSpacesBefore(expr) {
    if (expr instanceof pexprs.Apply && expr.isSyntactic()) {
      return this.skipSpaces();
    } else if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },

  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },

  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },

  numBindings() {
    return this._bindings.length;
  },

  truncateBindings(newLength) {
    // Yes, this is this really faster than setting the `length` property (tested with
    // bin/es5bench on Node v6.1.0).
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },

  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },

  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },

  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);

    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        // Substitute parameters with the actual pexprs that were passed to
        // the current rule.
        expr = expr.substituteParams(app.args);
      } else {
        // This branch is only reached for the "end-check" that is
        // performed after the top-level application. In that case,
        // expr === pexprs.end so there is no need to substitute
        // parameters.
      }

      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },

  recordFailure(failure, shouldCloneIfNew) {
    const key = failure.toKey();
    if (!this.recordedFailures[key]) {
      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key].clearFluffy();
    }
  },

  recordFailures(failures, shouldCloneIfNew) {
    const self = this;
    Object.keys(failures).forEach(key => {
      self.recordFailure(failures[key], shouldCloneIfNew);
    });
  },

  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return undefined;
    }

    const ans = Object.create(null);
    const self = this;
    Object.keys(this.recordedFailures).forEach(key => {
      ans[key] = self.recordedFailures[key].clone();
    });
    return ans;
  },

  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },

  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ?
        this.posToOffset(this.rightmostFailurePosition) :
        -1;
  },

  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr.ruleName) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },

  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) ||
           new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },

  isTracing() {
    return !!this.trace;
  },

  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }

    if (this.recordedFailures &&
        this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }

    return true;
  },


  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }

    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition =
        Math.max(this.rightmostFailurePosition, memoRecRightmostFailurePosition);
    if (this.recordedFailures &&
        this.positionToRecordFailures === memoRecRightmostFailurePosition &&
        memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }

    this.inputStream.examinedLength =
        Math.max(this.inputStream.examinedLength, memoRec.examinedLength + origPos);

    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },

  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const inputStream = this.inputStream;
    const origNumBindings = this._bindings.length;

    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = Object.create(null);
    }

    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);

    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }

    // Do the actual evaluation.
    const ans = expr.eval(this);

    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }

    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        const self = this;
        Object.keys(this.recordedFailures).forEach(key => {
          self.recordedFailures[key].makeFluffy();
        });
      }
    } else {
      // Reset the position and the bindings.
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }

    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }

    return ans;
  },

  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      const self = this;
      rightmostFailures = Object.keys(this.recordedFailures).map(key => self.recordedFailures[key]);
    }
    return new MatchResult(
        this.matcher,
        this.input,
        this.startExpr,
        this._bindings[0],
        this._bindingOffsets[0],
        this.rightmostFailurePosition,
        rightmostFailures);
  },

  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();

    // The trace node for the start rule is always the last entry. If it is a syntactic rule,
    // the first entry is for an application of 'spaces'.
    // TODO(pdubroy): Clean this up by introducing a special `Match<startAppl>` rule, which will
    // ensure that there is always a single root trace node.
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },

  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },

  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchState;


/***/ }),

/***/ "./node_modules/ohm-js/src/Matcher.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Matcher.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const MatchState = __webpack_require__(/*! ./MatchState */ "./node_modules/ohm-js/src/MatchState.js");

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Matcher(grammar) {
  this.grammar = grammar;
  this.memoTable = [];
  this.input = '';
}

Matcher.prototype.getInput = function() {
  return this.input;
};

Matcher.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};

Matcher.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length ||
      endIdx < 0 || endIdx > currentInput.length ||
      startIdx > endIdx) {
    throw new Error('Invalid indices: ' + startIdx + ' and ' + endIdx);
  }

  // update input
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);

  // update memo table (similar to the above)
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(undefined);
  }
  restOfMemoTable.forEach(
      function(posInfo) { this.memoTable.push(posInfo); },
      this);

  // Invalidate memoRecs
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }

  return this;
};

Matcher.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};

Matcher.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};

Matcher.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};

/*
  Returns the starting expression for this Matcher's associated grammar. If `optStartApplicationStr`
  is specified, it is a string expressing a rule application in the grammar. If not specified, the
  grammar's default start rule will be used.
*/
Matcher.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error('Missing start rule argument -- the grammar has no default start rule.');
  }

  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs.Seq([startApp, pexprs.end]);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Matcher;


/***/ }),

/***/ "./node_modules/ohm-js/src/Namespace.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Namespace.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Namespace() {
}
Namespace.prototype = Object.create(null);

Namespace.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace) {
    return objOrNamespace;
  }
  return Namespace.createNamespace(objOrNamespace);
};

// Create a new namespace. If `optProps` is specified, all of its properties
// will be copied to the new namespace.
Namespace.createNamespace = function(optProps) {
  return Namespace.extend(Namespace.prototype, optProps);
};

// Create a new namespace which extends another namespace. If `optProps` is
// specified, all of its properties will be copied to the new namespace.
Namespace.extend = function(namespace, optProps) {
  if (namespace !== Namespace.prototype && !(namespace instanceof Namespace)) {
    throw new TypeError('not a Namespace object: ' + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return extend(ns, optProps);
};

// TODO: Should this be a regular method?
Namespace.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Namespace;


/***/ }),

/***/ "./node_modules/ohm-js/src/PosInfo.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/PosInfo.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function PosInfo() {
  this.applicationMemoKeyStack = []; // active applications at this position
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = undefined;
}

PosInfo.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },

  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },

  exit() {
    this.applicationMemoKeyStack.pop();
  },

  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;

    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    const indexOfFirstInvolvedRule =
        applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(indexOfFirstInvolvedRule);

    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };

    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },

  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },

  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },

  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset =
        Math.max(this.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
    return memoRec;
  },

  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      // Optimization: none of the rule applications that were memoized here examined the
      // interval of the input that changed, so nothing has to be invalidated.
      return;
    }

    const memo = this.memo;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    const self = this;
    Object.keys(memo).forEach(k => {
      const memoRec = memo[k];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k];
      } else {
        self.maxExaminedLength = Math.max(self.maxExaminedLength, memoRec.examinedLength);
        self.maxRightmostFailureOffset =
            Math.max(self.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
      }
    });
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = PosInfo;


/***/ }),

/***/ "./node_modules/ohm-js/src/Semantics.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Semantics.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const IterationNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").IterationNode;
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const globalActionStack = [];
let prototypeGrammar;
let prototypeGrammarSemantics;

// JSON is not a valid subset of JavaScript because there are two possible line terminators,
// U+2028 (line separator) and U+2029 (paragraph separator) that are allowed in JSON strings
// but not in JavaScript strings.
// jsonToJS() properly encodes those two characters in JSON so that it can seamlessly be
// inserted into JavaScript code (plus the encoded version is still valid JSON)
function jsonToJS(str) {
  const output = str.replace(/[\u2028\u2029]/g, (char, pos, str) => {
    const hex = char.codePointAt(0).toString(16);
    return '\\u' + '0000'.slice(hex.length) + hex;
  });
  return output;
}

// ----------------- Wrappers -----------------

// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)
// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A
// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and
// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is
// used to cache the wrapper instances that are created for its child nodes. Setting these instance
// variables is the responsibility of the constructor of each Semantics-specific subclass of
// `Wrapper`.
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;

    // The interval that the childOffsets of `node` are relative to. It should be the source
    // of the closest Nonterminal node.
    this._baseInterval = baseInterval;

    if (node.isNonterminal()) {
      common.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }

  toString() {
    return '[semantics wrapper for ' + this._node.grammar.name + ']';
  };

  // This is used by ohm editor to display a node wrapper appropriately.
  toJSON() {
    return this.toString();
  }

  _forgetMemoizedResultFor(attributeName) {
    // Remove the memoized attribute from the cstNode and all its children.
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach(child => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }

  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      // TODO: Consider throwing an exception here.
      return undefined;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];

      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
    }
    return childWrapper;
  }

  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    // Force the creation of all child wrappers
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }

  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }

  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }

  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }

  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];

    const childNodes = childWrappers.map(c => c._node);
    const iter = new IterationNode(this._node.grammar, childNodes, [], -1, false);

    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }

  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }

  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }

  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error('The `interval` property is deprecated -- use `source` instead');
  }

  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }

  // Returns the primitive value of this CST node, if it's a terminal node. Otherwise,
  // throws an exception.
  get primitiveValue() {
    if (this.isTerminal()) {
      return this._node.primitiveValue;
    }
    throw new TypeError(
        "tried to access the 'primitiveValue' attribute of a non-terminal CST node");
  }

  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}

// ----------------- Semantics -----------------

// A Semantics is a container for a family of Operations and Attributes for a given grammar.
// Semantics enable modularity (different clients of a grammar can create their set of operations
// and attributes in isolation) and extensibility even when operations and attributes are mutually-
// recursive. This constructor should not be called directly except from
// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are
// `g.createSemantics()` and `g.extendSemantics(parentSemantics)`.
function Semantics(grammar, superSemantics) {
  const self = this;
  this.grammar = grammar;
  this.checkedActionDicts = false;

  // Constructor for wrapper instances, which are passed as the arguments to the semantic actions
  // of an operation or attribute. Operations and attributes require double dispatch: the semantic
  // action is chosen based on both the node's type and the semantics. Wrappers ensure that
  // the `execute` method is called with the correct (most specific) semantics object as an
  // argument.
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self.checkActionDictsIfHaventAlready();
      this._semantics = self;
    }
  };

  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) {
      throw new Error(
          "Cannot extend a semantics for grammar '" + this.super.grammar.name +
          "' for use with grammar '" + grammar.name + "' (not a sub-grammar)");
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = Object.create(null);

    // Assign unique symbols for each of the attributes inherited from the super-semantics so that
    // they are memoized independently.
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = Object.create(null);
    this.attributes = Object.create(null);
    this.attributeKeys = Object.create(null);
  }
}

Semantics.prototype.toString = function() {
  return '[semantics for ' + this.grammar.name + ']';
};

Semantics.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};

// Checks that the action dictionaries for all operations and attributes in this semantics,
// including the ones that were inherited from the super-semantics, agree with the grammar.
// Throws an exception if one or more of them doesn't.
Semantics.prototype.checkActionDicts = function() {
  let name;
  for (name in this.operations) {
    this.operations[name].checkActionDict(this.grammar);
  }
  for (name in this.attributes) {
    this.attributes[name].checkActionDict(this.grammar);
  }
};

Semantics.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s) {
    return s.super !== Semantics.BuiltInSemantics._getSemantics();
  }

  let str = '(function(g) {\n';
  if (hasSuperSemantics(this)) {
    str += '  var semantics = ' + this.super.toRecipe(true) + '(g';

    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += '.superGrammar';
      relatedGrammar = relatedGrammar.superGrammar;
    }

    str += ');\n';
    str += '  return g.extendSemantics(semantics)';
  } else {
    str += '  return g.createSemantics()';
  }
  ['Operation', 'Attribute'].forEach(type => {
    const semanticOperations = this[type.toLowerCase() + 's'];
    Object.keys(semanticOperations).forEach(name => {
      const {actionDict, formals, builtInDefault} = semanticOperations[name];

      let signature = name;
      if (formals.length > 0) {
        signature += '(' + formals.join(', ') + ')';
      }

      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + 's'][name]) {
        method = 'extend' + type;
      } else {
        method = 'add' + type;
      }
      str += '\n    .' + method + '(' + JSON.stringify(signature) + ', {';

      const srcArray = [];
      Object.keys(actionDict).forEach(actionName => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();

          // Convert method shorthand to plain old function syntax.
          // https://github.com/harc/ohm/issues/263
          source = source.replace(/^.*\(/, 'function(');

          srcArray.push('\n      ' + JSON.stringify(actionName) + ': ' + source);
        }
      });
      str += srcArray.join(',') + '\n    })';
    });
  });
  str += ';\n  })';

  if (!semanticsOnly) {
    str =
      '(function() {\n' +
      '  var grammar = this.fromRecipe(' + jsonToJS(this.grammar.toRecipe()) + ');\n' +
      '  var semantics = ' + str + '(grammar);\n' +
      '  return semantics;\n' +
      '});\n';
  }

  return str;
};

function parseSignature(signature, type) {
  if (!prototypeGrammar) {
    // The Operations and Attributes grammar won't be available while Ohm is loading,
    // but we can get away the following simplification b/c none of the operations
    // that are used while loading take arguments.
    common.assert(signature.indexOf('(') === -1);
    return {
      name: signature,
      formals: []
    };
  }

  const r = prototypeGrammar.match(
      signature,
      type === 'operation' ? 'OperationSignature' : 'AttributeSignature');
  if (r.failed()) {
    throw new Error(r.message);
  }

  return prototypeGrammarSemantics(r).parse();
}

function newDefaultAction(type, name, doIt) {
  return function(children) {
    const self = this;
    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
    const args = thisThing.formals.map(formal => self.args[formal]);

    if (this.isIteration()) {
      // This CST node corresponds to an iteration expression in the grammar (*, +, or ?). The
      // default behavior is to map this operation or attribute over all of its child nodes.
      return children.map(child => doIt.apply(child, args));
    }

    // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that
    // we got here means that this action dictionary doesn't have an action for this particular
    // non-terminal or a generic `_nonterminal` action.
    if (children.length === 1) {
      // As a convenience, if this node only has one child, we just return the result of
      // applying this operation / attribute to the child node.
      return doIt.apply(children[0], args);
    } else {
      // Otherwise, we throw an exception to let the programmer know that we don't know what
      // to do with this node.
      throw errors.missingSemanticAction(this.ctorName, name, type, globalActionStack);
    }
  };
}

Semantics.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + 's';

  const parsedNameAndFormalArgs = parseSignature(signature, type);
  const name = parsedNameAndFormalArgs.name;
  const formals = parsedNameAndFormalArgs.formals;

  // TODO: check that there are no duplicate formal arguments

  this.assertNewName(name, type);

  // Create the action dictionary for this operation / attribute that contains a `_default` action
  // which defines the default behavior of iteration, terminal, and non-terminal nodes...
  const builtInDefault = newDefaultAction(type, name, doIt);
  const realActionDict = {_default: builtInDefault};
  // ... and add in the actions supplied by the programmer, which may override some or all of the
  // default ones.
  Object.keys(actionDict).forEach(name => {
    realActionDict[name] = actionDict[name];
  });

  const entry = type === 'operation' ?
      new Operation(name, formals, realActionDict, builtInDefault) :
      new Attribute(name, realActionDict, builtInDefault);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  entry.checkActionDict(this.grammar);

  this[typePlural][name] = entry;

  function doIt() {
    // Dispatch to most specific version of this operation / attribute -- it may have been
    // overridden by a sub-semantics.
    const thisThing = this._semantics[typePlural][name];

    // Check that the caller passed the correct number of arguments.
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
          'Invalid number of arguments passed to ' + name + ' ' + type + ' (expected ' +
          thisThing.formals.length + ', got ' + arguments.length + ')');
    }

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let idx = 0; idx < arguments.length; idx++) {
      const formal = thisThing.formals[idx];
      args[formal] = arguments[idx];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }

  if (type === 'operation') {
    this.Wrapper.prototype[name] = doIt;
    this.Wrapper.prototype[name].toString = function() {
      return '[' + name + ' operation]';
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name, {
      get: doIt,
      configurable: true // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name, {
      value: util.uniqueId(name)
    });
  }
};

Semantics.prototype.extendOperationOrAttribute = function(type, name, actionDict) {
  const typePlural = type + 's';

  // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.
  parseSignature(name, 'attribute');

  if (!(this.super && name in this.super[typePlural])) {
    throw new Error('Cannot extend ' + type + " '" + name +
        "': did not inherit an " + type + ' with that name');
  }
  if (Object.prototype.hasOwnProperty.call(this[typePlural], name)) {
    throw new Error('Cannot extend ' + type + " '" + name + "' again");
  }

  // Create a new operation / attribute whose actionDict delegates to the super operation /
  // attribute's actionDict, and which has all the keys from `inheritedActionDict`.
  const inheritedFormals = this[typePlural][name].formals;
  const inheritedActionDict = this[typePlural][name].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach(name => {
    newActionDict[name] = actionDict[name];
  });

  this[typePlural][name] = type === 'operation' ?
      new Operation(name, inheritedFormals, newActionDict) :
      new Attribute(name, newActionDict);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  this[typePlural][name].checkActionDict(this.grammar);
};

Semantics.prototype.assertNewName = function(name, type) {
  if (Wrapper.prototype.hasOwnProperty(name)) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': that's a reserved name");
  }
  if (name in this.operations) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an operation with that name already exists");
  }
  if (name in this.attributes) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an attribute with that name already exists");
  }
};

// Returns a wrapper for the given CST `node` in this semantics.
// If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?
Semantics.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};

// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from
// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new
// Semantics instance. When that function is invoked with a CST node as an argument, it returns
// a wrapper for that node which gives access to the operations and attributes provided by this
// semantics.
Semantics.createSemantics = function(grammar, optSuperSemantics) {
  const s = new Semantics(
      grammar,
      optSuperSemantics !== undefined ?
          optSuperSemantics :
          Semantics.BuiltInSemantics._getSemantics());

  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy
  // for `s`, which is the real `Semantics` instance.
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
          'Semantics expected a MatchResult, but got ' + common.unexpectedObjToString(matchResult));
    }
    if (matchResult.failed()) {
      throw new TypeError('cannot apply Semantics to ' + matchResult.toString());
    }

    const cst = matchResult._cst;
    if (cst.grammar !== grammar) {
      throw new Error(
          "Cannot use a MatchResult from grammar '" + cst.grammar.name +
          "' with a semantics for '" + grammar.name + "'");
    }
    const inputStream = new InputStream(matchResult.input);
    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };

  // Forward public methods from the proxy to the semantics instance.
  proxy.addOperation = function(signature, actionDict) {
    s.addOperationOrAttribute('operation', signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name, actionDict) {
    s.extendOperationOrAttribute('operation', name, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name, actionDict) {
    s.addOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name, actionDict) {
    s.extendOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error('"' + operationOrAttributeName + '" is not a valid operation or attribute ' +
        'name in this semantics for "' + grammar.name + '"');
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s.operations) {
      semantic = s.operations[operationOrAttributeName];
      delete s.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s.attributes) {
      semantic = s.attributes[operationOrAttributeName];
      delete s.attributes[operationOrAttributeName];
    }
    delete s.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s.attributes);
  };
  proxy.getGrammar = function() {
    return s.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s.toRecipe(semanticsOnly);
  };

  // Make the proxy's toString() work.
  proxy.toString = s.toString.bind(s);

  // Returns the semantics for the proxy.
  proxy._getSemantics = function() {
    return s;
  };

  return proxy;
};

// ----------------- Operation -----------------

// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very
// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by
// recursively walking the CST, and at each node, invoking the matching semantic action from
// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic
// action is found.
class Operation {
  constructor(name, formals, actionDict, builtInDefault) {
    this.name = name;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }

  checkActionDict(grammar) {
    grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }

  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      // Look for a semantic action whose name matches the node's constructor name, which is either
      // the name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an
      // iteration node). In the latter case, the action function receives a single argument, which
      // is an array containing all of the children of the CST node.
      const ctorName = nodeWrapper._node.ctorName;
      let actionFn = this.actionDict[ctorName];
      let ans;
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        ans = this.doAction(semantics, nodeWrapper, actionFn, nodeWrapper.isIteration());
        return ans;
      }

      // The action dictionary does not contain a semantic action for this specific type of node.
      // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic
      // action, we invoke it:
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, '_nonterminal', ctorName]);
          ans = this.doAction(semantics, nodeWrapper, actionFn, true);
          return ans;
        }
      }

      // Otherwise, we invoke the '_default' semantic action.
      globalActionStack.push([this, 'default action', ctorName]);
      ans = this.doAction(semantics, nodeWrapper, this.actionDict._default, true);
      return ans;
    } finally {
      globalActionStack.pop();
    }
  }

  // Invoke `actionFn` on the CST node that corresponds to `nodeWrapper`, in the context of
  // `semantics`. If `optPassChildrenAsArray` is truthy, `actionFn` will be called with a single
  // argument, which is an array of wrappers. Otherwise, the number of arguments to `actionFn` will
  // be equal to the number of children in the CST node.
  doAction(semantics, nodeWrapper, actionFn, optPassChildrenAsArray) {
    return optPassChildrenAsArray ?
        actionFn.call(nodeWrapper, nodeWrapper._children()) :
        actionFn.apply(nodeWrapper, nodeWrapper._children());
  }
}

Operation.prototype.typeName = 'operation';

// ----------------- Attribute -----------------

// Attributes are Operations whose results are memoized. This means that, for any given semantics,
// the semantic action for a CST node will be invoked no more than once.
class Attribute extends Operation {
  constructor(name, actionDict, builtInDefault) {
    super(name, [], actionDict, builtInDefault);
  }

  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key = semantics.attributeKeys[this.name];
    if (!node.hasOwnProperty(key)) {
      // The following is a super-send -- isn't JS beautiful? :/
      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key];
  }
}

Attribute.prototype.typeName = 'attribute';


// ----------------- Deferred initialization -----------------

util.awaitBuiltInRules(builtInRules => {
  const operationsAndAttributesGrammar = __webpack_require__(/*! ../dist/operations-and-attributes */ "./node_modules/ohm-js/dist/operations-and-attributes.js");
  initBuiltInSemantics(builtInRules);
  initPrototypeParser(operationsAndAttributesGrammar); // requires BuiltInSemantics
});

function initBuiltInSemantics(builtInRules) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };

  Semantics.BuiltInSemantics = Semantics
      .createSemantics(builtInRules, null)
      .addOperation('asIteration', {
        emptyListOf: actions.empty,
        nonemptyListOf: actions.nonEmpty,
        EmptyListOf: actions.empty,
        NonemptyListOf: actions.nonEmpty
      });
}

function initPrototypeParser(grammar) {
  prototypeGrammarSemantics = grammar.createSemantics().addOperation('parse', {
    AttributeSignature(name) {
      return {
        name: name.parse(),
        formals: []
      };
    },
    OperationSignature(name, optFormals) {
      return {
        name: name.parse(),
        formals: optFormals.parse()[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().parse();
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  prototypeGrammar = grammar;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Semantics;


/***/ }),

/***/ "./node_modules/ohm-js/src/Trace.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/Trace.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Unicode characters that are used in the `toString` output.
const BALLOT_X = '\u2717';
const CHECK_MARK = '\u2713';
const DOT_OPERATOR = '\u22C5';
const RIGHTWARDS_DOUBLE_ARROW = '\u21D2';
const SYMBOL_FOR_HORIZONTAL_TABULATION = '\u2409';
const SYMBOL_FOR_LINE_FEED = '\u240A';
const SYMBOL_FOR_CARRIAGE_RETURN = '\u240D';

const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};

function spaces(n) {
  return common.repeat(' ', n).join('');
}

// Return a string representation of a portion of `input` at offset `pos`.
// The result will contain exactly `len` characters.
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));

  // Pad the output if necessary.
  if (excerpt.length < len) {
    return excerpt + common.repeat(' ', len - excerpt.length).join('');
  }
  return excerpt;
}

function asEscapedString(obj) {
  if (typeof obj === 'string') {
    // Replace non-printable characters with visible symbols.
    return obj
        .replace(/ /g, DOT_OPERATOR)
        .replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)
        .replace(/\n/g, SYMBOL_FOR_LINE_FEED)
        .replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}

// ----------------- Trace -----------------

function Trace(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;

  this._flags = succeeded ? Flags.succeeded : 0;
}

// A value that can be returned from visitor functions to indicate that a
// node should not be recursed into.
Trace.prototype.SKIP = {};

Object.defineProperty(Trace.prototype, 'displayString', {
  get() { return this.expr.toDisplayString(); }
});

// For convenience, create a getter and setter for the boolean flags in `Flags`.
Object.keys(Flags).forEach(name => {
  const mask = Flags[name];
  Object.defineProperty(Trace.prototype, name, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});

Trace.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};

Trace.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace(
      this.input, this.pos, this.pos2, expr, this.succeeded, this.bindings, this.children);

  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};

// Record the trace information for the terminating condition of the LR loop.
Trace.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry =
      new Trace(this.input, this.pos, this.pos2, this.expr, false, [value], [ruleBodyTrace]);
  this.terminatingLREntry.terminatesLR = true;
};

// Recursively traverse this trace node and all its descendents, calling a visitor function
// for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property
// is a function to call before visiting the children of a node, and its 'exit' property is
// a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'
// function.
//
// The functions are called with three arguments: the Trace node, its parent Trace, and a number
// representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if
// specified, is the value to use for `this` when executing the visitor functions.
Trace.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === 'function') {
    visitor = {enter: visitor};
  }

  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach(child => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    // Don't visit the root node itself, only its children.
    this.children.forEach(c => { _walk(c, null, 0); });
  } else {
    _walk(this, null, 0);
  }
};

// Return a string representation of the trace.
// Sample:
//     12⋅+⋅2⋅*⋅3 ✓ exp ⇒  "12"
//     12⋅+⋅2⋅*⋅3   ✓ addExp (LR) ⇒  "12"
//     12⋅+⋅2⋅*⋅3       ✗ addExp_plus
Trace.prototype.toString = function() {
  const sb = new common.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    // Don't print anything for Alt nodes.
    if (ctorName === 'Alt') {
      return; // eslint-disable-line consistent-return
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(' (LR)');
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');
      sb.append(typeof contents === 'string' ? '"' + contents + '"' : contents);
    }
    sb.append('\n');
  });
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Trace;


/***/ }),

/***/ "./node_modules/ohm-js/src/common.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/common.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Helpers

const escapeStringFor = {};
for (let c = 0; c < 128; c++) {
  escapeStringFor[c] = String.fromCharCode(c);
}
escapeStringFor["'".charCodeAt(0)] = "\\'";
escapeStringFor['"'.charCodeAt(0)] = '\\"';
escapeStringFor['\\'.charCodeAt(0)] = '\\\\';
escapeStringFor['\b'.charCodeAt(0)] = '\\b';
escapeStringFor['\f'.charCodeAt(0)] = '\\f';
escapeStringFor['\n'.charCodeAt(0)] = '\\n';
escapeStringFor['\r'.charCodeAt(0)] = '\\r';
escapeStringFor['\t'.charCodeAt(0)] = '\\t';
escapeStringFor['\u000b'.charCodeAt(0)] = '\\v';

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.abstract = function(optMethodName) {
  const methodName = optMethodName || '';
  return function() {
    throw new Error(
        'this method ' + methodName + ' is abstract! ' +
      '(it has no implementation in class ' + this.constructor.name + ')');
  };
};

exports.assert = function(cond, message) {
  if (!cond) {
    throw new Error(message);
  }
};

// Define a lazily-computed, non-enumerable property named `propName`
// on the object `obj`. `getterFn` will be called to compute the value the
// first time the property is accessed.
exports.defineLazyProperty = function(obj, propName, getterFn) {
  let memo;
  Object.defineProperty(obj, propName, {
    get() {
      if (!memo) {
        memo = getterFn.call(this);
      }
      return memo;
    }
  });
};

exports.clone = function(obj) {
  if (obj) {
    return extend({}, obj);
  }
  return obj;
};

exports.extend = extend;

exports.repeatFn = function(fn, n) {
  const arr = [];
  while (n-- > 0) {
    arr.push(fn());
  }
  return arr;
};

exports.repeatStr = function(str, n) {
  return new Array(n + 1).join(str);
};

exports.repeat = function(x, n) {
  return exports.repeatFn(() => x, n);
};

exports.getDuplicates = function(array) {
  const duplicates = [];
  for (let idx = 0; idx < array.length; idx++) {
    const x = array[idx];
    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {
      duplicates.push(x);
    }
  }
  return duplicates;
};

exports.copyWithoutDuplicates = function(array) {
  const noDuplicates = [];
  array.forEach(entry => {
    if (noDuplicates.indexOf(entry) < 0) {
      noDuplicates.push(entry);
    }
  });
  return noDuplicates;
};

exports.isSyntactic = function(ruleName) {
  const firstChar = ruleName[0];
  return firstChar === firstChar.toUpperCase();
};

exports.isLexical = function(ruleName) {
  return !exports.isSyntactic(ruleName);
};

exports.padLeft = function(str, len, optChar) {
  const ch = optChar || ' ';
  if (str.length < len) {
    return exports.repeatStr(ch, len - str.length) + str;
  }
  return str;
};

// StringBuffer

exports.StringBuffer = function() {
  this.strings = [];
};

exports.StringBuffer.prototype.append = function(str) {
  this.strings.push(str);
};

exports.StringBuffer.prototype.contents = function() {
  return this.strings.join('');
};

// Character escaping and unescaping

exports.escapeChar = function(c, optDelim) {
  const charCode = c.charCodeAt(0);
  if ((c === '"' || c === "'") && optDelim && c !== optDelim) {
    return c;
  } else if (charCode < 128) {
    return escapeStringFor[charCode];
  } else if (128 <= charCode && charCode < 256) {
    return '\\x' + exports.padLeft(charCode.toString(16), 2, '0');
  } else {
    return '\\u' + exports.padLeft(charCode.toString(16), 4, '0');
  }
};

exports.unescapeChar = function(s) {
  if (s.charAt(0) === '\\') {
    switch (s.charAt(1)) {
      case 'b': return '\b';
      case 'f': return '\f';
      case 'n': return '\n';
      case 'r': return '\r';
      case 't': return '\t';
      case 'v': return '\v';
      case 'x': return String.fromCharCode(parseInt(s.substring(2, 4), 16));
      case 'u': return String.fromCharCode(parseInt(s.substring(2, 6), 16));
      default: return s.charAt(1);
    }
  } else {
    return s;
  }
};

// Helper for producing a description of an unknown object in a safe way.
// Especially useful for error messages where an unexpected type of object was encountered.
exports.unexpectedObjToString = function(obj) {
  if (obj == null) {
    return String(obj);
  }
  const baseToString = Object.prototype.toString.call(obj);
  try {
    let typeName;
    if (obj.constructor && obj.constructor.name) {
      typeName = obj.constructor.name;
    } else if (baseToString.indexOf('[object ') === 0) {
      typeName = baseToString.slice(8, -1); // Extract e.g. "Array" from "[object Array]".
    } else {
      typeName = typeof obj;
    }
    return typeName + ': ' + JSON.stringify(String(obj));
  } catch (e) {
    return baseToString;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/errors.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/errors.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}

// ----------------- errors about intervals -----------------

function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}

// ----------------- errors about grammars -----------------

// Grammar syntax error

function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, 'message', {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, 'shortMessage', {
    enumerable: true,
    get() {
      return 'Expected ' + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}

// Undeclared grammar

function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ?
      'Grammar ' + grammarName + ' is not declared in namespace ' + Namespace.toString(namespace) :
      'Undeclared grammar ' + grammarName;
  return createError(message, interval);
}

// Duplicate grammar declaration

function duplicateGrammarDeclaration(grammar, namespace) {
  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');
}

// ----------------- rules -----------------

// Undeclared rule

function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,
      optInterval);
}

// Cannot override undeclared rule

function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Cannot extend undeclared rule

function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Duplicate rule declaration

function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName +
      "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}

// Wrong number of parameters

function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
      'Wrong number of parameters for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      source);
}

// Wrong number of arguments

function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
      'Wrong number of arguments for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// Duplicate parameter names

function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(', '),
      source);
}

// Invalid parameter expression

function invalidParameter(ruleName, expr) {
  return createError(
      'Invalid parameter to rule ' + ruleName + ': ' + expr + ' has arity ' + expr.getArity() +
         ', but parameter expressions must have arity 1',
      expr.source);
}

// Application of syntactic rule from lexical rule

function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',
      applyExpr.source);
}

// Incorrect argument type

function incorrectArgumentType(expectedType, expr) {
  return createError('Incorrect argument type: expected ' + expectedType, expr.source);
}

// Multiple instances of the super-splice operator (`...`) in the rule body.

function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}

// ----------------- Kleene operators -----------------

function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ?
    applicationStack[applicationStack.length - 1].args :
    [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message =
    'Nullable expression ' + expr + " is not allowed inside '" +
    kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack
        .map(app => new pexprs.Apply(app.ruleName, app.args))
        .join('\n');
    message += '\nApplication stack (most recent application last):\n' + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}

// ----------------- arity -----------------

function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
      'Rule ' + ruleName + ' involves an alternation which has inconsistent arity ' +
          '(expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// ----------------- properties -----------------

function duplicatePropertyNames(duplicates) {
  return createError('Object pattern has duplicate property names: ' + duplicates.join(', '));
}

// ----------------- constructors -----------------

function invalidConstructorCall(grammar, ctorName, children) {
  return createError(
      'Attempt to invoke constructor ' + ctorName + ' with invalid or unexpected arguments');
}

// ----------------- convenience -----------------

function multipleErrors(errors) {
  const messages = errors.map(e => e.message);
  return createError(
      ['Errors:'].concat(messages).join('\n- '),
      errors[0].interval);
}

// ----------------- semantic -----------------

function missingSemanticAction(ctorName, name, type, stack) {
  let stackTrace = stack.slice(0, -1).map(info => {
    const ans = '  ' + info[0].name + ' > ' + info[1];
    return info.length === 3
        ? ans + " for '" + info[2] + "'"
        : ans;
  }).join('\n');
  stackTrace += '\n  ' + name + ' > ' + ctorName;

  const where = type + " '" + name + "'";
  const message = "Missing semantic action for '" + ctorName + "' in " + where + '\n' +
                'Action stack (most recent call last):\n' + stackTrace;

  const e = createError(message);
  e.name = 'missingSemanticAction';
  return e;
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  applicationOfSyntacticRuleFromLexicalContext,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  wrongNumberOfArguments,
  wrongNumberOfParameters,

  throwErrors(errors) {
    if (errors.length === 1) {
      throw errors[0];
    }
    if (errors.length > 1) {
      throw multipleErrors(errors);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/main.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/main.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global document, XMLHttpRequest */



// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Builder = __webpack_require__(/*! ./Builder */ "./node_modules/ohm-js/src/Builder.js");
const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const version = __webpack_require__(/*! ./version */ "./node_modules/ohm-js/src/version.js");

const isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/ohm-js/node_modules/is-buffer/index.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// The metagrammar, i.e. the grammar for Ohm grammars. Initialized at the
// bottom of this file because loading the grammar requires Ohm itself.
let ohmGrammar;

// An object which makes it possible to stub out the document API for testing.
let documentInterface = {
  querySelector(sel) { return document.querySelector(sel); },
  querySelectorAll(sel) { return document.querySelectorAll(sel); }
};

const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);

// Check if `obj` is a DOM element.
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

function isUndefined(obj) {
  return obj === void 0; // eslint-disable-line no-void
}

const MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

function isArrayLike(obj) {
  if (obj == null) {
    return false;
  }
  const length = obj.length;
  return typeof length === 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
}

// TODO: just use the jQuery thing
function load(url) {
  const req = new XMLHttpRequest();
  req.open('GET', url, false);
  try {
    req.send();
    if (req.status === 0 || req.status === 200) {
      return req.responseText;
    }
  } catch (e) {}
  throw new Error('unable to load url ' + url);
}

// Returns a Grammar instance (i.e., an object with a `match` method) for
// `tree`, which is the concrete syntax tree of a user-written grammar.
// The grammar will be assigned into `namespace` under the name of the grammar
// as specified in the source.
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;

  // A visitor that produces a Grammar instance from the CST.
  const helpers = metaGrammar.createSemantics().addOperation('visit', {
    Grammar(n, s, open, rs, close) {
      const grammarName = n.visit();
      decl = builder.newGrammar(grammarName, namespace);
      s.visit();
      rs.visit();
      const g = decl.build();
      g.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors.duplicateGrammarDeclaration(g, namespace);
      }
      namespace[grammarName] = g;
      return g;
    },

    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === 'null') {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },

    Rule_define(n, fs, d, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      // If there is no default start rule yet, set it now. This must be done before visiting
      // the body, because it might contain an inline rule definition.
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b.visit();
      const description = d.visit()[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description, source);
    },
    Rule_override(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];

      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);

      overriding = true;
      const body = b.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      const body = b.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      const args = terms.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();

      // Check if the super-splice operator (`...`) appears in the terms.
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);

        // Ensure it appears no more than once.
        afterTerms.forEach(t => {
          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);
        });

        return new pexprs.Splice(
            decl.superGrammar, currentRuleName, beforeTerms, afterTerms).withSource(this.source);
      } else {
        return builder.alt.apply(builder, args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },

    Params(opointy, ps, cpointy) {
      return ps.visit();
    },

    Alt(seqs) {
      const args = seqs.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },

    TopLevelTerm_inline(b, n) {
      const inlineRuleName = currentRuleName + '_' + n.visit();
      const body = b.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration =
          !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map(formal => builder.app(formal));
      return builder.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },

    Seq(expr) {
      return builder.seq.apply(builder, expr.visit()).withSource(this.source);
    },

    Iter_star(x, _) {
      return builder.star(x.visit()).withSource(this.source);
    },
    Iter_plus(x, _) {
      return builder.plus(x.visit()).withSource(this.source);
    },
    Iter_opt(x, _) {
      return builder.opt(x.visit()).withSource(this.source);
    },

    Pred_not(_, x) {
      return builder.not(x.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x) {
      return builder.lookahead(x.visit()).withSource(this.source);
    },

    Lex_lex(_, x) {
      return builder.lex(x.visit()).withSource(this.source);
    },

    Base_application(rule, ps) {
      return builder.app(rule.visit(), ps.visit()[0] || []).withSource(this.source);
    },
    Base_range(from, _, to) {
      return builder.range(from.visit(), to.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x, close) {
      return x.visit();
    },

    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },

    caseName(_, space1, n, space2, end) {
      return n.visit();
    },

    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {},
    nameRest(expr) {},

    terminal(open, cs, close) {
      return cs.visit().join('');
    },

    oneCharTerminal(open, c, close) {
      return c.visit();
    },

    terminalChar(_) {
      return common.unescapeChar(this.sourceString);
    },

    escapeChar(_) {
      return this.sourceString;
    },

    NonemptyListOf(x, _, xs) {
      return [x.visit()].concat(xs.visit());
    },
    EmptyListOf() {
      return [];
    },

    _terminal() {
      return this.primitiveValue;
    }
  });
  return helpers(match).visit();
}

function compileAndLoad(source, namespace) {
  const m = ohmGrammar.match(source, 'Grammars');
  if (m.failed()) {
    throw errors.grammarSyntaxError(m);
  }
  return buildGrammar(m, namespace);
}

// Return the contents of a script element, fetching it via XHR if necessary.
function getScriptElementContents(el) {
  if (!isElement(el)) {
    throw new TypeError('Expected a DOM Node, got ' + common.unexpectedObjToString(el));
  }
  if (el.type !== 'text/ohm-js') {
    throw new Error('Expected a script tag with type="text/ohm-js", got ' + el);
  }
  return el.getAttribute('src') ? load(el.getAttribute('src')) : el.innerHTML;
}

function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);

  // Ensure that the source contained no more than one grammar definition.
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error('Missing grammar definition');
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
        util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) +
        'Found more than one grammar definition -- use ohm.grammars() instead.');
  }
  return ns[grammarNames[0]]; // Return the one and only grammar.
}

function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== 'string') {
    // For convenience, detect Node.js Buffer objects and automatically call toString().
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
          'Expected string as first argument, got ' + common.unexpectedObjToString(source));
    }
  }
  compileAndLoad(source, ns);
  return ns;
}

function grammarFromScriptElement(optNode) {
  let node = optNode;
  if (isUndefined(node)) {
    const nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
    if (nodeList.length !== 1) {
      throw new Error(
          'Expected exactly one script tag with type="text/ohm-js", found ' + nodeList.length);
    }
    node = nodeList[0];
  }
  return grammar(getScriptElementContents(node));
}

function grammarsFromScriptElements(optNodeOrNodeList) {
  // Simple case: the argument is a DOM node.
  if (isElement(optNodeOrNodeList)) {
    return grammars(optNodeOrNodeList);
  }
  // Otherwise, it must be either undefined or a NodeList.
  let nodeList = optNodeOrNodeList;
  if (isUndefined(nodeList)) {
    // Find all script elements with type="text/ohm-js".
    nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
  } else if (typeof nodeList === 'string' || (!isElement(nodeList) && !isArrayLike(nodeList))) {
    throw new TypeError('Expected a Node, NodeList, or Array, but got ' + nodeList);
  }
  const ns = Namespace.createNamespace();
  for (let i = 0; i < nodeList.length; ++i) {
    // Copy the new grammars into `ns` to keep the namespace flat.
    common.extend(ns, grammars(getScriptElementContents(nodeList[i]), ns));
  }
  return ns;
}

function makeRecipe(recipe) {
  if (typeof recipe === 'function') {
    return recipe.call(new Builder());
  } else {
    if (typeof recipe === 'string') {
      // stringified JSON recipe
      recipe = JSON.parse(recipe);
    }
    return (new Builder()).fromRecipe(recipe);
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

// Stuff that users should know about
module.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null, // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util,
  extras: __webpack_require__(/*! ../extras */ "./node_modules/ohm-js/extras/index.js"),
  version
};

// Stuff for testing, etc.
module.exports._buildGrammar = buildGrammar;
module.exports._setDocumentInterfaceForTesting = function(doc) { documentInterface = doc; };

// Late initialization for stuff that is bootstrapped.

Grammar.BuiltInRules = __webpack_require__(/*! ../dist/built-in-rules */ "./node_modules/ohm-js/dist/built-in-rules.js");
util.announceBuiltInRules(Grammar.BuiltInRules);

module.exports.ohmGrammar = ohmGrammar = __webpack_require__(/*! ../dist/ohm-grammar */ "./node_modules/ohm-js/dist/ohm-grammar.js");
Grammar.initApplicationParser(ohmGrammar, buildGrammar);


/***/ }),

/***/ "./node_modules/ohm-js/src/nodes.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/nodes.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

class Node {
  constructor(grammar, ctorName, matchLength) {
    this.grammar = grammar;
    this.ctorName = ctorName;
    this.matchLength = matchLength;
  }

  numChildren() {
    return this.children ? this.children.length : 0;
  }

  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }

  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }

  hasChildren() {
    return this.numChildren() > 1;
  }

  hasNoChildren() {
    return !this.hasChildren();
  }

  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
          'cannot get only child of a node of type ' + this.ctorName +
          ' (it has ' + this.numChildren() + ' children)');
    } else {
      return this.firstChild();
    }
  }

  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get first child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(0);
    }
  }

  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get last child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }

  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childBefore() called w/ an argument that is not a child');
    } else if (childIdx === 0) {
      throw new Error('cannot get child before first child');
    } else {
      return this.childAt(childIdx - 1);
    }
  }

  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childAfter() called w/ an argument that is not a child');
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error('cannot get child after last child');
    } else {
      return this.childAt(childIdx + 1);
    }
  }

  isTerminal() {
    return false;
  }

  isNonterminal() {
    return false;
  }

  isIteration() {
    return false;
  }

  isOptional() {
    return false;
  }

  toJSON() {
    return {[this.ctorName]: this.children};
  }
}

// Terminals

class TerminalNode extends Node {
  constructor(grammar, value) {
    const matchLength = value ? value.length : 0;
    super(grammar, '_terminal', matchLength);
    this.primitiveValue = value;
  }

  isTerminal() {
    return true;
  }

  toJSON() {
    return {[this.ctorName]: this.primitiveValue};
  }
}

// Nonterminals

class NonterminalNode extends Node {
  constructor(grammar, ruleName, children, childOffsets, matchLength) {
    super(grammar, ruleName, matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
  }

  isNonterminal() {
    return true;
  }

  isLexical() {
    return common.isLexical(this.ctorName);
  }

  isSyntactic() {
    return common.isSyntactic(this.ctorName);
  }
}

// Iterations

class IterationNode extends Node {
  constructor(grammar, children, childOffsets, matchLength, isOptional) {
    super(grammar, '_iter', matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }

  isIteration() {
    return true;
  }

  isOptional() {
    return this.optional;
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  Node,
  TerminalNode,
  NonterminalNode,
  IterationNode
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js":
/*!************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Return true if we should skip spaces preceding this expression in a syntactic context.
*/
pexprs.PExpr.prototype.allowsSkippingPrecedingSpace = common.abstract(
    'allowsSkippingPrecedingSpace'
);

/*
  Generally, these are all first-order expressions and (with the exception of Apply)
  directly read from the input stream.
*/
pexprs.any.allowsSkippingPrecedingSpace =
pexprs.end.allowsSkippingPrecedingSpace =
pexprs.Apply.prototype.allowsSkippingPrecedingSpace =
pexprs.Terminal.prototype.allowsSkippingPrecedingSpace =
pexprs.Range.prototype.allowsSkippingPrecedingSpace =
pexprs.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};

/*
  Higher-order expressions that don't directly consume input.
*/
pexprs.Alt.prototype.allowsSkippingPrecedingSpace =
pexprs.Iter.prototype.allowsSkippingPrecedingSpace =
pexprs.Lex.prototype.allowsSkippingPrecedingSpace =
pexprs.Lookahead.prototype.allowsSkippingPrecedingSpace =
pexprs.Not.prototype.allowsSkippingPrecedingSpace =
pexprs.Param.prototype.allowsSkippingPrecedingSpace =
pexprs.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

let BuiltInRules;

util.awaitBuiltInRules(g => { BuiltInRules = g; });

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

let lexifyCount;

pexprs.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.PExpr.prototype._assertAllApplicationsAreValid = common.abstract(
    '_assertAllApplicationsAreValid'
);

pexprs.any._assertAllApplicationsAreValid =
pexprs.end._assertAllApplicationsAreValid =
pexprs.Terminal.prototype._assertAllApplicationsAreValid =
pexprs.Range.prototype._assertAllApplicationsAreValid =
pexprs.Param.prototype._assertAllApplicationsAreValid =
pexprs.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  // no-op
};

pexprs.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
  lexifyCount--;
};

pexprs.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Iter.prototype._assertAllApplicationsAreValid =
pexprs.Not.prototype._assertAllApplicationsAreValid =
pexprs.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  const ruleInfo = grammar.rules[this.ruleName];

  // Make sure that the rule exists...
  if (!ruleInfo) {
    throw errors.undeclaredRule(this.ruleName, grammar.name, this.source);
  }

  // ...and that this application is allowed
  if (common.isSyntactic(this.ruleName) && (!common.isSyntactic(ruleName) || lexifyCount > 0)) {
    throw errors.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }

  // ...and that this application has the correct number of arguments
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }

  // ...and that all of the argument expressions only have valid applications and have arity 1.
  const self = this;
  this.args.forEach(arg => {
    arg._assertAllApplicationsAreValid(ruleName, grammar);
    if (arg.getArity() !== 1) {
      throw errors.invalidParameter(self.ruleName, arg);
    }
  });

  // Extra checks for "special" applications

  // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.
  if (BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive) {
    if (!(this.args[0] instanceof pexprs.Terminal)) {
      throw errors.incorrectArgumentType('a Terminal (e.g. \"abc\")', this.args[0]);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertChoicesHaveUniformArity = common.abstract(
    'assertChoicesHaveUniformArity'
);

pexprs.any.assertChoicesHaveUniformArity =
pexprs.end.assertChoicesHaveUniformArity =
pexprs.Terminal.prototype.assertChoicesHaveUniformArity =
pexprs.Range.prototype.assertChoicesHaveUniformArity =
pexprs.Param.prototype.assertChoicesHaveUniformArity =
pexprs.Lex.prototype.assertChoicesHaveUniformArity =
pexprs.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op
};

pexprs.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};

pexprs.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // Extend is a special case of Alt that's guaranteed to have exactly two
  // cases: [extensions, origBody].
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};

pexprs.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};

pexprs.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op (not required b/c the nested expr doesn't show up in the CST)
};

pexprs.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // The arities of the parameter expressions is required to be 1 by
  // `assertAllApplicationsAreValid()`.
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertIteratedExprsAreNotNullable = common.abstract(
    'assertIteratedExprsAreNotNullable'
);

pexprs.any.assertIteratedExprsAreNotNullable =
pexprs.end.assertIteratedExprsAreNotNullable =
pexprs.Terminal.prototype.assertIteratedExprsAreNotNullable =
pexprs.Range.prototype.assertIteratedExprsAreNotNullable =
pexprs.Param.prototype.assertIteratedExprsAreNotNullable =
pexprs.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // no-op
};

pexprs.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // Note: this is the implementation of this method for `Star` and `Plus` expressions.
  // It is overridden for `Opt` below.
  this.expr.assertIteratedExprsAreNotNullable(grammar);
  if (this.expr.isNullable(grammar)) {
    throw errors.kleeneExprHasNullableOperand(this, []);
  }
};

pexprs.Opt.prototype.assertIteratedExprsAreNotNullable =
pexprs.Not.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lookahead.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.expr.assertIteratedExprsAreNotNullable(grammar);
};

pexprs.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.args.forEach(arg => {
    arg.assertIteratedExprsAreNotNullable(grammar);
  });
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-check.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-check.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.check = common.abstract('check');

pexprs.any.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.end.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === undefined;
};

pexprs.Terminal.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === this.obj;
};

pexprs.Range.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === typeof this.from;
};

pexprs.Param.prototype.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.Alt.prototype.check = function(grammar, vals) {
  for (let i = 0; i < this.terms.length; i++) {
    const term = this.terms[i];
    if (term.check(grammar, vals)) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.check = function(grammar, vals) {
  let pos = 0;
  for (let i = 0; i < this.factors.length; i++) {
    const factor = this.factors[i];
    if (factor.check(grammar, vals.slice(pos))) {
      pos += factor.getArity();
    } else {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.check = function(grammar, vals) {
  const arity = this.getArity();
  const columns = vals.slice(0, arity);
  if (columns.length !== arity) {
    return false;
  }
  const rowCount = columns[0].length;
  let i;
  for (i = 1; i < arity; i++) {
    if (columns[i].length !== rowCount) {
      return false;
    }
  }

  for (i = 0; i < rowCount; i++) {
    const row = [];
    for (let j = 0; j < arity; j++) {
      row.push(columns[j][i]);
    }
    if (!this.expr.check(grammar, row)) {
      return false;
    }
  }

  return true;
};

pexprs.Not.prototype.check = function(grammar, vals) {
  return true;
};

pexprs.Lookahead.prototype.check =
pexprs.Lex.prototype.check = function(grammar, vals) {
  return this.expr.check(grammar, vals);
};

pexprs.Apply.prototype.check = function(grammar, vals) {
  if (!(vals[0] instanceof nodes.Node &&
        vals[0].grammar === grammar &&
        vals[0].ctorName === this.ruleName)) {
    return false;
  }

  // TODO: think about *not* doing the following checks, i.e., trusting that the rule
  // was correctly constructed.
  const ruleNode = vals[0];
  const body = grammar.rules[this.ruleName].body;
  return body.check(grammar, ruleNode.children) && ruleNode.numChildren() === body.getArity();
};

pexprs.UnicodeChar.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === 'string';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-eval.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-eval.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const TerminalNode = nodes.TerminalNode;
const NonterminalNode = nodes.NonterminalNode;
const IterationNode = nodes.IterationNode;

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should
  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures
  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific
  data structures to be "secrets" of that class, which is good for modularity.)

  The contract of this method is as follows:
  * When the return value is `true`,
    - the state object will have `expr.getArity()` more bindings than it did before the call.
  * When the return value is `false`,
    - the state object may have more bindings than it did before the call, and
    - its input stream's position may be anywhere.

  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state
  object's bindings nor its input stream's position will change if the expression fails to match.
*/
pexprs.PExpr.prototype.eval = common.abstract('eval'); // function(state) { ... }

pexprs.any.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.end.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode(state.grammar, undefined), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Terminal.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode(state.grammar, this.obj), origPos);
    return true;
  }
};

pexprs.Range.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.from <= ch && ch <= this.to) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};

pexprs.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};

pexprs.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }

  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];

    const endOffset =
        lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
        new IterationNode(state.grammar, cols[idx], colOffsets[idx], matchLength, isOptional));
    state._bindingOffsets.push(offset);
  }
  return true;
};

pexprs.Not.prototype.eval = function(state) {
  /*
    TODO:
    - Right now we're just throwing away all of the failures that happen inside a `not`, and
      recording `this` as a failed expression.
    - Double negation should be equivalent to lookahead, but that's not the case right now wrt
      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce
      a failure for 'foo' instead.
  */

  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();

  const ans = state.eval(this.expr);

  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }

  inputStream.pos = origPos;
  return true;
};

pexprs.Lookahead.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};

pexprs.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);

  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    // This rule is already active at this position, i.e., it is left-recursive.
    return app.handleCycle(state);
  }

  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];

  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};

pexprs.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const currentLeftRecursion = posInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];

  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    // We already know about this left recursion, but it's possible there are "involved
    // applications" that we don't already know about, so...
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    // New left recursion detected! Memoize a failure to try to get a seed parse.
    memoRec = posInfo.memoize(
        memoKey,
        {matchLength: 0, examinedLength: 0, value: false, rightmostFailureOffset: -1});
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};

pexprs.Apply.prototype.reallyEval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const body = ruleInfo.body;
  const description = ruleInfo.description;

  state.enterApplication(origPosInfo, this);

  if (description) {
    state.pushFailuresInfo();
  }

  // Reset the input stream's examinedLength property so that we can track
  // the examined length of this particular application.
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;

  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;

  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec); // updates origPosInfo's maxExaminedLength
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    // This application is not involved in left recursion, so it's ok to memoize it.
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;

  if (description) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }

  // Record trace information in the memo table, so that it is available if the memoized result
  // is used later.
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }

  // Fix the input stream's examinedLength -- it should be the maximum examined length
  // across all applications, not just this one.
  inputStream.examinedLength = Math.max(inputStream.examinedLength, origInputStreamExaminedLength);

  state.exitApplication(origPosInfo, value);

  return succeeded;
};

pexprs.Apply.prototype.evalOnce = function(expr, state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;

  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    return new NonterminalNode(
        state.grammar, this.ruleName, bindings, offsets, inputStream.pos - origPos);
  } else {
    return false;
  }
};

pexprs.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }

  const inputStream = state.inputStream;

  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();

    if (state.isTracing()) {
      // Before evaluating the body again, add a trace node for this application to the memo entry.
      // Its only child is a copy of the trace node from `newValue`, which will always be the last
      // element in `state.trace`.
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace(
          state.input, origPos, inputStream.pos, this, true, [newValue], [seedTrace.clone()]);
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1); // Drop the trace for the old seed.
    }
  }
  if (state.isTracing()) {
    // The last entry is for an unused result -- pop it and save it in the "real" entry.
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};

pexprs.UnicodeChar.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-generateExample.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-generateExample.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Helpers
// --------------------------------------------------------------------

function flatten(listOfLists) {
  return Array.prototype.concat.apply([], listOfLists);
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.generateExample = common.abstract('generateExample');

function categorizeExamples(examples) {
  // A list of rules that the system needs examples of, in order to generate an example
  //   for the current rule
  let examplesNeeded = examples.filter(example => example.hasOwnProperty('examplesNeeded'))
      .map(example => example.examplesNeeded);

  examplesNeeded = flatten(examplesNeeded);

  const uniqueExamplesNeeded = {};
  for (let i = 0; i < examplesNeeded.length; i++) {
    const currentExampleNeeded = examplesNeeded[i];
    uniqueExamplesNeeded[currentExampleNeeded] = true;
  }
  examplesNeeded = Object.keys(uniqueExamplesNeeded);

  // A list of successfully generated examples
  const successfulExamples = examples.filter(example => example.hasOwnProperty('value'))
      .map(item => item.value);

  // This flag returns true if the system cannot generate the rule it is currently
  //   attempting to generate, regardless of whether or not it has the examples it needs.
  //   Currently, this is only used in overriding generators to prevent the system from
  //   generating examples for certain rules (e.g. 'ident').
  const needHelp = examples.some(item => item.needHelp);

  return {
    examplesNeeded,
    successfulExamples,
    needHelp
  };
}

pexprs.any.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return {value: String.fromCharCode(Math.floor(Math.random() * 255))};
};

// Assumes that terminal's object is always a string
pexprs.Terminal.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: this.obj};
};

pexprs.Range.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  const rangeSize = this.to.charCodeAt(0) - this.from.charCodeAt(0);
  return {value: String.fromCharCode(
      this.from.charCodeAt(0) + Math.floor(rangeSize * Math.random())
  )};
};

pexprs.Param.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return actuals[this.index].generateExample(grammar, examples, inSyntacticContext, actuals);
};

pexprs.Alt.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  // items -> termExamples
  const termExamples = this.terms.map(term => {
    return term.generateExample(grammar, examples, inSyntacticContext, actuals);
  });

  const categorizedExamples = categorizeExamples(termExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // Alt can contain both an example and a request for examples
  if (successfulExamples.length > 0) {
    const i = Math.floor(Math.random() * successfulExamples.length);
    ans.value = successfulExamples[i];
  }
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }
  ans.needHelp = needHelp;

  return ans;
};

pexprs.Seq.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const factorExamples = this.factors.map(factor => {
    return factor.generateExample(grammar, examples, inSyntacticContext, actuals);
  });
  const categorizedExamples = categorizeExamples(factorExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // In a Seq, all pieces must succeed in order to have a successful example.
  if (examplesNeeded.length > 0 || needHelp) {
    ans.examplesNeeded = examplesNeeded;
    ans.needHelp = needHelp;
  } else {
    ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  }

  return ans;
};

pexprs.Iter.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const rangeTimes = Math.min(this.maxNumMatches - this.minNumMatches, 3);
  const numTimes = Math.floor(Math.random() * (rangeTimes + 1) + this.minNumMatches);
  const items = [];

  for (let i = 0; i < numTimes; i++) {
    items.push(this.expr.generateExample(grammar, examples, inSyntacticContext, actuals));
  }

  const categorizedExamples = categorizeExamples(items);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;

  const ans = {};

  // It's always either one or the other.
  // TODO: instead of ' ', call 'spaces.generateExample()'
  ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }

  return ans;
};

// Right now, 'Not' and 'Lookahead' generate nothing and assume that whatever follows will
//   work according to the encoded constraints.
pexprs.Not.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lookahead.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lex.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return this.expr.generateExample(grammar, examples, false, actuals);
};

pexprs.Apply.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const ans = {};

  const ruleName = this.substituteParams(actuals).toString();

  if (!examples.hasOwnProperty(ruleName)) {
    ans.examplesNeeded = [ruleName];
  } else {
    const relevantExamples = examples[ruleName];
    const i = Math.floor(Math.random() * relevantExamples.length);
    ans.value = relevantExamples[i];
  }

  return ans;
};

pexprs.UnicodeChar.prototype.generateExample = function(
    grammar, examples, inSyntacticContext, actuals) {
  let char;
  switch (this.category) {
    case 'Lu': char = 'Á'; break;
    case 'Ll': char = 'ŏ'; break;
    case 'Lt': char = 'ǅ'; break;
    case 'Lm': char = 'ˮ'; break;
    case 'Lo': char = 'ƻ'; break;

    case 'Nl': char = 'ↂ'; break;
    case 'Nd': char = '½'; break;

    case 'Mn': char = '\u0487'; break;
    case 'Mc': char = 'ि'; break;

    case 'Pc': char = '⁀'; break;

    case 'Zs': char = '\u2001'; break;

    case 'L': char = 'Á'; break;
    case 'Ltmo': char = 'ǅ'; break;
  }
  return {value: char}; // 💩
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-getArity.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-getArity.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.getArity = common.abstract('getArity');

pexprs.any.getArity =
pexprs.end.getArity =
pexprs.Terminal.prototype.getArity =
pexprs.Range.prototype.getArity =
pexprs.Param.prototype.getArity =
pexprs.Apply.prototype.getArity =
pexprs.UnicodeChar.prototype.getArity = function() {
  return 1;
};

pexprs.Alt.prototype.getArity = function() {
  // This is ok b/c all terms must have the same arity -- this property is
  // checked by the Grammar constructor.
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};

pexprs.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};

pexprs.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};

pexprs.Not.prototype.getArity = function() {
  return 0;
};

pexprs.Lookahead.prototype.getArity =
pexprs.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-introduceParams.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-introduceParams.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Called at grammar creation time to rewrite a rule body, replacing each reference to a formal
  parameter with a `Param` node. Returns a PExpr -- either a new one, or the original one if
  it was modified in place.
*/
pexprs.PExpr.prototype.introduceParams = common.abstract('introduceParams');

pexprs.any.introduceParams =
pexprs.end.introduceParams =
pexprs.Terminal.prototype.introduceParams =
pexprs.Range.prototype.introduceParams =
pexprs.Param.prototype.introduceParams =
pexprs.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};

pexprs.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};

pexprs.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};

pexprs.Iter.prototype.introduceParams =
pexprs.Not.prototype.introduceParams =
pexprs.Lookahead.prototype.introduceParams =
pexprs.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};

pexprs.Apply.prototype.introduceParams = function(formals) {
  const index = formals.indexOf(this.ruleName);
  if (index >= 0) {
    if (this.args.length > 0) {
      // TODO: Should this be supported? See issue #64.
      throw new Error('Parameterized rules cannot be passed as arguments to another rule.');
    }
    return new pexprs.Param(index).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-isNullable.js":
/*!******************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-isNullable.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns `true` if this parsing expression may accept without consuming any input.
pexprs.PExpr.prototype.isNullable = function(grammar) {
  return this._isNullable(grammar, Object.create(null));
};

pexprs.PExpr.prototype._isNullable = common.abstract('_isNullable');

pexprs.any._isNullable =
pexprs.Range.prototype._isNullable =
pexprs.Param.prototype._isNullable =
pexprs.Plus.prototype._isNullable =
pexprs.UnicodeChar.prototype._isNullable = function(grammar, memo) {
  return false;
};

pexprs.end._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Terminal.prototype._isNullable = function(grammar, memo) {
  if (typeof this.obj === 'string') {
    // This is an over-simplification: it's only correct if the input is a string. If it's an array
    // or an object, then the empty string parsing expression is not nullable.
    return this.obj === '';
  } else {
    return false;
  }
};

pexprs.Alt.prototype._isNullable = function(grammar, memo) {
  return this.terms.length === 0 ||
      this.terms.some(term => term._isNullable(grammar, memo));
};

pexprs.Seq.prototype._isNullable = function(grammar, memo) {
  return this.factors.every(factor => factor._isNullable(grammar, memo));
};

pexprs.Star.prototype._isNullable =
pexprs.Opt.prototype._isNullable =
pexprs.Not.prototype._isNullable =
pexprs.Lookahead.prototype._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Lex.prototype._isNullable = function(grammar, memo) {
  return this.expr._isNullable(grammar, memo);
};

pexprs.Apply.prototype._isNullable = function(grammar, memo) {
  const key = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key)) {
    const body = grammar.rules[this.ruleName].body;
    const inlined = body.substituteParams(this.args);
    memo[key] = false; // Prevent infinite recursion for recursive rules.
    memo[key] = inlined._isNullable(grammar, memo);
  }
  return memo[key];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-outputRecipe.js":
/*!********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-outputRecipe.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.outputRecipe = common.abstract('outputRecipe');

pexprs.any.outputRecipe = function(formals, grammarInterval) {
  return ['any', getMetaInfo(this, grammarInterval)];
};

pexprs.end.outputRecipe = function(formals, grammarInterval) {
  return ['end', getMetaInfo(this, grammarInterval)];
};

pexprs.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'terminal',
    getMetaInfo(this, grammarInterval),
    this.obj
  ];
};

pexprs.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'range',
    getMetaInfo(this, grammarInterval),
    this.from,
    this.to
  ];
};

pexprs.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'param',
    getMetaInfo(this, grammarInterval),
    this.index
  ];
};

pexprs.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'alt',
    getMetaInfo(this, grammarInterval)
  ].concat(this.terms.map(term => term.outputRecipe(formals, grammarInterval)));
};

pexprs.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0]; // [extension, original]
  return extension.outputRecipe(formals, grammarInterval);
};

pexprs.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    'splice',
    getMetaInfo(this, grammarInterval),
    beforeTerms.map(term => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map(term => term.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'seq',
    getMetaInfo(this, grammarInterval)
  ].concat(this.factors.map(factor => factor.outputRecipe(formals, grammarInterval)));
};

pexprs.Star.prototype.outputRecipe =
pexprs.Plus.prototype.outputRecipe =
pexprs.Opt.prototype.outputRecipe =
pexprs.Not.prototype.outputRecipe =
pexprs.Lookahead.prototype.outputRecipe =
pexprs.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};

pexprs.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'app',
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map(arg => arg.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'unicodeChar',
    getMetaInfo(this, grammarInterval),
    this.category
  ];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-substituteParams.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-substituteParams.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a PExpr that results from recursively replacing every formal parameter (i.e., instance
  of `Param`) inside this PExpr with its actual value from `actuals` (an Array).

  The receiver must not be modified; a new PExpr must be returned if any replacement is necessary.
*/
// function(actuals) { ... }
pexprs.PExpr.prototype.substituteParams = common.abstract('substituteParams');

pexprs.any.substituteParams =
pexprs.end.substituteParams =
pexprs.Terminal.prototype.substituteParams =
pexprs.Range.prototype.substituteParams =
pexprs.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};

pexprs.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};

pexprs.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs.Alt(
      this.terms.map(term => term.substituteParams(actuals)));
};

pexprs.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs.Seq(
      this.factors.map(factor => factor.substituteParams(actuals)));
};

pexprs.Iter.prototype.substituteParams =
pexprs.Not.prototype.substituteParams =
pexprs.Lookahead.prototype.substituteParams =
pexprs.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};

pexprs.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    // Avoid making a copy of this application, as an optimization
    return this;
  } else {
    const args = this.args.map(arg => arg.substituteParams(actuals));
    return new pexprs.Apply(this.ruleName, args);
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toArgumentNameList.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const {copyWithoutDuplicates} = common;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}

function resolveDuplicatedNames(argumentNameList) {
  // `count` is used to record the number of times each argument name occurs in the list,
  // this is useful for checking duplicated argument name. It maps argument names to ints.
  const count = Object.create(null);
  argumentNameList.forEach(argName => {
    count[argName] = (count[argName] || 0) + 1;
  });

  // Append subscripts ('_1', '_2', ...) to duplicate argument names.
  Object.keys(count).forEach(dupArgName => {
    if (count[dupArgName] <= 1) {
      return;
    }

    // This name shows up more than once, so add subscripts.
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + '_' + subscript++;
      }
    });
  });
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a list of strings that will be used as the default argument names for its receiver
  (a pexpr) in a semantic action. This is used exclusively by the Semantics Editor.

  `firstArgIndex` is the 1-based index of the first argument name that will be generated for this
  pexpr. It enables us to name arguments positionally, e.g., if the second argument is a
  non-alphanumeric terminal like "+", it will be named '$2'.

  `noDupCheck` is true if the caller of `toArgumentNameList` is not a top level caller. It enables
  us to avoid nested duplication subscripts appending, e.g., '_1_1', '_1_2', by only checking
  duplicates at the top level.

  Here is a more elaborate example that illustrates how this method works:
  `(a "+" b).toArgumentNameList(1)` evaluates to `['a', '$2', 'b']` with the following recursive
  calls:

    (a).toArgumentNameList(1) -> ['a'],
    ("+").toArgumentNameList(2) -> ['$2'],
    (b).toArgumentNameList(3) -> ['b']

  Notes:
  * This method must only be called on well-formed expressions, e.g., the receiver must
    not have any Alt sub-expressions with inconsistent arities.
  * e.getArity() === e.toArgumentNameList(1).length
*/
// function(firstArgIndex, noDupCheck) { ... }
pexprs.PExpr.prototype.toArgumentNameList = common.abstract('toArgumentNameList');

pexprs.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['any'];
};

pexprs.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['end'];
};

pexprs.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === 'string' && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    // If this terminal is a valid suffix for a JS identifier, just prepend it with '_'
    return ['_' + this.obj];
  } else {
    // Otherwise, name it positionally.
    return ['$' + firstArgIndex];
  }
};

pexprs.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + '_to_' + this.to;
  // If the `argName` is not valid then try to prepend a `_`.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '_' + argName;
  }
  // If the `argName` still not valid after prepending a `_`, then name it positionally.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '$' + firstArgIndex;
  }
  return [argName];
};

pexprs.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // `termArgNameLists` is an array of arrays where each row is the
  // argument name list that corresponds to a term in this alternation.
  const termArgNameLists = this.terms.map(term => term.toArgumentNameList(firstArgIndex, true));

  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join('_or_'));
  }

  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // Generate the argument name list, without worrying about duplicates.
  let argumentNameList = [];
  this.factors.forEach(factor => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);

    // Shift the firstArgIndex to take this factor's argument names into account.
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck)
      .map(exprArgumentString => exprArgumentString[exprArgumentString.length - 1] === 's' ?
          exprArgumentString + 'es' :
          exprArgumentString + 's');
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(argName => {
    return 'opt' + argName[0].toUpperCase() + argName.slice(1);
  });
};

pexprs.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};

pexprs.Lookahead.prototype.toArgumentNameList =
pexprs.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};

pexprs.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};

pexprs.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['$' + firstArgIndex];
};

pexprs.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['param' + this.index];
};

// "Value pexprs" (Value, Str, Arr, Obj) are going away soon, so we don't worry about them here.


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toDisplayString.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toDisplayString.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns a string representing the PExpr, for use as a UI label, etc.
pexprs.PExpr.prototype.toDisplayString = common.abstract('toDisplayString');

pexprs.Alt.prototype.toDisplayString =
pexprs.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return '[' + this.constructor.name + ']';
};

pexprs.any.toDisplayString =
pexprs.end.toDisplayString =
pexprs.Iter.prototype.toDisplayString =
pexprs.Not.prototype.toDisplayString =
pexprs.Lookahead.prototype.toDisplayString =
pexprs.Lex.prototype.toDisplayString =
pexprs.Terminal.prototype.toDisplayString =
pexprs.Range.prototype.toDisplayString =
pexprs.Param.prototype.toDisplayString = function() {
  return this.toString();
};

pexprs.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toDisplayString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toDisplayString = function() {
  return 'Unicode [' + this.category + '] character';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toFailure.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toFailure.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.toFailure = common.abstract('toFailure');

pexprs.any.toFailure = function(grammar) {
  return new Failure(this, 'any object', 'description');
};

pexprs.end.toFailure = function(grammar) {
  return new Failure(this, 'end of input', 'description');
};

pexprs.Terminal.prototype.toFailure = function(grammar) {
  return new Failure(this, this.obj, 'string');
};

pexprs.Range.prototype.toFailure = function(grammar) {
  // TODO: come up with something better
  return new Failure(this, JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');
};

pexprs.Not.prototype.toFailure = function(grammar) {
  const description = this.expr === pexprs.any ?
      'nothing' :
      'not ' + this.expr.toFailure(grammar);
  return new Failure(this, description, 'description');
};

pexprs.Lookahead.prototype.toFailure = function(grammar) {
  return this.expr.toFailure(grammar);
};

pexprs.Apply.prototype.toFailure = function(grammar) {
  let description = grammar.rules[this.ruleName].description;
  if (!description) {
    const article = (/^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a');
    description = article + ' ' + this.ruleName;
  }
  return new Failure(this, description, 'description');
};

pexprs.UnicodeChar.prototype.toFailure = function(grammar) {
  return new Failure(this, 'a Unicode [' + this.category + '] character', 'description');
};

pexprs.Alt.prototype.toFailure = function(grammar) {
  const fs = this.terms.map(t => t.toFailure(grammar));
  const description = '(' + fs.join(' or ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Seq.prototype.toFailure = function(grammar) {
  const fs = this.factors.map(f => f.toFailure(grammar));
  const description = '(' + fs.join(' ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Iter.prototype.toFailure = function(grammar) {
  const description = '(' + this.expr.toFailure(grammar) + this.operator + ')';
  return new Failure(this, description, 'description');
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toString.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toString.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.
  Note that this is not an iff (<==>): e.g.,
  (~"b" "a").toString() !== ("a").toString(), even though
  ~"b" "a" and "a" are interchangeable in any grammar,
  both in terms of the languages they accept and their arities.
*/
pexprs.PExpr.prototype.toString = common.abstract('toString');

pexprs.any.toString = function() {
  return 'any';
};

pexprs.end.toString = function() {
  return 'end';
};

pexprs.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};

pexprs.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);
};

pexprs.Param.prototype.toString = function() {
  return '$' + this.index;
};

pexprs.Lex.prototype.toString = function() {
  return '#(' + this.expr.toString() + ')';
};

pexprs.Alt.prototype.toString = function() {
  return this.terms.length === 1 ?
    this.terms[0].toString() :
    '(' + this.terms.map(term => term.toString()).join(' | ') + ')';
};

pexprs.Seq.prototype.toString = function() {
  return this.factors.length === 1 ?
    this.factors[0].toString() :
    '(' + this.factors.map(factor => factor.toString()).join(' ') + ')';
};

pexprs.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};

pexprs.Not.prototype.toString = function() {
  return '~' + this.expr;
};

pexprs.Lookahead.prototype.toString = function() {
  return '&' + this.expr;
};

pexprs.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toString = function() {
  return '\\p{' + this.category + '}';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const UnicodeCategories = __webpack_require__(/*! ../third_party/UnicodeCategories */ "./node_modules/ohm-js/third_party/UnicodeCategories.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// General stuff

class PExpr {
  constructor() {
    if (this.constructor === PExpr) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }

  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}

// Any

const any = Object.create(PExpr.prototype);

// End

const end = Object.create(PExpr.prototype);

// Terminals

class Terminal extends PExpr {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}

// Ranges

class Range extends PExpr {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
  }
}

// Parameters

class Param extends PExpr {
  constructor(index) {
    super();
    this.index = index;
  }
}

// Alternation

class Alt extends PExpr {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}

// Extend is an implementation detail of rule extension

class Extend extends Alt {
  constructor(superGrammar, name, body) {
    const origBody = superGrammar.rules[name].body;
    super([body, origBody]);

    this.superGrammar = superGrammar;
    this.name = name;
    this.body = body;
  }
}

// Splice is an implementation detail of rule overriding with the `...` operator.
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);

    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}

// Sequences

class Seq extends PExpr {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}

// Iterators and optionals

class Iter extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Star extends Iter {}
class Plus extends Iter {}
class Opt extends Iter {}

Star.prototype.operator = '*';
Plus.prototype.operator = '+';
Opt.prototype.operator = '?';

Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;

Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;

// Predicates

class Not extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Lookahead extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// "Lexification"

class Lex extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// Rule application

class Apply extends PExpr {
  constructor(ruleName, args=[]) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }

  isSyntactic() {
    return common.isSyntactic(this.ruleName);
  }

  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, '_memoKey', {value: this.toString()});
    }
    return this._memoKey;
  }
}

// Unicode character

class UnicodeChar extends PExpr {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.PExpr = PExpr;
exports.any = any;
exports.end = end;
exports.Terminal = Terminal;
exports.Range = Range;
exports.Param = Param;
exports.Alt = Alt;
exports.Extend = Extend;
exports.Splice = Splice;
exports.Seq = Seq;
exports.Iter = Iter;
exports.Star = Star;
exports.Plus = Plus;
exports.Opt = Opt;
exports.Not = Not;
exports.Lookahead = Lookahead;
exports.Lex = Lex;
exports.Apply = Apply;
exports.UnicodeChar = UnicodeChar;

// --------------------------------------------------------------------
// Extensions
// --------------------------------------------------------------------

__webpack_require__(/*! ./pexprs-allowsSkippingPrecedingSpace */ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js");
__webpack_require__(/*! ./pexprs-assertAllApplicationsAreValid */ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js");
__webpack_require__(/*! ./pexprs-assertChoicesHaveUniformArity */ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js");
__webpack_require__(/*! ./pexprs-assertIteratedExprsAreNotNullable */ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js");
__webpack_require__(/*! ./pexprs-check */ "./node_modules/ohm-js/src/pexprs-check.js");
__webpack_require__(/*! ./pexprs-eval */ "./node_modules/ohm-js/src/pexprs-eval.js");
__webpack_require__(/*! ./pexprs-getArity */ "./node_modules/ohm-js/src/pexprs-getArity.js");
__webpack_require__(/*! ./pexprs-generateExample */ "./node_modules/ohm-js/src/pexprs-generateExample.js");
__webpack_require__(/*! ./pexprs-outputRecipe */ "./node_modules/ohm-js/src/pexprs-outputRecipe.js");
__webpack_require__(/*! ./pexprs-introduceParams */ "./node_modules/ohm-js/src/pexprs-introduceParams.js");
__webpack_require__(/*! ./pexprs-isNullable */ "./node_modules/ohm-js/src/pexprs-isNullable.js");
__webpack_require__(/*! ./pexprs-substituteParams */ "./node_modules/ohm-js/src/pexprs-substituteParams.js");
__webpack_require__(/*! ./pexprs-toDisplayString */ "./node_modules/ohm-js/src/pexprs-toDisplayString.js");
__webpack_require__(/*! ./pexprs-toArgumentNameList */ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js");
__webpack_require__(/*! ./pexprs-toFailure */ "./node_modules/ohm-js/src/pexprs-toFailure.js");
__webpack_require__(/*! ./pexprs-toString */ "./node_modules/ohm-js/src/pexprs-toString.js");


/***/ }),

/***/ "./node_modules/ohm-js/src/util.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/util.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Given an array of numbers `arr`, return an array of the numbers as strings,
// right-justified and padded to the same length.
function padNumbersToEqualLength(arr) {
  let maxLen = 0;
  const strings = arr.map(n => {
    const str = n.toString();
    maxLen = Math.max(maxLen, str.length);
    return str;
  });
  return strings.map(s => common.padLeft(s, maxLen));
}

// Produce a new string that would be the result of copying the contents
// of the string `src` onto `dest` at offset `offest`.
function strcpy(dest, src, offset) {
  const origDestLen = dest.length;
  const start = dest.slice(0, offset);
  const end = dest.slice(offset + src.length);
  return (start + src + end).substr(0, origDestLen);
}

// Casts the underlying lineAndCol object to a formatted message string,
// highlighting `ranges`.
function lineAndColumnToMessage(...ranges) {
  const lineAndCol = this;
  const offset = lineAndCol.offset;
  const repeatStr = common.repeatStr;

  const sb = new common.StringBuffer();
  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\n');

  // An array of the previous, current, and next line numbers as strings of equal length.
  const lineNumbers = padNumbersToEqualLength([
    lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
    lineAndCol.lineNum,
    lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
  ]);

  // Helper for appending formatting input lines to the buffer.
  const appendLine = (num, content, prefix) => {
    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\n');
  };

  // Include the previous line for context if possible.
  if (lineAndCol.prevLine != null) {
    appendLine(0, lineAndCol.prevLine, '  ');
  }
  // Line that the error occurred on.
  appendLine(1, lineAndCol.line, '> ');

  // Build up the line that points to the offset and possible indicates one or more ranges.
  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.
  const lineLen = lineAndCol.line.length;
  let indicationLine = repeatStr(' ', lineLen + 1);
  for (let i = 0; i < ranges.length; ++i) {
    let startIdx = ranges[i][0];
    let endIdx = ranges[i][1];
    common.assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');

    const lineStartOffset = offset - lineAndCol.colNum + 1;
    startIdx = Math.max(0, startIdx - lineStartOffset);
    endIdx = Math.min(endIdx - lineStartOffset, lineLen);

    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);
  }
  const gutterWidth = 2 + lineNumbers[1].length + 3;
  sb.append(repeatStr(' ', gutterWidth));
  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);
  sb.append(indicationLine.replace(/ +$/, '') + '\n');

  // Include the next line for context if possible.
  if (lineAndCol.nextLine != null) {
    appendLine(2, lineAndCol.nextLine, '  ');
  }
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

let builtInRulesCallbacks = [];

// Since Grammar.BuiltInRules is bootstrapped, most of Ohm can't directly depend it.
// This function allows modules that do depend on the built-in rules to register a callback
// that will be called later in the initialization process.
exports.awaitBuiltInRules = cb => {
  builtInRulesCallbacks.push(cb);
};

exports.announceBuiltInRules = grammar => {
  builtInRulesCallbacks.forEach(cb => {
    cb(grammar);
  });
  builtInRulesCallbacks = null;
};

// Return an object with the line and column information for the given
// offset in `str`.
exports.getLineAndColumn = (str, offset) => {
  let lineNum = 1;
  let colNum = 1;

  let currOffset = 0;
  let lineStartOffset = 0;

  let nextLine = null;
  let prevLine = null;
  let prevLineStartOffset = -1;

  while (currOffset < offset) {
    const c = str.charAt(currOffset++);
    if (c === '\n') {
      lineNum++;
      colNum = 1;
      prevLineStartOffset = lineStartOffset;
      lineStartOffset = currOffset;
    } else if (c !== '\r') {
      colNum++;
    }
  }

  // Find the end of the target line.
  let lineEndOffset = str.indexOf('\n', lineStartOffset);
  if (lineEndOffset === -1) {
    lineEndOffset = str.length;
  } else {
    // Get the next line.
    const nextLineEndOffset = str.indexOf('\n', lineEndOffset + 1);
    nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset)
                                        : str.slice(lineEndOffset, nextLineEndOffset);
    // Strip leading and trailing EOL char(s).
    nextLine = nextLine.replace(/^\r?\n/, '').replace(/\r$/, '');
  }

  // Get the previous line.
  if (prevLineStartOffset >= 0) {
    prevLine = str.slice(prevLineStartOffset, lineStartOffset)
        .replace(/\r?\n$/, ''); // Strip trailing EOL char(s).
  }

  // Get the target line, stripping a trailing carriage return if necessary.
  const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, '');

  return {
    offset,
    lineNum,
    colNum,
    line,
    prevLine,
    nextLine,
    toString: lineAndColumnToMessage
  };
};

// Return a nicely-formatted string describing the line and column for the
// given offset in `str` highlighting `ranges`.
exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
  return exports.getLineAndColumn(str, offset).toString(...ranges);
};

exports.uniqueId = (() => {
  let idCounter = 0;
  return prefix => '' + prefix + idCounter++;
})();


/***/ }),

/***/ "./node_modules/ohm-js/src/version.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/version.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global __GLOBAL_OHM_VERSION__ */



// When running under Node, read the version from package.json. For the browser,
// use a special global variable defined in the build process (see webpack.config.js).
module.exports = typeof __GLOBAL_OHM_VERSION__ === 'string'
    ? __GLOBAL_OHM_VERSION__
    : __webpack_require__(/*! ../package.json */ "./node_modules/ohm-js/package.json").version;


/***/ }),

/***/ "./node_modules/ohm-js/third_party/UnicodeCategories.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/third_party/UnicodeCategories.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Based on https://github.com/mathiasbynens/unicode-9.0.0.
// These are just categories that are used in ES5/ES2015.
// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.
module.exports = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,

  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,

  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,

  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,

  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,

  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};


/***/ }),

/***/ "./node_modules/util-extend/extend.js":
/*!********************************************!*\
  !*** ./node_modules/util-extend/extend.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = extend;
function extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || typeof add !== 'object') return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}


/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./plugins/merriam.js":
/*!****************************!*\
  !*** ./plugins/merriam.js ***!
  \****************************/
/*! exports provided: merriam, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriam", function() { return merriam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriam; });
const merriam = {
    name: "MerriamAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    cache: null,
    cacheNextItem: null,
    currentResponseItemIndex: -1,
    src: null,
    get: async function(prerequisite, arg){
        if(arg){
            if(!this.cache){
                throw Error("No result has been fetched");
            }
            if(arg == "next"){
                let results = this.cache.results;
                this.currentResponseItemIndex += 1;
                if(this.currentResponseItemIndex >= results.length){
                    this.currentResponseItemIndex = 0;
                }
                this.response = this.cache.results[this.currentResponseItemIndex];
                // put the result in the next item cache
                this.cacheNextItem = this.cache.results[this.currentResponseItemIndex];
                return JSON.stringify(this.response, null, '\t');
            }
            // here we assume that the arg is a key in the next item cache
            this.response = this.cacheNextItem[arg];
            return this.response;
        }
        const payload = parsePrerequisite(prerequisite);
        const params = {
            "method": "POST",
            "headers": {
                "content-type": "application/json"
            },
            "body": JSON.stringify(payload)
        };
        let response = await fetch(this.src, params);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            this.cache = json;
            return JSON.stringify(this.response, null, '\t');
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    }
}


let parsePrerequisite = (p) => {
    let pList = p.split(";");
    let payload = {};
    pList.forEach((item) => {
        let key = item.split(":")[0];
        let value = item.replace(`${key}:`, "");
        switch(key){
        case "fields":
            payload["fields"] = value.split(',');
            break;
        case "weights":
            let weights = {};
            value.split(",").forEach((w) => {
                let [w_name, w_value] = w.split(":");
                weights[w_name] = Number(w_value);
            });
            payload["weights"] = weights;
            break;
        case "doc_ids":
            payload["doc_ids"] = value.split(",");
            break;
        case "limit":
            payload["limit"] = Number(value);
            break;
        }
    });
    return payload;
}





/***/ }),

/***/ "./plugins/plugins.js":
/*!****************************!*\
  !*** ./plugins/plugins.js ***!
  \****************************/
/*! exports provided: plugins, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugins", function() { return plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return plugins; });
/* harmony import */ var _testAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./testAPI.js */ "./plugins/testAPI.js");
/* harmony import */ var _merriam_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./merriam.js */ "./plugins/merriam.js");



const plugins = {
    "MerriamAPI": _merriam_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    "TestAPI": _testAPI_js__WEBPACK_IMPORTED_MODULE_0__["default"]
}




/***/ }),

/***/ "./plugins/testAPI.js":
/*!****************************!*\
  !*** ./plugins/testAPI.js ***!
  \****************************/
/*! exports provided: test, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test", function() { return test; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return test; });
const test = {
    name: "TestAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    src: null,
    get: async function(prerequisite, key){
        if(key){
            if(!this.response){
                throw Error("No result has been fetched");
            }
            return this.response[key];
        }
        let src = this.src;
        if(prerequisite){
            src = src + "/" + prerequisite;
        }
        let response = await fetch(src);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            return JSON.stringify(json);
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    },
};




/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9FeGVjdXRpb25TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9BdWRpby5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9DYXJkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvRHJhd2luZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0ZpZWxkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9QYXJ0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dvcmxkU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9jbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9lcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9oYW5kSW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3V0aWxzL21lcnJpYW1JbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9zZXJpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVyLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvQXJlYVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9BdWRpb1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Ccm93c2VyVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0J1dHRvblZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9DYXJkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0ZpZWxkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0hhbG8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9JbWFnZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9QYXJ0Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1Jlc291cmNlVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1N0YWNrVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1dpbmRvd1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Xb3JsZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9jb250ZXh0bWVudS9Db250ZXh0TWVudS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2NvbnRleHRtZW51L0NvbnRleHRNZW51SXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvQ29sb3JQaWNrZXJUb29sLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9Db2xvcldoZWVsV2lkZ2V0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9EcmF3aW5nVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvRXJhc2VyVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvUGVuY2lsVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JDdXN0b21MaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JMb2NhdGlvbkluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvck1lc3Nlbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yUHJvcEl0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclByb3BMaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JTdWJwYXJ0c1BhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclRhYi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvdXRpbHMvc3VicGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvQ2FyZFJvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL25hdmlnYXRvci9OYXZpZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvU3RhY2tSb3cuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvV3JhcHBlZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL2Rpc3QvYnVpbHQtaW4tcnVsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9kaXN0L29obS1ncmFtbWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZGlzdC9vcGVyYXRpb25zLWFuZC1hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZXh0cmFzL1Zpc2l0b3JGYW1pbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvc2VtYW50aWNzLXRvQVNULmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0Nhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0ZhaWx1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9HcmFtbWFyRGVjbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnB1dFN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL01hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvTmFtZXNwYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1Bvc0luZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvU2VtYW50aWNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1RyYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9ub2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWNoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1ldmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1nZW5lcmF0ZUV4YW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWdldEFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1pbnRyb2R1Y2VQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWlzTnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLW91dHB1dFJlY2lwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtc3Vic3RpdHV0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9Bcmd1bWVudE5hbWVMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy10b0Rpc3BsYXlTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLXRvRmFpbHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3RoaXJkX3BhcnR5L1VuaWNvZGVDYXRlZ29yaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsLWV4dGVuZC9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL21lcnJpYW0uanMiLCJ3ZWJwYWNrOi8vLy4vcGx1Z2lucy9wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL3BsdWdpbnMvdGVzdEFQSS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUVBQWM7QUFDL0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELFdBQVc7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxXQUFXOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LEVBQUU7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFL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QUFDQSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixVQUFVLG9DQUFvQyxXQUFXO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN0UkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QjtBQUNFO0FBS007O0FBRXJDLHFCQUFxQixnREFBSTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRkFBa0I7QUFDMUIsUUFBUSwwRkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQzs7Ozs7Ozs7Ozs7OztBQzVJRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZCOzs7QUFHN0IseUJBQXlCLGdEQUFJO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsb0NBQW9DLFdBQVc7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JVRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx3REFBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2hKRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWMsY0FBYyxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBLHFGQUFxRixpQkFBaUIsWUFBWTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDbE1GO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdEQUF3RCxjQUFjO0FBQ3RFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQU1FOzs7Ozs7Ozs7Ozs7O0FDcFJGO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN4R0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFNO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1FOzs7Ozs7Ozs7Ozs7O0FDN0NGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDM2VGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPRTs7Ozs7Ozs7Ozs7OztBQzlmRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q2hDO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsd0RBQVMsQ0FBQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRLE1BQU0sWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2hYRjtBQUFBO0FBQUE7QUFBQTtBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9EQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFELHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDcFRGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RDtBQUNlOztBQUV0RSxnREFBZ0QsbUVBQVc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQsYUFBYTtBQUNiLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFLGFBQWE7QUFDYixvREFBb0QsTUFBTTtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvQ0FBb0M7QUFDdkcsa0VBQWtFLGdEQUFnRDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvQ0FBb0M7QUFDdkcsa0VBQWtFLGdEQUFnRDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsb0RBQVE7QUFDakM7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RCw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDL1JGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9EQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFB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Q3hMRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sSUFBSSxPQUFPLElBQUksT0FBTyxJQUFJLE9BQU87QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZLElBQUksWUFBWSxJQUFJLFlBQVksSUFBSSxnQkFBZ0I7QUFDbkk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DLDZCQUE2QixRQUFRO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFlBQVk7QUFDckMsNkJBQTZCLFlBQVk7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3BhRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dDO0FBQ0c7QUFDQTtBQUNVOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIscURBQVE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUMsc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDeldGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN2UEY7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNyUEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVDO0FBQ1U7QUFDRTtBQUNFO0FBQ0k7QUFDWjtBQUM3Qzs7QUFFQTtBQUNBLDJDQUEyQyxxREFBUztBQUNwRCxrREFBa0QsMERBQWM7QUFDaEUsbURBQW1ELDREQUFnQjtBQUNuRSxpREFBaUQsMkRBQWU7QUFDaEUsZ0RBQWdELDhEQUFrQjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELEtBQUssTUFBTSxLQUFLO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEOztBQUVBLHVCQUF1Qix1REFBUztBQUNoQyxvQ0FBb0MsdURBQVM7QUFDN0MsU0FBUztBQUNULG9DQUFvQyx1REFBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxzQkFBc0IsZUFBZSxnQkFBZ0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM2dCRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxLQUFLO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDM1ZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUU7QUFDSzs7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QTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDeEZGO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsbUJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3pRRjtBQUFBO0FBQUE7QUFBQTtBQUFpRDs7QUFFakQ7QUFDQSxpREFBaUQsMERBQWM7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2pKRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUN5RDtBQUNaO0FBQ2lDOztBQUU5RSxxREFBcUQsOERBQWtCOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkYsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG9EQUFRO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLG9CQUFvQjtBQUNqRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDcExGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQztBQUNLO0FBQ047QUFDRjs7QUFFbkM7QUFDQSw4Q0FBOEMsb0RBQVE7QUFDdEQsNkNBQTZDLG1EQUFPO0FBQ3BELDZDQUE2Qyx1REFBVzs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsb0RBQVE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG9CQUFvQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQzlQRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9EQUFRO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLG9CQUFvQjtBQUNqRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDckxGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDBCQUEwQixvREFBUTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RCxxQ0FBcUMscUJBQXFCO0FBQzFELDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2xORjtBQUFBO0FBQUE7QUFBQTtBQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsVUFBVSxVQUFVLGtDQUFrQyxVQUFVO0FBQzlHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLGlFQUFpRSxVQUFVO0FBQy9HOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLEVBQUUsT0FBTztBQUNyQyxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVMsSUFBSSxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVMsSUFBSSxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNB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Q0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxpQ0FBaUMsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOzs7QUFNRTs7Ozs7Ozs7Ozs7O0FDOXBDRixVQUFVLG1CQUFPLENBQUMsNkNBQUk7QUFDdEIsNENBQTRDLHdCQUF3Qiw4b0JBQThvQixFQUFFLDJCQUEyQixtQkFBbUIseUJBQXlCLHlDQUF5Qyx5QkFBeUIsU0FBUyx5QkFBeUIsc0JBQXNCLHlCQUF5QixtQ0FBbUMsMEJBQTBCLHVCQUF1QiwyQkFBMkIsU0FBUywyQkFBMkIscUJBQXFCLDJCQUEyQixxQkFBcUIsMkJBQTJCLHdDQUF3QywyQkFBMkIsd0JBQXdCLDJCQUEyQixpQ0FBaUMsMkJBQTJCLGtDQUFrQywyQkFBMkIsU0FBUywyQkFBMkIsdUJBQXVCLDJCQUEyQixvQkFBb0IsMkJBQTJCLGdDQUFnQywyQkFBMkIsNkJBQTZCLDJCQUEyQixTQUFTLDJCQUEyQiw2QkFBNkIsMkJBQTJCLGNBQWMsMkJBQTJCLGNBQWMsMkJBQTJCLDBCQUEwQiwyQkFBMkIsY0FBYywyQkFBMkIsb0NBQW9DLDJCQUEyQiw2QkFBNkIsMkJBQTJCLFdBQVcsMkJBQTJCLGFBQWEsMkJBQTJCLFNBQVMsMkJBQTJCLFdBQVcsMkJBQTJCLGNBQWMsMkJBQTJCLGlDQUFpQywyQkFBMkIsNkJBQTZCLDJCQUEyQix1QkFBdUIsMkJBQTJCLDZCQUE2QiwyQkFBMkIsU0FBUywyQkFBMkIsNkJBQTZCLDJCQUEyQixjQUFjLDJCQUEyQixjQUFjLDJCQUEyQiwwQkFBMEIsMkJBQTJCLGNBQWMsMkJBQTJCLG9DQUFvQywyQkFBMkIsNkJBQTZCLDJCQUEyQixXQUFXLDJCQUEyQixhQUFhLDJCQUEyQixTQUFTLDJCQUEyQixXQUFXLDJCQUEyQixjQUFjLDJCQUEyQixpQ0FBaUMsMkJBQTJCLDZCQUE2QiwyQkFBMkIsR0FBRzs7Ozs7Ozs7Ozs7O0FDRHJtRyxVQUFVLG1CQUFPLENBQUMsNkNBQUk7QUFDdEIsNENBQTRDLGVBQWUsMEVBQTBFLFlBQVksaTNDQUFpM0MsZzRDQUFnNEMsRUFBRSx3QkFBd0Isc0JBQXNCLHdCQUF3QixrQkFBa0IseUJBQXlCLFNBQVMseUJBQXlCLHNDQUFzQyx5QkFBeUIsaUJBQWlCLHlCQUF5QixTQUFTLHlCQUF5QixxQkFBcUIseUJBQXlCLFNBQVMseUJBQXlCLGtDQUFrQyx5QkFBeUIsR0FBRyxZQUFZLHlCQUF5QixTQUFTLHlCQUF5QiwwQkFBMEIseUJBQXlCLEdBQUcsK0JBQStCLDBCQUEwQixpQkFBaUIsMkJBQTJCLGNBQWMsMkJBQTJCLGVBQWUsMkJBQTJCLHdDQUF3QywyQkFBMkIsaUJBQWlCLDJCQUEyQixTQUFTLDJCQUEyQixxQkFBcUIsMkJBQTJCLFNBQVMsMkJBQTJCLHdCQUF3QiwyQkFBMkIsU0FBUywyQkFBMkIsK0JBQStCLDJCQUEyQixjQUFjLDJCQUEyQiw2Q0FBNkMsMkJBQTJCLGlCQUFpQiwyQkFBMkIsU0FBUywyQkFBMkIscUJBQXFCLDJCQUEyQixTQUFTLDJCQUEyQiw2QkFBNkIsMkJBQTJCLGVBQWUsMkJBQTJCLG1EQUFtRCwyQkFBMkIsaUJBQWlCLDJCQUEyQixTQUFTLDJCQUEyQixxQkFBcUIsMkJBQTJCLFNBQVMsMkJBQTJCLDZCQUE2QiwyQkFBMkIsZUFBZSwyQkFBMkIsb0NBQW9DLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDJCQUEyQiwyQ0FBMkMsMkJBQTJCLGlCQUFpQiwyQkFBMkIsU0FBUywyQkFBMkIsY0FBYywyQkFBMkIsZUFBZSwyQkFBMkIsMkJBQTJCLDJCQUEyQixpQ0FBaUMsMkJBQTJCLDJDQUEyQywyQkFBMkIsaUJBQWlCLDJCQUEyQixTQUFTLDJCQUEyQixtQkFBbUIsMkJBQTJCLDRDQUE0QywyQkFBMkIsaUJBQWlCLDJCQUEyQixTQUFTLDJCQUEyQixtQ0FBbUMsMkJBQTJCLDJDQUEyQywyQkFBMkIsaUJBQWlCLDJCQUEyQixTQUFTLDJCQUEyQixjQUFjLDJCQUEyQixlQUFlLDJCQUEyQiwyQkFBMkIsMkJBQTJCLHlDQUF5QywyQkFBMkIsd0RBQXdELDJCQUEyQixzQkFBc0IsMkJBQTJCLDJDQUEyQywyQkFBMkIsaUJBQWlCLDJCQUEyQixTQUFTLDJCQUEyQixnREFBZ0QsMkJBQTJCLDJDQUEyQywyQkFBMkIsaUJBQWlCLDJCQUEyQixjQUFjLDJCQUEyQixjQUFjLDJCQUEyQixtQkFBbUIsMkJBQTJCLDBCQUEwQiwyQkFBMkIscUJBQXFCLDJCQUEyQiw0QkFBNEIsMkJBQTJCLGlCQUFpQiwyQkFBMkIsY0FBYywyQkFBMkIsY0FBYywyQkFBMkIsbUJBQW1CLDJCQUEyQix3QkFBd0IsMkJBQTJCLHFCQUFxQiwyQkFBMkIseUJBQXlCLDJCQUEyQixpQkFBaUIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsd0JBQXdCLDJCQUEyQiwwQkFBMEIsMkJBQTJCLGtCQUFrQiwyQkFBMkIsU0FBUywyQkFBMkIscUNBQXFDLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLHlCQUF5QiwyQkFBMkIsK0JBQStCLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLHlCQUF5QiwyQkFBMkIsOEJBQThCLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLHlCQUF5QiwyQkFBMkIsMEJBQTBCLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLHlCQUF5QiwyQkFBMkIseUJBQXlCLDJCQUEyQix3QkFBd0IsMkJBQTJCLG9DQUFvQywyQkFBMkIsaUJBQWlCLDJCQUEyQixjQUFjLDJCQUEyQixjQUFjLDJCQUEyQix5Q0FBeUMsMkJBQTJCLGlCQUFpQiwyQkFBMkIsY0FBYywyQkFBMkIsY0FBYywyQkFBMkIsK0JBQStCLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLHdCQUF3QiwyQkFBMkIsOEJBQThCLDJCQUEyQixrQ0FBa0MsMkJBQTJCLGlCQUFpQiwyQkFBMkIsY0FBYywyQkFBMkIsY0FBYywyQkFBMkIsK0JBQStCLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLHVCQUF1QiwyQkFBMkIsNENBQTRDLDJCQUEyQixpQkFBaUIsMkJBQTJCLFNBQVMsMkJBQTJCLHFCQUFxQiwyQkFBMkIsU0FBUywyQkFBMkIsdUJBQXVCLDJCQUEyQixTQUFTLDJCQUEyQixTQUFTLDJCQUEyQixTQUFTLDJCQUEyQixTQUFTLDJCQUEyQiwrQkFBK0IsMkJBQTJCLG9CQUFvQiwyQkFBMkIsb0JBQW9CLDJCQUEyQixtQ0FBbUMsNEJBQTRCLGlCQUFpQiw0QkFBNEIsU0FBUyw0QkFBNEIsb0NBQW9DLDZCQUE2QixlQUFlLDZCQUE2QixvREFBb0QsNkJBQTZCLGlCQUFpQiw2QkFBNkIseUNBQXlDLDZCQUE2QixpQkFBaUIsNkJBQTZCLGNBQWMsNkJBQTZCLGNBQWMsNkJBQTZCLHdCQUF3Qiw2QkFBNkIsMEJBQTBCLDRCQUE0QixpQkFBaUIsNEJBQTRCLFNBQVMsMkJBQTJCLGdDQUFnQyw0QkFBNEIsMEJBQTBCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDJDQUEyQyw2QkFBNkIsaUNBQWlDLDZCQUE2QixjQUFjLDZCQUE2QixjQUFjLDZCQUE2QixrQ0FBa0MsNkJBQTZCLG1DQUFtQyw2QkFBNkIsa0JBQWtCLDZCQUE2QixTQUFTLDZCQUE2QixTQUFTLDZCQUE2QixjQUFjLDZCQUE2QixlQUFlLDZCQUE2QixvQ0FBb0MsNkJBQTZCLGlCQUFpQiw2QkFBNkIsY0FBYyw2QkFBNkIsZ0JBQWdCLDZCQUE2QixTQUFTLDZCQUE2QixTQUFTLDZCQUE2QixjQUFjLDZCQUE2QixnQkFBZ0IsNkJBQTZCLHVCQUF1Qiw2QkFBNkIscUJBQXFCLDZCQUE2QixTQUFTLDZCQUE2QixTQUFTLDZCQUE2QixjQUFjLDZCQUE2QixnQkFBZ0IsNkJBQTZCLHVCQUF1Qiw2QkFBNkIsY0FBYyw2QkFBNkIscUJBQXFCLDZCQUE2QixjQUFjLDZCQUE2QixHQUFHLHlCQUF5Qiw2QkFBNkIscUJBQXFCLDZCQUE2QixTQUFTLDZCQUE2QiwwQkFBMEIsNkJBQTZCLFNBQVMsNkJBQTZCLDBDQUEwQyw2QkFBNkIsaUJBQWlCLDZCQUE2QixjQUFjLDZCQUE2QixjQUFjLDZCQUE2QixzQ0FBc0MsNkJBQTZCLGlCQUFpQiw2QkFBNkIsY0FBYyw2QkFBNkIsY0FBYyw2QkFBNkIsa0NBQWtDLDZCQUE2Qiw0QkFBNEIsNkJBQTZCLG1DQUFtQyw2QkFBNkIsaUJBQWlCLDZCQUE2QixjQUFjLDZCQUE2QixnQkFBZ0IsNkJBQTZCLFNBQVMsNkJBQTZCLGtDQUFrQyw2QkFBNkIsc0NBQXNDLDZCQUE2QixpQkFBaUIsNkJBQTZCLGNBQWMsNkJBQTZCLGVBQWUsNkJBQTZCLGlDQUFpQyw2QkFBNkIsbUNBQW1DLDZCQUE2QixpQkFBaUIsNkJBQTZCLFNBQVMsNkJBQTZCLDBCQUEwQiw2QkFBNkIsU0FBUyw2QkFBNkIsY0FBYyw2QkFBNkIsZ0JBQWdCLDZCQUE2QixjQUFjLDZCQUE2QixnQkFBZ0IsNkJBQTZCLGNBQWMsNkJBQTZCLGdCQUFnQiw2QkFBNkIsZ0RBQWdELDZCQUE2QixzQkFBc0IsNkJBQTZCLDhDQUE4Qyw2QkFBNkIsc0JBQXNCLDZCQUE2Qiw4Q0FBOEMsNkJBQTZCLHNCQUFzQiw2QkFBNkIsMkNBQTJDLDZCQUE2QixzQkFBc0IsNkJBQTZCLDBDQUEwQyw2QkFBNkIsc0JBQXNCLDZCQUE2QixnREFBZ0QsNkJBQTZCLHNCQUFzQiw2QkFBNkIscUNBQXFDLDZCQUE2QixzQkFBc0IsNkJBQTZCLCtDQUErQyw2QkFBNkIsaUJBQWlCLDZCQUE2QixjQUFjLDZCQUE2QixnQkFBZ0IsNkJBQTZCLHdCQUF3Qiw2QkFBNkIsd0JBQXdCLDZCQUE2Qix3QkFBd0IsNkJBQTZCLG9EQUFvRCw2QkFBNkIsaUJBQWlCLDZCQUE2QixjQUFjLDZCQUE2QixnQkFBZ0IsNkJBQTZCLHdCQUF3Qiw2QkFBNkIsMENBQTBDLDZCQUE2QixpQ0FBaUMsNkJBQTZCLFNBQVMsNkJBQTZCLG9DQUFvQyw2QkFBNkIsc0NBQXNDLDZCQUE2QixzQ0FBc0MsNkJBQTZCLG9DQUFvQyw2QkFBNkIsbUNBQW1DLDZCQUE2Qix5Q0FBeUMsNkJBQTZCLDhCQUE4Qiw2QkFBNkIsd0NBQXdDLDZCQUE2QixpREFBaUQsNkJBQTZCLGlCQUFpQiw2QkFBNkIsZ0RBQWdELDZCQUE2QixpQkFBaUIsNkJBQTZCLGNBQWMsNkJBQTZCLGdCQUFnQiw2QkFBNkIsU0FBUyw2QkFBNkIsU0FBUyw2QkFBNkIsY0FBYyw2QkFBNkIsZ0JBQWdCLDZCQUE2QiwyQkFBMkIsNkJBQTZCLFNBQVMsNkJBQTZCLGNBQWMsNkJBQTZCLGVBQWUsNkJBQTZCLDhDQUE4Qyw2QkFBNkIsaUJBQWlCLDZCQUE2QixjQUFjLDZCQUE2QixnQkFBZ0IsNkJBQTZCLFNBQVMsNkJBQTZCLFNBQVMsNkJBQTZCLGNBQWMsNkJBQTZCLGdCQUFnQiw2QkFBNkIsMEJBQTBCLDZCQUE2Qiw4QkFBOEIsNkJBQTZCLGlCQUFpQiw2QkFBNkIsU0FBUyw2QkFBNkIsa0NBQWtDLDZCQUE2QiwrQ0FBK0MsNkJBQTZCLGtCQUFrQiw2QkFBNkIsU0FBUyw2QkFBNkIsa0NBQWtDLDZCQUE2QixpQkFBaUIsNkJBQTZCLFNBQVMsNkJBQTZCLHdCQUF3Qiw2QkFBNkIsdUJBQXVCLDZCQUE2QixxQkFBcUIsNkJBQTZCLHdCQUF3Qiw2QkFBNkIsMkJBQTJCLDZCQUE2Qix3QkFBd0IsNkJBQTZCLG1DQUFtQyw2QkFBNkIsaUJBQWlCLDZCQUE2QixjQUFjLDZCQUE2QixvQkFBb0IsNkJBQTZCLG1CQUFtQiw2QkFBNkIsb0JBQW9CLDZCQUE2QixvQkFBb0IsNkJBQTZCLG1CQUFtQiw2QkFBNkIsbUJBQW1CLDZCQUE2QixtQkFBbUIsNkJBQTZCLG1CQUFtQiw2QkFBNkIsaUNBQWlDLDZCQUE2QixpQkFBaUIsNkJBQTZCLGNBQWMsNkJBQTZCLG1CQUFtQiw2QkFBNkIsbUJBQW1CLDZCQUE2QixtQkFBbUIsNkJBQTZCLFNBQVM7Ozs7Ozs7Ozs7OztBQ0R4b2xCLFVBQVUsbUJBQU8sQ0FBQyw2Q0FBSTtBQUN0Qiw0Q0FBNEMsbUNBQW1DLDJRQUEyUSxFQUFFLHNEQUFzRCxnQ0FBZ0MseUJBQXlCLGlCQUFpQix5QkFBeUIsNkNBQTZDLDBCQUEwQixpQkFBaUIsMEJBQTBCLFNBQVMseUJBQXlCLG9CQUFvQiwwQkFBMEIsU0FBUyx5QkFBeUIsdUNBQXVDLDJCQUEyQixpQkFBaUIsMkJBQTJCLGNBQWMsMkJBQTJCLGNBQWMsMkJBQTJCLG1CQUFtQiwyQkFBMkIseUJBQXlCLDJCQUEyQixxQkFBcUIsMkJBQTJCLDBCQUEwQiwyQkFBMkIscUJBQXFCLDJCQUEyQixTQUFTLDJCQUEyQiwwQkFBMEIsMkJBQTJCLFNBQVMsMkJBQTJCLDBDQUEwQywyQkFBMkIsaUJBQWlCLDJCQUEyQixjQUFjLDJCQUEyQixjQUFjLDJCQUEyQixzQ0FBc0MsMkJBQTJCLGlCQUFpQiwyQkFBMkIsY0FBYywyQkFBMkIsY0FBYywyQkFBMkIsZUFBZTs7Ozs7Ozs7Ozs7OztBQ0RqcEQ7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQywwREFBZTs7QUFFdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdDQUFnQyxzQ0FBc0M7QUFDdEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN2S2E7O0FBRWI7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsMEVBQW1CO0FBQ2hELFNBQVMsbUJBQU8sQ0FBQywwRUFBbUI7QUFDcEM7Ozs7Ozs7Ozs7Ozs7QUNOYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDBEQUFlO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9FQUFvQjtBQUNoRCxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBZ0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHlEQUFhOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQU8sQ0FBQywrREFBZTtBQUMzQyxlQUFlLG1CQUFPLENBQUMscURBQVU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDL0xhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBVztBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQyxtREFBUztBQUN0QyxlQUFlLG1CQUFPLENBQUMscURBQVU7QUFDakMsT0FBTyxnQkFBZ0IsR0FBRyxtQkFBTyxDQUFDLHFEQUFVOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzNFYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbEdhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsbUJBQU8sQ0FBQyx1RkFBMkI7QUFDbkUsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVc7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsMkRBQWE7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMscURBQVU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2hXYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsK0RBQWU7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMscURBQVU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMxTGE7O0FBRWI7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVI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QUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBDQUEwQztBQUMxQyxLQUFLO0FBQ0wsR0FBRztBQUNILFdBQVcsS0FBSzs7QUFFaEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixrRkFBa0Y7QUFDbEYsOENBQThDO0FBQzlDLDBCQUEwQjtBQUMxQixRQUFRLEVBQUU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0EseUNBQXlDLG1CQUFPLENBQUMsa0dBQW1DO0FBQ3BGO0FBQ0Esc0RBQXNEO0FBQ3RELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQztBQUMzQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hNYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHFEQUFVOztBQUVqQyxrQkFBa0IsbUJBQU8sQ0FBQywyREFBYTs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6UUE7O0FBRWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDJEQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMscURBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxpREFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBVzs7QUFFbkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVc7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0MsRUFBRTtBQUM1RCx5QkFBeUIsdUNBQXVDO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCO0FBQ3RCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRFQUE0RTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQU1FOzs7Ozs7Ozs7Ozs7O0FDdkZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBZ0M7QUFDRzs7QUFFbkM7QUFDQSxrQkFBa0IsbURBQU87QUFDekIsZUFBZSxtREFBSTtBQUNuQjs7QUFLQzs7Ozs7Ozs7Ozs7OztBQ1hEO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBS0UiLCJmaWxlIjoiZGV2U3lzdGVtLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vanMvb2JqZWN0cy9TeXN0ZW0uanNcIik7XG4iLCIvKipcbiAqIEV4ZWN1dGlvblN0YWNrXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBhIHN0YWNrIG9mXG4gKiBBY3RpdmF0aW9uQ29udGV4dCBvYmplY3RzLlxuICogSSBhbSBkZXNpZ25lZCB0byBiZSB1c2VkIGJ5IFN5c3RlbSBhcyB0aGVcbiAqIGdsb2JhbCBleGVjdXRpb24gc3RhY2suXG4gKlxuICovXG5cbmNsYXNzIEV4ZWN1dGlvblN0YWNrIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9nbG9iYWxzID0ge307XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnBvcCA9IHRoaXMucG9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHVzaCA9IHRoaXMucHVzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEdsb2JhbCA9IHRoaXMuc2V0R2xvYmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0R2xvYmFsID0gdGhpcy5nZXRHbG9iYWwuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBwb3AoKXtcbiAgICAgICAgaWYoIXRoaXMuX3N0YWNrLmxlbmd0aCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2sucG9wKCk7XG4gICAgfVxuXG4gICAgcHVzaChhbkFjdGl2YXRpb24pe1xuICAgICAgICB0aGlzLl9zdGFjay5wdXNoKGFuQWN0aXZhdGlvbik7XG4gICAgfVxuXG4gICAgc2V0R2xvYmFsKHZhck5hbWUsIHZhbHVlKXtcbiAgICAgICAgdGhpcy5fZ2xvYmFsc1t2YXJOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldEdsb2JhbCh2YXJOYW1lKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsb2JhbHNbdmFyTmFtZV07XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnQoKXtcbiAgICAgICAgaWYoIXRoaXMuX3N0YWNrLmxlbmd0aCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgZ2V0IHByZXZpb3VzKCl7XG4gICAgICAgIGlmKCF0aGlzLl9zdGFjay5sZW5ndGggPj0gMil7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMl07XG4gICAgfVxufTtcblxuY2xhc3MgQWN0aXZhdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VOYW1lLCBwYXJ0LCBpbmNvbWluZ01lc3NhZ2UsIGhhbmRsZXJGdW5jdGlvbil7XG4gICAgICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgICAgIHRoaXMubWVzc2FnZU5hbWUgPSBtZXNzYWdlTmFtZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gaW5jb21pbmdNZXNzYWdlO1xuICAgICAgICB0aGlzLmhhbmRsZXJGdW5jdGlvbiA9IGhhbmRsZXJGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5fbG9jYWxzID0ge307XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0TG9jYWwgPSB0aGlzLmdldExvY2FsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0TG9jYWwgPSB0aGlzLnNldExvY2FsLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0KHZhck5hbWUpe1xuICAgICAgICBsZXQgbG9jYWxWYWx1ZSA9IHRoaXMuZ2V0TG9jYWwodmFyTmFtZSk7XG4gICAgICAgIGlmKGxvY2FsVmFsdWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRyeSB0byByZXR1cm4gYSBnbG9iYWxcbiAgICAgICAgLy8gdmFyaWFibGVcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2suZ2V0R2xvYmFsKHZhck5hbWUpO1xuICAgIH1cblxuICAgIGdldExvY2FsKHZhck5hbWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxzW3Zhck5hbWVdO1xuICAgIH1cblxuICAgIHNldExvY2FsKHZhck5hbWUsIHZhbHVlKXtcbiAgICAgICAgdGhpcy5fbG9jYWxzW3Zhck5hbWVdID0gdmFsdWU7XG4gICAgfVxufVxuXG5leHBvcnQge1xuICAgIEV4ZWN1dGlvblN0YWNrLFxuICAgIEFjdGl2YXRpb25Db250ZXh0XG59O1xuIiwiLyoqXG4gKiBTeXN0ZW0gT2JqZWN0XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIFwidG9wXCIgb2YgdGhlXG4gKiBzeXRlbS4gSSBhbSB0aGUgcG9pbnQgb2YgY29tbXVuaWNhdGlvbiBiZXR3ZWVuXG4gKiBNb2RlbHMgYW5kIFZpZXdzLlxuICovXG5pbXBvcnQgQ2FyZCBmcm9tICcuL3BhcnRzL0NhcmQuanMnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4vcGFydHMvU3RhY2suanMnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuL3BhcnRzL0J1dHRvbi5qcyc7XG5pbXBvcnQgRmllbGQgZnJvbSAnLi9wYXJ0cy9GaWVsZC5qcyc7XG5pbXBvcnQgV29ybGRTdGFjayBmcm9tICcuL3BhcnRzL1dvcmxkU3RhY2suanMnO1xuaW1wb3J0IFdpbmRvdyBmcm9tICcuL3BhcnRzL1dpbmRvdy5qcyc7XG5pbXBvcnQgRHJhd2luZyBmcm9tICcuL3BhcnRzL0RyYXdpbmcuanMnO1xuaW1wb3J0IEF1ZGlvIGZyb20gJy4vcGFydHMvQXVkaW8uanMnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi9wYXJ0cy9Ccm93c2VyLmpzJztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL3BhcnRzL1Jlc291cmNlLmpzJztcbmltcG9ydCBJbWFnZSBmcm9tICcuL3BhcnRzL0ltYWdlLmpzJztcbmltcG9ydCBBcmVhIGZyb20gJy4vcGFydHMvQXJlYS5qcyc7XG5cbmltcG9ydCBXb3JsZFZpZXcgZnJvbSAnLi92aWV3cy9Xb3JsZFZpZXcuanMnO1xuaW1wb3J0IFN0YWNrVmlldyBmcm9tICcuL3ZpZXdzL1N0YWNrVmlldy5qcyc7XG5pbXBvcnQgQnV0dG9uVmlldyBmcm9tICcuL3ZpZXdzL0J1dHRvblZpZXcuanMnO1xuXG5pbXBvcnQgQ2FyZFZpZXcgZnJvbSAnLi92aWV3cy9DYXJkVmlldy5qcyc7XG5pbXBvcnQgV2luZG93VmlldyBmcm9tICcuL3ZpZXdzL1dpbmRvd1ZpZXcnO1xuaW1wb3J0IEZpZWxkVmlldyBmcm9tICcuL3ZpZXdzL0ZpZWxkVmlldy5qcyc7XG5pbXBvcnQgRHJhd2luZ1ZpZXcgZnJvbSAnLi92aWV3cy9kcmF3aW5nL0RyYXdpbmdWaWV3LmpzJztcbmltcG9ydCBJbWFnZVZpZXcgZnJvbSAnLi92aWV3cy9JbWFnZVZpZXcuanMnO1xuaW1wb3J0IEFyZWFWaWV3IGZyb20gJy4vdmlld3MvQXJlYVZpZXcuanMnO1xuaW1wb3J0IEF1ZGlvVmlldyBmcm9tICcuL3ZpZXdzL0F1ZGlvVmlldy5qcyc7XG5pbXBvcnQgQnJvd3NlclZpZXcgZnJvbSAnLi92aWV3cy9Ccm93c2VyVmlldy5qcyc7XG5pbXBvcnQgUmVzb3VyY2VWaWV3IGZyb20gJy4vdmlld3MvUmVzb3VyY2VWaWV3LmpzJztcblxuXG5pbXBvcnQgSGFsbyBmcm9tICcuL3ZpZXdzL0hhbG8uanMnO1xuaW1wb3J0IFNUTmF2aWdhdG9yIGZyb20gJy4vdmlld3MvbmF2aWdhdG9yL05hdmlnYXRvci5qcyc7XG5pbXBvcnQgRWRpdG9yIGZyb20gJy4vdmlld3MvZWRpdG9ycy9FZGl0b3IuanMnO1xuXG5pbXBvcnQgb2htIGZyb20gJ29obS1qcyc7XG5pbXBvcnQgaW50ZXJwcmV0ZXJTZW1hbnRpY3MgZnJvbSAnLi4vb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyc7XG5pbXBvcnQge0V4ZWN1dGlvblN0YWNrLCBBY3RpdmF0aW9uQ29udGV4dH0gZnJvbSAnLi9FeGVjdXRpb25TdGFjay5qcyc7XG5cbmltcG9ydCBpZE1ha2VyIGZyb20gJy4vdXRpbHMvaWQuanMnO1xuaW1wb3J0IFNUQ2xpcGJvYXJkIGZyb20gJy4vdXRpbHMvY2xpcGJvYXJkLmpzJztcblxuaW1wb3J0IHtCYXNpY1Byb3BlcnR5fSBmcm9tICcuL3Byb3BlcnRpZXMvUGFydFByb3BlcnRpZXMuanMnO1xuXG5pbXBvcnQgaGFuZEludGVyZmFjZSBmcm9tICcuL3V0aWxzL2hhbmRJbnRlcmZhY2UuanMnO1xuaW1wb3J0IG1lcnJpYW1TaW1TY29yZSBmcm9tICcuL3V0aWxzL21lcnJpYW1JbnRlcmZhY2UuanMnO1xuXG5pbXBvcnQge1NURGVzZXJpYWxpemVyLCBTVFNlcmlhbGl6ZXJ9IGZyb20gJy4vdXRpbHMvc2VyaWFsaXphdGlvbi5qcyc7XG5cbmltcG9ydCBwbHVnaW5zIGZyb20gJy4uLy4uL3BsdWdpbnMvcGx1Z2lucy5qcyc7XG5cbmNvbnN0IERPTXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuaW1wb3J0IGNyZWF0ZUhpZ2hsaWdodGVyIGZyb20gJy4vdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMnO1xuXG5cbmNvbnN0IFN5c3RlbSA9IHtcbiAgICBuYW1lOiBcIlN5c3RlbVwiLFxuICAgIGlkOiAtMSxcbiAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgcGFydHNCeUlkOiB7fSxcbiAgICBfY29tbWFuZEhhbmRsZXJzOiB7fSxcbiAgICBfZnVuY3Rpb25IYW5kbGVyczoge30sXG4gICAgX2Rlc2VyaWFsaXplcjogbnVsbCxcblxuICAgIC8vIEEgZGljdGlvbmFyeSBtYXBwaW5nIGF2YWlsYWJsZSBTVCByZXNvdXJjZSAoc3VjaCBhcyBwbHVnaW4pIG5hbWVzXG4gICAgYXZhaWxhYmxlUmVzb3VyY2VzOiB7fSxcblxuICAgIC8vIEEgZGljdGlvbmFyeSBtYXBwaW5nIHBhcnQgdHlwZXMgbGlrZVxuICAgIC8vICdidXR0b24nIHRvIHRoZWlyIGNsYXNzZXMgKEJ1dHRvbilcbiAgICBhdmFpbGFibGVQYXJ0czoge30sXG5cbiAgICAvLyBBIGRpY3Rpb25hcnkgbWFwcGluZyBwYXJ0IHR5cGVzIGxpa2VcbiAgICAvLyAnYnV0dG9uJyB0byB0aGVpciB2aWV3IGNsYXNzZXMgKEJ1dHRvblZpZXcpXG4gICAgYXZhaWxhYmxlVmlld3M6IHt9LFxuXG4gICAgLy8gQSByZWdpc3RyeSB0aGF0IGtlZXBzIGFsbCBzeXN0ZW0gbWVzc2FnZXMgZnJvbVxuICAgIC8vIGJlZ2lubmlnbiBvZiB0aW1lOyBUT0RPIGluIHRoZSBmdXR1cmUgd2UgbWlnaHQgd2FudFxuICAgIC8vIHRvIG5vdGUga2VlcCBhbGwgdGhpcyBpbiBtZW1vcnlcbiAgICAvLyBlYWNoIGxvZyBjb25zaXN0cyBvZjpcbiAgICAvLyBbYU1lc3NhZ2UsIChzb3VyY2VOYW1lLCBzb3VyY2VJZCksICh0YXJnZXROYW1lLCB0YXJnZXRJZCldXG4gICAgbWVzc2FnZUxvZzogW10sXG5cbiAgICAvLyBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgcGFnZSBsb2Fkcy5cbiAgICAvLyBDaGVja3MgZm9yIGFueSB2aWV3IGVsZW1lbnRzIGluIHRoZVxuICAgIC8vIHBhZ2UgYW5kIGF0dGVtcHRzIHRvIGZpbmQgc2VyaWFsaXplZFxuICAgIC8vIG1vZGVsIHN0YXRlIGZvciBlYWNoIG9mIHRoZW0uIElmIHByZXNlbnQsXG4gICAgLy8gZGVzZXJpYWxpemVzIHRoZSBtb2RlbCBhbmQgYXR0YWNoZXMgaXRcbiAgICAvLyB0byB0aGUgdmlldy5cbiAgICBpbml0aWFsTG9hZDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gbG9hZCB0aGUgYXZhaWxhYmxlIHJlc291cmNlc1xuICAgICAgICAvLyB0aGVzZSBtaWdodCBiZSBuZWVkZWQgZG93biB0aGUgbGluZVxuICAgICAgICB0aGlzLmxvYWRSZXNvdXJjZXMoKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgc2VyaWFsaXphdGlvbiBzY3JpcHQgdGFnXG4gICAgICAgIC8vIGNvbnRhaW5pbmcgSlNPTiBvZiBzZXJpYWxpemVkIGluZm9ybWF0aW9uLFxuICAgICAgICAvLyBhdHRlbXB0IHRvIGxvYWQgZnJvbSBpdFxuICAgICAgICBsZXQgc2VyaWFsaXphdGlvbkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgaWYoc2VyaWFsaXphdGlvbkVsICYmIHNlcmlhbGl6YXRpb25FbC50ZXh0ICE9IFwiXCIpe1xuICAgICAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRJbml0aWFsT3Blbk1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5uYXZpZ2F0b3Iuc2V0TW9kZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2UgcmVuZGVyIHRoZSBXb3JsZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJlaGVuc2l2ZSBFZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyKHRoaXMud29ybGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2FkRnJvbUVtcHR5KCk7XG4gXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB3ZSByZW5kZXIgdGhlIFdvcmxkIGluIHRoZVxuICAgICAgICAgICAgLy8gQ29tcHJlaGVuc2l2ZSBFZGl0b3JcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcih0aGlzLndvcmxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBhIG5ldyBjbGlwYm9hcmQgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQgPSBuZXcgU1RDbGlwYm9hcmQodGhpcyk7XG5cbiAgICAgICAgLy8gQnkgdGhpcyBwb2ludCB3ZSBzaG91bGQgaGF2ZSBhIFdvcmxkVmlldyB3aXRoXG4gICAgICAgIC8vIGEgbW9kZWwgYXR0YWNoZWQuXG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBsb2FkUmVzb3VyY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVSZXNvdXJjZXNba10gPSBwbHVnaW5zW2tdO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbG9hZEZyb21FbXB0eTogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHdvcmxkTW9kZWwgPSBuZXcgdGhpcy5hdmFpbGFibGVQYXJ0c1snd29ybGQnXSgpO1xuICAgICAgICB0aGlzLnBhcnRzQnlJZFt3b3JsZE1vZGVsLmlkXSA9IHdvcmxkTW9kZWw7XG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgdGhpcy50YWdOYW1lRm9yVmlld05hbWVkKCd3b3JsZCcpXG4gICAgICAgICk7XG4gICAgICAgIHdvcmxkVmlldy5zZXRNb2RlbCh3b3JsZE1vZGVsKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh3b3JsZFZpZXcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIHN0YWNrIG1vZGVsXG4gICAgICAgIGxldCBpbml0U3RhY2sgPSB0aGlzLm5ld01vZGVsKCdzdGFjaycsIHdvcmxkTW9kZWwuaWQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIGNhcmQgbW9kZWwgZm9yIHRoYXQgc3RhY2tcbiAgICAgICAgbGV0IGluaXRDYXJkID0gdGhpcy5uZXdNb2RlbCgnY2FyZCcsIGluaXRTdGFjay5pZCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgc3RhY2sgYW5kIGNhcmQgaWRzIFxuICAgICAgICB3b3JsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB3b3JsZE1vZGVsLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgaW5pdFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGluaXRTdGFjay5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgaW5pdFN0YWNrLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgaW5pdENhcmQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgLy8gVXBkYXRlIHNlcmlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5zZXJpYWxpemUoKTtcblxuICAgICAgICB0aGlzLnNlbmRJbml0aWFsT3Blbk1lc3NhZ2VzKCk7XG4gICAgICAgIFN5c3RlbS5uYXZpZ2F0b3Iuc2V0TW9kZWwoXG4gICAgICAgICAgICBTeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHNlbmRJbml0aWFsT3Blbk1lc3NhZ2VzOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBTZW5kIHRoZSBvcGVuV29ybGQgbWVzc2FnZSB0byB0aGUgV29ybGRTdGFja1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICAgICAgd29ybGQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuV29ybGQnLFxuICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgfSwgd29ybGQpO1xuICAgICAgICB3b3JsZC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TdGFjaycsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB3b3JsZC5jdXJyZW50U3RhY2spO1xuICAgICAgICB3b3JsZC5jdXJyZW50U3RhY2suc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuQ2FyZCcsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB3b3JsZC5jdXJyZW50U3RhY2suY3VycmVudENhcmQpO1xuICAgIH0sXG5cbiAgICBzZW5kTWVzc2FnZTogZnVuY3Rpb24oYU1lc3NhZ2UsIHNvdXJjZSwgdGFyZ2V0KXtcbiAgICAgICAgaWYoIXRhcmdldCB8fCB0YXJnZXQgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZXMgbXVzdCBiZSBzZW50IHdpdGggdGFyZ2V0IHJlY2VpdmVycyBzcGVjaWZpZWQhJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFsbCBzb3VyY2VzIHdoaWNoIHBhc3MgdGhpcyBtZXNzYWdlXG4gICAgICAgIGlmICghKFwic2VuZGVyc1wiIGluIGFNZXNzYWdlKSkge1xuICAgICAgICAgICAgYU1lc3NhZ2VbXCJzZW5kZXJzXCJdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYU1lc3NhZ2Uuc2VuZGVycy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHNvdXJjZS5uYW1lLFxuICAgICAgICAgICAgaWQ6IHNvdXJjZS5pZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5yZWNlaXZlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgfSxcblxuICAgIHJlY2VpdmVNZXNzYWdlOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIHN3aXRjaChhTWVzc2FnZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ25ld1ZpZXcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld1ZpZXcoXG4gICAgICAgICAgICAgICAgICAgIGFNZXNzYWdlLnZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBhTWVzc2FnZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBpbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGUoYU1lc3NhZ2UpO1xuICAgICAgICAgICAgY2FzZSAnY29tbWFuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbW1hbmQoYU1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2VzTm90VW5kZXJzdGFuZChhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZG9lc05vdFVuZGVyc3RhbmQ6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgaGFzIHRoZSBzaG91bGRJZ25vcmUgcHJvcGVydHlcbiAgICAgICAgLy8gc2V0IHRvIHRydWUsIGl0IG1lYW5zIHdlIHNob3VsZCBqdXN0IHN3YWxsb3dcbiAgICAgICAgLy8gdGhpcyBtZXNzYWdlIGlmIHdlIGRvbid0IHVuZGVyc3RhbmQgaXQuIFRoaXMgaXNcbiAgICAgICAgLy8gdXNlZnVsIGZvciBtZXNzYWdlcyBsaWtlIG1vdXNlIGV2ZW50cyBvbiBidXR0b25zXG4gICAgICAgIC8vIHdoaWNoIGFyZSBub3QgY2FwdHVyZWQgYnkgZGVmYXVsdCBhbmQgd291bGQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGVuZCB1cCBhcnJpdmluZyB0byB0aGlzIFN5c3RlbSBvYmplY3QgdmlhIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGRlbGVnYXRpb24gY2hhaW4uXG4gICAgICAgIGlmKGFNZXNzYWdlLnNob3VsZElnbm9yZSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gdGhpcy5wYXJ0c0J5SWRbYU1lc3NhZ2Uuc2VuZGVyc1swXS5pZF07XG4gICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBuYW1lOiBcIk1lc3NhZ2VOb3RVbmRlcnN0b29kXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBhTWVzc2FnZVxuICAgICAgICB9O1xuICAgICAgICBvcmlnaW5hbFNlbmRlci5zZW5kTWVzc2FnZShtc2csIG9yaWdpbmFsU2VuZGVyKTtcbiAgICB9LFxuXG4gICAgY29tcGlsZTogZnVuY3Rpb24oYU1lc3NhZ2Upe1xuICAgICAgICBsZXQgdGFyZ2V0T2JqZWN0ID0gdGhpcy5wYXJ0c0J5SWRbYU1lc3NhZ2UudGFyZ2V0SWRdO1xuICAgICAgICBpZighdGFyZ2V0T2JqZWN0IHx8IHRhcmdldE9iamVjdCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTeXN0ZW0gY291bGQgbm90IGNvbXBpbGUgdGFyZ2V0IG9iamVjdCAke2FNZXNzYWdlLnRhcmdldElkfWApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBpbmNvbWluZyBTaW1wbGVUYWxrIHNjcmlwdCBzdHJpbmcuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBncmFtbWF0aWNhbCBlcnJvcnMsIHJlcG9ydCB0aGVtIGFuZCBiYWlsLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBzZW1hbnRpY3Mgb24gdGhlIHRhcmdldFBhcnQsIGFkZFxuICAgICAgICAvLyB0aGUgcmVxdWlyZWQgc2VtYW50aWMgb3BlcmF0aW9ucywgYW5kIGludGVycHJldCB0aGUgdG9wXG4gICAgICAgIC8vIGxldmVsIG9mIHRoZSBzY3JpcHQsIHdoaWNoIHdpbGwgY3JlYXRlIHRoZSBKUyBoYW5kbGVyIGZ1bmN0aW9uc1xuICAgICAgICBsZXQgcGFyc2VkU2NyaXB0ID0gbGFuZ3VhZ2VHcmFtbWFyLm1hdGNoKGFNZXNzYWdlLmNvZGVTdHJpbmcpO1xuICAgICAgICBpZihwYXJzZWRTY3JpcHQuZmFpbGVkKCkpe1xuICAgICAgICAgICAgLy8gY29uc2lkZXIgdXNpbmcgdGhlIHBhcnNlIGRhdGEgZnJvbSB0cmFjZVxuICAgICAgICAgICAgLy8gZXhhbXBsZTogbGV0IHRyYWNlZFNjcmlwdCA9IGxhbmd1YWdlR3JhbW1hci50cmFjZShhTWVzc2FnZS5jb2RlU3RyaW5nKTtcbiAgICAgICAgICAgIC8vIGxldCB0cmVlID0gdHJhY2VkU2NyaXB0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkdyYW1tYXJNYXRjaEVycm9yXCIsXG4gICAgICAgICAgICAgICAgcGFyc2VkU2NyaXB0OiBwYXJzZWRTY3JpcHQsXG4gICAgICAgICAgICAgICAgcGFydElkOiBhTWVzc2FnZS50YXJnZXRJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5zZW5kTWVzc2FnZShtc2csIHRhcmdldE9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgY2xlYXIgb3V0IGFueSBjdXJyZW50bHkgY29tcGlsZWQgaGFuZGxlcnNcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBpbmNvbWluZyBzY3JpcHQgbWlnaHQgZ2V0IHJpZCBvZiB0aGVtXG4gICAgICAgICAgICB0YXJnZXRPYmplY3QuX2NvbW1hbmRIYW5kbGVycyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZW1hbnRpY3Mgb2JqZWN0IHdob3NlIHBhcnRDb250ZXh0XG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGJlIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0Ll9zZW1hbnRpY3MgPSBsYW5ndWFnZUdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgICAgICB0YXJnZXRPYmplY3QuX3NlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJTZW1hbnRpY3ModGFyZ2V0T2JqZWN0LCB0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5fc2VtYW50aWNzKHBhcnNlZFNjcmlwdCkuaW50ZXJwcmV0KCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEJlIHN1cmUgdG8gdGhlbiB1cGRhdGUgdGhlXG4gICAgICAgIC8vIHNlcmlhbGl6YXRpb24gZm9yIHRoZSB0YXJnZXRcbiAgICAgICAgLy8gcGFydCwgdGh1cyBhZGRpbmcgdGhlIHNjcmlwdCB0b1xuICAgICAgICAvLyBpdHMgc2VyaWFsaXphdGlvblxuICAgICAgICBpZihhTWVzc2FnZS5zZXJpYWxpemUpe1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWNlaXZlQ29tbWFuZDogZnVuY3Rpb24oYU1lc3NhZ2Upe1xuICAgICAgICBsZXQgaGFuZGxlciA9IHRoaXMuX2NvbW1hbmRIYW5kbGVyc1thTWVzc2FnZS5jb21tYW5kTmFtZV07XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGxldCBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9lc05vdFVuZGVyc3RhbmQoYU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5ld01vZGVsOiBmdW5jdGlvbihraW5kLCBvd25lcklkLCBuYW1lLCBidWlsZFZpZXc9dHJ1ZSl7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1vZGVsIHRoYXRcbiAgICAgICAgLy8gbWF0Y2hlcyB0aGUgb3duZXIncyBpZFxuICAgICAgICBsZXQgb3duZXJQYXJ0ID0gdGhpcy5wYXJ0c0J5SWRbb3duZXJJZF07XG4gICAgICAgIGlmKCFvd25lclBhcnQgfHwgb3duZXJQYXJ0ID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5c3RlbSBjb3VsZCBub3QgbG9jYXRlIG93bmVyIHBhcnQgd2l0aCBpZCAke293bmVySWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBjbGFzcyBjb25zdHJ1Y3RvciBmb3IgdGhlIGtpbmQgb2ZcbiAgICAgICAgLy8gcGFydCByZXF1ZXN0ZWQgYXMgYSBuZXcgbW9kZWwuIElmIG5vdCBrbm93bixcbiAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgbGV0IG1vZGVsQ2xhc3MgPSB0aGlzLmF2YWlsYWJsZVBhcnRzW2tpbmRdO1xuICAgICAgICBpZighbW9kZWxDbGFzcyl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgdW5rbm93biBwYXJ0IHR5cGU6ICR7a2luZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kZWwgPSBuZXcgbW9kZWxDbGFzcyhvd25lclBhcnQpO1xuICAgICAgICBpZihuYW1lKXtcbiAgICAgICAgICAgIG1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQobW9kZWwsICduYW1lJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0c0J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG5cbiAgICAgICAgLy8gQW55IGNyZWF0ZWQgcGFydCBtaWdodCBpbml0aWFsaXplIGl0c1xuICAgICAgICAvLyBvd24gc3VicGFydHMuIFdlIG5lZWQgdG8gbGV0IHRoZSBTeXN0ZW0ga25vd1xuICAgICAgICAvLyBhYm91dCB0aG9zZSB0b29cbiAgICAgICAgbW9kZWwuc3VicGFydHMuZm9yRWFjaChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydHNCeUlkW3N1YnBhcnQuaWRdID0gc3VicGFydDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2YWxpZCBvd25lciBwYXJ0IGZvclxuICAgICAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBwYXJ0IG1vZGVsLFxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBtb2RlbCB0byB0aGUgb3duZXInc1xuICAgICAgICAvLyBzdWJwYXJ0cyBsaXN0XG4gICAgICAgIGlmKG93bmVyUGFydCl7XG4gICAgICAgICAgICBvd25lclBhcnQuYWRkUGFydChtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlIFN5c3RlbSBhcyBhIHByb3BlcnR5IHN1YnNjcmliZXIgdG9cbiAgICAgICAgLy8gdGhlIG5ldyBtb2RlbC4gVGhpcyB3aWxsIHNlbmQgYSBtZXNzYWdlIHRvXG4gICAgICAgIC8vIHRoaXMgU3lzdGVtIG9iamVjdCB3aGVuZXZlciBhbnkgb2YgdGhpcyBtb2RlbCdzXG4gICAgICAgIC8vIHByb3BlcnRpZXMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIG1vZGVsLmFkZFByb3BlcnR5U3Vic2NyaWJlcih0aGlzKTtcblxuICAgICAgICBpZihidWlsZFZpZXcpe1xuICAgICAgICAgICAgLy8gU2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSB2aWV3IGZvciB0aGUgbW9kZWwuXG4gICAgICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBhbmQgYXR0YWNoIGl0LlxuICAgICAgICAgICAgbGV0IHZpZXdGb3JNb2RlbCA9IHRoaXMuZmluZFZpZXdCeUlkKG1vZGVsLmlkKTtcbiAgICAgICAgICAgIGlmKCF2aWV3Rm9yTW9kZWwpe1xuICAgICAgICAgICAgICAgIHRoaXMubmV3Vmlldyhtb2RlbC50eXBlLCBtb2RlbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgb3duZXIgcGFydCBpcyBlaXRoZXIgYSB3b3JsZCBvciBhIHN0YWNrXG4gICAgICAgIC8vIGFuZCBoYXMgb25seSBvbmUgc3RhY2sgb3IgY2FyZCBjaGlsZCwgcmVzcGVjdGl2ZWx5LCBzZXRcbiAgICAgICAgLy8gdGhhdCBjaGlsZCB0byBiZSB0aGUgY3VycmVudFxuICAgICAgICBpZihvd25lclBhcnQudHlwZSA9PSBcIndvcmxkXCIgfHwgb3duZXJQYXJ0LnR5cGUgPT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBvd25lclBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvd25lclBhcnQsIFwiY3VycmVudFwiKTtcbiAgICAgICAgICAgIGlmKCFjdXJyZW50SWQpe1xuICAgICAgICAgICAgICAgIG93bmVyUGFydC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG93bmVyUGFydCwgXCJjdXJyZW50XCIsIG1vZGVsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHkgc2VuZCB0aGUgbW9kZWwgYSBtZXNzYWdlIHRvIGFubm91bmNlIHRoYXQgaXQgaXMgbmV3XG4gICAgICAgIC8vIHRvIHRoZSB3b3JsZCwgYnV0IGRvbid0IFxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbmV3TW9kZWwnLFxuICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICBzaG91bGROb3REZWxlZ2F0ZTogdHJ1ZSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB0aGlzLCBtb2RlbCk7XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICBuZXdQcm9wZXJ0eShzZW5kZXJzLCBwcm9wTmFtZSwgb2JqZWN0SWQpe1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBsZXQgb3JpZ2luYWxTZW5kZXIgPSBzZW5kZXJzWzBdLmlkO1xuXG4gICAgICAgIGlmKG9iamVjdElkKXtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgYW4gb2JqZWN0SWQsIHdlIGFyZVxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgcHJvcGVydHkgb2YgYSBzcGVjaWZpYyBwYXJ0IGJ5XG4gICAgICAgICAgICAvLyBpZFxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb2JqZWN0SWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvbiB0aGUgcGFydFxuICAgICAgICAgICAgLy8gdGhhdCBvcmlnaW5hbGx5IHNlbnQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29yaWdpbmFsU2VuZGVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBuZXdQcm9wZXJ0eSB0YXJnZXQhYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUpKXtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgYSBTVCBlcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJ0ICR7dGFyZ2V0LmlkfSBhbHJlYWR5IGhhcyBwcm9wZXJ0eSBcIiR7cHJvcE5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBvbmx5IGFkZCBiYXNpYyBwcm9wZXJ0eSBhbmQgdGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbFxuICAgICAgICBsZXQgY3VzdG9tUHJvcCA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChcImN1c3RvbS1wcm9wZXJ0aWVzXCIpO1xuICAgICAgICBsZXQgbmV3UHJvcCA9IG5ldyBCYXNpY1Byb3BlcnR5KHByb3BOYW1lLCBudWxsKTtcbiAgICAgICAgY3VzdG9tUHJvcC5hZGQobmV3UHJvcCk7XG4gICAgfSxcblxuICAgIGRlbGV0ZVByb3BlcnR5KHNlbmRlcnMsIHByb3BOYW1lLCBvYmplY3RJZCl7XG4gICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgIGxldCBvcmlnaW5hbFNlbmRlciA9IHNlbmRlcnNbMF0uaWQ7XG5cbiAgICAgICAgaWYob2JqZWN0SWQpe1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhbiBvYmplY3RJZCwgd2UgYXJlXG4gICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvZiBhIHNwZWNpZmljIHBhcnQgYnlcbiAgICAgICAgICAgIC8vIGlkXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvYmplY3RJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHNldHRpbmcgdGhlIHByb3BlcnR5IG9uIHRoZSBwYXJ0XG4gICAgICAgICAgICAvLyB0aGF0IG9yaWdpbmFsbHkgc2VudCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb3JpZ2luYWxTZW5kZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGRlbGV0ZVByb3BlcnR5IHRhcmdldCFgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgd2lsbCBvbmx5IGRlbGV0ZSBjdXN0b20gcHJvcGVydGllcyB3aGljaCBpcyB3aGF0IHdlIHdhbnRcbiAgICAgICAgbGV0IHByb3AgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUpO1xuXG4gICAgICAgIGxldCBjdXN0b21Qcm9wID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKFwiY3VzdG9tLXByb3BlcnRpZXNcIik7XG4gICAgICAgIGN1c3RvbVByb3AuZGVsZXRlKHByb3ApO1xuICAgIH0sXG5cbiAgICBzZXRQcm9wZXJ0eShzZW5kZXJzLCBwcm9wTmFtZSwgdmFsdWUsIG9iamVjdElkKXtcbiAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gc2VuZGVyc1swXS5pZDtcblxuICAgICAgICBpZihvYmplY3RJZCl7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIGFuIG9iamVjdElkLCB3ZSBhcmVcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHByb3BlcnR5IG9mIGEgc3BlY2lmaWMgcGFydCBieVxuICAgICAgICAgICAgLy8gaWRcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29iamVjdElkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBhcmUgc2V0dGluZyB0aGUgcHJvcGVydHkgb24gdGhlIHBhcnRcbiAgICAgICAgICAgIC8vIHRoYXQgb3JpZ2luYWxseSBzZW50IHRoZSBtZXNzYWdlXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvcmlnaW5hbFNlbmRlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc2V0UHJvcGVydHkgdGFyZ2V0IWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGUgbW9kZWwgd2l0aCB0aGUgZ2l2ZW4gSUQgZnJvbVxuICAgIC8vIHRoZSBTeXN0ZW0ncyByZWdpc3RyeSwgYXMgd2VsbCBhcyBmcm9tIHRoZSBzdWJwYXJ0c1xuICAgIC8vIGFycmF5IG9mIGFueSBvd25lcnNcbiAgICBkZWxldGVNb2RlbDogZnVuY3Rpb24obW9kZWxJZCl7XG4gICAgICAgIGxldCBmb3VuZE1vZGVsID0gdGhpcy5wYXJ0c0J5SWRbbW9kZWxJZF07XG4gICAgICAgIGlmKCFmb3VuZE1vZGVsKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHJlbW92aW5nIGEgY2FyZCBvciBhIHN0YWNrIGJlIHN1cmUgaXQgaXMgbm90IHRoZSBvbmx5IG9uZVxuICAgICAgICAvLyBhbmQgaWYgaXQgaXMgdGhlIGN1cnJlbnQgY2FyZCBvciBzdGFjayB3ZSBzaG91bGQgZ28gdG8gdGhlIG5leHQgb25lXG4gICAgICAgIC8vIGJlZm9yZSByZW1vdmluZyBpdFxuICAgICAgICBpZihmb3VuZE1vZGVsLnR5cGUgPT0gXCJjYXJkXCIgfHwgZm91bmRNb2RlbC50eXBlID09IFwic3RhY2tcIil7XG4gICAgICAgICAgICBsZXQgc2FtZVR5cGVTdWJwYXJ0cyA9IGZvdW5kTW9kZWwuX293bmVyLnN1YnBhcnRzLmZpbHRlcigocCkgPT4ge3JldHVybiBwLnR5cGUgPT0gZm91bmRNb2RlbC50eXBlO30pO1xuICAgICAgICAgICAgaWYoc2FtZVR5cGVTdWJwYXJ0cy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHRoZSBvbmx5ICR7Zm91bmRNb2RlbC50eXBlfWApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG1vZGVsSWQgPT0gdGhpcy5nZXRDdXJyZW50U3RhY2tNb2RlbCgpLmlkICB8fCBtb2RlbElkID09IHRoaXMuZ2V0Q3VycmVudENhcmRNb2RlbCgpLmlkKXtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGJlIGEgU1QgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgdGhlIGN1cnJlbnQgJHtmb3VuZE1vZGVsLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gc3RvcCBhbGwgc3RlcHBpbmdcbiAgICAgICAgLy8gb24gdGhlIFBhcnQsIG90aGVyd2lzZSBzdGVwcGluZ1xuICAgICAgICAvLyBpbnRlcnZhbHMgd2lsbCBlcnJvciBpbmZpbml0ZWx5XG4gICAgICAgIGZvdW5kTW9kZWwuc3RvcFN0ZXBwaW5nKCk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBlZGl0b3IgaXMgY2xvc2VkXG4gICAgICAgIGZvdW5kTW9kZWwuY2xvc2VFZGl0b3JDbWRIYW5kbGVyKCk7XG5cbiAgICAgICAgbGV0IG93bmVyTW9kZWwgPSBmb3VuZE1vZGVsLl9vd25lcjtcbiAgICAgICAgaWYob3duZXJNb2RlbCl7XG4gICAgICAgICAgICBvd25lck1vZGVsLnJlbW92ZVBhcnQoZm91bmRNb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5wYXJ0c0J5SWRbbW9kZWxJZF07XG4gICAgICAgIHRoaXMucmVtb3ZlVmlld3MobW9kZWxJZCk7XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBzdGF0ZVxuICAgICAgICB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFsbCB2aWV3cyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgLy8gbW9kZWwgaWQgZnJvbSB0aGUgRE9NXG4gICAgcmVtb3ZlVmlld3M6IGZ1bmN0aW9uKG1vZGVsSWQpe1xuICAgICAgICBsZXQgdmlld3MgPSBBcnJheS5mcm9tKHRoaXMuZmluZFZpZXdzQnlJZChtb2RlbElkKSk7XG4gICAgICAgIHZpZXdzLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICBsZXQgcGFyZW50RWwgPSB2aWV3LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2aWV3LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodmlldyk7XG4gICAgICAgICAgICAvLyBEaXNwYXRjaCBhIEN1c3RvbUV2ZW50IG9uIHRoZSBwYXJlbnRFbGVtZW50XG4gICAgICAgICAgICAvLyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBwYXJ0IGhhcyBiZWVuIHJlbW92ZWQsIGFuZFxuICAgICAgICAgICAgLy8gYW55IHZpZXcgdXRpbGl0aWVzIHRoYXQgY2FyZSBjYW4gYmUgbm90aWZpZWQuXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3N0LXZpZXctcmVtb3ZlZCcsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFydFR5cGU6IHZpZXcubW9kZWwudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGFydElkOiBtb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBvd25lcklkOiBudWxsXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50RWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGVuc2VzID0gdGhpcy5maW5kTGVuc1ZpZXdzQnlJZChtb2RlbElkKTtcbiAgICAgICAgbGVuc2VzLmZvckVhY2gobGVuc1ZpZXcgPT4ge1xuICAgICAgICAgICAgbGVuc1ZpZXcucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChsZW5zVmlldyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBuZXdWaWV3OiBmdW5jdGlvbihwYXJ0TmFtZSwgbW9kZWxJZCwgcGFyZW50SWQpe1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLnBhcnRzQnlJZFttb2RlbElkXTtcbiAgICAgICAgaWYoIW1vZGVsIHx8IG1vZGVsID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5c3RlbSBkb2VzIG5vdCBrbm93IHBhcnQgJHtwYXJ0TmFtZX1bJHttb2RlbElkfV1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZighcGFydE5hbWUpe1xuICAgICAgICAgICAgcGFydE5hbWUgPSBtb2RlbC50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgcGFyZW50IG1vZGVsIGlkLiBUaGlzIHdpbGxcbiAgICAgICAgLy8gaGVscCB1cyBmaW5kIHRoZSBwYXJlbnQgdmlldyBlbGVtZW50IGZvclxuICAgICAgICAvLyBhcHBlbmRpbmcgdGhlIG5ldyBlbGVtZW50LlxuICAgICAgICBpZiAoIXBhcmVudElkKXtcbiAgICAgICAgICAgIHBhcmVudElkID0gbW9kZWwuX293bmVyLmlkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnRFbGVtZW50ID0gdGhpcy5maW5kVmlld0J5SWQocGFyZW50SWQpO1xuICAgICAgICBpZighcGFyZW50RWxlbWVudCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhcmVudCBlbGVtZW50IGZvciAke3BhcnROYW1lfVske21vZGVsSWR9XSAobW9kZWwgb3duZXIgaWQ6ICR7bW9kZWwuX293bmVyLmlkfSlgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IHZpZXcgaW5zdGFuY2UsXG4gICAgICAgIC8vIGFwcGVuZCB0byBwYXJlbnQsIGFuZCBzZXQgdGhlIG1vZGVsXG4gICAgICAgIGxldCBuZXdWaWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIHRoaXMudGFnTmFtZUZvclZpZXdOYW1lZChwYXJ0TmFtZSlcbiAgICAgICAgKTtcbiAgICAgICAgbmV3Vmlldy5zZXRNb2RlbChtb2RlbCk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJ2aWV3Q2hhbmdlZFwiLFxuICAgICAgICAgICAgY2hhbmdlTmFtZTogXCJzdWJwYXJ0LW5ld1wiLFxuICAgICAgICAgICAgYXJnczogW25ld1ZpZXddXG4gICAgICAgIH0sIG1vZGVsLl9vd25lciwgcGFyZW50RWxlbWVudCk7XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggYSBDdXN0b21FdmVudCBvbiB0aGUgcGFyZW50RWxlbWVudFxuICAgICAgICAvLyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBwYXJ0IGhhcyBiZWVuIGNyZWF0ZWQsIGFuZFxuICAgICAgICAvLyBhbnkgdmlldyB1dGlsaXRpZXMgdGhhdCBjYXJlIGNhbiBiZSBub3RpZmllZC5cbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzdC12aWV3LWFkZGVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcGFydFR5cGU6IG1vZGVsLnR5cGUsXG4gICAgICAgICAgICAgICAgcGFydElkOiBtb2RlbC5pZCxcbiAgICAgICAgICAgICAgICBvd25lcklkOiBtb2RlbC5fb3duZXIuaWQgfHwgbnVsbFxuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICAgICAgLy8gU2VlIGlmIHRoZXJlIGFyZSBsZW5zIHZpZXdzIGFuZCB1cGRhdGVcbiAgICAgICAgLy8gdGhvc2UgYXMgd2VsbFxuICAgICAgICBsZXQgbGVuc1ZpZXdzID0gdGhpcy5maW5kTGVuc1ZpZXdzQnlJZChwYXJlbnRJZCk7XG4gICAgICAgIGxlbnNWaWV3cy5mb3JFYWNoKGxlbnNWaWV3ID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdMZW5zVmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lRm9yVmlld05hbWVkKHBhcnROYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldE1vZGVsKG1vZGVsKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnLCBtb2RlbElkKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldEF0dHJpYnV0ZSgncm9sZScsICdsZW5zJyk7XG4gICAgICAgICAgICBsZW5zVmlldy5hcHBlbmRDaGlsZChuZXdMZW5zVmlldyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE8gZG8gd2Ugd2FudCB0byBhbGxvdyB0aGUgcG9zc2liaWxpeSBvZiBhIHZpZXcgb24gYW5cbiAgICAgICAgLy8gZWxlbWVudCBidXQgbm8gc3VicGFydCBvZiB0aGF0IHZpZXcgb24gdGhlIGVsZW1lbnQ/XG5cbiAgICAgICAgLy8gRm9yIGFsbCBzdWJwYXJ0cyBvZiB0aGlzIG1vZGVsLCBjYWxsXG4gICAgICAgIC8vIHRoZSBuZXdWaWV3IG1ldGhvZCByZWN1cnNpdmVseVxuICAgICAgICBtb2RlbC5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXdWaWV3KHN1YnBhcnQudHlwZSwgc3VicGFydC5pZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXdWaWV3O1xuICAgIH0sXG5cbiAgICByZWdpc3RlclBhcnQ6IGZ1bmN0aW9uKG5hbWUsIGNscyl7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlUGFydHNbbmFtZV0gPSBjbHM7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyVmlldzogZnVuY3Rpb24obmFtZSwgY2xzKXtcbiAgICAgICAgdGhpcy5hdmFpbGFibGVWaWV3c1tuYW1lXSA9IGNscztcbiAgICB9LFxuXG4gICAgdGFnTmFtZUZvclZpZXdOYW1lZDogZnVuY3Rpb24obmFtZSl7XG4gICAgICAgIHJldHVybiBgc3QtJHtuYW1lfWA7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IG1hdGNoaW5nIHZpZXcgZWxlbWVudFxuICAgIC8vIHdpdGggdGhlIGdpdmVuIGlkXG4gICAgZmluZFZpZXdCeUlkOiBmdW5jdGlvbihpZCl7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgfSxcblxuICAgIGZpbmRMZW5zVmlld3NCeUlkOiBmdW5jdGlvbihpZCl7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtsZW5zLXBhcnQtaWQ9XCIke2lkfVwiXWApKTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhbGwgbWF0Y2hpbmcgdmlldyBlbGVtZW50cyB3aXRoXG4gICAgLy8gdGhlIGdpdmVuIHBhcnQgaWRcbiAgICBmaW5kVmlld3NCeUlkOiBmdW5jdGlvbihpZCl7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbcGFydC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgbW9kZWwgY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBzdGFja1xuICAgIGdldEN1cnJlbnRTdGFja01vZGVsOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLmdldFdvcmxkU3RhY2tNb2RlbCgpO1xuICAgICAgICByZXR1cm4gd29ybGQuY3VycmVudFN0YWNrO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdGhlIG1vZGVsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgY2FyZFxuICAgIGdldEN1cnJlbnRDYXJkTW9kZWw6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmdldEN1cnJlbnRTdGFja01vZGVsKCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50U3RhY2suY3VycmVudENhcmQ7XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgbW9kZWwgY29ycmVzcG9uZGluZyB0byB0aGUgd29ybGQgc3RhY2tcbiAgICBnZXRXb3JsZFN0YWNrTW9kZWw6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRoZSBtb2RlbCBjb3JyZXNwb25kaW5nIHNjcmlwdCBlZGl0b3Igc3QtZmllbGRcbiAgICAvLyBOb3RlOiB3ZSB1c2UgdGhlIHdpbmRvdy5tb2RlbC50YXJnZXQgdG8gbG9jYXRlIHRoZSBjb3JyZXNwb25kaW5nIHdpbmRvd1xuICAgIC8vIGJ1dCByZXR1cm4gaXRzIHN0LWZpZWxkIHN1YnBhcnRcbiAgICBmaW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZDogZnVuY3Rpb24oaWQpe1xuICAgICAgICBsZXQgc2NyaXB0RWRpdG9yRmllbGQ7XG4gICAgICAgIGxldCB3aW5kb3dzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0LXdpbmRvd1wiKTtcbiAgICAgICAgd2luZG93cy5mb3JFYWNoKCh3KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdy5tb2RlbC50YXJnZXQ7XG4gICAgICAgICAgICBpZih0YXJnZXQgJiYgdGFyZ2V0LmlkID09PSBpZCl7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWRpdG9yRmllbGQgPSB3LnF1ZXJ5U2VsZWN0b3IoXCJzdC1maWVsZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzY3JpcHRFZGl0b3JGaWVsZDtcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICAgICAgaWYoIXdvcmxkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gd29ybGQgZm91bmQhYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcmlhbGl6ZXIgPSBuZXcgU1RTZXJpYWxpemVyKHRoaXMpO1xuICAgICAgICBsZXQgc2VyaWFsU3RyaW5nID0gc2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ10sIHRydWUpO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHNjcmlwdCB0YWcgaW4gdGhlXG4gICAgICAgIC8vIGJvZHkgZm9yIHRoZSBzZXJpYWxpemF0aW9uLCBjcmVhdGUgaXRcbiAgICAgICAgbGV0IHNlcmlhbGl6YXRpb25TY3JpcHRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXJpYWxpemF0aW9uJyk7XG4gICAgICAgIGlmKCFzZXJpYWxpemF0aW9uU2NyaXB0RWwpe1xuICAgICAgICAgICAgc2VyaWFsaXphdGlvblNjcmlwdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uU2NyaXB0RWwuaWQgPSAnc2VyaWFsaXphdGlvbic7XG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uU2NyaXB0RWwudHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNlcmlhbGl6YXRpb25TY3JpcHRFbCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXphdGlvblNjcmlwdEVsLnRleHRDb250ZW50ID0gc2VyaWFsU3RyaW5nO1xuICAgIH0sXG5cbiAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHNlcmlhbGl6YXRpb25FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXJpYWxpemF0aW9uJyk7XG4gICAgICAgIGlmKCFzZXJpYWxpemF0aW9uRWwpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzZXJpYWxpemF0aW9uIGZvdW5kIGZvciB0aGlzIHBhZ2VgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZXIgPSBuZXcgU1REZXNlcmlhbGl6ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbkVsLnRleHRDb250ZW50KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGEgKmNvbXBsZXRlKiBIVE1MXG4gICAgLy8gcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgYXBwbGljYXRpb25cbiAgICAvLyB0aGF0IGNhbiBsYXRlciBiZSBzYXZlZCB0byBhIGZpbGVcbiAgICBnZXRGdWxsSFRNTFN0cmluZzogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGNsb25lZERvY3VtZW50ID0gZG9jdW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBsZXQgd29ybGQgPSBjbG9uZWREb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpO1xuICAgICAgICBsZXQgbmF2ID0gY2xvbmVkRG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtbmF2aWdhdG9yJyk7XG4gICAgICAgIGlmKHdvcmxkKXtcbiAgICAgICAgICAgIHdvcmxkLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKG5hdil7XG4gICAgICAgICAgICBuYXYucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVkRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICB9LFxuXG5cbiAgICAvKiogTmF2aWdhdGlvbiBvZiBDdXJyZW50IFdvcmxkICoqL1xuICAgIGdvVG9OZXh0U3RhY2s6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICByZXR1cm4gd29ybGQuZ29Ub05leHRTdGFjaygpO1xuICAgIH0sXG5cbiAgICBnb1RvUHJldlN0YWNrOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICAgICAgcmV0dXJuIHdvcmxkLmdvVG9QcmV2U3RhY2soKTtcbiAgICB9LFxuXG4gICAgZ29Ub1N0YWNrQnlJZDogZnVuY3Rpb24oc3RhY2tJZCl7XG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICByZXR1cm4gd29ybGQuZ29Ub1N0YWNrQnlJZChzdGFja0lkKTtcbiAgICB9LFxuXG4gICAgLyoqIE5hdmlnYXRpb24gb2YgQ3VycmVudCBTdGFjayAqKi9cbiAgICBnb1RvTmV4dENhcmQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmdldEN1cnJlbnRTdGFja01vZGVsKCk7IFxuICAgICAgICByZXR1cm4gY3VycmVudFN0YWNrLmdvVG9OZXh0Q2FyZCgpO1xuICAgIH0sXG5cbiAgICBnb1RvUHJldkNhcmQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmdldEN1cnJlbnRTdGFja01vZGVsKCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50U3RhY2suZ29Ub1ByZXZDYXJkKCk7XG4gICAgfSxcblxuICAgIGdvVG9DYXJkQnlJZDogZnVuY3Rpb24oY2FyZElkKXtcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGFjay5nb1RvQ2FyZEJ5SWQoY2FyZElkKTtcbiAgICB9LFxuXG4gICAgb3BlbkVkaXRvckZvclBhcnQ6IGZ1bmN0aW9uKHBhcnRJZCl7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcihcbiAgICAgICAgICAgIHRoaXMucGFydHNCeUlkW3BhcnRJZF1cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub3BlbigpO1xuICAgIH0sXG5cbiAgICBjbG9zZUVkaXRvckZvclBhcnQ6IGZ1bmN0aW9uKHBhcnRJZCl7XG4gICAgICAgIHRoaXMuZWRpdG9yLmNsb3NlKCk7XG4gICAgfVxufTtcblxuLyoqIEFkZCBEZWZhdWx0IFN5c3RlbSBDb21tYW5kIEhhbmRsZXJzICoqL1xuLy9TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZGVsZXRlTW9kZWwnXSA9IFN5c3RlbS5kZWxldGVNb2RlbDtcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydkZWxldGVNb2RlbCddID0gZnVuY3Rpb24oc2VuZGVycywgLi4ucmVzdCl7XG4gICAgU3lzdGVtLmRlbGV0ZU1vZGVsKC4uLnJlc3QpO1xufTtcbi8vU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ25ld01vZGVsJ10gPSBTeXN0ZW0ubmV3TW9kZWw7XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3TW9kZWwnXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIC4uLnJlc3Qpe1xuICAgIFN5c3RlbS5uZXdNb2RlbCguLi5yZXN0KTtcbiAgICB0aGlzLnNlcmlhbGl6ZSgpO1xufTtcbi8vU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ25ld1ZpZXcnXSA9IFN5c3RlbS5uZXdWaWV3O1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ25ld1ZpZXcnXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIC4uLnJlc3Qpe1xuICAgIFN5c3RlbS5uZXdWaWV3KC4uLnJlc3QpO1xufTtcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyduZXdQcm9wZXJ0eSddID0gU3lzdGVtLm5ld1Byb3BlcnR5O1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ3NldFByb3BlcnR5J10gPSBTeXN0ZW0uc2V0UHJvcGVydHk7XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZGVsZXRlUHJvcGVydHknXSA9IFN5c3RlbS5kZWxldGVQcm9wZXJ0eTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2FzayddID0gZnVuY3Rpb24oc2VuZGVycywgcXVlc3Rpb24pe1xuICAgIC8vIFVzZSB0aGUgbmF0aXZlIEpTIHByb21wdCBmdW5jdGlvbiB0byBhc2sgdGhlIHF1ZXN0aW9uXG4gICAgLy8gYW5kIHJldHVybiBpdHMgdmFsdWUuXG4gICAgLy8gQnkgcmV0dXJuaW5nIGhlcmUsIHdlIGV4cGVjdCB0aGUgaW1wbGljaXQgdmFyaWFibGVcbiAgICAvLyBcIml0XCIgdG8gYmUgc2V0IGluc2lkZSBhbnkgY2FsbGluZyBzY3JpcHRcbiAgICByZXR1cm4gcHJvbXB0KHF1ZXN0aW9uKTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydwdXRJbnRvJ10gPSBmdW5jdGlvbihzZW5kZXJzLCB2YWx1ZSwgdmFyaWFibGVOYW1lLCBnbG9iYWwpe1xuICAgIGlmKGdsb2JhbCl7XG4gICAgICAgIFN5c3RlbS5leGVjdXRpb25TdGFjay5zZXRHbG9iYWwodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQmVjYXVzZSB3ZSBwdXNoIGFsbCBoYW5kbGVycyBvbnRvIHRoZSBleGVjdXRpb24gc3RhY2ssXG4gICAgLy8gdGhlIHB1dEludG8gaGFuZGxlciBpcyBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2suXG4gICAgLy8gSW4gb3JkZXIgdG8gbW9kaWZ5IHRoZSBjYWxsZXIncyB2YXJpYWJsZXMsIHdlIG5lZWQgdG9cbiAgICAvLyBmaW5kIHRoZSBjb250ZXh0IHRoYXQgaXMgb25lIHByZXZpb3VzIG9uIHRoZSBzdGFja1xuICAgIGlmKFN5c3RlbS5leGVjdXRpb25TdGFjay5wcmV2aW91cyl7XG4gICAgICAgIFN5c3RlbS5leGVjdXRpb25TdGFjay5wcmV2aW91cy5zZXRMb2NhbCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4ZWN1dGlvblN0YWNrIEVycm9yOiAjcHV0SW50byBvbiB0b3Agb2YgZW1wdHkgc3RhY2shYCk7XG4gICAgfVxufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2Fuc3dlciddID0gZnVuY3Rpb24oc2VuZGVycywgdmFsdWUpe1xuICAgIGFsZXJ0KHZhbHVlLnRvU3RyaW5nKCkpO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2dvIHRvIGRpcmVjdGlvbiddID0gZnVuY3Rpb24oc2VuZGVycywgZGlyZWN0aXZlLCBvYmplY3ROYW1lKXtcbiAgICBzd2l0Y2gob2JqZWN0TmFtZSkge1xuICAgICAgICBjYXNlICdjYXJkJzpcbiAgICAgICAgICAgIHN3aXRjaChkaXJlY3RpdmUpe1xuICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9OZXh0Q2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXZpb3VzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvUHJldkNhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdGFjayc6XG4gICAgICAgICAgICBzd2l0Y2goZGlyZWN0aXZlKXtcbiAgICAgICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvTmV4dFN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9QcmV2U3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYWxlcnQoYFwiZ28gdG9cIiBub3QgaW1wbGVtZW50ZWQgZm9yICR7b2JqZWN0TmFtZX1gKTtcblxuICAgIH1cbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydnbyB0byddID0gZnVuY3Rpb24oc2VuZGVycywgaWQpe1xuICAgIGxldCBtb2RlbCA9IHRoaXMucGFydHNCeUlkW2lkXTtcbiAgICBpZighbW9kZWwpe1xuICAgICAgICBhbGVydChgXCJnbyB0b1wiIHRhcmdldCBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgc3dpdGNoKG1vZGVsLnR5cGUpIHtcbiAgICBjYXNlICdjYXJkJzpcbiAgICAgICAgdGhpcy5nb1RvQ2FyZEJ5SWQoaWQpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgJ3N0YWNrJzpcbiAgICAgICAgdGhpcy5nb1RvU3RhY2tCeUlkKGlkKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgICBhbGVydChgXCJnbyB0b1wiIG5vdCBpbXBsZW1lbnRlZCBmb3IgJHttb2RlbC50eXBlfWApO1xuXG4gICAgfVxufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2dvIHRvIHdlYnNpdGUnXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHVybCl7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG59O1xuXG4vL0ltcG9ydCBhIHdvcmxkLCBpLmUuIGl0cyBzdGFja3MgZnJvbSBhbm90aGVyIHNvdXJjZVxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2ltcG9ydFdvcmxkJ10gPSBmdW5jdGlvbihzZW5kZXIsIHNvdXJjZVVybCl7XG4gICAgaWYoIXNvdXJjZVVybCl7XG4gICAgICAgIHNvdXJjZVVybCA9IHdpbmRvdy5wcm9tcHQoXCJDaG9vc2UgV29ybGQgbG9jYXRpb25cIik7XG4gICAgfVxuICAgIGZldGNoKHNvdXJjZVVybClcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgaWYoIWNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvaHRtbCcpKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29udGVudCB0eXBlOiAke2NvbnRlbnRUeXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKS50aGVuKGJsb2IgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWREb2N1bWVudCA9IERPTXBhcnNlci5wYXJzZUZyb21TdHJpbmcocmVhZGVyLnJlc3VsdCwgXCJ0ZXh0L2h0bWxcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIC5nZXRFbGVtZW50QnlJZCgpIGZvciBhIG5vZGUgSFRNTCBwYXJzZWQgZG9jdW1lbnQhXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uRWwgPSBwYXJzZWREb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2VyaWFsaXphdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBpZighc2VyaWFsaXphdGlvbkVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBzZXJpYWxpemF0aW9uIGZvdW5kIGZvciAke3NvdXJjZVVybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KGBXb3JsZCBcIiR7c291cmNlVXJsfVwiIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2VyaWFsaXplciA9IG5ldyBTVERlc2VyaWFsaXplcih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemVyLnRhcmdldElkID0gJ3dvcmxkJzsgLy8gV2Ugd2lsbCBpbnNlcnQgdGhlIHN0YWNrcyBpbnRvIHRoZSB3b3JsZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVyLmltcG9ydEZyb21TZXJpYWxpemF0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbkVsLnRleHRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gb25seSBTdGFja3MgdGhhdCBhcmUgZGlyZWN0IHN1YnBhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHdvcmxkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1N0YWNrID0gcGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzV29ybGRTdWJwYXJ0ID0gcGFydC5fb3duZXIgJiYgcGFydC5fb3duZXIudHlwZSA9PSAnd29ybGQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0YWNrICYmIGlzV29ybGRTdWJwYXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBfc3JjLlxuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaW5maW5pdGVseVxuICAgICAgICAgICAgLy8gY2FsbCB0aGUgbG9hZCBvcGVyYXRpb25cbiAgICAgICAgICAgIHRoaXMuX3NyYyA9IHNvdXJjZVVybDtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvLyBTdG9wIGFuZCByZXN0YXJ0IGhhbmQgaW50ZXJmYWNlIGlmIGl0J3MgcnVubmluZy5cbiAgICAgICAgICAgIGlmIChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaGFuZEludGVyZmFjZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgaGFuZEludGVyZmFjZS5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBhbGVydChcIkNvdWxkIG5vdCBsb2FkIHdvcmxkXCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydvcGVuU2NyaXB0RWRpdG9yJ10gPSBmdW5jdGlvbihzZW5kZXJzLCB0YXJnZXRJZCl7XG4gICAgbGV0IHRhcmdldCA9IHRoaXMucGFydHNCeUlkW3RhcmdldElkXTtcbiAgICBsZXQgdGFyZ2V0TmFtZSA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRhcmdldCwgXCJuYW1lXCIpO1xuICAgIGlmKHRhcmdldE5hbWUpe1xuICAgICAgICB0YXJnZXROYW1lID0gYFwiJHt0YXJnZXROYW1lfVwiYDtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBgU2NyaXB0IEZvciAke3RhcmdldC5uYW1lfSAke3RhcmdldE5hbWV9YDtcblxuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBkaW53byBvcGVuZWQgd2l0aCB0aGlzIG5hbWUsIHRoZW5cbiAgICAvLyB3ZSByZXR1cm4gd2l0aG91dCBjcmVhdGluZyBhbnl0aGluZyBuZXcuXG4gICAgbGV0IGZvdW5kID0gT2JqZWN0LnZhbHVlcyhTeXN0ZW0ucGFydHNCeUlkKS5maWx0ZXIocGFydCA9PiB7XG4gICAgICAgIGxldCBwYXJ0TmFtZTtcbiAgICAgICAgaWYocGFydC50eXBlID09ICd3aW5kb3cnKXtcbiAgICAgICAgICAgIHBhcnROYW1lID0gcGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgICAgJ3RpdGxlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHBhcnQudHlwZSA9PSAnd2luZG93JyAmJiBuYW1lID09IHBhcnROYW1lKTtcbiAgICB9KTtcbiAgICBpZihmb3VuZC5sZW5ndGgpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRDYXJkID0gdGhpcy5nZXRDdXJyZW50Q2FyZE1vZGVsKCk7XG4gICAgbGV0IHdpbmRvdyA9IHRoaXMubmV3TW9kZWwoJ3dpbmRvdycsIGN1cnJlbnRDYXJkLmlkKTtcbiAgICBsZXQgYXJlYSA9IHRoaXMubmV3TW9kZWwoJ2FyZWEnLCB3aW5kb3cuaWQpO1xuICAgIGxldCBzY3JpcHRGaWVsZCA9IHRoaXMubmV3TW9kZWwoJ2ZpZWxkJywgYXJlYS5pZCk7XG4gICAgbGV0IHNhdmVCdXR0b24gPSB0aGlzLm5ld01vZGVsKCdidXR0b24nLCBhcmVhLmlkKTtcblxuXG4gICAgLy8gc2V0dXAgdGhlIHdpbmRvdyBhbmQgc3RhY2sgcHJvcGVydGllc1xuICAgIHdpbmRvdy5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICB3aW5kb3cucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh3aW5kb3csIFwidGl0bGVcIiwgbmFtZSk7XG4gICAgd2luZG93LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQod2luZG93LCBcImhlaWdodFwiLCAyMDApO1xuICAgIHdpbmRvdy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHdpbmRvdywgXCJ3aWR0aFwiLCA1MDApO1xuICAgIHdpbmRvdy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHdpbmRvdywgJ3RvcCcsIDEwMCk7XG4gICAgd2luZG93LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQod2luZG93LCAnbGVmdCcsIDEwMCk7XG5cbiAgICBhcmVhLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoYXJlYSwgXCJsYXlvdXRcIiwgXCJsaXN0XCIpO1xuICAgIGFyZWEucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChhcmVhLCBcImxpc3QtZGlyZWN0aW9uXCIsIFwiY29sdW1uXCIpO1xuICAgIGFyZWEucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChhcmVhLCBcIndpZHRoXCIsIFwiZmlsbFwiKTtcbiAgICBhcmVhLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoYXJlYSwgXCJoZWlnaHRcIiwgXCJmaWxsXCIpO1xuXG4gICAgLy8gc2NyaXB0IGZpZWxkXG4gICAgbGV0IHRhcmdldFNjcmlwdCA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRhcmdldCwgXCJzY3JpcHRcIik7IFxuICAgIHNjcmlwdEZpZWxkLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2NyaXB0RmllbGQsIFwidGV4dFwiLCB0YXJnZXRTY3JpcHQpO1xuICAgIHNjcmlwdEZpZWxkLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2NyaXB0RmllbGQsIFwiaGVpZ2h0XCIsIFwiZmlsbFwiKTtcbiAgICBzY3JpcHRGaWVsZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNjcmlwdEZpZWxkLCBcIndpZHRoXCIsIFwiZmlsbFwiKTtcblxuICAgIC8vIFNldHVwIHN5bnRheCBoaWdobGlnaHRcbiAgICBzY3JpcHRGaWVsZC5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICBjb21tYW5kTmFtZTogXCJoaWdobGlnaHRTeW50YXhcIixcbiAgICAgICAgYXJnczogW11cbiAgICB9LCBzY3JpcHRGaWVsZCk7XG5cblxuICAgIC8vIHNldHVwIHVwIHRoZSBzYXZlIGJ1dHRvbiBwcm9wZXJ0aWVzXG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwibmFtZVwiLCBcIlNhdmUgU2NyaXB0XCIpO1xuICAgIHNhdmVCdXR0b24ucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzYXZlQnV0dG9uLCBcIndpZHRoXCIsIFwiZmlsbFwiKTtcbiAgICBzYXZlQnV0dG9uLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2F2ZUJ1dHRvbiwgXCJ0ZXh0LXNpemVcIiwgMjApO1xuICAgIHNhdmVCdXR0b24ucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzYXZlQnV0dG9uLCBcInRhcmdldFwiLCBgcGFydCBpZCAke3RhcmdldC5pZH1gKTtcblxuICAgIHNhdmVCdXR0b24ucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzYXZlQnV0dG9uLCBcInRhcmdldFwiLCBgcGFydCBpZCAke3RhcmdldC5pZH1gKTtcbiAgICBsZXQgc2F2ZVNjcmlwdCA9IGBvbiBjbGlja1xcblxcdHRlbGwgdGFyZ2V0IHRvIHNldCBcInNjcmlwdFwiIHRvIHRoZSBcInRleHRcIiBvZiBmaXJzdCBmaWVsZFxcbmVuZCBjbGlja2A7IFxuICAgIHNhdmVCdXR0b24ucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzYXZlQnV0dG9uLCBcInNjcmlwdFwiLCBzYXZlU2NyaXB0KTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydTaW1wbGVUYWxrJ10gPSBmdW5jdGlvbihzZW5kZXJzKXtcbiAgICByZXR1cm4gU3lzdGVtLmdyYW1tYXIuc291cmNlLnNvdXJjZVN0cmluZztcbn1cblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ29wZW5EZWJ1Z2dlciddID0gZnVuY3Rpb24oc2VuZGVycywgcGFydElkKXtcbiAgICBsZXQgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbcGFydElkXTtcbiAgICAvLyBDcmVhdGUgdGhlIEZpZWxkIG1vZGVsIGFuZCBhdHRhY2ggdG8gY3VycmVudCBjYXJkXG4gICAgbGV0IGN1cnJlbnRDYXJkID0gdGhpcy5nZXRDdXJyZW50Q2FyZE1vZGVsKCk7XG4gICAgbGV0IGZpZWxkTW9kZWwgPSB0aGlzLm5ld01vZGVsKCdmaWVsZCcsIGN1cnJlbnRDYXJkLmlkKTtcbiAgICBsZXQgdGV4dCA9IGBBdmFpbGFibGUgQ29tbWFuZHMgZm9yICR7dGFyZ2V0Lm5hbWV9IChpZCAke3RhcmdldC5pZH0pXFxuXFxuYDtcbiAgICBPYmplY3Qua2V5cyh0YXJnZXQuY29tbWFuZEhhbmRsZXJSZWdpc3RyeSkuZm9yRWFjaCgobmFtZSkgPT57XG4gICAgICAgIGxldCBpbmZvID0gdGFyZ2V0LmNvbW1hbmRIYW5kbGVyUmVnaXN0cnlbbmFtZV07XG4gICAgICAgIHRleHQgKz0gYCR7bmFtZX06ICR7SlNPTi5zdHJpbmdpZnkoaW5mbyl9XFxuYDtcbiAgICB9KTtcbiAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgIGZpZWxkTW9kZWwsXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgdGV4dFxuICAgICk7XG4gICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICBmaWVsZE1vZGVsLFxuICAgICAgICAnZWRpdGFibGUnLFxuICAgICAgICBmYWxzZVxuICAgICk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snc2F2ZUhUTUwnXSA9IGZ1bmN0aW9uKHNlbmRlcnMpe1xuICAgIC8vIFN0b3AgaGFuZCByZWNvZ25pdGlvbiBpZiBpdCdzIHJ1bm5pbmcuXG4gICAgbGV0IGhhbmRSZWNvZ25pdGlvbk9yaWdpbmFsbHlSdW5uaW5nID0gaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uUnVubmluZztcbiAgICBpZiAoaGFuZFJlY29nbml0aW9uT3JpZ2luYWxseVJ1bm5pbmcpIHtcbiAgICAgICAgaGFuZEludGVyZmFjZS5zdG9wKCk7XG4gICAgfVxuICAgIHRoaXMuc2VyaWFsaXplKCk7XG5cbiAgICBsZXQgc3RhbXAgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCk7XG4gICAgbGV0IHNlcmlhbGl6ZWRQYWdlID0gdGhpcy5nZXRGdWxsSFRNTFN0cmluZygpO1xuICAgIGxldCB0eXBlSW5mbyA9IFwiZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLThcIjtcbiAgICBsZXQgdXJsID0gYCR7dHlwZUluZm99LCR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlcmlhbGl6ZWRQYWdlKX1gO1xuXG4gICAgbGV0IGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhbmNob3Iuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGFuY2hvcik7XG4gICAgYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgYW5jaG9yLmRvd25sb2FkID0gYFNpbXBsZVRhbGtTbmFwc2hvdF8ke3N0YW1wfS5odG1sYDtcbiAgICBhbmNob3IuY2xpY2soKTtcbiAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgIGFuY2hvci5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGFuY2hvcik7XG4gICAgLy8gU3RhcnQgaGFuZCByZWNvZ25pdGlvbiBpZiBpdCB3YXMgcnVubmluZy5cbiAgICBpZiAoaGFuZFJlY29nbml0aW9uT3JpZ2luYWxseVJ1bm5pbmcpIHtcbiAgICAgICAgaGFuZEludGVyZmFjZS5zdGFydCgpO1xuICAgIH1cbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyd0ZWxsJ10gPSAoc2VuZGVycywgdGFyZ2V0SWQsIGRlZmVycmVkTWVzc2FnZSkgPT4ge1xuICAgIGxldCB0YXJnZXRQYXJ0ID0gU3lzdGVtLnBhcnRzQnlJZFt0YXJnZXRJZF07XG4gICAgaWYoIXRhcmdldFBhcnQpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byB0ZWxsIHBhcnQgaWQgJHt0YXJnZXRJZH06IG5vIHN1Y2ggcGFydCFgKTtcbiAgICB9XG4gICAgdGFyZ2V0UGFydC5zZW5kTWVzc2FnZShkZWZlcnJlZE1lc3NhZ2UsIHRhcmdldFBhcnQpO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ3RvZ2dsZUhhbmREZXRlY3Rpb24nXSA9ICgpID0+IHtcbiAgICBpZiAoaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uTW9kZWwgPT09IG51bGwpIHtcbiAgICAgICAgaGFuZEludGVyZmFjZS5zdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RvcCgpO1xuICAgIH1cbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydtZXJyaWFtJ10gPSAoc2VuZGVycywgZG9jSWQpID0+IHtcbiAgICBjb25zdCBzZW5kZXIgPSBTeXN0ZW0ucGFydHNCeUlkW3NlbmRlcnNbMF0uaWRdO1xuICAgIG1lcnJpYW1TaW1TY29yZShzZW5kZXIsIGRvY0lkKTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydnbG9iYWxJbnRlcnJ1cHQnXSA9ICgpID0+IHtcbiAgICAvLyBjeWNsZSB0aHJvdWdoIGFsbCB0aGUgcGFydHMgYW5kIHNldCB0aGUgXCJzdGVwcGluZ1wiIHByb3BlcnR5IHRvIGZhbHNlXG4gICAgT2JqZWN0LnZhbHVlcyhTeXN0ZW0ucGFydHNCeUlkKS5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgIGlmKHBhcnQuaXNTdGVwcGluZyl7XG4gICAgICAgICAgICBwYXJ0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQocGFydCwgXCJzdGVwcGluZ1wiLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqIFJlZ2lzdGVyIHRoZSBpbml0aWFsIHNldCBvZiBwYXJ0cyBpbiB0aGUgc3lzdGVtICoqL1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnY2FyZCcsIENhcmQpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnc3RhY2snLCBTdGFjayk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdmaWVsZCcsIEZpZWxkKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2J1dHRvbicsIEJ1dHRvbik7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCd3b3JsZCcsIFdvcmxkU3RhY2spO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnd2luZG93JywgV2luZG93KTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2ZpZWxkJywgRmllbGQpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnZHJhd2luZycsIERyYXdpbmcpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnaW1hZ2UnLCBJbWFnZSk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdhcmVhJywgQXJlYSk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdhdWRpbycsIEF1ZGlvKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2Jyb3dzZXInLCBCcm93c2VyKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ3Jlc291cmNlJywgUmVzb3VyY2UpO1xuXG4vKiogUmVnaXN0ZXIgdGhlIGluaXRpYWwgc2V0IG9mIHZpZXdzIGluIHRoZSBzeXN0ZW0gKiovXG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdidXR0b24nLCBCdXR0b25WaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ3N0YWNrJywgU3RhY2tWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ3dvcmxkJywgV29ybGRWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2NhcmQnLCBDYXJkVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCd3aW5kb3cnLCBXaW5kb3dWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2ZpZWxkJywgRmllbGRWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2RyYXdpbmcnLCBEcmF3aW5nVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdpbWFnZScsIEltYWdlVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdhcmVhJywgQXJlYVZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnYXVkaW8nLCBBdWRpb1ZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnYnJvd3NlcicsIEJyb3dzZXJWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ3Jlc291cmNlJywgUmVzb3VyY2VWaWV3KTtcblxuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGFkZGluZyBhbGwgb2YgdGhlXG4vLyBhdmFpbGFibGUgY3VzdG9tIGVsZW1lbnRzIHRvIHRoZSB3aW5kb3cgb2JqZWN0J3Ncbi8vIGN1c3RvbUVsZW1lbnRzIHJlZ2lzdHJ5XG5TeXN0ZW0ucmVnaXN0ZXJDdXN0b21FbGVtZW50cyA9IGZ1bmN0aW9uKCl7XG4gICAgT2JqZWN0LmtleXMoU3lzdGVtLmF2YWlsYWJsZVZpZXdzKS5mb3JFYWNoKHBhcnROYW1lID0+IHtcbiAgICAgICAgbGV0IHZpZXdDbGFzcyA9IFN5c3RlbS5hdmFpbGFibGVWaWV3c1twYXJ0TmFtZV07XG4gICAgICAgIGxldCBlbGVtZW50TmFtZSA9IFN5c3RlbS50YWdOYW1lRm9yVmlld05hbWVkKHBhcnROYW1lKTtcbiAgICAgICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZShlbGVtZW50TmFtZSwgdmlld0NsYXNzKTtcbiAgICB9KTtcbn07XG5cbi8vIGluaWl0YWxpemUgdGhlIGNvbXBpbGVyIGFuZCBhZGQgaXQgdG8gdGhlIHN5c3RlbVxuLy8gSW5zdGFudGlhdGUgdGhlIGdyYW1tYXIuXG5sZXQgbGFuZ3VhZ2VHcmFtbWFyO1xuaWYgKHdpbmRvdy5ncmFtbWFyKXtcbiAgICAvLyBmb3IgdGVzdGluZyBpdCBpcyBzb21ldGltZXMgY29udmVuaWVudCB0byBsb2FkIHRoZSBncmFtbWFyIGFuZCBhZGQgdG8gd2luZG93XG4gICAgLy8gc2VlIC4vdGVzdHMvcHJlbG9hZC5qcyBmb3IgZXhhbXBsZVxuICAgIGxhbmd1YWdlR3JhbW1hciA9IG9obS5ncmFtbWFyKHdpbmRvdy5ncmFtbWFyKTtcbn0gZWxzZSB7XG4gICAgbGFuZ3VhZ2VHcmFtbWFyID0gb2htLmdyYW1tYXJGcm9tU2NyaXB0RWxlbWVudCgpO1xufVxuXG5TeXN0ZW0uZ3JhbW1hciA9IGxhbmd1YWdlR3JhbW1hcjtcblxuLy8gU2V0IHRoZSBleGVjdGlvbiBzdGFjayBvbiB0aGVcbi8vIFN5c3RlbVxuU3lzdGVtLmV4ZWN1dGlvblN0YWNrID0gbmV3IEV4ZWN1dGlvblN0YWNrKCk7XG5cbi8vIEFkZCBhIGR5bmFtaWMgZ2V0dGVyIGZvciB0aGUgV29ybGQgZm9yIGNvbnZlbmllbmNlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3lzdGVtLCAnd29ybGQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgfVxufSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgLy8gQWRkIHRoZSBTeXN0ZW0gb2JqZWN0IHRvIHdpbmRvdyBzb1xuICAgIC8vIHRoYXQgaXQgaXMgZ2xvYmFsIG9uIHRoZSBwYWdlLiBXZSBkbyB0aGlzXG4gICAgLy8gZm9yIGJvdGggZGVidWdnaW5nIGFuZCB0ZXN0aW5nLlxuICAgIHdpbmRvdy5TeXN0ZW0gPSBTeXN0ZW07XG4gICAgLy8gQWRkIHRoZSBwb3NzaWJsZSB2aWV3cyBhcyB3ZWJjb21wb25lbnRzXG4gICAgLy8gaW4gdGhlIGN1c3RvbSBlbGVtZW50IHJlZ2lzdHJ5XG4gICAgU3lzdGVtLnJlZ2lzdGVyQ3VzdG9tRWxlbWVudHMoKTtcblxuICAgIC8vIEFkZCBhbnkgb3RoZXIgbm9uLXBhcnQgdmlldyBDdXN0b21FbGVtZW50cyxcbiAgICAvLyBsaWtlIHRoZSBoYWxvXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3QtaGFsbycsIEhhbG8pO1xuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0LW5hdmlnYXRvcicsIFNUTmF2aWdhdG9yKTtcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdC1lZGl0b3InLCBFZGl0b3IpO1xuXG4gICAgLy8gQWRkIG5hdlxuICAgIFN5c3RlbS5uYXZpZ2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1uYXZpZ2F0b3InKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFN5c3RlbS5uYXZpZ2F0b3IpO1xuXG4gICAgLy8gQWRkIGNvbXByZWhlbnNpdmUgZWRpdG9yIHBhbmVcbiAgICAvLyBpZiBvbmUgaXMgbm90IGFscmVhZHkgcHJlc2VudCBpbiB0aGUgbWFya3VwXG4gICAgbGV0IGV4aXN0aW5nRWRpdG9ycyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3QtZWRpdG9yJykpO1xuICAgIGV4aXN0aW5nRWRpdG9ycy5mb3JFYWNoKGVkaXRvckVsID0+IHtcbiAgICAgICAgZWRpdG9yRWwucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgU3lzdGVtLmVkaXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWVkaXRvcicpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoU3lzdGVtLmVkaXRvcik7XG5cbiAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIHNldHVwIG9mXG4gICAgLy8gdGhlIHN5c3RlbVxuICAgIFN5c3RlbS5pbml0aWFsTG9hZCgpO1xufSk7XG5cbi8vIGFkZCBhIG1lc3NhZ2UgbGlzdGVuZXIgb24gd2luZG93XG4vLyB0aGVzZSBjYW4gaW5jbHVkZSBtZXNzYWdlIGZyb20gYSBicm93c2VyIHBhcnRcbi8vIGZvciBub3cgZmlsdGVyIHRob3NlIG5vdCBjb21pbmcgZnJvbSB0aGUgb3JpZ2luXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gd2luZG93Lm9yaWdpbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKGBNZXNzYWdlIHRvIGJyb3dzZXJgKTtcbiAgICAvLyBUT0RPOiBtYXliZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBxdW90ZSBlc2NhcGVzIGRpcmVjdGx5XG4gICAgLy8gaW4gdGhlIGdyYW1tYXJcbiAgICBsZXQgc2NyaXB0ID0gZXZlbnQuZGF0YS5yZXBsYWNlQWxsKFwiJ1wiLCAnXCInKTtcbiAgICAvLyBvbmx5IHN0YXRlbWVudHMgYXJlIGFjY2VwdGVkIGZvciBub3dcbiAgICBsZXQgcGFyc2VkU2NyaXB0ID0gbGFuZ3VhZ2VHcmFtbWFyLm1hdGNoKHNjcmlwdCwgXCJTdGF0ZW1lbnRcIik7XG4gICAgaWYocGFyc2VkU2NyaXB0LmZhaWxlZCgpKXtcbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IGxvZyB0aGF0IGl0IGZhaWxlZFxuICAgICAgICBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBzY3JpcHQgZm9yIGJyb3dzZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNlbWFudGljcyA9IGxhbmd1YWdlR3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgbGV0IHdvcmxkID0gU3lzdGVtLnBhcnRzQnlJZFtcIndvcmxkXCJdO1xuICAgICAgICBzZW1hbnRpY3MuYWRkT3BlcmF0aW9uKFxuICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICBpbnRlcnByZXRlclNlbWFudGljcyh3b3JsZCwgU3lzdGVtKVxuICAgICAgICApO1xuICAgICAgICBsZXQgbXNnID0gc2VtYW50aWNzKHBhcnNlZFNjcmlwdCkuaW50ZXJwcmV0KCk7XG4gICAgICAgIFN5c3RlbS5zZW5kTWVzc2FnZShtc2csIHdvcmxkLCBTeXN0ZW0pO1xuICAgIH1cbn0pO1xuXG4vLyBnbG9iYWwgaW50ZXJydXB0XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgaWYoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkgPT0gJ2MnKXtcbiAgICAgICAgU3lzdGVtLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZ2xvYmFsSW50ZXJydXB0XCIsXG4gICAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICB9LCBTeXN0ZW0sIFN5c3RlbSk7XG4gICAgfVxufSk7XG5cblxuZXhwb3J0IHtcbiAgICBTeXN0ZW0sXG4gICAgU3lzdGVtIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEFyZWFcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBBcmVhIFBhcnQuXG4gKiBJIHJlcHJlc2VudCBhICdncm91cGluZycgb2Ygc3VicGFydHMgd2l0aGluXG4gKiBteSBvd25lciBwYXJ0LlxuICogSSBjb250YWluIHRoZSBMYXlvdXQgcHJvcGVydGllcyBzZXQsIGFuZCB0aGVyZWZvcmVcbiAqIGNhbiBkaXNwbGF5IG15IGNvbnRhaW5lZCBzdWJwYXJ0cyBhY2NvcmRpbmcgdG8gXG4gKiBkaWZmZXJlbnQgbGF5b3V0IHByb3BlcnRpZXMgdGhhbiBteSBhbmNlc3RvclxuICogQ2FyZC5cbiAqXG4gKi9cbmltcG9ydCB7UGFydH0gZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRMYXlvdXRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jbGFzcyBBcmVhIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImFyZWFcIixcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBcImZpZWxkXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgICAgICBcInJlc291cmNlXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdcIixcbiAgICAgICAgICAgIFwiYnJvd3NlclwiLFxuICAgICAgICAgICAgXCJ3aW5kb3dcIlxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEFkZCBzdHlsZSBwcm9wc1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkTGF5b3V0U3R5bGVQcm9wcyh0aGlzKTtcblxuICAgICAgICAvLyBTZXQgZGVmYXVsdCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIC8vIGZvciBhbiBlbXB0eSBhcmVhXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgNTBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgNTBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnY2xpcHBpbmcnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnYWxsb3ctc2Nyb2xsaW5nJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwicmdiKDIzOCwgMjM4LCAyMzgpXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LXRyYW5zcGFyZW5jeWAsXG4gICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2FyZWEnO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQXJlYSxcbiAgICBBcmVhIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkVGV4dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQXVkaW8gZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgc3JjKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNyYyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVhZHlTdGF0ZScsXG4gICAgICAgICAgICBcIkhBVkVfTk9USElOR1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInBsYXlcIixcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInN0b3BcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJsb2FkQXVkaW9Gcm9tU291cmNlXCIsIHRoaXMubG9hZEF1ZGlvRnJvbVNvdXJjZSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwicGxheVwiLCAoKSA9PiB7dGhpcy5wbGF5KHRydWUpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInBhdXNlXCIsICgpID0+IHt0aGlzLnBsYXkoZmFsc2UpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInN0b3BcIiwgdGhpcy5zdG9wKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMubG9hZEF1ZGlvRnJvbVNvdXJjZSA9IHRoaXMubG9hZEF1ZGlvRnJvbVNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBsYXkgPSB0aGlzLnBsYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdG9wID0gdGhpcy5zdG9wLmJpbmQodGhpcyk7XG5cblxuICAgICAgICAvLyBsb2FkIHRoZSBzcmMgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYoc3JjKXtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInNyY1wiLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFRleHRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC10cmFuc3BhcmVuY3knLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl0uZm9yRWFjaCgoc2lkZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3NpZGV9LXdpZHRoYCxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2F1ZGlvJztcbiAgICB9XG5cbiAgICBsb2FkQXVkaW9Gcm9tU291cmNlKHNlbmRlcnMsIHNvdXJjZVVybCl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInNyY1wiLCBzb3VyY2VVcmwpO1xuICAgIH1cblxuICAgIHBsYXkodmFsdWUpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJwbGF5XCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3RvcFwiLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgc3RvcCgpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJwbGF5XCIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3RvcFwiLCB0cnVlKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEF1ZGlvLFxuICAgIEF1ZGlvIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkVGV4dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQnJvd3NlciBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBzcmMpIHtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuXG4gICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3JjID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVhZHlTdGF0ZScsXG4gICAgICAgICAgICBcIkhBVkVfTk9USElOR1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInBsYXlcIixcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInN0b3BcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzZXRVUkxUb1wiLCB0aGlzLnNldFVSTCk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiZm9yd2FyZFwiLCB0aGlzLnNlbmRNZXNzYWdlVG9Ccm93c2VyKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0VVJMID0gdGhpcy5zZXRVUkwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQnJvd3NlciA9IHRoaXMuc2VuZE1lc3NhZ2VUb0Jyb3dzZXIuYmluZCh0aGlzKTtcblxuXG4gICAgICAgIC8vIGxvYWQgdGhlIHNyYyBpZiBwcm92aWRlZFxuICAgICAgICBpZihzcmMpe1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3R5bGUgcHJvcGVydGllc1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzaWRlfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICAgICA0MDAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdicm93c2VyJztcbiAgICB9XG5cbiAgICBzZXRVUkwoc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwic3JjXCIsIHNvdXJjZVVybCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2VUb0Jyb3dzZXIoc2VuZGVycywgbWVzc2FnZSl7XG4gICAgICAgIGxldCB2aWV3cyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0aGlzLmlkKTtcbiAgICAgICAgdmlld3MuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgbGV0IGlmcmFtZSA9IHYuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKTtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHdpbmRvdy5vcmlnaW4pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEJyb3dzZXIsXG4gICAgQnJvd3NlciBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBCdXR0b25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBCdXR0b24gUGFydC5cbiAqIE15IG93bmVyIGlzIGFsd2F5cyBhIENhcmQuXG4gKiBJIGFtIGEgY2xpY2thYmxlIHBvaW50IG9mIGludGVyYWN0aW9uIG9uIGEgQ2FyZCxcbiAqIHdob3NlIGZ1bmN0aW9uYWxpdHkgY2FuIGJlIGN1c3RvbWl6ZWQgYnkgdGhlIGF1dGhvci5cbiAqL1xuaW1wb3J0IFBhcnQgZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCB7XG4gICAgQmFzaWNQcm9wZXJ0eSxcbiAgICBEeW5hbWljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkVGV4dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQnV0dG9uIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpe1xuICAgICAgICBzdXBlcihvd25lcik7XG5cbiAgICAgICAgdGhpcy5pc0J1dHRvbiA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIEJ1dHRvbi1zcGVjaWZpYyBwYXJ0IHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICdzZWxlY3RlZFRleHQnLFxuICAgICAgICAgICAgbnVsbCwgLy8gcmVhZE9ubHkgKGZvciBub3cpXG4gICAgICAgICAgICB0aGlzLmdldFNlbGVjdGVkVGV4dCxcbiAgICAgICAgICAgIHRydWUsIC8vIHJlYWRPbmx5LFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0eWxpbmdcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFRleHRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcInJnYigyNTUsIDIzNCwgMTQ5KVwiLCAvLyB2YXIoLS1wYWxldHRlLXllbGxvdylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjb3JuZXItdG9wLWxlZnQtcm91bmQnLFxuICAgICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2Nvcm5lci10b3AtcmlnaHQtcm91bmQnLFxuICAgICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2Nvcm5lci1ib3R0b20tbGVmdC1yb3VuZCcsXG4gICAgICAgICAgICAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY29ybmVyLWJvdHRvbS1yaWdodC1yb3VuZCcsXG4gICAgICAgICAgICAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYm9yZGVyLXRvcC13aWR0aCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYm9yZGVyLWJvdHRvbS13aWR0aCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYm9yZGVyLWxlZnQtd2lkdGgnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JvcmRlci1yaWdodC13aWR0aCcsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnc2hhZG93LWxlZnQnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3NoYWRvdy10b3AnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3NoYWRvdy1ibHVyJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdzaGFkb3ctYmx1cicsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG5cbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpe1xuICAgICAgICByZXR1cm4gJ2J1dHRvbic7XG4gICAgfVxuXG4gICAgLy9UT0RPOiBpbXBsZW1lbnQgdGhpcyBwcm9wZXJ0eVxuICAgIC8vIGdldHRlciBmb3IgcmVhbFxuICAgIGdldFNlbGVjdGVkVGV4dChwcm9wTmFtZSwgcHJvcFZhbCl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQnV0dG9uLFxuICAgIEJ1dHRvbiBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBDYXJkXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIENhcmQgUGFydC5cbiAqIEkgcmVwcmVzZW50IGEgY29sbGVjdGlvbiBvZiBQYXJ0cyB0aGF0IGlzXG4gKiBkaXNwbGF5ZWQgb24gdGhlIHNjcmVlbi4gTXkgb3duZXIgaXMgYWx3YXlzXG4gKiBhIFN0YWNrIFBhcnQuXG4gKiBJIGNhbiBjb250YWluIGFueSBraW5kIG9mIFBhcnQsIGluY2x1ZGluZ1xuICogYnV0dG9ucyBhbmQgZmllbGRzLlxuICovXG5pbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIEJhc2ljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmltcG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZExheW91dFN0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgQ2FyZCBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBuYW1lKXtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5fb3duZXI7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcIndpbmRvd1wiLCBcImJ1dHRvblwiLFxuICAgICAgICAgICAgXCJmaWVsZFwiLCBcImFyZWFcIiwgXCJkcmF3aW5nXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsIFwiYXVkaW9cIiwgXCJicm93c2VyXCIsIFwicmVzb3VyY2VcIlxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmlzQ2FyZCA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIENhcmQtc3BlY2lmaWMgcGFydFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ21hcmtlZCcsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdjYW50RGVsZXRlJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2RvbnRTZWFyY2gnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnc2hvd1BpY3QnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgaW5pdGlhbGl6aW5nIHdpdGggYSBuYW1lXG4gICAgICAgIC8vIHNldCB0aGUgbmFtZSBwcm9wZXJ0eVxuICAgICAgICBpZihuYW1lKXtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZExheW91dFN0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgIFwicmdiKDAsIDc1LCAxMDMpXCIgLy8gcGFsZXR0ZS1ibHVlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdjYXJkJztcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIENhcmQsXG4gICAgQ2FyZCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBCYXNpYyBVc2VyIERyYXdpbmcgUGFydFxuICovXG5pbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY29uc3Qgc2lkZXMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5cbmNsYXNzIERyYXdpbmcgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcil7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBTZXQgbmV3IHByb3BlcnRpZXMgZm9yIHRoaXNcbiAgICAgICAgLy8gcGFydCB0eXBlXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICAnZHJhd2luZydcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU3R5bGVcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwicmdiKDIzOCwgMjM4LCAyMzgpXCIsIC8vZ3JleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS10cmFuc3BhcmVuY3lgLFxuICAgICAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgIDMwMFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAyMDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBXZSBhcmUgdXNpbmcgYSBkaXN0aW5jdCBzaG93LWJvcmRlclxuICAgICAgICAvLyBwcm9wZXJ0eSB0byBkZWFsIHdpdGggYmVpbmcgYWJsZSB0byBzZWVcbiAgICAgICAgLy8gYSBkcmF3aW5nIHRoYXQgaXMgZW1wdHlcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnc2hvdy1ib3JkZXInLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFdoZW4gZHJhd2luZyBmcm9tIGEgc2NyaXB0L2NvbW1hbmRzLFxuICAgICAgICAvLyB3ZSB3aWxsIHVzZSB0aGlzIGFzIHRoZSBvcGVuIGNhbnZhc1xuICAgICAgICAvLyB3aG9zZSBpbWFnZSBieXRlcyB3aWxsIGJlIHNldCB0byB0aGVcbiAgICAgICAgLy8gaW1hZ2UgcHJvcGVydHlcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBudWxsO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgZHJhd2luZyBjb21tYW5kc1xuICAgICAgICB0aGlzLnNldHVwRHJhd2luZ0NvbW1hbmRzKCk7XG5cblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0dXBEcmF3aW5nQ29tbWFuZHMgPSB0aGlzLnNldHVwRHJhd2luZ0NvbW1hbmRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gdGhpcy5zdHJva2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlVG8gPSB0aGlzLm1vdmVUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxpbmVUbyA9IHRoaXMubGluZVRvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVnaW5EcmF3ID0gdGhpcy5iZWdpbkRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmREcmF3ID0gdGhpcy5lbmREcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXIgPSB0aGlzLmNsZWFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29vcmRzRnJvbVN0cmluZyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnZHJhd2luZyc7XG4gICAgfVxuXG4gICAgc2V0dXBEcmF3aW5nQ29tbWFuZHMoKXtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ2xpbmVUbycsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdtb3ZlVG8nLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignYmVnaW5EcmF3JywgKHNlbmRlcnMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5EcmF3KC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ2ZpbmlzaERyYXcnLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmREcmF3KC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ3N0cm9rZScsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdjbGVhcicsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBTY3JpcHRhYmxlIERyYXdpbmcgQ29tbWFuZHMgKi9cbiAgICBzdHJva2UoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgLy8gSGFyZC1jb2RlZC4gR2V0IGZyb20gcHJvcHNcbiAgICAgICAgICAgIC8vIGFuZCBsaW5rIHRvIHZpZXdzXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQuc3Ryb2tlV2lkdGggPSAxMDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlVG8oeCwgeSl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIC8vbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZyhjb29yZFBhaXIpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0Lm1vdmVUbyhcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5lVG8oeCwgeSl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIC8vbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZyhjb29yZFBhaXIpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWdpbkRyYXcoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEcmF3aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMud2lkdGggPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3dpZHRoJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcy5oZWlnaHQgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2hlaWdodCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0ID0gdGhpcy5hY3RpdmVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBjdXJyZW50bHkgaW1hZ2UgZGF0YSBzZXQgdG8gdGhlXG4gICAgICAgIC8vIGltYWdlIHBhcnQgcHJvcGVydHksIHdlIG5lZWQgdG8gZHJhdyB0aGF0IGltYWdlXG4gICAgICAgIC8vIG9udG8gdGhlIGNhbnZhcyBmaXJzdC5cbiAgICAgICAgbGV0IGN1cnJlbnRJbWFnZSA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaW1hZ2UnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRJbWFnZSl7XG4gICAgICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gY3VycmVudEltYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVnaW4gYSBkcmF3aW5nIHBhdGhcbiAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGVuZERyYXcoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGltYWdlIHByb3BlcnR5IHRvIGJlIHRoZVxuICAgICAgICAgICAgLy8gc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHVwZGF0ZSBhbnkgc3Vic2NyaWJlZCB2aWV3c1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcy50b0RhdGFVUkwoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzRHJhd2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzLndpZHRoID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICd3aWR0aCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMuaGVpZ2h0ID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dCA9IHRoaXMuYWN0aXZlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMudG9EYXRhVVJMKClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qIFV0aWxpdHkgTWV0aG9kcyBmb3IgU2NyaXB0YWJsZSBEcmF3aW5nICovXG4gICAgY29vcmRzRnJvbVN0cmluZyhjb29yZFN0cmluZyl7XG4gICAgICAgIGxldCBwYWlyID0gY29vcmRTdHJpbmcuc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgeCA9IHBhcnNlSW50KHBhaXJbMF0pO1xuICAgICAgICBsZXQgeSA9IHBhcnNlSW50KHBhaXJbMV0pO1xuICAgICAgICByZXR1cm4ge3gsIHl9O1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRHJhd2luZyxcbiAgICBEcmF3aW5nIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEZpZWxkXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIEZpZWxkIFBhcnQuXG4gKiBJIGFtIGEgY29udGFpbmVyIHRoYXQgaG9sZHMgdGV4dC4gSSBhbHNvIGFsbG93XG4gKiBhIHVzZXIgdG8gZWRpdCBteSB0ZXh0LlxuICovXG5pbXBvcnQgUGFydCBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcblxuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jbGFzcyBGaWVsZCBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBuYW1lKXtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXCJmaWVsZFwiXTtcblxuICAgICAgICB0aGlzLmlzRmllbGQgPSB0cnVlO1xuXG4gICAgICAgIGlmKG5hbWUpe1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIEZpZWxkLXNwZWNpZmljXG4gICAgICAgIC8vIFBhcnQgUHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdtb2RlJyxcbiAgICAgICAgICAgICdlZGl0aW5nJyAvL1RPRE8gdGhpcyBzaG91bGQgYmUgZWl0aGVyIFwiYnJhdm9cIiBvciBcInNpbXBsZXRhbGtcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAgICAgICAnJ1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3RhcmdldFJhbmdlSWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vICd0ZXh0JyBpcyBhIER5bmFtaWNQcm9wZXJ0eSBjb25maWd1cmVkIHRvIGFsc28gc2V0IHRoZSBpbm5lckhUTUxcbiAgICAgICAgLy8gQmFzaWNQcm9wZXJ0eSB3aGVuIGNoYW5nZWQuIFRoZSBiYXNpYyBpZGVhIGlzIHRoYXQgJ3RleHQnIHdpbGwgYmVcbiAgICAgICAgLy8gdGhlIHByb3BlcnR5IHRoYXQgU1Qgd2lsbCBpbnRlcmZhY2Ugd2l0aCBhbmQgZXZlcnl0aW1lIGl0XG4gICAgICAgIC8vIGlzIGNoYW5nZWQgdGhlICdpbm5lckhUTUwnIHByb3BlcnR5IHNob3VsZCBmb2xsb3cuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAob3duZXIsIHByb3AsIHZhbHVlLCBub3RpZnkpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9wLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmKG5vdGlmeSl7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgYWxsIG5ld2xpbmUgY2hhcmFjdGVycyB3aXRoIDxicj5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpO1xuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG93bmVyLCAnaW5uZXJIVE1MJywgdmFsdWUsIG5vdGlmeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChvd25lciwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wLl92YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICAgICAgJycgICAgIC8vIGRlZmF1bHQgaXMgZW1wdHkgc3RyaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnZWRpdGFibGUnLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG5cbiAgICAgICAgLy8gQSBudW1iZXIgb2YgdGhlIHByb3BzIGRlYWwgd2l0aCBkaXJlY3QgdGV4dCBlZGl0aW5nLFxuICAgICAgICAvLyBhbmQgc28gdGhleSBhcmUgbGlrZSBjb21tYW5kcy4gRXhhbXBsZXMgaW5jbHVkZSBcInVuZG9cIlxuICAgICAgICAvLyBcInJlZG9cIiBcImNsZWFyXCIgZXRjLiBIZXJlIHdlIHVzZSBkeW5hbWkgcHJvcHMgd2hpY2ggdGhlXG4gICAgICAgIC8vIHZpZXcgY2FuIHJlc3BvbmQgdG8gYWNjb3JkaW5nbHksIGJ1dCBoYXZpbmcgdGhlc2UgcHJvcHMgaGF2ZVxuICAgICAgICAvLyBubyBhY3R1YWwgJ3N0YXRlJ1xuICAgICAgICAvKiogVE9ETzogdGhlc2Ugc2hvdWxkIGJlIHByaXZhdGUgY29tbWFuZHNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgIFwidW5kb1wiLFxuICAgICAgICAgICAgKCkgPT4ge30sIC8vIGFsbCB3ZSBpcyBhIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgKCkgPT4ge30gLy8gbm8gZ2V0dGVyXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICBcInJlZG9cIixcbiAgICAgICAgICAgICgpID0+IHt9LCAvLyBhbGwgd2UgaXMgYSBub3RpZmljYXRpb25cbiAgICAgICAgICAgICgpID0+IHt9IC8vIG5vIGdldHRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgXCJyZW1vdmUtZm9ybWF0XCIsXG4gICAgICAgICAgICAoKSA9PiB7fSwgLy8gYWxsIHdlIGlzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAoKSA9PiB7fSAvLyBubyBnZXR0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgKiovXG5cbiAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICAvLyBzZXR0aW5nIHdpZHRoIGFuZCBoZWlnaHQgdG8gbnVsbFxuICAgICAgICAvLyBlZmZlY3RpdmVseSBmb3JjZXMgdG8gdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAgICAvLyBvZiB0aGUgYnV0dG9uIHRvIGZpdCB0aGUgYnV0dG9uIG5hbWVcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFRleHRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcInJnYigyNTUsIDI0OCwgMjIwKVwiLCAvLyB2YXIoLS1wYWxldHRlLWNvcm5zaWspXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgXCJtZWRpdW1cIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tc3R5bGVgLFxuICAgICAgICAgICAgICAgIFwic29saWRcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwiYmxhY2tcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgICAgIFwiMVwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICAgICA0MDAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG5cbiAgICAgICAgdGhpcy5pbnNlcnRSYW5nZSA9IHRoaXMuaW5zZXJ0UmFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24gPSB0aGlzLnNldFNlbGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImluc2VydFJhbmdlXCIsIHRoaXMuaW5zZXJ0UmFuZ2UpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInNldFNlbGVjdGlvblwiLCB0aGlzLnNldFNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiaGlnaGxpZ2h0U3ludGF4XCIsIHRoaXMuaGlnaGxpZ2h0U3ludGF4KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJ1bmhpZ2hsaWdodFN5bnRheFwiLCB0aGlzLnVuaGlnaGxpZ2h0U3ludGF4KTtcbiAgICB9XG5cbiAgICBpbnNlcnRSYW5nZShzZW5kZXJzLCByYW5nZUlkLCBodG1sLCBjc3Mpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGhpcy5pZCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy5pbnNlcnRSYW5nZShyYW5nZUlkLCBodG1sLCBjc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb24oc2VuZGVycywgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKXtcbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IGFsbG93IHByb3BlcnRpZXMgb2YgdHlwZSBcInRleHQtKlwiIHRvIGJlIHNldFxuICAgICAgICBpZihwcm9wZXJ0eU5hbWUuc3RhcnRzV2l0aChcInRleHQtXCIpKXtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0aGlzLmlkKS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRTZWxlY3Rpb24ocHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCB2aWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5pZCk7XG4gICAgICAgIGlmKHZpZXcpe1xuICAgICAgICAgICAgdmlldy5oaWdobGlnaHRTeW50YXgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCB2aWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5pZCk7XG4gICAgICAgIGlmKHZpZXcpe1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodFN5bnRheCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdmaWVsZCc7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBGaWVsZCxcbiAgICBGaWVsZCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuXG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgSW1hZ2UgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgc3JjKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgdGhpcy5zZXRTb3VyY2UsXG4gICAgICAgICAgICB0aGlzLmdldFNvdXJjZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3NyYyA9IHNyYztcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwibWltZVR5cGVcIixcbiAgICAgICAgICAgIFwidW5rbm93blwiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcImltYWdlRGF0YVwiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2RyYWdnYWJsZScsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcImJsYWNrXCJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJsb2FkSW1hZ2VGcm9tXCIsIHRoaXMubG9hZEltYWdlRnJvbVNvdXJjZSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZEltYWdlRnJvbUZpbGVcIiwgdGhpcy5sb2FkSW1hZ2VGcm9tRmlsZSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLmxvYWRJbWFnZUZyb21Tb3VyY2UgPSB0aGlzLmxvYWRJbWFnZUZyb21Tb3VyY2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2VGcm9tRmlsZSA9IHRoaXMubG9hZEltYWdlRnJvbUZpbGUuYmluZCh0aGlzKTtcbiAgICB9XG5cblxuICAgIGxvYWRJbWFnZUZyb21Tb3VyY2Uoc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgZmV0Y2goc291cmNlVXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICBpZighY29udGVudFR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UnKSl7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbWFnZSBtaW1lVHlwZTogJHtjb250ZW50VHlwZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbWVUeXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZihjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiaW1hZ2Uvc3ZnXCIpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKHRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKS50aGVuKGJsb2IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXN1bHQgLy8gd2lsbCBiZSB0aGUgYmFzZTY0IGVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBfc3JjLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGluZmluaXRlbHlcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBsb2FkIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuX3NyYyA9IHNvdXJjZVVybDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAnaW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2FkSW1hZ2VGcm9tRmlsZSgpe1xuICAgICAgICBsZXQgZmlsZVBpY2tlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGZpbGVQaWNrZXIudHlwZSA9ICdmaWxlJztcbiAgICAgICAgZmlsZVBpY2tlci5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsICdpbWFnZS8qJyk7XG4gICAgICAgIGZpbGVQaWNrZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZmlsZVBpY2tlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZmlsZSBoZXJlXG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAnbWltZVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICBmaWxlUGlja2VyLmZpbGVzWzBdLnR5cGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXN1bHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBpbWFnZUZpbGUgPSBmaWxlUGlja2VyLmZpbGVzWzBdO1xuICAgICAgICAgICAgaWYoaW1hZ2VGaWxlLnR5cGUuaW5jbHVkZXMoJ3N2ZycpKXtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChpbWFnZUZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZUZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVBpY2tlci5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGZpbGVQaWNrZXIpO1xuICAgICAgICBmaWxlUGlja2VyLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlKG93bmVyLCBwcm9wZXJ0eSwgdmFsdWUpe1xuICAgICAgICBvd25lci5fc3JjID0gdmFsdWU7XG4gICAgICAgIGlmKHZhbHVlKXtcbiAgICAgICAgICAgIG93bmVyLmxvYWRJbWFnZUZyb21Tb3VyY2UoW3RoaXNdLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTb3VyY2Uob3duZXIsIHByb3BlcnR5KXtcbiAgICAgICAgcmV0dXJuIG93bmVyLl9zcmM7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgfVxuXG4gICAgZ2V0IGlzU3ZnKCl7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIm1pbWVUeXBlXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYoIW1pbWVUeXBlKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW1lVHlwZS5zdGFydHNXaXRoKCdpbWFnZS9zdmcnKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEltYWdlLFxuICAgIEltYWdlIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFBhcnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgcmVwcmVzZW50IHRoZSBwcm90b3R5cGUgb2JqZWN0IGZvciBhbGxcbiAqIFNpbXBsZVRhbGsgcGFydHMuXG4gKi9cbmltcG9ydCB7XG4gICAgaWRNYWtlcixcbiAgICBpc1ZhbGlkSWRcbn0gZnJvbSAnLi4vdXRpbHMvaWQuanMnO1xuaW1wb3J0IGVycm9ySGFuZGxlciBmcm9tICcuLi91dGlscy9lcnJvckhhbmRsZXIuanMnO1xuaW1wb3J0IHtcbiAgICBQYXJ0UHJvcGVydGllcyxcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcblxuaW1wb3J0IHtBY3RpdmF0aW9uQ29udGV4dH0gZnJvbSAnLi4vRXhlY3V0aW9uU3RhY2suanMnO1xuXG5cbmNsYXNzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGFuT3duZXJQYXJ0LCBuYW1lLCBkZXNlcmlhbGl6aW5nPWZhbHNlKXtcblxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgLy8gQW4gYXJyYXkgb2YgY2hpbGQgcGFydHNcbiAgICAgICAgdGhpcy5zdWJwYXJ0cyA9IFtdO1xuICAgICAgICAvLyBhIGxpc3Qgb2YgYWxsIGFjY2VwdGVkIHN1YnBhcnRzIGJ5IHR5cGVcbiAgICAgICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIG51bGwgYW5kIGVhY2ggUGFydCBzdWJjbGNhc3Mgc2hvdWxkXG4gICAgICAgIC8vIHNwZWNpZnkgaWYgb3RoZXJ3aXNlXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzID0gbmV3IFBhcnRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuX293bmVyID0gYW5Pd25lclBhcnQ7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9wcml2YXRlQ29tbWFuZEhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0U2VtYW50aWNzID0ge307XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5U3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3ZpZXdTdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaXNQYXJ0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BlcnRpZXMgPSB0aGlzLnNldHVwUHJvcGVydGllcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzID0gdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuYWRkUGFydCA9IHRoaXMuYWRkUGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVBhcnQgPSB0aGlzLnJlbW92ZVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hY2NlcHRzU3VicGFydCA9IHRoaXMuYWNjZXB0c1N1YnBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIgPSB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlciA9IHRoaXMucmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0RnVuY0hhbmRsZXIgPSB0aGlzLnNldEZ1bmNIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUNtZCA9IHRoaXMucmVjZWl2ZUNtZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVGdW5jID0gdGhpcy5yZWNlaXZlRnVuYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVFcnJvciA9IHRoaXMucmVjZWl2ZUVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZU1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVNZXNzYWdlID0gdGhpcy5kZWxlZ2F0ZU1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IHRoaXMuc2VuZE1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eVN1YnNjcmliZXIgPSB0aGlzLmFkZFByb3BlcnR5U3Vic2NyaWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5U3Vic2NyaWJlciA9IHRoaXMucmVtb3ZlUHJvcGVydHlTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkVmlld1N1YnNjcmliZXIgPSB0aGlzLmFkZFZpZXdTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlVmlld1N1YnNjcmliZXIgPSB0aGlzLnJlbW92ZVZpZXdTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gdGhpcy5zZXJpYWxpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b0pTT04gPSB0aGlzLnRvSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByb3BzRnJvbURlc2VyaWFsaXplciA9IHRoaXMuc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmluZEFuY2VzdG9yT2ZUeXBlID0gdGhpcy5maW5kQW5jZXN0b3JPZlR5cGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuRWRpdG9yQ21kSGFuZGxlciA9IHRoaXMub3BlbkVkaXRvckNtZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvckNtZEhhbmRsZXIgPSB0aGlzLmNsb3NlRWRpdG9yQ21kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvcHlDbWRIYW5kbGVyID0gdGhpcy5jb3B5Q21kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhc3RlQ21kSGFuZGxlciA9IHRoaXMucGFzdGVDbWRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNTdWJwYXJ0T2ZDdXJyZW50Q2FyZCA9IHRoaXMuaXNTdWJwYXJ0T2ZDdXJyZW50Q2FyZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzU3VicGFydE9mQ3VycmVudFN0YWNrID0gdGhpcy5pc1N1YnBhcnRPZkN1cnJlbnRTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE93bmVyQnJhbmNoID0gdGhpcy5nZXRPd25lckJyYW5jaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0U3RlcHBpbmcgPSB0aGlzLnN0YXJ0U3RlcHBpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdG9wU3RlcHBpbmcgPSB0aGlzLnN0b3BTdGVwcGluZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRhcmdldFByb3AgPSB0aGlzLnNldFRhcmdldFByb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVN1YnBhcnRVcCA9IHRoaXMubW92ZVN1YnBhcnRVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vdmVTdWJwYXJ0RG93biA9IHRoaXMubW92ZVN1YnBhcnREb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVN1YnBhcnRUb0ZpcnN0ID0gdGhpcy5tb3ZlU3VicGFydFRvRmlyc3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlU3VicGFydFRvTGFzdCA9IHRoaXMubW92ZVN1YnBhcnRUb0xhc3QuYmluZCh0aGlzKTtcblxuXG5cbiAgICAgICAgLy8gRmluYWxseSwgd2UgZmluaXNoIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgLy8gY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm9wZW5FZGl0b3JcIiwgdGhpcy5vcGVuRWRpdG9yQ21kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiY2xvc2VFZGl0b3JcIiwgdGhpcy5jbG9zZUVkaXRvckNtZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInNldFRhcmdldFRvXCIsIHRoaXMuc2V0VGFyZ2V0UHJvcCk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiY29weVwiLCB0aGlzLmNvcHlDbWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlQ21kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVVcFwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnRVcCh0aGlzKTt9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlRG93blwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnREb3duKHRoaXMpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0ZpcnN0XCIsICgpID0+IHt0aGlzLl9vd25lci5tb3ZlU3VicGFydFRvRmlyc3QodGhpcyk7fSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVRvTGFzdFwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnRUb0xhc3QodGhpcyk7fSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZ2V0dGVyIHRvIGdldCB0aGUgaWRcbiAgICAvLyBmcm9tIHRoZSBwYXJ0UHJvcGVydGllc1xuICAgIGdldCBpZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsICdpZCcpO1xuICAgIH1cblxuICAgIHNldCBpZCh2YWwpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsICdpZCcsIHZhbCk7XG4gICAgfVxuXG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgbmFtZXMgb2YgYWxsIG9mIG15IGFuZCBteSBhbmNlc3RvcnMnIGhhbmRsZXJzXG4gICAgLy8gZm9yIHRoZSBtb21lbnQgdGhpcyBpcyBqdXN0IG5hbWVzLCB0eXBlLCBpZCBhbmQgd2hldGhlciB0aGUgaGFuZGxlciBvdmVycmlkZXNcbiAgICAvLyBhbiBvd25lcidzLCBidXQgY291bGQgYmUgcmljaGVyIGluZm8sIHN1Y2ggYXMgYXJndW1lbnRzLCBkb2N1bWVudGF0aW9uIGV0Y1xuICAgIGdldCBjb21tYW5kSGFuZGxlclJlZ2lzdHJ5KCl7XG4gICAgICAgIGxldCBoYW5kbGVyc0luZm8gPSB7fTtcbiAgICAgICAgbGV0IG93bmVyQnJhbmNoID0gdGhpcy5nZXRPd25lckJyYW5jaCgpO1xuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDw9IG93bmVyQnJhbmNoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gb3duZXJCcmFuY2hbb3duZXJCcmFuY2gubGVuZ3RoIC0gaV07XG4gICAgICAgICAgICBsZXQgcGFydFR5cGUgPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgICBpZihwYXJ0LmlkID09PSAtMSl7XG4gICAgICAgICAgICAgICAgcGFydFR5cGUgPSBcIlN5c3RlbVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTeXN0ZW0gZG9lc24ndCBoYXZlIHByaXZhdGUgY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcnQuX3ByaXZhdGVDb21tYW5kSGFuZGxlcnMpLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhhbmRsZXJzSW5mb1toXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNJbmZvW2hdID0ge3BhcnRJZDogcGFydC5pZCwgcGFydFR5cGU6IHBhcnRUeXBlLCBvdmVycmlkZTogb3ZlcnJpZGUsIHByaXZhdGU6IHRydWV9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFydC5fY29tbWFuZEhhbmRsZXJzKS5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoaGFuZGxlcnNJbmZvW2hdKXtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVyc0luZm9baF0gPSB7cGFydElkOiBwYXJ0LmlkLCBwYXJ0VHlwZTogcGFydFR5cGUsIG92ZXJyaWRlOiBvdmVycmlkZSwgcHJpdmF0ZTogZmFsc2V9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzSW5mbztcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIHRoZSB0aGlzLnBhcnQgLT4gU3lzdGVtIGJyYW5jaCBieSBwYXJ0IGlkXG4gICAgZ2V0T3duZXJCcmFuY2goYnJhbmNoKXtcbiAgICAgICAgaWYoIWJyYW5jaCl7XG4gICAgICAgICAgICBicmFuY2ggPSBbdGhpc107XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy50eXBlID09PSBcIndvcmxkXCIpe1xuICAgICAgICAgICAgYnJhbmNoLnB1c2god2luZG93LlN5c3RlbSk7XG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJhbmNoLnB1c2godGhpcy5fb3duZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fb3duZXIuZ2V0T3duZXJCcmFuY2goYnJhbmNoKTtcbiAgICB9XG5cbiAgICAvLyBDb25maWd1cmVzIHRoZSBzcGVjaWZpYyBwcm9wZXJ0aWVzIHRoYXQgdGhlXG4gICAgLy8gZ2l2ZW4gcGFydCBjYW4gZXhwZWN0LCBhbG9uZyB3aXRoIGFueSBkZWZhdWx0XG4gICAgLy8gdmFsdWVzLlxuICAgIC8vIERlc2NlbmRhbnQgUGFydHMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kXG4gICAgLy8gaW4gdGhlaXIgb3duIGNvbnN0cnVjdG9yIGFmdGVyIGNhbGxpbmcgc3VwZXIsXG4gICAgLy8gc28gdGhhdCB0aGV5IGdldCB0aGUgcGFyZW50J3MgZ2VuZXJhbCBwcm9wZXJ0aWVzXG4gICAgLy8gdG9vLlxuICAgIHNldHVwUHJvcGVydGllcygpe1xuICAgICAgICAvLyBIZXJlLCB3ZSBzZXQgdXAgcHJvcGVydGllcyBjb21tb25cbiAgICAgICAgLy8gdG8gQUxMIFBhcnRzIGluIHRoZSBzeXN0ZW0uXG4gICAgICAgIGxldCBiYXNpY1Byb3BzID0gW1xuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ3RhcmdldCcsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnY29udGVudHMnLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnd2FudHMtbW92ZScsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgICAgIGlkTWFrZXIubmV3KClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgYE5ldyAke3RoaXMudHlwZX1gXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ3JlY3RhbmdsZScsXG4gICAgICAgICAgICAgICAgXCIwLCAwLCAwLCAwXCIsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBbJ3JlY3QnXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIG51bGwgLy8gRm9yIG5vd1xuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICAgICAgLy8gY3NzIChyZWFsbHkgSlMgc3R5bGUpIGtleS12YWx1ZXNcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdjc3NTdHlsZScsXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gY3NzIChyZWFsbHkgSlMgc3R5bGUpIGtleS12YWx1ZXNcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdjc3NUZXh0U3R5bGUnLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgICBiYXNpY1Byb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLmFkZFByb3BlcnR5KHByb3ApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGUgaW5kZXggbnVtYmVyIG9mIHRoZSBwYXJ0IGluIHBhcnQuX293bmVyLnN1YnBhcnRcbiAgICAgICAgLy8gYXJyYXkuIE5vdGU6IHRoaXMgaXMgMS1pbmRleGVkXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgIG51bGwsIC8vIG5vIHNldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICBpZihwcm9wT3duZXIudHlwZSA9PSBcIndvcmxkXCIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BPd25lci5fb3duZXIuc3VicGFydHMuaW5kZXhPZihwcm9wT3duZXIpICsgMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlIC8vIHJlYWRvbmx5XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICd0YXJnZXQnLFxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWwpe1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgdGFyZ2V0IGlzIGEgbm9uLUlEXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gaXNWYWxpZElkKHZhbCk7XG4gICAgICAgICAgICAgICAgaWYoaWQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhbiBJRCBpbnNlcnQgXCJwYXJ0XCIgc2luY2Ugb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdyYW1tYXIgZG9lc24ndCBoYW5kbGUgSUQgd2l0aG91dCBzeXN0ZW0gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZWZpeGVzXG4gICAgICAgICAgICAgICAgICAgIHByb3BPYmplY3QuX3ZhbHVlID0gYHBhcnQgaWQgJHt2YWx9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wT2JqZWN0Ll92YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICApLFxuXG4gICAgICAgIC8vIEN1c3RvbSBQcm9wZXJ0aWVzIHN0b3JlIHByb3BzIGRlZmluZWQgd2l0aGluIHRoZVxuICAgICAgICAvLyBTVCBlbnZpcm9ubWVudFxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0N1c3RvbVByb3AoXG4gICAgICAgICksXG5cbiAgICAgICAgLy8gU3RlcHBpbmcgcmVsYXRlZCBwcm9wc1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAvLyBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlblxuICAgICAgICAgICAgLy8gc2VuZHMgb2YgdGhlIHN0ZXAgY29tbWFuZCBpZiB0aGVcbiAgICAgICAgICAgIC8vIHN0ZXBwaW5nIHByb3BlcnR5IGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAnc3RlcFRpbWUnLFxuICAgICAgICAgICAgLy8gRHluYW1pYyBzZXR0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsdWUpe1xuICAgICAgICAgICAgICAgIGlmKHByb3BPd25lci5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJydXB0IHRoZSBjdXJyZW50IGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXN0YXJ0IHdpdGggbmV3IHN0ZXBUaW1lXG4gICAgICAgICAgICAgICAgICAgIHByb3BPd25lci5zdG9wU3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnN0YXJ0U3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIER5bmFtaWMgZ2V0dGVyXG4gICAgICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZSwgLy8gY2FuIHJlYWQgYW5kIHdyaXRlXG4gICAgICAgICAgICA1MDAgLy8gRGVmYXVsdCB0byBoYWxmIGEgc2Vjb25kXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICdzdGVwcGluZycsXG4gICAgICAgICAgICAvLyBEeW5hbWljIHNldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWx1ZSl7XG4gICAgICAgICAgICAgICAgaWYodmFsdWUgPT09IGZhbHNlICYmIHByb3BPd25lci5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnN0b3BTdGVwcGluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PT0gdHJ1ZSAmJiAhcHJvcE93bmVyLmlzU3RlcHBpbmcpe1xuICAgICAgICAgICAgICAgICAgICBwcm9wT3duZXIuc3RhcnRTdGVwcGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBEeW5hbWljIGdldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW50ZXJ2YWxJZCBpcyBzZXQsIHRoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgUGFydCBpcyBjdXJyZW50bHkgc3RlcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE93bmVyLmlzU3RlcHBpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgfVxuXG4gICAgLy8gVG8gYmUgY2FsbGVkIGluIGVhY2ggc3ViLWNsYXNzIHRoYXQgaGFzIFN0eWxlUHJvcGVydGllc1xuICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgc3R5bGUgcHJvcHMgYXJlIGNvbmZpZ3VyZWRcbiAgICBzZXR1cFN0eWxlUHJvcGVydGllcygpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLl9wcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmKHByb3AuY29uc3RydWN0b3IubmFtZSA9PT0gXCJTdHlsZVByb3BlcnR5XCIpe1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHZhbHVlIG9uIGl0c2VsZiBlbnN1cmVzIHRoYXQgdGhlIGNzc1N0eWxlXG4gICAgICAgICAgICAgICAgLy8gQmFzaWNQcm9wZXJ0eSBpcyB1cGRhdGVkIHdpdGggdGhlIGFwcHJvcHJpYXRlIHN0eWxlclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnNpb24gY3NzIGtleS12YWxcbiAgICAgICAgICAgICAgICBwcm9wLnNldFZhbHVlKHRoaXMsIHByb3AuX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFN1YnBhcnQgQWNjZXNzICoqL1xuICAgIC8qKlxuICAgICAqIEVhY2ggc3ViY2xhc3Mgd2lsbCBpbXBsZW1lbnQgaXRzIG93biBzZXQgb2YgY2hlY2tzLFxuICAgICAqIGFuZCB0aHJvdyBhbiBhcHByb3ByaXRlIGVycm9yIGlmIHRoZSBzdWJwYXJ0IHR5cGUgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBhY2NlcHRzU3VicGFydChhUGFydFR5cGUpe1xuICAgICAgICBpZiAodGhpcy5hY2NlcHRlZFN1YnBhcnRUeXBlc1swXSA9PT0gXCIqXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMuaW5jbHVkZXMoYVBhcnRUeXBlLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwYXJ0IHRvIHRoaXMgcGFydCdzIHN1YnBhcnRzXG4gICAgICogY29sbGVjdGlvbiwgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICAgKiBJdCB3aWxsIGFsc28gc2V0IHRoZSBvd25lciBvZiB0aGVcbiAgICAgKiBhZGRlZCBwYXJ0IHRvIGJlIHRoaXMgcGFydC5cbiAgICAgKi9cbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgaWYoIXRoaXMuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gZG9lcyBub3QgYWNjZXB0IHN1YnBhcnRzIG9mIHR5cGUgJHthUGFydC50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYoZm91bmQgPCAwKXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydHMucHVzaChhUGFydCk7XG4gICAgICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcGFydCBmcm9tIHRoaXNcbiAgICAgKiBwYXJ0J3MgbGlzdCBvZiBzdWJwYXJ0cyAoaWYgcHJlc2VudCkuXG4gICAgICogSXQgd2lsbCBhbHNvIHVuc2V0IHRoZSBvd25lciBvZiB0aGVcbiAgICAgKiBnaXZlbiBwYXJ0LlxuICAgICAqL1xuICAgIHJlbW92ZVBhcnQoYVBhcnQpe1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYocGFydEluZGV4ID49IDApe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UocGFydEluZGV4LCAxKTtcbiAgICAgICAgICAgIGFQYXJ0Ll9vd25lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgdGhlIFBhcnQgaW5zdGFuY2UgaXMgYSBzdWJwYXJ0IG9mIHRoZSBjdXJyZW50XG4gICAgICogQ2FyZC5cbiAgICAgKi9cbiAgICBpc1N1YnBhcnRPZkN1cnJlbnRDYXJkKCl7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBQYXJ0IGluc3RhbmNlIGlzIGEgc3VicGFydCBvZiB0aGUgY3VycmVudFxuICAgICAqIFN0YWNrLlxuICAgICAqL1xuICAgIGlzU3VicGFydE9mQ3VycmVudFN0YWNrKCl7XG4gICAgfVxuXG4gICAgLyoqIExvZ2dpbmcgYW5kIFJlcG9ydGluZyAqKi9cbiAgICBzaG91bGRCZUltcGxlbWVudGVkKGZ1bmN0aW9uTmFtZSl7XG4gICAgICAgIGxldCBtc2cgPSBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHNob3VsZCBpbXBsZW1lbnQgJHtmdW5jdGlvbk5hbWV9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgLyoqIE1lc3NhZ2UgSGFuZGxpbmcgYW5kIERlbGVnYXRpb24gKiovXG4gICAgZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICBhTWVzc2FnZSxcbiAgICAgICAgICAgIHRoaXMuX293bmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHRhcmdldCl7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLnNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0aGlzLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIHJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgUGFydHMgd2lsbCBvbmx5IGhhbmRsZVxuICAgICAgICAvLyBtZXNzYWdlcyBvZiB0eXBlICdjb21tYW5kJyBhbmQgJ2Z1bmN0aW9uJ1xuICAgICAgICBzd2l0Y2goYU1lc3NhZ2UudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlQ21kKGFNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVGdW5jKGFNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVFcnJvcihhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNlaXZlRXJyb3IoYU1lc3NhZ2Upe1xuICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyLmhhbmRsZShhTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmVjZWl2ZUNtZChhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fY29tbWFuZEhhbmRsZXJzW2FNZXNzYWdlLmNvbW1hbmROYW1lXTtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIFBhcnQgaGFzIGEgaGFuZGxlciBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBnaXZlbiBjb21tYW5kLCB3ZSBydW4gaXQuXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGxhdGUtYmluZCB0aGUgY3VycmVudCBwYXJ0XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSBhcyB0aGUgJ3RoaXMnIGNvbnRleHQgZm9yXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlclxuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByaXZhdGVIYW5kbGVyID0gdGhpcy5fcHJpdmF0ZUNvbW1hbmRIYW5kbGVyc1thTWVzc2FnZS5jb21tYW5kTmFtZV07XG4gICAgICAgIGlmKHByaXZhdGVIYW5kbGVyKXtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgUGFydCBoYXMgYSBoYW5kbGVyIGZvclxuICAgICAgICAgICAgLy8gdGhlIGdpdmVuIGNvbW1hbmQsIHdlIHJ1biBpdC5cbiAgICAgICAgICAgIC8vIFdlIGFsc28gbGF0ZS1iaW5kIHRoZSBjdXJyZW50IHBhcnRcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIGFzIHRoZSAndGhpcycgY29udGV4dCBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICBsZXQgYm91bmRIYW5kbGVyID0gcHJpdmF0ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBoYXZlIG5vIGhhbmRsZXIgZm9yXG4gICAgICAgIC8vIGl0LiBVbmxlc3MgdGhlIG1lc3NhZ2UgaW5kaWNhdGVzIHNob3VsZE5vdERlbGVnYXRlXG4gICAgICAgIC8vIHdlIGRlbGVnYXRlIGFsb25nIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGRlbGVnYXRpb24gY2hhaW4uIEl0IGlzIHVwXG4gICAgICAgIC8vIHRvIFBhcnRzIHRvIHByb3Blcmx5IGltcGxlbWVudCBkZWxlZ2F0aW9uXG4gICAgICAgIC8vIGZvciB0aGVtc2VsdmVzIVxuICAgICAgICBpZihhTWVzc2FnZS5zaG91bGROb3REZWxlZ2F0ZSl7XG4gICAgICAgICAgICByZXR1cm4gYU1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZWNlaXZlRnVuYyhhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fZnVuY3Rpb25IYW5kbGVyc1thTWVzc2FnZS5mdW5jdGlvbk5hbWVdO1xuXG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZEhhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoY29tbWFuZE5hbWUsIGhhbmRsZXIpe1xuICAgICAgICB0aGlzLl9wcml2YXRlQ29tbWFuZEhhbmRsZXJzW2NvbW1hbmROYW1lXSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgcmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyKGNvbW1hbmROYW1lKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ByaXZhdGVDb21tYW5kSGFuZGxlcnNbY29tbWFuZE5hbWVdO1xuICAgIH1cblxuICAgIHNldEZ1bmNIYW5kbGVyKGZ1bmNOYW1lLCBoYW5kbGVyKXtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25IYW5kbGVyc1tmdW5jTmFtZV0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIC8qKiBDb21tYW5kIEhhbmRsZXJzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ29tbWFuZCBoYW5kbGVycyB3aGljaCBhcmUgaW52b2tlZCBhdCB0aGUgUGFydCBsZXZlbFxuICAgICAgICB3aGljaCBhcmUgbm90IGltbWVkaWF0ZWx5IGRlbGVnYWVkIHRvIHRoZSBQYXJ0Ll9vd25lclxuICAgICoqL1xuXG4gICAgb3BlbkVkaXRvckNtZEhhbmRsZXIoKXtcbiAgICAgICAgbGV0IGVkaXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LWVkaXRvcicpO1xuICAgICAgICBlZGl0b3IucmVuZGVyKHRoaXMpO1xuICAgICAgICBpZighZWRpdG9yLmlzT3Blbil7XG4gICAgICAgICAgICBlZGl0b3Iub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VFZGl0b3JDbWRIYW5kbGVyKCl7XG4gICAgICAgIGxldCBlZGl0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1lZGl0b3Iub3BlbicpO1xuICAgICAgICBpZihlZGl0b3Ipe1xuICAgICAgICAgICAgZWRpdG9yLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUYXJnZXRQcm9wKHNlbmRlcnMsIC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYXJncy5qb2luKFwiIFwiKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgY29weUNtZEhhbmRsZXIoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29weVBhcnQodGhpcyk7XG4gICAgfVxuXG4gICAgcGFzdGVDbWRIYW5kbGVyKCl7XG4gICAgICAgIGlmKCF3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5pc0VtcHR5KXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29udGVudHNbMF07XG4gICAgICAgICAgICBpZihpdGVtLnR5cGUgPT0gJ3NpbXBsZXRhbGsvanNvbicgJiYgdGhpcy5hY2NlcHRzU3VicGFydChpdGVtLnBhcnRUeXBlKSl7XG4gICAgICAgICAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQucGFzdGVDb250ZW50c0ludG8odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlKHNlbmRlcnMsIG1vdmVtZW50WCwgbW92ZW1lbnRZKXtcbiAgICAgICAgaWYoIXRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcIndhbnRzLW1vdmVcIikpe1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBhcnQgJHt0aGlzLmlkfSB0cnlpbmcgdG8gbW92ZSB3aXRoICd3YW50cy1tb3ZlJyBwcm9wZXJ0eSBmYWxzZWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJ0b3BcIik7XG4gICAgICAgIHRvcCArPSBtb3ZlbWVudFk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInRvcFwiLCB0b3ApO1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcImxlZnRcIik7XG4gICAgICAgIGxlZnQgKz0gbW92ZW1lbnRYO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJsZWZ0XCIsIGxlZnQpO1xuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgdGhpcy5zdWJwYXJ0cy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRVcChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gMCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdGU6IG1vdmVTdWJwYXJ0VG9GaXJzdCBtZWFucyBtb3ZlIHRvIGZpcnN0IGluIHRoZSB2aWV3XG4gICAgLy8gaS5lLiBsYXN0IGFzIGEgc3ViYXBydFxuICAgIG1vdmVTdWJwYXJ0VG9GaXJzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0xhc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgLyoqIFByb3BlcnR5IFN1YnNjcmliZXJzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBPYmplY3RzIGFkZGVkIGFzIHByb3BlcnR5IHN1YnNjcmliZXJzXG4gICAgICAgIHdpbGwgYmUgJ25vdGlmaWVkJyB3aGVuZXZlciBvbmUgb2YgdGhpc1xuICAgICAgICBQYXJ0J3MgcHJvcGVydGllcyBjaGFuZ2VzXG4gICAgKiovXG4gICAgYWRkUHJvcGVydHlTdWJzY3JpYmVyKGFuT2JqZWN0KXtcbiAgICAgICAgdGhpcy5fcHJvcGVydHlTdWJzY3JpYmVycy5hZGQoYW5PYmplY3QpO1xuICAgIH1cblxuICAgIHJlbW92ZVByb3BlcnR5U3Vic2NyaWJlcihhbk9iamVjdCl7XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5U3Vic2NyaWJlcnMuZGVsZXRlKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eUNoYW5nZWQocHJvcGVydHlOYW1lLCBuZXdWYWx1ZSl7XG4gICAgICAgIGxldCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3Byb3BlcnR5Q2hhbmdlZCcsXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIHBhcnRJZDogdGhpcy5pZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eVN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2UsIHN1YnNjcmliZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogVmlldyBTdWJzY3JpYmVyc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgT2JqZWN0cyBhZGRlZCBhcyB2aWV3IHN1YnNjcmliZXJzXG4gICAgICAgIHdpbGwgYmUgJ25vdGlmaWVkJyB3aGVuZXZlciB0aGlzIFBhcnRcbiAgICAgICAgaW5jdXJycyBhIHZpZXcgY2hhbmdlIChhZGQsIGRlbGV0ZSBzdWJwYXJ0cywgcmVvcmRlciBldGMpXG4gICAgKiovXG4gICAgYWRkVmlld1N1YnNjcmliZXIoYW5PYmplY3Qpe1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMuYWRkKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICByZW1vdmVWaWV3U3Vic2NyaWJlcihhbk9iamVjdCl7XG4gICAgICAgIHRoaXMuX3ZpZXdTdWJzY3JpYmVycy5kZWxldGUoYW5PYmplY3QpO1xuICAgIH1cblxuICAgIHZpZXdDaGFuZ2VkKGNoYW5nZU5hbWUsIC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWV3Q2hhbmdlZCcsXG4gICAgICAgICAgICBjaGFuZ2VOYW1lOiBjaGFuZ2VOYW1lLFxuICAgICAgICAgICAgcGFydElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobWVzc2FnZSwgc3Vic2NyaWJlcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN1YnBhcnRPcmRlckNoYW5nZWQoaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpe1xuICAgICAgICBsZXQgc3VicGFydCA9IHRoaXMuc3VicGFydHMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSlbMF07XG4gICAgICAgIHRoaXMuc3VicGFydHMuc3BsaWNlKG5ld0luZGV4LCAwLCBzdWJwYXJ0KTtcbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlZChcInN1YnBhcnQtb3JkZXJcIiwgaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpO1xuICAgIH1cblxuICAgIHN0YXJ0U3RlcHBpbmcoKXtcbiAgICAgICAgaWYodGhpcy5fc3RlcEludGVydmFsSWQpe1xuICAgICAgICAgICAgdGhpcy5zdG9wU3RlcHBpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RlcFRpbWUgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3N0ZXBUaW1lJ1xuICAgICAgICApO1xuICAgICAgICBpZihzdGVwVGltZSA+IDApe1xuICAgICAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdzdGVwJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHN0ZXBUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BTdGVwcGluZygpe1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3N0ZXBJbnRlcnZhbElkKTtcbiAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBpc1N0ZXBwaW5nKCl7XG4gICAgICAgIC8vIFdlIGtub3cgdGhlIFBhcnQgaXMgY3VycmVudGx5IHN0ZXBwaW5nXG4gICAgICAgIC8vIG9mIHRoZSBzdG9yZWQgaW50ZXJ2YWxJZCBpcyBzZXQgdG9cbiAgICAgICAgLy8gc29tZXRoaW5nIGJlc2lkZXMgbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcEludGVydmFsSWQgIT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgUGFydCdzIHN0YXRlIGFzIEpTT04uXG4gICAgICogQnkgZGVmYXVsdCwgd2UgZG8gbm90IHNlcmlhbGl6ZSBzcGVjaWZpY1xuICAgICAqIFBhcnRDb2xsZWN0aW9uIGluZm9ybWF0aW9uIChyZWN1cnNpdmVseSksXG4gICAgICogYW5kIG9ubHkgaW5jbHVkZSBiYXNpY3MgaW5jbHVkaW5nIHRoZSBjdXJyZW50XG4gICAgICogc3RhdGUgb2YgYWxsIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCl7XG4gICAgICAgIGxldCBvd25lcklkID0gbnVsbDtcbiAgICAgICAgaWYodGhpcy5fb3duZXIpe1xuICAgICAgICAgICAgb3duZXJJZCA9IHRoaXMuX293bmVyLmlkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgc3VicGFydHM6IHRoaXMuc3VicGFydHMubWFwKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LmlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvd25lcklkOiBvd25lcklkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuX3Byb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcC5nZXRWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcHJvcGVydGllcyBhbmQgb3RoZXJcbiAgICAgKiBhdHRyaWJ1dGVzIG9mIHRoaXMgUGFydCBtb2RlbFxuICAgICAqIGZyb20gYSBkZXNlcmlhbGl6ZWQgSlNPTiBvYmplY3QuXG4gICAgICovXG4gICAgc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyKGluY29taW5nUHJvcHMsIGRlc2VyaWFsaXplcil7XG4gICAgICAgIE9iamVjdC5rZXlzKGluY29taW5nUHJvcHMpLmZvckVhY2gocHJvcE5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gdGhpcy5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZighcHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWUgb2xkIG9yIGludmFsaWQgcHJvcGVydHkgaXNcbiAgICAgICAgICAgICAgICAvLyBwcmVzZW50IGluIHRoZSBkZXNlcmlhbGl6YXRpb24sIHNpbXBseSBwcm92aWRlXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nIGFuZCB0aGVuIHNraXAgdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXNlcmlhbGl6ZWQgcHJvcGVydHkgXCIke3Byb3BOYW1lfVwiIGlzIG5vdCBhIHZhbGlkIHByb3BlcnR5IG5hbWUgZm9yICR7dGhpcy50eXBlfSAoaWQgJHt0aGlzLmlkfSkgYW5kIHdpbGwgYmUgaWdub3JlZGApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHByb3BOYW1lID09IFwiY3VzdG9tLXByb3BlcnRpZXNcIil7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIHByb3BlcnRpZXMgYXJlIHNlcmlhbGl6ZWQgYXMgYW4gb2JqZWN0IGxpa2Ugb3RoZXIgcHJvcHNcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byBjcmVhdGUgcHJvcGVydGllcyBmcm9tIHRoZXNlIGFuZCBzZXQgdGhlaXIgcmVzcGVjdGl2ZVxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcy4gVGhlbiB3ZSBuZWVkIHRvIHNldCB0aGUgdmFsdWUgb2YgXCJjdXN0b20tcHJvcGVydGllc1wiIHByb3BcbiAgICAgICAgICAgICAgICAvLyBpdHNlbGYgdG8gYmUgdGhlIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGVzZVxuICAgICAgICAgICAgICAgIGxldCBjdXN0b21Qcm9wc0RhdGEgPSBpbmNvbWluZ1Byb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q3VzdG9tUHJvcHNPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKGN1c3RvbVByb3BzRGF0YSkuZm9yRWFjaCgocHJvcERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgQmFzaWNQcm9wZXJ0eShwcm9wRGF0YS5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcC5zZXRWYWx1ZSh0aGlzLCBwcm9wRGF0YS5fdmFsdWUsIGZhbHNlKTsgLy8gbm8gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3VzdG9tUHJvcHNPYmplY3RbcHJvcERhdGEubmFtZV0gPSBuZXdQcm9wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFZhbHVlKHRoaXMsIG5ld0N1c3RvbVByb3BzT2JqZWN0LCBmYWxzZSk7IC8vIG5vIG5lZWQgdG8gbm90aWZ5XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXByb3BlcnR5LnJlYWRPbmx5KXtcbiAgICAgICAgICAgICAgICAvLyBMYXN0IGFyZyBpcyBmYWxzZSwgd2hpY2ggdGVsbHMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbm90IHRvIG5vdGlmeSBpdHMgb3duZXIncyBzdWJzY3JpYmVycyBvZlxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IGNoYW5nZXMuIFdlIGRvbid0IG5lZWQgdGhhdCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gZGVzZXJpYWxpemluZ1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFZhbHVlKHRoaXMsIGluY29taW5nUHJvcHNbcHJvcE5hbWVdLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvSlNPTigpe1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9XG5cbiAgICBmaW5kQW5jZXN0b3JPZlR5cGUoYVBhcnRUeXBlKXtcbiAgICAgICAgbGV0IG93bmVyID0gdGhpcy5fb3duZXI7XG4gICAgICAgIHdoaWxlKG93bmVyKXtcbiAgICAgICAgICAgIGlmKG93bmVyLnR5cGUgPT0gYVBhcnRUeXBlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvd25lciA9IG93bmVyLl9vd25lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnQsXG4gICAgUGFydCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIFJlc291cmNlIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIHNyYykge1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3JjID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdyZWFkeVN0YXRlJyxcbiAgICAgICAgICAgIFwibm90UmVhZHlcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJwcmVyZXF1aXNpdGVcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwicmVzb3VyY2VOYW1lXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZFJlc291cmNlXCIsIHRoaXMubG9hZFJlc291cmNlKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzZXRTb3VyY2VUb1wiLCB0aGlzLnNldFNvdXJjZVRvKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJnZXRcIiwgdGhpcy5nZXQpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5sb2FkUmVzb3VyY2UgPSB0aGlzLmxvYWRSZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgc3JjIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRUZXh0U3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzaWRlfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdyZXNvdXJjZSc7XG4gICAgfVxuXG4gICAgbG9hZFJlc291cmNlKHNlbmRlcnMsIHJlc291cmNlTmFtZSl7XG4gICAgICAgIGlmKCF3aW5kb3cuU3lzdGVtLmF2YWlsYWJsZVJlc291cmNlcyB8fCAhd2luZG93LlN5c3RlbS5hdmFpbGFibGVSZXNvdXJjZXNbcmVzb3VyY2VOYW1lXSl7XG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGJlIGEgU1QgZXJyb3JcbiAgICAgICAgICAgIHRocm93IEVycm9yKGByZXNvdXJjZSAke3Jlc291cmNlTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHdpbmRvdy5TeXN0ZW0uYXZhaWxhYmxlUmVzb3VyY2VzW3Jlc291cmNlTmFtZV07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlc291cmNlTmFtZVwiLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICAvLyB3ZSBjYW4ndCBndWFyYW50ZWUgdGhlIHN0YXRlIG9mIGEgcmVzb3VyY2UgYW5kIHNvIGl0IHNob3VsZCBiZSByZS1zZXQgZXZlcnkgdGltZVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlVG8oc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgaWYoIXRoaXMucmVzb3VyY2Upe1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgbm8gcmVzb3VyY2UgbG9hZGVkIGZvciByZXNvdXJjZSBwYXJ0IGlkICR7dGhpcy5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgc291cmNlVXJsKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZS5sb2FkKHNvdXJjZVVybCk7XG4gICAgICAgIC8vIHdlIGNhbid0IGd1YXJhbnRlZSB0aGUgc3RhdGUgb2YgYSByZXNvdXJjZSBhbmQgc28gaXQgc2hvdWxkIGJlIHJlLXNldCBldmVyeSB0aW1lXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgIH1cblxuICAgIGdldChzZW5kZXJzLCAuLi5hcmdzKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVhZHlTdGF0ZVwiLCBcImZldGNoaW5nXCIpO1xuICAgICAgICBsZXQgcHJlcmVxdWlzaXRlID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicHJlcmVxdWlzaXRlXCIpO1xuICAgICAgICB0aGlzLnJlc291cmNlLmdldChwcmVyZXF1aXNpdGUsIC4uLmFyZ3MpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZWFkeVN0YXRlXCIsIFwicmVhZHlcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJyZXNwb25kZWRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5pZCwgdGhpcy5yZXNvdXJjZS5uYW1lXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlYWR5U3RhdGVcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlc3BvbnNlXCIsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZXJyb3JlZFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmlkLCB0aGlzLnJlc291cmNlLm5hbWUsIGVycm9yLm1lc3NhZ2VdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0KCl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlYWR5U3RhdGVcIiwgXCJub3RSZWFkeVwiKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVzcG9uc2VcIiwgbnVsbCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBSZXNvdXJjZSxcbiAgICBSZXNvdXJjZSBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTdGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSB0aGUgU3RhY2sgUGFydC5cbiAqIEkgcmVwcmVzZW50IGEgY29sbGVjdGlvbiBvZiBDYXJkIHBhcnRzLFxuICogYWxvbmcgd2l0aCBzb21lIGV4dHJhIGNvbmZpZ3VyYWJpbGl0eS5cbiAqL1xuaW1wb3J0IFBhcnQgZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZC5qcyc7XG5pbXBvcnQge1xuICAgIEJhc2ljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIFN0YWNrIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIG5hbWUsIGRlc2VyaWFsaXppbmc9ZmFsc2Upe1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImNhcmRcIiwgXCJ3aW5kb3dcIiwgXCJidXR0b25cIiwgXCJhcmVhXCIsIFwiZmllbGRcIixcbiAgICAgICAgICAgIFwiZHJhd2luZ1wiLCBcImltYWdlXCIsIFwiYXVkaW9cIiwgXCJicm93c2VyXCJcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBTZXQgdXAgU3RhY2sgc3BlY2lmaWNcbiAgICAgICAgLy8gUGFydFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnY2FudFBlZWsnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVzaXphYmxlJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cblxuICAgICAgICAvLyBXaWxsIGhvbGQgdGhlIGNhcmQtYmFzZWQgaW5kZXgsXG4gICAgICAgIC8vIHdoaWNoIGhlcmUgaXMgemVyby1pbmRleGVkLCBvZiB0aGVcbiAgICAgICAgLy8gY2FyZCB0aGF0IGlzIHRoZSBjdXJyZW50IGNhcmQgZm9yIHRoaXNcbiAgICAgICAgLy8gU3RhY2suXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgZ2VuZXJhbCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8gPSB0aGlzLnNlbmRPcGVuQ2FyZFRvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvID0gdGhpcy5zZW5kQ2xvc2VDYXJkVG8uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIHN0YWNrIG5hdmlnYXRpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLmdvVG9OZXh0Q2FyZCA9IHRoaXMuZ29Ub05leHRDYXJkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub1ByZXZDYXJkID0gdGhpcy5nb1RvUHJldkNhcmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvQ2FyZEJ5SWQgPSB0aGlzLmdvVG9DYXJkQnlJZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdvVG9OdGhDYXJkID0gdGhpcy5nb1RvTnRoQ2FyZC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdvVG9OZXh0Q2FyZCgpe1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoY2FyZHMubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBjdXJyZW50SWR4ID0gY2FyZHMuaW5kZXhPZihjdXJyZW50Q2FyZCk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCArIDE7XG4gICAgICAgIGlmKG5leHRJZHggPj0gY2FyZHMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHRJZHggPSAobmV4dElkeCAlIGNhcmRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHNbbmV4dElkeF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBuZXh0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50Q2FyZElkICE9IG5leHRDYXJkLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvKGN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8obmV4dENhcmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub0NhcmRCeUlkKGFuSWQpe1xuICAgICAgICBsZXQgY3VycmVudENhcmRJZCA9IHRoaXMuY3VycmVudENhcmRJZDtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkID0gdGhpcy5jdXJyZW50Q2FyZDtcbiAgICAgICAgbGV0IGNhcmRzID0gT2JqZWN0LnZhbHVlcyh3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZCkuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwiY2FyZFwiO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHMuZmluZChjYXJkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXJkLmlkID09IGFuSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZighbmV4dENhcmQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FyZCBpZDogJHthbklkfSBjYW50IGJlIGZvdW5kIHN0YWNrYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGNhcmQgaXMgbm90IG9uIHRoaXMgc3RhY2sgd2Ugc2hvdWxkIGdvIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0YWNrXG4gICAgICAgIGlmKG5leHRDYXJkLl9vd25lciAhPSB0aGlzKXtcbiAgICAgICAgICAgIHRoaXMuX293bmVyLmdvVG9TdGFja0J5SWQobmV4dENhcmQuX293bmVyLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dENhcmQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYoY3VycmVudENhcmRJZCAhPSBuZXh0Q2FyZC5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZUNhcmRUbyhjdXJyZW50Q2FyZCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuQ2FyZFRvKG5leHRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9QcmV2Q2FyZCgpe1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoY2FyZHMubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBjdXJyZW50SWR4ID0gY2FyZHMuaW5kZXhPZihjdXJyZW50Q2FyZCk7XG5cbiAgICAgICAgbGV0IG5leHRJZHggPSBjdXJyZW50SWR4IC0gMTtcbiAgICAgICAgaWYobmV4dElkeCA8IDApe1xuICAgICAgICAgICAgbmV4dElkeCA9IGNhcmRzLmxlbmd0aCArIG5leHRJZHg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHNbbmV4dElkeF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBuZXh0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50Q2FyZElkICE9IG5leHRDYXJkLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvKGN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8obmV4dENhcmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub050aENhcmQoYW5JbmRleCl7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSB1c2luZyAxLWluZGV4ZWQgdmFsdWVzXG4gICAgICAgIC8vIHBlciB0aGUgU2ltcGxlVGFsayBzeXN0ZW1cbiAgICAgICAgbGV0IHRydWVJbmRleCA9IGFuSW5kZXggLSAxO1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYodHJ1ZUluZGV4IDwgMCB8fCB0cnVlSW5kZXggPiBjYXJkcy5sZW5ndGggLTEpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgbmF2aWdhdGUgdG8gY2FyZCBudW1iZXIgJHthbkluZGV4fSAtLSBvdXQgb2YgYm91bmRzYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBuZXh0Q2FyZCA9IGNhcmRzW3RydWVJbmRleF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgIG5leHRDYXJkLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRDYXJkSWQgIT0gbmV4dENhcmQuaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VDYXJkVG8oY3VycmVudENhcmQpO1xuICAgICAgICAgICAgdGhpcy5zZW5kT3BlbkNhcmRUbyhuZXh0Q2FyZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kQ2xvc2VDYXJkVG8oYUNhcmQpe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2Nsb3NlQ2FyZCcsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYUNhcmRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZW5kT3BlbkNhcmRUbyhhQ2FyZCl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlbkNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFDYXJkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdzdGFjayc7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRDYXJkSWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudENhcmQoKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RoaXMuY3VycmVudENhcmRJZF07XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGJhc2UgY2xhc3MgbWV0aG9kc1xuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsQ2FyZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPCBsYXN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlU3VicGFydFRvTGFzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsQ2FyZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPCBsYXN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgbGFzdFZhbGlkUGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VXAocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBmaXJzdFZhbGlkUGFydEluZGV4ID0gMDtcbiAgICAgICAgaWYocGFydC50eXBlICE9IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlyc3RWYWxpZFBhcnRJbmRleCA9IGFsbENhcmRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPiBmaXJzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0ZpcnN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgZmlyc3RWYWxpZFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmKHBhcnQudHlwZSAhPSBcImNhcmRcIil7XG4gICAgICAgICAgICBsZXQgYWxsQ2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0VmFsaWRQYXJ0SW5kZXggPSBhbGxDYXJkcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gZmlyc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBmaXJzdFZhbGlkUGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFBhcnQoYVBhcnQpe1xuICAgICAgICBpZighdGhpcy5hY2NlcHRzU3VicGFydChhUGFydC50eXBlKSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy50eXBlfSBkb2VzIG5vdCBhY2NlcHQgc3VicGFydHMgb2YgdHlwZSAke2FQYXJ0LnR5cGV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YoYVBhcnQpO1xuICAgICAgICBpZihmb3VuZCA8IDApe1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcnQgaXMgYSBjYXJkIHRoZW4gYXBwZW5kIGFmdGVyIHRoZSBsYXN0IGNhcmRcbiAgICAgICAgICAgIGlmKGFQYXJ0LnR5cGUgPT0gXCJjYXJkXCIpe1xuICAgICAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UoYWxsQ2FyZHMubGVuZ3RoLCAwLCBhUGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VicGFydHMucHVzaChhUGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTdGFjayxcbiAgICBTdGFjayBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBXaW5kb3cgUGFydFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBIFdpbmRvdyBpcyBhIFBhcnQgdGhhdCB3cmFwcyBhbm90aGVyXG4gKiBQYXJ0IG9mIHR5cGUgQ2FyZCwgU3RhY2ssIG9yIFdvcmxkU3RhY2tcbiAqIGluIGEgbW92ZWFibGUgd2luZG93LlxuICogSSBjYW4gYWxzbyBvcHRpb25hbGx5IGhvbGQgYSByZWZlcmVuY2VcbiAqIHRvIGEgdGFyZ2V0IFBhcnQgdGhhdCBJIGRvIG5vdCBvd24uIEkgY2FsbFxuICogdGhpcyBKUyBwcm9wZXJ0eSB0YXJnZXQgYW5kIEkgc3RvcmUgdGhlXG4gKiB0YXJnZXQgcGFydCdzIGlkIGFzIGEgSHlwZXJUYWxrIHByb3BlcnR5XG4gKiBjYWxsZWQgdGFyZ2V0SWQuXG4gKiBXaGVuIG15IG93bmVyIHBhcnQgaXMgdGhlIGN1cnJlbnQgdmlldywgSVxuICogd2lsbCBiZSB2aXNpYmxlIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2UuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi9TdGFjay5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkTGF5b3V0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBXaW5kb3cgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgbmFtZSwgdGFyZ2V0LCBkZXNlcmlhbGl6aW5nPWZhbHNlKXtcbiAgICAgICAgc3VwZXIob3duZXIsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImFyZWFcIixcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBcImZpZWxkXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgICAgICBcInJlc291cmNlXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdcIixcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBJZiB3ZSBwYXNzIGluIGEgdGFyZ2V0LFxuICAgICAgICAvLyBzZXQgaXQuXG4gICAgICAgIGlmKHRhcmdldCl7XG4gICAgICAgICAgICB0aGlzLnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHVwIFdpbmRvdyBzcGVjaWZpY1xuICAgICAgICAvLyBwYXJ0IHB0b3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgICAgIFwiTmV3IFdpbmRvdyBUaXRsZVwiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnaXNSZXNpemFibGUnLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICAvLyBTdHlsZVxuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICAvLyBwYXJ0IHNwZWNpZmljIGRlZmF1bHQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXRUYXJnZXQgPSB0aGlzLnNldFRhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV2luZG93Q2xvc2UgPSB0aGlzLm9uV2luZG93Q2xvc2UuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBBZGQgcHJpdmF0ZSBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignd2luZG93Q2xvc2UnLCB0aGlzLm9uV2luZG93Q2xvc2UpO1xuICAgIH1cblxuICAgIHNldFRhcmdldChhUGFydCl7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYVBhcnQ7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgdGhpcy50YXJnZXQuaWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1bnNldFRhcmdldCgpe1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlXG4gICAgICogVW5saWtlIG90aGVyIGtpbmRzIG9mIFBhcnRzLCBhIHdpbmRvd1xuICAgICAqIGhhcyBvbmx5IG9uZSBzdWJwYXJ0LCB3aGljaCBzaG91bGQgYmVcbiAgICAgKiBDYXJkLCBTdGFjaywgb3IgV29ybGRTdGFjay5cbiAgICAgKi9cbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0aGlzLmFjY2VwdHNTdWJwYXJ0KGFQYXJ0LnR5cGUpO1xuICAgICAgICBpZighaXNWYWxpZCl7XG4gICAgICAgICAgICAvLyBDb25zaWRlciByZXBsYWNpbmcgdGhpcyBnZW5lcmljIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCBhIG1lc3NhZ2UgYmFzZWQgYXBwcm9hY2ggdGhhdCBzZW5kc1xuICAgICAgICAgICAgLy8gdGhlc2Ugc29ydHMgb2Ygbm9uLWZhdGFsIGVycm9ycyB0byBTeXN0ZW1cbiAgICAgICAgICAgIC8vIGFzIGEga2luZCBvZiBtZXNzYWdlLiBUaGlzIHdheSB3ZSBjYW4gZGlzcGxheVxuICAgICAgICAgICAgLy8gZXJyb3JzIGluIFNpbXBsdFRhbGsgb2JqZWN0cy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2luZG93cyBjYW5ub3Qgd3JhcCBwYXJ0cyBvZiB0eXBlICR7YVBhcnQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhcnQoc3VicGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIG9uV2luZG93Q2xvc2Uoc2VuZGVycywgLi4uYXJncyl7XG4gICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gZGVsZXRlXG4gICAgICAgIC8vIHRoZSB3aW5kb3cgbW9kZWwgZnJvbSB0aGUgU3lzdGVtLlxuICAgICAgICAvLyBTY3JpcHRzIGNhbiBvdmVycmlkZSB0aGlzIGhhbmRsZXJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdkZWxldGVNb2RlbCcsXG4gICAgICAgICAgICAgICAgYXJnczogWyB0aGlzLmlkIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICd3aW5kb3cnO1xuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBXaW5kb3csXG4gICAgV2luZG93IGFzIGRlZmF1bHRcbn1cbiIsIi8qKlxuICogV29ybGRTdGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgU3RhY2sgcGFydCB0aGF0IHJlcHJlc2VudHMgdGhlIHJvb3Qgb2YgYVxuICogaGllcmFyY2h5IG9mIHBhcnRzLiBJIGFtIHRoZSBlbmQgb2YgdGhlIG93bmVyc2hpcFxuICogY2hhaW4gZm9yIGFueSBnaXZlbiBjb25maWd1cmF0aW9uIG9mIFBhcnRzLlxuICogSSBhbSBhbHNvIHRoZSBmaW5hbCByZXNvbHZlciBvZiBhbGwgdW5oYW5kbGVkXG4gKiBtZXNzYWdlcyBzZW50IGFsb25nIHRoZSBkZWxlZ2F0aW9uIGNoYWluIGZvciBwYXJ0cy5cbiAqIEFsbCBwYXJ0cyBjYW4gZXZlbnR1YWxseSByZXNvbHZlIHRvIG1lIHZpYSB0aGUgZGVsZWdhdGlvblxuICogY2hhaW4gb3Igb3duZXJzaGlwIGhpZXJhcmNoeS5cbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBpbnN0YW5jZSBvZiBtZSBpbiBhbnkgZ2l2ZW5cbiAqIFNpbXBsZVRhbGsgZW52aXJvbm1lbnQuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5cblxuY2xhc3MgV29ybGRTdGFjayBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKG51bGwpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXCJzdGFja1wiLCBcImltYWdlXCJdO1xuXG4gICAgICAgIHRoaXMuaXNXb3JsZCA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIHN0YWNrXG4gICAgICAgIC8vIGlkIG9mIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFNldCB0aGUgaWQgcHJvcGVydHkgdG8gYWx3YXlzXG4gICAgICAgIC8vIGJlICd3b3JsZCdcbiAgICAgICAgdGhpcy5pZCA9ICd3b3JsZCc7XG5cbiAgICAgICAgLy8gQmluZCBnZW5lcmFsIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZW5kT3BlblN0YWNrVG8gPSB0aGlzLnNlbmRPcGVuU3RhY2tUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8gPSB0aGlzLnNlbmRDbG9zZVN0YWNrVG8uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIG5hdmlnYXRpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLmdvVG9OZXh0U3RhY2sgPSB0aGlzLmdvVG9OZXh0U3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvUHJldlN0YWNrID0gdGhpcy5nb1RvUHJldlN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub050aFN0YWNrID0gdGhpcy5nb1RvTnRoU3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvU3RhY2tCeUlkID0gdGhpcy5nb1RvU3RhY2tCeUlkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvbW1hbmQgaGFuZGxlcnMgd2hpY2ggYXJlIG5vdCBuZWVkZWQgZm9yIHdvcmxkXG4gICAgICAgIHRoaXMucmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVVwXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVEb3duXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0ZpcnN0XCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0xhc3RcIik7XG4gICAgfVxuXG4gICAgZ29Ub05leHRTdGFjaygpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihzdGFja3MubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrSWQgPSB0aGlzLmN1cnJlbnRTdGFja0lkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IHN0YWNrcy5pbmRleE9mKGN1cnJlbnRTdGFjayk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCArIDE7XG4gICAgICAgIGlmKG5leHRJZHggPj0gc3RhY2tzLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0SWR4ID0gKG5leHRJZHggJSBzdGFja3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvU3RhY2tCeUlkKGFuSWQpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzLmZpbmQoc3RhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmlkID09IGFuSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZighbmV4dFN0YWNrKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIGlkOiAke2FuSWR9IGNhbnQgYmUgZm91bmQgb24gdGhpcyBzdGFja2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG5leHRTdGFjay5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50U3RhY2tJZCAhPSBuZXh0U3RhY2suaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VTdGFja1RvKGN1cnJlbnRTdGFjayk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuU3RhY2tUbyhuZXh0U3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZTdGFjaygpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihzdGFja3MubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrSWQgPSB0aGlzLmN1cnJlbnRTdGFja0lkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IHN0YWNrcy5pbmRleE9mKGN1cnJlbnRTdGFjayk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCAtIDE7XG4gICAgICAgIGlmKG5leHRJZHggPCAwKXtcbiAgICAgICAgICAgIG5leHRJZHggPSBzdGFja3MubGVuZ3RoICsgbmV4dElkeDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvTnRoU3RhY2soYW5JbmRleCl7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSB1c2luZyAxLWluZGV4ZWQgdmFsdWVzXG4gICAgICAgIC8vIHBlciB0aGUgU2ltcGxlVGFsayBzeXN0ZW1cbiAgICAgICAgbGV0IHRydWVJbmRleCA9IGFuSW5kZXggLSAxO1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZih0cnVlSW5kZXggPCAwIHx8IHRydWVJbmRleCA+IHN0YWNrcy5sZW5ndGggLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbmF2aWdhdGUgdG8gc3RhY2sgbnVtYmVyICR7YW5JbmRleH0gLS0gb3V0IG9mIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgbGV0IG5leHRTdGFjayA9IHN0YWNrc1t0cnVlSW5kZXhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kQ2xvc2VTdGFja1RvKGFTdGFjayl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbG9zZVN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIGFTdGFjayk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IGFTdGFjay5jdXJyZW50Q2FyZDtcbiAgICAgICAgaWYoY3VycmVudENhcmQpe1xuICAgICAgICAgICAgYVN0YWNrLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbG9zZUNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgYVN0YWNrLmN1cnJlbnRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbmRPcGVuU3RhY2tUbyhhU3RhY2spe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIGFTdGFjayk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IGFTdGFjay5jdXJyZW50Q2FyZDtcbiAgICAgICAgaWYoY3VycmVudENhcmQpe1xuICAgICAgICAgICAgYVN0YWNrLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsIFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlbkNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgYVN0YWNrLmN1cnJlbnRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnd29ybGQnO1xuICAgIH1cblxuICAgIGdldCBsb2FkZWRTdGFja3MoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBub3JtYWwgUGFydCBzZXJpYWxpemF0aW9uLlxuICAgIC8vIEhlcmUgd2UgbmVlZCB0byBhbHNvIGluY2x1ZGUgYW4gYXJyYXkgb2YgaWRzIG9mXG4gICAgLy8gbG9hZGVkIHN0YWNrcyBhbmQgdGhlIGlkIG9mIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgc2VyaWFsaXplKCl7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgc3VicGFydHM6IHRoaXMuc3VicGFydHMubWFwKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LmlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvd25lcklkOiBudWxsLFxuICAgICAgICAgICAgbG9hZGVkU3RhY2tzOiAodGhpcy5sb2FkZWRTdGFja3MubWFwKHN0YWNrID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2suaWQ7XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGN1cnJlbnQgcGFydCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHZhbHVlc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLl9wcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AuZ2V0VmFsdWUodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBmb3IgZGVsZWdhdGlvbi5cbiAgICAvLyBXZSBzZW5kIGFueSBtZXNzYWdlcyB0aGF0IHNob3VsZCBiZSBkZWxlZ2F0ZWRcbiAgICAvLyB0byB0aGUgZ2xvYmFsIFN5c3RlbSBvYmplY3QsIHdoaWNoIGhhcyBhbnlcbiAgICAvLyAnaGFuZGxlcnMgb2YgbGFzdCByZXNvcnQnXG4gICAgZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHdpbmRvdy5TeXN0ZW0pO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50U3RhY2tJZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50J1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50U3RhY2soKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RoaXMuY3VycmVudFN0YWNrSWRdO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHRoZSBiYXNlIGNsYXNzIG1ldGhvZHNcbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgaWYoIXRoaXMuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gZG9lcyBub3QgYWNjZXB0IHN1YnBhcnRzIG9mIHR5cGUgJHthUGFydC50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYoZm91bmQgPCAwKXtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJ0IGlzIGEgc3RhY2sgdGhlbiBhcHBlbmQgYWZ0ZXIgdGhlIGxhc3Qgc3RhY2tcbiAgICAgICAgICAgIGlmKGFQYXJ0LnR5cGUgPT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgICAgICBsZXQgYWxsU3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UoYWxsU3RhY2tzLmxlbmd0aCwgMCwgYVBhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVBhcnQuX293bmVyID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwic3RhY2tcIil7XG4gICAgICAgICAgICBsZXQgYWxsU3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwic3RhY2tcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsU3RhY2tzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbGFzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0xhc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBsYXN0VmFsaWRQYXJ0SW5kZXggPSB0aGlzLnN1YnBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKHBhcnQudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RWYWxpZFBhcnRJbmRleCA9IGFsbFN0YWNrcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IGxhc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBsYXN0VmFsaWRQYXJ0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRVcChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGZpcnN0VmFsaWRQYXJ0SW5kZXggPSAwO1xuICAgICAgICBpZihwYXJ0LnR5cGUgIT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBhbGxTdGFja3MgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJzdGFja1wiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaXJzdFZhbGlkUGFydEluZGV4ID0gYWxsU3RhY2tzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPiBmaXJzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0ZpcnN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgZmlyc3RWYWxpZFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmKHBhcnQudHlwZSAhPSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0VmFsaWRQYXJ0SW5kZXggPSBhbGxTdGFja3MubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA+IGZpcnN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgZmlyc3RWYWxpZFBhcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmV4cG9ydCB7XG4gICAgV29ybGRTdGFjayxcbiAgICBXb3JsZFN0YWNrIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgY3NzU3R5bGVyIGZyb20gJy4uL3V0aWxzLy9zdHlsZXIuanMnO1xuXG4vKipcbiAqIFBhcnRQcm9wZXJ0aWVzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmFzZVxuICogUGFydCBQcm9wZXJ0aWVzIGZvciBhbGwgUGFydHMuXG4gKiBJIGFsc28gaW5jbHVkZSBzb21lIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIG9uIG15IHByb3RvdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5XG4gKiBvdGhlciBQYXJ0cyB3aGVuIHRoZXkgaW5oZXJpdCBmcm9tIG1lLlxuICogRm9yIG5vdywgd2UgdXNlIE9iamVjdC5jcmVhdGUoKSBmb3IgaW5oZXJpdGFuY2UuXG4gKi9cblxuY2xhc3MgQmFzaWNQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seT1mYWxzZSwgYWxpYXNlcz1bXSl7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgIHRoaXMuYWxpYXNlcyA9IGFsaWFzZXM7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5nZXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhc0FsaWFzID0gdGhpcy5oYXNBbGlhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSB0aGlzLm1hdGNoZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzTmFtZU9yQWxpYXMgPSB0aGlzLm1hdGNoZXNOYW1lT3JBbGlhcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBiYXNpYyBwcm9wZXJ0aWVzLCB3ZSByZXR1cm5cbiAgICAvLyB0aGUgc2V0L3N0b3JlZCB2YWx1ZVxuICAgIGdldFZhbHVlKG93bmVyKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8vIEZvciB0aGUgYmFzaWMgcHJvcGVydGllcywgd2Ugc2V0XG4gICAgLy8gYmFzZWQgb24gdGhlIGluY29taW5nIGRlc2lyZWQgdmFsdWVcbiAgICAvLyBhbG9uZSAobm90aGluZyBpcyBjb21wdXRlZClcbiAgICBzZXRWYWx1ZShvd25lciwgdmFsLCBub3RpZnk9dHJ1ZSl7XG4gICAgICAgIGlmKCF0aGlzLnJlYWRPbmx5KXtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICAgICAgaWYobm90aWZ5KXtcbiAgICAgICAgICAgICAgICBvd25lci5wcm9wZXJ0eUNoYW5nZWQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHByb3BlcnR5XG4gICAgLy8gZ29lcyBieSB0aGUgZ2l2ZW4gYWxpYXNcbiAgICBoYXNBbGlhcyhhbkFsaWFzKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpYXNlcy5pbmNsdWRlcyhhbkFsaWFzKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG5hbWUgaXNcbiAgICAvLyBlaXRoZXIgYW4gYWxpYXMgb3IgdGhlIGV4YWN0IG5hbWVcbiAgICAvLyBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgIG1hdGNoZXNOYW1lT3JBbGlhcyhhTmFtZU9yQWxpYXMpe1xuICAgICAgICBpZih0aGlzLmhhc0FsaWFzKGFOYW1lT3JBbGlhcykpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZihhTmFtZU9yQWxpYXMgPT0gdGhpcy5uYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGluY29taW5nIFByb3BlcnR5XG4gICAgLy8gaGFzIHRoZSBzYW1lIG5hbWUgYW5kL29yIG9uZSBvZiB0aGUgc2FtZVxuICAgIC8vIGFsaWFzZXMgYXMgdGhpcyBQcm9wZXJ0eVxuICAgIG1hdGNoZXMoYVByb3BlcnR5KXtcbiAgICAgICAgaWYoYVByb3BlcnR5Lm5hbWUgPT0gdGhpcy5uYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYWxpYXNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgbGV0IG15QWxpYXMgPSB0aGlzLmFsaWFzZXNbaV07XG4gICAgICAgICAgICAgICAgaWYoYVByb3BlcnR5Lmhhc0FsaWFzKG15QWxpYXMpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5cbi8qKiBDdXN0b20gUHJvcGVydGllcyBhcmUgc2ltaWxhciB0byBkeW5hbWljIHByb3BzLCBleGNlcHQgdGhhdFxuICAqIHVuZGVyIHRoZSBob29kIHRoZXkgc3RvcmUgYW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgKiBzdG9yaW5nIHByb3BzIGRlZmluZWQgd2l0aGluIHRoZSBTVCBlbnZpcm9ubWVudC4gVGhlIGZpbmQoKVxuICAqIGFkZCgpIGRlbGV0ZSgpIG1ldGhvZHMgZmluZCwgYWRkLCBvciByZW1vdmUgcHJvcGVydGllcyBmcm9tIHRoZVxuICAqIHRoaXMuY3VzdG9tUHJvcGVydGllcyBvYmplY3QuXG4gKiovXG5jbGFzcyBDdXN0b21Qcm9wZXJ0eSBleHRlbmRzIEJhc2ljUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWU9XCJjdXN0b20tcHJvcGVydGllc1wiLCBkZWZhdWx0VmFsdWU9e30sIHJlYWRPbmx5PWZhbHNlLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seT1mYWxzZSwgYWxpYXNlcyk7XG4gICAgfVxuXG4gICAgZmluZChuYW1lKXtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl92YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYocHJvcCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhZGQoYVByb3BlcnR5KXtcbiAgICAgICAgLy8gTk9URTogYWxpYXNlcyBhcmUgY29tcGxldGVkIGlnbm9yZWQgZm9yIG5vd1xuICAgICAgICBpZighdGhpcy5maW5kKGFQcm9wZXJ0eS5uYW1lKSl7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZVthUHJvcGVydHkubmFtZV0gPSBhUHJvcGVydHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUoYVByb3BlcnR5KXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ZhbHVlW2FQcm9wZXJ0eS5uYW1lXTtcbiAgICB9XG5cblxuXG59O1xuXG5jbGFzcyBEeW5hbWljUHJvcGVydHkgZXh0ZW5kcyBCYXNpY1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzZXR0ZXIsIGdldHRlciwgcmVhZE9ubHk9ZmFsc2UsIGRlZmF1bHRWYWx1ZT1udWxsLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seSwgYWxpYXNlcyk7XG4gICAgICAgIHRoaXMudmFsdWVTZXR0ZXIgPSBzZXR0ZXI7XG4gICAgICAgIHRoaXMudmFsdWVHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhpcyBvdmVycmlkZSwgd2UgdXNlIHRoZSBnZXR0ZXJcbiAgICAvLyBpZiBhdmFpbGFibGUsIHRvIGR5bmFtaWNhbGx5IGdldCB0aGVcbiAgICAvLyBpbmNvbWluZyB2YWx1ZS5cbiAgICBnZXRWYWx1ZShvd25lcil7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlR2V0dGVyKG93bmVyLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBJbiB0aGlzIG92ZXJyaWRlLCB3ZSB1c2UgdGhlIHNldHRlclxuICAgIC8vIGlmIGF2YWlsYWJsZSwgdG8gZHluYW1pY2FsbHkgc2V0IHRoZVxuICAgIC8vIGluY29taW5nIHZhbHVlXG4gICAgc2V0VmFsdWUob3duZXIsIHZhbCwgbm90aWZ5PXRydWUpe1xuICAgICAgICBpZighdGhpcy5yZWFkT25seSl7XG4gICAgICAgICAgICB0aGlzLnZhbHVlU2V0dGVyKG93bmVyLCB0aGlzLCB2YWwsIG5vdGlmeSk7XG4gICAgICAgICAgICBpZihub3RpZnkpe1xuICAgICAgICAgICAgICAgIG93bmVyLnByb3BlcnR5Q2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKiogSSBhbSBhIHNwZWNpYWwgcHJvcGVydHkgd2hpY2ggaGFuZGxlcyBpbnRlcmZhY2luZyB3aXRoIHRoZVxuICAqIHRoZSBjc3NTdHlsZSBiYXNpYyBwcm9wZXJ0eS4gV2hlbmV2ZXIgSSBhbSB1cGRhdGVkIEkgbWFrZVxuICAqIHN1cmUgdG8gdXBkYXRlIHRoZSBjc3NTdHlsZSBwcm9wZXJ0eSB2aWEgdGhlIHN0eWxlciB1dGlsaXR5XG4gICogZnVuY3Rpb24uIEkgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGRpZmZlcmVudCBhbmQgaW5kZXBlbnRcbiAgKiBzdHlsaW5nIG9wdGlvbnMuXG4gICoqL1xuY2xhc3MgU3R5bGVQcm9wZXJ0eSBleHRlbmRzIEJhc2ljUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlZmF1bHRWYWx1ZSwgIHByb3BOYW1lPSdjc3NTdHlsZScsIHN0eWxlcj1jc3NTdHlsZXIsIHJlYWRPbmx5PWZhbHNlLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seSwgYWxpYXNlcyk7XG4gICAgICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICAgICAgdGhpcy5zdHlsZXIgPSBzdHlsZXI7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhpcyBvdmVycmlkZSwgd2UgdXBkYXRlIHRoZSBjc3NTdHlsZSBwcm9wZXJ0eVxuICAgIHNldFZhbHVlKG93bmVyLCB2YWwsIG5vdGlmeT10cnVlKXtcbiAgICAgICAgaWYoIXRoaXMucmVhZE9ubHkpe1xuICAgICAgICAgICAgbGV0IHN0eWxlUHJvcGVydHkgPSBvd25lci5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCh0aGlzLnByb3BOYW1lKTtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHN0eWxlUHJvcGVydHkuZ2V0VmFsdWUob3duZXIpO1xuICAgICAgICAgICAgbGV0IG5ld1N0eWxlID0gdGhpcy5zdHlsZXIoc3R5bGUsIHRoaXMubmFtZSwgdmFsKTtcbiAgICAgICAgICAgIHN0eWxlUHJvcGVydHkuc2V0VmFsdWUob3duZXIsIG5ld1N0eWxlLCBub3RpZnkpO1xuXG4gICAgICAgICAgICAvLyBzZXQgbXkgdmFsdWUgYXMgd2VsbFxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICBpZihub3RpZnkpe1xuICAgICAgICAgICAgICAgIG93bmVyLnByb3BlcnR5Q2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY2xhc3MgUGFydFByb3BlcnRpZXMge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuaGFzUHJvcGVydHkgPSB0aGlzLmhhc1Byb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkgPSB0aGlzLmFkZFByb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlUHJvcGVydHkgPSB0aGlzLnJlbW92ZVByb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmluZFByb3BlcnR5TmFtZWQgPSB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHlOYW1lZCA9IHRoaXMuc2V0UHJvcGVydHlOYW1lZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFByb3BlcnR5TmFtZWQgPSB0aGlzLmdldFByb3BlcnR5TmFtZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXdCYXNpY1Byb3AgPSB0aGlzLm5ld0Jhc2ljUHJvcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5ld1N0eWxlUHJvcCA9IHRoaXMubmV3U3R5bGVQcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubmV3RHluYW1pY1Byb3AgPSB0aGlzLm5ld0R5bmFtaWNQcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2luZGV4T2ZQcm9wZXJ0eSA9IHRoaXMuX2luZGV4T2ZQcm9wZXJ0eS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCBhbGwoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjb2xsZWN0aW9uICdoYXMnIGEgcHJvcGVydHkgaWYgaXQgY29udGFpbnNcbiAgICAvLyBhIFByb3BlcnR5IG9iamVjdCB3aXRoIG1hdGNoaW5nIG5hbWUgb3IgYWxpYXNcbiAgICAvLyBvZiB0aGUgaW5jb21pbmcgcHJvcGVydHkuXG4gICAgaGFzUHJvcGVydHkoYVByb3BlcnR5KXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYoYVByb3BlcnR5Lm1hdGNoZXMocHJvcCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIG9uZSBvZiBteSBQcm9wZXJ0aWVzIGJ5XG4gICAgLy8gYSBuYW1lIG9yIGFsaWFzLiBSZXR1cm5zIG51bGxcbiAgICAvLyBpZiBubyBtYXRjaCBmb3VuZC4gUGVyaGFwcyB3ZSBzaG91bGRcbiAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgIGZpbmRQcm9wZXJ0eU5hbWVkKGFOYW1lKXtcbiAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgbGV0IGN1c3RvbVByb3BlcnRpZXNQcm9wO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fcHJvcGVydGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuX3Byb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBpZihwcm9wLm1hdGNoZXNOYW1lT3JBbGlhcyhhTmFtZSkpe1xuICAgICAgICAgICAgICAgIGZvdW5kID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIGN1c3RvbSBwcm9wZXJ0aWVzIHByb3AsIGFzIHdlIG1pZ2h0IG5lZWQgaXRcbiAgICAgICAgICAgIC8vIGZvciBsYXRlclxuICAgICAgICAgICAgaWYocHJvcC5tYXRjaGVzTmFtZU9yQWxpYXMoXCJjdXN0b20tcHJvcGVydGllc1wiKSl7XG4gICAgICAgICAgICAgICAgY3VzdG9tUHJvcGVydGllc1Byb3AgPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiB0aGUgcHJvcGVydHkgaXMgY3VzdG9tXG4gICAgICAgIGlmKCFmb3VuZCAmJiBjdXN0b21Qcm9wZXJ0aWVzUHJvcCl7XG4gICAgICAgICAgICBmb3VuZCA9IGN1c3RvbVByb3BlcnRpZXNQcm9wLmZpbmQoYU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0cyB0byBnZXQgdGhlICp2YWx1ZSogb2YgdGhlIHByb3BlcnR5XG4gICAgLy8gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciBhbGlhcy5cbiAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB3ZSB0aHJvdyBhblxuICAgIC8vIGVycm9yXG4gICAgZ2V0UHJvcGVydHlOYW1lZChvd25lciwgYU5hbWUpe1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkKGFOYW1lKTtcbiAgICAgICAgaWYoIWZvdW5kKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvd25lcn0gZG9lcyBub3QgaGF2ZSBwcm9wZXJ0eSBcIiR7YU5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQuZ2V0VmFsdWUob3duZXIpO1xuICAgIH1cblxuICAgIC8vIEF0dGVtcHRzIHRvIHNldCB0aGUgKnZhbHVlKiBvZiB0aGUgcHJvcGVydHlcbiAgICAvLyB3aXRoIHRoZSBnaXZlbiBuYW1lIG9yIGFsaWFzLlxuICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHdlIHRocm93IGFuXG4gICAgLy8gZXJyb3JcbiAgICBzZXRQcm9wZXJ0eU5hbWVkKG93bmVyLCBhTmFtZSwgYVZhbHVlLCBub3RpZnk9dHJ1ZSl7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZmluZFByb3BlcnR5TmFtZWQoYU5hbWUpO1xuICAgICAgICBpZighZm91bmQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke293bmVyfSBkb2VzIG5vdCBoYXZlIHByb3BlcnR5IFwiJHthTmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZC5zZXRWYWx1ZShvd25lciwgYVZhbHVlLCBub3RpZnkpO1xuICAgIH1cblxuICAgIC8vIElmIHlvdSBhZGQgYSBwcm9wZXJ0eSB3aXRoIGEgbmFtZSBvciBhbGlhc1xuICAgIC8vIHRoYXQgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBjb2xsZWN0aW9uLFxuICAgIC8vIHRoZW4gd2UgJ292ZXJ3cml0ZScgaXQgYnkgcmVtb3ZpbmcgdGhlIGV4aXNpbmdcbiAgICAvLyBwcm9wZXJ0eSBhbmQgcmVwbGFjaW5nIGl0IHdpdGggdGhlIGluY29taW5nIG9uZS5cbiAgICAvLyBPdGhlcndpc2UsIHdlIGp1c3QgYWRkIHRoZSBwcm9wZXJ0eVxuICAgIGFkZFByb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGlmKHRoaXMuaGFzUHJvcGVydHkoYVByb3BlcnR5KSl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5KGFQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvcGVydGllcy5wdXNoKGFQcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZpbmcgYSBwcm9wZXJ0eSBoZXJlIG1lYW5zIHJlbW92aW5nXG4gICAgLy8gaXQgZnJvbSB0aGUgc3RvcmVkIGFycmF5LiBJZiB0aGUgcHJvcGVydHlcbiAgICAvLyBpcyBub3QgaW4gdGhlIGFycmF5LCB3ZSBkbyBOT1QgdGhyb3cgYW4gZXJyb3IuXG4gICAgLy8gV2UganVzdCBnbyBvbiB3aXRoIG91ciBsaXZlcywgYmVjYXVzZSB3aG8gY2FyZXM/XG4gICAgcmVtb3ZlUHJvcGVydHkoYVByb3BlcnR5KXtcbiAgICAgICAgbGV0IHByb3BJbmRleCA9IHRoaXMuX2luZGV4T2ZQcm9wZXJ0eShhUHJvcGVydHkpO1xuICAgICAgICBpZihwcm9wSW5kZXggPj0gMCl7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnNwbGljZShwcm9wSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBiYXNpY1xuICAgIC8vIHByb3BlcnR5LlxuICAgIG5ld0Jhc2ljUHJvcCguLi5hcmdzKXtcbiAgICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgQmFzaWNQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShuZXdQcm9wKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IGN1c3RvbVxuICAgIC8vIHByb3BlcnR5LlxuICAgIG5ld0N1c3RvbVByb3AoLi4uYXJncyl7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IEN1c3RvbVByb3BlcnR5KC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KG5ld1Byb3ApO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXcgc3R5bGVcbiAgICAvLyBwcm9wZXJ0eS5cbiAgICBuZXdTdHlsZVByb3AoLi4uYXJncyl7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IFN0eWxlUHJvcGVydHkoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ld1xuICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgIG5ld0R5bmFtaWNQcm9wKC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbmV3UHJvcCA9IG5ldyBEeW5hbWljUHJvcGVydHkoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QuIEZpbmRzIHRoZSBmaXJzdCBvY2N1cnJpbmdcbiAgICAvLyBpbmRleCBvZiB0aGUgZ2l2ZW4gUHJvcGVydHkgaW4gdGhlIGFycmF5XG4gICAgLy8gb2YgcHJvcGVydGllcyBpbiB0aGlzIGNvbGxlY3Rpb24uIFJldHVybnNcbiAgICAvLyAtMSBpZiBub3QgZm91bmQsIHBlciBKUyBpbXBsZW1lbnRhdGlvbi5cbiAgICBfaW5kZXhPZlByb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYoYVByb3BlcnR5Lm1hdGNoZXMocHJvcCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnRQcm9wZXJ0aWVzLFxuICAgIEJhc2ljUHJvcGVydHksXG4gICAgQ3VzdG9tUHJvcGVydHksXG4gICAgRHluYW1pY1Byb3BlcnR5LFxuICAgIFBhcnRQcm9wZXJ0aWVzIGFzIGRlZmF1bHRcbn07XG4iLCIvKiogU2Vjb25kIHBhc3MgYXQgc3ludGF4IGhpZ2hsaWdodGVyIHNlbWFudGljcyAqKi9cbmNvbnN0IHN5bnRheFNwYW4gPSAocnVsZU5hbWUpID0+IHtcbiAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3N0LXN5bnRheCcpO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKCdkYXRhLXN0LXJ1bGUnLCBydWxlTmFtZSk7XG4gICAgcmV0dXJuIHNwYW47XG59XG5cbmNvbnN0IGNyZWF0ZUhpZ2hsaWdodGVyID0gKGZpZWxkRWxlbWVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIE1lc3NhZ2VIYW5kbGVyT3BlbjogZnVuY3Rpb24obGl0ZXJhbE9uLCBtZXNzYWdlTmFtZSwgb3B0aW9uYWxQYXJhbUxpc3Qpe1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBzeW50YXhTcGFuKFwiTWVzc2FnZUhhbmRsZXJPcGVuXCIpO1xuICAgICAgICAgICAgbGV0IG9uU3BhbiA9IHN5bnRheFNwYW4oXCJrZXl3b3JkXCIpO1xuICAgICAgICAgICAgb25TcGFuLmFwcGVuZChcIm9uIFwiKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKG9uU3Bhbik7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCBzdWItcnVsZXNcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKG1lc3NhZ2VOYW1lLmhpZ2hsaWdodFN5bnRheCgpKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKC4uLm9wdGlvbmFsUGFyYW1MaXN0LmhpZ2hsaWdodFN5bnRheCgpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWVzc2FnZUhhbmRsZXJDbG9zZShsaXRlcmFsRW5kLCBtZXNzYWdlTmFtZSl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IHN5bnRheFNwYW4oXCJNZXNzYWdlSGFuZGxlckNsb3NlXCIpO1xuICAgICAgICAgICAgbGV0IGVuZFNwYW4gPSBzeW50YXhTcGFuKFwia2V5d29yZFwiKTtcbiAgICAgICAgICAgIGVuZFNwYW4uYXBwZW5kKFwiZW5kIFwiKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKGVuZFNwYW4pO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBhcnRzXG4gICAgICAgICAgICBzcGFuLmFwcGVuZChtZXNzYWdlTmFtZS5oaWdobGlnaHRTeW50YXgoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9LFxuXG4gICAgICAgIFBhcmFtZXRlckxpc3Q6IGZ1bmN0aW9uKHBhcmFtU3RyaW5nKXtcbiAgICAgICAgICAgIGxldCBvdXRlciA9IHN5bnRheFNwYW4oXCJQYXJhbWV0ZXJMaXN0XCIpO1xuICAgICAgICAgICAgbGV0IGlubmVySXRlbXMgPSBwYXJhbVN0cmluZy5hc0l0ZXJhdGlvbigpLmNoaWxkcmVuLm1hcChwYXJhbU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzcGFuID0gc3ludGF4U3BhbihcIlBhcmFtZXRlckxpc3QtaXRlbVwiKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZChwYXJhbU5hbWUuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Bhbi5vdXRlckhUTUw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dGVyLmlubmVySFRNTCA9IGlubmVySXRlbXMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG91dGVyO1xuICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZU5hbWU6IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZCgnc3Qtc3ludGF4Jyk7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnZGF0YS1zdC1ydWxlJywgJ21lc3NhZ2VOYW1lJyk7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZChzdHJpbmcuc291cmNlU3RyaW5nICsgXCIgXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5d29yZDogZnVuY3Rpb24oc3RyaW5nKXtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdzdC1zeW50YXgnKTtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKCdkYXRhLXN0LXJ1bGUnLCAna2V5d29yZCcpO1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmQoc3RyaW5nLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnQge1xuICAgIGNyZWF0ZUhpZ2hsaWdodGVyLFxuICAgIGNyZWF0ZUhpZ2hsaWdodGVyIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFV0aWxpdGllcyBmb3IgQ2xpcGJvYXJkIEZ1bmN0aW9uYWxpdHlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRm9yIHRoZSBtb21lbnQgd2UgdXNlIGEgdmVyeSBwcmltaXRpdmUgc3RhbmQtaW5cbiAqIHNpbmNlIHRoZSBDbGlwYm9hcmQgQVBJIGlzIG5vdCBzdGFuZGFyZGl6ZWQgYWNyb3NzXG4gKiBicm93c2VyIGltcGxlbWVudGF0aW9ucy5cbiAqKi9cbmltcG9ydCBpZE1ha2VyIGZyb20gJy4vaWQuanMnO1xuaW1wb3J0IHtTVERlc2VyaWFsaXplciwgU1RTZXJpYWxpemVyfSBmcm9tICcuL3NlcmlhbGl6YXRpb24uanMnO1xuXG5jbGFzcyBTVENsaXBib2FyZCB7XG4gICAgY29uc3RydWN0b3IoYVN5c3RlbSl7XG4gICAgICAgIHRoaXMuc3lzdGVtID0gYVN5c3RlbTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IFtdO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5jb3B5UGFydCA9IHRoaXMuY29weVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXN0ZUNvbnRlbnRzSW50byA9IHRoaXMucGFzdGVDb250ZW50c0ludG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlTGVuc2VkQ2hpbGRyZW4gPSB0aGlzLl9jcmVhdGVMZW5zZWRDaGlsZHJlbi5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvcHlQYXJ0KGFQYXJ0KXtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZXIgPSBuZXcgU1RTZXJpYWxpemVyKHRoaXMuc3lzdGVtKTtcbiAgICAgICAgbGV0IHJvb3RTZXJpYWxpemF0aW9uID0gc2VyaWFsaXplci5zZXJpYWxpemUoYVBhcnQsIGZhbHNlKTtcbiAgICAgICAgbGV0IGl0ZW0gPSBuZXcgU1RDbGlwYm9hcmRJdGVtKFxuICAgICAgICAgICAgJ3NpbXBsZXRhbGsvanNvbicsXG4gICAgICAgICAgICByb290U2VyaWFsaXphdGlvbixcbiAgICAgICAgICAgIGFQYXJ0LnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IFtpdGVtXTtcbiAgICB9XG5cbiAgICBwYXN0ZUNvbnRlbnRzSW50byhhVGFyZ2V0UGFydCl7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IHRoaXMuY29udGVudHMubWFwKGNsaXBib2FyZENvbnRlbnQgPT4ge1xuICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudC5kYXRhO1xuICAgICAgICAgICAgbGV0IGRlc2VyaWFsaXplciA9IG5ldyBTVERlc2VyaWFsaXplcih0aGlzLnN5c3RlbSk7XG4gICAgICAgICAgICBkZXNlcmlhbGl6ZXIudGFyZ2V0SWQgPSBhVGFyZ2V0UGFydC5pZDtcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENvbnRlbnQpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdG9wIGFuZCBsZWZ0IHZhbHVlcyB0byB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXN0ZWQgcGFydCBkb2Vzbid0IHJ1biBvdXRzaWRlIG9mIHRoZSBuZXdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRpdmUgYm91bmRzIGluIHdoaWNoIGl0IGhhcyBiZWVuIHBhc3RlZFxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGFydCA9IGRlc2VyaWFsaXplci5yb290UGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNUb3AgPSBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCd0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0xlZnQgPSBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1RvcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihoYXNMZWZ0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcnQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiBIYWxvIG9uIHRoZSBuZXcgdmlld1xuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZXIucm9vdFZpZXdzWzBdLm9wZW5IYWxvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIEN1c3RvbUV2ZW50IHRoYXQgbm90aWZpZXMgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYSBuZXcgdmlldyB3YXMgYWRkZWQgKHVzZWQgYnkgTmF2IGV0YylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzdC12aWV3LWFkZGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydFR5cGU6IG5ld1BhcnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IG5ld1BhcnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJZDogbmV3UGFydC5fb3duZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplci5yb290Vmlld3NbMF0uZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFueSBsZW5zZWQgdmlld3MgdGhhdCBtaWdodCBiZSBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvb3RMZW5zVmlld3MgPSB0aGlzLnN5c3RlbS5maW5kTGVuc1ZpZXdzQnlJZChuZXdQYXJ0Ll9vd25lci5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RMZW5zVmlld3MuZm9yRWFjaChsZW5zVmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TGVuc1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQobmV3UGFydC50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldE1vZGVsKG5ld1BhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIG5ld1BhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbnNWaWV3LmFwcGVuZENoaWxkKG5ld0xlbnNWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxlbnNlZENoaWxkcmVuKG5ld0xlbnNWaWV3LCBuZXdQYXJ0LnN1YnBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlTGVuc2VkQ2hpbGRyZW4oYUxlbnNWaWV3LCBzdWJwYXJ0cyl7XG4gICAgICAgIHN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3TGVuc1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIHRoaXMuc3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQoc3VicGFydC50eXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldE1vZGVsKHN1YnBhcnQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIHN1YnBhcnQuaWQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgIGFMZW5zVmlldy5hcHBlbmRDaGlsZChuZXdMZW5zVmlldyk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVMZW5zZWRDaGlsZHJlbihuZXdMZW5zVmlldywgc3VicGFydC5zdWJwYXJ0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBnZXQgaXNFbXB0eSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGggPD0gMDtcbiAgICB9XG59XG5cbmNsYXNzIFNUQ2xpcGJvYXJkSXRlbSB7XG4gICAgY29uc3RydWN0b3IobWltZVR5cGUsIGRhdGEsIHBhcnRUeXBlKXtcbiAgICAgICAgaWYobWltZVR5cGUpe1xuICAgICAgICAgICAgdGhpcy50eXBlID0gbWltZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFydFR5cGUpe1xuICAgICAgICAgICAgdGhpcy5fcGFydFR5cGUgPSBwYXJ0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGFydFR5cGUoKXtcbiAgICAgICAgaWYodGhpcy50eXBlID09ICdzaW1wbGV0YWxrL2pzb24nKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXQgcGFydFR5cGUodmFsKXtcbiAgICAgICAgdGhpcy5fcGFydFR5cGUgPSB2YWw7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTVENsaXBib2FyZCxcbiAgICBTVENsaXBib2FyZCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBFcnJvciBIYW5kbGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gcmVzcG9uc2libGUgZm9yIGhhbmRsZXIgYWxsXG4gKiBTeXN0ZW0td2lkZSBlcnJvcnNcbiAqL1xuXG5jb25zdCBlcnJvckhhbmRsZXIgPSB7XG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLm5hbWUpe1xuICAgICAgICAgICAgY2FzZSAnR3JhbW1hck1hdGNoRXJyb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUdyYW1tYXJNYXRjaEVycm9yKGFNZXNzYWdlKTtcbiAgICAgICAgICAgIGNhc2UgJ01lc3NhZ2VOb3RVbmRlcnN0b29kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNZXNzYWdlTm90VW5kZXJzdG9vZChhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlmIEkgZG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggdGhpcyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgLy8gSSBzZW5kIGl0IGFsb25nIHRvIHRoZSBTeXN0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5yZWNlaXZlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlR3JhbW1hck1hdGNoRXJyb3I6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gVE9ETyBpcyB0aGVyZSBhIG1vcmUgc3RydWN0dXJlZCB3YXkgdG8gZ2V0IHRoaXMgb3V0IG9mIG9obT9cbiAgICAgICAgbGV0IHJlZ2V4ID0gL0xpbmUgKD88bGluZT5cXGQpLCBjb2wgKD88Y29sdW1uPlxcZCkvO1xuICAgICAgICBsZXQgbWF0Y2ggPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQubWVzc2FnZS5tYXRjaChyZWdleCk7XG4gICAgICAgIGxldCBlcnJvckxpbmVOdW0gPSBwYXJzZUludChtYXRjaC5ncm91cHNbXCJsaW5lXCJdKSAtIDE7IC8vIG9obSBsaW5lcyBzdGFydCB3aXRoIDEgXG4gICAgICAgIC8vIHNlZSBpZiB0aGUgZ3JhbW1hciBydWxlIGhhcyBiZWVuIGlkZW50aWZpZWRcbiAgICAgICAgbGV0IHJ1bGVOYW1lO1xuICAgICAgICBsZXQgcmlnaHRNb3N0RmFpbHVyZXMgPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQuZ2V0UmlnaHRtb3N0RmFpbHVyZXMoKTtcbiAgICAgICAgaWYocmlnaHRNb3N0RmFpbHVyZXNbMV0pe1xuICAgICAgICAgICAgcnVsZU5hbWUgPSByaWdodE1vc3RGYWlsdXJlc1sxXS5wZXhwci5ydWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgc29tZSBtb3JlIGluZm8gYWJvdXQgd2hhdCB0aGUgcGFyc2VyIGV4cGVjdGVkXG4gICAgICAgIGxldCBleHBlY3RlZFRleHQgPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQuZ2V0RXhwZWN0ZWRUZXh0KCk7XG4gICAgICAgIC8vIGdldCB0aGUgb3JpZ2luYWwgc2NyaXB0XG4gICAgICAgIGxldCB0ZXh0ID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmlucHV0O1xuICAgICAgICBsZXQgdGV4dExpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgLy8gcmVwbGFjZSBzYWlkIHRleHQgbGluZSB3aXRoIGFuIGVycm9yIG1hcmtlclxuICAgICAgICB0ZXh0TGluZXNbZXJyb3JMaW5lTnVtXSArPSBgIC0tPDw8W0V4cGVjdGVkOiR7ZXhwZWN0ZWRUZXh0fTsgcnVsZU5hbWU6IFwiJHtydWxlTmFtZX1cIl1gO1xuICAgICAgICB0ZXh0ID0gdGV4dExpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBwYXJzZWQgc2NyaXB0IGlzIFwiZG9JdFwiIHRoZW4gdGhlIHN0YXRlbWVudExpbmVzIGFyZVxuICAgICAgICAvLyBsb2NhdGVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHRleHQsIG5vdCB0aGUgc2NyaXB0LCBwcm9wZXJ0eSBhbmRcbiAgICAgICAgLy8gd2Ugd2FudCB0aGUgZXJyb3IgdG8gYmUgbWFya2VkIHVwIGluIHRoZSBmaWVsZCB0ZXh0YXJlYVxuICAgICAgICBpZihhTWVzc2FnZS5wYXJzZWRTY3JpcHQuaW5wdXQuc3RhcnRzV2l0aChcIm9uIGRvSXRcIikpe1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyTW9kZWwgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFthTWVzc2FnZS5wYXJ0SWRdO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBnZXQgdGhlIG9yaWdpbmFsIHRleHQgc28gYXMgbm90IHRvIGNvbXBsZXRlbHkgcmVwbGFjZSBpdFxuICAgICAgICAgICAgLy8gdGhlbiBpbnNlcnQgdGhlIG1hcmt1cCBpbiB0aGUgYXBwcm9wcmlhdGUgbGluZVxuICAgICAgICAgICAgbGV0IGZpZWxkVGV4dCA9IG9yaWdpbmFsU2VuZGVyTW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvcmlnaW5hbFNlbmRlck1vZGVsLCBcInRleHRcIik7XG4gICAgICAgICAgICBsZXQgc2NyaXB0ID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmlucHV0O1xuICAgICAgICAgICAgc2NyaXB0ID0gdGhpcy5fY2xlYW5Eb0l0U0NyaXB0KHNjcmlwdCk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBcImRvSXRcIiBoYW5kbGVyIGluc2VydGVkIGJhY2sgaW4sIHNpbmNlIGl0J3MganVzdCBhIGhpZGRlbiB3cmFwcGVyIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHN0YXRlbWVudCBsaW5lc1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuX2NsZWFuRG9JdFNDcmlwdCh0ZXh0KTtcbiAgICAgICAgICAgIGZpZWxkVGV4dCA9IGZpZWxkVGV4dC5yZXBsYWNlKHNjcmlwdCwgdGV4dCk7XG4gICAgICAgICAgICBvcmlnaW5hbFNlbmRlck1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQob3JpZ2luYWxTZW5kZXJNb2RlbCwgXCJ0ZXh0XCIsIGZpZWxkVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBsb2NhdGUgdGhlIHNjcmlwdCBlZGl0b3IgaW4gcXVlc3Rpb25cbiAgICAgICAgICAgIGxldCBzY3JpcHRFZGl0b3IgPSB3aW5kb3cuU3lzdGVtLmZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkKGFNZXNzYWdlLnBhcnRJZCk7XG4gICAgICAgICAgICBpZighc2NyaXB0RWRpdG9yKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGVuU2NyaXB0RWRpdG9yKGFNZXNzYWdlLnBhcnRJZCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChhTWVzc2FnZS5wYXJ0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyaXB0RWRpdG9yLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2NyaXB0RWRpdG9yLm1vZGVsLCBcInRleHRcIiwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3BlbiB0aGUgZ3JhbW1hciBpZiB0aGVyZSBpcyBub3Qgb25lIG9wZW4gYWxyZWFkeVxuICAgICAgICBsZXQgY3VycmVudENhcmQgPSB3aW5kb3cuU3lzdGVtLmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICAgICAgbGV0IGdyYW1tYXIgPSBjdXJyZW50Q2FyZC5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocGFydC50eXBlID09IFwiZmllbGRcIikgJiYgKHBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChwYXJ0LCBcIm5hbWVcIikgPT0gXCJTaW1wbGVUYWxrXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoZ3JhbW1hci5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICB0aGlzLl9vcGVuR3JhbW1hcihhTWVzc2FnZS5wYXJ0SWQsIHJ1bGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVNZXNzYWdlTm90VW5kZXJzdG9vZChhTWVzc2FnZSl7XG4gICAgICAgIGxldCBvZmZlbmRpbmdNZXNzYWdlID0gYU1lc3NhZ2UubWVzc2FnZTtcbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gb2ZmZW5kaW5nTWVzc2FnZS5zZW5kZXJzWzBdO1xuICAgICAgICAvLyBBcmUgd2UgZXZlciBnb2luZyB0byBoYXZlIE1OVSBlcnJvcnMgb24gbWVzc2FnZXMgdGhhdFxuICAgICAgICAvLyBhcmUgbm90IHR5cGU6IGNvbW1hbmQ/XG4gICAgICAgIGlmKG9mZmVuZGluZ01lc3NhZ2UudHlwZSA9PT0gXCJjb21tYW5kXCIpe1xuICAgICAgICAgICAgbGV0IGNvbW1hbmROYW1lID0gb2ZmZW5kaW5nTWVzc2FnZS5jb21tYW5kTmFtZTtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFNlbmRlck1vZGVsID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbb3JpZ2luYWxTZW5kZXIuaWRdO1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXHMqJHtjb21tYW5kTmFtZX0oXFxzfFxcbnwkKWAsICdnJyk7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgICAgICBsZXQgZXhlY3V0aW9uU3RhY2sgPSB3aW5kb3cuU3lzdGVtLmV4ZWN1dGlvblN0YWNrLl9zdGFjaztcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBleGVjdXRpb24gc3RhY2sgaXMgXCJkb0l0XCIgdGhlbiB0aGUgc3RhdGVtZW50TGluZXMgYXJlXG4gICAgICAgICAgICAvLyBsb2NhdGVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHRleHQsIG5vdCB0aGUgc2NyaXB0LCBwcm9wZXJ0eSBhbmRcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdGhlIGVycm9yIHRvIGJlIG1hcmtlZCB1cCBpbiB0aGUgZmllbGQgdGV4dGFyZWFcbiAgICAgICAgICAgIGlmKGV4ZWN1dGlvblN0YWNrWzBdICYmIGV4ZWN1dGlvblN0YWNrWzBdLm1lc3NhZ2VOYW1lID09IFwiZG9JdFwiKXtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBleGVjdXRpb25TdGFja1swXS5wYXJ0O1xuICAgICAgICAgICAgICAgIHRleHQgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvcmlnaW5hbFNlbmRlck1vZGVsLCAndGV4dCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb3JpZ2luYWxTZW5kZXJNb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKG9yaWdpbmFsU2VuZGVyTW9kZWwsICdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICBsZXQgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChvcmlnaW5hbFNlbmRlci5pZCk7XG4gICAgICAgICAgICAgICAgaWYoIXNjcmlwdEVkaXRvcil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5TY3JpcHRFZGl0b3Iob3JpZ2luYWxTZW5kZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRFZGl0b3IgPSB3aW5kb3cuU3lzdGVtLmZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkKG9yaWdpbmFsU2VuZGVyLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoc2NyaXB0RWRpdG9yKXtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2NyaXB0RWRpdG9yLm1vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gU29ydCB0aGlzIG91dFxuICAgICAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dExpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBvZmZlbmRpbmcgY29tbWFuZCB0ZXh0IGxpbmUgd2l0aCBhbiBlcnJvciBtYXJrZXJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0TGluZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmKGxpbmUubWF0Y2gocmVnZXgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IGxpbmUgKz0gYCAtLTw8PFtNZXNzYWdlTm90VW5kZXJzdG9vZDogY29tbWFuZDsgY29tbWFuZE5hbWU6IFwiJHtjb21tYW5kTmFtZX1cIl1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0TGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwidGV4dFwiLCB0ZXh0KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmluYWxseSBvcGVuIHRoZSBkZWJ1Z2dlciAob3IgY3VycmVudCB2ZXJzaW9uIHRoZXJlb2YpXG4gICAgICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIGEgYml0IGRhbmdlcm91cywgYi9jIGlmIHRoZSBTeXN0ZW0gZG9lc24ndFxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBgb3BlbkRlYnVnZ2VyYCBjb21tYW5kIGFueXdoZXJlIGl0IHdpbGwgdGhyb3dcbiAgICAgICAgICAgIC8vIGEgTU5VIGVycm9yLCB3aGljaCB3aWxsIHRoZW4gaW52b2tlIHRoaXMgaGFuZGxlciBjdWFzaW5nXG4gICAgICAgICAgICAvLyBhbiBpbmZpbml0ZSBsb29wIVxuICAgICAgICAgICAgdGhpcy5fb3BlbkRlYnVnZ2VyKG9yaWdpbmFsU2VuZGVyLmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYW5Eb0l0U0NyaXB0KHNjcmlwdCl7XG4gICAgICAgIC8vIGNsZWFuIHVwIHRoZSBEb0l0IHNjcmlwdCBieSByZW1vdmluZyB0aGUgaGFuZGxlclxuICAgICAgICAvLyBuZXdsaW5lcywgdGFicyBhbmQgc3BhY2VzXG4gICAgICAgIHNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlKFwib24gZG9JdFwiLCBcIlwiKTtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoXCJlbmQgZG9JdFwiLCBcIlwiKTtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoL15bXFxuXFx0IF0rLywgXCJcIik7XG4gICAgICAgIHNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlKC9bXFxuXFx0IF0rJC8sIFwiXCIpO1xuICAgICAgICByZXR1cm4gc2NyaXB0O1xuICAgIH0sXG5cbiAgICBfb3BlblNjcmlwdEVkaXRvcjogZnVuY3Rpb24ocGFydElkKXtcbiAgICAgICAgbGV0IHRhcmdldCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3BhcnRJZF07XG4gICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgIFwiY29tbWFuZE5hbWVcIjogXCJvcGVuU2NyaXB0RWRpdG9yXCIsXG4gICAgICAgICAgICBhcmdzOiBbcGFydElkXVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UobXNnLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICBfb3BlbkdyYW1tYXI6IGZ1bmN0aW9uKHBhcnRJZCwgcnVsZU5hbWUpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbcGFydElkXTtcbiAgICAgICAgbGV0IHN0YXRlbWVudExpbmVzID0gW1xuICAgICAgICAgICAgJ2lmIHRoZXJlIGlzIG5vdCBhIGZpZWxkIFwiU2ltcGxlVGFsa1wiIG9mIGN1cnJlbnQgY2FyZCcsXG4gICAgICAgICAgICAndGhlbicsXG4gICAgICAgICAgICAnYWRkIGZpZWxkIFwiU2ltcGxlVGFsa1wiIHRvIGN1cnJlbnQgY2FyZCcsXG4gICAgICAgICAgICAndGVsbCBmaWVsZCBcIlNpbXBsZVRhbGtcIiBvZiBjdXJyZW50IGNhcmQgdG8gc2V0IFwiZWRpdGFibGVcIiB0byBmYWxzZScsXG4gICAgICAgICAgICAnU2ltcGxlVGFsaycsXG4gICAgICAgICAgICAndGVsbCBmaWVsZCBcIlNpbXBsZVRhbGtcIm9mIGN1cnJlbnQgY2FyZCB0byBzZXQgXCJ0ZXh0XCIgdG8gaXQnLFxuICAgICAgICAgICAgJ2VuZCBpZidcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IHNjcmlwdCA9IGBvbiBkb0l0XFxuICAgJHtzdGF0ZW1lbnRMaW5lcy5qb2luKCdcXG4nKX1cXG5lbmQgZG9JdGA7XG4gICAgICAgIHRhcmdldC5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbXBpbGVcIixcbiAgICAgICAgICAgICAgICBjb2RlU3RyaW5nOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHRhcmdldC5pZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICApO1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZG9JdFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gQXQgdGhlIG1vbWVudCB0aGlzIHNpbXBseSBvcGVucyBhIHN0LXdpbmRvdyBzdC1maWVsZCB3aXRoXG4gICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIGF2YWlsYWJsZSBjb21tYW5kcyBmb3Igc2FpZCBwYXJ0c1xuICAgIF9vcGVuRGVidWdnZXI6IGZ1bmN0aW9uKHBhcnRJZCl7XG4gICAgICAgIGxldCB0YXJnZXQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtwYXJ0SWRdO1xuICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBcImNvbW1hbmROYW1lXCI6IFwib3BlbkRlYnVnZ2VyXCIsXG4gICAgICAgICAgICBhcmdzOiBbcGFydElkXVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UobXNnLCB0YXJnZXQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgZXJyb3JIYW5kbGVyLFxuICAgIGVycm9ySGFuZGxlciBhcyBkZWZhdWx0XG59O1xuIiwiY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5jb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuY29uc3Qgc2NhbGVEaW0gPSAoZGltKSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSAwLjc7XG4gICAgY29uc3Qgc3RyaWRlID0gMTY7XG4gICAgY29uc3QgZXZlblJlcyA9IGRpbSAqIHNjYWxlIC0gMTtcbiAgICByZXR1cm4gZXZlblJlcyAtIChldmVuUmVzICUgc3RyaWRlKSArIDE7XG59O1xuXG5jb25zdCBkZXRlY3RIYW5kcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IHNjYWxlRGltKGNhbnZhcy53aWR0aCk7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gc2NhbGVEaW0oY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjb25zdCBpbWFnZSA9IHRmLnRpZHkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGYuZnJvbVBpeGVscyhjYW52YXMpLnJlc2l6ZUJpbGluZWFyKFtzY2FsZWRIZWlnaHQsIHNjYWxlZFdpZHRoXSkuZXhwYW5kRGltcygwKTtcbiAgICB9KTtcbiAgICBjb25zdCBbc2NvcmVzLCB0Ym94ZXNdID0gYXdhaXQgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uTW9kZWwuZXhlY3V0ZUFzeW5jKGltYWdlKTtcbiAgICBpbWFnZS5kaXNwb3NlKCk7XG4gICAgY29uc3QgaGFuZHNEZXRlY3RlZCA9IHRmLnRpZHkoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gdGYuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb24oXG4gICAgICAgICAgICB0Ym94ZXMucmVzaGFwZShbdGJveGVzLnNoYXBlWzFdLCB0Ym94ZXMuc2hhcGVbM11dKSxcbiAgICAgICAgICAgIHNjb3Jlcy5yZXNoYXBlKFtzY29yZXMuc2hhcGVbMV1dKSxcbiAgICAgICAgICAgIDIwLFxuICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgMC44NSkuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGJveGVzID0gW107XG4gICAgICAgIHZhciBpZHg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWR4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgICAgIHZhciBzY29yZSA9IHNjb3Jlcy5nZXQoMCwgaWR4LCAwKTtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG9yZGVyIGlzIFttaW5ZLCBtaW5YLCBtYXhZLCBtYXhYXSBzbyB3ZSByZW9yZGVyLlxuICAgICAgICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IFt0Ym94ZXMuZ2V0KDAsIGlkeCwgMCwgMSksIHRib3hlcy5nZXQoMCwgaWR4LCAwLCAwKV0sXG4gICAgICAgICAgICAgICAgbG93ZXJSaWdodDogW3Rib3hlcy5nZXQoMCwgaWR4LCAwLCAzKSwgdGJveGVzLmdldCgwLCBpZHgsIDAsIDIpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJveGVzLnB1c2goe3Njb3JlOiBzY29yZSwgYm94OiBib3h9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2JveGVzOiBib3hlcywgdGltZXN0YW1wOiBEYXRlLm5vdygpfTtcbiAgICB9KTtcbiAgICBzY29yZXMuZGlzcG9zZSgpO1xuICAgIHRib3hlcy5kaXNwb3NlKCk7XG4gICAgaWYgKGhhbmRzRGV0ZWN0ZWQuYm94ZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGlmIChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRldGVjdEhhbmRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJveCA9IGhhbmRzRGV0ZWN0ZWQuYm94ZXNbMF0uYm94O1xuICAgIGNvbnN0IFt4MSwgeTFdID0gYm94LnVwcGVyTGVmdDtcbiAgICBjb25zdCBbeDIsIHkyXSA9IGJveC5sb3dlclJpZ2h0O1xuICAgIGNvbnN0IGFyZWEgPSB7YXJlYTogKHgyIC0geDEpICogKHkyIC0geTEpLCB0aW1lc3RhbXA6IERhdGUubm93KCl9O1xuICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzID0gW10uY29uY2F0KGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzLnNsaWNlKC0yKSwgW2FyZWFdKTtcbiAgICAvLyBVcGRhdGUgaGFuZCBsb2NhdGlvblxuICAgIGNvbnN0IHZ3ID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDAsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApXG4gICAgY29uc3QgdmggPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IDAsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKVxuICAgIGNvbnN0IHAgPSBbMC41ICogKHgxICsgeDIpICogdncsIDAuNSAqICh5MSArIHkyKSAqIHZoXTtcbiAgICBoYW5kSW50ZXJmYWNlLnBvc2l0aW9ucyA9IFtdLmNvbmNhdChoYW5kSW50ZXJmYWNlLnBvc2l0aW9ucy5zbGljZSgtMiksIFtwXSk7XG4gICAgdmFyIHRhcmdldCA9IGhhbmRJbnRlcmZhY2UudGFyZ2V0RWxlbWVudDtcbiAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHRhcmdldCA9IGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIGF2ZXJhZ2UgcG9zaXRpb25cbiAgICBjb25zdCBbcDEsIHAyLCBwM10gPSBoYW5kSW50ZXJmYWNlLnBvc2l0aW9ucztcbiAgICBjb25zdCBbYXAxLCBhcDJdID0gWygxLzMpKihwMVswXSArIHAyWzBdICsgcDNbMF0pLCAoMS8zKSoocDFbMV0gKyBwMlsxXSArIHAzWzFdKV07XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcImxlZnRcIiwgYXAxKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwidG9wXCIsIGFwMik7XG4gICAgLy8gRXh0cmFjdCBhcmVhIGluZm9ybWF0aW9uIHdpdGhvdXQgYW55IHRpbWVzdGFtcHNcbiAgICB2YXIganVzdEFyZWFzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25BcmVhcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBqdXN0QXJlYXMucHVzaChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25BcmVhc1tpXS5hcmVhKTtcbiAgICB9XG4gICAgdmFyIGp1c3RBcmVhcyA9IFtdLmNvbmNhdChBcnJheSgzIC0ganVzdEFyZWFzLmxlbmd0aCkuZmlsbCgwKSwganVzdEFyZWFzKTtcbiAgICAvLyBDaGVjayBpZiBoYW5kIGlzIHB1c2hpbmcgaW5cbiAgICBjb25zdCBbYTEsIGEyLCBhM10gPSBqdXN0QXJlYXM7XG4gICAgY29uc3QgYXZlQXJlYSA9ICgxLzMpICogKGExICsgYTIgKyBhMyk7XG4gICAgaWYgKGF2ZUFyZWEgPiAwLjI1KSB7XG4gICAgICAgIGlmICghaGFuZEludGVyZmFjZS5oYW5kTWFza2VkKSB7XG4gICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmhhbmRNYXNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGhhbmRJbnRlcmZhY2UuaGFuZE1hc2tlZCA9IGZhbHNlOyB9LCAzMDAwKTtcbiAgICAgICAgICAgIGlmIChoYW5kSW50ZXJmYWNlLnRhcmdldEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VzdFZpZXcgPSBmaW5kQ2xvc2VzdFZpZXcoW3AxLCBwMl0pO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0VmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmxlbmluSGFuZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kLCBcImhpZGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UudGFyZ2V0RWxlbWVudCA9IGNsb3Nlc3RWaWV3Lm1vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZEludGVyZmFjZS5sZW5pbkhhbmQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChoYW5kSW50ZXJmYWNlLmxlbmluSGFuZCwgXCJoaWRlXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGV0ZWN0SGFuZHMpO1xuICAgIH1cbn07XG5cbmNvbnN0IGZpbmRDbG9zZXN0VmlldyA9IChwb2ludCkgPT4ge1xuICAgIGxldCB2aWV3cyA9IFtdO1xuICAgIHdpbmRvdy5TeXN0ZW0uZ2V0Q3VycmVudENhcmRNb2RlbCgpLnN1YnBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgbGV0IHBhcnRWaWV3cyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZChwYXJ0LmlkKTtcbiAgICAgICAgcGFydFZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXdzLnB1c2godmlldyk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgdmFyIFtjbG9zZXN0RGlzdCwgY2xvc2VzdFZpZXddID0gW0luZmluaXR5LCBudWxsXTtcbiAgICB2aWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgIGxldCB2aWV3RGlzdCA9IGRpc3QocG9pbnQsIGdldFZlcnRpY2VzKHZpZXcpKTtcbiAgICAgICAgaWYgKHZpZXdEaXN0IDwgY2xvc2VzdERpc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gdmlld0Rpc3Q7XG4gICAgICAgICAgICBjbG9zZXN0VmlldyA9IHZpZXc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvc2VzdFZpZXc7XG59XG5cbi8vIGh0dHBzOi8vYWFyb25zbWl0aC5vbmxpbmUvZWFzaWx5LWxvYWQtYW4tZXh0ZXJuYWwtc2NyaXB0LXVzaW5nLWphdmFzY3JpcHQvXG5jb25zdCBsb2FkU2NyaXB0ID0gc3JjID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy50ZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVuc29yZmxvd2pzIGFscmVhZHkgbG9hZGVkXCIpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwibG9hZGluZyB0ZW5zb3JmbG93anNcIik7XG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kKHNjcmlwdCk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBsb2FkSGFuZERldGVjdGlvbk1vZGVsID0gKCkgPT4ge1xuICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzID0gW107XG4gICAgbG9hZFNjcmlwdChcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHRlbnNvcmZsb3cvdGZqc0AwLjEzLjUvZGlzdC90Zi5qc1wiKS50aGVuKCgpID0+IHtcbiAgICAgICAgd2luZG93LnRmLmxvYWRGcm96ZW5Nb2RlbChcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9oYW5kdHJhY2tqcy9tb2RlbHMvd2ViL3NzZGxpdGVtb2JpbGVuZXR2Mi90ZW5zb3JmbG93anNfbW9kZWwucGJcIixcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9oYW5kdHJhY2tqcy9tb2RlbHMvd2ViL3NzZGxpdGVtb2JpbGVuZXR2Mi93ZWlnaHRzX21hbmlmZXN0Lmpzb25cIlxuICAgICAgICApLnRoZW4obW9kZWwgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJoYW5kIGRldGVjdGlvbiBtb2RlbCBsb2FkZWRcIik7XG4gICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25Nb2RlbCA9IG1vZGVsO1xuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiB0cnVlIH0pO1xuICAgICAgICB9KS50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gdmlkZW8ucGxheSgpO1xuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmlkZW8gc3RhcnRlZFwiKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC0xLCAwLCAwLCAxLCBjYW52YXMud2lkdGgsIDApOyAvLyBNaXJyb3IgaW5jb21pbmcgdmlkZW9cbiAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgaGFuZEludGVyZmFjZS5sZW5pbkhhbmQgPSB3aW5kb3cuU3lzdGVtLm5ld01vZGVsKCdpbWFnZScsIHdpbmRvdy5TeXN0ZW0uZ2V0V29ybGRTdGFja01vZGVsKCkuaWQsIFwiL2ltYWdlcy9sZW5pbkhhbmQucG5nXCIpO1xuICAgICAgICAgICAgaGFuZEludGVyZmFjZS50YXJnZXRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGV0ZWN0SGFuZHMpO1xuICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciBsb2FkaW5nIGhhbmQgZGV0ZWN0aW9uIG1vZGVsXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmNvbnN0IHVubG9hZEhhbmREZXRlY3Rpb25Nb2RlbCA9ICgpID0+IHtcbiAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nID0gZmFsc2U7XG4gICAgd2luZG93LlN5c3RlbS5kZWxldGVNb2RlbChoYW5kSW50ZXJmYWNlLmxlbmluSGFuZC5pZClcbiAgICBoYW5kSW50ZXJmYWNlLmxlbmluSGFuZCA9IG51bGw7XG4gICAgdmlkZW8ucGF1c2UoKTtcbiAgICBjb25zdCB0cmFja3MgPSB2aWRlby5zcmNPYmplY3QuZ2V0VHJhY2tzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhY2tzW2ldLnN0b3AoKTtcbiAgICB9XG4gICAgdmlkZW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICBjb25zb2xlLmxvZyhcInZpZGVvIHN0b3BwZWRcIik7XG4gICAgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uTW9kZWwgPSBudWxsO1xuICAgIGNvbnNvbGUubG9nKFwidW5sb2FkaW5nIGhhbmQgZGV0ZWN0aW9uIG1vZGVsXCIpO1xufVxuXG5jb25zdCBnZXRWZXJ0aWNlcyA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdXBwZXJMZWZ0ID0gW3JlY3QueCwgcmVjdC55XTtcbiAgICBjb25zdCB1cHBlclJpZ2h0ID0gW3JlY3QueCArIHJlY3Qud2lkdGgsIHJlY3QueV07XG4gICAgY29uc3QgbG93ZXJMZWZ0ID0gW3JlY3QueCwgcmVjdC55ICsgcmVjdC5oZWlnaHRdO1xuICAgIGNvbnN0IGxvd2VyUmlnaHQgPSBbcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55ICsgcmVjdC5oZWlnaHRdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwcGVyTGVmdDogdXBwZXJMZWZ0LFxuICAgICAgICB1cHBlclJpZ2h0OiB1cHBlclJpZ2h0LFxuICAgICAgICBsb3dlckxlZnQ6IGxvd2VyTGVmdCxcbiAgICAgICAgbG93ZXJSaWdodDogbG93ZXJSaWdodFxuICAgIH07XG59XG5cbmNvbnN0IGRpc3QgPSAocG9pbnQsIHZlcnRpY2VzKSA9PiB7XG4gICAgY29uc3QgW3AxLCBwMl0gPSBwb2ludDtcbiAgICBjb25zdCBbdWwxLCB1bDJdID0gdmVydGljZXMudXBwZXJMZWZ0O1xuICAgIGNvbnN0IFtsbDEsIGxsMl0gPSB2ZXJ0aWNlcy5sb3dlckxlZnQ7XG4gICAgY29uc3QgW3VyMSwgdXIyXSA9IHZlcnRpY2VzLnVwcGVyUmlnaHQ7XG4gICAgY29uc3QgW2xyMSwgbHIyXSA9IHZlcnRpY2VzLmxvd2VyUmlnaHQ7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gICAgLy8gTmV4dCB3ZSBjb21wdXRlIHRoZSB2ZWN0b3IgcG9pbnRpbmcgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGNsb3Nlc3QgcG9pbnRcbiAgICAvLyBvbiB0aGUgcmVjdGFuZ2xlLiBUaGVyZSBhcmUgOSBjYXNlcy4gVGhlIGZpcnN0IGlzIHdoZW4gdGhlIHBvaW5zdCBpc1xuICAgIC8vIGluc2lkZSB0aGUgcmVjdGFuZ2xlLiBUaGUgbmV4dCBmb3VyIGNhc2VzIGFyZSBpZiB0aGUgcG9pbnQgaW4gb25lIG9mXG4gICAgLy8gdGhlIGZvdXIgY29ybmVycyBhbmQgdGhlIGZpbmFsIGZvdXIgY2FzZXMgYXJlIHdoZW4gdGhlIHBvaW50IGlzIG9uIG9uZVxuICAgIC8vIG9mIHRoZSBmb3VyIHNpZGVzLlxuICAgIHZhciBbdjEsIHYyXSA9IFtudWxsLCBudWxsXTtcbiAgICBpZiAoKHVsMSA8PSBwMSkgJiYgKHAxIDw9IGxyMSkgJiYgKHVsMiA8PSBwMikgJiYgKHAyIDw9IGxyMikpIHtcbiAgICAgICAgLy8gQ2FzZSAwOiBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICAgICAgICBbdjEsIHYyXSA9IFswLCAwXTtcbiAgICB9IGVsc2UgaWYgKChwMSA8PSB1bDEpICYmIChwMiA8PSB1bDIpKSB7XG4gICAgICAgIC8vIENhc2UgMTogdXBwZXIgbGVmdFxuICAgICAgICBbdjEsIHYyXSA9IFt1bDEgLSBwMSwgdWwyIC0gcDJdO1xuICAgIH0gZWxzZSBpZiAoKHAxID49IHVyMSkgJiYgKHAyIDw9IHVyMikpIHtcbiAgICAgICAgLy8gQ2FzZSAyOiB1cHBlciByaWdodFxuICAgICAgICBbdjEsIHYyXSA9IFt1cjEgLSBwMSwgdXIyIC0gcDJdO1xuICAgIH0gZWxzZSBpZiAoKHAxIDw9IGxsMSkgJiYgKHAyID49IGxsMikpIHtcbiAgICAgICAgLy8gQ2FzZSAzOiBsb3dlciBsZWZ0XG4gICAgICAgIFt2MSwgdjJdID0gW2xsMSAtIHAxLCBsbDIgLSBwMl07XG4gICAgfSBlbHNlIGlmICgocDEgPj0gbHIxKSAmJiAocDIgPj0gbHIyKSkge1xuICAgICAgICAvLyBDYXNlIDQ6IGxvd2VyIHJpZ2h0XG4gICAgICAgIFt2MSwgdjJdID0gW2xyMSAtIHAxLCBscjIgLSBwMl07XG4gICAgfSBlbHNlIGlmIChwMSA8PSB1bDEpIHtcbiAgICAgICAgLy8gQ2FzZSA1OiBzaWRlIGxlZnRcbiAgICAgICAgW3YxLCB2Ml0gPSBbdWwxIC0gcDEsIDBdO1xuICAgIH0gZWxzZSBpZiAocDEgPj0gbHIxKSB7XG4gICAgICAgIC8vIENhc2UgNjogc2lkZSByaWdodFxuICAgICAgICBbdjEsIHYyXSA9IFtscjEgLSBwMSwgMF07XG4gICAgfSBlbHNlIGlmIChwMiA8PSB1bDIpIHtcbiAgICAgICAgLy8gQ2FzZSA3OiBzaWRlIHRvcFxuICAgICAgICBbdjEsIHYyXSA9IFswLCB1bDIgLSBwMl07XG4gICAgfSBlbHNlIGlmIChwMiA+PSBscjIpIHtcbiAgICAgICAgLy8gQ2FzZSA4OiBzaWRlIGJvdHRvbVxuICAgICAgICBbdjEsIHYyXSA9IFswLCBscjIgLSBwMl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSA5OiBpbnNpZGVcbiAgICAgICAgW3YxLCB2Ml0gPSBbMCwgMF07XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnNxcnQodjEqdjEgKyB2Mip2Mik7XG59XG5cbmNsYXNzIEhhbmRJbnRlcmZhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhbmREZXRlY3Rpb25Nb2RlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZERldGVjdGlvblJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5pbkhhbmQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRNYXNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kRGV0ZWN0aW9uQXJlYXMgPSBbXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbWzAsIDBdLCBbMCwgMF0sIFswLCAwXV07XG4gICAgICAgIC8vIFhYWCAtIE9ubHkgaGVyZSB0byBpZ25vcmUgdGhlIHRlbnNvcmZsb3cgd2FybmluZ3NcbiAgICAgICAgY29uc29sZS53YXJuID0gKCkgPT4ge307XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGxvYWRIYW5kRGV0ZWN0aW9uTW9kZWwoKTtcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB1bmxvYWRIYW5kRGV0ZWN0aW9uTW9kZWwoKTtcbiAgICB9XG59XG5cbmNvbnN0IFRlc3RhYmxlcyA9IHtcbiAgICBkaXN0OiBkaXN0XG59XG5cbmNvbnN0IGhhbmRJbnRlcmZhY2UgPSBuZXcgSGFuZEludGVyZmFjZSgpO1xuXG5leHBvcnQge1xuICAgIFRlc3RhYmxlcyxcbiAgICBoYW5kSW50ZXJmYWNlLFxuICAgIGhhbmRJbnRlcmZhY2UgYXMgZGVmYXVsdFxufTtcbiIsImxldCBwYXJ0SWNvbnMgPSB7fTtcblxucGFydEljb25zLndvcmxkID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXdvcmxkXCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjQ0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI5XCIgLz5cbiAgPGxpbmUgeDE9XCIzLjZcIiB5MT1cIjlcIiB4Mj1cIjIwLjRcIiB5Mj1cIjlcIiAvPlxuICA8bGluZSB4MT1cIjMuNlwiIHkxPVwiMTVcIiB4Mj1cIjIwLjRcIiB5Mj1cIjE1XCIgLz5cbiAgPHBhdGggZD1cIk0xMS41IDNhMTcgMTcgMCAwIDAgMCAxOFwiIC8+XG4gIDxwYXRoIGQ9XCJNMTIuNSAzYTE3IDE3IDAgMCAxIDAgMThcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuc3RhY2sgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc3RhY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzJjM2U1MFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiMTIgNCA0IDggMTIgMTIgMjAgOCAxMiA0XCIgLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjQgMTIgMTIgMTYgMjAgMTJcIiAvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiNCAxNiAxMiAyMCAyMCAxNlwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5jYXJkID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXNxdWFyZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMmMzZTUwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxyZWN0IHg9XCI0XCIgeT1cIjRcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuYnV0dG9uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWhhbmQtZmluZ2VyXCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjQ0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk04IDEzdi04LjVhMS41IDEuNSAwIDAgMSAzIDB2Ny41XCIgLz5cbiAgPHBhdGggZD1cIk0xMSAxMS41di0yYTEuNSAxLjUgMCAxIDEgMyAwdjIuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTAuNWExLjUgMS41IDAgMCAxIDMgMHYxLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE3IDExLjVhMS41IDEuNSAwIDAgMSAzIDB2NC41YTYgNiAwIDAgMSAtNiA2aC0yaC4yMDhhNiA2IDAgMCAxIC01LjAxMiAtMi43YTY5Ljc0IDY5Ljc0IDAgMCAxIC0uMTk2IC0uM2MtLjMxMiAtLjQ3OSAtMS40MDcgLTIuMzg4IC0zLjI4NiAtNS43MjhhMS41IDEuNSAwIDAgMSAuNTM2IC0yLjAyMmExLjg2NyAxLjg2NyAwIDAgMSAyLjI4IC4yOGwxLjQ3IDEuNDdcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMud2luZG93ID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXdpbmRvd1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTIgM2MtMy44NjYgMCAtNyAzLjI3MiAtNyA3djEwYTEgMSAwIDAgMCAxIDFoMTJhMSAxIDAgMCAwIDEgLTF2LTEwYzAgLTMuNzI4IC0zLjEzNCAtNyAtNyAtN3pcIiAvPlxuICA8bGluZSB4MT1cIjVcIiB5MT1cIjEzXCIgeDI9XCIxOVwiIHkyPVwiMTNcIiAvPlxuICA8bGluZSB4MT1cIjEyXCIgeTE9XCIzXCIgeDI9XCIxMlwiIHkyPVwiMjFcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuYXJlYSA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zaGFwZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxjaXJjbGUgY3g9XCI1XCIgY3k9XCI1XCIgcj1cIjJcIiAvPlxuICA8Y2lyY2xlIGN4PVwiMTlcIiBjeT1cIjVcIiByPVwiMlwiIC8+XG4gIDxjaXJjbGUgY3g9XCI1XCIgY3k9XCIxOVwiIHI9XCIyXCIgLz5cbiAgPGNpcmNsZSBjeD1cIjE5XCIgY3k9XCIxOVwiIHI9XCIyXCIgLz5cbiAgPGxpbmUgeDE9XCI1XCIgeTE9XCI3XCIgeDI9XCI1XCIgeTI9XCIxN1wiIC8+XG4gIDxsaW5lIHgxPVwiN1wiIHkxPVwiNVwiIHgyPVwiMTdcIiB5Mj1cIjVcIiAvPlxuICA8bGluZSB4MT1cIjdcIiB5MT1cIjE5XCIgeDI9XCIxN1wiIHkyPVwiMTlcIiAvPlxuICA8bGluZSB4MT1cIjE5XCIgeTE9XCI3XCIgeDI9XCIxOVwiIHkyPVwiMTdcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuZmllbGQgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItZm9ybXNcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEyIDNhMyAzIDAgMCAwIC0zIDN2MTJhMyAzIDAgMCAwIDMgM1wiIC8+XG4gIDxwYXRoIGQ9XCJNNiAzYTMgMyAwIDAgMSAzIDN2MTJhMyAzIDAgMCAxIC0zIDNcIiAvPlxuICA8cGF0aCBkPVwiTTEzIDdoN2ExIDEgMCAwIDEgMSAxdjhhMSAxIDAgMCAxIC0xIDFoLTdcIiAvPlxuICA8cGF0aCBkPVwiTTUgN2gtMWExIDEgMCAwIDAgLTEgMXY4YTEgMSAwIDAgMCAxIDFoMVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTcgMTJoLjAxXCIgLz5cbiAgPHBhdGggZD1cIk0xMyAxMmguMDFcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuZHJhd2luZyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1wYWxldHRlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMiAyMWE5IDkgMCAxIDEgMCAtMThhOSA4IDAgMCAxIDkgOGE0LjUgNCAwIDAgMSAtNC41IDRoLTIuNWEyIDIgMCAwIDAgLTEgMy43NWExLjMgMS4zIDAgMCAxIC0xIDIuMjVcIiAvPlxuICA8Y2lyY2xlIGN4PVwiNy41XCIgY3k9XCIxMC41XCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIC8+XG4gIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiNy41XCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIC8+XG4gIDxjaXJjbGUgY3g9XCIxNi41XCIgY3k9XCIxMC41XCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5pbWFnZSA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1waG90b1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxsaW5lIHgxPVwiMTVcIiB5MT1cIjhcIiB4Mj1cIjE1LjAxXCIgeTI9XCI4XCIgLz5cbiAgPHJlY3QgeD1cIjRcIiB5PVwiNFwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiM1wiIC8+XG4gIDxwYXRoIGQ9XCJNNCAxNWw0IC00YTMgNSAwIDAgMSAzIDBsNSA1XCIgLz5cbiAgPHBhdGggZD1cIk0xNCAxNGwxIC0xYTMgNSAwIDAgMSAzIDBsMiAyXCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmdlbmVyaWMgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcHV6emxlXCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjQ0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk00IDdoM2ExIDEgMCAwIDAgMSAtMXYtMWEyIDIgMCAwIDEgNCAwdjFhMSAxIDAgMCAwIDEgMWgzYTEgMSAwIDAgMSAxIDF2M2ExIDEgMCAwIDAgMSAxaDFhMiAyIDAgMCAxIDAgNGgtMWExIDEgMCAwIDAgLTEgMXYzYTEgMSAwIDAgMSAtMSAxaC0zYTEgMSAwIDAgMSAtMSAtMXYtMWEyIDIgMCAwIDAgLTQgMHYxYTEgMSAwIDAgMSAtMSAxaC0zYTEgMSAwIDAgMSAtMSAtMXYtM2ExIDEgMCAwIDEgMSAtMWgxYTIgMiAwIDAgMCAwIC00aC0xYTEgMSAwIDAgMSAtMSAtMXYtM2ExIDEgMCAwIDEgMSAtMVwiIC8+XG48L3N2Zz5cbmA7XG5cbmV4cG9ydCB7XG4gICAgcGFydEljb25zLFxuICAgIHBhcnRJY29ucyBhcyBkZWZhdWx0XG59O1xuIiwiLy8gSUQgcmVsYXRlZCB1dGlsaXRpZXNcblxuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5cbi8qKlxuICogSUQgTWFrZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgZ2xvYmFsbHlcbiAqIHVuaXF1ZSBJRCB2YWx1ZXMgZm9yIFBhcnRzIGluIHRoZSBTaW1wbGVUYWxrXG4gKiB3b3JsZC5cbiAqIEhDIHJlcXVpcmVzIHRoYXQgYWxsIFBhcnRzIGhhdmUgdW5pcXVlIGlkcyBhbmRcbiAqIHRoYXQgdGhlc2Ugc2hvdWxkIG5vdCBiZSByZXBlYXRlZCBpbiBhbnkgZ2l2ZW5cbiAqIFwiYXBwbGljYXRpb25cIiBpbnN0YW5jZS5cbiAqIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoYXQgYW4gXCJhcHBsaWNhdGlvblwiIGlzXG4gKiBpbiBvdXIgY29udGV4dCwgYnV0IHJlZ2FyZGxlc3Mgd2UgY2FuIHVzZSB0aGlzXG4gKiBtb2R1bGUgYXMgYSBkcm9wIGluIHJlcGxhY2VtZW50LCBpbXBsZW1lbnRpbmdcbiAqIFVVSURzIG9yIFVSTHMgb3Igd2hhdGV2ZXIgd2Ugd2FudC5cbiAqIEZvciBub3cgd2UganVzdCBpbmNyZW1lbnQgYW4gaW50ZWdlci5cbiAqL1xuY29uc3QgaWRNYWtlciA9IHtcbiAgICBuZXc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBpZCA9IHV1aWR2NCgpO1xuICAgICAgICByZXR1cm4gaWQucmVwbGFjZSgvLS9nLCAnJyk7XG4gICAgfVxufTtcblxuLyogSUQgY2hlY2tlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gaWQgaXNcbiAqIGlzIHZhbGlkIGFuZCByZXR1cm5pbmcgaXQgaWYgc29cbiAqL1xuY29uc3QgaXNWYWxpZElkID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZihpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkIHx8IGlkID09PSBcIlwiKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZihpZC5sZW5ndGggIT0gMzIgfHwgaWQubWF0Y2goJ1thLXowLTldKicpWzBdLmxlbmd0aCAhPSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydCB7XG4gICAgaWRNYWtlcixcbiAgICBpc1ZhbGlkSWQsXG4gICAgaWRNYWtlciBhcyBkZWZhdWx0XG59O1xuIiwiY29uc3QgbWVycmlhbVNpbVNjb3JlID0gYXN5bmMgKHNlbmRlciwgZG9jSWQpID0+IHtcbiAgICBjb25zdCB1cmwgPSBcImh0dHBzOi8vcGF0ZW50cy5tZXJyaWFtdGVjaC5jb20vX2FwaS9tZXJyaWFtL1wiXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgXCJmaWVsZHNcIjogW1xuICAgICAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICAgICAgXCJkYXRlX3B1YmxcIlxuICAgICAgICBdLFxuICAgICAgICBcIndlaWdodHNcIjoge1xuICAgICAgICAgICAgXCJtZXJyaWFtXCI6MC43LFxuICAgICAgICAgICAgXCJkYXRlXCI6MC4zLFxuICAgICAgICAgICAgXCJoaWVyYXJjaHlcIjowLjFcbiAgICAgICAgfSxcbiAgICAgICAgXCJkb2NfaWRzXCI6IFtcbiAgICAgICAgICAgIGRvY0lkXG4gICAgICAgIF0sXG4gICAgICAgIFwibGltaXRcIjogNX1cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImhlYWRlcnNcIjoge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJib2R5XCI6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gICAgfVxuICAgIGZldGNoKHVybCwgcGFyYW1zKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICByZXR1cm4gZGF0YS5qc29uKCk7XG4gICAgfSkudGhlbihqc29uID0+IHtcbiAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtZXJyaWFtcmVzdWx0JyxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICBzZW5kZXIuc2VuZE1lc3NhZ2UobXNnLCBzZW5kZXIpO1xuICAgIH0pO1xufVxuXG5leHBvcnQge1xuICAgIG1lcnJpYW1TaW1TY29yZSxcbiAgICBtZXJyaWFtU2ltU2NvcmUgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogU2VyaWFsaXphdGlvbiBhbmQgRGVzZXJpYWxpemF0aW9uIFV0aWxpdHkgQ2xhc3Nlc1xuICovXG5pbXBvcnQgaWRNYWtlciBmcm9tICcuL2lkLmpzJztcblxuY29uc3QgdmVyc2lvbiA9IFwiMC4wLjJcIjtcblxuY2xhc3MgU1REZXNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGFTeXN0ZW0pe1xuICAgICAgICB0aGlzLnN5c3RlbSA9IGFTeXN0ZW07XG5cbiAgICAgICAgLy8gVGhlc2UgY2FjaGVzIGFyZSB1c2VkIGR1cmluZyB0aGUgcHJvY2Vzc1xuICAgICAgICAvLyBhcyBvcHRpbWl6YXRpb25zXG4gICAgICAgIHRoaXMuX21vZGVsQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc3VicGFydE1hcENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2lkQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLl9wcm9wc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3ZpZXdzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0Q2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fcm9vdHNDYWNoZSA9IFtdO1xuXG4gICAgICAgIC8vIFRoZSB0YXJnZXRJZCBpcyB0aGUgaWQgb2ZcbiAgICAgICAgLy8gdGhlIFBhcnQgdGhhdCB3ZSB3aXNoIHRvIGFwcGVuZCBhbnlcbiAgICAgICAgLy8gZGVzZXJpYWxpemVkIHN1YnBhcnQgdHJlZSBpbnRvLlxuICAgICAgICAvLyBCeSBkZWZhdWx0IHdlIGFzc3VtZSB0aGUgd2hvbGUgc3lzdGVtLFxuICAgICAgICAvLyBpZSBmdWxsIGRlc2VyaWFsaXphdGlvbi5cbiAgICAgICAgdGhpcy50YXJnZXRJZCA9ICdzeXN0ZW0nO1xuICAgICAgICAvLyB0aGUgcm9vdCBpZCBpcyB0aGUgaWQgb2YgdGhlIHJvb3QgcGFydCBpbnN0YW5jZVxuICAgICAgICAvLyBiZWluZyBhdHRhY2hlZFxuICAgICAgICB0aGlzLnJvb3RJZCA9IG51bGw7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gdGhpcy5kZXNlcmlhbGl6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplRGF0YSA9IHRoaXMuZGVzZXJpYWxpemVEYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemVQYXJ0ID0gdGhpcy5kZXNlcmlhbGl6ZVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hdHRhY2hTdWJwYXJ0cyA9IHRoaXMuYXR0YWNoU3VicGFydHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzID0gdGhpcy5zZXRQcm9wZXJ0aWVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlVmlldyA9IHRoaXMuY3JlYXRlVmlldy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmF0dGFjaFZpZXcgPSB0aGlzLmF0dGFjaFZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRWaWV3TW9kZWwgPSB0aGlzLnNldFZpZXdNb2RlbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVQYXJ0U2NyaXB0ID0gdGhpcy5jb21waWxlUGFydFNjcmlwdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2hXb3JsZCA9IHRoaXMucmVmcmVzaFdvcmxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXBwZW5kV29ybGQgPSB0aGlzLmFwcGVuZFdvcmxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUGFydHNUb1N5c3RlbSA9IHRoaXMuYWRkUGFydHNUb1N5c3RlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVTY3JpcHRzID0gdGhpcy5jb21waWxlU2NyaXB0cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEZsYXR0ZW5lZFBhcnRUcmVlID0gdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE1vZGVsQ2xhc3MgPSB0aGlzLmdldE1vZGVsQ2xhc3MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVJZCA9IHRoaXMuaGFuZGxlSWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yID0gdGhpcy50aHJvd0Vycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmx1c2hDYWNoZXMgPSB0aGlzLmZsdXNoQ2FjaGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hWaWV3QWRkZWQgPSB0aGlzLmRpc3BhdGNoVmlld0FkZGVkLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgZGVzZXJpYWxpemUoYUpTT05TdHJpbmcpe1xuICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKGFKU09OU3RyaW5nKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3lzdGVtLnBhcnRzQnlJZFt0aGlzLnRhcmdldElkXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVEYXRhKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIGRlc2VyaWFsaXplZCBQYXJ0cyB0byB0aGUgU3lzdGVtIGRpY3QsXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkaW5nIHRoZSBuZXcgV29ybGQuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQYXJ0c1RvU3lzdGVtKHRoaXMuX2luc3RhbmNlQ2FjaGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDb21waWxlIHRoZSBzY3JpcHRzIG9uICphbGwqIGRlc2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIC8vIHBhcnRzXG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlU2NyaXB0cyh0aGlzLl9pbnN0YW5jZUNhY2hlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSByb290IFBhcnQgaW50byB3aGF0ZXZlclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBpdCBzaG91bGQgZ28gaW50by5cbiAgICAgICAgICAgICAgICBsZXQgcm9vdFBhcnQgPSB0aGlzLnJvb3RQYXJ0c1swXTtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdFZpZXcgPSB0aGlzLnJvb3RWaWV3c1swXTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRhcmdldElkID09ICdzeXN0ZW0nKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoV29ybGQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYWRkUGFydChyb290UGFydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgYXBwZW5kIHRoZSBQYXJ0VmlldyByb290IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBpdCBzaG91bGQgZ28gaW4gdGhlIHZpZXcgdHJlZS5cbiAgICAgICAgICAgICAgICBpZih0aGlzLnRhcmdldElkID09ICdzeXN0ZW0nKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRXb3JsZCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3RoaXMudGFyZ2V0SWR9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZpZXcuYXBwZW5kQ2hpbGQocm9vdFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVmlld0FkZGVkKHJvb3RWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFBhcnQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICduZXdNb2RlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE5vdERlbGVnYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sIHJvb3RQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXNlcmlhbGl6ZURhdGEoKXtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDYWNoZXMoKTtcbiAgICAgICAgICAgIC8vIEZpcnN0LCB3ZSBlbnN1cmUgdGhhdCB0aGUgdGFyZ2V0IHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgZGVzZXJpYWxpemluZyBpbnRvIGFjdHVhbGx5IGV4aXN0c1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3lzdGVtLnBhcnRzQnlJZFt0aGlzLnRhcmdldElkXTtcbiAgICAgICAgICAgIGlmKCF0YXJnZXQgJiYgdGhpcy50YXJnZXRJZCAhPSAnc3lzdGVtJyl7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBUYXJnZXQgaWQgJHt0aGlzLnRhcmdldElkfSBkb2VzIG5vdCBleGlzdCBpbiBTeXN0ZW1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2Vjb25kLCB3ZSBjcmVhdGUgaW5zdGFuY2VzIG9mIGFsbCBtb2RlbHMgaW4gdGhlIHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBkbyBub3QgeWV0IGF0dGFjaCB0aGVpciBzdWJwYXJ0cy5cbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5kYXRhLnBhcnRzKS5mb3JFYWNoKHBhcnREYXRhID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplUGFydChPYmplY3QuYXNzaWduKHt9LCBwYXJ0RGF0YSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0YXJnZXRzXG4gICAgICAgICAgICBmb3IgKGxldCBtb2RlbElkIGluIHRoaXMuX3Byb3BzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHMgPSB0aGlzLl9wcm9wc0NhY2hlW21vZGVsSWRdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy50YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgb2xkSWQgaW4gdGhpcy5faWRDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0lkID0gdGhpcy5faWRDYWNoZVtvbGRJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMudGFyZ2V0ID09PSAncGFydCBpZCAnICsgb2xkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy50YXJnZXQgPSAncGFydCBpZCAnICsgbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgc2NyaXB0c1xuICAgICAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLl9zY3JpcHRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGxldCBzY3JpcHQgPSB0aGlzLl9zY3JpcHRDYWNoZVttb2RlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0ICE9PSBudWxsICYmIHNjcmlwdC5tYXRjaCgncGFydCBpZCcpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG9sZElkIGluIHRoaXMuX2lkQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJZCA9IHRoaXMuX2lkQ2FjaGVbb2xkSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9sZFJlID0gJ3BhcnQgaWQgJyArIG9sZElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1JlID0gJ3BhcnQgaWQgJyArIG5ld0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NjcmlwdENhY2hlW21vZGVsSWRdLm1hdGNoKG9sZFJlKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1vZGVsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAob2xkUmUsIFwiZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JpcHRDYWNoZVttb2RlbElkXSA9IHNjcmlwdC5yZXBsYWNlKHJlLCBuZXdSZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoaXJkLCB3ZSBnbyB0aHJvdWdoIGVhY2ggY3JlYXRlZCBQYXJ0IGluc3RhbmNlXG4gICAgICAgICAgICAvLyBhbmQgYWRkIGFueSBzdWJwYXJ0cyB0byBpdC4gTm90ZSB0aGF0IHRoaXMgaXMgbm90XG4gICAgICAgICAgICAvLyByZWN1cnNpdmVcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlQ2FjaGUuZm9yRWFjaChwYXJ0SW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoU3VicGFydHMocGFydEluc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGb3J0aCBhbmQgZmlmdGguIENyZWF0ZSBhbmQgYXR0YWNoIHZpZXdzXG4gICAgICAgICAgICAvLyBOb3RlIHRoaXMgaXMgcmVjdXJzaXZlIHRvIHByZXNlcnZlIHRoZSBzdWJwYXJ0ICsgdmlldyBjaGlsZHJlbiBvcmRlclxuICAgICAgICAgICAgbGV0IHJvb3QgPSB0aGlzLl9pbnN0YW5jZUNhY2hlLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQocGFydCwgXCJpZFwiKSA9PSB0aGlzLnJvb3RJZDtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVBbmRBdHRhY2hWaWV3cyhyb290KTtcblxuICAgICAgICAgICAgLy8gU2l4dGgsIHdlIHNldCBhbGwgcHJvcGVydGllcyBvbiBlYWNoIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIFBhcnQgbW9kZWwgZnJvbSB0aGUgZGVzZXJpYWxpemVkIGRhdGEuXG4gICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHVzaW5nIGEgdmlzaXRvciBtZXRob2Qgb24gdGhlIGluc3RhbmNlc1xuICAgICAgICAgICAgLy8gdGhlbXNlbHZlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdGhlIGluLW1lbW9yeSB2aWV3cyB0aGUgYWJpbGl0eSB0b1xuICAgICAgICAgICAgLy8gcmVhY3QgdG8gYW55IGluaXRpYWwgY2hhbmdlcyB0byB0aGVpciBtb2RlbHMuXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZUNhY2hlLmZvckVhY2gocGFydEluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMocGFydEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYW5zbGF0ZSBuZXcgaWRzIHRvIG9sZCBvbmVzXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRJbnN0YW5jZS5uYW1lID09IFwiV29ybGRTdGFja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3b3JsZCA9IHBhcnRJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pZENhY2hlW3dvcmxkLmN1cnJlbnRTdGFja0lkXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydEluc3RhbmNlLm5hbWUgPT0gXCJTdGFja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHBhcnRJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pZENhY2hlW3N0YWNrLmN1cnJlbnRDYXJkSWRdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld01vZGVsKHBhcnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gV2UgZGV0ZXJtaW5lIHdoaWNoIG9mIHRoZSBpbnN0YW5jZXMgaXMgYSBcInJvb3RcIixcbiAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhhdCBpdCBoYXMsIGF0IHRoaXMgcG9pbnQsIG5vIG93bmVyIGluXG4gICAgICAgICAgICAvLyB0aGUgZGVzZXJpYWxpemVkIGRhdGEuIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSByb290c1xuICAgICAgICAgICAgLy8gKGFuZCB0aGVyZWZvcmUgbXVsdGlwbGUgdHJlZXMpIGluIGEgc2luZ2xlIGRlc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgdGhpcy5fcm9vdHNDYWNoZSA9IHRoaXMuX2luc3RhbmNlQ2FjaGUuZmlsdGVyKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuX293bmVyID09IG51bGwgfHwgaW5zdGFuY2UuX293bmVyID09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJbnNlcnRpb24gc2hvdWxkIGJlIGhhbmRsZWQgYnkgY29tcG9zZWRcbiAgICAgICAgICAgIC8vIHByb21pc2VzIGVsc2V3aGVyZSAoc2VlIGltcG9ydHMgYW5kIGRlc2VyaWFsaXplKClcbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlcylcblxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNyZWF0ZUFuZEF0dGFjaFZpZXdzKHBhcnRJbnN0YW5jZSl7XG4gICAgICAgIHRoaXMuY3JlYXRlVmlldyhwYXJ0SW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmF0dGFjaFZpZXcocGFydEluc3RhbmNlKTtcbiAgICAgICAgaWYocGFydEluc3RhbmNlLnN1YnBhcnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBwYXJ0SW5zdGFuY2Uuc3VicGFydHMuZm9yRWFjaCgoc3VicGFydEluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVBbmRBdHRhY2hWaWV3cyhzdWJwYXJ0SW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbXBvcnRGcm9tU2VyaWFsaXphdGlvbihhSlNPTlN0cmluZywgZmlsdGVyRnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKGFKU09OU3RyaW5nKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3lzdGVtLnBhcnRzQnlJZFt0aGlzLnRhcmdldElkXTtcbiAgICAgICAgbGV0IHRhcmdldFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7dGhpcy50YXJnZXRJZH1cIl1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVEYXRhKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgcHJvdmlkZSBhIGZpbHRlciBmdW5jdGlvbiBvdmVyXG4gICAgICAgICAgICAgICAgLy8gYWxsIGRlc2VyaWFsaXplZCBwYXJ0IGluc3RhbmNlcywgcmV0dXJuaW5nIG9ubHlcbiAgICAgICAgICAgICAgICAvLyB0aG9zZSB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGFsbCBTdGFja3MgaW4gdGhlIFdvcmxkU3RhY2suXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlQ2FjaGUuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocm9vdFBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdFBhcnRzLmZvckVhY2gocm9vdFBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxsVHJlZVBhcnRzID0gdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZShyb290UGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFydHNUb1N5c3RlbShhbGxUcmVlUGFydHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByb290UGFydHM7XG5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocm9vdFBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdFBhcnRzLmZvckVhY2gocm9vdFBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxsVHJlZVBhcnRzID0gdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZShyb290UGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZVNjcmlwdHMoYWxsVHJlZVBhcnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFBhcnRzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyb290UGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICByb290UGFydHMuZm9yRWFjaChyb290UGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlld3NDYWNoZVtyb290UGFydC5pZF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5hZGRQYXJ0KHJvb3RQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Vmlldy5hcHBlbmRDaGlsZCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFZpZXdBZGRlZCh2aWV3KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlc2VyaWFsaXplUGFydChwYXJ0RGF0YSl7XG4gICAgICAgIGxldCBwYXJ0Q2xhc3MgPSB0aGlzLmdldE1vZGVsQ2xhc3MocGFydERhdGEudHlwZSk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBwYXJ0Q2xhc3MoKTtcblxuICAgICAgICAvLyBXZSBjcmVhdGUgYSBuZXcgSUQgZm9yIHRoaXMgcGFydCwgc2luY2Ugd2UgY2Fubm90XG4gICAgICAgIC8vIGd1YXJhbnRlZSBJRCBjbGFzaGVzIHdpdGggdGhlIGV4aXN0aW5nIFN5c3RlbS5cbiAgICAgICAgLy8gRXhjZXB0aW9uIGlzIGlmIHRoZSB1c2VPcmlnaW5hbGlkcyBmbGFnIGlzIHNldCxcbiAgICAgICAgLy8gc3VjaCBhcyBhdCBsb2FkIHRpbWVcbiAgICAgICAgbGV0IHtuZXdJZCwgb2xkSWR9ID0gdGhpcy5oYW5kbGVJZChpbnN0YW5jZSwgcGFydERhdGEpO1xuICAgICAgICBpbnN0YW5jZS5pZCA9IG5ld0lkO1xuICAgICAgICAvLyBjYWNoZSB0aGUgbmV3IHJvb3QgSUQgaWYgdGhpcyBpcyBhIHJvb3QgaW5zdGFuY2VcbiAgICAgICAgaWYodGhpcy5kYXRhLnJvb3RJZCA9PSBvbGRJZCl7XG4gICAgICAgICAgICB0aGlzLnJvb3RJZCA9IG5ld0lkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRvIG91ciBjYWNoZXMgYW5kIGFsc28gdG8gdGhlIFN5c3RlbVxuICAgICAgICB0aGlzLl9pZENhY2hlW29sZElkXSA9IG5ld0lkO1xuICAgICAgICB0aGlzLl9zY3JpcHRDYWNoZVtuZXdJZF0gPSBwYXJ0RGF0YS5wcm9wZXJ0aWVzLnNjcmlwdDtcbiAgICAgICAgdGhpcy5fcHJvcHNDYWNoZVtuZXdJZF0gPSBwYXJ0RGF0YS5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLl9tb2RlbENhY2hlW25ld0lkXSA9IGluc3RhbmNlO1xuICAgICAgICB0aGlzLl9zdWJwYXJ0TWFwQ2FjaGVbbmV3SWRdID0gcGFydERhdGEuc3VicGFydHM7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlQ2FjaGUucHVzaChpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlSWQoYVBhcnQsIHBhcnREYXRhKXtcbiAgICAgICAgbGV0IG5ld0lkLCBvbGRJZDtcbiAgICAgICAgb2xkSWQgPSBwYXJ0RGF0YS5pZDtcbiAgICAgICAgbmV3SWQgPSBhUGFydC5pZDtcbiAgICAgICAgaWYoYVBhcnQudHlwZSAhPT0gJ3dvcmxkJyl7XG4gICAgICAgICAgICBuZXdJZCA9IGlkTWFrZXIubmV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5ld0lkLFxuICAgICAgICAgICAgb2xkSWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhZGRQYXJ0c1RvU3lzdGVtKGFMaXN0T2ZQYXJ0cyl7XG4gICAgICAgIGFMaXN0T2ZQYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0ucGFydHNCeUlkW3BhcnQuaWRdID0gcGFydDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tcGlsZVNjcmlwdHMoYUxpc3RPZlBhcnRzKXtcbiAgICAgICAgYUxpc3RPZlBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVQYXJ0U2NyaXB0KHBhcnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhdHRhY2hTdWJwYXJ0cyhhUGFydCl7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBfc3VicGFydE1hcENhY2hlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGFuIGVudHJ5IG1hcHBpbmcgZnJvbSB0aGlzIGFQYXJ0J3MgKG5ldylcbiAgICAgICAgLy8gaWQgdG8gYW4gYXJyYXkgb2YgaWRzIG9mIGFsc28taW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gc3VicGFydCBtb2RlbHNcbiAgICAgICAgbGV0IHN1YnBhcnRJZHMgPSB0aGlzLl9zdWJwYXJ0TWFwQ2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICBzdWJwYXJ0SWRzLmZvckVhY2goc3VicGFydElkID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdJZCA9IHRoaXMuX2lkQ2FjaGVbc3VicGFydElkXTtcbiAgICAgICAgICAgIGxldCBzdWJwYXJ0TW9kZWwgPSB0aGlzLl9tb2RlbENhY2hlW25ld0lkXTtcbiAgICAgICAgICAgIGlmKCFzdWJwYXJ0TW9kZWwpe1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVBhcnQuYWRkUGFydChzdWJwYXJ0TW9kZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRQcm9wZXJ0aWVzKGFQYXJ0KXtcbiAgICAgICAgbGV0IHByb3BzID0gdGhpcy5fcHJvcHNDYWNoZVthUGFydC5pZF07XG4gICAgICAgIGRlbGV0ZSBwcm9wc1snaWQnXTtcbiAgICAgICAgYVBhcnQuc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyKHByb3BzLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjcmVhdGVWaWV3KGFQYXJ0KXtcbiAgICAgICAgbGV0IG5ld1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgdGhpcy5zeXN0ZW0udGFnTmFtZUZvclZpZXdOYW1lZChhUGFydC50eXBlKVxuICAgICAgICApO1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgcGFydC1pZCBhdHRyaWJ1dGUgc2luY2UgdGhlc2VcbiAgICAgICAgLy8gYXJlIHVzZWQgZm9yIHF1ZXJpZXMgbmVlZGVkIGZvciB0aGluZ3MgbGlrZVxuICAgICAgICAvLyBjdXJyZW50IHN0YWNrIGFuZCBjYXJkXG4gICAgICAgIG5ld1ZpZXcuc2V0QXR0cmlidXRlKFwicGFydC1pZFwiLCBhUGFydC5pZCk7XG4gICAgICAgIHRoaXMuX3ZpZXdzQ2FjaGVbYVBhcnQuaWRdID0gbmV3VmlldztcbiAgICB9XG5cbiAgICBzZXRWaWV3TW9kZWwoYVBhcnQpe1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3ZpZXdzQ2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICB2aWV3LnNldE1vZGVsKGFQYXJ0KTtcbiAgICB9XG4gICAgXG4gICAgYXR0YWNoVmlldyhhUGFydCl7XG4gICAgICAgIGxldCBvd25lciA9IGFQYXJ0Ll9vd25lcjtcbiAgICAgICAgaWYob3duZXIpe1xuICAgICAgICAgICAgbGV0IG93bmVyVmlldyA9IHRoaXMuX3ZpZXdzQ2FjaGVbb3duZXIuaWRdO1xuICAgICAgICAgICAgbGV0IHBhcnRWaWV3ID0gdGhpcy5fdmlld3NDYWNoZVthUGFydC5pZF07XG4gICAgICAgICAgICBvd25lci5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2aWV3Q2hhbmdlZFwiLFxuICAgICAgICAgICAgICAgIGNoYW5nZU5hbWU6IFwic3VicGFydC1uZXdcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbcGFydFZpZXddXG4gICAgICAgICAgICB9LCBvd25lclZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcGlsZVBhcnRTY3JpcHQoYVBhcnQpe1xuICAgICAgICBsZXQgc2NyaXB0U3RyaW5nID0gdGhpcy5fc2NyaXB0Q2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICBpZihzY3JpcHRTdHJpbmcgJiYgc2NyaXB0U3RyaW5nICE9IFwiXCIpe1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0uY29tcGlsZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBpbGUnLFxuICAgICAgICAgICAgICAgIHRhcmdldElkOiBhUGFydC5pZCxcbiAgICAgICAgICAgICAgICBjb2RlU3RyaW5nOiBzY3JpcHRTdHJpbmcsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWZyZXNoV29ybGQoKXtcbiAgICAgICAgLy8gV2UgYXNzdW1lIGEgc2luZ2xlIHJvb3QgcGFydCB3YXMgZGVzZXJpYWxpemVkIGFuZFxuICAgICAgICAvLyBhdHRhY2ggaXQgYXMgdGhlIFdvcmxkIGFjY29yZGluZ2x5XG4gICAgICAgIGxldCBuZXdXb3JsZCA9IHRoaXMucm9vdFBhcnRzWzBdO1xuICAgICAgICBpZihuZXdXb3JsZC50eXBlICE9PSAnd29ybGQnKXtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihgRm91bmQgJHt0aGlzLnJvb3RQYXJ0cy5sZW5ndGh9IHJvb3RzLCBidXQgbm8gd29ybGQhYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddID0gdGhpcy5yb290UGFydHNbMF07XG4gICAgfVxuXG4gICAgYXBwZW5kV29ybGQoKXtcbiAgICAgICAgLy8gV2UgYXNzdW1lIGEgc2luZ2xlIHJvb3QgdmlldyB0aGF0IGlzIGFuIHN0LXdvcmxkLlxuICAgICAgICBsZXQgZm91bmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpO1xuICAgICAgICBpZihmb3VuZCl7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlcGxhY2VDaGlsZCh0aGlzLnJvb3RWaWV3c1swXSwgZm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5wcmVwZW5kKHRoaXMucm9vdFZpZXdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoVmlld0FkZGVkKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJykpO1xuICAgIH1cblxuICAgIGdldEZsYXR0ZW5lZFBhcnRUcmVlKGFQYXJ0LCBsaXN0PVtdKXtcbiAgICAgICAgbGlzdC5wdXNoKGFQYXJ0KTtcbiAgICAgICAgYVBhcnQuc3VicGFydHMuZm9yRWFjaChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RmxhdHRlbmVkUGFydFRyZWUoc3VicGFydCwgbGlzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICB0aHJvd0Vycm9yKG1lc3NhZ2Upe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlc2VyaWFsaXphdGlvbiBFcnJvcjogJHttZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGdldE1vZGVsQ2xhc3MoYVBhcnRUeXBlU3RyKXtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuc3lzdGVtLmF2YWlsYWJsZVBhcnRzW2FQYXJ0VHlwZVN0cl07XG4gICAgICAgIGlmKCFjbHMpe1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBQYXJ0IHR5cGUgXCIke2FQYXJ0VHlwZVN0cn1cIiBkb2VzIG5vdCBleGlzdCBpbiBzeXN0ZW1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xzO1xuICAgIH1cblxuICAgIGZsdXNoQ2FjaGVzKCl7XG4gICAgICAgIHRoaXMuX21vZGVsQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc3VicGFydE1hcENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2lkQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLl9wcm9wc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3ZpZXdzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0Q2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fcm9vdHNDYWNoZSA9IFtdO1xuICAgIH1cblxuICAgIGRpc3BhdGNoVmlld0FkZGVkKGFWaWV3KXtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzdC12aWV3LWFkZGVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcGFydFR5cGU6IGFWaWV3Lm1vZGVsLnR5cGUsXG4gICAgICAgICAgICAgICAgcGFydElkOiBhVmlldy5tb2RlbC5pZCxcbiAgICAgICAgICAgICAgICAvL293bmVySWQ6IGFWaWV3Lm1vZGVsLl9vd25lci5pZCB8fCBudWxsXG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgYVZpZXcucGFyZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBnZXQgcm9vdFBhcnRzKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290c0NhY2hlO1xuICAgIH1cblxuICAgIGdldCByb290Vmlld3MoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdFBhcnRzLm1hcChwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3c0NhY2hlW3BhcnQuaWRdO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuY2xhc3MgU1RTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihhU3lzdGVtKXtcbiAgICAgICAgdGhpcy5zeXN0ZW0gPSBhU3lzdGVtO1xuICAgICAgICB0aGlzLl9vYmplY3RDYWNoZSA9IHt9O1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXJpYWxpemVQYXJ0ID0gdGhpcy5zZXJpYWxpemVQYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmx1c2hDYWNoZXMgPSB0aGlzLmZsdXNoQ2FjaGVzLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgc2VyaWFsaXplKGFSb290UGFydCwgcHJldHR5PXRydWUpe1xuICAgICAgICB0aGlzLmZsdXNoQ2FjaGVzKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgcm9vdElkOiBhUm9vdFBhcnQuaWQsXG4gICAgICAgICAgICB0eXBlOiBhUm9vdFBhcnQudHlwZSxcbiAgICAgICAgICAgIGlkOiBhUm9vdFBhcnQuaWRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgUGFydHMgYW5kXG4gICAgICAgIC8vIHN0b3JlIGluIGZsYXQgbGlzdFxuICAgICAgICB0aGlzLnNlcmlhbGl6ZVBhcnQoYVJvb3RQYXJ0KTtcblxuICAgICAgICAvLyBXZSBzZXQgdGhlIHJlc3VsdCBvYmplY3RzIHBhcnRzXG4gICAgICAgIC8vIGRpY3QgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGNhY2hlXG4gICAgICAgIHJlc3VsdC5wYXJ0cyA9IHRoaXMuX29iamVjdENhY2hlO1xuXG4gICAgICAgIC8vIEZpbmFsbHksIHdlIGNvbnZlcnQgdG8gYSBzdHJpbmcgYW5kXG4gICAgICAgIC8vIHJldHVyblxuICAgICAgICBpZihwcmV0dHkpe1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlcmlhbGl6ZVBhcnQoYVBhcnQpe1xuICAgICAgICAvLyBXZSB1c2UgdGhlIHNlcmlhbGl6ZSBtZXRob2QgYXZhaWxhYmxlIG9uXG4gICAgICAgIC8vIGJhc2UgUGFydHMsIHBhc3NpbmcgaW4gdGhpcyBzZXJpYWxpemVyIGluc3RhbmNlXG4gICAgICAgIC8vIGFzIHRoZSBzb2xlIGFyZ1xuICAgICAgICB0aGlzLl9vYmplY3RDYWNoZVthUGFydC5pZF0gPSBhUGFydC5zZXJpYWxpemUodGhpcyk7XG4gICAgICAgIGFQYXJ0LnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZVBhcnQoc3VicGFydCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZsdXNoQ2FjaGVzKCl7XG4gICAgICAgIHRoaXMuX29iamVjdENhY2hlID0ge307XG4gICAgfVxufVxuXG5leHBvcnQge1xuICAgIFNUU2VyaWFsaXplcixcbiAgICBTVERlc2VyaWFsaXplclxufTtcbiIsIi8qKlxuICogSGVscGVycyBmb3Igc2V0dGluZyB1cCB2YXJpb3VzXG4gKiBzdHlsZSBwcm9wZXJ0aWVzXG4gKi9cblxuXG4vKipcbiAqIEJhc2ljIHN0eWxlIHByb3BlcnRpZXMgYXJlIHRob3NlXG4gKiBjb21tb24gdG8gYWxsICh2aXN1YWwpIFBhcnRzXG4gKi9cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jb25zdCBhZGRCYXNpY1N0eWxlUHJvcHMgPSAodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgMSxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIiwgLy8gd2hpdGUgXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndHJhbnNwYXJlbmN5JyxcbiAgICAgICAgMS4wLFxuICAgICk7XG4gICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAgICAgYGJvcmRlci0ke3N9LXN0eWxlYCxcbiAgICAgICAgICAgICdzb2xpZCdcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgXCJyZ2IoMCwgMCwgMClcIiwgLy8gYmxhY2tcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICAgICBgYm9yZGVyLSR7c30tdHJhbnNwYXJlbmN5YCxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LWxlZnQnLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LXRvcCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctYmx1cicsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctc3ByZWFkJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3NoYWRvdy1jb2xvcicsXG4gICAgICAgIFwicmdiKDIzOCwgMjM4LCAyMzgpXCIsIC8vIGdyZXlcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgMVxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2Nvcm5lci10b3AtbGVmdC1yb3VuZCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdjb3JuZXItdG9wLXJpZ2h0LXJvdW5kJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2Nvcm5lci1ib3R0b20tbGVmdC1yb3VuZCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdjb3JuZXItYm90dG9tLXJpZ2h0LXJvdW5kJyxcbiAgICAgICAgMFxuICAgICk7XG59O1xuXG4vKipcbiAqIFN0eWxlIHByb3BlcnRpZXMgZm9yIFBhcnRzIHRoYXQgY2FuXG4gKiBiZSBtb3ZlZCBhbmQgdGhhdCBjYW4gaGF2ZSBleHBsaWNpdFxuICogZGltZW5zaW9ucy4gRXhhbXBsZXM6IGJ1dHRvbnMsIGZpZWxkcy5cbiAqIEV4YW1wbGVzIG9mIHRob3NlIHRoYXQgY2FuJ3Q6IENhcmRzLCBTdGFja3NcbiAqL1xuY29uc3QgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzID0gKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdoaWRlJyxcbiAgICAgICAgZmFsc2UsXG4gICAgKTtcbiAgICAvLyBzZXR0aW5nIHdpZHRoIGFuZCBoZWlnaHQgdG8gbnVsbFxuICAgIC8vIGVmZmVjdGl2ZWx5IGZvcmNlcyB0byB0aGUgZGVmYXVsdCBzaXplXG4gICAgLy8gb2YgdGhlIGJ1dHRvbiB0byBmaXQgdGhlIGJ1dHRvbiBuYW1lXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgMTAwLFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIG51bGwsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndG9wJyxcbiAgICAgICAgMCxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgMCxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdyb3RhdGUnLFxuICAgICAgICBudWxsLFxuICAgICk7XG5cbiAgICAvLyBob3Jpem9udGFsLXJlc2l6aW5nIHNwZWNpZmllcyBhIHN0cmF0ZWd5XG4gICAgLy8gZm9yIGhvdyB0aGlzIFBhcnQgc2hvdWxkIGFkanVzdCBpdHNcbiAgICAvLyBob3Jpem9udGFsIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBhcmVudC5cbiAgICAvLyBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgIC8vICogcmlnaWQgLSBTdGljayB0byB0aGUgdG9wLCBsZWZ0LCB3aWR0aFxuICAgIC8vIGFuZCBoZWlnaHQgcHJvcGVydGllcyBhcyB0aGV5IGFyZSBleHBsaWNpdGx5XG4gICAgLy8gc2V0O1xuICAgIC8vICogc2hyaW5rLXdyYXAgLSBCZWNvbWUgbGFyZ2UgZW5vdWdoIG9uIHRoZSBob3JpLVxuICAgIC8vIHpvbnRhbCBheGlzIG9ubHkgdG8gZml0IGFueSBjaGlsZCBjb250ZW50cztcbiAgICAvLyAqIHNwYWNlLWZpbGwgLSBGaWxsIGFzIG11Y2ggYXMgd2UgY2FuIGluIHRoZVxuICAgIC8vIGhvcml6b250YWwgYXhpcyBpbiB0aGUgcGFyZW50IFBhcnQuXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2hvcml6b250YWwtcmVzaXppbmcnLFxuICAgICAgICAncmlnaWQnXG4gICAgKTtcblxuICAgIC8vIHZlcnRpY2FsLXJlc2l6aW5nIHNwZWNpZmllcyBhIHN0cmF0ZWd5XG4gICAgLy8gZm9yIGhvdyB0aGlzIFBhcnQgc2hvdWxkIGFkanVzdCBpdHNcbiAgICAvLyB2ZXJ0aWNhbCBheGlzIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gICAgLy8gUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAvLyAqIHJpZ2lkIC0gU3RpY2sgdG8gdGhlIHRvcCwgbGVmdCwgd2lkdGhcbiAgICAvLyBhbmQgaGVpZ2h0IHByb3BlcnRpZXMgYXMgdGhleSBhcmUgZXhwbGljaXRseVxuICAgIC8vIHNldDtcbiAgICAvLyAqIHNocmluay13cmFwIC0gQmVjb21lIGxhcmdlIGVub3VnaCBvbiB0aGUgaG9yaS1cbiAgICAvLyB6b250YWwgYXhpcyBvbmx5IHRvIGZpdCBhbnkgY2hpbGQgY29udGVudHM7XG4gICAgLy8gKiBzcGFjZS1maWxsIC0gRmlsbCBhcyBtdWNoIGFzIHdlIGNhbiBpbiB0aGVcbiAgICAvLyB2ZXJ0aWNhbCBheGlzIGluIHRoZSBwYXJlbnQgUGFydC5cbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndmVydGljYWwtcmVzaXppbmcnLFxuICAgICAgICAncmlnaWQnXG4gICAgKTtcblxuICAgIC8vIE1hcmdpbiBzcGVjaWZpZXMgc29tZSBzcGFjZSBiZXR3ZWVuIHRoZVxuICAgIC8vIHRhcmdldCBQYXJ0IGFuZCBhbnkgb3RoZXIgUGFydHMgdGhhdCBtaWdodFxuICAgIC8vIGJlIGFkamFjZW50IHRvIGl0IGluIGEgY29tbW9uIE93bmVyLiBJdCB3aWxsXG4gICAgLy8gbm90IGJlIGluIGVmZmVjdCB3aGVuIHRoZSBvd25lciBpcyB1c2luZyBhXG4gICAgLy8gc3RyaWN0IGxheW91dC5cbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndG9wLW1hcmdpbicsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdyaWdodC1tYXJnaW4nLFxuICAgICAgICBudWxsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnYm90dG9tLW1hcmdpbicsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdsZWZ0LW1hcmdpbicsXG4gICAgICAgIG51bGxcbiAgICApO1xuXG4gICAgLy8gUGlubmluZyBzcGVjaWZpZXMgd2hldGhlciBvciBub3RcbiAgICAvLyBhIGdpdmVuIHBhcnQgc2hvdWxkIFwic3RpY2tcIiB0byBhXG4gICAgLy8gcGFydGljdWxhciBzaWRlIG9mIGl0cyBvd25lciBQYXJ0LlxuICAgIC8vIFBpbm5pbmcgcHJvcGVydGllcyBvbmx5IGhhdmUgZWZmZWN0XG4gICAgLy8gaW5zaWRlIG9mIFBhcnRzIHdpdGggYSBzdHJpY3QgbGF5b3V0XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAncGlubmluZy10b3AnLFxuICAgICAgICBwaW5uaW5nU2V0dGVyLFxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHByb3BPYmplY3QuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICBmYWxzZSAvLyBkZWZhdWx0IHZhbHVlXG5cbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgJ3Bpbm5pbmctbGVmdCcsXG4gICAgICAgIHBpbm5pbmdTZXR0ZXIsXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlLCAvLyBub3QgcmVhZCBvbmx5XG4gICAgICAgIGZhbHNlIC8vIGRlZmF1bHQgdmFsdWVcblxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAncGlubmluZy1ib3R0b20nLFxuICAgICAgICBwaW5uaW5nU2V0dGVyLFxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHByb3BPYmplY3QuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICBmYWxzZSAvLyBkZWZhdWx0IHZhbHVlXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICdwaW5uaW5nLXJpZ2h0JyxcbiAgICAgICAgcGlubmluZ1NldHRlcixcbiAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgIHJldHVybiBwcm9wT2JqZWN0Ll92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2UsIC8vIG5vdCByZWFkIG9ubHlcbiAgICAgICAgZmFsc2UgLy8gZGVmYXVsdCB2YWx1ZVxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXMgZm9yIHRoZSBjb21wb3VuZFxuICAgICAgICAvLyAncGlubmluZycgcHJvcGVydHkgYXJlOlxuICAgICAgICAvLyAqXCJub25lXCIgb3IgbnVsbFxuICAgICAgICAvLyAqdG9wXG4gICAgICAgIC8vICp0b3AtcmlnaHRcbiAgICAgICAgLy8gKnRvcC1sZWZ0XG4gICAgICAgIC8vICpib3R0b21cbiAgICAgICAgLy8gKmJvdHRvbS1yaWdodFxuICAgICAgICAvLyAqYm90dG9tLWxlZnRcbiAgICAgICAgLy8gKmxlZnRcbiAgICAgICAgLy8gKnJpZ2h0XG4gICAgICAgICdwaW5uaW5nJyxcbiAgICAgICAgLy8gU2V0dGVyXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsdWUpe1xuICAgICAgICAgICAgaWYoIXZhbHVlIHx8IHZhbHVlID09IFwibm9uZVwiKXtcbiAgICAgICAgICAgICAgICBbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaW4gPSBgcGlubmluZy0ke3NpZGV9YDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wT3duZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpbm5pbmdBZGp1c3QocHJvcE93bmVyLCB2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICBsZXQgdG9wID0gcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLXRvcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLWJvdHRvbSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1sZWZ0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1yaWdodCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZih0b3Ape1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd0b3AnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihib3R0b20pe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdib3R0b20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGxlZnQpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYocmlnaHQpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdyaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJy0nKTtcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG4vKipcbiAqIFN0eWxlIHByb3BlcnRpZXMgZm9yIFBhcnRzIHRoYXQgZGlzcGxheVxuICogdGV4dFxuICovXG5jb25zdCBhZGRUZXh0U3R5bGVQcm9wcyA9ICh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1hbGlnbicsXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LWZvbnQnLFxuICAgICAgICAnZGVmYXVsdCcsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1jb2xvcicsXG4gICAgICAgIFwicmdiKDAsIDAsIDApXCIsIC8vIGJsYWNrXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC10cmFuc3BhcmVuY3knLFxuICAgICAgICAxLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtc3R5bGUnLFxuICAgICAgICAncGxhaW4nLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtYm9sZCcsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtaXRhbGljJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1zaXplJyxcbiAgICAgICAgMTUsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbn07XG5cbi8qKlxuICogQmFzaWMgbGF5b3V0IHN0eWxlcyBhcmUgdGhvc2UgcGVydGFpbmluZ1xuICogdG8gdGhlIHBvc2l0aW9uaW5nIGFuZCByZXNpemluZyBvZiBzdWJwYXJ0cy5cbiAqIEV4YW1wbGVzIGluY2x1ZGUgQ2FyZHMgYW5kIEFyZWFcbiAqL1xuY29uc3QgYWRkTGF5b3V0U3R5bGVQcm9wcyA9ICh0YXJnZXQpID0+IHtcbiAgICAvLyBUaGUgJ2xheW91dCcgcHJvcGVydHkgaXNcbiAgICAvLyBvbmUgb2YgdHdvIHN0cmluZ3M6XG4gICAgLy8gc3RyaWN0IC0gRXF1aXZhbGVudCB0byB0aGUgYWJzb2x1dGVcbiAgICAvLyBsYXlvdXQgYmFzZWQgc3RyaWN0bHkgb24gY29vcmRpbmF0ZXNcbiAgICAvLyBsaXN0IC0gV2lsbCBmb3JjZSBpdGVtcyBpbnRvIGVpdGhlciBhIHJvd1xuICAgIC8vIG9yIGNvbHVtbiBsaXN0LCBiYXNlZCBvbiB0aGUgcGFpcmluZyB3aXRoXG4gICAgLy8gdGhlICdsaXN0RGlyZWN0aW9uJyBwcm9wZXJ0eVxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICdsYXlvdXQnLFxuICAgICAgICAnc3RyaWN0J1xuICAgICk7XG5cbiAgICAvLyBsaXN0LWRpcmVjdGlvbiBzcGVjaWZpZXMgcm93IG9yIGNvbHVtblxuICAgIC8vIGFuZCB3aWxsIG9ubHkgaGF2ZSBhbiBlZmZlY3Qgd2hlbnQgdGhlXG4gICAgLy8gbGF5b3V0IHByb3BlcnR5IGlzIHNldCB0byAnbGlzdCdcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAnbGlzdC1kaXJlY3Rpb24nLFxuICAgICAgICAncm93J1xuICAgICk7XG5cbiAgICAvLyBXcmFwcGluZyBzcGVjaWZpZXMgd2hldGhlciBhIGxpc3Qgc2hvdWxkXG4gICAgLy8gd3JhcCBhbG9uZyBpdHMgZG9taW5hbnQgZGltZW5zaW9uIChyb3cgb3IgY29sdW1uKVxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICdsaXN0LXdyYXBwaW5nJyxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgLy8gUGFkZGluZyBzcGVjaWZpZXMgc29tZSBzcGFjZSBmcm9tIHRoZVxuICAgIC8vIGJvcmRlciBvZiB0aGUgdGFyZ2V0IFBhcnQgdG8gdGhlIGJlZ2lubmluZ1xuICAgIC8vIG9mIHRoZSBsYXlvdXQgb2YgYW55IHN1YnBhcnRzLlxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0b3AtcGFkZGluZycsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdyaWdodC1wYWRkaW5nJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2JvdHRvbS1wYWRkaW5nJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2xlZnQtcGFkZGluZycsXG4gICAgICAgIG51bGxcbiAgICApO1xuXG4gICAgLy8gTGlzdCBhbGlnbm1lbnQgZGVzY3JpYmVzIGhvdyBlbGVtZW50cyBpblxuICAgIC8vIGEgbGlzdCBsYXlvdXQgc2hvdWxkIGFsaWduIHRoZW1zZWx2ZXMgYWxvbmdcbiAgICAvLyB0aGUgZG9taW5hbnQgZGltZW5zaW9uIChyb3cgb3IgY29sdW1uKVxuICAgIC8vIFRoZXkgYXJlIGVzc2VudGlhbGx5IHByb3hpZXMgZm9yIGFsaWduLWl0ZW1zXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgJ2xpc3QtYWxpZ25tZW50JyxcbiAgICAgICAgbnVsbFxuICAgICk7XG5cbiAgICAvLyBMaXN0IGRpc3RyaWJ1dGlvbiBkZXNjcmliZXMgaG93IGVsZW1lbnRzXG4gICAgLy8gaW4gYSBsaXN0IGxheW91dCBzaG91bGQgZGlzdHJpYnV0ZSB0aGVtc2VsdmVzXG4gICAgLy8gYWNyb3NzIG9yIGFsb25nIHRoZSBkb21pbmFudCBkaW1lbnNpb25cbiAgICAvLyAocm93IG9yIGNvbHVtbilcbiAgICAvLyBUaGlzIGlzIGVzc2VudGlhbGx5IGEgd3JhcHBlciBmb3IganVzdGlmeS1jb250ZW50XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgJ2xpc3QtZGlzdHJpYnV0aW9uJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG59O1xuXG4vKipcbiAgKiBIRUxQRVJTXG4gKiovXG5cbmNvbnN0IHBpbm5pbmdTZXR0ZXIgPSAocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWx1ZSkgPT4ge1xuICAgIGxldCBzaWRlID0gcHJvcE9iamVjdC5uYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICBsZXQgdG9wTGVmdDtcbiAgICBzd2l0Y2ggKHNpZGUpe1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICB0b3BMZWZ0ID0gXCJsZWZ0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgdG9wTGVmdCA9IFwidG9wXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRvcExlZnQgPSBzaWRlO1xuICAgIH1cbiAgICAvLyB3ZSdsbCBuZWVkIHRvIGZpeCBhbmQgdW4tZml4IHRoZSBjb3JyZXNwb25kaW5nIHRvcCBvciBsZWZ0IHByb3BlcnR5IGRlcGVuZGluZ1xuICAgIC8vIG9uIHdoZXRoZXIgdmFsdWUgaXMgdHJ1ZSBvZiBmYWxzZSwgcmVzcGVjdGl2ZWx5XG4gICAgbGV0IHByb3AgPSBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoXG4gICAgICAgIHRvcExlZnQgXG4gICAgKTtcbiAgICBsZXQgb3Bwb3NpdGVTaWRlO1xuICAgIHN3aXRjaCAoc2lkZSl7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgb3Bwb3NpdGVTaWRlID0gXCJyaWdodFwiO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgb3Bwb3NpdGVTaWRlID0gXCJsZWZ0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgb3Bwb3NpdGVTaWRlID0gXCJib3R0b21cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICBvcHBvc2l0ZVNpZGUgPSBcInRvcFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYodmFsdWUpe1xuICAgICAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCBwaW5uaW5nLWJvdHRvbSBpcyBmYWxzZVxuICAgICAgICBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgIGBwaW5uaW5nLSR7b3Bwb3NpdGVTaWRlfWAsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICBwcm9wLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNldCB0aGUgdmFsdWUgYmFjayB0byB0cmlnZ2VyIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIHByb3Auc2V0VmFsdWUocHJvcE93bmVyLCBwcm9wLl92YWx1ZSk7XG4gICAgICAgIHByb3AucmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcHJvcE9iamVjdC5fdmFsdWUgPSB2YWx1ZTtcbn07XG5cbmNvbnN0IHBpbm5pbmdBZGp1c3QgPSAob3duZXIsIHZhbHVlKSA9PiB7XG4gICAgbGV0IHNpZGVzID0gWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXTtcbiAgICBzaWRlcy5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgICBpZih2YWx1ZS5zdGFydHNXaXRoKHNpZGUpKXtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgYHBpbm5pbmctJHtzaWRlfWAsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgYHBpbm5pbmctJHtzaWRlfWAsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKHZhbHVlLmluY2x1ZGVzKFwiLVwiKSl7XG4gICAgICAgIGlmKHZhbHVlLmVuZHNXaXRoKCdsZWZ0Jykpe1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1sZWZ0JyxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1yaWdodCcsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZS5lbmRzV2l0aCgncmlnaHQnKSl7XG4gICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLWxlZnQnLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1yaWdodCcsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRUZXh0U3R5bGVQcm9wcyxcbiAgICBhZGRMYXlvdXRTdHlsZVByb3BzXG59O1xuIiwiLyoqXG4gKiBTdHlsZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSByZXNwb25zaWJsZSBmb3IgY29udmVydGluZ1xuICogU2ltcGxlVGFsayB2aXN1YWwgc3R5bGluZyB0byBhIGRpY3RcbiAqIE9iamVjdCBvZiBDU1MgSmF2YVNjcmlwdCB0eXBlIGtleS12YWx1ZSBwYWlyc1xuICovXG5cbi8qKiBJIHN0eWxlIHRoZSBzdHlsZU9ialxuICogc3R5bGVPYmo6IGNzcyBKYXZhU2NyaXB0IGtleTp2YWx1ZSBwYWlyc1xuICogcHJvcGVydHlOYW1lOiAoU2ltcGxlVGFsaykgc3R5bGluZyBwcm9wZXJ0eSBuYW1lXG4gKiBwcm9wZXJ0eVZhbHVlOiAoU2ltcGxlVGFsaykgc3R5bGluZyBwcm9wZXJ0eSB2YWx1ZVxuICovXG5cbmNvbnN0IGNzc1N0eWxlciA9IChzdHlsZU9iaiwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSA9PiB7XG4gICAgc3dpdGNoKHByb3BlcnR5TmFtZSl7XG5cbiAgICBjYXNlIFwiYmFja2dyb3VuZC1jb2xvclwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiYmFja2dyb3VuZENvbG9yXCIsICBfY29sb3JUb1JHQkEoc3R5bGVPYmpbXCJiYWNrZ3JvdW5kQ29sb3JcIl0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgLy8gaGVyZSB3ZSBzZXQgdGhlIEFscGhhIHZhbHVlIG9mIHRoZSBjdXJyZW50IHN0eWxlT2JqW1wiYmFja2dyb3VuZENvbG9yXCJdIHJnYmFcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImJhY2tncm91bmRDb2xvclwiLCAgX2NvbG9yVHJhbnNwYXJlbmN5VG9SR0JBKHN0eWxlT2JqW1wiYmFja2dyb3VuZENvbG9yXCJdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImJvcmRlci10b3Atc3R5bGVcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiOlxuICAgIGNhc2UgXCJib3JkZXItbGVmdC1zdHlsZVwiOlxuICAgIGNhc2UgXCJib3JkZXItcmlnaHQtc3R5bGVcIjoge1xuICAgICAgICBsZXQgcyA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYGJvcmRlci0ke3N9LXN0eWxlYCwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFwiYm9yZGVyLXRvcC13aWR0aFwiOlxuICAgIGNhc2UgXCJib3JkZXItYm90dG9tLXdpZHRoXCI6XG4gICAgY2FzZSBcImJvcmRlci1sZWZ0LXdpZHRoXCI6XG4gICAgY2FzZSBcImJvcmRlci1yaWdodC13aWR0aFwiOiB7XG4gICAgICAgIGxldCBzID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgYm9yZGVyLSR7c30td2lkdGhgLCAgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFwiYm9yZGVyLXRvcC1jb2xvclwiOlxuICAgIGNhc2UgXCJib3JkZXItYm90dG9tLWNvbG9yXCI6XG4gICAgY2FzZSBcImJvcmRlci10b3AtY29sb3JcIjpcbiAgICBjYXNlIFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCI6IHtcbiAgICAgICAgbGV0IHMgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtzfS1jb2xvcmAsICBfY29sb3JUb1JHQkEoc3R5bGVPYmpbYGJvcmRlci0ke3N9LWNvbG9yYF0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImJvcmRlci10b3AtdHJhbnNwYXJlbmN5XCI6XG4gICAgY2FzZSBcImJvcmRlci1ib3R0b20tdHJhbnNwYXJlbmN5XCI6XG4gICAgY2FzZSBcImJvcmRlci1sZWZ0LXRyYW5zcGFyZW5jeVwiOlxuICAgIGNhc2UgXCJib3JkZXItcmlnaHQtdHJhbnNwYXJlbmN5XCI6IHtcbiAgICAgICAgbGV0IHMgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtzfS1jb2xvcmAsICBfY29sb3JUcmFuc3BhcmVuY3lUb1JHQkEoc3R5bGVPYmpbYGJvcmRlci0ke3N9LWNvbG9yYF0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImNvcm5lci10b3AtbGVmdC1yb3VuZFwiOlxuICAgIGNhc2UgXCJjb3JuZXItdG9wLXJpZ2h0LXJvdW5kXCI6XG4gICAgY2FzZSBcImNvcm5lci1ib3R0b20tbGVmdC1yb3VuZFwiOlxuICAgIGNhc2UgXCJjb3JuZXItYm90dG9tLXJpZ2h0LXJvdW5kXCI6e1xuICAgICAgICBsZXQgYzEgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBsZXQgYzIgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzJdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtjMX0tJHtjMn0tcmFkaXVzYCwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcInNoYWRvdy1sZWZ0XCI6XG4gICAgY2FzZSBcInNoYWRvdy10b3BcIjpcbiAgICBjYXNlIFwic2hhZG93LWJsdXJcIjpcbiAgICBjYXNlIFwic2hhZG93LXNwcmVhZFwiOlxuICAgIGNhc2UgXCJzaGFkb3ctY29sb3JcIjpcbiAgICBjYXNlIFwic2hhZG93LXRyYW5zcGFyZW5jeVwiOlxuICAgICAgICBsZXQgc2hhZG93UHJvcCA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIGxldCBbbGVmdCwgdG9wLCBibHVyLCBzcHJlYWQsIGNvbG9yXSA9IF9jc3NCb3hTaGFkb3coc3R5bGVPYmpbXCJib3gtc2hhZG93XCJdKTtcbiAgICAgICAgc3dpdGNoKHNoYWRvd1Byb3Ape1xuICAgICAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgICAgIGNvbG9yID0gX2NvbG9yVG9SR0JBKGNvbG9yLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHJhbnNwYXJlbmN5XCI6XG4gICAgICAgICAgICBjb2xvciA9IF9jb2xvclRyYW5zcGFyZW5jeVRvUkdCQShjb2xvciwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgIGxlZnQgPSBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICB0b3AgPSBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICAgICAgYmx1ciA9IF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcHJlYWRcIjpcbiAgICAgICAgICAgIHNwcmVhZCA9IF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImJveC1zaGFkb3dcIiwgYCR7bGVmdH0gJHt0b3B9ICR7Ymx1cn0gJHtzcHJlYWR9ICR7Y29sb3J9YCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtY29sb3JcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImNvbG9yXCIsICBfY29sb3JUb1JHQkEoc3R5bGVPYmpbXCJjb2xvclwiXSwgcHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWZvbnRcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnRGYW1pbHlcIiwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LXNpemVcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnRTaXplXCIsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWFsaWduXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0ZXh0QWxpZ25cIiwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWJvbGRcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udC13ZWlnaHRcIiwgIFwiYm9sZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmKHByb3BlcnR5VmFsdWUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJmb250LXdlaWdodFwiLCAgXCJub3JtYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1pdGFsaWNcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udC1zdHlsZVwiLCAgXCJpdGFsaWNcIik7XG4gICAgICAgIH0gZWxzZSBpZihwcm9wZXJ0eVZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udC1zdHlsZVwiLCAgXCJub3JtYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC11bmRlcmxpbmVcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidGV4dERlY29yYXRpb25cIiwgIFwidW5kZXJsaW5lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtc3RyaWtldGhyb3VnaFwiOlxuICAgICAgICBpZihwcm9wZXJ0eVZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0ZXh0RGVjb3JhdGlvblwiLCAgXCJsaW5lLXRocm91Z2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC10cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgLy8gaGVyZSB3ZSBzZXQgdGhlIEFscGhhIHZhbHVlIG9mIHRoZSBjdXJyZW50IHN0eWxlT2JqW1wiY29sb3JcIl0gcmdiYVxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiY29sb3JcIiwgIF9jb2xvclRyYW5zcGFyZW5jeVRvUkdCQShzdHlsZU9ialtcImNvbG9yXCJdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidG9wXCIsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImxlZnRcIiwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcIndpZHRoXCIsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiaGVpZ2h0XCIsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImxlZnQtbWFyZ2luXCI6XG4gICAgY2FzZSBcInJpZ2h0LW1hcmdpblwiOlxuICAgIGNhc2UgXCJib3R0b20tbWFyZ2luXCI6XG4gICAgY2FzZSBcInRvcC1tYXJnaW5cIjpcbiAgICAgICAgbGV0IG1hcmdpblNpZGUgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgICBtYXJnaW5TaWRlID0gYCR7bWFyZ2luU2lkZVswXS50b1VwcGVyQ2FzZSgpfSR7bWFyZ2luU2lkZS5zbGljZSgxKX1gO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBtYXJnaW4ke21hcmdpblNpZGV9YCwgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJsZWZ0LXBhZGRpbmdcIjpcbiAgICBjYXNlIFwicmlnaHQtcGFkZGluZ1wiOlxuICAgIGNhc2UgXCJib3R0b20tcGFkZGluZ1wiOlxuICAgIGNhc2UgXCJ0b3AtcGFkZGluZ1wiOlxuICAgICAgICBsZXQgcGFkZGluZ1NpZGUgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgICBwYWRkaW5nU2lkZSA9IGAke3BhZGRpbmdTaWRlWzBdLnRvVXBwZXJDYXNlKCl9JHtwYWRkaW5nU2lkZS5zbGljZSgxKX1gO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBwYWRkaW5nJHtwYWRkaW5nU2lkZX1gLCBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtc3R5bGVcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcInRleHRTdHlsZVwiLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidHJhbnNmb3JtXCIsICBfaW50VG9Sb3RhdGVEZWcocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcIm9wYWNpdHlcIiwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJoaWRlXCI6XG4gICAgICAgIGlmKHByb3BlcnR5VmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgc3R5bGVPYmpbXCJkaXNwbGF5XCJdID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSBpZihwcm9wZXJ0eVZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICBzdHlsZU9ialtcImRpc3BsYXlcIl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICBkZWZhdWx0OlxuICAgICAgICAvLyBmb3IgdGhlIGRlZmF1bHQgd2Ugc2ltcGx5IGFsbG93IFNUIHN0eWxlIG5hbWVzIHRvIG1hcCAxLTFcbiAgICAgICAgLy8gdG8gQ1NTL0pTIHN0eWxlIG5hbWVzLiBUaGlzIGlzIG9ubHkgc29tZXdoYXQgc2FmZSwgc2luY2UgdGhlIERPTVxuICAgICAgICAvLyB3aWxsIHNpbXBseSBpZ25vcmUgbm9uc2Vuc2UgbmFtZXMgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci4gQnV0IGl0XG4gICAgICAgIC8vIGRvZXMgYWxsb3cgdXMgdG8gYXZvaWQgd3JpdGluZyBhIHJ1bGUgZm9yIGV2ZXJ5IHRlcm0gKGV4YW1wbGU6IHdpZHRoLFxuICAgICAgICAvLyBoZWlnaHQsIHRvcCwgbGVmdCBldGMpXG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgcHJvcGVydHlOYW1lLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZU9iajtcblxufTtcblxuLy8gSW4gb3JkZXIgdG8gYXZvaWQgY2xhc2hpbmcgd2l0aCB2aWV3cyBpbnRlcmFjdGluZ1xuLy8gdGhlIHN0eWxlIGF0dHJpYnV0ZSBkaXJlY3RseSB3ZSBpZ25vcmUgZXZlcnl0aGluZyB0aGF0XG4vLyBpcyBlaXRoZXIgbnVsbCBvciB1bmRlZmluZWRcbi8vIFRPRE8gcmV2aWV3IHRoaXMgZGVjaXNpb24hXG5jb25zdCBfc2V0T3JOb3QgPSAoc3R5bGVPYmosIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgaWYodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgIHN0eWxlT2JqW25hbWVdID0gdmFsdWU7XG4gICAgfVxufTtcblxuY29uc3QgX2ludFRvUm90YXRlRGVnID0gKG4pID0+IHtcbiAgICBpZihuICE9PSBudWxsICYmIG4gIT09IHVuZGVmaW5lZCl7XG4gICAgICAgIGlmKHR5cGVvZihuKSA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICBuID0gbi5zcGxpdChcImRlZ1wiKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHJvdGF0ZSgke259ZGVnKWA7XG4gICAgfVxufTtcblxuXG5jb25zdCBfaW50VG9QeCA9IChuKSA9PiB7XG4gICAgaWYobiAhPT0gbnVsbCAmJiBuICE9PSB1bmRlZmluZWQpe1xuICAgICAgICBpZih0eXBlb2YobikgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgaWYobiA9PSBcImZpbGxcIil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMTAwJVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmKFtcInRoaW5cIiwgXCJtZWRpdW1cIiwgXCJ0aGlja1wiXS5pbmRleE9mKG4pID4gLTEpe1xuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4uc3BsaXQoXCJweFwiKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bn1weGA7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCBjb2xvcnMgdG8gcmdiYVxuLy8gY2hhbmdlIGEgY3NzIGNvbG9yIFJHQiB2YWx1ZXMsIHByZXNlcnZpbmcgdGhlIEEobHBoYSkgdmFsdWVcbmNvbnN0IF9jb2xvclRvUkdCQSA9IChjc3NDb2xvciwgU1RDb2xvcikgPT4ge1xuICAgIGlmKCFTVENvbG9yKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgciwgZywgYiwgYSwgXztcbiAgICAvLyBTVCBjb2xvcnMgYXJlIFJHQlxuICAgIGlmKFNUQ29sb3Iuc3RhcnRzV2l0aChcInJnYlwiKSl7XG4gICAgICAgIFtyLCBnLCBiXSA9IFNUQ29sb3IubWF0Y2goL1xcZCsvZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbG9ySW5mbyA9IGJhc2ljQ1NTQ29sb3JzW1NUQ29sb3JdO1xuICAgICAgICBpZihjb2xvckluZm8pe1xuICAgICAgICAgICAgciA9IGNvbG9ySW5mb1tcInJcIl07XG4gICAgICAgICAgICBnID0gY29sb3JJbmZvW1wiZ1wiXTtcbiAgICAgICAgICAgIGIgPSBjb2xvckluZm9bXCJiXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKGNzc0NvbG9yKXtcbiAgICAgICAgW18sIF8sIF8sIGFdID0gY3NzQ29sb3IubWF0Y2goL1tcXGRcXC5dKy9nKTtcbiAgICAgICAgLy8gaWYgQWxwaGEgaXMgbm90IGRlZmluZWQgdGhlbiB3ZSBzZXQgaXQgdG8gMVxuICAgICAgICAvLyBkZWZhdWx0IGZvciBicm93c2Vyc1xuICAgIH1cbiAgICBpZighYSl7XG4gICAgICAgIGEgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xufVxuXG4vLyBjaGFuZ2UgdGhlIEEoYWxwaGEpIHZhbHVlLCBwcmVzZXJ2aW5nIHRoZSBSR0IgdmFsdWVzXG5jb25zdCBfY29sb3JUcmFuc3BhcmVuY3lUb1JHQkEgPSAoY3NzQ29sb3IsIHRWYWx1ZSkgPT4ge1xuICAgIGlmKCFjc3NDb2xvcil7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgciwgZywgYjtcbiAgICBsZXQgbWFwcGVkQ29sb3IgPSBiYXNpY0NTU0NvbG9yc1tjc3NDb2xvcl07XG4gICAgaWYobWFwcGVkQ29sb3Ipe1xuICAgICAgICByID0gbWFwcGVkQ29sb3IucjtcbiAgICAgICAgZyA9IG1hcHBlZENvbG9yLmc7XG4gICAgICAgIGIgPSBtYXBwZWRDb2xvci5iO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFtyLCBnLCBiXSA9IGNzc0NvbG9yLm1hdGNoKC9cXGQrL2cpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHt0VmFsdWV9KWA7XG59XG5cbi8vIEFkZCBtb3JlIGNvbG9ycyBhcyBuZWVkZWRcbmNvbnN0IGJhc2ljQ1NTQ29sb3JzID0ge1xuICAgIGJsYWNrOiB7aGV4OiBcIiMwMDAwMDBcIiwgcjogMCwgZzogMCwgYjogMH0sXG5cdFx0c2lsdmVyOiB7aGV4OiBcIiNDMEMwQzBcIiwgcjogMTkyLCBnOiAxOTIsIGI6IDE5Mn0sXG5cdFx0Z3JheToge2hleDogXCIjODA4MDgwXCIsIHI6IDEyOCwgZzogMTI4LCBiOiAxMjh9LFxuXHRcdHdoaXRlOiB7aGV4OiBcIiNGRkZGRkZcIiwgcjogMjU1LCBnOiAyNTUsIGI6IDI1NX0sXG5cdFx0bWFyb29uOiB7aGV4OiBcIiM4MDAwMDBcIiwgcjogMTI4LCBnOiAwLCBiOiAwfSxcblx0XHRyZWQ6IHtoZXg6IFwiI0ZGMDAwMFwiLCByOiAyNTUsIGc6IDAsIGI6IDB9LFxuXHRcdHB1cnBsZToge2hleDogXCIjODAwMDgwXCIsIHI6IDEyOCwgZzogMCwgYjogMTI4fSxcblx0XHRmdWNoc2lhOiB7aGV4OiBcIiNGRjAwRkZcIiwgcjogMjU1LCBnOiAwLCBiOiAyNTV9LFxuXHRcdGdyZWVuOiB7aGV4OiBcIiMwMDgwMDBcIiwgcjogMCwgZzogMTI4LCBiOiAwfSxcblx0XHRsaW1lOiB7aGV4OiBcIiMwMEZGMDBcIiwgcjogMCwgZzogMjU1LCBiOiAwfSxcblx0XHRvbGl2ZToge2hleDogXCIjODA4MDAwXCIsIHI6IDEyOCwgZzogMTI4LCBiOiAwfSxcblx0XHR5ZWxsb3c6IHtoZXg6IFwiI0ZGRkYwMFwiLCByOiAyNTUsIGc6IDI1NSwgYjogMH0sXG5cdFx0bmF2eToge2hleDogXCIjMDAwMDgwXCIsIHI6IDAsIGc6IDAsIGI6IDEyOH0sXG5cdFx0Ymx1ZToge2hleDogXCIjMDAwMEZGXCIsIHI6IDAsIGc6IDAsIGI6IDI1NX0sXG5cdFx0dGVhbDoge2hleDogXCIjMDA4MDgwXCIsIHI6IDAsIGc6IDEyOCwgYjogMTI4fSxcblx0XHRhcXVhOiB7aGV4OiBcIiMwMEZGRkZcIiwgcjogMCwgZzogMjU1LCBiOiAyNTV9LFxufTtcblxuLy8gdGFrZSB0aGUgY3NzIGJveC1zaGFkb3cgcHJvcGVydHkgYW5kIHJldHVybiBpdHNcbi8vIGNvbXBvbmVudHMgKG9mZnNldC15LCBvZmZzZXQteCwgYmx1ciwgc3ByZWFkIGFuZCBjb2xvcilcbi8vIGlmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZCByZXR1cm4gYSBkZWZhdWx0XG5jb25zdCBfY3NzQm94U2hhZG93ID0gKGNzc1Byb3BWYWx1ZSkgPT57XG4gICAgaWYoIWNzc1Byb3BWYWx1ZSl7XG4gICAgICAgIHJldHVybiBbXCIwcHhcIiwgXCIwcHhcIiwgXCIwcHhcIiwgXCIwcHhcIiwgXCJyZ2JhKDAsIDAsIDAsIDEpXCJdO1xuICAgIH1cbiAgICBsZXQgW2ludFZhbHVlcywgcmdiYV0gPSBjc3NQcm9wVmFsdWUuc3BsaXQoXCIgcmdiYVwiKTtcbiAgICBsZXQgW2xlZnQsIHRvcCwgYmx1ciwgc3ByZWFkXSA9IGludFZhbHVlcy5zcGxpdChcIiBcIik7XG4gICAgcmV0dXJuIFtsZWZ0LCB0b3AsIGJsdXIsIHNwcmVhZCwgYHJnYmEke3JnYmF9YF07XG59XG5cbmV4cG9ydCB7XG4gICAgY3NzU3R5bGVyLFxuICAgIGNzc1N0eWxlciBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBBcmVhVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHdlYmNvbXBvbmVudCByZXByZXNlbnRhdGlvblxuICogb2YgYW4gQXJlYSwgd2hpY2ggaXMgYSBncm91cGluZyBvZlxuICogUGFydHMgdGhhdCBoYXZlIHNvbWUga2luZCBvZiBsYXlvdXRcbiAqIHNwZWNpZmllZFxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuICAgICAgICAgICAgICAgIDxzdHlsZT5cbiAgICAgICAgICAgICAgICAjYXJlYS13cmFwcGVyIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduLWNvbnRlbnQ6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyBcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLmNsaXAge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuOyAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC5hbGxvdy1zY3JvbGwge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiYXJlYS13cmFwcGVyXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuYDtcblxuY2xhc3MgQXJlYVZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmNsaXBwaW5nQ2hhbmdlZCA9IHRoaXMuY2xpcHBpbmdDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWxsb3dTY3JvbGxpbmdDaGFuZ2VkID0gdGhpcy5hbGxvd1Njcm9sbGluZ0NoYW5nZWQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBQcm9wIGNoYW5nZSBoYW5kbGVyc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY2xpcHBpbmcnLCB0aGlzLmNsaXBwaW5nQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdhbGxvdy1zY3JvbGxpbmcnLCB0aGlzLmFsbG93U2Nyb2xsaW5nQ2hhbmdlZCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICBsZXQgY2xpcHBpbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJjbGlwcGluZ1wiXG4gICAgICAgICk7XG4gICAgICAgIGxldCBhbGxvd1Njcm9sbGluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcImFsbG93LXNjcm9sbGluZ1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2xpcHBpbmdDaGFuZ2VkKGNsaXBwaW5nLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgdGhpcy5hbGxvd1Njcm9sbGluZ0NoYW5nZWQoYWxsb3dTY3JvbGxpbmcsIHRoaXMubW9kZWwuaWQpO1xuICAgIH1cblxuICAgIGNsaXBwaW5nQ2hhbmdlZChuZXdWYWwsIGlkKXtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdhcmVhLXdyYXBwZXInKTtcbiAgICAgICAgaWYobmV3VmFsID09IHRydWUpe1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdhbGxvdy1zY3JvbGwnKTtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnY2xpcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdjbGlwJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhbGxvd1Njcm9sbGluZ0NoYW5nZWQobmV3VmFsLCBpZCl7XG4gICAgICAgIGxldCB3cmFwcGVyID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYXJlYS13cmFwcGVyJyk7XG4gICAgICAgIGlmKG5ld1ZhbCA9PSB0cnVlKXtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnY2xpcCcpO1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdhbGxvdy1zY3JvbGwnKTtcbiAgICAgICAgICAgIC8vIHRoaXMuY2xhc3NMaXN0LmFkZCgnb3V0ZXItYWxsb3ctc2Nyb2xsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ291dGVyLWFsbG93LXNjcm9sbCcpO1xuICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdhbGxvdy1zY3JvbGwnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZENvbnRleHRNZW51SXRlbXMoY29udGV4dE1lbnUpe1xuICAgICAgICBjb250ZXh0TWVudS5hZGRTcGFjZXIoKTtcbiAgICAgICAgbGV0IGxheW91dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbGF5b3V0J1xuICAgICAgICApO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdsaXN0LWRpcmVjdGlvbidcbiAgICAgICAgKTtcbiAgICAgICAgaWYobGF5b3V0ICE9ICdsaXN0Jyl7XG4gICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICBcIlNldCBMYXlvdXQgdG8gTGlzdFwiLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xheW91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgXCJTZXQgTGF5b3V0IHRvIFN0cmljdFwiLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xheW91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaWN0J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZihkaXJlY3Rpb24gPT0gJ3Jvdycpe1xuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICBcIlNldCBMaXN0IERpcmVjdGlvbiB0byBDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGlzdC1kaXJlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2x1bW4nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiU2V0IExpc3QgRGlyZWN0aW9uIHRvIFJvd1wiLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0LWRpcmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JvdydcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBBcmVhVmlldyxcbiAgICBBcmVhVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuXG5jb25zdCBsaW5rSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1saW5rXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMCAxNGEzLjUgMy41IDAgMCAwIDUgMGw0IC00YTMuNSAzLjUgMCAwIDAgLTUgLTVsLS41IC41XCIgLz5cbiAgPHBhdGggZD1cIk0xNCAxMGEzLjUgMy41IDAgMCAwIC01IDBsLTQgNGEzLjUgMy41IDAgMCAwIDUgNWwuNSAtLjVcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbjpob3N0IHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBwYWRkaW5nOiAxcHg7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ud3JhcHBlcntcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxufVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XG4gICAgPGF1ZGlvPjwvYXVkaW8+XG4gICAgPHNwYW4gY2xhc3M9XCJuYW1lXCI+PC9zcGFuPlxuICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1tdXNpY1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgICA8Y2lyY2xlIGN4PVwiNlwiIGN5PVwiMTdcIiByPVwiM1wiPjwvY2lyY2xlPlxuICAgIDxjaXJjbGUgY3g9XCIxNlwiIGN5PVwiMTdcIiByPVwiM1wiPjwvY2lyY2xlPlxuICAgIDxwb2x5bGluZSBwb2ludHM9XCI5IDE3IDkgNCAxOSA0IDE5IDE3XCI+PC9wb2x5bGluZT5cbiAgICA8bGluZSB4MT1cIjlcIiB5MT1cIjhcIiB4Mj1cIjE5XCIgeTI9XCI4XCI+PC9saW5lPlxuICAgIDwvc3ZnPlxuPC9kaXY+XG5gO1xuXG4vLyBIVE1MTWVkaWFFbGVtZW50U3RhdGVzIGNvcGllZCBmcm9tXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9yZWFkeVN0YXRlXG5jb25zdCBtZWRpYVN0YXRlcyA9IHtcbiAgICAwOiBcIkhBVkVfTk9USElOR1wiLFxuICAgIDE6IFwiSEFWRV9NRVRBREFUQVwiLFxuICAgIDI6IFwiSEFWRV9DVVJSRU5UX0RBVEFcIixcbiAgICAzOiBcIkhBVkVfRlVUVVJFX0RBVEFcIixcbiAgICA0OiBcIkhBVkVfRU5PVUdIX0RBVEFcIlxufTtcblxuY2xhc3MgQXVkaW9WaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyBkb21cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdWRpb0xpbmsgPSB0aGlzLnVwZGF0ZUF1ZGlvTGluay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBsYXkgPSB0aGlzLnBsYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXVzZSA9IHRoaXMucGF1c2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICBsZXQgYXVkaW8gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKTtcbiAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0ZUNvZGUgPSBhdWRpby5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgXCJyZWFkeVN0YXRlXCIsXG4gICAgICAgICAgICAgICAgbWVkaWFTdGF0ZXNbc3RhdGVDb2RlXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIXRoaXMuaGFsb0J1dHRvbil7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgbGV0IG5hbWVTcGFuID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIik7XG4gICAgICAgIG5hbWVTcGFuLmlubmVyVGV4dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcIm5hbWVcIik7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcInJlYWR5U3RhdGVcIixcbiAgICAgICAgICAgXCJIQVZFX05PVEhJTkdcIlxuICAgICAgICApO1xuICAgICAgICBsZXQgYXVkaW8gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKTtcbiAgICAgICAgbGV0IHNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInNyY1wiKTtcbiAgICAgICAgaWYoc3JjKXtcbiAgICAgICAgICAgIGF1ZGlvLnNyYyA9IHNyYztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJuYW1lXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbmFtZVNwYW4uaW5uZXJUZXh0ID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcInJlYWR5U3RhdGVcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBsZXQgYm9yZGVyQ29sb3IgPSBcInJlZFwiO1xuICAgICAgICAgICAgaWYodmFsdWUgPT0gXCJIQVZFX0ZVVFVSRV9EQVRBXCIgfHwgdmFsdWUgPT0gXCJIQVZFX0VOT1VHSF9EQVRBXCIpe1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yID0gXCJncmVlblwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFtcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiXS5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIGBib3JkZXItJHtzaWRlfS1jb2xvcmAsIGJvcmRlckNvbG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJwbGF5XCIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYodmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwic3RvcFwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgICBhdWRpby5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcInNyY1wiLCAodXJsKSA9PiB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgLy8gcmVzb3VyY2UgbG9hZCBpcyBhdXRvLWxvYWRlZCBieSB0aGUgPGF1ZGlvPiBlbGVtZW50XG4gICAgICAgICAgICAgICAgYXVkaW8uc3JjID0gdXJsO1xuICAgICAgICAgICAgfSBjYXRjaChlcnJvcil7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTXNnID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUmVzb3VyY2VOb3RGb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZVR5cGU6IFwiYXVkaW9cIixcbiAgICAgICAgICAgICAgICAgICAgcGFydElkOiB0aGlzLm1vZGVsLmlkLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiB7c291cmNlOiB1cmwsIHR5cGU6IFwidXJsXCJ9XG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe2Vycm9yTXNnfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBsYXkoKXtcbiAgICAgICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIHJlc291cmNlIGlzIHJlYWR5XG4gICAgICAgIGxldCBhdWRpbyA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpO1xuICAgICAgICBsZXQgcmVhZHlTdGF0ZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJlYWR5U3RhdGVcIik7XG4gICAgICAgIGlmKHJlYWR5U3RhdGUgPT0gXCJIQVZFX0ZVVFVSRV9EQVRBXCIgfHwgcmVhZHlTdGF0ZSA9PSBcIkhBVkVfRU5PVUdIX0RBVEFcIil7XG4gICAgICAgICAgICBhdWRpby5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChgYXVkaW8gaXMgbm90IHJlYWR5OyBjdXJyZW50IHN0YXRlOiAke3JlYWR5U3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXVzZSgpe1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKS5wYXVzZSgpO1xuICAgIH1cblxuICAgIC8vIHJlLWxvYWRzIHRoZSBtZWRpYSwgc2V0dGluZyBpdCBiYWNrIHRvIHRoZSBiZWdnbmluZ1xuICAgIHN0b3AoKXtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiYXVkaW9cIikubG9hZCgpO1xuICAgIH1cblxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCl7XG4gICAgICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIHRoZSBvbiBjbGljayBtZXNzYWdlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmhhc09wZW5IYWxvKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5IYWxvKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKCF0aGlzLmhhc09wZW5IYWxvKXtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBjbGljayBjb21tYW5kIG1lc3NhZ2UgdG8gc2VsZlxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlIC8vIFNob3VsZCBpZ25vcmUgaWYgU3lzdGVtIEROVVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9CdXR0b24pO1xuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9uKCl7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaWQgPSAnaGFsby1hdWRpby1saW5rJztcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBsaW5rSWNvbjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnN0eWxlLm1hcmdpblRvcCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAncmlnaHQtY29sdW1uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0VkaXQgbGluayBmb3IgYXVkaW8gc291cmNlJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudXBkYXRlQXVkaW9MaW5rKTtcbiAgICB9XG5cbiAgICB1cGRhdGVBdWRpb0xpbmsoZXZlbnQpe1xuICAgICAgICAvLyBUZWxscyB0aGUgbW9kZWwgdG8gdXBkYXRlIGl0c1xuICAgICAgICAvLyBzcmMgbGluayBmb3IgdGhlIGF1ZGlvXG4gICAgICAgIGxldCBjdXJyZW50U3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdzcmMnXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZXN1bHQgPSB3aW5kb3cucHJvbXB0KFwiRWRpdCBVUkwgZm9yIGF1ZGlvOlwiLCBjdXJyZW50U3JjKTtcbiAgICAgICAgaWYocmVzdWx0ICYmIHJlc3VsdCAhPT0gJycgJiYgcmVzdWx0ICE9PSBjdXJyZW50U3JjKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbG9hZEF1ZGlvRnJvbVNvdXJjZScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsgcmVzdWx0IF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcblxuZXhwb3J0IHtcbiAgICBBdWRpb1ZpZXcsXG4gICAgQXVkaW9WaWV3IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IGxpbmtJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxpbmtcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEwIDE0YTMuNSAzLjUgMCAwIDAgNSAwbDQgLTRhMy41IDMuNSAwIDAgMCAtNSAtNWwtLjUgLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDEwYTMuNSAzLjUgMCAwIDAgLTUgMGwtNCA0YTMuNSAzLjUgMCAwIDAgNSA1bC41IC0uNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuOmhvc3Qge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHBhZGRpbmc6IDFweDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG5pZnJhbWUge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cbjwvc3R5bGU+XG48aWZyYW1lIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT5cbmA7XG5cbmNsYXNzIEJyb3dzZXJWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyBkb21cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVCcm93c2VyTGluayA9IHRoaXMudXBkYXRlQnJvd3NlckxpbmsuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICBsZXQgaWZyYW1lID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiaWZyYW1lXCIpO1xuICAgICAgICBsZXQgc3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwic3JjXCIpO1xuICAgICAgICBpZihzcmMpe1xuICAgICAgICAgICAgaWZyYW1lLnNyYyA9IHNyYztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcInNyY1wiLCAodXJsKSA9PiB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgLy8gcmVzb3VyY2UgbG9hZCBpcyBhdXRvLWxvYWRlZCBieSB0aGUgPGJyb3dzZXI+IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZnJhbWUuc3JjID0gdXJsO1xuICAgICAgICAgICAgfSBjYXRjaChlcnJvcil7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTXNnID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUmVzb3VyY2VOb3RGb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZVR5cGU6IFwiYnJvd3NlclwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IHRoaXMubW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtzb3VyY2U6IHVybCwgdHlwZTogXCJ1cmxcIn1cblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7ZXJyb3JNc2d9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgdGhlIG9uIGNsaWNrIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNsaWNrIGNvbW1hbmQgbWVzc2FnZSB0byBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b24oKXtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pZCA9ICdoYWxvLWJyb3dzZXItbGluayc7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaW5uZXJIVE1MID0gbGlua0ljb247XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zdHlsZS5tYXJnaW5Ub3AgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ3JpZ2h0LWNvbHVtbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdFZGl0IGxpbmsgZm9yIGJyb3dzZXIgc291cmNlJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudXBkYXRlQnJvd3NlckxpbmspO1xuICAgIH1cblxuICAgIHVwZGF0ZUJyb3dzZXJMaW5rKGV2ZW50KXtcbiAgICAgICAgLy8gVGVsbHMgdGhlIG1vZGVsIHRvIHVwZGF0ZSBpdHNcbiAgICAgICAgLy8gc3JjIGxpbmsgZm9yIHRoZSBicm93c2VyXG4gICAgICAgIGxldCBjdXJyZW50U3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdzcmMnXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZXN1bHQgPSB3aW5kb3cucHJvbXB0KFwiRWRpdCBVUkwgZm9yIGJyb3dzZXI6XCIsIGN1cnJlbnRTcmMpO1xuICAgICAgICBpZihyZXN1bHQgJiYgcmVzdWx0ICE9PSAnJyAmJiByZXN1bHQgIT09IGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdzZXRVUkxUbycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsgcmVzdWx0IF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcblxuZXhwb3J0IHtcbiAgICBCcm93c2VyVmlldyxcbiAgICBCcm93c2VyVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBCdXR0b25WaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSB3ZWJjb21wb25lbnQgcmVwcmVzZW50aW5nIGEgQnV0dG9uLlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuICAgICAgICAgICAgICAgIDxzdHlsZT5cbiAgICAgICAgICAgICAgICAgLnN0LWJ1dHRvbi1sYWJlbCB7XG4gICAgICAgICAgICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICAgICAgICAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA5NSU7XG4gICAgICAgICAgICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0LWJ1dHRvbi1sYWJlbFwiPlxuICAgICAgICAgICAgICAgICAgICA8c2xvdD48L3Nsb3Q+PCEtLSBUZXh0IG9mIHRoZSBOYW1lIC0tPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbmA7XG5cbmNsYXNzIEJ1dHRvblZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMgPSB0aGlzLnNldHVwUHJvcEhhbmRsZXJzLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0dXAgcHJvcCBjaGFuZ2UgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCduYW1lJywgKHZhbHVlLCBwYXJ0SWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJUZXh0ID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIGxldCBidXR0b25OYW1lID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwibmFtZVwiKTtcbiAgICAgICAgaWYoYnV0dG9uTmFtZSl7XG4gICAgICAgICAgICB0aGlzLmlubmVyVGV4dCA9IGJ1dHRvbk5hbWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGJhc2UgY2xhc3MgaW1wbGVtZW50YXRpb25cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDApe1xuICAgICAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgICAgIHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZighdGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgY2xpY2sgY29tbWFuZCBtZXNzYWdlIHRvIHNlbGZcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE92ZXJ3cml0aW5nIHRoZSBiYXNlIGNsYXNzIG9wZW4vY2xvc2UgZWRpdG9yIG1ldGhvZHNcbiAgICBvcGVuRWRpdG9yKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0ub3BlbkVkaXRvckZvclBhcnQodGhpcy5tb2RlbC5pZCk7XG4gICAgfVxuXG4gICAgY2xvc2VFZGl0b3IoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5jbG9zZUVkaXRvckZvclBhcnQodGhpcy5tb2RlbC5pZCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBCdXR0b25WaWV3LFxuICAgIEJ1dHRvblZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQ2FyZFZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgd2ViY29tcG9uZW50IHJlcHJlc2VudGF0aW9uIG9mIGEgQ2FyZC5cbiAqL1xuXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuICAgICAgICAgICAgICAgIDxzdHlsZT5cbiAgICAgICAgICAgICAgICA8L3N0eWxlPlxuICAgICAgICAgICAgICAgIDxzbG90Pjwvc2xvdD5cbmA7XG5cbmNsYXNzIENhcmRWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEhhbG8gc2V0dGluZ3MuIENhcmRzIGRvbid0IHdhbnRcbiAgICAgICAgLy9hIGhhbG8gdG8gb3BlblxuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgY2xhc3MgbWV0aG9kXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwICYmIGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZENvbnRleHRNZW51SXRlbXMoY29udGV4dE1lbnUpe1xuICAgICAgICBjb250ZXh0TWVudS5hZGRTcGFjZXIoKTtcbiAgICAgICAgLy8gVG9vbGJveCB0b2dnbGUgaGlkZS91bmhpZGVcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHdpbmRvdy5TeXN0ZW0uZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTtcbiAgICAgICAgbGV0IHRvb2xib3ggPSBjdXJyZW50U3RhY2suc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChwYXJ0LCBcIm5hbWVcIik7XG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PSBcIlRvb2xib3hcIjtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHRvb2xib3ggYXQgYWxsLCB0aGF0J3Mgd2VpcmQgYnV0IGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmKHRvb2xib3gpe1xuICAgICAgICAgICAgbGV0IGhpZGRlbiA9IHRvb2xib3gucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0b29sYm94LCBcImhpZGVcIik7XG4gICAgICAgICAgICBpZihoaWRkZW4pe1xuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICBcIlVuaGlkZSBUb29sYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbGJveC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRvb2xib3gsIFwiaGlkZVwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgXCJIaWRlIFRvb2xib3hcIixcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sYm94LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodG9vbGJveCwgXCJoaWRlXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQ2FyZFZpZXcsXG4gICAgQ2FyZFZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogRmllbGRWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gdGhlIHZpZXcgb2YgYW4gRmllbGQgcGFydC5cbiAqIEkgYW0gYW4gXCJpbnRlcmltXCIgdmlldyBpbnRlbmRlZCB0byBkaXNwbGF5XG4gKiBhbmQgZWRpdCBwbGFpbiB0ZXh0IG9uIGEgQ2FyZC5cbiAqIEkgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggYSBtb3JlIGNvbXByZWhlbnNpdmVcbiAqIGltcGxlbWVudGF0aW9uIG9mIEZpZWxkL0ZpZWxkVmlldyBpbiB0aGUgZnV0dXJlLlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5pbXBvcnQgY3NzU3R5bGVyIGZyb20gJy4uL3V0aWxzLy9zdHlsZXIuanMnO1xuaW1wb3J0IENvbG9yV2hlZWxXaWRnZXQgZnJvbSAnLi9kcmF3aW5nL0NvbG9yV2hlZWxXaWRnZXQuanMnO1xuaW1wb3J0IGludGVycHJldGVyU2VtYW50aWNzIGZyb20gJy4uLy4uL29obS9pbnRlcnByZXRlci1zZW1hbnRpY3MuanMnO1xuaW1wb3J0IGNyZWF0ZUhpZ2hsaWdodGVyIGZyb20gJy4uL3V0aWxzL0FsdFN5bnRheEhpZ2hsaWdodGVyLmpzJztcblxuY29uc3QgaGFsb0VkaXRCdXR0b25TVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItdG9vbHNcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTMgMjFoNGwxMyAtMTNhMS41IDEuNSAwIDAgMCAtNCAtNGwtMTMgMTN2NFwiIC8+XG4gIDxsaW5lIHgxPVwiMTQuNVwiIHkxPVwiNS41XCIgeDI9XCIxOC41XCIgeTI9XCI5LjVcIiAvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiMTIgOCA3IDMgMyA3IDggMTJcIiAvPlxuICA8bGluZSB4MT1cIjdcIiB5MT1cIjhcIiB4Mj1cIjUuNVwiIHkyPVwiOS41XCIgLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjE2IDEyIDIxIDE3IDE3IDIxIDEyIDE2XCIgLz5cbiAgPGxpbmUgeDE9XCIxNlwiIHkxPVwiMTdcIiB4Mj1cIjE0LjVcIiB5Mj1cIjE4LjVcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBoYWxvTG9ja0J1dHRvblNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1sb2NrXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8cmVjdCB4PVwiNVwiIHk9XCIxMVwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMlwiPjwvcmVjdD5cbiAgIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTZcIiByPVwiMVwiPjwvY2lyY2xlPlxuICAgPHBhdGggZD1cIk04IDExdi00YTQgNCAwIDAgMSA4IDB2NFwiPjwvcGF0aD5cbjwvc3ZnPlxuYDtcblxuY29uc3QgaGFsb1VubG9ja0J1dHRvblNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1sb2NrLW9wZW5cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxyZWN0IHg9XCI1XCIgeT1cIjExXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjEwXCIgcng9XCIyXCI+PC9yZWN0PlxuICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxNlwiIHI9XCIxXCI+PC9jaXJjbGU+XG4gICA8cGF0aCBkPVwiTTggMTF2LTVhNCA0IDAgMCAxIDggMFwiPjwvcGF0aD5cbjwvc3ZnPlxuYDtcblxuY29uc3QgZmllbGRUZW1wbGF0ZVN0cmluZyA9IGBcbiAgICAgIDxzdHlsZT5cbiAgICAgICAgLmZpZWxkIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgIH1cblxuICAgICAgICAuZmllbGQgY29sb3Itd2hlZWwge1xuICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLmZpZWxkLXRleHRhcmVhIHtcbiAgICAgICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSA1cHgpO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gICAgICAgICAgICBvdmVyZmxvdy13cmFwOiBhbnl3aGVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFN5bnRheCBIaWdobGlnaHRpbmdcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnNwYW5bZGF0YS1zdC1ydWxlPVwibWVzc2FnZU5hbWVcIl17XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG59XG5cbnNwYW5bZGF0YS1zdC1ydWxlPVwia2V5d29yZFwiXXtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbn1cblxuc3BhbltkYXRhLXN0LXJ1bGU9XCJQYXJhbWV0ZXJMaXN0LWl0ZW1cIl17XG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgIGNvbG9yOiBncmV5O1xufVxuXG5cbiAgICA8L3N0eWxlPlxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQtdGV4dGFyZWFcIiBzcGVsbGNoZWNrPVwiZmFsc2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5gO1xuXG5cbmZ1bmN0aW9uIGZvcm1hdERvYyhzQ21kLCBzVmFsdWUpIHtcbiAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoc0NtZCwgZmFsc2UsIHNWYWx1ZSk7IG9Eb2MuZm9jdXMoKTtcbn1cblxuY2xhc3MgRmllbGRWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gdGhpcy5lZGl0b3JDb21wbGV0ZXIgPSB0aGlzLnNpbXBsZVRhbGtDb21wbGV0ZXI7XG4gICAgICAgIHRoaXMudGV4dFN0eWxlciA9IGNzc1N0eWxlcjsgIC8vIHdlIG1pZ2h0IHdhbnQgdG8gY29uc2lkZXIgYSBtb3JlIHByb2dyYW1tYXRpYyB3YXkgdG8gc2V0IHRoaXNcbiAgICAgICAgdGhpcy5lZGl0b3JDb21wbGV0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51T3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZXMgPSB7fTtcbiAgICAgICAgdGhpcy53YW50c0NvbnRleHRNZW51ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gUHJlc2V0cyBmb3Igc3ludGF4IGhpZ2hsaWdodGluZy5cbiAgICAgICAgLy8gV2hlbiBoaWdobGlnaHRpbmcgaXMgZW5hYmxlZCwgd2Ugd2lsbCBjaGVja1xuICAgICAgICAvLyBlYWNoIGxpbmUgb2YgdGhlIHRleHQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gZ3JhbW1hdGljYWwgcnVsZXM6XG4gICAgICAgIHRoaXMuX3N5bnRheFJ1bGVzID0gW1xuICAgICAgICAgICAgXCJNZXNzYWdlSGFuZGxlck9wZW5cIixcbiAgICAgICAgICAgIFwiTWVzc2FnZUhhbmRsZXJDbG9zZVwiXG4gICAgICAgIF07XG5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gZmllbGRUZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbklucHV0ID0gdGhpcy5vbklucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25CZWZvcmVJbnB1dCA9IHRoaXMub25CZWZvcmVJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbktleWRvd24gPSB0aGlzLm9uS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2Vkb3duID0gdGhpcy5vbk1vdXNlZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW5Db250ZXh0TWVudSA9IHRoaXMub3BlbkNvbnRleHRNZW51LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSA9IHRoaXMuY2xvc2VDb250ZXh0TWVudS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvSXQgPSB0aGlzLmRvSXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb24gPSB0aGlzLmhhbmRsZVNlbGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW5GaWVsZCA9IHRoaXMub3BlbkZpZWxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dFRvSHRtbCA9IHRoaXMudGV4dFRvSHRtbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNpbXBsZVRhbGtDb21wbGV0ZXIgPSB0aGlzLnNpbXBsZVRhbGtDb21wbGV0ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbnMgPSB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9ucy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluc2VydFJhbmdlID0gdGhpcy5pbnNlcnRSYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFJhbmdlSW5UYXJnZXQgPSB0aGlzLnNldFJhbmdlSW5UYXJnZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24gPSB0aGlzLnNldFNlbGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodFN5bnRheCA9IHRoaXMuaGlnaGxpZ2h0U3ludGF4LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudW5oaWdobGlnaHRTeW50YXggPSB0aGlzLnVuaGlnaGxpZ2h0U3ludGF4LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdlZGl0YWJsZScsICh2YWx1ZSwgaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5oYWxvTG9ja1VubG9ja0J1dHRvbiA9IHRoaXMuaGFsb0xvY2tCdXR0b247XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKFwiZWRpdGFibGVcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5oYWxvTG9ja1VubG9ja0J1dHRvbiA9IHRoaXMuaGFsb1VubG9ja0J1dHRvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vICd0ZXh0JyBpcyBhIER5bmFtaWNQcm9wIHdob3NlIHNldHRlciB3aWxsIHNldCB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAvLyB2YWx1ZSBmb3IgYGlubmVySFRNTGAuIFRoaXMgd2F5IHdlIGNhbiBoYXZlIHByb2dyYW1tYXRpYyBjb250ZW50XG4gICAgICAgIC8vIHNldHRpbmcgYW5kIHN0aWxsIGFsbG93IHRvIG5vdCBsb29zZSBtYXJrdXAuXG4gICAgICAgIC8vICdpbm5lckhUTUwnIGlzIGEgQmFzaWNQcm9wLiBTZWUgaG93IHRoZXNlIGFyZSBzZXQsIHdpdGhvdXRcbiAgICAgICAgLy8gbm90aWZpY2F0aW9uIGluIHRoaXMub25JbnB1dCgpXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdpbm5lckhUTUwnLCAodmFsdWUsIGlkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5pbm5lclRleHQsXG4gICAgICAgICAgICAgICAgZmFsc2UgLy8gZG8gbm90IG5vdGlmeSwgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgLy8gVGhlIGV2ZW50cyBoZXJlIGFyZSBhZGRlZCB2aWEgdGhlIC5hZGRFdmVudExpc3RlbmVyKCkgQVBJIHdoaWNoIGlzXG4gICAgICAgIC8vIGRpc3RpbmN0IGZyb20gdGhlIHRoaXMuZXZlbnRSZXNwb25kKCkgd2hpY2ggdXNlcyB0aGUgRE9NIGVsZW1lbnRcbiAgICAgICAgLy8gZWxlbWVudC5vbkV2ZW50IEFQSS4gVGhpcyBhbGxvd3MgdXMgdG8gZGlzdG5ndWlzaCBiZXR3ZWVuIFwiY29yZVwiXG4gICAgICAgIC8vIHN5c3RlbS13ZWIgZXZlbnRzIHRoYXQgd2UgZG9uJ3Qgd2FudCBtZWRkbGVkIHdpdGggYXQgdGhlIG1vbWVudCwgbGlrZVxuICAgICAgICAvLyBlbnRlcmluZyB0ZXh0IGluIGEgZmllbGQsIGFuZCBvbmVzIGV4cG9zZWQgaW4gdGhlIGVudmlyb25lbW50IGZvciBzY3JpcHRpbmdcbiAgICAgICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmZpZWxkLXRleHRhcmVhJyk7XG5cbiAgICAgICAgdGhpcy50ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25JbnB1dCk7XG4gICAgICAgIC8vdGhpcy50ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIHRoaXMub25CZWZvcmVJbnB1dCk7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlkb3duKTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgYSBjbGljayBsaXN0ZW5lciBhcyB0aGUgYmFzZSBQYXJ0VmlldyBjbGFzcyBkb2VzIHRoYXRcblxuICAgICAgICAvLyBpbiBvcmRlciB0byBkZWFsIHdpdGggcmFuZ2UgaW5zZXJ0aW9ucyAoZm9yIHN0eWxpbmcgdGV4dCBmcmFnbWVudHMgd2l0aGluXG4gICAgICAgIC8vIHRoZSB0ZXh0YXJlYSksIHdlIG5lZWQgdG8gaGF2ZSB0aGUgZGVmYXVsdCBwYXJhZ3JhcGggdGFnID0gPC9icj4uIE90aGVyd2lzZVxuICAgICAgICAvLyB0aGUgaW5zZXJ0IG5ldyBsaW5lIGlzIG9mIHRoZSBmb3JtIDxkaXY+PC9icj48ZGl2PiB3aGljaCBjYXVzZXMgdGhlIGFwcGVhcmFuY2VcbiAgICAgICAgLy8gb2YgbmV3bGluZXMgd2hlbiBub2RlcyBhcmUgaW5zZXJ0ZWQgaW50byBhIHJhbmdlXG4gICAgICAgIC8vZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJkZWZhdWx0UGFyYWdyYXBoU2VwYXJhdG9yXCIsIGZhbHNlLCBcInN0LWxpbmVcIik7XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25JbnB1dCk7XG4gICAgICAgIC8vdGhpcy50ZXh0YXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIHRoaXMub25CZWZvcmVJbnB1dCk7XG4gICAgICAgIHRoaXMudGV4dGFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlkb3duKTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC10ZXh0YXJlYScpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbW9kZWwsIHNldCB0aGUgdmFsdWUgb2YgdGhlIHRleHRhcmVhXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGh0bWwgb2YgdGhlIGZpZWxkIG1vZGVsXG4gICAgICAgIGxldCBpbm5lckhUTUwgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2lubmVySFRNTCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG5cbiAgICAgICAgbGV0IGlzRWRpdGFibGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIGlzRWRpdGFibGUpO1xuXG4gICAgICAgIC8vIHNldHVwIHRoZSBsb2NrL3VubG9jayBoYWxvIGJ1dHRvblxuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9ucygpO1xuICAgICAgICBsZXQgZWRpdGFibGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2VkaXRhYmxlJ1xuICAgICAgICApO1xuICAgICAgICBpZihlZGl0YWJsZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICB0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uID0gdGhpcy5oYWxvTG9ja0J1dHRvbjtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChcImVkaXRhYmxlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRhYmxlID09PSBmYWxzZSl7XG4gICAgICAgICAgICB0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uID0gdGhpcy5oYWxvVW5sb2NrQnV0dG9uO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFwiZWRpdGFibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaW1wbGVUYWxrQ29tcGxldGVyKGVsZW1lbnQpe1xuICAgICAgICBsZXQgdGV4dENvbnRlbnQgPSB0aGlzLmh0bWxUb1RleHQoZWxlbWVudCk7XG4gICAgICAgIGxldCBzdGFydE9mSGFuZGxlclJlZ2V4ID0gL15vblxccyhcXHcrKShcXHN8XFxuKSskLztcbiAgICAgICAgbGV0IG1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2goc3RhcnRPZkhhbmRsZXJSZWdleCk7XG4gICAgICAgIGlmKG1hdGNoKXtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlTmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgLy8gaWYgaW5wdXQgYnJlYWsgaXMgYSBuZXcgbGluZSB0aGVuIGFuIGV4dHJhXG4gICAgICAgICAgICAvLyA8ZGl2PjwvYnI+PC9kaXY+IGhhcyBiZWVkIGFkZGVkIGludG8gdGhlIGVsZW1lbiBhbHJlYWR5XG4gICAgICAgICAgICBsZXQgdGFiTGluZSA9IFwiXFx0XFxuXCI7XG4gICAgICAgICAgICBpZihtYXRjaFsyXSA9PT0gXCJcXG5cIil7XG4gICAgICAgICAgICAgICAgdGFiTGluZT0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRDb250ZW50ID0gYCR7dGFiTGluZX1lbmQgJHttZXNzYWdlTmFtZX1gO1xuICAgICAgICAgICAgbGV0IGlubmVySFRNTCA9IHRoaXMudGV4dFRvSHRtbCh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICBlbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBpbm5lckhUTUwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LmlubmVySFRNTDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEkgb3ZlcnJpZGUgbXkgYmFzZS1jbGFzcydzIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0YXJnZXQgcmVsYXRlZCBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgc3R5bGVUZXh0Q1NTKCl7XG4gICAgICAgIGxldCB0ZXh0YXJlYSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmZpZWxkLXRleHRhcmVhJyk7XG4gICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcImNzc1RleHRTdHlsZVwiKTtcbiAgICAgICAgT2JqZWN0LmtleXMoY3NzU3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY3NzU3R5bGVba2V5XTtcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGFyZ2V0IGFuZCByYW5nZSBzZXQgdGhlbiBzZW5kIHRoZSB0YXJnZXQgYW4gdXBkYXRlIG1lc3NhZ2VcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCAndGFyZ2V0Jyk7XG4gICAgICAgIGlmKHRhcmdldCl7XG4gICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5UYXJnZXQodGFyZ2V0LCB0aGlzLnRleHRhcmVhLmlubmVySFRNTCwgY3NzU3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBzZXQgYSB0ZXh0LSogcHJvcGVydHkgb24gc2VsZWN0aW9uIHRvIHN0eWxlIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICogTm90ZTogdGhpcyBpcyBkb25lIGZvciBldmVyeSBjdXJyZW50IHNlbGVjdGlvbiwgaS5lLiBldmVydGhpbmdcbiAgICAgKiBpbiB0aGlzLnNlbGVjdGlvblJhbmdlc1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvbihwcm9wTmFtZSwgdmFsdWUpe1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuc2VsZWN0aW9uUmFuZ2VzKS5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdHlsZSA9IHt9O1xuICAgICAgICAgICAgLy8gLy8gaWYgdGhlIGRvY3VtZW50IGZyYWdtZW50IGhhcyBvbmUgY2hpbGQgbm9kZSBhbmQgaXQncyBhIHNwYW5cbiAgICAgICAgICAgIC8vIC8vIHdlIHNob3VsZCBzdHlsZSB0aGF0IGRpcmVjdGx5LiBUaGlzIGF2b2lkcyB1bm5jZXNzYXJ5IERPTSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gLy8gYmVpbmcgY3JlYXRlZCB0byB3cmFwIHRoZSBjb250ZW50cywgc3VjaCBhcyB3aGVuIHN0eWxpbmcgaXMgY29udGludWFsbHlcbiAgICAgICAgICAgIC8vIC8vIGFwcGxpZWQgb3QgdGhlIHNhbWUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyBsZXQgc3BhbjtcbiAgICAgICAgICAgIC8vIGlmKGRvY0ZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgZG9jRnJhZ21lbnQuY2hpbGROb2Rlc1swXS5ub2RlTmFtZSA9PSBcIlNQQU5cIil7XG4gICAgICAgICAgICAvLyAgICAgc3BhbiA9IGRvY0ZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAvLyAgICAgLy8gTm90ZSB0aGUgdXNlIG9mIE9iZWpjdC52YWx1ZXMgaGVyZSBmb3IgdGhlIERPTSBzdHlsZSBhdHRyaWJ1dGUgb2JqZWN0XG4gICAgICAgICAgICAvLyAgICAgLy8gdGhhdCdzIHdlaXJkXG4gICAgICAgICAgICAvLyAgICAgT2JqZWN0LnZhbHVlcyhzcGFuLnN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY3VycmVudFN0eWxlW2tleV0gPSBzcGFuLnN0eWxlW2tleV07XG4gICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgc3BhbiBlbGVtZW50IHRvIHdyYXAgdGhlIGNvbnRlbnRzIGluIHN0eWxlXG4gICAgICAgICAgICAvLyAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIC8vICAgICAvLyBXaGlsZSB0ZW1wdGluZyB0byB1c2UgcmFuZ2Uuc3Vycm91bmRDb250ZW50cygpIGF2b2lkIHRoaXNcbiAgICAgICAgICAgIC8vICAgICAvLyBzaW5jZSBpdCB3aWxsIGZhaWwgd2l0aCBhIG5vbi1pbmZvcm1hdGl2ZSBlcnJvciBpZiB0aGUgcmFuZ2VcbiAgICAgICAgICAgIC8vICAgICAvLyBpbmNsdWRlcyBwYXJ0aWFsIG5vZGVzIChleCB0ZXh0IGFjcm9zcyB2YXJpb3VzIG5vZGVzKVxuICAgICAgICAgICAgLy8gICAgIHdoaWxlIChkb2NGcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCl7XG4gICAgICAgICAgICAvLyAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jRnJhZ21lbnQuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBsZXQgY3NzT2JqZWN0ID0gdGhpcy50ZXh0U3R5bGVyKGN1cnJlbnRTdHlsZSwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzc09iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zdHlsZVtrZXldID0gY3NzT2JqZWN0W2tleV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3Bhbi5hcHBlbmQocmFuZ2UuZXh0cmFjdENvbnRlbnRzKCkpO1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShzcGFuKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgZmFsc2UgLy8gZG8gbm90IG5vdGlmeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGFyZ2V0IGFuZCByYW5nZSBzZXQgdGhlbiBzZW5kIHRoZSB0YXJnZXQgYW4gdXBkYXRlIG1lc3NhZ2VcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgJ3RhcmdldCcpO1xuICAgICAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5UYXJnZXQodGFyZ2V0LCB0aGlzLnRleHRhcmVhLmlubmVySFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uQmVmb3JlSW5wdXQoZXZlbnQpe1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGVkUmFuZ2UuY2xvbmVSYW5nZSgpO1xuXG4gICAgICAgIGxldCBpbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MO1xuICAgICAgICBpZighaW5uZXJIVE1MLmVuZHNXaXRoKFwiPGRpdj48YnI+PC9kaXY+XCIpKXtcbiAgICAgICAgICAgIGlubmVySFRNTCArPSBcIjxkaXY+PGJyPjwvZGl2PlwiO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoZXZlbnQuaW5wdXRUeXBlID09IFwiaW5zZXJ0UGFyYWdyYXBoXCIpe1xuICAgICAgICAgICAgLy9ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGxldCBiciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gICAgICAgICAgICBsZXQgYnIyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoYnIpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShicjIpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihicjIpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoYnIyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSW5wdXQoZXZlbnQpe1xuICAgICAgICBsZXQgaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTDtcbiAgICAgICAgLypcbiAgICAgICAgaWYoIWlubmVySFRNTC5lbmRzV2l0aChcIjxicj5cIikpe1xuICAgICAgICAgICAgaW5uZXJIVE1MICs9IFwiPGJyPlwiO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgICAgIGlmKHRoaXMuZWRpdG9yQ29tcGxldGVyKXtcbiAgICAgICAgICAgIC8vIFRPRE8gc29ydCBvdXQgaG93IHRoaXMgd291bGQgd29ya1xuICAgICAgICAgICAgbGV0IGlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgICAgICBpbm5lckhUTUwgPSB0aGlzLmVkaXRvckNvbXBsZXRlcihldmVudC50YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lclRleHQsXG4gICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5LCB0byBwcmVzZXJ2ZSBjb250ZW50ZWRpdGFibGUgY29udGV4dFxuICAgICAgICApO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MLFxuICAgICAgICAgICAgZmFsc2UgLy8gZG8gbm90IG5vdGlmeVxuICAgICAgICApO1xuICAgICAgICAvLyBTaW5jZSB3ZSB1cGRhdGUgdGhlICd0ZXh0JyBwcm9wZXJ0eSB3aXRob3V0IG5vdGlmaWNhdGlvbiwgdGhlIHBhcnQvbW9kZWxcbiAgICAgICAgLy8gaXMgbm90IHNlbnQgdGhlIFwicHJvcGVydHlDaGFuZ2VkXCIgbWVzc2FnZSBzbyB3ZSBkbyBzbyBtYW51YWxseVxuICAgICAgICB0aGlzLm1vZGVsLnByb3BlcnR5Q2hhbmdlZChcInRleHRcIiwgZXZlbnQudGFyZ2V0LmlubmVyVGV4dCk7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGFyZ2V0IGFuZCByYW5nZSBzZXQgdGhlbiBzZW5kIHRoZSB0YXJnZXQgYW4gdXBkYXRlIG1lc3NhZ2VcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCAndGFyZ2V0Jyk7XG4gICAgICAgIGlmKHRhcmdldCl7XG4gICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5UYXJnZXQodGFyZ2V0LCBldmVudC50YXJnZXQuaW5uZXJIVE1MKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uS2V5ZG93bihldmVudCl7XG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGRlZmF1bHQgdGFiIGtleSB0byBsZWF2ZSBmb2N1cyBvbiB0aGUgZmllbGRcbiAgICAgICAgaWYoZXZlbnQua2V5PT09XCJUYWJcIil7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy9kb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0SFRNTCcsIGZhbHNlLCAnJiN4OScpO1xuICAgICAgICAgICAgbGV0IHNlbCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XG5cbiAgICAgICAgICAgIGxldCB0YWJOb2RlVmFsdWUgPSAnXFx0JztcbiAgICAgICAgICAgIGxldCB0YWJOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGFiTm9kZVZhbHVlKTtcblxuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZSh0YWJOb2RlKTtcblxuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcih0YWJOb2RlKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKHRhYk5vZGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG9uTW91c2Vkb3duKGV2ZW50KXtcbiAgICAgICAgLy8gY2xlYXIgYWxsIHNlbGVjdGlvbnNcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZXMgPSB7fTtcbiAgICB9XG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCl7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc2hpZnQga2V5IGlzIHByZXNzZWQgd2UgdG9nZ2xlIHRoZSBoYWxvXG4gICAgICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gdGV4dCBpcyBzZWxlY3RlZCB3ZSBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgaWYodGV4dCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbHRLZXkgaXMgcHJlc3NlZCB3ZSBvcGVuIHRoZSBjb250ZXh0IChcImRvIGl0XCIpIG1lbnVcbiAgICAgICAgICAgICAgICAgICAgaWYoZXZlbnQuYWx0S2V5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmNvbnRleHRNZW51T3Blbil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0aW9uKGV2ZW50Lm1ldGFLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG5vIGNvbnRleHQgbWVudSBpcyBvcGVuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29udGV4dE1lbnVPcGVuKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGFsbCB0aGUgc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIEkgaGFuZGxlIHNlbGVjdGVkIHRleHQsIGNyZWF0aW5nIGEgbmV3IGZpZWxkIG1vZGVsL3ZpZXdcbiAgICAgKiBmb3IgZXZlcnkgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiwga2VlcGluZyB0cmFjayBvZiBldmVyeSByYW5nZVxuICAgICAqIGluIHRoaXMuc2VsZWN0aW9uIE9iamVjdC9kaWN0IHNvIHRoYXQgbW9kaWZpY2F0aW9uIGNhbiBiZSBpbnNlcnRlZFxuICAgICAqIGJhY2sgaW50byB0aGUgY29ycmVzcG9uZGluZyByYW5nZXMuXG4gICAgICovXG4gICAgaGFuZGxlU2VsZWN0aW9uKG9wZW5OZXdGaWVsZCl7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpIDwgc2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkrKyl7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhpcyBpcyBub3QgYSBjb250aW51aW5nIHNlbGVjdGlvblxuICAgICAgICAgICAgLy8gYW5kIHRoYXQgdGhlIHJhbmdlIGlzIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRSYW5nZXMgPSBPYmplY3QudmFsdWVzKHRoaXMuc2VsZWN0aW9uUmFuZ2VzKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRSYW5nZXMuaW5kZXhPZihyYW5nZSkgPj0gMCl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBnZW5lcmF0ZSBvdXIgb3duIHJhbmdlIGlkcywgc2luY2Ugd2Ugd2FudCB0aGlzIHRvIGNvcnJlc3BvbmQgdG9cbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBvcmRlciB3aGljaCBpcyBub3QgcmVzcGVjdGVkIGJ5IHRoZSBicm93c2VyIHNlbGVjdGlvbiBvYmplY3RcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB3ZSBkb24ndCBoaXQgb24gb3RoZXIgdmlld3MnIHJhbmdlcyBieSBhY2NpZGVudCB3ZSBuZWVkIHVuaXF1ZSBpZCdzXG4gICAgICAgICAgICBsZXQgcmFuZ2VJZCA9IERhdGUubm93KCk7IC8vVE9ETyB3ZSBuZWVkIGEgYmV0dGVyIHJhbmRvbSBpZFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZXNbcmFuZ2VJZF0gPSByYW5nZTtcbiAgICAgICAgICAgIGlmKG9wZW5OZXdGaWVsZCl7XG4gICAgICAgICAgICAgICAgLy8gb3BlbiBhIGZpZWxkIGZvciBlYWNoIG5ldyBzZWxlY3Rpb24gYW5kIHBvcHVsYXRlIGl0IHdpdGggdGhlIHJhbmdlIGh0bWxcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5GaWVsZChyYW5nZSwgcmFuZ2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuRmllbGQocmFuZ2UsIHJhbmdlSWQpe1xuICAgICAgICAvLyBjcmVhdGUgYW4gSFRNTCBkb2N1bWVudCBmcmFnbWVudCBmcm9tIHRoZSByYW5nZSB0byBhdm9pZCBkZWFsaW5nIHdpaHQgc3RhcnQvZW5kXG4gICAgICAgIC8vIGFuZCBvZmZzZXQgY2FsY3VsYXRpb25zXG4gICAgICAgIC8vIGZyYWdtZW50cyBkb24ndCBoYXZlIHRoZSBmdWxsIGh0bWwgRE9NIGVsZW1lbnQgQVBJIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChyYW5nZS5jbG9uZUNvbnRlbnRzKCkpO1xuXG4gICAgICAgIC8vIFRPRE8gdGhlc2Ugc2hvdWxkIGFsbCBiZSBtZXNzYWdlcyBhbmQgY29ycmVzcG5kaW5nIGNvbW1hbmQgaGFuZGxlciBkZWZpbml0aW9uc1xuICAgICAgICAvLyBzaG91bGQgYmUgcGFydCBvZiB0aGUgZmllbGQncyBvd24gc2NyaXB0XG4gICAgICAgIGxldCBmaWVsZE1vZGVsID0gd2luZG93LlN5c3RlbS5uZXdNb2RlbChcImZpZWxkXCIsIHRoaXMubW9kZWwuX293bmVyLmlkLCBgc2VsZWN0aW9uICR7cmFuZ2VJZH1gKTtcbiAgICAgICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGZpZWxkTW9kZWwsIFwiaW5uZXJIVE1MXCIsIHNwYW4uaW5uZXJIVE1MKTtcbiAgICAgICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGZpZWxkTW9kZWwsIFwidGFyZ2V0XCIsIGBmaWVsZCBpZCAke3RoaXMubW9kZWwuaWR9YCk7XG4gICAgICAgIGZpZWxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChmaWVsZE1vZGVsLCBcInRhcmdldFJhbmdlSWRcIiwgcmFuZ2VJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIEdpdmVuIGEgdGFncmdldCBzcGVjaWZpZXIgYW5kIGh0bWxcbiAgICAgICogSSBmaXJzdCBsb29rIHVwIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB0YXJnZXQgaGFzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAqIHJhbmdlIChjb21pbmcgZnJvbSB0aGUgdGFyZ2V0UmFuZ2VJZCBwcm9wZXJ0eSksIGFuZCB0aGVuIHNldCBpdCB3aXRoIG15XG4gICAgICAqIGlubmVySFRNTC4gTm90ZSwgc2luY2UgdGhlIHRhcmdldCBwcm9wZXJ0eSB2YWx1ZSBpcyBhbiBvYmplY3Qgc3BlY2lmaWVyIElcbiAgICAgICogY3JlYXRlIGEgc2VtYW50aWNzIG9iamVjdHMgYW5kIGludGVycHJldCB0aGUgdmFsdWUgcmVzdWx0aW5nIGluIGEgdmFsaWRcbiAgICAgICogcGFydCBpZC5cbiAgICAgICovXG4gICAgc2V0UmFuZ2VJblRhcmdldCh0YXJnZXRTcGVjaWZpZXIsIGh0bWwsIGNzcyl7XG4gICAgICAgIGxldCB0YXJnZXRSYW5nZUlkID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsICd0YXJnZXRSYW5nZUlkJyk7XG4gICAgICAgIGxldCBtYXRjaCA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5tYXRjaCh0YXJnZXRTcGVjaWZpZXIsIFwiT2JqZWN0U3BlY2lmaWVyXCIpO1xuICAgICAgICBsZXQgc2VtYW50aWNzID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLmNyZWF0ZVNlbWFudGljcygpO1xuICAgICAgICBzZW1hbnRpY3MuYWRkT3BlcmF0aW9uKCdpbnRlcnByZXQnLCBpbnRlcnByZXRlclNlbWFudGljcyh0aGlzLm1vZGVsLCB3aW5kb3cuU3lzdGVtKSk7XG4gICAgICAgIGxldCB0YXJnZXRJZCA9IHNlbWFudGljcyhtYXRjaCkuaW50ZXJwcmV0KCk7XG5cbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImluc2VydFJhbmdlXCIsXG4gICAgICAgICAgICBhcmdzOiBbdGFyZ2V0UmFuZ2VJZCwgaHRtbCwgY3NzXVxuICAgICAgICB9LCB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFt0YXJnZXRJZF0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSSBpbnNlcnQgdGhlIGh0bWwgKHN0cmluZykgaW50byB0aGUgc3BlY2lmaWVkIHJhbmdlIChieSBpZClcbiAgICAgKi9cbiAgICBpbnNlcnRSYW5nZShyYW5nZUlkLCBodG1sLCBjc3NPYmope1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvblJhbmdlc1tyYW5nZUlkXTtcbiAgICAgICAgaWYocmFuZ2Upe1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBzcGFuLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICBpZihjc3NPYmope1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzc09iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNzc09ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHNwYW4pO1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSB0ZXh0IGFuZCBpbm5lckhUTUwgcHJvcGVydGllcyB3aXRob3V0IG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgLy8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBzZXR0aW5nIG9mIHRoZSB0ZXh0L2h0bWxcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVyVGV4dCxcbiAgICAgICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5LCB0byBwcmVzZXJ2ZSBjb250ZW50ZWRpdGFibGUgY29udGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdpbm5lckhUTUwnLFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLFxuICAgICAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuQ29udGV4dE1lbnUoKXtcbiAgICAgICAgbGV0IHRleHQgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpO1xuICAgICAgICBsZXQgZm9jdXNOb2RlID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkuZm9jdXNOb2RlO1xuICAgICAgICBsZXQgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgYnV0dG9uLmlkID0gXCJkb0l0XCI7XG4gICAgICAgIGJ1dHRvbi5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIxMHB4XCI7XG4gICAgICAgIGJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInZhcigtLXBhbGV0dGUtZ3JlZW4pXCI7XG4gICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IFwiRG8gaXQhXCI7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5kb0l0KTtcbiAgICAgICAgZm9jdXNOb2RlLmFmdGVyKGJ1dHRvbik7XG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVPcGVuID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY2xvc2VDb250ZXh0TWVudSgpe1xuICAgICAgICBsZXQgYnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjZG9JdCcpO1xuICAgICAgICBpZihidXR0b24pe1xuICAgICAgICAgICAgYnV0dG9uLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIHRoZSBzZWxlY3Rpb24gYW5kIHNldCB0aGUgY29udGV4dCBtZW51IHRvIGNsb3NlZFxuICAgICAgICBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudU9wZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkb0l0KGV2ZW50KXtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGxldCB0ZXh0ID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gY2xlYW4gdXAgdGhlIHRleHQgdG8gbWFrZSBzdXJlIG5vIG5ld2xpbmVzIG9yIHNwYWNlcyBtYWRlIGl0IGluXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15bXFx0XFxuIF0rLywgXCJcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXHRcXG4gXSskLywgXCJcIik7XG4gICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAvLyBzZW5kIG1lc3NhZ2UgdG8gY29tcGlsZSB0aGUgcHJlcHBlZCBzY3JpcHRcbiAgICAgICAgbGV0IHNjcmlwdCA9IGBvbiBkb0l0XFxuICAgJHt0ZXh0fVxcbmVuZCBkb0l0YDtcbiAgICAgICAgLy8gc2VuZCB0aGVzZSBtZXNzYWdlcyBmcm9tIHRoZSBtb2RlbCAobm90IHRoZSB2aWV3KVxuICAgICAgICAvLyBzaW5jZSBpZiB0aGVyZSBpcyBhbiBlcnJvciB0aGUgb3JpZ2luYWwgc2VuZGVyIHdpbGxcbiAgICAgICAgLy8gaGF2ZSBhbiBpZFxuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tcGlsZVwiLFxuICAgICAgICAgICAgICAgIGNvZGVTdHJpbmc6IHNjcmlwdCxcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogdGhpcy5tb2RlbC5pZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJkb0l0XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlIC8vIFNob3VsZCBpZ25vcmUgaWYgU3lzdGVtIEROVVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbnMoKXtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLmlkID0gXCJoYWxvLWZpZWxkLWxvY2stZWRpdG9yXCI7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5pbm5lckhUTUwgPSBoYWxvTG9ja0J1dHRvblNWRztcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ2JvdHRvbS1yb3cnKTtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0xvY2sgRWRpdGluZycpO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnc2V0UHJvcGVydHknLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcImVkaXRhYmxlXCIsIGZhbHNlXSxcbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgICAgIC8vIGNsb3NlL29wZW4gdGhlIGhhbG8gdG8gdXBkYXRlIHRoZSBlZGl0aW5nIHN0YXRlIHRvZ2dsZSBidXR0b25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uaWQgPSBcImhhbG8tZmllbGQtdW5sb2NrLWVkaXRvclwiO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLmlubmVySFRNTCA9IGhhbG9VbmxvY2tCdXR0b25TVkc7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnYm90dG9tLXJvdycpO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdVbmxvY2sgRWRpdGluZycpO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdzZXRQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgYXJnczogW1wiZWRpdGFibGVcIiwgdHJ1ZV0sXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIC8vIGNsb3NlL29wZW4gdGhlIGhhbG8gdG8gdXBkYXRlIHRoZSBlZGl0aW5nIHN0YXRlIHRvb2dsZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5IYWxvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQuIEhlcmUgd2UgYWRkIGEgY3VzdG9tIGJ1dHRvblxuICAgICAgICAvLyB3aGVuIHNob3dpbmcuXG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZighZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChmb3VuZEhhbG8pO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kSGFsby5hcHBlbmQodGhpcy5oYWxvTG9ja1VubG9ja0J1dHRvbik7XG4gICAgfVxuXG4gICAgLy8gT3ZlcndyaXRpbmcgdGhlIGJhc2UgY2xhc3Mgb3Blbi9jbG9zZSBlZGl0b3IgbWV0aG9kc1xuICAgIG9wZW5FZGl0b3IoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5vcGVuRWRpdG9yRm9yUGFydCh0aGlzLm1vZGVsLmlkKTtcbiAgICB9XG5cbiAgICBjbG9zZUVkaXRvcigpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmNsb3NlRWRpdG9yRm9yUGFydCh0aGlzLm1vZGVsLmlkKTtcbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogSSBjb252ZXJ0IHJhdyB0ZXh0IHRvIGh0bWwgcmVzcGVjdGluZyB0aGUgRmlyZWZveFxuICAgICAqIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGUgZ3VpZGVsbmVzLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCBzaW5nbGUgbGlucyBvZiB0ZXh0IGFyZSBsZWZ0IGFzIGlzO1xuICAgICAqIG11bHRpbGluZSB0ZXh0LCBpLmUuIHRleHQgd2hpY2ggaW5jbHVkZXMgXCJcXG5cIiwgaXNcbiAgICAgKiB3cmFwcGVkIGluIDxkaXY+PC9kaXY+IGZvciBldmVyeSBsaW5lOyBhbmQgdGhlIGxhc3RcbiAgICAgKiBsaW5lIGdldHMgYSA8YnI+IHRhZyBpbnNlcnRlZCBiZWZvcmUgdGhlIDwvZGl2PiB0byByZWZsZWN0XG4gICAgICogdGhlIFwib24tZW50ZXIta2V5XCIgYmVoYXZpb3IuXG4gICAgICovXG4gICAgdGV4dFRvSHRtbCh0ZXh0KXtcbiAgICAgICAgaWYodGV4dCl7XG4gICAgICAgICAgICBsZXQgdGV4dExpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGlmKHRleHRMaW5lcy5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGV4dExpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYobGluZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGA8ZGl2PiR7bGluZX08L2Rpdj5gO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBcIjxkaXY+PGJyPjwvZGl2PlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICBgPGRpdj4ke2h0bWx9PGJyPjwvZGl2PmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBodG1sVG9UZXh0KGVsZW1lbnQpe1xuICAgICAgICAvLyBUT0RPIHRoaXMgaXMgdmVyeSBuYWl2ZSBhbmQgaWdub3JlcyBtb3N0IHBvc3NpYmxlIHN0cnVjdHVyZVxuICAgICAgICBpZihlbGVtZW50LmlubmVySFRNTCl7XG4gICAgICAgICAgICAvLyBmaXJzdCByZXBsYWNlIGFsbCB0aGUgXCI8L2Rpdj48ZGl2PlwiIHdpdGggbGluZSBicmVha3NcbiAgICAgICAgICAgIGxldCBjbGVhbkhUTUwgPSAgZWxlbWVudC5pbm5lckhUTUwucmVwbGFjZSgvPFxcL2Rpdj48ZGl2Pi9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIC8vIHRoZW4gcmVtb3ZlIGFsbCBodG1sXG4gICAgICAgICAgICBsZXQgdGVtcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID0gY2xlYW5IVE1MO1xuICAgICAgICAgICAgbGV0IGNsZWFuVGV4dCA9IHRlbXBFbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgICAgdGVtcEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm4gY2xlYW5UZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoaWdobGlnaHRTeW50YXgoKXtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInN5bnRheFwiKTtcbiAgICAgICAgaWYoY3VycmVudCAmJiBjdXJyZW50ICE9PSBcImZhbHNlXCIpe1xuICAgICAgICAgICAgdGhpcy51bmhpZ2hsaWdodFN5bnRheCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZW1hbnRpY3MgPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICBcImhpZ2hsaWdodFN5bnRheFwiLFxuICAgICAgICAgICAgY3JlYXRlSGlnaGxpZ2h0ZXIodGhpcylcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJ0ZXh0XCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYoIXRleHQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdIVE1MID0gdGV4dC5zcGxpdChcIlxcblwiKS5tYXAobGluZSA9PiB7XG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBydWxlIGFuZCB0cnkgdG8gbWF0Y2hcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9zeW50YXhSdWxlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLl9zeW50YXhSdWxlc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIubWF0Y2gobGluZSwgcnVsZSk7XG4gICAgICAgICAgICAgICAgaWYobWF0Y2guc3VjY2VlZGVkKCkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VtYW50aWNzKG1hdGNoKS5oaWdobGlnaHRTeW50YXgoKS5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwiaW5uZXJIVE1MXCIsXG4gICAgICAgICAgICBuZXdIVE1MXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy50b2dnbGVBdHRyaWJ1dGUoXCJzeW50YXhcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdW5oaWdobGlnaHRTeW50YXgoKXtcbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJ0ZXh0XCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYoIXRleHQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwbGFpbkVsZW1lbnRzID0gdGV4dC5zcGxpdChcIlxcblwiKS5tYXAobGluZSA9PiB7XG4gICAgICAgICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi5pbm5lclRleHQgPSBsaW5lO1xuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaW5hbExpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBmaW5hbExpbmUuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICAgIHBsYWluRWxlbWVudHMucHVzaChmaW5hbExpbmUpO1xuXG4gICAgICAgIGxldCBuZXdIVE1MID0gXCJcIjtcbiAgICAgICAgcGxhaW5FbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgbmV3SFRNTCArPSBlbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwiaW5uZXJIVE1MXCIsXG4gICAgICAgICAgICBuZXdIVE1MXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy50b2dnbGVBdHRyaWJ1dGUoXCJzeW50YXhcIiwgZmFsc2UpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRmllbGRWaWV3LFxuICAgIEZpZWxkVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBOZXcgSGFsb1xuICovXG5cbi8qKiBOb3RlOiBJY29ucyBhcmUgZnJvbSBcbioqKiBodHRwczovL3RhYmxlcmljb25zLmNvbS9cbioqL1xuY29uc3QgZGVsZXRlSWNvbiA9YFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXRyYXNoXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGxpbmUgeDE9XCI0XCIgeTE9XCI3XCIgeDI9XCIyMFwiIHkyPVwiN1wiIC8+XG4gIDxsaW5lIHgxPVwiMTBcIiB5MT1cIjExXCIgeDI9XCIxMFwiIHkyPVwiMTdcIiAvPlxuICA8bGluZSB4MT1cIjE0XCIgeTE9XCIxMVwiIHgyPVwiMTRcIiB5Mj1cIjE3XCIgLz5cbiAgPHBhdGggZD1cIk01IDdsMSAxMmEyIDIgMCAwIDAgMiAyaDhhMiAyIDAgMCAwIDIgLTJsMSAtMTJcIiAvPlxuICA8cGF0aCBkPVwiTTkgN3YtM2ExIDEgMCAwIDEgMSAtMWg0YTEgMSAwIDAgMSAxIDF2M1wiIC8+XG48L3N2Zz5cbmA7XG5jb25zdCBlZGl0SWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1lZGl0XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk05IDdoLTNhMiAyIDAgMCAwIC0yIDJ2OWEyIDIgMCAwIDAgMiAyaDlhMiAyIDAgMCAwIDIgLTJ2LTNcIiAvPlxuICA8cGF0aCBkPVwiTTkgMTVoM2w4LjUgLTguNWExLjUgMS41IDAgMCAwIC0zIC0zbC04LjUgOC41djNcIiAvPlxuICA8bGluZSB4MT1cIjE2XCIgeTE9XCI1XCIgeDI9XCIxOVwiIHkyPVwiOFwiIC8+XG48L3N2Zz5cbmA7XG5jb25zdCBncm93SWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1hcnJvd3MtZGlhZ29uYWwtMlwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCIxNiAyMCAyMCAyMCAyMCAxNlwiIC8+XG4gIDxsaW5lIHgxPVwiMTRcIiB5MT1cIjE0XCIgeDI9XCIyMFwiIHkyPVwiMjBcIiAvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiOCA0IDQgNCA0IDhcIiAvPlxuICA8bGluZSB4MT1cIjRcIiB5MT1cIjRcIiB4Mj1cIjEwXCIgeTI9XCIxMFwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGNvcHlJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNvcHlcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxyZWN0IHg9XCI4XCIgeT1cIjhcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMTJcIiByeD1cIjJcIj48L3JlY3Q+XG4gICA8cGF0aCBkPVwiTTE2IDh2LTJhMiAyIDAgMCAwIC0yIC0yaC04YTIgMiAwIDAgMCAtMiAydjhhMiAyIDAgMCAwIDIgMmgyXCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBwYXN0ZUljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2xpcGJvYXJkLWNoZWNrXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8cGF0aCBkPVwiTTkgNWgtMmEyIDIgMCAwIDAgLTIgMnYxMmEyIDIgMCAwIDAgMiAyaDEwYTIgMiAwIDAgMCAyIC0ydi0xMmEyIDIgMCAwIDAgLTIgLTJoLTJcIj48L3BhdGg+XG4gICA8cmVjdCB4PVwiOVwiIHk9XCIzXCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMlwiPjwvcmVjdD5cbiAgIDxwYXRoIGQ9XCJNOSAxNGwyIDJsNCAtNFwiPjwvcGF0aD5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGFyZ2V0SWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1mb2N1c1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIuNVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj48L2NpcmNsZT5cbiAgIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiOVwiPjwvY2lyY2xlPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBzZXR0aW5nc0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc2V0dGluZ3NcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEwLjMyNSA0LjMxN2MuNDI2IC0xLjc1NiAyLjkyNCAtMS43NTYgMy4zNSAwYTEuNzI0IDEuNzI0IDAgMCAwIDIuNTczIDEuMDY2YzEuNTQzIC0uOTQgMy4zMSAuODI2IDIuMzcgMi4zN2ExLjcyNCAxLjcyNCAwIDAgMCAxLjA2NSAyLjU3MmMxLjc1NiAuNDI2IDEuNzU2IDIuOTI0IDAgMy4zNWExLjcyNCAxLjcyNCAwIDAgMCAtMS4wNjYgMi41NzNjLjk0IDEuNTQzIC0uODI2IDMuMzEgLTIuMzcgMi4zN2ExLjcyNCAxLjcyNCAwIDAgMCAtMi41NzIgMS4wNjVjLS40MjYgMS43NTYgLTIuOTI0IDEuNzU2IC0zLjM1IDBhMS43MjQgMS43MjQgMCAwIDAgLTIuNTczIC0xLjA2NmMtMS41NDMgLjk0IC0zLjMxIC0uODI2IC0yLjM3IC0yLjM3YTEuNzI0IDEuNzI0IDAgMCAwIC0xLjA2NSAtMi41NzJjLTEuNzU2IC0uNDI2IC0xLjc1NiAtMi45MjQgMCAtMy4zNWExLjcyNCAxLjcyNCAwIDAgMCAxLjA2NiAtMi41NzNjLS45NCAtMS41NDMgLjgyNiAtMy4zMSAyLjM3IC0yLjM3YzEgLjYwOCAyLjI5NiAuMDcgMi41NzIgLTEuMDY1elwiIC8+XG4gIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiM1wiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHJvdGF0ZUljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcm90YXRlLWNsb2Nrd2lzZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHBhdGggZD1cIk00LjA1IDExYTggOCAwIDEgMSAuNSA0bS0uNSA1di01aDVcIj48L3BhdGg+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuIDpob3N0IHtcbiAgICAgLS1oYWxvLWJ1dHRvbi1oZWlnaHQ6IDI1cHg7XG4gICAgIC0taGFsby1idXR0b24td2lkdGg6IDI1cHg7XG4gICAgIC0taGFsby1yaW0tbWFyZ2luOiAxMHB4O1xuICAgICAtLWhhbG8tYnV0dG9uLXdpZHRoLXBhZGRlZDogY2FsYyh2YXIoLS1oYWxvLWJ1dHRvbi13aWR0aCkgKyB2YXIoLS1oYWxvLXJpbS1tYXJnaW4pKTtcbiAgICAgLS1oYWxvLWJ1dHRvbi1oZWlnaHQtcGFkZGVkOiBjYWxjKHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodCkgKyB2YXIoLS1oYWxvLXJpbS1tYXJnaW4pKTtcbiAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICB0b3A6IGNhbGMoLTEgKiB2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQtcGFkZGVkKSk7XG4gICAgIGxlZnQ6IGNhbGMoLTEgKiB2YXIoLS1oYWxvLWJ1dHRvbi13aWR0aC1wYWRkZWQpKTtcbiAgICAgd2lkdGg6IGNhbGMoMTAwJSArICgyICogdmFyKC0taGFsby1idXR0b24td2lkdGgtcGFkZGVkKSkpO1xuICAgICBoZWlnaHQ6IGNhbGMoMTAwJSArICgyICogdmFyKC0taGFsby1idXR0b24taGVpZ2h0LXBhZGRlZCkpKTtcbiAgICAgY29sb3I6IGluaXRpYWw7XG4gICAgIHotaW5kZXg6IDEwO1xuIH1cblxuXG4gLmhhbG8tcm93LFxuIC5oYWxvLWNvbHVtbiB7XG4gICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiB9XG5cbiAuaGFsby1jb2x1bW4ge1xuICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuIH1cblxuICNoYWxvLXRvcC1yb3csXG4gI2hhbG8tYm90dG9tLXJvdyB7XG4gICAgIHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS1oYWxvLWJ1dHRvbi13aWR0aC1wYWRkZWQpKTtcbiAgICAgaGVpZ2h0OiB2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQtcGFkZGVkKTtcbiB9XG5cbiAjaGFsby10b3Atcm93IHtcbiAgICAgbGVmdDogMDtcbiAgICAgdG9wOiAwO1xuIH1cblxuICNoYWxvLWJvdHRvbS1yb3cge1xuICAgICByaWdodDogMDtcbiAgICAgYm90dG9tOiAwO1xuICAgICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiB9XG5cbiAjaGFsby1yaWdodC1jb2x1bW4sXG4gI2hhbG8tbGVmdC1jb2x1bW4ge1xuICAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpKTtcbiAgICAgd2lkdGg6IHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoLXBhZGRlZCk7XG4gfVxuXG4gI2hhbG8tcmlnaHQtY29sdW1uIHtcbiAgICAgcmlnaHQ6IDA7XG4gICAgIHRvcDogMDtcbiAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuIH1cblxuICNoYWxvLWxlZnQtY29sdW1uIHtcbiAgICAgbGVmdDogMDtcbiAgICAgdG9wOiB2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQtcGFkZGVkKTtcbiB9XG5cbiAuaGFsby1idXR0b24sXG4gOjpzbG90dGVkKCopIHtcbiAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC44KTtcbiAgICAgd2lkdGg6IHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoKTtcbiAgICAgaGVpZ2h0OiB2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQpO1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjIwLCAyMjAsIDIyMCk7XG4gfVxuXG4gLmhhbG8tYnV0dG9uOmhvdmVyXG4gOjpzbG90dGVkKCopLmhhbG8tYnV0dG9uOmhvdmVyIHtcbiAgICAgY3Vyc29yOiBwb2ludGVyO1xuIH1cblxuIC5oYWxvLWJ1dHRvbjphY3RpdmVcbiA6OnNsb3R0ZWQoKikuaGFsby1idXR0b246YWN0aXZlIHtcbiAgICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gfVxuXG4gLmhhbG8tYnV0dG9uLmhpZGRlblxuIDo6c2xvdHRlZCgqKS5oYWxvLWJ1dHRvbi5oaWRkZW4ge1xuICAgICBkaXNwbGF5OiBub25lO1xuIH1cblxuPC9zdHlsZT5cblxuPGRpdiBpZD1cImhhbG8tdG9wLXJvd1wiIGNsYXNzPVwiaGFsby1yb3dcIj5cbiAgICA8ZGl2IGlkPVwiaGFsby1kZWxldGVcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJEZWxldGUgdGhpcyBwYXJ0XCI+XG4gICAgICAgICR7ZGVsZXRlSWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwidG9wLXJvd1wiPjwvc2xvdD5cbjwvZGl2PlxuXG48ZGl2IGlkPVwiaGFsby1ib3R0b20tcm93XCIgY2xhc3M9XCJoYWxvLXJvd1wiPlxuICAgIDxkaXYgaWQ9XCJoYWxvLXJlc2l6ZVwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIlJlc2l6ZSB0aGlzIHBhcnRcIj5cbiAgICAgICAgJHtncm93SWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwiaGFsby1zY3JpcHQtZWRpdFwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIkVkaXQgdGhpcyBwYXJ0J3Mgc2NyaXB0XCI+XG4gICAgICAgICR7ZWRpdEljb259XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImhhbG8tZWRpdFwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIkVkaXQgdGhpcyBwYXJ0XCI+XG4gICAgICAgICR7c2V0dGluZ3NJY29ufVxuICAgIDwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJib3R0b20tcm93XCI+PC9zbG90PlxuPC9kaXY+XG5cbjxkaXYgaWQ9XCJoYWxvLWxlZnQtY29sdW1uXCIgY2xhc3M9XCJoYWxvLWNvbHVtblwiPlxuICAgIDxkaXYgaWQ9XCJoYWxvLWNvcHlcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJDb3B5IHRoaXMgUGFydFwiPlxuICAgICAgICAke2NvcHlJY29ufVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoYWxvLXBhc3RlXCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiUGFzdGUgdGhlIGNvbnRlbnRzIG9mIGNsaXBib2FyZCBpbnRvIHRoaXMgUGFydFwiPlxuICAgICAgICAke3Bhc3RlSWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwiaGFsby10YXJnZXRcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJTZWxlY3QgdGhpcyBQYXJ0J3MgdGFyZ2V0XCI+XG4gICAgICAgICR7dGFyZ2V0SWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwibGVmdC1jb2x1bW5cIj48L3Nsb3Q+XG48L2Rpdj5cblxuPGRpdiBpZD1cImhhbG8tcmlnaHQtY29sdW1uXCIgY2xhc3M9XCJoYWxvLWNvbHVtblwiPlxuICAgIDxkaXYgaWQ9XCJoYWxvLXJvdGF0ZVwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIlJvdGF0ZSB0aGlzIHBhcnRcIj5cbiAgICAgICAgJHtyb3RhdGVJY29ufVxuICAgIDwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJyaWdodC1jb2x1bW5cIj48L3Nsb3Q+XG48L2Rpdj5cblxuYDtcblxuY2xhc3MgSGFsbyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgU2hhZG93IERPTSBhbmQgdGVtcGxhdGVcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLnNoYWRvdy5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuXG5cbiAgICAgICAgLy8gQmluZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplTW91c2VEb3duID0gdGhpcy5vblJlc2l6ZU1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplTW91c2VVcCA9IHRoaXMub25SZXNpemVNb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemVNb3VzZU1vdmUgPSB0aGlzLm9uUmVzaXplTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Sb3RhdGVNb3VzZURvd24gPSB0aGlzLm9uUm90YXRlTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Sb3RhdGVNb3VzZVVwID0gdGhpcy5vblJvdGF0ZU1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJvdGF0ZU1vdXNlTW92ZSA9IHRoaXMub25Sb3RhdGVNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0Um9vdE5vZGUoKS5ob3N0O1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2VkaXRpbmcnKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudC5oYXNPcGVuSGFsbyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG5cbiAgICAgICAgICAgIC8vIFJlc2l6ZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMucmVzaXplciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1yZXNpemUnKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUmVzaXplTW91c2VEb3duKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvUmVzaXplKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSb3RhdGUgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLnJvdGF0ZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tcm90YXRlJyk7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblJvdGF0ZU1vdXNlRG93bik7XG4gICAgICAgICAgICBpZighdGhpcy50YXJnZXRFbGVtZW50LndhbnRzSGFsb1JvdGF0ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1kZWxldGUnKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9EZWxldGUpO1xuICAgICAgICAgICAgaWYoIXRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9EZWxldGUpe1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVkaXQgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLnNjcmlwdEVkaXRvciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1zY3JpcHQtZWRpdCcpO1xuICAgICAgICAgICAgdGhpcy5zY3JpcHRFZGl0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvT3BlblNjcmlwdEVkaXRvcik7XG4gICAgICAgICAgICBpZighdGhpcy50YXJnZXRFbGVtZW50LndhbnRzSGFsb1NjcmlwdEVkaXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2NyaXB0RWRpdG9yLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHJlaGVuc2l2ZSBlZGl0b3IgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLmVkaXRvciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1lZGl0Jyk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9PcGVuRWRpdG9yKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvRWRpdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb3B5IGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5jb3BpZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tY29weScpO1xuICAgICAgICAgICAgdGhpcy5jb3BpZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvQ29weSk7XG5cblxuICAgICAgICAgICAgLy8gUGFzdGUgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLnBhc3RlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1wYXN0ZScpO1xuICAgICAgICAgICAgdGhpcy5wYXN0ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvUGFzdGUpO1xuXG4gICAgICAgICAgICAvLyBUYXJnZXQgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLnRhcmdldGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXRhcmdldCcpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9UYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlRW50ZXIpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlTGVhdmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRpbmcnKTtcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50Lmhhc09wZW5IYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICB0aGlzLnJlc2l6ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblJlc2l6ZU1vdXNlRG93bik7XG4gICAgfVxuXG5cbiAgICAvKiBFdmVudCBIYW5kbGluZyAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDAgJiYgdGhpcy50YXJnZXRFbGVtZW50LndhbnRzSGFsb01vdmUpe1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICBsZXQgY3VycmVudFRvcCA9IHBhcnNlSW50KHRoaXMudGFyZ2V0RWxlbWVudC5zdHlsZS50b3ApO1xuICAgICAgICBsZXQgY3VycmVudExlZnQgPSBwYXJzZUludCh0aGlzLnRhcmdldEVsZW1lbnQuc3R5bGUubGVmdCk7XG4gICAgICAgIGxldCBuZXdUb3AgPSBldmVudC5tb3ZlbWVudFkgKyBjdXJyZW50VG9wO1xuICAgICAgICBsZXQgbmV3TGVmdCA9IGV2ZW50Lm1vdmVtZW50WCArIGN1cnJlbnRMZWZ0O1xuXG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMudGFyZ2V0RWxlbWVudC5tb2RlbDtcbiAgICAgICAgbW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChtb2RlbCwgXCJ0b3BcIiwgbmV3VG9wKTtcbiAgICAgICAgbW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChtb2RlbCwgXCJsZWZ0XCIsIG5ld0xlZnQpO1xuICAgIH1cblxuICAgIG9uTW91c2VVcChldmVudCl7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgIH1cblxuICAgIG9uUmVzaXplTW91c2VEb3duKGV2ZW50KXtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25SZXNpemVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vblJlc2l6ZU1vdXNlVXApO1xuICAgIH1cblxuICAgIG9uUmVzaXplTW91c2VVcChldmVudCl7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25SZXNpemVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vblJlc2l6ZU1vdXNlVXApO1xuICAgIH1cblxuICAgIG9uUmVzaXplTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb1Jlc2l6ZShcbiAgICAgICAgICAgIGV2ZW50Lm1vdmVtZW50WCxcbiAgICAgICAgICAgIGV2ZW50Lm1vdmVtZW50WVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG9uUm90YXRlTW91c2VEb3duKGV2ZW50KXtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Sb3RhdGVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vblJvdGF0ZU1vdXNlVXApO1xuICAgIH1cblxuICAgIG9uUm90YXRlTW91c2VVcChldmVudCl7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Sb3RhdGVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vblJvdGF0ZU1vdXNlVXApO1xuICAgIH1cblxuICAgIG9uUm90YXRlTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb1JvdGF0ZShcbiAgICAgICAgICAgIGV2ZW50Lm1vdmVtZW50WCxcbiAgICAgICAgICAgIGV2ZW50Lm1vdmVtZW50WVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgSGFsbyxcbiAgICBIYWxvIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IGxpbmtJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxpbmtcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEwIDE0YTMuNSAzLjUgMCAwIDAgNSAwbDQgLTRhMy41IDMuNSAwIDAgMCAtNSAtNWwtLjUgLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDEwYTMuNSAzLjUgMCAwIDAgLTUgMGwtNCA0YTMuNSAzLjUgMCAwIDAgNSA1bC41IC0uNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHBpY3R1cmVJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXBob3RvXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8bGluZSB4MT1cIjE1XCIgeTE9XCI4XCIgeDI9XCIxNS4wMVwiIHkyPVwiOFwiPjwvbGluZT5cbiAgIDxyZWN0IHg9XCI0XCIgeT1cIjRcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjNcIj48L3JlY3Q+XG4gICA8cGF0aCBkPVwiTTQgMTVsNCAtNGEzIDUgMCAwIDEgMyAwbDUgNVwiPjwvcGF0aD5cbiAgIDxwYXRoIGQ9XCJNMTQgMTRsMSAtMWEzIDUgMCAwIDEgMyAwbDIgMlwiPjwvcGF0aD5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48aW1nIGlkPVwid3JhcHBlZC1pbWFnZVwiIGNsYXNzPVwiaGlkZGVuXCIgLz5cbjxzdmcgY2xhc3M9XCJoaWRkZW5cIiBpZD1cIndyYXBwZWQtc3ZnXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuPC9zdmc+XG48c3R5bGU+XG46aG9zdCB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG5cbi5oaWRkZW4ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG59XG5pbWcge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogYXV0bztcbiAgICBkaXNwbGF5OiBibG9jaztcbn1cblxuLmN1cnJlbnRseS13cmFwcGVkIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG48L3N0eWxlPlxuYDtcblxuY2xhc3MgSW1hZ2VWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyBkb21cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnVwZGF0ZUltYWdlRGF0YSA9IHRoaXMudXBkYXRlSW1hZ2VEYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlU3ZnSW1hZ2UgPSB0aGlzLnVwZGF0ZVN2Z0ltYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlQmluYXJ5SW1hZ2UgPSB0aGlzLnVwZGF0ZUJpbmFyeUltYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0RGVmYXVsdEltYWdlID0gdGhpcy5zZXREZWZhdWx0SW1hZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24gPSB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlSW1hZ2VMaW5rID0gdGhpcy51cGRhdGVJbWFnZUxpbmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmdGb3JWaWV3cG9ydCA9IHRoaXMudXBkYXRlU2l6aW5nRm9yVmlld3BvcnQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIHByb3AgY2hhbmdlc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcImltYWdlRGF0YVwiLCAoaW1hZ2VEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZighaW1hZ2VEYXRhKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERlZmF1bHRJbWFnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbWFnZURhdGEoaW1hZ2VEYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgaW1hZ2VEYXRhLiBJZiBub3QsIHRyeVxuICAgICAgICAvLyB0byBsb2FkIGZyb20gYSBzcmMuXG4gICAgICAgIGxldCBjdXJyZW50SW1hZ2VEYXRhID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwiaW1hZ2VEYXRhXCJcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJzcmNcIlxuICAgICAgICApO1xuICAgICAgICBpZighY3VycmVudEltYWdlRGF0YSl7XG4gICAgICAgICAgICBpZihjdXJyZW50U3JjKXtcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbG9hZEltYWdlRnJvbScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsgY3VycmVudFNyYyBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKG1zZywgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEltYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlRGF0YShjdXJyZW50SW1hZ2VEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIGlmKCF0aGlzLmhhbG9CdXR0b24pe1xuICAgICAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBzZXREZWZhdWx0SW1hZ2UoKXtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiaW1hZ2VEYXRhXCIsIHBpY3R1cmVJY29uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwibWltZVR5cGVcIiwgXCJpbWFnZS9zdmdcIik7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInNyY1wiLCBcIlwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbWFnZURhdGEocGljdHVyZUljb24pO1xuICAgIH1cblxuICAgIHVwZGF0ZUltYWdlRGF0YShpbWFnZURhdGEpe1xuICAgICAgICBpZih0aGlzLm1vZGVsLmlzU3ZnKXtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3ZnSW1hZ2UoaW1hZ2VEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmluYXJ5SW1hZ2UoaW1hZ2VEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUJpbmFyeUltYWdlKGltYWdlRGF0YSl7XG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIGltYWdlRGF0YSBpc1xuICAgICAgICAvLyBhIGJhc2U2NCBlbmNvZGVkIGRhdGEgdXJsIGRlc2NyaWJpbmdcbiAgICAgICAgLy8gdGhlIGJpdHMgb2YgdGhlIGltYWdlLlxuICAgICAgICBsZXQgaW1nRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd3cmFwcGVkLWltYWdlJyk7XG4gICAgICAgIGxldCBzdmdFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZWQtc3ZnJyk7XG4gICAgICAgIHN2Z0VsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBzdmdFbC5jbGFzc0xpc3QucmVtb3ZlKCdjdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBpbWdFbC5jbGFzc0xpc3QuYWRkKCdjdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBpbWdFbC5zcmMgPSBpbWFnZURhdGE7XG4gICAgICAgIGltZ0VsLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vdGhpcy51cGRhdGVTaXppbmdGb3JWaWV3cG9ydCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByZXNlcnZlQXNwZWN0T25SZXNpemUgPSB0cnVlO1xuICAgICAgICBpbWdFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTdmdJbWFnZShpbWFnZURhdGEpe1xuICAgICAgICBsZXQgaW1nRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd3cmFwcGVkLWltYWdlJyk7XG4gICAgICAgIGxldCBjdXJyZW50U3ZnRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd3cmFwcGVkLXN2ZycpO1xuICAgICAgICBsZXQgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBsZXQgeG1sRG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGltYWdlRGF0YSwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgICBsZXQgbmV3U3ZnRWwgPSB4bWxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIFNWRyBoYXMgc29tZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXNcbiAgICAgICAgLy8gc2V0IHNvIHdlIGhhdmUgaW5pdGlhbCBkaW1lbnNpb25zIHRvIGRpc3BsYXkuIElmIG5vdCBwcmVzZW50LFxuICAgICAgICAvLyBwdWxsIGZyb20gdmlld2JveC5cbiAgICAgICAgaWYoIW5ld1N2Z0VsLmhhc0F0dHJpYnV0ZSgnd2lkdGgnKSB8fCAhbmV3U3ZnRWwuaGFzQXR0cmlidXRlKCdoZWlnaHQnKSl7XG4gICAgICAgICAgICBsZXQgdmlld0JveCA9IG5ld1N2Z0VsLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgICAgICAgaWYodmlld0JveCl7XG4gICAgICAgICAgICAgICAgdmlld0JveCA9IHZpZXdCb3guc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgIGxldCB2aWV3Qm94V2lkdGggPSBwYXJzZUludCh2aWV3Qm94WzJdKTtcbiAgICAgICAgICAgICAgICBsZXQgdmlld0JveEhlaWdodCA9IHBhcnNlSW50KHZpZXdCb3hbM10pO1xuICAgICAgICAgICAgICAgIG5ld1N2Z0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgdmlld0JveEhlaWdodCk7XG4gICAgICAgICAgICAgICAgbmV3U3ZnRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHZpZXdCb3hXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIG5ld1N2Z0VsLmlkID0gJ3dyYXBwZWQtc3ZnJztcbiAgICAgICAgbmV3U3ZnRWwuY2xhc3NMaXN0LmFkZCgnY3VycmVudGx5LXdyYXBwZWQnKTtcbiAgICAgICAgaW1nRWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIGltZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGN1cnJlbnRTdmdFbC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChuZXdTdmdFbCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nRm9yVmlld3BvcnQoKTtcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZUFzcGVjdE9uUmVzaXplID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdXBkYXRlSW1hZ2VMaW5rKGV2ZW50KXtcbiAgICAgICAgLy8gVGVsbHMgdGhlIG1vZGVsIHRvIHVwZGF0ZSBpdHNcbiAgICAgICAgLy8gc3JjIGxpbmsgZm9yIHRoZSBpbWFnZVxuICAgICAgICBsZXQgY3VycmVudFNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnc3JjJ1xuICAgICAgICApO1xuICAgICAgICBsZXQgcmVzdWx0ID0gd2luZG93LnByb21wdChcIkVkaXQgVVJMIGZvciBpbWFnZTpcIiwgY3VycmVudFNyYyk7XG4gICAgICAgIGlmKHJlc3VsdCAmJiByZXN1bHQgIT09ICcnICYmIHJlc3VsdCAhPT0gY3VycmVudFNyYyl7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2xvYWRJbWFnZUZyb20nLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbIHJlc3VsdCBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlU2l6aW5nRm9yVmlld3BvcnQoKXtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhpcyBjb21wb25lbnQgZG9lcyBub3QgZGlzcGxheSBsYXJnZXJcbiAgICAgICAgLy8gdGhhbiB0aGUgY3VycmVudCByZW1haW5pbmcgc3VicmVjdGFuZ2xlIG9mIGl0cyBvcmlnaW5cbiAgICAgICAgLy8gYW5kIHRoZSBjb3JuZXIgb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgIGxldCBwYWRkaW5nID0gNDA7XG4gICAgICAgIC8vIEZpcnN0LCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGFic29sdXRlIHRvcCBjb3JuZXJcbiAgICAgICAgLy8gbG9jYXRpb25zIGZvciB0aGUgZWxlbWVudFxuICAgICAgICBsZXQgZWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5jdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBsZXQgdG9wID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICB3aGlsZShlbCl7XG4gICAgICAgICAgICB0b3AgKz0gZWwub2Zmc2V0VG9wO1xuICAgICAgICAgICAgbGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBoZWlnaHRMaW1pdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgLSBwYWRkaW5nO1xuICAgICAgICBpZigocmVjdC5oZWlnaHQgKyB0b3ApID4gaGVpZ2h0TGltaXQpe1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gKGhlaWdodExpbWl0IC0gdG9wKSAvIHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gdGhpcy5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodCAqIHJhdGlvfXB4YDtcbiAgICAgICAgICAgIC8vIHRoaXMuc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRoICogcmF0aW99cHhgO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgICAocmVjdC53aWR0aCAqIHJhdGlvKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgICAgIChyZWN0LmhlaWdodCAqIHJhdGlvKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQuIEhlcmUgd2UgYWRkIGEgY3VzdG9tIGJ1dHRvblxuICAgICAgICAvLyB3aGVuIHNob3dpbmcuXG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZighZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChmb3VuZEhhbG8pO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kSGFsby5hcHBlbmQodGhpcy5oYWxvQnV0dG9uKTtcbiAgICB9XG5cbiAgICBvbkhhbG9SZXNpemUobW92ZW1lbnRYLCBtb3ZlbWVudFkpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAgICAvLyBXZSByZXNpemUgdGhlIHdyYXBwZWQgc3ZnIG9yIGltZyBpbnN0ZWFkXG4gICAgICAgIC8vIGFuZCBoYXZlIHRoZSBvdXRlciBjb21wb25lbnQgc2ltcGx5IHJlYWN0IHRvXG4gICAgICAgIC8vIHRoZSBjaGFuZ2UuXG4gICAgICAgIC8vIElmIHRoZSBwYXJ0IGlzIHJvdGF0ZWQgdGhpcyB3aWxsIHRocm93IG9mZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgIC8vIGJyb3dzZXIgY2FsY3VhbHRpb24uIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gcm90YXRlIHRoZSBwYXJ0IHRvIDBcbiAgICAgICAgLy8gKGlmIG5lY2Vzc2FyeSkgZG8gdGhlIGNhbGN1bGF0aW9ucyBhbmQgdGhlbiByb3RhdGUgaXQgYmFja1xuICAgICAgICBsZXQgYW5nbGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIik7XG4gICAgICAgIGlmKGFuZ2xlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd3JhcHBlZEltYWdlID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuY3VycmVudGx5LXdyYXBwZWQnKTtcbiAgICAgICAgbGV0IHJlY3QgPSB3cmFwcGVkSW1hZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBuZXdXaWR0aCwgbmV3SGVpZ2h0O1xuICAgICAgICBpZih0aGlzLnByZXNlcnZlQXNwZWN0T25SZXNpemUpe1xuICAgICAgICAgICAgbGV0IG1heFdpZHRoID0gcmVjdC53aWR0aCArIG1vdmVtZW50WDtcbiAgICAgICAgICAgIGxldCBtYXhIZWlnaHQgPSByZWN0LmhlaWdodCArIG1vdmVtZW50WTtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IE1hdGgubWluKG1heFdpZHRoIC8gcmVjdC53aWR0aCwgbWF4SGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiByYXRpbztcbiAgICAgICAgICAgIG5ld1dpZHRoID0gcmVjdC53aWR0aCAqIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3V2lkdGggPSByZWN0LndpZHRoICsgbW92ZW1lbnRYO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyBtb3ZlbWVudFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihuZXdXaWR0aCAmJiBuZXdIZWlnaHQpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgICAgIG5ld0hlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0aGUgcm90YXRlIGFuZ2xlIHRvIHRoZSBvcmlnaW5hbCAoaWYgbmVjZXNzYXJ5KVxuICAgICAgICBpZihhbmdsZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIiwgYW5nbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b24oKXtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pZCA9ICdoYWxvLWltYWdlLWxpbmsnO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlubmVySFRNTCA9IGxpbmtJY29uO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luVG9wID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdyaWdodC1jb2x1bW4nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnRWRpdCBsaW5rIGZvciBpbWFnZSBmaWxlJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudXBkYXRlSW1hZ2VMaW5rKTtcbiAgICB9XG5cbiAgICBhZGRDb250ZXh0TWVudUl0ZW1zKGNvbnRleHRNZW51KXtcbiAgICAgICAgY29udGV4dE1lbnUuYWRkU3BhY2VyKCk7XG4gICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgJ0VkaXQgSW1hZ2UgVVJMJyxcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2VMaW5rXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBJbWFnZVZpZXcsXG4gICAgSW1hZ2VWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFBhcnRWaWV3XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGFuICphYnN0cmFjdCogd2ViY29tcG9lbnQgQ3VzdG9tRWxlbWVudFxuICogdGhhdCBzZXJ2ZXMgYXMgdGhlIGdlbmVyaWMgdmlldyBmb3IgYW55IFBhcnRcbiAqIG1vZGVscy5cbiAqIEkgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIG5vciBzaG91bGRcbiAqIEkgYmUgYWRkZWQgdG8gYW55IHdlYiBwYWdlJ3MgcmVnaXN0cnkgb2YgQ3VzdG9tRWxlbWVudHMuXG4gKiBJIGFtIGluZGVuZGVkIHRvIGJlIGV4dGVuZGVkIChzdWJjbGFzc2VkKSBieSB0aGUgYWN0dWFsXG4gKiB2aWV3cyBmb3IgZWFjaCBQYXJ0IGtpbmQsIGFuZCB0aGVyZWZvcmUgSSBjb250YWluIGFsbFxuICogb2YgdGhlIGNvbW1vbiBiZWhhdmlvciwgaW5jbHVkaW5nIGxpZmVjeWNsZSBtZXRob2RzLFxuICogZm9yIHRoZXNlLlxuICovXG5pbXBvcnQgQ29udGV4dE1lbnUgZnJvbSAnLi9jb250ZXh0bWVudS9Db250ZXh0TWVudS5qcyc7XG5pbXBvcnQgaW50ZXJwcmV0ZXJTZW1hbnRpY3MgZnJvbSAnLi4vLi4vb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyc7XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0LWNvbnRleHQtbWVudScsIENvbnRleHRNZW51KTtcblxuY2xhc3MgUGFydFZpZXcgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNQYXJ0VmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMZW5zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLnByb3BDaGFuZ2VIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNldHVwQmFzZVByb3BIYW5kbGVycygpO1xuICAgICAgICB0aGlzLnZpZXdDaGFuZ2VIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNldHVwQmFzZVZpZXdDaGFuZ2VIYW5kbGVycygpO1xuXG4gICAgICAgIC8vIEhhbG8gc2V0dGluZ3MuIEFsbCBhcmUgb24gYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLndhbnRzSGFsb1Jlc2l6ZSA9IHRydWU7XG4gICAgICAgIHRoaXMud2FudHNIYWxvUm90YXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG9TY3JpcHRFZGl0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG9FZGl0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG9EZWxldGUgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IHRydWU7XG4gICAgICAgIC8vIE5vdGU6IHNlZSBnZXR0ZXIgZm9yIHdhbnRzSGFsb01vdmVcblxuICAgICAgICAvLyBDb250ZXh0IG1lbnUgc2V0dGluZ3NcbiAgICAgICAgdGhpcy53YW50c0NvbnRleHRNZW51ID0gdHJ1ZTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0TW9kZWwgPSB0aGlzLnNldE1vZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudW5zZXRNb2RlbCA9IHRoaXMudW5zZXRNb2RlbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlID0gdGhpcy5zZW5kTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwQmFzZVByb3BIYW5kbGVycyA9IHRoaXMuc2V0dXBCYXNlUHJvcEhhbmRsZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBCYXNlVmlld0NoYW5nZUhhbmRsZXJzID0gdGhpcy5zZXR1cEJhc2VWaWV3Q2hhbmdlSGFuZGxlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0TGF5b3V0ID0gdGhpcy5pbml0TGF5b3V0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBpbml0aWFsIHByb3BlcnR5IG1ldGhvZFxuICAgICAgICB0aGlzLnN0eWxlQ1NTID0gdGhpcy5zdHlsZUNTUy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0eWxlVGV4dENTUyA9IHRoaXMuc3R5bGVUZXh0Q1NTLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBwcm9wZXJ0eSBjaGFuZ2UgcmVhY3Rpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLnByaW1IYW5kbGVQcm9wQ2hhbmdlID0gdGhpcy5wcmltSGFuZGxlUHJvcENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSA9IHRoaXMub25Qcm9wQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJpbUhhbmRsZVZpZXdDaGFuZ2UgPSB0aGlzLnByaW1IYW5kbGVWaWV3Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25WaWV3Q2hhbmdlID0gdGhpcy5vblZpZXdDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY3JpcHRDaGFuZ2VkID0gdGhpcy5zY3JpcHRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGF5b3V0Q2hhbmdlZCA9IHRoaXMubGF5b3V0Q2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxpc3REaXJlY3Rpb25DaGFuZ2VkID0gdGhpcy5saXN0RGlyZWN0aW9uQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxpc3RXcmFwcGluZ0NoYW5nZWQgPSB0aGlzLmxpc3RXcmFwcGluZ0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy52UmVzaXppbmdDaGFuZ2VkID0gdGhpcy52UmVzaXppbmdDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaFJlc2l6aW5nQ2hhbmdlZCA9IHRoaXMuaFJlc2l6aW5nQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpbm5pbmdMZWZ0Q2hhbmdlZCA9IHRoaXMucGlubmluZ0xlZnRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlubmluZ1RvcENoYW5nZWQgPSB0aGlzLnBpbm5pbmdUb3BDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlubmluZ0JvdHRvbUNoYW5nZWQgPSB0aGlzLnBpbm5pbmdCb3R0b21DaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlubmluZ1JpZ2h0Q2hhbmdlZCA9IHRoaXMucGlubmluZ1JpZ2h0Q2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxpc3RBbGlnbm1lbnRDaGFuZ2VkID0gdGhpcy5saXN0QWxpZ25tZW50Q2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxpc3REaXN0cmlidXRpb25DaGFuZ2VkID0gdGhpcy5saXN0RGlzdHJpYnV0aW9uQ2hhbmdlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgdmlldyBjaGFuZ2UgcmVhY3Rpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQgPSB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXdTdWJwYXJ0VmlldyA9IHRoaXMubmV3U3VicGFydFZpZXcuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIEhhbG8gcmVsYXRlZCBtZXRob2RzXG4gICAgICAgIHRoaXMub3BlbkhhbG8gPSB0aGlzLm9wZW5IYWxvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2VIYWxvID0gdGhpcy5jbG9zZUhhbG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9EZWxldGUgPSB0aGlzLm9uSGFsb0RlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb09wZW5FZGl0b3IgPSB0aGlzLm9uSGFsb09wZW5FZGl0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9PcGVuU2NyaXB0RWRpdG9yID0gdGhpcy5vbkhhbG9PcGVuU2NyaXB0RWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvUmVzaXplID0gdGhpcy5vbkhhbG9SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9Sb3RhdGUgPSB0aGlzLm9uSGFsb1JvdGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1Bhc3RlID0gdGhpcy5vbkhhbG9QYXN0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb0NvcHkgPSB0aGlzLm9uSGFsb0NvcHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9UYXJnZXQgPSB0aGlzLm9uSGFsb1RhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuZEhhbG9UYXJnZXQgPSB0aGlzLmVuZEhhbG9UYXJnZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUVudGVyID0gdGhpcy5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VMZWF2ZSA9IHRoaXMub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayA9IHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvT3BlbkVkaXRvciA9IHRoaXMub25IYWxvT3BlbkVkaXRvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQXV4Q2xpY2sgPSB0aGlzLm9uQXV4Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Db250ZXh0TWVudUNsaWNrID0gdGhpcy5vbkNvbnRleHRNZW51Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVRhcmdldEtleSA9IHRoaXMuaGFuZGxlVGFyZ2V0S2V5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VDbGljayA9IHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3ZlciA9IHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdXQgPSB0aGlzLmhhbmRsZVRhcmdldE1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRDb250ZXh0TWVudUl0ZW1zID0gdGhpcy5hZGRDb250ZXh0TWVudUl0ZW1zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFRhcmdldFZpZXdzID0gdGhpcy5nZXRDdXJyZW50VGFyZ2V0Vmlld3MuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIGVkaXRvciByZWxhdGVkIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vcGVuRWRpdG9yID0gdGhpcy5vcGVuRWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IgPSB0aGlzLmNsb3NlRWRpdG9yLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQ29udGV4dCBtZW51XG4gICAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51QXQgPSB0aGlzLm9wZW5Db250ZXh0TWVudUF0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSA9IHRoaXMuY2xvc2VDb250ZXh0TWVudS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIG1pc2NcbiAgICAgICAgdGhpcy5oaWdobGlnaHQgPSB0aGlzLmhpZ2hsaWdodC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0ID0gdGhpcy51bmhpZ2hsaWdodC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgbGlmZWN5Y2xlIG1ldGhvZHNcbiAgICAgICAgdGhpcy5hZnRlck1vZGVsU2V0ID0gdGhpcy5hZnRlck1vZGVsU2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWZ0ZXJNb2RlbFVuc2V0ID0gdGhpcy5hZnRlck1vZGVsVW5zZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZnRlckNvbm5lY3RlZCA9IHRoaXMuYWZ0ZXJDb25uZWN0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZnRlckRpc2Nvbm5lY3RlZCA9IHRoaXMuYWZ0ZXJEaXNjb25uZWN0ZWQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIC8vIERvIHNvbWUgdW5pdmVyc2FsIFBhcnRWaWV3IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIC8vIHdoZW4gYXR0YWNoZWQgdG8gYSBwYXJlbnQgZWxlbWVudCwgbGlrZVxuICAgICAgICAgICAgLy8gcmVnaXN0ZXJpbmcgZXZlbnQgbGlzdGVuZXJzIGV0Y1xuXG4gICAgICAgICAgICAvLyBSZWdpc3RlciBtaWRkbGUgbW91c2UgYnV0dG9uIGNsaWNrXG4gICAgICAgICAgICAvLyB0byB0b2dnbGUgdGhlIGhhbG9cbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYXV4Y2xpY2snLCB0aGlzLm9uQXV4Q2xpY2spO1xuXG4gICAgICAgICAgICAvLyBSZWdpc3RlciBkZWZhdWx0IGV2ZW50IGhhbmRsZXJzIG1hbnVhbGx5XVxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBsaWZlY3ljbGUgbWV0aG9kIHdoZW4gZG9uZVxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYWJvdmVcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJDb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYXV4Y2xpY2snLCB0aGlzLm9uQXV4Q2xpY2spO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICAgICAgdGhpcy5hZnRlckRpc2Nvbm5lY3RlZCgpO1xuICAgIH1cblxuICAgIHNldE1vZGVsKGFNb2RlbCl7XG4gICAgICAgIHRoaXMudW5zZXRNb2RlbCgpO1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICBhTW9kZWwuYWRkUHJvcGVydHlTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICBhTW9kZWwuYWRkVmlld1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIGlmKHRoaXMuaXNMZW5zZWQpe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnLCBhTW9kZWwuaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3BhcnQtaWQnLCBhTW9kZWwuaWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCAnc3BlY2lhbCcgcHJvcHNcbiAgICAgICAgbGV0IHdhbnRzTW92ZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcIndhbnRzLW1vdmVcIlxuICAgICAgICApO1xuICAgICAgICBpZih3YW50c01vdmUpe1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvYWQgYWxsIHRoZSBpbml0aWFsIHN0eWxpbmdcbiAgICAgICAgdGhpcy5zdHlsZUNTUygpO1xuICAgICAgICB0aGlzLnN0eWxlVGV4dENTUygpO1xuICAgICAgICB0aGlzLmluaXRMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5hZnRlck1vZGVsU2V0KCk7XG4gICAgfVxuXG4gICAgdW5zZXRNb2RlbCgpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIGxldCByZW1vdmVkTW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5yZW1vdmVQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdwYXJ0LWlkJywgXCJcIik7XG4gICAgICAgICAgICB0aGlzLmFmdGVyTW9kZWxVbnNldChyZW1vdmVkTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0dXBCYXNlUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgd2Ugc2hvdWxkIHNldHVwIGFueVxuICAgICAgICAvLyBwcm9wIGNoYW5nZSBoYW5kbGVycyB0aGF0IGFyZSB1bml2ZXJzYWxcbiAgICAgICAgLy8gdG8gYWxsIFBhcnRWaWV3cy4gV2Ugd291bGQgZG8gdGhpcyB2aWFcbiAgICAgICAgLy8gdGhlICNvblByb3BDaGFuZ2UgbWV0aG9kLCB3aGljaCByZWdpc3RlcnNcbiAgICAgICAgLy8gYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHRoZSB1bml2ZXJzYWxzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdzY3JpcHQnLCB0aGlzLnNjcmlwdENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbnVtYmVyJywgdGhpcy5udW1iZXJDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2Nzc1N0eWxlJywgdGhpcy5zdHlsZUNTUyk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjc3NUZXh0U3R5bGUnLCB0aGlzLnN0eWxlVGV4dENTUyk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdsYXlvdXQnLCB0aGlzLmxheW91dENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbGlzdC1kaXJlY3Rpb24nLCB0aGlzLmxpc3REaXJlY3Rpb25DaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2xpc3Qtd3JhcHBpbmcnLCB0aGlzLmxpc3RXcmFwcGluZ0NoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbGlzdC1hbGlnbm1lbnQnLCB0aGlzLmxpc3RBbGlnbm1lbnRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2xpc3QtZGlzdHJpYnV0aW9uJywgdGhpcy5saXN0RGlzdHJpYnV0aW9uQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdob3Jpem9udGFsLXJlc2l6aW5nJywgdGhpcy5oUmVzaXppbmdDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3ZlcnRpY2FsLXJlc2l6aW5nJywgdGhpcy52UmVzaXppbmdDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Bpbm5pbmctdG9wJywgdGhpcy5waW5uaW5nVG9wQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdwaW5uaW5nLXJpZ2h0JywgdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Bpbm5pbmctbGVmdCcsIHRoaXMucGlubmluZ0xlZnRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3Bpbm5pbmctYm90dG9tJywgdGhpcy5waW5uaW5nQm90dG9tQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCd3YW50cy1tb3ZlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZih2YWx1ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0dXBCYXNlVmlld0NoYW5nZUhhbmRsZXJzKCl7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgd2Ugc2hvdWxkIHNldHVwIGFueVxuICAgICAgICAvLyB2aWV3IGNoYW5nZSBoYW5kbGVycyB0aGF0IGFyZSB1bml2ZXJzYWxcbiAgICAgICAgLy8gdG8gYWxsIFBhcnRWaWV3cy4gV2Ugd291bGQgZG8gdGhpcyB2aWFcbiAgICAgICAgLy8gdGhlICNvblZpZXdDaGFuZ2UgbWV0aG9kLCB3aGljaCByZWdpc3RlcnNcbiAgICAgICAgLy8gYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2RcbiAgICAgICAgdGhpcy5vblZpZXdDaGFuZ2UoJ3N1YnBhcnQtb3JkZXInLCB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uVmlld0NoYW5nZSgnc3VicGFydC1uZXcnLCB0aGlzLm5ld1N1YnBhcnRWaWV3KTtcbiAgICB9XG5cbiAgICBpbml0TGF5b3V0KCl7XG4gICAgICAgIC8vIE5vdCBhbGwgUGFydC9QYXJ0VmlldyBwYWlycyBoYXZlIHRoZSBsYXlvdXRcbiAgICAgICAgLy8gcHJvcGVydGllcy4gRW5zdXJlIHRoZXkgZXhpc3QgZmlyc3RcbiAgICAgICAgbGV0IGhhc0xheW91dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoJ2xheW91dCcpO1xuICAgICAgICBsZXQgaGFzQm94UmVzaXppbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCd2ZXJ0aWNhbC1yZXNpemluZycpO1xuICAgICAgICBsZXQgaGFzUGlubmluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoJ3Bpbm5pbmcnKTtcbiAgICAgICAgaWYoaGFzTGF5b3V0KXtcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGF5b3V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2xheW91dCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbExpc3REaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnbGlzdC1kaXJlY3Rpb24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxMaXN0V3JhcHBpbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnbGlzdC13cmFwcGluZydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmxheW91dENoYW5nZWQoaW5pdGlhbExheW91dCk7XG4gICAgICAgICAgICB0aGlzLmxpc3REaXJlY3Rpb25DaGFuZ2VkKGluaXRpYWxMaXN0RGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubGlzdFdyYXBwaW5nQ2hhbmdlZChpbml0aWFsTGlzdFdyYXBwaW5nKTtcbiAgICAgICAgICAgIHRoaXMubGlzdEFsaWdubWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdERpc3RyaWJ1dGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGhhc0JveFJlc2l6aW5nKXtcbiAgICAgICAgICAgIGxldCBpbml0aWFsVlJlc2l6aW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3ZlcnRpY2FsLXJlc2l6aW5nJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsSFJlc2l6aW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2hvcml6b250YWwtcmVzaXppbmcnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy52UmVzaXppbmdDaGFuZ2VkKGluaXRpYWxWUmVzaXppbmcpO1xuICAgICAgICAgICAgdGhpcy5oUmVzaXppbmdDaGFuZ2VkKGluaXRpYWxIUmVzaXppbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaGFzUGlubmluZyl7XG4gICAgICAgICAgICB0aGlzLnBpbm5pbmdUb3BDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnBpbm5pbmdCb3R0b21DaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnBpbm5pbmdMZWZ0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdHlsZUNTUygpe1xuICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJjc3NTdHlsZVwiKTtcbiAgICAgICAgT2JqZWN0LmtleXMoY3NzU3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY3NzU3R5bGVba2V5XTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdHlsZVRleHRDU1MoKXtcbiAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwiY3NzVGV4dFN0eWxlXCIpO1xuICAgICAgICBPYmplY3Qua2V5cyhjc3NTdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjc3NTdHlsZVtrZXldO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0YXJnZXQpe1xuICAgICAgICBpZighdGhpcy5pc0xlbnNlZCl7XG4gICAgICAgICAgICAvLyBMZW5zZWQgdmlld3Mgc2hvdWxkIG5vdCBzZW5kIG1lc3NhZ2VzXG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLnNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0aGlzLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVjZWl2ZU1lc3NhZ2UoYU1lc3NhZ2Upe1xuICAgICAgICBzd2l0Y2goYU1lc3NhZ2UudHlwZSl7XG4gICAgICAgIGNhc2UgJ3Byb3BlcnR5Q2hhbmdlZCc6XG4gICAgICAgICAgICB0aGlzLnByaW1IYW5kbGVQcm9wQ2hhbmdlKFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLnByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS5wYXJ0SWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmlld0NoYW5nZWQnOlxuICAgICAgICAgICAgdGhpcy5wcmltSGFuZGxlVmlld0NoYW5nZShcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS5jaGFuZ2VOYW1lLFxuICAgICAgICAgICAgICAgIC4uLmFNZXNzYWdlLmFyZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaW1IYW5kbGVQcm9wQ2hhbmdlKG5hbWUsIHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICAvLyBXZSBub3RpZnkgdGhlIG1vZGVsIHRoYXQgdGhlIHByb3BlcnR5IGNoYW5nZSBzbyB0aGF0XG4gICAgICAgIC8vIG9uIHByb3BlcnR5Q2hhbmdlZCBjb21tYW5kIGhhbmRsZXJzIGNvdWxkIGJlIGludm9rZWRcbiAgICAgICAgLy8gYnV0IHdlIG1ha2Ugc3VyZSB0aGF0IHRoaXMgc3RvcHMgYXQgdGhlIHNhaWQgbW9kZWwgYW5kXG4gICAgICAgIC8vIGRvZXMgbm90IGdvIHVwIHRoZSBkZWxlZ2F0aW9uIGNoYWluXG4gICAgICAgIGxldCBjb21tYW5kTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAncHJvcGVydHlDaGFuZ2VkJyxcbiAgICAgICAgICAgIGFyZ3M6IFtuYW1lLCB2YWx1ZV0sXG4gICAgICAgICAgICBzaG91bGROb3REZWxlZ2F0ZTp0cnVlLCAvLyBkbyBub3Qgc2VuZCB0aGlzIHVwIHRoZSBkZWxlZ2F0aW9uIGNoYWluXG4gICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShjb21tYW5kTWVzc2FnZSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBuYW1lZFxuICAgICAgICAvLyBwcm9wZXJ0eS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIGRvIG5vdGhpbmdcbiAgICAgICAgbGV0IGhhbmRsZXIgPSB0aGlzLnByb3BDaGFuZ2VIYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgaWYoIWhhbmRsZXIpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodmFsdWUsIHBhcnRJZCk7XG4gICAgfVxuXG5cbiAgICBvblByb3BDaGFuZ2UobmFtZSwgZnVuYyl7XG4gICAgICAgIHRoaXMucHJvcENoYW5nZUhhbmRsZXJzW25hbWVdID0gZnVuYztcbiAgICB9XG5cbiAgICBwcmltSGFuZGxlVmlld0NoYW5nZShuYW1lLCAuLi5hcmdzKXtcbiAgICAgICAgLy8gRmluZCB0aGUgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5hbWVkXG4gICAgICAgIC8vIHByb3BlcnR5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgZG8gbm90aGluZ1xuICAgICAgICBsZXQgaGFuZGxlciA9IHRoaXMudmlld0NoYW5nZUhhbmRsZXJzW25hbWVdO1xuICAgICAgICBpZighaGFuZGxlcil7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gaGFuZGxlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgICBvblZpZXdDaGFuZ2UobmFtZSwgZnVuYyl7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZUhhbmRsZXJzW25hbWVdID0gZnVuYztcbiAgICB9XG5cbiAgICBzY3JpcHRDaGFuZ2VkKHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBhcmUgb25seSBzZW5kaW5nIHRoZSBjb21waWxlXG4gICAgICAgIC8vIG1lc3NhZ2Ugd2hlbiBkZWFsaW5nIHdpdGggYSAnY29yZScgc3QtcGFydCB2aWV3cyAobm90XG4gICAgICAgIC8vIHdpdGggbmF2aWdhdG9yIG9yIHJlbGF0ZWQgdmlld3MpXG4gICAgICAgIGlmKHRoaXMudGFnTmFtZS5zcGxpdChcIi1cIilbMF0gIT0gXCJTVFwiIHx8IHRoaXMuc2xvdCA9PSBcIndyYXBwZWQtdmlld1wiKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21waWxlJyxcbiAgICAgICAgICAgIGNvZGVTdHJpbmc6IHZhbHVlLFxuICAgICAgICAgICAgdGFyZ2V0SWQ6IHBhcnRJZFxuICAgICAgICB9LCB3aW5kb3cuU3lzdGVtKTtcbiAgICB9XG5cbiAgICBzdWJwYXJ0T3JkZXJDaGFuZ2VkKGlkLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4KXtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBkbyBhbnl0aGluZyBmb3IgdGhlIHdyYXBwZWQgdmlld3NcbiAgICAgICAgLy8gQ2FyZFJvdyBhbmQgU3RhY2tSb3cgd2lsbCBoYW5kbGUgdGhlIHVwZGF0ZXNcbiAgICAgICAgaWYodGhpcy5uYW1lID09IFwiV3JhcHBlZFZpZXdcIil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnBhcnROb2RlID0gdGhpcy5jaGlsZE5vZGVzW2N1cnJlbnRJbmRleF07XG4gICAgICAgIGlmKG5ld0luZGV4ID09IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3VicGFydE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhY2NvdW50IGZvciB3aGV0aGVyIHRoZSBpbmRleCBvZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIG5ld0luZGV4XG4gICAgICAgICAgICBpZihjdXJyZW50SW5kZXggPCBuZXdJbmRleCl7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tuZXdJbmRleF07XG4gICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShzdWJwYXJ0Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdTdWJwYXJ0VmlldyhuZXdWaWV3KXtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdWaWV3KTtcbiAgICB9XG5cbiAgICBsYXlvdXRDaGFuZ2VkKHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICBpZih2YWx1ZSA9PSAnbGlzdCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdsaXN0LWxheW91dCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdsaXN0LWxheW91dCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdERpcmVjdGlvbkNoYW5nZWQodmFsdWUsIHBhcnRJZCl7XG4gICAgICAgIC8vIFJvdyBpcyB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIGZvciBhIGxpc3QgbGF5b3V0LCBzbyBvbmx5IG9uZSBleHRyYVxuICAgICAgICAvLyBDU1MgY2xhc3MgbmVlZHMgdG8gYmUgdG9nZ2xlZFxuICAgICAgICBpZih2YWx1ZSA9PSAncm93Jyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3QtY29sdW1uJyk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAnY29sdW1uJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3QtY29sdW1uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0V3JhcHBpbmdDaGFuZ2VkKHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICBpZih2YWx1ZSA9PSB0cnVlKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnd3JhcC1saXN0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3dyYXAtbGlzdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaFJlc2l6aW5nQ2hhbmdlZCh2YWx1ZSl7XG4gICAgICAgIGlmKHZhbHVlID09ICdzcGFjZS1maWxsJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2gtc3BhY2UtZmlsbCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICdoLXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAnaC1zaHJpbmstd3JhcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAnc2hyaW5rLXdyYXAnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaC1zaHJpbmstd3JhcCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICdoLXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAnaC1zcGFjZS1maWxsJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlID09ICdyaWdpZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoLXJpZ2lkJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ2gtc3BhY2UtZmlsbCcsXG4gICAgICAgICAgICAgICAgJ2gtc2hyaW5rLXdyYXAnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdlJlc2l6aW5nQ2hhbmdlZCh2YWx1ZSl7XG4gICAgICAgIGlmKHZhbHVlID09ICdzcGFjZS1maWxsJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Ytc3BhY2UtZmlsbCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICd2LXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAndi1zaHJpbmstd3JhcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAnc2hyaW5rLXdyYXAnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgndi1zaHJpbmstd3JhcCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICd2LXJpZ2lkJyxcbiAgICAgICAgICAgICAgICAndi1zcGFjZS1maWxsJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlID09ICdyaWdpZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd2LXJpZ2lkJyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgJ3Ytc3BhY2UtZmlsbCcsXG4gICAgICAgICAgICAgICAgJ3Ytc2hyaW5rLXdyYXAnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ1RvcENoYW5nZWQoKXtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAncGlubmluZy10b3AnXG4gICAgICAgICk7XG4gICAgICAgIGlmKHRvcCl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Bpbi10b3AnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncGluLXRvcCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ0xlZnRDaGFuZ2VkKCl7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdwaW5uaW5nLWxlZnQnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGxlZnQpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwaW4tbGVmdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdwaW4tbGVmdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ1JpZ2h0Q2hhbmdlZCgpe1xuICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3Bpbm5pbmctcmlnaHQnXG4gICAgICAgICk7XG4gICAgICAgIGlmKHJpZ2h0KXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGluLXJpZ2h0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Bpbi1yaWdodCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGlubmluZ0JvdHRvbUNoYW5nZWQoKXtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAncGlubmluZy1ib3R0b20nXG4gICAgICAgICk7XG4gICAgICAgIGlmKGJvdHRvbSl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Bpbi1ib3R0b20nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncGluLWJvdHRvbScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdEFsaWdubWVudENoYW5nZWQoKXtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdsaXN0LWFsaWdubWVudCdcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHZhbGlkID0gW1xuICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICdyaWdodCcsXG4gICAgICAgICAgICAnY2VudGVyJ1xuICAgICAgICBdO1xuICAgICAgICBpZih2YWxpZC5pbmNsdWRlcyh2YWx1ZSkpe1xuICAgICAgICAgICAgdmFsaWQuZm9yRWFjaChzaWRlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoYGxpc3QtYWxpZ24tJHtzaWRlfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoYGxpc3QtYWxpZ24tJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxpc3REaXN0cmlidXRpb25DaGFuZ2VkKCl7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbGlzdC1kaXN0cmlidXRpb24nXG4gICAgICAgICk7XG4gICAgICAgIGxldCB2YWxpZCA9IFtcbiAgICAgICAgICAgICdzdGFydCcsXG4gICAgICAgICAgICAnZW5kJyxcbiAgICAgICAgICAgICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICdzcGFjZS1hcm91bmQnLFxuICAgICAgICAgICAgJ2NlbnRlcidcbiAgICAgICAgXTtcbiAgICAgICAgaWYodmFsaWQuaW5jbHVkZXModmFsdWUpKXtcbiAgICAgICAgICAgIHZhbGlkLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGBsaXN0LWRpc3RyaWJ1dGlvbi0ke3NpZGV9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChgbGlzdC1kaXN0cmlidXRpb24tJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIExpZmVjeWNsZSBNZXRob2QgRGVmYXVsdHMgKi9cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsVW5zZXQocmVtb3ZlZE1vZGVsKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBieSBkZWZhdWx0LlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzXG4gICAgfVxuXG4gICAgLyogSGFsbyBSZWxhdGVkIE1ldGhvZHMgKi9cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgaGFsbyBpblxuICAgICAgICAvLyB0aGUgY29tcG9uZW50J3Mgc2hhZG93IHJvb3QgYWxyZWFkeVxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBsZXQgbmV3SGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChuZXdIYWxvKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlSGFsbygpe1xuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsby5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZUFudHNCb3JkZXIoKXtcbiAgICAgICAgaWYodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ21hcmNoaW5nLWFudHMnKSl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ21hcmNoaW5nLWFudHMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbWFyY2hpbmctYW50cycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25IYWxvRGVsZXRlKCl7XG4gICAgICAgIC8vIFdoYXQgdG8gZG8gd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlXG4gICAgICAgIC8vIGRlbGV0ZSBidXR0b24gb24gYSBoYWxvIGZvciB0aGlzIHBhcnR2aWV3LlxuICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyB0byBzZW5kIGEgbWVzc2FnZVxuICAgICAgICAvLyB0byB0aGUgU3lzdGVtIHRvIGRlbGV0ZSB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAvLyBtb2RlbCBhbmQgKmFsbCogdmlld3MgcmVmZXJlbmNpbmcgdGhhdFxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ2RlbGV0ZU1vZGVsJyxcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLm1vZGVsLmlkXVxuICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbkhhbG9PcGVuU2NyaXB0RWRpdG9yKCl7XG4gICAgICAgIC8vIFNlbmQgdGhlIG1lc3NhZ2UgdG8gb3BlbiBhIHNjcmlwdCBlZGl0b3JcbiAgICAgICAgLy8gd2l0aCB0aGlzIHZpZXcncyBtb2RlbCBhcyB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLm1vZGVsLmlkXVxuICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbkhhbG9PcGVuRWRpdG9yKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uZWRpdG9yLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgd2luZG93LlN5c3RlbS5lZGl0b3Iub3BlbigpO1xuICAgIH1cblxuICAgIG9uSGFsb1Jlc2l6ZShtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb24gd2hhdCB0byBkbyBkdXJpbmdcbiAgICAgICAgLy8gaGFsbyBidXR0b24gcmVzaXplIG9wZXJ0YXRpb25zLiBTdWJjbGFzc2VzXG4gICAgICAgIC8vIGNhbiBvdmVycmlkZSBmb3IgY3VzdG9tIGJlaGF2aW9yLlxuICAgICAgICAvLyBEZWZhdWx0IGlzIHRvIHVwZGF0ZSB0aGUgVmlldyBjb21wb25lbnQnc1xuICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHN0eWxlIHByb3BlcnRpZXMgZGlyZWN0bHkuXG4gICAgICAgIC8vIElmIHRoZSBwYXJ0IGlzIHJvdGF0ZWQgdGhpcyB3aWxsIHRocm93IG9mZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgIC8vIGJyb3dzZXIgY2FsY3VhbHRpb24uIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gcm90YXRlIHRoZSBwYXJ0IHRvIDBcbiAgICAgICAgLy8gKGlmIG5lY2Vzc2FyeSkgZG8gdGhlIGNhbGN1bGF0aW9ucyBhbmQgdGhlbiByb3RhdGUgaXQgYmFja1xuICAgICAgICBsZXQgYW5nbGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIik7XG4gICAgICAgIGlmKGFuZ2xlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBuZXdXaWR0aCwgbmV3SGVpZ2h0O1xuICAgICAgICBpZih0aGlzLnByZXNlcnZlQXNwZWN0T25SZXNpemUpe1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGh5cCA9IE1hdGguc3FydCgobW92ZW1lbnRYKioyKSArIChtb3ZlbWVudFkqKjIpKTtcbiAgICAgICAgICAgIGlmKG1vdmVtZW50WCA8IDAgfHwgbW92ZW1lbnRZIDwgMCl7XG4gICAgICAgICAgICAgICAgaHlwID0gaHlwICogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSByZWN0LmhlaWdodCArIGh5cDtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gcmVjdC53aWR0aCArIGh5cDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gbW92ZW1lbnRYICsgcmVjdC53aWR0aDtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IG1vdmVtZW50WSArIHJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcIndpZHRoXCIsIG5ld1dpZHRoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiaGVpZ2h0XCIsIG5ld0hlaWdodCk7XG4gICAgICAgIC8vIHJlc2V0IHRoZSByb3RhdGUgYW5nbGUgdG8gdGhlIG9yaWdpbmFsIChpZiBuZWNlc3NhcnkpXG4gICAgICAgIGlmKGFuZ2xlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkhhbG9Sb3RhdGUobW92ZW1lbnRYLCBtb3ZlbWVudFkpe1xuICAgICAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9uIHdoYXQgdG8gZG8gZHVyaW5nXG4gICAgICAgIC8vIGhhbG8gYnV0dG9uIHJvdGF0ZSBvcGVydGF0aW9ucy4gU3ViY2xhc3Nlc1xuICAgICAgICAvLyBjYW4gb3ZlcnJpZGUgZm9yIGN1c3RvbSBiZWhhdmlvci5cbiAgICAgICAgLy8gRGVmYXVsdCBpcyB0byB1cGRhdGUgdGhlIFZpZXcgY29tcG9uZW50J3NcbiAgICAgICAgLy8gcm90YXRlIHN0eWxlIHByb3BlcnR5IGRpcmVjdGx5LlxuICAgICAgICBpZihtb3ZlbWVudFggfHwgbW92ZW1lbnRZKXtcbiAgICAgICAgICAgIGxldCBjdXJyZW50QW5nbGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIik7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZighY3VycmVudEFuZ2xlKXtcbiAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRoZXRhMSA9IE1hdGguYXRhbigocmVjdC5oZWlnaHQvMikvKHJlY3Qud2lkdGgvMikpO1xuICAgICAgICAgICAgbGV0IHRoZXRhMiA9IE1hdGguYXRhbigocmVjdC5oZWlnaHQvMiArIG1vdmVtZW50WSkvKHJlY3Qud2lkdGgvMiArIG1vdmVtZW50WCkpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZUFuZ2xlID0gTWF0aC5hYnMoKHRoZXRhMiAtIHRoZXRhMSkqMTgwL01hdGguUEkpO1xuICAgICAgICAgICAgbGV0IG5ld0FuZ2xlID0gKGN1cnJlbnRBbmdsZSArIGNoYW5nZUFuZ2xlKSAlIDM2MDtcbiAgICAgICAgICAgIGlmKG5ld0FuZ2xlIDwgMCl7XG4gICAgICAgICAgICAgICAgbmV3QW5nbGUgPSAzNjAgKyBuZXdBbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG5ld0FuZ2xlKXtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIiwgbmV3QW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25IYWxvQ29weSgpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5jb3B5UGFydCh0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbkhhbG9QYXN0ZSgpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5wYXN0ZUNvbnRlbnRzSW50byh0aGlzLm1vZGVsKTtcbiAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICB9XG5cbiAgICBvbkhhbG9UYXJnZXQoZXZlbnQpe1xuICAgICAgICAvLyBBZGQgdGFyZ2V0aW5nIHJlY2VpdmUgbGlzdGVuZXJzIHRvIGFsbCBQYXJ0Vmlld3NcbiAgICAgICAgLy8gb24gdGhlIGN1cnJlbnQgY2FyZC5cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja1ZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suaWR9XCJdYCk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suY3VycmVudENhcmQuaWR9XCJdYCk7XG4gICAgICAgIGxldCB0YXJnZXRDYXJkUGFydHMgPSBBcnJheS5mcm9tKGN1cnJlbnRDYXJkVmlldy5xdWVyeVNlbGVjdG9yQWxsKCdbcGFydC1pZF0nKSk7XG4gICAgICAgIGxldCB0YXJnZXRTdGFja1BhcnRzID0gQXJyYXkuZnJvbShjdXJyZW50U3RhY2tWaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ1twYXJ0LWlkXTpub3Qoc3QtY2FyZCk6bm90KHN0LXN0YWNrKScpKTtcbiAgICAgICAgbGV0IGFsbFRhcmdldHMgPSB0YXJnZXRDYXJkUGFydHMuY29uY2F0KHRhcmdldFN0YWNrUGFydHMpO1xuICAgICAgICBhbGxUYXJnZXRzLmZvckVhY2gocGFydFZpZXcgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlVGFyZ2V0S2V5KTtcbiAgICAgICAgICAgIHBhcnRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdmVyKTtcbiAgICAgICAgICAgIHBhcnRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU91dCk7XG4gICAgICAgICAgICBwYXJ0Vmlldy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VDbGljayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3RhcmdldGluZy1tb2RlJyk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIG9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlRW50ZXIoKXtcbiAgICAgICAgLy8gbGlnaHQgdXAgdGhlIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFRhcmdldFZpZXdzKCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy5oaWdobGlnaHQoXCJyZ2IoNTQsIDE3MiwgMTAwKVwiKTsgLy9ncmVlblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUxlYXZlKCl7XG4gICAgICAgIC8vIGxpZ2h0IHVwIHRoZSBjdXJyZW50IHRhcmdldFxuICAgICAgICB0aGlzLmdldEN1cnJlbnRUYXJnZXRWaWV3cygpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0KGNvbG9yKXtcbiAgICAgICAgaWYodGhpcy5uYW1lICE9IFwiU3RhY2tWaWV3XCIgJiYgdGhpcy5uYW1lICE9IFwiV29ybGRWaWV3XCIpe1xuICAgICAgICAgICAgdGhpcy5fdGVtcEJhY2tncm91bmRDb2xvciA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtY29sb3JcIik7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBCYWNrZ3JvdW5kVHJhbnNwYXJlbmN5ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIik7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeVwiLCAxKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdW5oaWdobGlnaHQoKXtcbiAgICAgICAgaWYodGhpcy5uYW1lICE9IFwiU3RhY2tWaWV3XCIgJiYgdGhpcy5uYW1lICE9IFwiV29ybGRWaWV3XCIpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC1jb2xvclwiLCB0aGlzLl90ZW1wQmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtdHJhbnNwYXJlbmN5XCIsIHRoaXMuX3RlbXBCYWNrZ3JvdW5kVHJhbnNwYXJlbmN5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZEhhbG9UYXJnZXQoKXtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0YXJnZXRpbmcgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdGhhdCB3ZXJlIGFkZGVkIGR1cmluZyB0aGUgb25IYWxvVGFyZ2V0XG4gICAgICAgIC8vIGhhbmRsZXJcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja1ZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suaWR9XCJdYCk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7d2luZG93LlN5c3RlbS53b3JsZC5jdXJyZW50U3RhY2suY3VycmVudENhcmQuaWR9XCJdYCk7XG4gICAgICAgIGxldCB0YXJnZXRDYXJkUGFydHMgPSBBcnJheS5mcm9tKGN1cnJlbnRDYXJkVmlldy5xdWVyeVNlbGVjdG9yQWxsKCdbcGFydC1pZF0nKSk7XG4gICAgICAgIGxldCB0YXJnZXRTdGFja1BhcnRzID0gQXJyYXkuZnJvbShjdXJyZW50U3RhY2tWaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ1twYXJ0LWlkXTpub3Qoc3QtY2FyZCk6bm90KHN0LXN0YWNrKScpKTtcbiAgICAgICAgbGV0IGFsbFRhcmdldHMgPSB0YXJnZXRDYXJkUGFydHMuY29uY2F0KHRhcmdldFN0YWNrUGFydHMpO1xuICAgICAgICBhbGxUYXJnZXRzLmZvckVhY2gocGFydFZpZXcgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlVGFyZ2V0S2V5KTtcbiAgICAgICAgICAgIHBhcnRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZVRhcmdldEtleSk7XG4gICAgICAgICAgICBwYXJ0Vmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3Zlcik7XG4gICAgICAgICAgICBwYXJ0Vmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdXQpO1xuICAgICAgICAgICAgcGFydFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlQ2xpY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd0YXJnZXRpbmctbW9kZScpO1xuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldEtleShldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmtleSA9PSAnRXNjYXBlJyl7XG4gICAgICAgICAgICB0aGlzLmVuZEhhbG9UYXJnZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldE1vdXNlT3ZlcihldmVudCl7XG4gICAgICAgIGlmKCFldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXRpbmcnKSl7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgndGFyZ2V0aW5nJyk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuaGlnaGxpZ2h0KFwicmdiKDIzNCwgNTUsIDU1KVwiKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50LnRhcmdldC5vbkNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldE1vdXNlTGVhdmUoZXZlbnQpe1xuICAgICAgICBpZihldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXRpbmcnKSl7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgndGFyZ2V0aW5nJyk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudW5oaWdobGlnaHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50LnRhcmdldC5vbkNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhcmdldE1vdXNlQ2xpY2soZXZlbnQpe1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiBldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3RhcmdldGluZycpO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3RhcmdldCcsXG4gICAgICAgICAgICBldmVudC50YXJnZXQubW9kZWwuaWRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbmRIYWxvVGFyZ2V0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC50YXJnZXQudW5oaWdobGlnaHQoKTtcbiAgICAgICAgZXZlbnQudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQudGFyZ2V0Lm9uQ2xpY2spO1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRUYXJnZXRWaWV3cygpe1xuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgY3VycmVudCB0YXJnZXRcbiAgICAgICAgbGV0IGN1cnJlbnRUYXJnZXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJ0YXJnZXRcIik7XG4gICAgICAgIGlmKGN1cnJlbnRUYXJnZXQpe1xuICAgICAgICAgICAgbGV0IHNlbWFudGljcyA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJTZW1hbnRpY3ModGhpcy5tb2RlbCwgd2luZG93LlN5c3RlbSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgbSA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5tYXRjaChjdXJyZW50VGFyZ2V0LCBcIk9iamVjdFNwZWNpZmllclwiKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IHNlbWFudGljcyhtKS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBvbkNvbnRleHRNZW51Q2xpY2soZXZlbnQpe1xuICAgICAgICBpZih0aGlzLndhbnRzQ29udGV4dE1lbnUpe1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaWYodGhpcy5jb250ZXh0TWVudUlzT3Blbil7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51QXQoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNsaWVudFlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkF1eENsaWNrKGV2ZW50KXtcbiAgICAgICAgLy8gU2hvdWxkIG9ubHkgb3BlbiBoYWxvIHdoZW4gbWlkZGxlXG4gICAgICAgIC8vIG1vdXNlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAxKXtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy5jb250ZXh0TWVudUlzT3Blbil7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiBldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25IYWxvQWN0aXZhdGlvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy53YW50c0hhbG8pe1xuICAgICAgICAgICAgaWYodGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBhbnkgb3RoZXIgb3BlbiBIYWxvc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBhdXRvbWF0aWNhbGx5IGNsb3NlIHRoZW1cbiAgICAgICAgICAgICAgICBsZXQgZXhTZWxlY3RvciA9IGAuZWRpdGluZzpub3QoW3BhcnQtaWQ9XCIke3RoaXMubW9kZWwuaWR9XCJdKWA7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGV4U2VsZWN0b3IpKS5mb3JFYWNoKG9wZW5IYWxvRWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcGVuSGFsb0VsLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgb3BlbiBvbiB0aGlzIHZpZXdcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5IYWxvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlRG93bihldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwICYmICFldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3ZlJyxcbiAgICAgICAgICAgIGFyZ3M6IFtldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WV1cbiAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb3BlbkNvbnRleHRNZW51QXQoeCwgeSl7XG4gICAgICAgIGxldCBtZW51RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1jb250ZXh0LW1lbnUnKTtcbiAgICAgICAgbWVudUVsLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgbWVudUVsLnN0eWxlLmxlZnQgPSBgJHt4fXB4YDtcbiAgICAgICAgbWVudUVsLnN0eWxlLnRvcCA9IGAke3l9cHhgO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChtZW51RWwpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBtZW51IGlzIGNvbXBsZXRlbHlcbiAgICAgICAgLy8gd2l0aGluIHRoZSBjdXJyZW50IHZpZXcuIElmIG5vdCAobWVhbmluZ1xuICAgICAgICAvLyBpdCBpcyBjbGlwcGVkKSwgdGhlbiBhZGp1c3Qgc28gaXQgaXNcbiAgICAgICAgLy8gY29tcGxldGVseSBpbiB0aGUgdmlldy5cbiAgICAgICAgbWVudUVsLmFkanVzdFRvQ2xpZW50VmlldygpO1xuICAgIH1cblxuICAgIGNsb3NlQ29udGV4dE1lbnUoKXtcbiAgICAgICAgbGV0IGZvdW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtY29udGV4dC1tZW51Jyk7XG4gICAgICAgIGlmKGZvdW5kKXtcbiAgICAgICAgICAgIGZvdW5kLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ29udGV4dE1lbnVJdGVtcyhjb250ZXh0TWVudSl7XG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIHRvXG4gICAgICAgIC8vIGRvIG5vdGhpbnMuXG4gICAgICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIGFuZCB1c2UgdGhlXG4gICAgICAgIC8vIHBhc3NlZC1pbiBjb250ZXh0TWVudSBvYmplY3QgdG8gY29uc3RydWN0XG4gICAgICAgIC8vIGxpc3QgaXRlbXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhlaXIgbmVlZHNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldCB3YW50c0hhbG9Nb3ZlKCl7XG4gICAgICAgIGlmKCF0aGlzLnBhcmVudEVsZW1lbnQgfHwgIXRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50RWxlbWVudC5tb2RlbDtcbiAgICAgICAgaWYoIXBhcmVudE1vZGVsKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhc0xheW91dCA9IHBhcmVudE1vZGVsLnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgcGFyZW50TW9kZWwsXG4gICAgICAgICAgICAnbGF5b3V0J1xuICAgICAgICApO1xuXG4gICAgICAgIGlmKCFoYXNMYXlvdXQpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyZW50TGF5b3V0ID0gcGFyZW50TW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHBhcmVudE1vZGVsLFxuICAgICAgICAgICAgJ2xheW91dCdcbiAgICAgICAgKTtcbiAgICAgICAgaWYocGFyZW50TGF5b3V0ID09PSAnc3RyaWN0JyB8ICFwYXJlbnRMYXlvdXQgfHwgcGFyZW50TGF5b3V0ID09IFwiXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRleHRNZW51SXNPcGVuKCl7XG4gICAgICAgIGxldCBmb3VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LWNvbnRleHQtbWVudScpO1xuICAgICAgICBpZihmb3VuZCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyogRWRpdG9yIHJlbGF0ZWQgbWV0aG9kcyAqL1xuICAgIG9wZW5FZGl0b3IoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAgIH1cblxuICAgIGNsb3NlRWRpdG9yKCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBieSBkZWZhdWx0LlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnRWaWV3LFxuICAgIFBhcnRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IGxpbmtJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxpbmtcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEwIDE0YTMuNSAzLjUgMCAwIDAgNSAwbDQgLTRhMy41IDMuNSAwIDAgMCAtNSAtNWwtLjUgLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDEwYTMuNSAzLjUgMCAwIDAgLTUgMGwtNCA0YTMuNSAzLjUgMCAwIDAgNSA1bC41IC0uNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuOmhvc3Qge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHBhZGRpbmc6IDFweDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLndyYXBwZXJ7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbn1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwid3JhcHBlclwiPlxuICAgIDxzcGFuIGNsYXNzPVwibmFtZVwiPjwvc3Bhbj5cbiAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItYnVpbGRpbmctYnJpZGdlLTJcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICAgPHBhdGggZD1cIk02IDdoMTJhMiAyIDAgMCAxIDIgMnY5YTEgMSAwIDAgMSAtMSAxaC0yYTEgMSAwIDAgMSAtMSAtMXYtMmE0IDQgMCAwIDAgLTggMHYyYTEgMSAwIDAgMSAtMSAxaC0yYTEgMSAwIDAgMSAtMSAtMXYtOWEyIDIgMCAwIDEgMiAtMlwiPjwvcGF0aD5cbiAgICA8L3N2Zz5cbjwvZGl2PlxuYDtcblxuY2xhc3MgUmVzb3VyY2VWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyBkb21cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVSZXNvdXJjZUxpbmsgPSB0aGlzLnVwZGF0ZVJlc291cmNlTGluay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluZGljYXRlUmVhZHlTdGF0ZSA9IHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgaWYoIXRoaXMuaGFsb0J1dHRvbil7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gaWYgdGhlIHJlc291cmNlTmFtZSBwcm9wZXJ0eSBpcyBzZXQgdGhlbiBtYWtlIHN1cmUgaXQgaXMgbG9hZGVkXG4gICAgICAgIC8vIFRPRE86IGkgZG9uJ3QgbGlrZSB0aGlzIHZpZXcgYXNraW5nIHRoZSBtb2RlbCB0byBsb2FkIVxuICAgICAgICBsZXQgcmVzb3VyY2VOYW1lID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicmVzb3VyY2VOYW1lXCIpO1xuICAgICAgICBpZihyZXNvdXJjZU5hbWUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5sb2FkUmVzb3VyY2UoW3RoaXNdLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJzcmNcIik7XG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldFNvdXJjZVRvKFt0aGlzXSwgc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZVNwYW4gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKTtcbiAgICAgICAgbmFtZVNwYW4uaW5uZXJUZXh0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwibmFtZVwiKTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwicmVhZHlTdGF0ZVwiLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmluZGljYXRlUmVhZHlTdGF0ZShzdGF0ZSk7XG4gICAgICAgIC8vIHByb3AgY2hhbmdlc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcIm5hbWVcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuYW1lU3Bhbi5pbm5lclRleHQgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwicmVhZHlTdGF0ZVwiLCB0aGlzLmluZGljYXRlUmVhZHlTdGF0ZSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwic3JjXCIsICh1cmwpID0+IHtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgdGhlIG9uIGNsaWNrIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNsaWNrIGNvbW1hbmQgbWVzc2FnZSB0byBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRpY2F0ZVJlYWR5U3RhdGUodmFsdWUpe1xuICAgICAgICBsZXQgYm9yZGVyQ29sb3IgPSBcInJlZFwiO1xuICAgICAgICBpZih2YWx1ZSA9PSBcImZldGNoaW5nXCIpe1xuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBcInllbGxvd1wiO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT0gXCJyZWFkeVwiKXtcbiAgICAgICAgICAgIGJvcmRlckNvbG9yID0gXCJncmVlblwiO1xuICAgICAgICB9O1xuICAgICAgICBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl0uZm9yRWFjaCgoc2lkZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIGBib3JkZXItJHtzaWRlfS1jb2xvcmAsIGJvcmRlckNvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9CdXR0b24pO1xuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9uKCl7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaWQgPSAnaGFsby1yZXNvdXJjZS1saW5rJztcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBsaW5rSWNvbjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnN0eWxlLm1hcmdpblRvcCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAncmlnaHQtY29sdW1uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0VkaXQgbGluayBmb3IgcmVzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVSZXNvdXJjZUxpbmspO1xuICAgIH1cblxuICAgIHVwZGF0ZVJlc291cmNlTGluayhldmVudCl7XG4gICAgICAgIC8vIFRlbGxzIHRoZSBtb2RlbCB0byB1cGRhdGUgaXRzXG4gICAgICAgIC8vIHNyYyBsaW5rIGZvciB0aGUgcmVzb3VyY2VcbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3NyYydcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoXCJFZGl0IFVSTCBmb3IgcmVzb3VyY2U6XCIsIGN1cnJlbnRTcmMpO1xuICAgICAgICBpZihyZXN1bHQgJiYgcmVzdWx0ICE9PSAnJyAmJiByZXN1bHQgIT09IGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdsb2FkUmVzb3VyY2UnLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbIHJlc3VsdCBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG5cbmV4cG9ydCB7XG4gICAgUmVzb3VyY2VWaWV3LFxuICAgIFJlc291cmNlVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTdGFja1ZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBXZWJjb21wb25lbnQgKGN1c3RvbSBlbGVtZW50KSByZXByZXNlbnRpbmdcbiAqIHRoZSB2aWV3IG9mIGEgU3RhY2suXG4gKiBJIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAqIHdoZW4gSSBhbSBiZWluZyBkaXNwbGF5ZWQuXG4gKiBNeSBjaGlsZCBlbGVtZW50cyBhcmUgQmFja2dyb3VuZFZpZXcgYW5kIENhcmRWaWV3XG4gKi9cblxuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4uL3BhcnRzL1N0YWNrLmpzJztcblxuLy8gYnkgZGVmYXVsdCwgc3RhY2tzIGFyZSBoaWRkZW4gdW5sZXNzIHRoZXkncmVcbi8vIHRoZSBjdXJyZW50IHN0YWNrLCBvciBlbHNlIHRoZXkgaGF2ZSB0aGUgY2xhc3Ncbi8vIHdpbmRvdy1zdGFjayAoc3VnZ2VzdGluZyB0aGVyZSdzIHdpbmRvdyBwYXJ0XG4vLyB3aG8gd2lzaGVzIHRvIGRpc3BsYXkgaXQpXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGA8c2xvdD48L3Nsb3Q+YDtcblxuY2xhc3MgU3RhY2tWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGluZyBhbmQgc2hhZG93IGRvbVxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBIYWxvIHNldHRpbmdzLiBDYXJkcyBkb24ndCB3YW50XG4gICAgICAgIC8vYSBoYWxvIHRvIG9wZW5cbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBIYW5kbGUgY3VycmVudC1uZXNzIHByb3AgY2hhbmdlXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlID0gdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICAvLyBEbyBhbiBpbml0aWFsIHNldHRpbmcgb2YgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgY2FyZFxuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDdXJyZW50Q2hhbmdlKCl7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBwcm9wIGlzIHRoZSBjYXJkIElEXG4gICAgICAgIC8vIG9mIHRoZSBjaGlsZCBDYXJkIHRoYXQgc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBjdXJyZW50IG9uZS4gV2UgcmVtb3ZlIHRoZSBjdXJyZW50LWNhcmQgY2xhc3MgZnJvbVxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgY3VycmVudCBjYXJkIGFuZCBhZGQgaXQgdG8gdGhlIG5ldyBvbmUuXG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMucXVlcnlTZWxlY3RvcignLmN1cnJlbnQtY2FyZCcpO1xuICAgICAgICBsZXQgbmV4dEN1cnJlbnRJZCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHNob3VsZE5vdGlmeSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VsZWN0b3IgPSBgOnNjb3BlID4gc3QtY2FyZFtwYXJ0LWlkPVwiJHtuZXh0Q3VycmVudElkfVwiXWA7XG4gICAgICAgIGlmKHRoaXMuaXNMZW5zZWQpe1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBgOnNjb3BlID4gc3QtY2FyZFtsZW5zLXBhcnQtaWQ9XCIke25leHRDdXJyZW50SWR9XCJdYDtcbiAgICAgICAgICAgIHNob3VsZE5vdGlmeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDdXJyZW50Q2FyZCA9IHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGN1cnJlbnRDYXJkIGFuZCBubyBuZXh0IGN1cnJlbnRDYXJkIHdlIHNldCBpdCB0byBiZSB0aGUgZmlyc3RcbiAgICAgICAgLy8gY2FyZCBjaGlsZCAodGhpcyBjYW4gaGFwcGVuIHdoZW4gbmV3IGlkcyBhcmUgY3JlYXRlZCBvbiBkZXNlcmlhbGl6YXRpb24gYW5kIHNvXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHByb3BlcnR5IHN0b3JlZCBpZCBpcyBubyBsb25nZXIgcmVsZXZhbnQpXG4gICAgICAgIGlmKCFuZXh0Q3VycmVudENhcmQgJiYgIWN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIG5leHRDdXJyZW50Q2FyZCA9IHRoaXMucXVlcnlTZWxlY3RvcihgOnNjb3BlID4gc3QtY2FyZGApO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGNhcmRzIGF0IGFsbCwgdGhpcyBtdXN0IGJlIGEgYnJhbmQgbmV3IHN0YWNrXG4gICAgICAgICAgICBpZighbmV4dEN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICAgICAgICBuZXh0Q3VycmVudENhcmQuaWQsXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90aWZ5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmKG5leHRDdXJyZW50Q2FyZCl7XG4gICAgICAgICAgICBuZXh0Q3VycmVudENhcmQuY2xhc3NMaXN0LmFkZCgnY3VycmVudC1jYXJkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudENhcmQgJiYgY3VycmVudENhcmQgIT0gbmV4dEN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIGN1cnJlbnRDYXJkLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQtY2FyZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgc3ViY2xhc3MgbWV0aG9kc1xuICAgIG5ld1N1YnBhcnRWaWV3KG5ld1ZpZXcpe1xuICAgICAgICBpZih0aGlzLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5ld1ZpZXcubmFtZSA9PSBcIkNhcmRWaWV3XCIpe1xuICAgICAgICAgICAgbGV0IGxhc3RDYXJkTm9kZTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGNoaWxkLm5hbWUgPT0gXCJDYXJkVmlld1wiKXtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENhcmROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZihsYXN0Q2FyZE5vZGUpe1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBhZnRlciB0aGUgbGFzdCBjYXJkXG4gICAgICAgICAgICAgICAgbGFzdENhcmROb2RlLmFmdGVyKG5ld1ZpZXcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGVyZSBhcmUgbm8gY2FyZHNcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmVmb3JlIGFsbCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS5pbnNlcnRCZWZvcmUobmV3Vmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld1ZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5leHBvcnQge1xuICAgIFN0YWNrVmlldyxcbiAgICBTdGFja1ZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogV2luZG93Vmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSB0aGUgdmlldyBvZiBhIFdpbmRvdyBQYXJ0LlxuICogV2luZG93cyBhcmUgd3JhcHBlcnMgZm9yIFN0YWNrcy9TdGFja1ZpZXdzIHRoYXRcbiAqIGFwcGVhciBhcyB0aGUgc3VicGFydHMgb2Ygb3RoZXIgU3RhY2tzIG9yIENhcmRzLlxuICogVGhleSBhcmUgZXhhbXBsZXMgb2YgaG93IHdlIGNhbiB1c2Ugc3RhY2sgYW5kIGNhcmRcbiAqIGNvbXBvc2l0aW9uIHRvIGNyZWF0ZSBtb3JlIGNvbXBsZXggVUlzLlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbiAqIHtcbiAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiB9XG5cbiAuc3Qtd2luZG93LWJhciB7XG4gICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgIHdpZHRoOiAxMDAlO1xuICAgICBtaW4taGVpZ2h0OiAyNXB4O1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjE4LCAyMTgsIDIxOCk7XG4gICAgIHBhZGRpbmctbGVmdDogOHB4O1xuICAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XG4gICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gfVxuIC5zdC13aW5kb3ctYnV0dG9uIHtcbiAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgIHdpZHRoOiAxMnB4O1xuICAgICBoZWlnaHQ6IDEycHg7XG4gICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAxNTAsIDE1MCk7XG4gICAgIG1hcmdpbi1yaWdodDogNHB4O1xuIH1cbiAuY2xvc2UtYnV0dG9uIHtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDUwLCA1MCwgMC40KTtcbiB9XG4gLnNoYWRlLWJ1dHRvbiB7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDAuIDAuNCk7XG4gfVxuIC5leHBhbmQtYnV0dG9uIHtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNTAsIDI1NSwgMCwgMC44KTtcbiB9XG4gLnN0LXdpbmRvdy1wYW5lIHtcbiAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgbWluLWhlaWdodDogNTBweDtcbiAgICAgZmxleDogMTtcbiB9XG4gLnN0LXdpbmRvdy1wYW5lLnNoYWRlZCB7XG4gICAgIGRpc3BsYXk6IG5vbmU7XG4gfVxuIC5zdC13aW5kb3ctZ3JpcHBlciB7XG4gICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgIHRvcDogY2FsYygxMDAlIC0gMTVweCk7XG4gICAgIHdpZHRoOiAzMHB4O1xuICAgICBoZWlnaHQ6IDMwcHg7XG4gfVxuIC5zdC13aW5kb3ctdGl0bGUge1xuICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgIG1heC13aWR0aDogNzAlO1xuIH1cbiAucmlnaHQtZ3JpcHBlciB7XG4gICAgIGxlZnQ6IGNhbGMoMTAwJSAtIDE1cHgpO1xuIH1cbiAucmlnaHQtZ3JpcHBlcjpob3ZlciB7XG4gICAgIGN1cnNvcjogbndzZS1yZXNpemU7XG4gfVxuIC5sZWZ0LWdyaXBwZXIge1xuICAgICByaWdodDogY2FsYygxMDAlIC0gMTVweCk7XG4gfVxuIC5sZWZ0LWdyaXBwZXI6aG92ZXIge1xuICAgICBjdXJzb3I6IG5lc3ctcmVzaXplO1xuIH1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwic3Qtd2luZG93LWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYnV0dG9uIGNsb3NlLWJ1dHRvblwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYnV0dG9uIHNoYWRlLWJ1dHRvblwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYnV0dG9uIGV4cGFuZC1idXR0b25cIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic3Qtd2luZG93LXRpdGxlXCI+XG4gICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1wYW5lXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwic3Qtd2luZG93LWdyaXBwZXIgcmlnaHQtZ3JpcHBlclwiIGRhdGEtZ3JpcC1lbmQ9XCJyaWdodFwiPjwvZGl2PlxuYDtcblxuY2xhc3MgV2luZG93VmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHZhciB0ZW1wbGF0ZUNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZUNvbnRlbnQpO1xuXG4gICAgICAgIHRoaXMubW91c2VEb3duSW5CYXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1NoYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHBhbmRDYWNoZSA9IHt9O1xuXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBncmlwcGluZyB0aGVcbiAgICAgICAgLy8gYm90dG9tIHJpZ2h0IGNvcm5lciBmb3IgYSByZXNpemVcbiAgICAgICAgdGhpcy5pc0dyaXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNldHVwQ2xpY2tBbmREcmFnID0gdGhpcy5zZXR1cENsaWNrQW5kRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwQmFyQnV0dG9ucyA9IHRoaXMuc2V0dXBCYXJCdXR0b25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBFeHBhbmRlckFyZWFzID0gdGhpcy5zZXR1cEV4cGFuZGVyQXJlYXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycyA9IHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUluQmFyID0gdGhpcy5vbk1vdXNlTW92ZUluQmFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZURvd25JbkJhciA9IHRoaXMub25Nb3VzZURvd25JbkJhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcEFmdGVyRHJhZyA9IHRoaXMub25Nb3VzZVVwQWZ0ZXJEcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU2hhZGUgPSB0aGlzLm9uU2hhZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkV4cGFuZCA9IHRoaXMub25FeHBhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkdyaXBEb3duID0gdGhpcy5vbkdyaXBEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25HcmlwVXAgPSB0aGlzLm9uR3JpcFVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25HcmlwTW92ZSA9IHRoaXMub25HcmlwTW92ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldHVwIHByb3AgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCd0aXRsZScsIHRoaXMuc2V0VGl0bGUpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIHRoaXMuc2V0dXBDbGlja0FuZERyYWcoKTtcbiAgICAgICAgdGhpcy5zZXR1cEJhckJ1dHRvbnMoKTtcbiAgICAgICAgdGhpcy5zZXR1cEV4cGFuZGVyQXJlYXMoKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMuc2V0VGl0bGUoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAndGl0bGUnXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0dXBDbGlja0FuZERyYWcoKXtcbiAgICAgICAgbGV0IGJhciA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnN0LXdpbmRvdy1iYXInKTtcbiAgICAgICAgYmFyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd25JbkJhcik7XG4gICAgfVxuXG4gICAgc2V0dXBCYXJCdXR0b25zKCl7XG4gICAgICAgIGxldCBjbG9zZUJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmNsb3NlLWJ1dHRvbicpO1xuICAgICAgICBsZXQgc2hhZGVCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zaGFkZS1idXR0b24nKTtcbiAgICAgICAgbGV0IGV4cGFuZEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmV4cGFuZC1idXR0b24nKTtcblxuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbG9zZSk7XG4gICAgICAgIHNoYWRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblNoYWRlKTtcbiAgICAgICAgZXhwYW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkV4cGFuZCk7XG4gICAgfVxuXG4gICAgc2V0dXBFeHBhbmRlckFyZWFzKCl7XG4gICAgICAgIGxldCBsb3dlclJpZ2h0ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcucmlnaHQtZ3JpcHBlcicpO1xuICAgICAgICBsb3dlclJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25HcmlwRG93bik7XG4gICAgfVxuXG4gICAgb25FeHBhbmQoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLmlzRXhwYW5kZWQpe1xuICAgICAgICAgICAgdGhpcy5zdHlsZS53aWR0aCA9IHRoaXMuZXhwYW5kQ2FjaGUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmhlaWdodCA9IHRoaXMuZXhwYW5kQ2FjaGUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZS50b3AgPSB0aGlzLmV4cGFuZENhY2hlLnRvcDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUubGVmdCA9IHRoaXMuZXhwYW5kQ2FjaGUubGVmdDtcbiAgICAgICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRDYWNoZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5zdHlsZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zdHlsZS50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zdHlsZS5sZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU2V0IG5ldyB2YWx1ZXMgYmFzZWQgb24gd2luZG93IHNpemVcbiAgICAgICAgICAgIHRoaXMuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gXCIxMDB2d1wiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCI7XG4gICAgICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25TaGFkZShldmVudCl7XG4gICAgICAgIGxldCBwYW5lID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3Qtd2luZG93LXBhbmUnKTtcbiAgICAgICAgaWYodGhpcy5pc1NoYWRlZCl7XG4gICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5yZW1vdmUoJ3NoYWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5pc1NoYWRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QuYWRkKCdzaGFkZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaXNTaGFkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DbG9zZShldmVudCl7XG4gICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ3dpbmRvd0Nsb3NlJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2UobXNnLCB0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlRG93bkluQmFyKGV2ZW50KXtcbiAgICAgICAgdGhpcy5tb3VzZURvd25JbkJhciA9IHRydWU7XG4gICAgICAgIGxldCBiYXIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVJbkJhcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcEFmdGVyRHJhZyk7XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwQWZ0ZXJEcmFnKGV2ZW50KXtcbiAgICAgICAgdGhpcy5tb3VzZURvd25JbkJhciA9IGZhbHNlO1xuICAgICAgICBsZXQgYmFyID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXBBZnRlckRyYWcpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlSW5CYXIpO1xuICAgIH1cblxuICAgIG9uTW91c2VNb3ZlSW5CYXIoZXZlbnQpe1xuICAgICAgICBsZXQgY3VycmVudFRvcCA9IHBhcnNlSW50KHRoaXMuc3R5bGUudG9wKTtcbiAgICAgICAgbGV0IGN1cnJlbnRMZWZ0ID0gcGFyc2VJbnQodGhpcy5zdHlsZS5sZWZ0KTtcbiAgICAgICAgLy8gbGV0IG5ld1RvcCA9IGAke2N1cnJlbnRUb3AgKyBldmVudC5tb3ZlbWVudFl9cHhgO1xuICAgICAgICAvLyBsZXQgbmV3TGVmdCA9IGAke2N1cnJlbnRMZWZ0ICsgZXZlbnQubW92ZW1lbnRYfXB4YDtcbiAgICAgICAgbGV0IG5ld1RvcCA9IGN1cnJlbnRUb3AgKyBldmVudC5tb3ZlbWVudFk7XG4gICAgICAgIGxldCBuZXdMZWZ0ID0gY3VycmVudExlZnQgKyBldmVudC5tb3ZlbWVudFg7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInRvcFwiLCBuZXdUb3ApO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJsZWZ0XCIsIG5ld0xlZnQpO1xuICAgIH1cblxuICAgIG9uR3JpcFVwKGV2ZW50KXtcbiAgICAgICAgdGhpcy5pc0dyaXBwaW5nID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25HcmlwTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uR3JpcFVwKTtcbiAgICB9XG5cbiAgICBvbkdyaXBEb3duKGV2ZW50KXtcbiAgICAgICAgdGhpcy5pc0dyaXBwaW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkdyaXBNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25HcmlwVXApO1xuICAgIH1cblxuICAgIG9uR3JpcE1vdmUoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLmlzR3JpcHBpbmcpe1xuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgY3VycmVudCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICAgICAgLy8gYW5kIHNldCB0aGUgcHJvcGVydHkgdG8gdGhlIG5ldyBvbmVcbiAgICAgICAgICAgIGxldCBib3ggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGV0IG5ld1dpZHRoID0gTWF0aC5mbG9vcihib3gud2lkdGgpICsgZXZlbnQubW92ZW1lbnRYO1xuICAgICAgICAgICAgaWYobmV3V2lkdGgpe1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcIndpZHRoXCIsIG5ld1dpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdIZWlnaHQgPSBNYXRoLmZsb29yKGJveC5oZWlnaHQpICsgZXZlbnQubW92ZW1lbnRZO1xuICAgICAgICAgICAgaWYobmV3SGVpZ2h0KXtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJoZWlnaHRcIiwgbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFRpdGxlKGFTdHJpbmcpe1xuICAgICAgICBsZXQgdGl0bGVBcmVhID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgJy5zdC13aW5kb3ctdGl0bGUgPiBzcGFuJ1xuICAgICAgICApO1xuICAgICAgICB0aXRsZUFyZWEuaW5uZXJUZXh0ID0gYVN0cmluZztcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSBzdWJjbGFzcyBtZXRob2RzXG4gICAgbmV3U3VicGFydFZpZXcobmV3Vmlldyl7XG4gICAgICAgIC8vIHNsb3QgdGhlIG5ldyB2aWV3IGludG8gdGhlIHdpbmRvdyBwYW5lXG4gICAgICAgIGxldCBwYW5lID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3Qtd2luZG93LXBhbmUnKTtcbiAgICAgICAgcGFuZS5hcHBlbmQobmV3Vmlldyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Vmlldyk7XG4gICAgfVxuXG5cbn07XG5cbmV4cG9ydCB7XG4gICAgV2luZG93VmlldyxcbiAgICBXaW5kb3dWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFdvcmxkVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgV2ViY29tcG9uZW50IChjdXN0b20gZWxlbWVudCkgdGhhdCByZXByZXNlbnRzXG4gKiBhIHZpZXcgb2YgYSBXb3JsZFN0YWNrIG1vZGVsLlxuICogTXkgZWxlbWVudCBjaGlsZHJlbiBzaG91bGQgY29udGFpbiBhIHNpbmdsZSBTdGFja1ZpZXcgcmVwcmVzZW50aW5nXG4gKiB0aGUgY3VycmVudCBkaXNwbGF5ZWQgc3RhY2sgKHRoaXMgY29tZXMgZnJvbSB0aGUgbW9kZWwpLlxuICogSSBhbSB0aGUgcm9vdC1sZXZlbCBlbGVtZW50IGZvciB0aGUgU2ltcGxlVGFsayBzeXN0ZW0gaW4gYSB3ZWJcbiAqIHBhZ2UuIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBvZiBtZSBvbiBhbnkgZ2l2ZW4gSFRNTCBwYWdlLlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYDxzbG90Pjwvc2xvdD5gO1xuXG5jb25zdCBOT0RFU19UT19JR05PUkVfV0hFTl9BUlJPV19LRVkgPSBbXG4gICAgJ1RFWFRBUkVBJyxcbiAgICAnSU5QVVQnLFxuICAgICdTVC1GSUVMRCdcbl07XG5cbmNsYXNzIFdvcmxkVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldCB1cCB0ZW1wbGF0aW5nIGFuZCBzaGFkb3cgZG9tXG4gICAgICAgIC8vIFRPRE86IFB1dCB0aGUgdGVtcGxhdGUgZGVmaW5pdGlvbiBpbiB0aGlzXG4gICAgICAgIC8vIG1vZHVsZSBhcyBmb3JtYXR0ZWQgdGV4dFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVGhlIHdvcmxkIG5ldmVyIHdhbnRzIGEgaGFsb1xuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50U3RhY2sgPSB0aGlzLnVwZGF0ZUN1cnJlbnRTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlID0gdGhpcy5yZWNlaXZlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUtleURvd24gPSB0aGlzLmhhbmRsZUtleURvd24uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBTZXR1cCBwcm9wIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb3BIYW5kbGVycygpe1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY3VycmVudCcsIHRoaXMudXBkYXRlQ3VycmVudFN0YWNrKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIERvIGFuIGluaXRpYWwgdXBkYXRlIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gdGhlIG1vZGVsJ3MgY3VycmVudCBzdGFja1xuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRTdGFjaygpO1xuICAgIH1cblxuICAgIHVwZGF0ZUN1cnJlbnRTdGFjaygpe1xuICAgICAgICAvLyBUaGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgcHJvcCBpcyB0aGUgc3RhY2sgSURcbiAgICAgICAgLy8gb2YgdGhlIGNoaWxkIFN0YWNrIHRoYXQgc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBjdXJyZW50IG9uZS4gV2UgcmVtb3ZlIHRoZSBjdXJyZW50LXN0YWNrIGNsYXNzIGZyb21cbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIGN1cnJlbnQgc3RhY2sgYW5kIGFkZCBpdCB0byB0aGUgbmV3IG9uZS5cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMucXVlcnlTZWxlY3RvcignLmN1cnJlbnQtc3RhY2snKTtcbiAgICAgICAgbGV0IG5leHRDdXJyZW50SWQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2N1cnJlbnQnXG4gICAgICAgICk7XG4gICAgICAgIGxldCBuZXh0Q3VycmVudFN0YWNrID0gdGhpcy5xdWVyeVNlbGVjdG9yKGA6c2NvcGUgPiBzdC1zdGFja1twYXJ0LWlkPVwiJHtuZXh0Q3VycmVudElkfVwiXWApO1xuICAgICAgICBpZihuZXh0Q3VycmVudFN0YWNrKXtcbiAgICAgICAgICAgIG5leHRDdXJyZW50U3RhY2suY2xhc3NMaXN0LmFkZCgnY3VycmVudC1zdGFjaycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvIHByZXZlbnQgdGhlIHNldHRpbmcgb2YgdGhlIHNhbWUgaWQgYXMgdGhlIGN1cnJlbnQgc3RhY2sgbWFrZSBzdXJlXG4gICAgICAgIC8vIG5leHQgYW5kIGN1cnJlbnQgYXJlIG5vdCB0aGUgc2FtZVxuICAgICAgICBpZihjdXJyZW50U3RhY2sgJiYgY3VycmVudFN0YWNrICE9IG5leHRDdXJyZW50U3RhY2spe1xuICAgICAgICAgICAgY3VycmVudFN0YWNrLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQtc3RhY2snKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUtleURvd24oZXZlbnQpe1xuICAgICAgICBpZihldmVudC5hbHRLZXkgJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC5jb2RlID09IFwiU3BhY2VcIil7XG4gICAgICAgICAgICBsZXQgbmF2aWdhdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtbmF2aWdhdG9yJyk7XG4gICAgICAgICAgICBuYXZpZ2F0b3IudG9nZ2xlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCaW5kIGFycm93IGtleSBldmVudHMgaWYgYW5kIG9ubHkgaWZcbiAgICAgICAgICAgIC8vIHRoZSBmb2N1cyBpcyBub3QgaW4gYW55IGtpbmQgb2YgdGV4dCBpbnB1dC5cbiAgICAgICAgICAgIC8vIFdlIHNlbmQgdGhlIGFycm93S2V5IGNvbW1hbmQgdG8gdGhlIGN1cnJlbnQgY2FyZFxuICAgICAgICAgICAgaWYoZXZlbnQuY29kZS5zdGFydHNXaXRoKCdBcnJvdycpKXtcbiAgICAgICAgICAgICAgICBpZighTk9ERVNfVE9fSUdOT1JFX1dIRU5fQVJST1dfS0VZLmluY2x1ZGVzKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2Fycm93S2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBhcmcgaXMgdGhlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNvZGUuc3BsaXQoJ0Fycm93JylbMV0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsLmN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgc3ViY2xhc3MgbWV0aG9kc1xuICAgIG5ld1N1YnBhcnRWaWV3KG5ld1ZpZXcpe1xuICAgICAgICBpZih0aGlzLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5ld1ZpZXcubmFtZSA9PSBcIlN0YWNrVmlld1wiKXtcbiAgICAgICAgICAgIGxldCBsYXN0U3RhY2tOb2RlO1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoY2hpbGQubmFtZSA9PSBcIlN0YWNrVmlld1wiKXtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YWNrTm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYobGFzdFN0YWNrTm9kZSl7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IHN0YWNrXG4gICAgICAgICAgICAgICAgbGFzdFN0YWNrTm9kZS5hZnRlcihuZXdWaWV3KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlcmUgYXJlIG5vIHN0YWNrc1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBiZWZvcmUgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLmluc2VydEJlZm9yZShuZXdWaWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Vmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmV4cG9ydCB7XG4gICAgV29ybGRWaWV3LFxuICAgIFdvcmxkVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLy8gUFJFQU1CTEVcbmltcG9ydCBDb250ZXh0TWVudUl0ZW0gZnJvbSAnLi9Db250ZXh0TWVudUl0ZW0uanMnO1xuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdC1jb250ZXh0LW1lbnUtaXRlbScsIENvbnRleHRNZW51SXRlbSk7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGJveC1zaGFkb3c6IDFweCAycHggMTBweCByZ2JhKDUwLCA1MCwgNTAsIDAuNyk7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgICAgICBtaW4td2lkdGg6IDIwMHB4O1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgfVxuXG4gICAgOmhvc3QtY29udGV4dChsaSkge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDEwMCU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgIH1cblxuICAgIDpob3N0LWNvbnRleHQobGkpOmhvdmVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG5cbiAgICBoZWFkZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuNSk7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XG4gICAgICAgIHBhZGRpbmctbGVmdDogMTZweDtcbiAgICAgICAgcGFkZGluZy10b3A6IDhweDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDhweDtcbiAgICB9XG5cbiAgICBoZWFkZXIgPiBoNCB7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIG1hcmdpbjowO1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBmb250LXNpemU6IDAuOHJlbTtcbiAgICB9XG5cbjwvc3R5bGU+XG48aGVhZGVyPlxuICAgIDxoND48L2g0PlxuPC9oZWFkZXI+XG48dWwgaWQ9XCJsaXN0LWl0ZW1zXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC91bD5cbmA7XG5cbmNsYXNzIENvbnRleHRNZW51IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5hZGRIYWxvVG9nZ2xlSXRlbSA9IHRoaXMuYWRkSGFsb1RvZ2dsZUl0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGROYXZpZ2F0b3JUb2dnbGVJdGVtID0gdGhpcy5hZGROYXZpZ2F0b3JUb2dnbGVJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkQ29weUFuZFBhc3RlSXRlbXMgPSB0aGlzLmFkZENvcHlBbmRQYXN0ZUl0ZW1zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkT3BlbkVkaXRvckl0ZW0gPSB0aGlzLmFkZE9wZW5FZGl0b3JJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkU2NyaXB0RWRpdEl0ZW0gPSB0aGlzLmFkZFNjcmlwdEVkaXRJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkTW92ZW1lbnRJdGVtcyA9IHRoaXMuYWRkTW92ZW1lbnRJdGVtcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFBhcnRTdWJtZW51ID0gdGhpcy5hZGRQYXJ0U3VibWVudS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZExpc3RJdGVtID0gdGhpcy5hZGRMaXN0SXRlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFNwYWNlciA9IHRoaXMuYWRkU3BhY2VyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGlkZUhlYWRlciA9IHRoaXMuaGlkZUhlYWRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkanVzdFRvQ2xpZW50VmlldyA9IHRoaXMuYWRqdXN0VG9DbGllbnRWaWV3LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcbiAgICAgICAgbGV0IGhlYWRlckVsID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdoZWFkZXIgPiBoNCcpO1xuICAgICAgICBsZXQgaGVhZGVyVGV4dCA9IGAke3RoaXMubW9kZWwudHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7dGhpcy5tb2RlbC50eXBlLnNsaWNlKDEpfWA7XG4gICAgICAgIGhlYWRlclRleHQgPSBgYSAke2hlYWRlclRleHR9YDtcbiAgICAgICAgaGVhZGVyRWwudGV4dENvbnRlbnQgPSBoZWFkZXJUZXh0O1xuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgZGVmYXVsdCBtZW51IGl0ZW1zXG4gICAgICAgIHRoaXMuYWRkSGFsb1RvZ2dsZUl0ZW0oKTtcbiAgICAgICAgdGhpcy5hZGRDb3B5QW5kUGFzdGVJdGVtcygpO1xuICAgICAgICB0aGlzLmFkZE9wZW5FZGl0b3JJdGVtKCk7XG4gICAgICAgIHRoaXMuYWRkUGFydFN1Ym1lbnUoKTtcbiAgICAgICAgdGhpcy5hZGRTY3JpcHRFZGl0SXRlbSgpO1xuICAgICAgICB0aGlzLmFkZE1vdmVtZW50SXRlbXMoKTtcbiAgICAgICAgdGhpcy5hZGROYXZpZ2F0b3JUb2dnbGVJdGVtKCk7XG5cbiAgICAgICAgLy8gQWRkIFZpZXctc3BlY2lmaWMgaXRlbXNcbiAgICAgICAgbGV0IHZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7dGhpcy5tb2RlbC5pZH1cIl1gKTtcbiAgICAgICAgdmlldy5hZGRDb250ZXh0TWVudUl0ZW1zKHRoaXMpO1xuICAgIH1cblxuICAgIGFkZExpc3RJdGVtKGxhYmVsLCBjYWxsYmFjaywgc3VibWVudT1udWxsKXtcbiAgICAgICAgbGV0IGl0ZW1FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWNvbnRleHQtbWVudS1pdGVtJyk7XG4gICAgICAgIGl0ZW1FbC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICBpdGVtRWwuY2xhc3NMaXN0LmFkZCgnY29udGV4dC1tZW51LWl0ZW0nKTtcbiAgICAgICAgaXRlbUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FsbGJhY2spO1xuICAgICAgICBpdGVtRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoc3VibWVudSl7XG4gICAgICAgICAgICBzdWJtZW51LmNsYXNzTGlzdC5hZGQoJ2NvbnRleHQtc3VibWVudScsICdzdWJtZW51LWhpZGRlbicpO1xuICAgICAgICAgICAgc3VibWVudS5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnc3VibWVudScpO1xuICAgICAgICAgICAgaXRlbUVsLmFwcGVuZChzdWJtZW51KTtcbiAgICAgICAgICAgIGl0ZW1FbC5zaG93Q2FyZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZChpdGVtRWwpO1xuICAgIH1cblxuICAgIGFkZEhhbG9Ub2dnbGVJdGVtKCl7XG4gICAgICAgIGxldCB0YXJnZXQgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZCh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgLy8gZG9uJ3QgYWRkIGhhbG8gb3B0aW9uIHRvIGNhcmRzLCBzaW5jZSB5b3UgY2FuJ3Qgc2VlIHRob3NlXG4gICAgICAgIGlmKHRhcmdldC5uYW1lICE9IFwiQ2FyZFZpZXdcIil7XG4gICAgICAgICAgICBpZih0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0aW5nJykpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICdDbG9zZSBIYWxvJyxcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICAnT3BlbiBIYWxvJyxcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQub3BlbkhhbG8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGROYXZpZ2F0b3JUb2dnbGVJdGVtKCl7XG4gICAgICAgIGxldCBuYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1uYXZpZ2F0b3InKTtcbiAgICAgICAgaWYobmF2LmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKXtcbiAgICAgICAgICAgIG5hdi5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJyk7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdDbG9zZSBOYXZpZ2F0b3InLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBuYXYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnT3BlbiBOYXZpZ2F0b3InLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBuYXYub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICBuYXYuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDb3B5QW5kUGFzdGVJdGVtcygpe1xuICAgICAgICAvLyBBZGQgY29weSBpdGVtXG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnQ29weScsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5jb3B5UGFydCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgcGFzdGUgYnV0IG9ubHkgaWY6XG4gICAgICAgIC8vIDEuIFRoZXJlIGlzIGNsaXBib2FyZCBjb250ZW50cztcbiAgICAgICAgLy8gMi4gVGhlIHBhcnQgdHlwZSBpbiB0aGUgY2xpcGJvYXJkIGlzXG4gICAgICAgIC8vICAgIG9uZSB0aGF0IGlzIGFjY2VwdGVkIGJ5IHRoaXMgbW9kZWwncyBwYXJ0XG4gICAgICAgIGlmKHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLmNvbnRlbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBsZXQgcGFydFR5cGUgPSB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5jb250ZW50c1swXS5wYXJ0VHlwZTtcbiAgICAgICAgICAgIGlmKHRoaXMubW9kZWwuYWNjZXB0c1N1YnBhcnQocGFydFR5cGUpKXtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBgUGFzdGUgKGEgJHtwYXJ0VHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7cGFydFR5cGUuc2xpY2UoMSl9KWA7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShsYWJlbCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xpcGJvYXJkLnBhc3RlQ29udGVudHNJbnRvKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkT3BlbkVkaXRvckl0ZW0oKXtcbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdPcGVuIEVkaXRvcicsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU3lzdGVtLm9wZW5FZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGFkZFNjcmlwdEVkaXRJdGVtKCl7XG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnRWRpdCBTY3JpcHQnLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMubW9kZWwuaWRdXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdFZGl0IFdvcmxkIFNjcmlwdCcsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbJ3dvcmxkJ11cbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgd2luZG93QW5jZXN0b3IgPSB0aGlzLm1vZGVsLmZpbmRBbmNlc3Rvck9mVHlwZSgnd2luZG93Jyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSAhPSAnd2luZG93JyAmJiB3aW5kb3dBbmNlc3RvciAhPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdFZGl0IE93bmluZyBXaW5kb3cgU2NyaXB0JyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3dpbmRvd0FuY2VzdG9yLmlkXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgY2FyZEFuY2VzdG9yID0gdGhpcy5tb2RlbC5maW5kQW5jZXN0b3JPZlR5cGUoJ2NhcmQnKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlICE9ICdjYXJkJyAmJiBjYXJkQW5jZXN0b3Ipe1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnRWRpdCBPd25pbmcgQ2FyZCBTY3JpcHQnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY2FyZEFuY2VzdG9yLmlkXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YWNrQW5jZXN0b3IgPSB0aGlzLm1vZGVsLmZpbmRBbmNlc3Rvck9mVHlwZSgnc3RhY2snKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlICE9ICdzdGFjaycgJiYgc3RhY2tBbmNlc3Rvcil7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdFZGl0IE93bmluZyBTdGFjayBTY3JpcHQnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbc3RhY2tBbmNlc3Rvci5pZF1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFBhcnRTdWJtZW51KCl7XG4gICAgICAgIC8vIEZpcnN0LCB3ZSBuZWVkIHRvIGdldCBhIGxpc3Qgb2YgbmFtZXNcbiAgICAgICAgLy8gb2Ygc3VicGFydHMgdGhhdCB0aGlzIG1vZGVsIGFjY2VwdHNcbiAgICAgICAgbGV0IHN1YnBhcnROYW1lcztcbiAgICAgICAgaWYodGhpcy5tb2RlbC5hY2NlcHRlZFN1YnBhcnRUeXBlc1swXSA9PSBcIipcIil7XG4gICAgICAgICAgICAvLyBUaGlzIG1vZGVsIGFjY2VwdHMgYWxsIHN1YnBhcnQgdHlwZXMuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCB0aGUgbmFtZXMgZm9yIHRoZXNlIHN1YnBhcnRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggYXJlIHJlZ2lzdGVyZWQgYXQgdGhlIFN5c3RlbSBsZXZlbC5cbiAgICAgICAgICAgIHN1YnBhcnROYW1lcyA9IE9iamVjdC5rZXlzKHdpbmRvdy5TeXN0ZW0uYXZhaWxhYmxlVmlld3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VicGFydE5hbWVzID0gdGhpcy5tb2RlbC5hY2NlcHRlZFN1YnBhcnRUeXBlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBzdWJwYXJ0IG5hbWVzIChtZWFuaW5nXG4gICAgICAgIC8vIHRoZSBnaXZlbiBwYXJ0LCBsaWtlIGEgYnV0dG9uLCBkb2Vzbid0XG4gICAgICAgIC8vIGFjY2VwdCBhbnkgc3VicGFydHMpLCB0aGVuIHdlIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmKHN1YnBhcnROYW1lcy5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgd2UgY29uc3RydWN0IHRoZSBzdWJtZW51IGZvciBhZGRpbmcgcGFydHNcbiAgICAgICAgLy8gb2YgdGhlIGdpdmVuIHR5cGVcbiAgICAgICAgbGV0IHN1Ym1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1jb250ZXh0LW1lbnUnKTtcbiAgICAgICAgc3VibWVudS5oaWRlSGVhZGVyKCk7XG4gICAgICAgIHN1YnBhcnROYW1lcy5mb3JFYWNoKHN1YnBhcnROYW1lID0+IHtcbiAgICAgICAgICAgIHN1Ym1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgc3VicGFydE5hbWVbMF0udG9VcHBlckNhc2UoKSArIHN1YnBhcnROYW1lLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ25ld01vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJwYXJ0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vdyBhZGQgdGhlIGxpc3QgaXRlbSB0aGF0IHdpbGwgXCJyZXZlYWxcIlxuICAgICAgICAvLyB0aGUgc3VibWVudVxuICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgJ0FkZCBhIG5ldyBwYXJ0JyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJtZW51XG4gICAgICAgICk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIGFkZE1vdmVtZW50SXRlbXMoKXtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tb2RlbC5fb3duZXIuc3VicGFydHMuaW5kZXhPZih0aGlzLm1vZGVsKTtcbiAgICAgICAgbGV0IG93bmVyTGVuZ3RoID0gdGhpcy5tb2RlbC5fb3duZXIuc3VicGFydHMubGVuZ3RoO1xuICAgICAgICBpZihvd25lckxlbmd0aCAmJiBpbmRleCA8IG93bmVyTGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG1vdmVEb3duIG9wdGlvblxuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnTW92ZSBEb3duJyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmVEb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdNb3ZlIHRvIExhc3QnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZVRvTGFzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmKGluZGV4ID4gMCl7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG1vdmVVcCBvcHRpb25cbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ01vdmUgVXAnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZVVwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdNb3ZlIHRvIEZpcnN0JyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmVUb0ZpcnN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRTcGFjZXIoKXtcbiAgICAgICAgbGV0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2NvbnRleHQtbWVudS1zcGFjZXInKTtcbiAgICAgICAgdGhpcy5hcHBlbmQoaXRlbSk7XG4gICAgfVxuXG4gICAgaGlkZUhlYWRlcigpe1xuICAgICAgICBsZXQgaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlcicpO1xuICAgICAgICBoZWFkZXJFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuXG4gICAgYWRqdXN0VG9DbGllbnRWaWV3KCl7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHBhZGRpbmcgPSAxMDtcbiAgICAgICAgbGV0IHZpZXdwb3J0V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGxldCB2aWV3cG9ydEhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxldCBib3R0b21EaWZmID0gKHJlY3QuYm90dG9tICsgcGFkZGluZykgLSB2aWV3cG9ydEhlaWdodDtcbiAgICAgICAgbGV0IHJpZ2h0RGlmZiA9IChyZWN0LnJpZ2h0ICsgcGFkZGluZykgLSB2aWV3cG9ydFdpZHRoO1xuICAgICAgICBpZihib3R0b21EaWZmID4gMCl7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRvcCA9IGAkeyhyZWN0LnRvcCAtIGJvdHRvbURpZmYpfXB4YDtcblxuICAgICAgICAgICAgLy8gUmVwb3NpdGlvbiBhbnkgaGlkZGVuIHN1Ym1lbnVzLCBzbyB0aGV5IG9wZW5cbiAgICAgICAgICAgIC8vIGFib3ZlXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pLmZpbHRlcihjaGlsZEVsID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRFbC5jaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfSkuZm9yRWFjaChpdGVtV2l0aFN1Ym1lbnUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBpdGVtV2l0aFN1Ym1lbnUuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnN1Ym1lbnUtYXJlYScpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHsoLTEgKiBpdGVtV2l0aFN1Ym1lbnUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KX1weGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZihyaWdodERpZmYgPiAwKXtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUubGVmdCA9IGAke3JlY3QubGVmdCAtIHJpZ2h0RGlmZn1weGA7XG5cbiAgICAgICAgICAgIC8vIFJlcG9zaXRpb24gYW55IGhpZGRlbiBzdWJtZW51cywgc28gdGhleSBvcGVuXG4gICAgICAgICAgICAvLyB0byB0aGUgbGVmdCAoaW5zdGVhZCBvZiByaWdodClcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5jaGlsZHJlbikuZmlsdGVyKGNoaWxkRWwgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEVsLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKGl0ZW1XaXRoU3VibWVudSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGl0ZW1XaXRoU3VibWVudS5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3VibWVudS1hcmVhJyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSBgJHsoLTEgKiBpdGVtV2l0aFN1Ym1lbnUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpfXB4YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBDb250ZXh0TWVudSxcbiAgICBDb250ZXh0TWVudSBhcyBkZWZhdWx0XG59O1xuIiwiY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICAgIC5zdWJtZW51LWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDEwMCU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgIH1cblxuICAgIDpob3N0KDpob3ZlcikgLnN1Ym1lbnUtYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuXG4gICAgLmxhYmVsLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cblxuICAgIC5jYXJldC5oaWRkZW4ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAuY2FyZXQge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJsYWJlbC1hcmVhXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPjxzbG90Pjwvc2xvdD48L3NwYW4+XG4gICAgPGRpdiBjbGFzcz1cImNhcmV0IGhpZGRlblwiPuKGkjwvZGl2PlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwic3VibWVudS1hcmVhXCI+XG4gICAgPHNsb3QgbmFtZT1cInN1Ym1lbnVcIj48L3Nsb3Q+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIENvbnRleHRNZW51SXRlbSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHNoYWRvdyBkb20gYW5kIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2hvd0NhcmV0ID0gdGhpcy5zaG93Q2FyZXQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzaG93Q2FyZXQoKXtcbiAgICAgICAgbGV0IGNhcmV0RWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5jYXJldCcpO1xuICAgICAgICBjYXJldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpOyAgICBcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIENvbnRleHRNZW51SXRlbSxcbiAgICBDb250ZXh0TWVudUl0ZW0gYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQ29sb3JQaWNrZXJUb29sXG4gKiBJIHByb3ZpZGUgYSBjb2xvciBjaG9vcnNlciBjYXBhYmlsaXR5XG4gKiBmb3IgdGhlIHNoYWRvdyBjYW52YXMgb2YgbXkgcGFyZW50IGVsZW1lbnQuXG4gKiBCcnVzaGVzIG9uIG15IHBhcmVudCBEcmF3aW5nIGNhbnZhcyB3aWxsIHVzZVxuICogd2hhdGV2ZXIgY29sb3IgSSBoYXZlIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAqIEkgYW0gZXhwbGljaXRseSBkZXNpZ25lZCBmb3IgdXNlIHdpdGhcbiAqIERyYXdpbmdWaWV3Ki9cbmltcG9ydCB7Q29sb3JXaGVlbFdpZGdldH0gZnJvbSAnLi9Db2xvcldoZWVsV2lkZ2V0LmpzJztcbmNvbnN0IGNvbG9yUGlja2VyU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNvbG9yLXN3YXRjaFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTkgM2gtNGEyIDIgMCAwIDAgLTIgMnYxMmE0IDQgMCAwIDAgOCAwdi0xMmEyIDIgMCAwIDAgLTIgLTJcIiAvPlxuICA8cGF0aCBkPVwiTTEzIDcuMzVsLTIgLTJhMiAyIDAgMCAwIC0yLjgyOCAwbC0yLjgyOCAyLjgyOGEyIDIgMCAwIDAgMCAyLjgyOGw5IDlcIiAvPlxuICA8cGF0aCBkPVwiTTcuMyAxM2gtMi4zYTIgMiAwIDAgMCAtMiAydjRhMiAyIDAgMCAwIDIgMmgxMlwiIC8+XG4gIDxsaW5lIHgxPVwiMTdcIiB5MT1cIjE3XCIgeDI9XCIxN1wiIHkyPVwiMTcuMDFcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjb2xvclBpY2tlclRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuICAgIH1cblxuICAgICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIC0tYWN0aXZlLWNvbG9yOiBibGFjaztcbiAgICAgICAgLS1pbmFjdGl2ZS1jb2xvcjogcmdiKDE3MCwgMTcwLCAxNzApO1xuICAgICAgICAtLWhvdmVyLWNvbG9yOiByZ2IoMTQwLCAxNDAsIDE0MCk7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICB9XG5cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiAjdG9vbC1idXR0b24ge1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICBjb2xvci13aGVlbCB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG5cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiBjb2xvci13aGVlbCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJ0b29sLWJ1dHRvblwiPlxuJHtjb2xvclBpY2tlclNWR31cbjwvZGl2PlxuPGNvbG9yLXdoZWVsPjwvY29sb3Itd2hlZWw+XG5gO1xuXG5cbmNsYXNzIENvbG9yUGlja2VyVG9vbCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldCB1cCBzaGFkb3cgZG9tLiBUaGlzIHRvb2wgd2lsbFxuICAgICAgICAvLyBkaXNwbGF5IGl0c2VsZiBhcyBhIGJ1dHRvbiB0aGF0IGNhbiBiZVxuICAgICAgICAvLyB0b2dnbGVkIHdpdGhpbiBpdHMgcGFyZW50IERyYXdpbmdWaWV3LlxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBjb2xvclBpY2tlclRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZHJhd2luZyBjb250ZXh0IGlzIG51bGwuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBzZXQgaWYgYW5kIHdoZW4gdGhpcyB0b29sXG4gICAgICAgIC8vIGlzIGNvbm5lY3RlZCB0byBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgIC8vIHRoYXQgaGFzIGEgY29udGV4dFxuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUgPSB0aGlzLnRvZ2dsZUFjdGl2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ29sb3JTZWxlY3RlZCA9IHRoaXMub25Db2xvclNlbGVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2VkID0gdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMgPSB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLmhhc0F0dHJpYnV0ZSgnY3VycmVudC1jb2xvcicpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY3VycmVudC1jb2xvcicsICdyZ2JhKDAsIDAsIDAsIDApJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgSSBhbSB0aGUgb25seSB0b29sIGluIG15IHBhcmVudCxcbiAgICAgICAgICAgICAgICAvLyBzZXQgbXlzZWxmIHRvIGFjdGl2ZVxuICAgICAgICAgICAgICAgIGxldCBzaWJsaW5nVG9vbHMgPSB0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYoc2libGluZ1Rvb2xzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5idXR0b24gPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2wtYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JXaGVlbCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjb2xvci13aGVlbCcpO1xuICAgICAgICAgICAgdGhpcy5jb2xvcldoZWVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbG9yLXNlbGVjdGVkJywgdGhpcy5vbkNvbG9yU2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5jb2xvcldoZWVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zcGFyZW5jeS1jaGFuZ2VkJywgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB0aGlzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgdGhpcy5jb2xvcldoZWVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbG9yLXNlbGVjdGVkJywgdGhpcy5vbkNvbG9yU2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmNvbG9yV2hlZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNwYXJlbmN5LWNoYW5nZWQnLCB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlZCk7XG4gICAgfVxuXG4gICAgc3RhcnQoeCwgeSl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBpbiB0aGlzIHRvb2xcbiAgICB9XG5cbiAgICBlbmQoeCwgeSl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBpbiB0aGlzIHRvb2xcbiAgICB9XG5cbiAgICBvbk1vdmUoeCwgeSl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBpbiB0aGlzIHRvb2xcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGluIHRoaXMgdG9vbFxuICAgIH1cblxuICAgIG9uQ29sb3JTZWxlY3RlZChldmVudCl7XG4gICAgICAgIGxldCBjb2xvckluZm8gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGxldCBjb2xvclN0ciA9IGByZ2JhKCR7Y29sb3JJbmZvLnJ9LCAke2NvbG9ySW5mby5nfSwgJHtjb2xvckluZm8uYn0sICR7Y29sb3JJbmZvLmFscGhhfSlgO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yU3RyO1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvclN0cjtcbiAgICB9XG5cbiAgICBvblRyYW5zcGFyZW5jeUNoYW5nZWQoZXZlbnQpe1xuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogXCJzZXRQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgYXJnczogW1widHJhbnNwYXJlbmN5XCIsIGV2ZW50LmRldGFpbF1cbiAgICAgICAgfSwgdGhpcy5wYXJlbnRFbGVtZW50Lm1vZGVsKTtcbiAgICB9XG5cbiAgICB0b2dnbGVBY3RpdmUoZXZlbnQpe1xuICAgICAgICBsZXQgaXNBY3RpdmUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlJyk7XG4gICAgICAgIGlmKGlzQWN0aXZlID09IFwidHJ1ZVwiKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBmaW5kIGFueSBvdGhlciB0b29scyBpbiBteSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgYW5kIGRlYWN0aXZhdGUgdGhlbS5cbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIHRvb2wgdG8gYmUgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjb2xvci1waWNrZXItdG9vbCcsIENvbG9yUGlja2VyVG9vbCk7XG5cbmV4cG9ydCB7XG4gICAgQ29sb3JQaWNrZXJUb29sLFxuICAgIENvbG9yUGlja2VyVG9vbCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBDb2xvcldoZWVsV2lkZ2V0XG4gKiBJIGFtIGEgKmdlbmVyaWMgdXNlKiB3ZWJjb21wb25lbnQgcmVwcmVzZW50aW5nXG4gKiBhIENvbG9yV2hlZWwgc2VsZWN0aW9uIHdpZGdldC5cbiAqIEkgb3BlcmF0ZSBhcyBhIGZsb2F0aW5nIG1vZGFsIHdpbmRvdyB3aXRoIGFcbiAqIGNpcmN1bGFyIGNvbG9yIHdoZWVsIGFzIHdlbGwgYXMgYSBsaXN0IG9mXG4gKiByZWNlbnRseSBzZWxlY3RlZCBjb2xvcnMuXG4gKiBJIGFtIGRlc2lnbmVkIHRvIGJlIHVzZWQgYnkgYW55IHBhcmVudCBlbGVtZW50LlxuICogSSB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgY2FsbGVkICdjb2xvci1jaGFuZ2UnIHdoZW5ldmVyXG4gKiBhIG5ldyBjb2xvciBoYXMgYmVlbiBzZWxlY3RlZCBmcm9tIHdpdGhpbiBtZVxuICovXG5cbmNvbnN0IGNvbG9yV2hlZWxUZW1wbGF0ZSA9IGBcbjxzdHlsZT5cbiAgOmhvc3Qge1xuICAgIGRpc3BsYXk6IGluaXRpYWwgIWltcG9ydGFudDtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICB9XG5cbiAgI3BhbGV0dGUtYmFyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgIGhlaWdodDogMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwMCwgMjAwLCAyMDApO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cblxuICAjcGFsZXR0ZS10aXRsZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG5cbiAgI2Nsb3NlLWJ1dHRvbiB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgd2lkdGg6IDEycHg7XG4gICAgaGVpZ2h0OiAxMnB4O1xuICAgIG1hcmdpbi1sZWZ0OiA4cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgfVxuXG4gICNwYWxldHRlLWNvbnRlbnQge1xuICAgIGZsZXg6IDE7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG4gICNob3Zlci1jb2xvciB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICB9XG4gICNvcHRpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMjVweDtcbiAgICBtYXJnaW4tdG9wOiA1cHg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIH1cblxuICAjb3B0aW9ucyA+IGxhYmVse1xuICAgIGZvbnQtc2l6ZTogLjhyZW07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgI3JlY2VudC1jb2xvcnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgIHBhZGRpbmctbGVmdDogMTVweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiAxNXB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgfVxuICAucmVjZW50LWNvbG9yLWl0ZW0ge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAyNnB4O1xuICAgIGhlaWdodDogMjZweDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjAwLCAyMDAsIDIwMCwgMC44KTtcbiAgfVxuXG4gIC5yZWNlbnQtY29sb3ItaXRlbS5zZWxlY3RlZCB7XG4gICAgYm9yZGVyOiAycHggc29saWQgYmxhY2s7XG4gIH1cblxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJwYWxldHRlLXdyYXBwZXJcIj5cbiAgPGRpdiBpZD1cInBhbGV0dGUtYmFyXCI+PGRpdiBpZD1cImNsb3NlLWJ1dHRvblwiPng8L2Rpdj48c3BhbiBpZD1cInBhbGV0dGUtdGl0bGVcIj48L3NwYW4+PC9kaXY+XG4gIDxkaXYgaWQ9XCJwYWxldHRlLWNvbnRlbnRcIj5cbiAgICA8ZGl2IGlkPVwib3B0aW9uc1wiPlxuICAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGlkPVwidHJhbnNwYXJlbmN5XCIgbmFtZT1cInRyYW5zcGFyZW5jeVwiIG1pbj1cIjBcIiBtYXg9XCIxXCIgc3RlcD1cIjAuMVwiIHZhbHVlPVwiMVwiPlxuICAgICAgPCEtLSA8bGFiZWwgZm9yPVwidHJhbnNwYXJlbmN5XCI+VHJhbnNwYXJlbmN5PC9sYWJlbD4tLT5cbiAgICA8L2Rpdj5cbiAgICA8dWwgaWQ9XCJyZWNlbnQtY29sb3JzXCI+XG4gICAgICA8bGkgY2xhc3M9XCJyZWNlbnQtY29sb3ItaXRlbSBzZWxlY3RlZFwiPjwvbGk+XG4gICAgICA8bGkgY2xhc3M9XCJyZWNlbnQtY29sb3ItaXRlbVwiPjwvbGk+XG4gICAgICA8bGkgY2xhc3M9XCJyZWNlbnQtY29sb3ItaXRlbVwiPjwvbGk+XG4gICAgPC91bD5cbiAgICA8Y2FudmFzIGlkPVwiY29sb3Itd2hlZWxcIiB3aWR0aD1cIjE1MFwiIGhlaWdodD1cIjE1MFwiPjwvY2FudmFzPlxuICAgIDxkaXYgaWQ9XCJob3Zlci1jb2xvclwiPjwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxuY2xhc3MgQ29sb3JXaGVlbFdpZGdldCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIFNldHVwIHNoYWRvdyBkb20gYW5kIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IGNvbG9yV2hlZWxUZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIGxvY2FsIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbldoZWVsTW91c2VFbnRlciA9IHRoaXMub25XaGVlbE1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldoZWVsTW91c2VMZWF2ZSA9IHRoaXMub25XaGVlbE1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldoZWVsTW91c2VNb3ZlID0gdGhpcy5vbldoZWVsTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25XaGVlbENsaWNrID0gdGhpcy5vbldoZWVsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkl0ZW1DbGljayA9IHRoaXMub25JdGVtQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkJhck1vdXNlRG93biA9IHRoaXMub25CYXJNb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkJhck1vdXNlVXAgPSB0aGlzLm9uQmFyTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQmFyTW91c2VNb3ZlID0gdGhpcy5vbkJhck1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZSA9IHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZHJhd1doZWVsID0gdGhpcy5fZHJhd1doZWVsLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuYmFyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdwYWxldHRlLWJhcicpO1xuICAgICAgICAgICAgLy8gZ2l2ZSB0aGUgd2lkZ2V0IGEgdGl0bGUgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmKHRoaXMubmFtZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdwYWxldHRlLXRpdGxlJykuaW5uZXJUZXh0ID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25XaGVlbENsaWNrKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uV2hlZWxNb3VzZUVudGVyKTtcbiAgICAgICAgICAgIHRoaXMuYmFyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25CYXJNb3VzZURvd24pO1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnLnJlY2VudC1jb2xvci1pdGVtJykpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkl0ZW1DbGljayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5U2xpZGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0cmFuc3BhcmVuY3knKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5U2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlKTtcblxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgY29sb3Igd2hlZWwgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgdGhpcy5fZHJhd1doZWVsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25XaGVlbENsaWNrKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25XaGVlbE1vdXNlRW50ZXIpO1xuICAgICAgICB0aGlzLmJhci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uQmFyTW91c2VEb3duKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnJlY2VudC1jb2xvci1pdGVtJykpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uSXRlbUNsaWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwYXJlbmN5U2xpZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZSk7XG4gICAgfVxuXG5cbiAgICBvbldoZWVsTW91c2VFbnRlcihldmVudCl7XG4gICAgICAgIC8vIENhY2hlIHRoZSBpbWFnZSBkYXRhIGZvciB0aGUgd2hvbGUgY2FudmFzXG4gICAgICAgIGxldCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9jYWNoZWRJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodFxuICAgICAgICApO1xuICAgICAgICAvLyBCaW5kIHN1YnNlcXVlbnQgZXZlbnRzXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25XaGVlbE1vdXNlTW92ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uV2hlZWxNb3VzZUxlYXZlKTtcbiAgICB9XG5cbiAgICBvbldoZWVsTW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25XaGVlbE1vdXNlTW92ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uV2hlZWxNb3VzZUxlYXZlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkSW1hZ2VEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBvbldoZWVsTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb25Gcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICBsZXQgcmdiID0gZ2V0UkdCRnJvbUltYWdlRGF0YShcbiAgICAgICAgICAgIHBvc2l0aW9uLngsXG4gICAgICAgICAgICBwb3NpdGlvbi55LFxuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRJbWFnZURhdGEuZGF0YVxuICAgICAgICApO1xuICAgICAgICBsZXQgaG92ZXJDb2xvckFyZWEgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hvdmVyLWNvbG9yJyk7XG4gICAgICAgIGxldCBuZXdTdHlsZSA9IGByZ2JhKCR7cmdiWzBdfSwgJHtyZ2JbMV19LCAke3JnYlsyXX0sICR7cmdiWzNdfSlgO1xuICAgICAgICBob3ZlckNvbG9yQXJlYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBuZXdTdHlsZTtcbiAgICB9XG5cbiAgICBvbldoZWVsQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBnZXRQb3NpdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICAgIGxldCByZ2IgPSBnZXRSR0JGcm9tSW1hZ2VEYXRhKFxuICAgICAgICAgICAgcG9zaXRpb24ueCxcbiAgICAgICAgICAgIHBvc2l0aW9uLnksXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZEltYWdlRGF0YS5kYXRhXG4gICAgICAgICk7XG4gICAgICAgIGxldCBjb2xvckluZm8gPSB7XG4gICAgICAgICAgICByOiByZ2JbMF0sXG4gICAgICAgICAgICBnOiByZ2JbMV0sXG4gICAgICAgICAgICBiOiByZ2JbMl0sXG4gICAgICAgICAgICBhbHBoYTogcmdiWzNdXG4gICAgICAgIH07XG4gICAgICAgIGxldCBuZXdFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29sb3Itc2VsZWN0ZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGNvbG9ySW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbG9yID0gY29sb3JJbmZvO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVjZW50IGNvbG9yIHN3YXRjaGVzXG4gICAgICAgIGxldCBjdXJyZW50U3dhdGNoU2VsZWN0aW9uID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5yZWNlbnQtY29sb3ItaXRlbS5zZWxlY3RlZCcpO1xuICAgICAgICBpZihjdXJyZW50U3dhdGNoU2VsZWN0aW9uKXtcbiAgICAgICAgICAgIGN1cnJlbnRTd2F0Y2hTZWxlY3Rpb24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYHJnYmEoJHtjb2xvckluZm8ucn0sICR7Y29sb3JJbmZvLmd9LCAke2NvbG9ySW5mby5ifSwgJHtjb2xvckluZm8uYWxwaGF9KWA7XG4gICAgICAgICAgICBjdXJyZW50U3dhdGNoU2VsZWN0aW9uLnNlbGVjdGVkQ29sb3IgPSBjb2xvckluZm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblRyYW5zcGFyZW5jeUNoYW5nZShldmVudCl7XG4gICAgICAgIGxldCBjb21tYW5kID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJzZWxlY3Rvci1jb21tYW5kXCIpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgdHJhbnNwYXJlbmN5IC0gdGV4dCBvciBiYWNrZ3JvdW5kXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGF0IHRoaXMgY29sb3Igd2hlZWwgaXMgc2V0dXAgdG8gdXBkYXRlXG4gICAgICAgIGxldCBwcm9wTmFtZSA9IFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIjtcbiAgICAgICAgaWYoY29tbWFuZCA9PT0gXCJ0ZXh0LWNvbG9yXCIpe1xuICAgICAgICAgICAgcHJvcE5hbWUgPSBcInRleHQtdHJhbnNwYXJlbmN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50RGV0YWlsID0ge3Byb3BOYW1lOiBwcm9wTmFtZSwgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZX07XG4gICAgICAgIGxldCBuZXdFdmVudCA9IG5ldyBDdXN0b21FdmVudCgndHJhbnNwYXJlbmN5LWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGV2ZW50RGV0YWlsLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9XG5cbiAgICBvbkl0ZW1DbGljayhldmVudCl7XG4gICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBpcyBub3QgdGhlIGN1cnJlbnRseVxuICAgICAgICAvLyBzZWxlY3RlZCByZWNlbnQgaXRlbSwgZmluZCB0aGUgb25lIHRoYXQgaXNcbiAgICAgICAgLy8gYW5kIHRvZ2dsZSB0aGUgc2VsZWN0aW9uIGNsYXNzLCB0aGVuIHRvZ2dsZVxuICAgICAgICAvLyB0aGlzIGl0ZW0ncyBzZWxlY3Rpb24gY2xhc3MuXG4gICAgICAgIGlmKCFldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKXtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZWNlbnQtY29sb3ItaXRlbS5zZWxlY3RlZCcpKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC5zZWxlY3RlZENvbG9yKXtcbiAgICAgICAgICAgIGxldCBuZXdFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29sb3Itc2VsZWN0ZWQnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiBldmVudC50YXJnZXQuc2VsZWN0ZWRDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25CYXJNb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uQmFyTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25CYXJNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvbkJhck1vdXNlVXAoZXZlbnQpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uQmFyTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25CYXJNb3VzZVVwKTtcbiAgICB9XG5cbiAgICBvbkJhck1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIGxldCBuZXdUb3AgPSB0aGlzLm9mZnNldFRvcCArIGV2ZW50Lm1vdmVtZW50WTtcbiAgICAgICAgbGV0IG5ld0xlZnQgPSB0aGlzLm9mZnNldExlZnQgKyBldmVudC5tb3ZlbWVudFg7XG4gICAgICAgIHRoaXMuc3R5bGUudG9wID0gYCR7bmV3VG9wfXB4YDtcbiAgICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gYCR7bmV3TGVmdH1weGA7XG4gICAgfVxuXG4gICAgb25DbG9zZShldmVudCl7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgX2RyYXdXaGVlbCgpe1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgZHJhd0NpcmNsZShjdHgsIHRoaXMuY2FudmFzLndpZHRoIC8gMik7XG4gICAgfVxufTtcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY29sb3Itd2hlZWwnLCBDb2xvcldoZWVsV2lkZ2V0KTtcblxuLyoqIFV0aWxpdHkgRnVuY3Rpb25zICoqL1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BiYW50aWMvaGFuZC1jb2RpbmctYS1jb2xvci13aGVlbC13aXRoLWNhbnZhcy03ODI1NmM5ZDdkNDNcbmNvbnN0IGRyYXdDaXJjbGUgPSAoY3R4LCByYWRpdXMpID0+IHtcbiAgICBsZXQgaW1hZ2UgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDIqcmFkaXVzLCAyKnJhZGl1cyk7XG4gICAgbGV0IGRhdGEgPSBpbWFnZS5kYXRhO1xuXG4gICAgZm9yIChsZXQgeCA9IC1yYWRpdXM7IHggPCByYWRpdXM7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gLXJhZGl1czsgeSA8IHJhZGl1czsgeSsrKSB7XG5cbiAgICAgICAgICAgIGxldCBbciwgcGhpXSA9IHh5MnBvbGFyKHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAociA+IHJhZGl1cykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgYWxsICh4LHkpIGNvb3JkaW5hdGVzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNpcmNsZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVnID0gcmFkMmRlZyhwaGkpO1xuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBzdGFydGluZyBpbmRleCBvZiB0aGlzIHBpeGVsIGluIHRoZSBpbWFnZSBkYXRhIGFycmF5LlxuICAgICAgICAgICAgbGV0IHJvd0xlbmd0aCA9IDIqcmFkaXVzO1xuICAgICAgICAgICAgbGV0IGFkanVzdGVkWCA9IHggKyByYWRpdXM7IC8vIGNvbnZlcnQgeCBmcm9tIFstNTAsIDUwXSB0byBbMCwgMTAwXSAodGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbWFnZSBkYXRhIGFycmF5KVxuICAgICAgICAgICAgbGV0IGFkanVzdGVkWSA9IHkgKyByYWRpdXM7IC8vIGNvbnZlcnQgeSBmcm9tIFstNTAsIDUwXSB0byBbMCwgMTAwXSAodGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbWFnZSBkYXRhIGFycmF5KVxuICAgICAgICAgICAgbGV0IHBpeGVsV2lkdGggPSA0OyAvLyBlYWNoIHBpeGVsIHJlcXVpcmVzIDQgc2xvdHMgaW4gdGhlIGRhdGEgYXJyYXlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IChhZGp1c3RlZFggKyAoYWRqdXN0ZWRZICogcm93TGVuZ3RoKSkgKiBwaXhlbFdpZHRoO1xuXG4gICAgICAgICAgICBsZXQgaHVlID0gZGVnO1xuICAgICAgICAgICAgbGV0IHNhdHVyYXRpb24gPSByIC8gcmFkaXVzO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gMS4wO1xuXG4gICAgICAgICAgICBsZXQgW3JlZCwgZ3JlZW4sIGJsdWVdID0gaHN2MnJnYihodWUsIHNhdHVyYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGxldCBhbHBoYSA9IDI1NTtcblxuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSByZWQ7XG4gICAgICAgICAgICBkYXRhW2luZGV4KzFdID0gZ3JlZW47XG4gICAgICAgICAgICBkYXRhW2luZGV4KzJdID0gYmx1ZTtcbiAgICAgICAgICAgIGRhdGFbaW5kZXgrM10gPSBhbHBoYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xufTtcblxuLy8gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AYmFudGljL2hhbmQtY29kaW5nLWEtY29sb3Itd2hlZWwtd2l0aC1jYW52YXMtNzgyNTZjOWQ3ZDQzXG5jb25zdCB4eTJwb2xhciA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHIgPSBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbiAgICBsZXQgcGhpID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgICByZXR1cm4gW3IsIHBoaV07XG59O1xuXG4vLyBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BiYW50aWMvaGFuZC1jb2RpbmctYS1jb2xvci13aGVlbC13aXRoLWNhbnZhcy03ODI1NmM5ZDdkNDNzXG5jb25zdCByYWQyZGVnID0gKHJhZCkgPT4ge1xuICAgIHJldHVybiAoKHJhZCArIE1hdGguUEkpIC8gKDIgKiBNYXRoLlBJKSkgKiAzNjA7XG59O1xuXG4vLyBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BiYW50aWMvaGFuZC1jb2RpbmctYS1jb2xvci13aGVlbC13aXRoLWNhbnZhcy03ODI1NmM5ZDdkNDNcbmNvbnN0IGhzdjJyZ2IgPSAoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBjaHJvbWEgPSB2YWx1ZSAqIHNhdHVyYXRpb247XG4gICAgbGV0IGh1ZTEgPSBodWUgLyA2MDtcbiAgICBsZXQgeCA9IGNocm9tYSAqICgxLSBNYXRoLmFicygoaHVlMSAlIDIpIC0gMSkpO1xuICAgIGxldCByMSwgZzEsIGIxO1xuICAgIGlmIChodWUxID49IDAgJiYgaHVlMSA8PSAxKSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbY2hyb21hLCB4LCAwXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDEgJiYgaHVlMSA8PSAyKSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbeCwgY2hyb21hLCAwXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDIgJiYgaHVlMSA8PSAzKSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbMCwgY2hyb21hLCB4XSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDMgJiYgaHVlMSA8PSA0KSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbMCwgeCwgY2hyb21hXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDQgJiYgaHVlMSA8PSA1KSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbeCwgMCwgY2hyb21hXSk7XG4gICAgfSBlbHNlIGlmIChodWUxID49IDUgJiYgaHVlMSA8PSA2KSB7XG4gICAgICAgIChbcjEsIGcxLCBiMV0gPSBbY2hyb21hLCAwLCB4XSk7XG4gICAgfVxuXG4gICAgbGV0IG0gPSB2YWx1ZSAtIGNocm9tYTtcbiAgICBsZXQgW3IsZyxiXSA9IFtyMSttLCBnMSttLCBiMSttXTtcblxuICAgIC8vIENoYW5nZSByLGcsYiB2YWx1ZXMgZnJvbSBbMCwxXSB0byBbMCwyNTVdXG4gICAgcmV0dXJuIFsyNTUqciwyNTUqZywyNTUqYl07XG59O1xuXG5jb25zdCBnZXRQb3NpdGlvbkZyb21FdmVudCA9IChldmVudCkgPT4ge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IG9mZnNldFggPSB0YXJnZXQub2Zmc2V0TGVmdDtcbiAgICBsZXQgb2Zmc2V0WSA9IHRhcmdldC5vZmZzZXRUb3A7XG4gICAgbGV0IGNoZWNrID0gdGFyZ2V0Lm9mZnNldFBhcmVudDtcbiAgICB3aGlsZShjaGVjayl7XG4gICAgICAgIG9mZnNldFggKz0gY2hlY2sub2Zmc2V0TGVmdDtcbiAgICAgICAgb2Zmc2V0WSArPSBjaGVjay5vZmZzZXRUb3A7XG4gICAgICAgIGNoZWNrID0gY2hlY2sub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gb2Zmc2V0WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIG9mZnNldFlcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBnZXRSR0JGcm9tSW1hZ2VEYXRhID0gKHgsIHksIHdpZHRoLCBkYXRhKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gKHkgKiB3aWR0aCArIHgpICogNDtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRhW2luZGV4XSwgLy8gclxuICAgICAgICBkYXRhW2luZGV4ICsgMV0sIC8vIGdcbiAgICAgICAgZGF0YVtpbmRleCArIDJdLCAvLyBiXG4gICAgICAgIGRhdGFbaW5kZXggKyAzXSAvLyBhbHBoYVxuICAgIF07XG59O1xuXG5leHBvcnQge1xuICAgIENvbG9yV2hlZWxXaWRnZXQsXG4gICAgQ29sb3JXaGVlbFdpZGdldCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBEcmF3aW5nVmlld1xuICogRXhwZXJpbWVudGFsLlxuICogVGhpcyBpcyBzdGlsbCBhIHB1cmUgd2ViY29tcG9uZW50IGFuZCBpcyBub3RcbiAqIGxpbmtlZCBhdCBhbGwgdG8gU2ltcGxlVGFsayB5ZXQuXG4gKlxuICovXG5pbXBvcnQge1BhcnRWaWV3fSBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5pbXBvcnQge1BlbmNpbFRvb2x9IGZyb20gJy4vUGVuY2lsVG9vbC5qcyc7XG5pbXBvcnQge0VyYXNlclRvb2x9IGZyb20gJy4vRXJhc2VyVG9vbC5qcyc7XG5pbXBvcnQge0NvbG9yUGlja2VyVG9vbH0gZnJvbSAnLi9Db2xvclBpY2tlclRvb2wuanMnO1xuXG5jb25zdCBoYWxvQnV0dG9uU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXRvb2xcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTcgMTBoM3YtM2wtMy41IC0zLjVhNiA2IDAgMCAxIDggOGw2IDZhMiAyIDAgMCAxIC0zIDNsLTYtNmE2IDYgMCAwIDEgLTggLThsMy41IDMuNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgICN0b29sLWJ1dHRvbnMge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IGNhbGMoMTAwJSArIDVweCk7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cbiAgICA6aG9zdCguc2hvdy1ib3JkZXIpe1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgICB9XG4gICAgOmhvc3QoOm5vdChbbW9kZT1cImRyYXdpbmdcIl0pKSA+ICN0b29sLWJ1dHRvbnMge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbjwvc3R5bGU+XG48Y2FudmFzPjwvY2FudmFzID5cbjxkaXYgaWQ9XCJ0b29sLWJ1dHRvbnNcIj5cbjxzbG90Pjwvc2xvdD5cbjwvZGl2PlxuYDtcblxuY2xhc3MgRHJhd2luZ1ZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCBzaGFkb3cgZG9tXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJUb29sID0gbnVsbDtcblxuICAgICAgICB0aGlzLmlzQ3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VMZWF2ZSA9IHRoaXMub25Nb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvUmVzaXplID0gdGhpcy5vbkhhbG9SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGVNb2RlID0gdGhpcy50b2dnbGVNb2RlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWZ0ZXJEcmF3QWN0aW9uID0gdGhpcy5hZnRlckRyYXdBY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwgPSB0aGlzLnJlc3RvcmVJbWFnZUZyb21Nb2RlbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVDaGFuZ2VkID0gdGhpcy5tb2RlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldHVwIHByb3AgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdtb2RlJywgdGhpcy5tb2RlQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdpbWFnZScsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBpbWFnZUJpdHMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaW1hZ2UnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwoaW1hZ2VCaXRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdzaG93LWJvcmRlcicsICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmKHZhbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzaG93LWJvcmRlcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3ctYm9yZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnd2lkdGgnLCAodmFsKSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3aGF0IHdlIHdhbnQgaXMgdGhlIGNhbGN1bGF0ZWQgQ1NTLCBub3QgdGhlIFNUIHBhcnQgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImNzc1N0eWxlXCIpO1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGNzc1N0eWxlLndpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdoZWlnaHQnLCAodmFsKSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3aGF0IHdlIHdhbnQgaXMgdGhlIGNhbGN1bGF0ZWQgQ1NTLCBub3QgdGhlIFNUIHBhcnQgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImNzc1N0eWxlXCIpO1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBjc3NTdHlsZS5oZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2RlQ2hhbmdlZCh2YWx1ZSl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RlJywgdmFsdWUpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5zaGFkb3cucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuXG4gICAgICAgIC8vIFNldCBhbmQgc3RvcmUgdGhlIGRyYXdpbmcgY29udGV4dFxuICAgICAgICB0aGlzLmRyYXdpbmdDb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBJZiBJIGRvbid0IGhhdmUgdGhlIGRlZmF1bHQgdG9vbHMsIGFkZFxuICAgICAgICAvLyB0aGVtIGFzIHJlYWwgZG9tIGNoaWxkcmVuIG5vd1xuICAgICAgICBsZXQgcGVuY2lsQ2hpbGQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3BlbmNpbC10b29sJyk7XG4gICAgICAgIGlmKCFwZW5jaWxDaGlsZCl7XG4gICAgICAgICAgICBsZXQgbmV3UGVuY2lsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGVuY2lsLXRvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5ld1BlbmNpbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVyYXNlckNoaWxkID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdlcmFzZXItdG9vbCcpO1xuICAgICAgICBpZighZXJhc2VyQ2hpbGQpe1xuICAgICAgICAgICAgbGV0IG5ld0VyYXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VyYXNlci10b29sJyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChuZXdFcmFzZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbG9yUGlja2VyQ2hpbGQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2NvbG9yLXBpY2tlci10b29sJyk7XG4gICAgICAgIGlmKCFjb2xvclBpY2tlckNoaWxkKXtcbiAgICAgICAgICAgIGxldCBuZXdDb2xvclBpY2tlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbG9yLXBpY2tlci10b29sJyk7XG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgaXMgYSB0b3RhbCBoYWNrIHNpbmNlIGRyYXdpbmcgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggc3R5bGVzIGF0IHRoZSBtb21lbnRcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5ld0NvbG9yUGlja2VyKTtcbiAgICAgICAgICAgIG5ld0NvbG9yUGlja2VyLmNvbG9yV2hlZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdkaXYjb3B0aW9ucycpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JQaWNrZXJUb29sID0gbmV3Q29sb3JQaWNrZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gc2V0dXAgdGhlIGNhbnZhcyBoZWlnaHQgYW5kIHdpZHRoXG4gICAgICAgIC8vIE5vdGU6IHdoYXQgd2Ugd2FudCBpcyB0aGUgY2FsY3VsYXRlZCBDU1MsIG5vdCB0aGUgU1QgcGFydCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJjc3NTdHlsZVwiKTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGNzc1N0eWxlLmhlaWdodCk7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBjc3NTdHlsZS53aWR0aCk7XG4gICAgICAgIGxldCBjdXJyZW50SW1hZ2UgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50SW1hZ2Upe1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwoY3VycmVudEltYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbml0aWFsU2hvd0JvcmRlciA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnc2hvdy1ib3JkZXInXG4gICAgICAgICk7XG4gICAgICAgIGlmKGluaXRpYWxTaG93Qm9yZGVyKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc2hvdy1ib3JkZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91c2VEb3duKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaW5EcmF3aW5nTW9kZSkge1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgbW91c2VVcCBjb21tYW5kIG1lc3NhZ2UgdG8gc2VsZlxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW91c2VVcCcsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlIC8vIFNob3VsZCBpZ25vcmUgaWYgU3lzdGVtIEROVVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVUb29sID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdbcm9sZT1cInRvb2xcIl1bYWN0aXZlPVwidHJ1ZVwiXScpO1xuICAgICAgICBpZighdGhpcy5hY3RpdmVUb29sKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvdy5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVUb29sLnN0YXJ0KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIH1cblxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuYWN0aXZlVG9vbCAmJiB0aGlzLmluRHJhd2luZ01vZGUpe1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUb29sLm9uTW92ZShcbiAgICAgICAgICAgICAgICBldmVudC5vZmZzZXRYLFxuICAgICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJ3YW50cy1tb3ZlXCIpKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmUnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WV1cbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuYWN0aXZlVG9vbCAmJiB0aGlzLmluRHJhd2luZ01vZGUgJiYgdGhpcy5pc0N1cnJlbnRseURyYXdpbmcpe1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUb29sLmVuZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJEcmF3QWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0N1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgIH1cblxuXG4gICAgb25Nb3VzZUxlYXZlKGV2ZW50KXtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIGxlZnQgdGhlIGFyZWFcbiAgICAgICAgLy8gd2hpbGUgZHJhd2luZy4gU28gY2FsbCB0aGUgYWN0aXZlVG9vbCdzXG4gICAgICAgIC8vIGVuZCBtZXRob2RcbiAgICAgICAgdGhpcy5hY3RpdmVUb29sLmVuZChcbiAgICAgICAgICAgIGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICBldmVudC5vZmZzZXRZXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaXNDdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWZ0ZXJEcmF3QWN0aW9uKCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIG9uSGFsb1Jlc2l6ZShtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIGxldCBjdXJyZW50SW1hZ2UgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICApO1xuICAgICAgICAvLyBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGggKyBtb3ZlbWVudFg7XG4gICAgICAgIC8vIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICsgbW92ZW1lbnRZO1xuICAgICAgICBsZXQgbmV3V2lkdGggPSBjYW52YXMud2lkdGggKyBtb3ZlbWVudFg7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICsgbW92ZW1lbnRZO1xuICAgICAgICBpZihuZXdXaWR0aCAmJiBuZXdIZWlnaHQpe1xuICAgICAgICAgICAgLy8gdGhpcy5zdHlsZS53aWR0aCA9IGAke25ld1dpZHRofXB4YDtcbiAgICAgICAgICAgIC8vIHRoaXMuc3R5bGUuaGVpZ2h0ID0gYCR7bmV3SGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgbmV3V2lkdGgsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgICAgIG5ld0hlaWdodCxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdG9yZUltYWdlRnJvbU1vZGVsKGN1cnJlbnRJbWFnZSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJEcmF3QWN0aW9uKCl7XG4gICAgICAgIC8vIEVuY29kZSBjYW52YXMgY29udGVudHMgYXMgYmFzZTY0IHBuZ1xuICAgICAgICAvLyBhbmQgc2V0IHRvIG1vZGVsJ3MgaW1hZ2UgcHJvcGVydHlcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICBjYW52YXMudG9EYXRhVVJMKClcbiAgICAgICAgKTtcbiAgICAgICAgLy90aGlzLnNldEF0dHJpYnV0ZShcIm1vZGVcIiwgXCJcIik7XG4gICAgfVxuXG4gICAgcmVzdG9yZUltYWdlRnJvbU1vZGVsKGJhc2U2NEltYWdlRGF0YSl7XG4gICAgICAgIC8vIENsZWFyIGFuZCBkcmF3IHRoZSBpbWFnZSB0byByZXN0b3JlIHRvXG4gICAgICAgIC8vIHRoZSBjYW52YXNcbiAgICAgICAgaWYoYmFzZTY0SW1hZ2VEYXRhKXtcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgICAgICBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBiYXNlNjRJbWFnZURhdGE7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgYm9yZGVyIHRvIGhpZGVcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdzaG93LWJvcmRlcicsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbigpe1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlkID0gXCJoYWxvLWRyYXdpbmctdG9nZ2xlLW1vZGVcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBoYWxvQnV0dG9uU1ZHO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luUmlnaHQgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ2JvdHRvbS1yb3cnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnVG9nZ2xlIGRyYXdpbmcgdG9vbHMnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVNb2RlKTtcbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgdG9nZ2xlTW9kZSgpe1xuICAgICAgICBsZXQgY3VycmVudE1vZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kZScpO1xuICAgICAgICBsZXQgbmV4dE1vZGUgPSAndmlld2luZyc7IC8vIEJ5IGRlZmF1bHQsIHNldCB0byB2aWV3aW5nXG4gICAgICAgIGxldCBpc0VtcHR5ID0gKCFjdXJyZW50TW9kZSB8fCBjdXJyZW50TW9kZSA9PSB1bmRlZmluZWQgfHwgY3VycmVudE1vZGUgPT0gXCJcIik7XG4gICAgICAgIGlmKGN1cnJlbnRNb2RlID09ICd2aWV3aW5nJyB8fCBpc0VtcHR5KXtcbiAgICAgICAgICAgIG5leHRNb2RlID0gJ2RyYXdpbmcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICBuZXh0TW9kZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCBpbkRyYXdpbmdNb2RlKCl7XG4gICAgICAgIGlmKCF0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RlJyk7XG4gICAgICAgIGlmKG1vZGUgPT0gJ2RyYXdpbmcnKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIERyYXdpbmdWaWV3LFxuICAgIERyYXdpbmdWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEVyYXNlclRvb2xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIHByb3ZpZGUgZXJhc2VyLWxpa2UgZnVuY3Rpb25hbGl0eSBvblxuICogbXkgcGFyZW50IGVsZW1lbnQncyBzaGFkb3cgY2FudmFzLlxuICogSSBhbSBzcGVjaWZpY2FsbHkgZGVzaWduZWQgZm9yIHVzZSBhcyBhXG4gKiBjaGlsZCBvZiBEcmF3aW5nVmlld1xuICovXG5jb25zdCBlcmFzZXJTVkcgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItZXJhc2VyXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xOSAxOWgtMTFsLTQgLTRhMSAxIDAgMCAxIDAgLTEuNDFsMTAgLTEwYTEgMSAwIDAgMSAxLjQxIDBsNSA1YTEgMSAwIDAgMSAwIDEuNDFsLTkgOVwiIC8+XG4gIDxsaW5lIHgxPVwiMThcIiB5MT1cIjEyLjNcIiB4Mj1cIjExLjdcIiB5Mj1cIjZcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBlcmFzZXJUb29sVGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDZweDtcbiAgICB9XG4gICAgI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgLS1hY3RpdmUtY29sb3I6IGJsYWNrO1xuICAgICAgICAtLWluYWN0aXZlLWNvbG9yOiByZ2IoMTcwLCAxNzAsIDE3MCk7XG4gICAgICAgIC0taG92ZXItY29sb3I6IHJnYigxNDAsIDE0MCwgMTQwKTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWluYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pID4gI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgICAgICBjb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgI2JydXNoZXMtY29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAjYnJ1c2gtYWRqdXN0ZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA2cHg7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlci13aWR0aDogMXB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgICNicnVzaC1zbGlkZXIsXG4gICAgI2JydXNoLW51bWJlciB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgICNicnVzaC1udW1iZXIge1xuICAgICAgICBtYXgtd2lkdGg6IDNyZW07XG4gICAgfVxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+ICNicnVzaGVzLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJ0b29sLWJ1dHRvblwiPlxuICAke2VyYXNlclNWR31cbjwvZGl2PlxuPGRpdiBpZD1cImJydXNoZXMtY29udGFpbmVyXCI+XG4gIDxkaXYgaWQ9XCJicnVzaC1hZGp1c3RlclwiPlxuICAgIDxpbnB1dCBpZD1cImJydXNoLXNsaWRlclwiIHR5cGU9XCJyYW5nZVwiIG1pbj1cIjFcIiBtYXg9XCIxMDBcIiBzdGVwPVwiMVwiPlxuICAgIDxpbnB1dCBpZD1cImJydXNoLW51bWJlclwiIHR5cGU9XCJudW1iZXJcIj5cbiAgPC9kaXY+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIEVyYXNlclRvb2wgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCBzaGFkb3cgZG9tLiBUaGlzIHRvb2wgd2lsbFxuICAgICAgICAvLyBkaXNwbGF5IGl0c2VsZiBhcyBhIGJ1dHRvbiB0aGF0IGNhblxuICAgICAgICAvLyBiZSB0b2dnbGVkLlxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBlcmFzZXJUb29sVGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLnNoYWRvdy5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBkcmF3aW5nIGNvbnRleHQgaXMgbnVsbC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHNldCBpZiBhbmQgd2hlbiB0aGlzIHRvb2wgaXNcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIGEgcGFyZW50IGVsZW1lbnQgdGhhdCBoYXMgYSBjb250ZXh0XG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy5lbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZSA9IHRoaXMudG9nZ2xlQWN0aXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzID0gdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSA9IHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlID0gdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYoIXRoaXMuaGFzQXR0cmlidXRlKCd3aWR0aCcpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnNicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIElmIEkgYW0gdGhlIG9ubHkgdG9vbCBpbiBteSBwYXJlbnQsXG4gICAgICAgICAgICAgICAgLy8gc2V0IG15c2VsZiB0byBhY3RpdmVcbiAgICAgICAgICAgICAgICBsZXQgc2libGluZ1Rvb2xzID0gdGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpO1xuICAgICAgICAgICAgICAgIGlmKHNpYmxpbmdUb29scy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0b29sLWJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2ZSk7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdicnVzaC1zbGlkZXInKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dCA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYnJ1c2gtbnVtYmVyJyk7XG4gICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgaXMgY3VycmVudGx5IGEgd2lkdGggc2V0LFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBzbGlkZXIgYW5kIG51bWJlciBpbnB1dCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYoY3VycmVudFdpZHRoKXtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnZhbHVlID0gcGFyc2VJbnQoY3VycmVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQudmFsdWUgPSBwYXJzZUludChjdXJyZW50V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB0aGlzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgdGhpcy5icnVzaFNsaWRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UpO1xuICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UpO1xuICAgIH1cblxuICAgIHN0YXJ0KHgsIHkpe1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmNhY2hlZFN0cm9rZVN0eWxlID0gdGhpcy5jdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIG9uTW92ZSh4LCB5KXtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBlbmQoeCwgeSl7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY2FjaGVkU3Ryb2tlU3R5bGU7XG4gICAgfVxuXG4gICAgc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzKCl7XG4gICAgICAgIC8vIGxpbmUgY2FwXG4gICAgICAgIGxldCBsaW5lQ2FwID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xpbmUtY2FwJyk7XG4gICAgICAgIGlmKGxpbmVDYXApe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lQ2FwID0gXCJyb3VuZFwiOyAvLyBkZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW5lIGpvaW5cbiAgICAgICAgbGV0IGxpbmVKb2luID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xpbmUtam9pbicpO1xuICAgICAgICBpZihsaW5lSm9pbil7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW5lIHdpZHRoXG4gICAgICAgIGxldCBsaW5lV2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgaWYobGluZVdpZHRoKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHBhcnNlSW50KGxpbmVXaWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSA2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKXtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAnbGluZS1qb2luJyxcbiAgICAgICAgICAgICdsaW5lLWNhcCdcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsLCBuZXdWYWwpe1xuICAgICAgICBpZihuYW1lID09ICd3aWR0aCcpe1xuICAgICAgICAgICAgaWYodGhpcy5icnVzaFNsaWRlcil7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlci52YWx1ZSA9IHBhcnNlSW50KG5ld1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmJydXNoTnVtYmVySW5wdXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC52YWx1ZSA9IHBhcnNlSW50KG5ld1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVCcnVzaFNsaWRlckNoYW5nZShldmVudCl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZShldmVudCl7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlQWN0aXZlKGV2ZW50KXtcbiAgICAgICAgbGV0IGlzQWN0aXZlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpO1xuICAgICAgICBpZihpc0FjdGl2ZSA9PSBcInRydWVcIil7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZmluZCBhbnkgb3RoZXIgdG9vbHMgaW4gbXkgcGFyZW50XG4gICAgICAgICAgICAvLyBlbGVtZW50IGFuZCBkZWFjdGl2YXRlIHRoZW0uXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnYWN0aXZlJykgPT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhpcyB0b29sIHRvIGJlIGFjdGl2ZVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZXJhc2VyLXRvb2wnLCBFcmFzZXJUb29sKTtcblxuZXhwb3J0IHtcbiAgICBFcmFzZXJUb29sLFxuICAgIEVyYXNlclRvb2wgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogUGVuY2lsVG9vbFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgcHJvdmlkZSBwZW5jaWwtbGlrZSBkcmF3aW5nIGNhcGFiaWxpdHlcbiAqIG9uIHRoZSBzaGFkb3cgY2FudmFzIG9mIG15IHBhcmVudCBlbGVtZW50LlxuICogSSBhbSBleHBsaWNpdGx5IGRlc2lnbmVkIGZvciB1c2Ugd2l0aFxuICogRHJhd2luZ1ZpZXdcbiAqL1xuY29uc3QgcGVuY2lsU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXBlbmNpbFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNNCAyMGg0bDEwLjUgLTEwLjVhMS41IDEuNSAwIDAgMCAtNCAtNGwtMTAuNSAxMC41djRcIiAvPlxuICA8bGluZSB4MT1cIjEzLjVcIiB5MT1cIjYuNVwiIHgyPVwiMTcuNVwiIHkyPVwiMTAuNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHBlbmNpbFRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA2cHg7XG4gICAgfVxuICAgICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIC0tYWN0aXZlLWNvbG9yOiBibGFjaztcbiAgICAgICAgLS1pbmFjdGl2ZS1jb2xvcjogcmdiKDE3MCwgMTcwLCAxNzApO1xuICAgICAgICAtLWhvdmVyLWNvbG9yOiByZ2IoMTQwLCAxNDAsIDE0MCk7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBib3JkZXItd2lkdGg6IDFweDtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+ICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgICNicnVzaGVzLWNvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgI2JydXNoLWFkanVzdGVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBib3JkZXItd2lkdGg6IDFweDtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICAjYnJ1c2gtc2xpZGVyLFxuICAgICNicnVzaC1udW1iZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAjYnJ1c2gtbnVtYmVyIHtcbiAgICAgICAgbWF4LXdpZHRoOiAzcmVtO1xuICAgIH1cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiAjYnJ1c2hlcy1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwidG9vbC1idXR0b25cIj5cbiAgJHtwZW5jaWxTVkd9XG48L2Rpdj5cbjxkaXYgaWQ9XCJicnVzaGVzLWNvbnRhaW5lclwiPlxuICA8ZGl2IGlkPVwiYnJ1c2gtYWRqdXN0ZXJcIj5cbiAgICA8aW5wdXQgaWQ9XCJicnVzaC1zbGlkZXJcIiB0eXBlPVwicmFuZ2VcIiBtaW49XCIxXCIgbWF4PVwiMTAwXCIgc3RlcD1cIjFcIj5cbiAgICA8aW5wdXQgaWQ9XCJicnVzaC1udW1iZXJcIiB0eXBlPVwibnVtYmVyXCI+XG4gIDwvZGl2PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBQZW5jaWxUb29sIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHNoYWRvdyBkb20uIFRoaXMgdG9vbCB3aWxsXG4gICAgICAgIC8vIGRpc3BsYXkgaXRzZWxmIGFzIGEgYnV0dG9uIHRoYXQgY2FuXG4gICAgICAgIC8vIGJlIHRvZ2dsZWQuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHBlbmNpbFRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZHJhd2luZyBjb250ZXh0XG4gICAgICAgIC8vIGlzIG51bGwuIFRoaXMgd2lsbCBiZSBzZXRcbiAgICAgICAgLy8gaWYgYW5kIHdoZW4gdGhpcyB0b29sIGlzXG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgIC8vIHRoYXQgaGFzIGEgY29udGV4dFxuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUgPSB0aGlzLnRvZ2dsZUFjdGl2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcyA9IHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UgPSB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZSA9IHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLmhhc0F0dHJpYnV0ZSgnd2lkdGgnKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBJIGFtIHRoZSBvbmx5IHRvb2wgaW4gbXkgcGFyZW50LFxuICAgICAgICAgICAgICAgIC8vIHNldCBteXNlbGYgdG8gYWN0aXZlXG4gICAgICAgICAgICAgICAgbGV0IHNpYmxpbmdUb29scyA9IHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKTtcbiAgICAgICAgICAgICAgICBpZihzaWJsaW5nVG9vbHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndG9vbC1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVBY3RpdmUpO1xuICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYnJ1c2gtc2xpZGVyJyk7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2JydXNoLW51bWJlcicpO1xuICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGlzIGN1cnJlbnRseSBhIHdpZHRoIHNldCxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2xpZGVyIGFuZCBudW1iZXIgaW5wdXQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIGxldCBjdXJyZW50V2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRXaWR0aCl7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnZhbHVlID0gcGFyc2VJbnQoY3VycmVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQudmFsdWUgPSBwYXJzZUludChjdXJyZW50V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICB0aGlzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgdGhpcy5icnVzaFNsaWRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UpO1xuICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UpO1xuICAgIH1cblxuICAgIHN0YXJ0KHgsIHkpe1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIG9uTW92ZSh4LCB5KXtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBlbmQoeCwgeSl7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHNldENvbnRleHRGcm9tQXR0cmlidXRlcygpe1xuICAgICAgICAvLyBsaW5lIGNhcFxuICAgICAgICBsZXQgbGluZUNhcCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsaW5lLWNhcCcpO1xuICAgICAgICBpZihsaW5lQ2FwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUNhcCA9IFwicm91bmRcIjsgLy8gZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGluZSBqb2luXG4gICAgICAgIGxldCBsaW5lSm9pbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsaW5lLWpvaW4nKTtcbiAgICAgICAgaWYobGluZUpvaW4pe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGluZSB3aWR0aFxuICAgICAgICBsZXQgbGluZVdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICAgIGlmKGxpbmVXaWR0aCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSBwYXJzZUludChsaW5lV2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gNjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCl7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgJ2xpbmUtam9pbicsXG4gICAgICAgICAgICAnbGluZS1jYXAnXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbCwgbmV3VmFsKXtcbiAgICAgICAgaWYobmFtZSA9PSAnd2lkdGgnKXtcbiAgICAgICAgICAgIGlmKHRoaXMuYnJ1c2hTbGlkZXIpe1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIudmFsdWUgPSBwYXJzZUludChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5icnVzaE51bWJlcklucHV0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQudmFsdWUgPSBwYXJzZUludChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UoZXZlbnQpe1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cblxuICAgIGhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UoZXZlbnQpe1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cblxuICAgIHRvZ2dsZUFjdGl2ZShldmVudCl7XG4gICAgICAgIGxldCBpc0FjdGl2ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKTtcbiAgICAgICAgaWYoaXNBY3RpdmUgPT0gXCJ0cnVlXCIpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QsIGZpbmQgYW55IG90aGVyIHRvb2xzIGluIG15IHBhcmVudFxuICAgICAgICAgICAgLy8gZWxlbWVudCBhbmQgZGVhY3RpdmF0ZSB0aGVtLlxuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpID09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG9vbCB0byBiZSBhY3RpdmVcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgncGVuY2lsLXRvb2wnLCBQZW5jaWxUb29sKTtcblxuZXhwb3J0IHtcbiAgICBQZW5jaWxUb29sLFxuICAgIFBlbmNpbFRvb2wgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBFZGl0b3JUYWIgZnJvbSAnLi9FZGl0b3JUYWIuanMnO1xuaW1wb3J0IEVkaXRvclByb3BMaXN0IGZyb20gJy4vRWRpdG9yUHJvcExpc3QuanMnO1xuaW1wb3J0IEVkaXRvck1lc3NlbmdlciBmcm9tICcuL0VkaXRvck1lc3Nlbmdlci5qcyc7XG5pbXBvcnQgRWRpdG9yQ3VzdG9tTGlzdCBmcm9tICcuL0VkaXRvckN1c3RvbUxpc3QuanMnO1xuaW1wb3J0IEVkaXRvclN1YnBhcnRzUGFuZSBmcm9tICcuL0VkaXRvclN1YnBhcnRzUGFuZS5qcyc7XG5pbXBvcnQgcGFydEljb25zIGZyb20gJy4uLy4uL3V0aWxzL2ljb25zLmpzJztcbi8vIFBSRUFNQkxFXG5cbi8vIEFkZCBlZGl0b3IgdGFiIGVsZW1lbnRcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci10YWInLCBFZGl0b3JUYWIpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLXByb3BzLWxpc3QnLCBFZGl0b3JQcm9wTGlzdCk7XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3ItY3VzdG9tLWxpc3QnLCBFZGl0b3JDdXN0b21MaXN0KTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1tZXNzZW5nZXInLCBFZGl0b3JNZXNzZW5nZXIpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLXN1YnBhcnRzJywgRWRpdG9yU3VicGFydHNQYW5lKTtcblxuY29uc3QgY2xvc2VCdXR0b24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXIteFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjOWU5ZTllXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxsaW5lIHgxPVwiMThcIiB5MT1cIjZcIiB4Mj1cIjZcIiB5Mj1cIjE4XCIgLz5cbiAgPGxpbmUgeDE9XCI2XCIgeTE9XCI2XCIgeDI9XCIxOFwiIHkyPVwiMThcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBzY3JpcHRJY29uID0gYFxuPHN2ZyBpZD0nc2NyaXB0JyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWZpbGUtY29kZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgICA8cGF0aCBkPVwiTTE0IDN2NGExIDEgMCAwIDAgMSAxaDRcIiAvPlxuICAgIDxwYXRoIGQ9XCJNMTcgMjFoLTEwYTIgMiAwIDAgMSAtMiAtMnYtMTRhMiAyIDAgMCAxIDIgLTJoN2w1IDV2MTFhMiAyIDAgMCAxIC0yIDJ6XCIgLz5cbiAgICA8cGF0aCBkPVwiTTEwIDEzbC0xIDJsMSAyXCIgLz5cbiAgICA8cGF0aCBkPVwiTTE0IDEzbDEgMmwtMSAyXCIgLz5cbjwvc3ZnPmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwNSUpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTUwbXMgbGluZWFyO1xuICAgICAgICB3aWR0aDogNDAwcHg7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjUpO1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDEwcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICB9XG4gICAgXG4gICAgOmhvc3QoLm9wZW4pe1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCUpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTUwbXMgbGluZWFyO1xuICAgICAgICB6LWluZGV4OiAxMDA7XG4gICAgfVxuXG4gICAgOmhvc3QoOjphZnRlcikge1xuICAgICAgICBjb250ZW50OiBcIiBcIjtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogNXB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogLTEwO1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMHB4IDNweCAxMHB4IHJnYmEoMTAwLCAxMDAsIDEwMCwgMC42KTtcbiAgICB9XG5cbiAgICA6OnNsb3R0ZWQoZWRpdG9yLXByb3BzLWxpc3Q6bm90KC5zaG93LXBhbmUpKSxcbiAgICA6OnNsb3R0ZWQoZWRpdG9yLW1lc3Nlbmdlcjpub3QoLnNob3ctcGFuZSkpLFxuICAgIDo6c2xvdHRlZChlZGl0b3ItY3VzdG9tLWxpc3Q6bm90KC5zaG93LXBhbmUpKSxcbiAgICA6OnNsb3R0ZWQoZWRpdG9yLXN1YnBhcnRzOm5vdCguc2hvdy1wYW5lKSl7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgI3RhYi1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG4gICAgXG4gICAgI3BhbmUtYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBtYXJnaW4tdG9wOiAyMHB4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cblxuICAgICNoZWFkZXItYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICB9XG5cbiAgICAuaGVhZGVyLXNpZGUge1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBtYXJnaW4tdG9wOiAyMHB4O1xuICAgIH1cblxuICAgICNkaXNwbGF5LWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAzMHB4O1xuICAgIH1cblxuICAgICNoZWFkZXItYXJlYSBoMyB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDVweDtcbiAgICAgICAgZm9udC1zaXplOiAxLjdyZW07XG4gICAgfVxuXG4gICAgI2hlYWRlci1sZWZ0ID4gaW5wdXQge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBhZGRpbmc6IDRweDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuOCk7XG4gICAgICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xuICAgIH1cblxuICAgICNoZWFkZXItcmlnaHQgPiBidXR0b24ge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44NWVtO1xuICAgIH1cblxuICAgICNoZWFkZXItcmlnaHQgPiBidXR0b246aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC4zKTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLXJpZ2h0ID4gYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC44KTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMjAsIDIyMCwgMjIwKTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLXJpZ2h0ID4gYnV0dG9uID4gc3ZnIHtcbiAgICAgICAgaGVpZ2h0OiAxLjNlbTtcbiAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgIH1cblxuICAgICNoZWFkZXItbGVmdCB7XG4gICAgICAgIG1heC13aWR0aDogODAlO1xuICAgIH1cblxuICAgICNoZWFkZXItbGVmdCBzcGFuIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICAgICAgZm9udC1zaXplOiAxLjFyZW07XG4gICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cblxuICAgICNpY29uLWRpc3BsYXktYXJlYSB7XG4gICAgICAgIHdpZHRoOiAxLjdyZW07XG4gICAgICAgIGhlaWdodDogMS43cmVtO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7XG4gICAgfVxuICAgICNpY29uLWRpc3BsYXktYXJlYSA+IHN2ZyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuXG4gICAgI2Nsb3NlLWJ1dHRvbiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogNTtcbiAgICAgICAgcmlnaHQ6IDU7XG4gICAgfVxuICAgICNjbG9zZS1idXR0b246aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJjbG9zZS1idXR0b25cIj4ke2Nsb3NlQnV0dG9ufTwvZGl2PlxuPGRpdiBpZD1cImhlYWRlci1hcmVhXCI+XG4gICAgPGRpdiBpZD1cImhlYWRlci1sZWZ0XCIgY2xhc3M9XCJoZWFkZXItc2lkZVwiPlxuICAgICAgICA8ZGl2IGlkPVwiZGlzcGxheS1hcmVhXCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwiaWNvbi1kaXNwbGF5LWFyZWFcIj48L2Rpdj5cbiAgICAgICAgICAgIDxoMz48L2gzPjxzcGFuPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwicGFydC1uYW1lLWlucHV0XCIvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoZWFkZXItcmlnaHRcIiBjbGFzcz1cImhlYWRlci1zaWRlXCI+XG4gICAgICAgIDxidXR0b24gaWQ9XCJlZGl0LXNjcmlwdC1idXR0b25cIj5cbiAgICAgICAgICAgICR7c2NyaXB0SWNvbn1cbiAgICAgICAgICAgIDxzcGFuPkVkaXQgU2NyaXB0PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBpZD1cInRhYi1hcmVhXCI+XG4gICAgPGVkaXRvci10YWIgYWN0aXZlPVwidHJ1ZVwiIG5hbWU9XCJwcm9wZXJ0aWVzXCI+UHJvcGVydGllczwvZWRpdG9yLXRhYj5cbiAgICA8ZWRpdG9yLXRhYiBuYW1lPVwiY3VzdG9tXCI+Q3VzdG9tPC9lZGl0b3ItdGFiPlxuICAgIDxlZGl0b3ItdGFiIG5hbWU9XCJtZXNzZW5nZXJcIj5NZXNzZW5nZXI8L2VkaXRvci10YWI+XG4gICAgPGVkaXRvci10YWIgbmFtZT1cInN1YnBhcnRzXCI+U3VicGFydHM8L2VkaXRvci10YWI+XG48L2Rpdj5cbjxkaXYgaWQ9XCJwYW5lLWFyZWFcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIEVkaXRvciBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMudG9nZ2xlID0gdGhpcy50b2dnbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuID0gdGhpcy5vcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jZW50ZXJPbkVsZW1lbnQgPSB0aGlzLmNlbnRlck9uRWxlbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVuZG9DZW50ZXJPbkVsZW1lbnQgPSB0aGlzLnVuZG9DZW50ZXJPbkVsZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVIZWFkZXIgPSB0aGlzLnVwZGF0ZUhlYWRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNoZWNrRm9yTmF2aWdhdGlvbiA9IHRoaXMuY2hlY2tGb3JOYXZpZ2F0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZU1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25UYWJBY3RpdmF0ZWQgPSB0aGlzLm9uVGFiQWN0aXZhdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25OYW1lSW5wdXRDaGFuZ2UgPSB0aGlzLm9uTmFtZUlucHV0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25FZGl0U2NyaXB0Q2xpY2sgPSB0aGlzLm9uRWRpdFNjcmlwdENsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RhYi1hY3RpdmF0ZWQnLCB0aGlzLm9uVGFiQWN0aXZhdGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2Nsb3NlLWJ1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgICAgIGxldCBuYW1lSW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdwYXJ0LW5hbWUtaW5wdXQnKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uTmFtZUlucHV0Q2hhbmdlKTtcblxuICAgICAgICAgICAgbGV0IGVkaXRTY3JpcHRCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdlZGl0LXNjcmlwdC1idXR0b24nKTtcbiAgICAgICAgICAgIGVkaXRTY3JpcHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRWRpdFNjcmlwdENsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFiLWFjdGl2YXRlZCcsIHRoaXMub25UYWJBY3RpdmF0ZWQpO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjbG9zZS1idXR0b24nKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAgIHRoaXMuY2xvc2VcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEV2ZW50c1xuICAgICAgICBsZXQgbmFtZUlucHV0ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgncGFydC1uYW1lLWlucHV0Jyk7XG4gICAgICAgIG5hbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uTmFtZUlucHV0Q2hhbmdlKTtcblxuICAgICAgICBsZXQgZWRpdFNjcmlwdEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2VkaXQtc2NyaXB0LWJ1dHRvbicpO1xuICAgICAgICBlZGl0U2NyaXB0QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkVkaXRTY3JpcHRDbGljayk7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCl7XG4gICAgICAgIGlmKHRoaXMuaXNPcGVuKXtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3Blbigpe1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5jZW50ZXJPbkVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpe1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcbiAgICAgICAgdGhpcy51bmRvQ2VudGVyT25FbGVtZW50KCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5yZW1vdmVQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcbiAgICAgICAgdGhpcy5tb2RlbC5hZGRQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGluY29taW5nIG1vZGVsIGlzIGEgQ2FyZCBvclxuICAgICAgICAvLyBTdGFjayB0aGF0IGlzIG5vdCB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgIC8vIHdlIG5hdmlnYXRlIHRvIGl0XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnY2FyZCcgfHwgdGhpcy5tb2RlbC50eXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgdGhpcy5jaGVja0Zvck5hdmlnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsb3NlIGFueSBvcGVuIEhhbG9zLlxuICAgICAgICAvLyBJZiB0aGUgbmV3IG1vZGVsIHdhbnRzIGEgSGFsbyxcbiAgICAgICAgLy8gb3BlbiBpdCBvbiB0aGUgVmlldyBmb3IgdGhhdCBNb2RlbC5cbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuZWRpdGluZ2ApKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGVsLmNsb3NlSGFsbygpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRhcmdldFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7dGhpcy5tb2RlbC5pZH1cIl1gKTtcbiAgICAgICAgaWYodGFyZ2V0VmlldyAmJiB0YXJnZXRWaWV3LndhbnRzSGFsbyl7XG4gICAgICAgICAgICB0YXJnZXRWaWV3Lm9wZW5IYWxvKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMudXBkYXRlSGVhZGVyKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgc2xvdHRlZCBpbm5lciBET01cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIEFkZCBwYW5lc1xuICAgICAgICBsZXQgcHJvcHNQYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLXByb3BzLWxpc3QnKTtcbiAgICAgICAgcHJvcHNQYW5lLnNldEF0dHJpYnV0ZSgndGFiLW5hbWUnLCAncHJvcGVydGllcycpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHByb3BzUGFuZSk7XG4gICAgICAgIHByb3BzUGFuZS5yZW5kZXIodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgbGV0IG1lc3NlbmdlclBhbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItbWVzc2VuZ2VyJyk7XG4gICAgICAgIG1lc3NlbmdlclBhbmUuc2V0QXR0cmlidXRlKCd0YWItbmFtZScsICdtZXNzZW5nZXInKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChtZXNzZW5nZXJQYW5lKTtcbiAgICAgICAgbWVzc2VuZ2VyUGFuZS5yZW5kZXIodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgbGV0IGN1c3RvbVBhbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItY3VzdG9tLWxpc3QnKTtcbiAgICAgICAgY3VzdG9tUGFuZS5zZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJywgJ2N1c3RvbScpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGN1c3RvbVBhbmUpO1xuICAgICAgICBjdXN0b21QYW5lLnJlbmRlcih0aGlzLm1vZGVsKTtcblxuICAgICAgICBsZXQgc3VicGFydHNQYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLXN1YnBhcnRzJyk7XG4gICAgICAgIHN1YnBhcnRzUGFuZS5zZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJywgJ3N1YnBhcnRzJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3VicGFydHNQYW5lKTtcbiAgICAgICAgc3VicGFydHNQYW5lLnJlbmRlcih0aGlzLm1vZGVsKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBhY3RpdmUgdGFiIGFuZCBzaG93IGl0cyBjb3JyZXNwb25kaW5nIHBhbmVcbiAgICAgICAgbGV0IGFjdGl2ZVRhYiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihgZWRpdG9yLXRhYlthY3RpdmU9XCJ0cnVlXCJdYCk7XG4gICAgICAgIGlmKGFjdGl2ZVRhYil7XG4gICAgICAgICAgICBsZXQgYWN0aXZlTmFtZSA9IGFjdGl2ZVRhYi5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbdGFiLW5hbWVdJykpLmZvckVhY2gocGFuZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBwYW5lLmdldEF0dHJpYnV0ZSgndGFiLW5hbWUnKTtcbiAgICAgICAgICAgICAgICBpZihuYW1lID09IGFjdGl2ZU5hbWUpe1xuICAgICAgICAgICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ3Nob3ctcGFuZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdy1wYW5lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIHBhbmUgaXMgYWxyZWFkeSBvcGVuLCB0aGVuIGNlbnRlclxuICAgICAgICAvLyBvbiB0aGUgcHJpbWFyeSB2aWV3IGVsZW1lbnQgZm9yIHRoZSBtb2RlbFxuICAgICAgICBpZih0aGlzLmlzT3Blbil7XG4gICAgICAgICAgICB0aGlzLmNlbnRlck9uRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2VudGVyT25FbGVtZW50KCl7XG4gICAgICAgIC8vIFVzZSBDU1MgdHJhbnNmb3JtcyBvZiB0aGUgd2hvbGUgV29ybGQgdG8gY2VudGVyIG9uXG4gICAgICAgIC8vIHRoZSBwcmltYXJ5IHZpZXcgZWxlbWVudCBvZiB0aGUgUGFydCBiZWluZyBlZGl0ZWQsXG4gICAgICAgIC8vIGlmIHNldC4gSWYgbm90IHNldCwgZG8gbm90aGluZy5cbiAgICAgICAgaWYodGhpcy5tb2RlbCl7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZWRpdGluZyBhIENhcmQsIFN0YWNrLCBvciBXb3JsZCwgdGhlblxuICAgICAgICAgICAgLy8gd2UgdW5jZW50ZXIgYW5kIHJldHVyblxuICAgICAgICAgICAgbGV0IGlzQ2FyZFN0YWNrT3JXb3JsZCA9IFsnY2FyZCcsICdzdGFjaycsICd3b3JsZCddLmluY2x1ZGVzKHRoaXMubW9kZWwudHlwZSk7XG4gICAgICAgICAgICBpZihpc0NhcmRTdGFja09yV29ybGQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuZG9DZW50ZXJPbkVsZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHBhcnRWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgICAgICBsZXQgd29ybGRWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQoJ3dvcmxkJyk7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHdvcmxkVmlldy5nZXRBdHRyaWJ1dGUoJ2NlbnRlcmVkLW9uJyk7XG4gICAgICAgICAgICBpZihjdXJyZW50ID09IHRoaXMubW9kZWwuaWQudG9TdHJpbmcoKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbWVudVJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGV0IHBhcnRSZWN0ID0gcGFydFZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgYWN0dWFsIHZpZXdhYmxlIHdpZHRoLCBwbHVzIHRoZSBlZGl0b3IgbWVudVxuICAgICAgICAgICAgbGV0IHZpZXdXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICsgbWVudVJlY3Qud2lkdGg7XG4gICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gbWVudVJlY3QuaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgWCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgbGV0IHRhcmdldFggPSAodmlld1dpZHRoIC0gcGFydFJlY3Qud2lkdGgpIC8gMjtcbiAgICAgICAgICAgIGxldCBuZXdYO1xuICAgICAgICAgICAgaWYodGFyZ2V0WCA8IHBhcnRSZWN0LmxlZnQpe1xuICAgICAgICAgICAgICAgIG5ld1ggPSAocGFydFJlY3QubGVmdCAtIHRhcmdldFgpICogLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ggPSB0YXJnZXRYIC0gcGFydFJlY3QubGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIFkgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIGxldCB0YXJnZXRZID0gKHZpZXdIZWlnaHQgLSBwYXJ0UmVjdC5oZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIGxldCBuZXdZO1xuICAgICAgICAgICAgaWYodGFyZ2V0WSA8IHBhcnRSZWN0LnRvcCl7XG4gICAgICAgICAgICAgICAgbmV3WSA9IChwYXJ0UmVjdC50b3AgLSB0YXJnZXRZKSAqIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdZID0gdGFyZ2V0WSAtIHBhcnRSZWN0LnRvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29ybGRWaWV3LnNldEF0dHJpYnV0ZSgnY2VudGVyZWQtb24nLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2V0IHRyYW5zZm9ybSBhbmQgdHJhbnNpdGlvblxuICAgICAgICAgICAgd29ybGRWaWV3LnN0eWxlLnRyYW5zaXRpb24gPSBcInRyYW5zZm9ybSAwLjNzIGVhc2Utb3V0XCI7XG4gICAgICAgICAgICB3b3JsZFZpZXcuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke25ld1h9cHgsICR7bmV3WX1weClgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5kb0NlbnRlck9uRWxlbWVudCgpe1xuICAgICAgICBsZXQgd29ybGRWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQoJ3dvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVBdHRyaWJ1dGUoJ2NlbnRlcmVkLW9uJyk7XG4gICAgICAgIHdvcmxkVmlldy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNmb3JtJyk7XG4gICAgfVxuXG4gICAgdXBkYXRlSGVhZGVyKCl7XG4gICAgICAgIGxldCBuYW1lSW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNoZWFkZXItbGVmdCA+IGlucHV0Jyk7XG4gICAgICAgIGxldCB0eXBlRGlzcGxheSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI2Rpc3BsYXktYXJlYSA+IGgzJyk7XG4gICAgICAgIGxldCBpZERpc3BsYXkgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNkaXNwbGF5LWFyZWEgPiBzcGFuJyk7XG4gICAgICAgIGxldCBpY29uRGlzcGxheSA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2ljb24tZGlzcGxheS1hcmVhJyk7XG5cbiAgICAgICAgbGV0IHBhcnROYW1lID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICduYW1lJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmKHBhcnROYW1lICYmIHBhcnROYW1lICE9PSBcIlwiKXtcbiAgICAgICAgICAgIG5hbWVJbnB1dC52YWx1ZSA9IHBhcnROYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZUlucHV0LnZhbHVlID0gXCIoVW5uYW1lZClcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGVEaXNwbGF5LnRleHRDb250ZW50ID0gdGhpcy5tb2RlbC50eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGhpcy5tb2RlbC50eXBlLnNsaWNlKDEpO1xuICAgICAgICBpZERpc3BsYXkudGV4dENvbnRlbnQgPSBgaWQ9JHt0aGlzLm1vZGVsLmlkfWA7XG4gICAgICAgIGlkRGlzcGxheS50aXRsZSA9IHRoaXMubW9kZWwuaWQ7XG5cbiAgICAgICAgaWYoT2JqZWN0LmtleXMocGFydEljb25zKS5pbmNsdWRlcyh0aGlzLm1vZGVsLnR5cGUpKXtcbiAgICAgICAgICAgIGljb25EaXNwbGF5LmlubmVySFRNTCA9IHBhcnRJY29uc1t0aGlzLm1vZGVsLnR5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWNvbkRpc3BsYXkuaW5uZXJIVE1MID0gcGFydEljb25zLmdlbmVyaWM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja0Zvck5hdmlnYXRpb24oKXtcbiAgICAgICAgLy8gSWYgdGhlIG1vZGVsIGlzIGEgQ2FyZCBvciBTdGFjayB0aGF0XG4gICAgICAgIC8vIGlzIG5vdCB0aGUgY3VycmVudCAoaWUsIG5vdCBiZWluZyBkaXNwbGF5ZWRcbiAgICAgICAgLy8gaW4gdGhlIG1haW4gd2luZG93KSwgdGhlbiB3ZSBzaG91bGQgbmF2aWdhdGVcbiAgICAgICAgLy8gdG8gaXRcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHdpbmRvdy5TeXN0ZW0ud29ybGQuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudENhcmQgPSBjdXJyZW50U3RhY2suY3VycmVudENhcmQ7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnY2FyZCcgJiYgdGhpcy5tb2RlbC5pZCAhPSBjdXJyZW50Q2FyZC5pZCl7XG4gICAgICAgICAgICBjdXJyZW50U3RhY2suZ29Ub0NhcmRCeUlkKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5tb2RlbC50eXBlID09ICdzdGFjaycgJiYgdGhpcy5tb2RlbC5pZCAhPSBjdXJyZW50U3RhY2suaWQpe1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS53b3JsZC5nb1RvU3RhY2tCeUlkKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIHJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLnR5cGUpe1xuICAgICAgICBjYXNlICdwcm9wZXJ0eUNoYW5nZWQnOlxuICAgICAgICAgICAgLy8gRmluZCBhbnkgbmVzdGVkIGVkaXRvci1wcm9wLWl0ZW0gZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGFuZCByZS1yZW5kZXIsIHNvIHRoZXkgZGlzcGxheSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgLy8gdmFsdWVzIGluIHRoZSBlZGl0b3JcbiAgICAgICAgICAgIGxldCBxdWVyeVN0cmluZyA9IGBlZGl0b3ItcHJvcC1pdGVtW25hbWU9XCIke2FNZXNzYWdlLnByb3BlcnR5TmFtZX1cIl1bb3duZXItaWQ9XCIke2FNZXNzYWdlLnBhcnRJZH1cIl1gO1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnlTdHJpbmcpKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBpZihlbC5wcm9wZXJ0eS52YWx1ZSAhPT0gYU1lc3NhZ2UudmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25UYWJBY3RpdmF0ZWQoZXZlbnQpe1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnZWRpdG9yLXRhYicpKVxuICAgICAgICAgICAgLmZpbHRlcih0YWJFbCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYkVsICE9PSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKHRhYkVsID0+IHtcbiAgICAgICAgICAgICAgICB0YWJFbC5yZW1vdmVBdHRyaWJ1dGUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBuYW1lIG9mIHRoZSBhY3RpdmF0ZWQgdGFiXG4gICAgICAgIGxldCB0YXJnZXROYW1lID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW3RhYi1uYW1lXScpKS5mb3JFYWNoKHBhbmUgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBwYW5lLmdldEF0dHJpYnV0ZSgndGFiLW5hbWUnKTtcbiAgICAgICAgICAgIGlmKG5hbWUgPT0gdGFyZ2V0TmFtZSl7XG4gICAgICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QuYWRkKCdzaG93LXBhbmUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93LXBhbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25OYW1lSW5wdXRDaGFuZ2UoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIGxldCBuZXdOYW1lID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgIG5ld05hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkVkaXRTY3JpcHRDbGljayhldmVudCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaXNPcGVuKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yLFxuICAgIEVkaXRvciBhcyBkZWZhdWx0XG59O1xuIiwiXG5cbi8vIFBSRUFNQkxFXG5cbmNvbnN0IGNhcmV0RG93bkljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2FyZXQtZG93blwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTggMTVsLTYgLTZsLTYgNmgxMlwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY2FyZXRSaWdodEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2FyZXQtcmlnaHRcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTE4IDE1bC02IC02bC02IDZoMTJcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgMTIgMTIpXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cblxuICAgICNwcm9wcy1saXN0IHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIH1cbiAgICAjZmlsdGVyLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG4gICAgI2ZpbHRlci1hcmVhID4gaW5wdXQge1xuICAgICAgICBtaW4td2lkdGg6IDA7XG4gICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBmb250LXNpemU6IDEuMHJlbTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA2cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDZweDtcbiAgICAgICAgcGFkZGluZy10b3A6IDNweDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDNweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjgpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgfVxuICAgIFxuICAgICNuZXctcHJvcC1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgI25ldy1wcm9wLWFyZWEub3BlbiA+ICNuZXctcHJvcC1mb3JtIHtcbiAgICAgICAgZGlzcGxheTpmbGV4O1xuICAgIH1cblxuICAgICNuZXctcHJvcC1mb3JtIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLnJvdyB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxZW07XG4gICAgfVxuXG4gICAgaDMge1xuICAgICAgICBwYWRkaW5nOiAwcHg7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDFlbTtcbiAgICB9XG5cbiAgICAjbmV3LXByb3AtZm9ybSA+IC5yb3cgPiAqIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxNnB4O1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDhweDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogOHB4O1xuICAgIH1cbiAgICAjbmV3LXByb3AtZm9ybSBpbnB1dCB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjcpO1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBwYWRkaW5nOiA2cHg7XG4gICAgfVxuXG4gICAgI25ldy1wcm9wLW5hbWU6aW52YWxpZCB7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZWQ7XG4gICAgfVxuICAgIFxuICAgIHNlbGVjdCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMWVtO1xuICAgIH1cbiAgICAjYWRkLXByb3AtZHJvcGRvd24tY29udHJvbCB7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIH1cblxuICAgICNhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sOmhvdmVyLFxuICAgICNhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sIGxhYmVsIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cblxuICAgICNjYXJldC1idXR0b24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxLjVlbTtcbiAgICAgICAgaGVpZ2h0OiAxLjVlbTtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGxpbmVhcjtcbiAgICB9XG5cbiAgICAjY2FyZXQtYnV0dG9uID4gc3ZnIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG4gICAgI25ldy1wcm9wLWFyZWEub3BlbiAjY2FyZXQtYnV0dG9uIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xcyBsaW5lYXI7XG4gICAgfVxuXG48L3N0eWxlPlxuPGRpdiBpZD1cIm5ldy1wcm9wLWFyZWFcIj5cbiAgICA8ZGl2IGNsYXNzPVwicm93XCIgaWQ9XCJhZGQtcHJvcC1kcm9wZG93bi1jb250cm9sXCI+XG4gICAgICAgIDxoMz48bGFiZWwgZm9yPVwiY2FyZXQtYnV0dG9uXCI+QWRkIE5ldyBQcm9wZXJ0eTwvbGFiZWw+PC9oMz5cbiAgICAgICAgPGRpdiBpZD1cImNhcmV0LWJ1dHRvblwiPiR7Y2FyZXRSaWdodEljb259PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cIm5ldy1wcm9wLWZvcm1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cIm5ldy1wcm9wLW5hbWVcIj5Qcm9wZXJ0eSBOYW1lIDwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cIm5ldy1wcm9wLW5hbWVcIiBwbGFjZWhvbGRlcj1cInByb3BlcnR5LW5hbWVcIiBwYXR0ZXJuPVwiW2EtelxcXFwtXXszLDY0fVwiLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJkZWZhdWx0LXZhbC1zZWxlY3RcIj5EZWZhdWx0IHZhbHVlIHR5cGU8L2xhYmVsPlxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cImRlZmF1bHQtdmFsLXNlbGVjdFwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIiBzZWxlY3RlZD5Ob25lPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInN0cmluZ1wiPlRleHQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibnVtYmVyXCI+TnVtYmVyPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJvb2xlYW5cIj5UcnVlIG9yIEZhbHNlPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJkZWZhdWx0LXZhbHVlXCI+RGVmYXVsdCB2YWx1ZSA8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJkZWZhdWx0LXZhbHVlXCIgcGxhY2Vob2xkZXI9XCJEZWZhdWx0IHZhbHVlXCIgZGlzYWJsZWQvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiIGlkPVwic3VibWl0LWNvbnRyb2xcIj5cbiAgICAgICAgICAgIDxidXR0b24gaWQ9XCJzdWJtaXQtcHJvcFwiPkNyZWF0ZTwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBpZD1cImZpbHRlci1hcmVhXCI+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJmaWx0ZXItaW5wdXRcIiBuYW1lPVwiZmlsdGVyLWlucHV0XCIgcGxhY2Vob2xkZXI9XCJGaWx0ZXIuLi5cIi8+XG4gICAgPGJ1dHRvbiBpZD1cImNsZWFyXCI+Q2xlYXI8L2J1dHRvbj5cbjwvZGl2PlxuPHVsIGlkPVwicHJvcHMtbGlzdFwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbjwvdWw+XG5gO1xuXG5jbGFzcyBFZGl0b3JDdXN0b21MaXN0IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0Rm9ybSA9IHRoaXMucmVzZXRGb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25EZWZhdWx0TmV3VHlwZUNoYW5nZSA9IHRoaXMub25EZWZhdWx0TmV3VHlwZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2FyZXRDbGljayA9IHRoaXMub25DYXJldENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DcmVhdGVTdWJtaXQgPSB0aGlzLm9uQ3JlYXRlU3VibWl0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25GaWx0ZXJJbnB1dCA9IHRoaXMub25GaWx0ZXJJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljayA9IHRoaXMub25GaWx0ZXJDbGVhckNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BUeXBlU2VsZWN0ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZGVmYXVsdC12YWwtc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BOYW1lSW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCduZXctcHJvcC1uYW1lJyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdkZWZhdWx0LXZhbHVlJyk7XG4gICAgICAgICAgICB0aGlzLmFkZFByb3BDb250cm9sID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYWRkLXByb3AtZHJvcGRvd24tY29udHJvbCcpO1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRm9ybSA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25ldy1wcm9wLWZvcm0nKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnc3VibWl0LXByb3AnKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjbGVhcicpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnB1dCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmFkZFByb3BDb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNhcmV0Q2xpY2spO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ3JlYXRlU3VibWl0KTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uRmlsdGVySW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25GaWx0ZXJDbGVhckNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuXG4gICAgICAgIC8vIENsZWFyIGFueSBtYWluIGRvbSBjaGlsZHJlblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc29ydGVkIGNvcHkgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIG9iamVjdHNcbiAgICAgICAgbGV0IGN1c3RvbVByb3BzID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdjdXN0b20tcHJvcGVydGllcydcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBzb3J0ZWQgbGlzdCBvZiB0aGUgY3VzdG9tIHByb3BlcnRpZXNcbiAgICAgICAgLy8gYXZhaWxhYmxlXG4gICAgICAgIHRoaXMucHJvcExpc3QgPSBPYmplY3QudmFsdWVzKGN1c3RvbVByb3BzKVxuICAgICAgICAgICAgLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3QubmFtZS5sb2NhbGVDb21wYXJlKHNlY29uZC5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgcHJvcGVydHkgaXRlbXMgYW5kIGluc2VydCB0aGVtXG4gICAgICAgIHRoaXMucHJvcExpc3QuZm9yRWFjaChwcm9wT2JqZWN0ID0+IHtcbiAgICAgICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1wcm9wLWl0ZW0nKTtcbiAgICAgICAgICAgIGVsLnNldFByb3BlcnR5KHByb3BPYmplY3QsIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCduYW1lJywgcHJvcE9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMubmV3UHJvcFR5cGVTZWxlY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbkRlZmF1bHROZXdUeXBlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5uZXdQcm9wVHlwZVNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uRGVmYXVsdE5ld1R5cGVDaGFuZ2UpO1xuICAgIH1cblxuICAgIG9uRGVmYXVsdE5ld1R5cGVDaGFuZ2UoZXZlbnQpe1xuICAgICAgICBsZXQgb3B0aW9uID0gZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9uc1swXTtcbiAgICAgICAgc3dpdGNoKG9wdGlvbi52YWx1ZSl7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgXCJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbnVtYmVyJyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG9wdGlvbi52YWx1ZSA9PSBcIlwiKXtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DYXJldENsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IG5ld1Byb3BBcmVhID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbmV3LXByb3AtYXJlYScpO1xuICAgICAgICBuZXdQcm9wQXJlYS5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJyk7XG4gICAgfVxuXG4gICAgb25DcmVhdGVTdWJtaXQoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIGxldCBwcm9wTmFtZSA9IHRoaXMubmV3UHJvcE5hbWVJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIGxldCBkZWZhdWx0VmFsdWUgPSB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudmFsdWU7XG4gICAgICAgICAgICBpZih0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudHlwZSA9PSAnY2hlY2tib3gnKXtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuY2hlY2tlZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudHlwZSA9PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBwcm9wZXJ0eSBjcmVhdGUgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbmV3UHJvcGVydHknLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuaWRcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjcmVhdGVkIHByb3AgdG8gdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIHZhbHVlXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFJlLXJlbmRlciB0aGlzIHBhbmVcbiAgICAgICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlckJ5KHRleHQpe1xuICAgICAgICAvLyBGaW5kIGFsbCBvZiB0aGUgcHJvcCBpdGVtIGVsZW1lbnRzIHdob3NlXG4gICAgICAgIC8vIHByb3BlcnR5IG5hbWUgZG9lcyAqbm90KiBpbmNsdWRlIHRoZSBzdWJzdHJpbmcsXG4gICAgICAgIC8vIGFuZCBzZXQgdGhvc2UgdG8gbm90IGRpc3BsYXlcbiAgICAgICAgbGV0IGFsbEVsZW1lbnRzID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2VkaXRvci1wcm9wLWl0ZW0nKSk7XG4gICAgICAgIGFsbEVsZW1lbnRzLmZvckVhY2gocHJvcEVsID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJvcEVsLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRleHQpKXtcbiAgICAgICAgICAgICAgICBwcm9wRWwuY2xhc3NMaXN0LnJlbW92ZSgnaXRlbS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcEVsLmNsYXNzTGlzdC5hZGQoJ2l0ZW0taGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uRmlsdGVySW5wdXQoZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlckJ5KGV2ZW50LnRhcmdldC52YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBvbkZpbHRlckNsZWFyQ2xpY2soZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5maWx0ZXJCeShcIlwiKTtcbiAgICB9XG5cbiAgICByZXNldEZvcm0oKXtcbiAgICAgICAgdGhpcy5uZXdQcm9wTmFtZUlucHV0LnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYodGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnR5cGUgPT0gJ2NoZWNrZWQnKXtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMubmV3UHJvcFR5cGVTZWxlY3Quc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JDdXN0b21MaXN0LFxuICAgIEVkaXRvckN1c3RvbUxpc3QgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBpbnRlcnByZXRlclNlbWFudGljcyBmcm9tICcuLi8uLi8uLi9vaG0vaW50ZXJwcmV0ZXItc2VtYW50aWNzLmpzJztcbmltcG9ydCB7b25Mb2NhdGlvbkxpbmtDbGljaywgZ2V0TG9jYXRpb25TdHJpbmdGb3J9IGZyb20gJy4vdXRpbHMvc3VicGFydHMuanMnO1xuXG4vLyBQUkVBTUJMRVxuY29uc3QgYXJyb3dMZWZ0SWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1hcnJvdy1uYXJyb3ctbGVmdFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxsaW5lIHgxPVwiNVwiIHkxPVwiMTJcIiB4Mj1cIjE5XCIgeTI9XCIxMlwiIC8+XG4gIDxsaW5lIHgxPVwiNVwiIHkxPVwiMTJcIiB4Mj1cIjlcIiB5Mj1cIjE2XCIgLz5cbiAgPGxpbmUgeDE9XCI1XCIgeTE9XCIxMlwiIHgyPVwiOVwiIHkyPVwiOFwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGNsaXBib2FyZEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2xpcGJvYXJkXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk05IDVoLTJhMiAyIDAgMCAwIC0yIDJ2MTJhMiAyIDAgMCAwIDIgMmgxMGEyIDIgMCAwIDAgMiAtMnYtMTJhMiAyIDAgMCAwIC0yIC0yaC0yXCIgLz5cbiAgPHJlY3QgeD1cIjlcIiB5PVwiM1wiIHdpZHRoPVwiNlwiIGhlaWdodD1cIjRcIiByeD1cIjJcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCguaGlkZGVuKXtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgLmJ1dHRvbi1saW5rIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC4zKTtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgZWFzZS1vdXQ7XG4gICAgICAgIHZlcnRpY2FsLWFsaWdubWVudDogY2VudGVyO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgcGFkZGluZzogMHB4O1xuICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICB9XG5cbiAgICAuYnV0dG9uLWxpbms6aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuNyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIC5idXR0b24tbGluayA+IHN2ZyB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA4cHg7XG4gICAgICAgIG9wYWNpdHk6IDAuNztcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDBweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgLmJ1dHRvbi1saW5rOmhvdmVyID4gc3ZnIHtcbiAgICAgICAgb3BhY2l0eTogMS4wO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTVweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuPC9zdHlsZT5cbjxwIGNsYXNzPVwicGFydC1pbmZvXCI+XG4gICAgTXkgPGJ1dHRvbiBpZD1cIm93bmVyLWxpbmtcIiBjbGFzcz1cImJ1dHRvbi1saW5rXCIgdGl0bGU9XCJcIj48c3Bhbj48L3NwYW4+JHthcnJvd0xlZnRJY29ufTwvYnV0dG9uPiBpcyBuYW1lZCA8c3BhbiBjbGFzcz1cInBhcnQtbmFtZVwiPjwvc3Bhbj4gYW5kIGlzIGxvY2F0ZWQgYXQgPGJ1dHRvbiBpZD1cImxvY2F0aW9uLWxpbmtcIiBjbGFzcz1cImJ1dHRvbi1saW5rXCIgdGl0bGU9XCJDb3B5IGxvY2F0aW9uXCI+PHNwYW4+PC9zcGFuPiR7Y2xpcGJvYXJkSWNvbn08L2J1dHRvbj4gPGJ1dHRvbiBpZD1cImlkLWxpbmtcIiBjbGFzcz1cImJ1dHRvbi1saW5rXCIgdGl0bGU9XCJDb3B5IGlkXCI+PHNwYW4+Q29weSBpZDwvc3Bhbj4ke2NsaXBib2FyZEljb259PC9idXR0b24+XG48L3A+XG5gO1xuXG5jbGFzcyBFZGl0b3JMb2NhdGlvbkluZm8gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWNjZXB0ZWQgdmFsdWVzIGZvciB0aGUga2luZCBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5hbGxvd2VkS2luZHMgPSBbJ3N0YWNrJywgJ2NhcmQnLCAnb3duZXInXTtcblxuICAgICAgICAvLyBkZWZpbmUgYW5kIGJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uU3RyaW5nRm9yID0gZ2V0TG9jYXRpb25TdHJpbmdGb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrID0gb25Mb2NhdGlvbkxpbmtDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5oYW5kbGVTdGFja0tpbmQgPSB0aGlzLmhhbmRsZVN0YWNrS2luZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNhcmRLaW5kID0gdGhpcy5oYW5kbGVDYXJkS2luZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUluZm8gPSB0aGlzLnVwZGF0ZUluZm8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRBbmNlc3Rvck9mVHlwZUZvciA9IHRoaXMuZ2V0QW5jZXN0b3JPZlR5cGVGb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzID0gdGhpcy5nZXRMb2NhdGlvblZpZXdzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MaW5rQ2xpY2sgPSB0aGlzLm9uTGlua0NsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZUVudGVyID0gdGhpcy5vbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTGVhdmUgPSB0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIC8vIEV2ZW50c1xuICAgICAgICBsZXQgb3duZXJMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnb3duZXItbGluaycpO1xuICAgICAgICBsZXQgbG9jYXRpb25MaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbG9jYXRpb24tbGluaycpO1xuICAgICAgICBsZXQgaWRMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaWQtbGluaycpO1xuICAgICAgICBvd25lckxpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTGlua0NsaWNrKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uQ2xpY2spO1xuICAgICAgICBpZExpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25DbGljayk7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuICAgICAgICBpZExpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgICAgIGlkTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGxldCBvd25lckxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdvd25lci1saW5rJyk7XG4gICAgICAgIGxldCBsb2NhdGlvbkxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1saW5rJyk7XG4gICAgICAgIGxldCBpZExpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdpZC1saW5rJyk7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkNsaWNrKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uQ2xpY2spO1xuICAgICAgICBvd25lckxpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgICAgIGlkTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuICAgICAgICBsb2NhdGlvbkxpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIGxldCBraW5kID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2tpbmQnKTtcbiAgICAgICAgaWYoIWtpbmQgfHwgIXRoaXMuYWxsb3dlZEtpbmRzLmluY2x1ZGVzKGtpbmQpKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICd3b3JsZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGVsZW1lbnQgcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLm93bmVyTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ293bmVyLWxpbmsnKTtcbiAgICAgICAgdGhpcy5vd25lckxpbmtUeXBlU3BhbiA9IHRoaXMub3duZXJMaW5rQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1saW5rJyk7XG4gICAgICAgIHRoaXMubG9jYXRpb25MaW5rU3BhbiA9IHRoaXMubG9jYXRpb25MaW5rQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5pZExpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdpZC1saW5rJyk7XG4gICAgICAgIHRoaXMuaWRMaW5rU3BhbiA9IHRoaXMuaWRMaW5rQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5uYW1lU3BhbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcigncCAucGFydC1uYW1lJyk7XG5cbiAgICAgICAgaWYoa2luZCA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RhY2tLaW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZihraW5kID09J2NhcmQnKXtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2FyZEtpbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5mbygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSW5mbygpe1xuICAgICAgICBsZXQga2luZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdraW5kJyk7XG4gICAgICAgIGxldCBhbmNlc3RvciA9IHRoaXMubW9kZWwuX293bmVyO1xuICAgICAgICBpZihraW5kID09ICdzdGFjaycgfHwga2luZCA9PSAnY2FyZCcpe1xuICAgICAgICAgICAgYW5jZXN0b3IgPSB0aGlzLmdldEFuY2VzdG9yT2ZUeXBlRm9yKHRoaXMubW9kZWwsIGtpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgY2Fubm90IGZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuXG4gICAgICAgIC8vIGtpbmQsIHRoZW4gd2UgaGlkZSB0aGlzIGZpZWxkXG4gICAgICAgIGlmKCFhbmNlc3Rvcil7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG5hbWUgc3BhblxuICAgICAgICBsZXQgYW5jZXN0b3JOYW1lID0gYW5jZXN0b3IucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIGFuY2VzdG9yLFxuICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICk7XG4gICAgICAgIGlmKCFhbmNlc3Rvck5hbWUpe1xuICAgICAgICAgICAgYW5jZXN0b3JOYW1lID0gJyh1bm5hbWVkKSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNlc3Rvck5hbWUgPSBgXCIke2FuY2VzdG9yTmFtZX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lU3Bhbi50ZXh0Q29udGVudCA9IGFuY2VzdG9yTmFtZTtcblxuICAgICAgICAvLyBVcGRhdGUga2luZCBzcGFuXG4gICAgICAgIGxldCBraW5kTGFiZWwgPSBraW5kWzBdLnRvVXBwZXJDYXNlKCkgKyBraW5kLnNsaWNlKDEpO1xuICAgICAgICB0aGlzLm93bmVyTGlua1R5cGVTcGFuLnRleHRDb250ZW50ID0ga2luZExhYmVsO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBsb2NhdGlvbiBsaW5rIHNwYW5cbiAgICAgICAgdGhpcy5sb2NhdGlvbkxpbmtTcGFuLnRleHRDb250ZW50ID0gdGhpcy5nZXRMb2NhdGlvblN0cmluZ0ZvcihhbmNlc3Rvcik7XG5cbiAgICAgICAgLy8gVXBkYXRlIGJ1dHRvbiB0aXRsZXNcbiAgICAgICAgbGV0IGVkaXRUaXRsZSA9IGBFZGl0IG93bmluZyAke2tpbmRMYWJlbH1gO1xuICAgICAgICBpZihraW5kID09ICdvd25lcicpe1xuICAgICAgICAgICAgZWRpdFRpdGxlID0gJ0VkaXQgT3duZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3duZXJMaW5rQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICd0aXRsZScsXG4gICAgICAgICAgICBlZGl0VGl0bGVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgdGhlIHJlZi1pZCBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JlZi1pZCcsIGFuY2VzdG9yLmlkKTtcbiAgICB9XG5cbiAgICBoYW5kbGVTdGFja0tpbmQoKXtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICdzdGFjaycgfHwgdGhpcy5tb2RlbC50eXBlID09ICd3b3JsZCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUluZm8oKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDYXJkS2luZCgpe1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ2NhcmQnIHx8IHRoaXMubW9kZWwudHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbmZvKCk7XG4gICAgfVxuXG4gICAgZ2V0QW5jZXN0b3JPZlR5cGVGb3IoYVBhcnQsIGFUeXBlKXtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGN1cnJlbnRPd25lciA9IGFQYXJ0Ll9vd25lcjtcbiAgICAgICAgd2hpbGUoY3VycmVudE93bmVyKXtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRPd25lci50eXBlID09IGFUeXBlKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXJyZW50T3duZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50T3duZXIgPSBjdXJyZW50T3duZXIuX293bmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgb25MaW5rQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmLWlkJyk7XG4gICAgICAgIGlmKGlkICYmIHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgLy8gUmUtcmVuZGVyIHRoZSBlZGl0b3Igb24gdGhlIFBhcnRcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZWQgYnkgdGhlIGZvdW5kIGlkXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbaWRdO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5lZGl0b3IucmVuZGVyKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlRW50ZXIoZXZlbnQpe1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MoZXZlbnQpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0KFwicmdiKDU0LCAxNzIsIDEwMClcIik7IC8vIGdyZWVuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uTW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyhldmVudCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRMb2NhdGlvblZpZXdzKGV2ZW50KXtcbiAgICAgICAgbGV0IHRhcmdldElkO1xuICAgICAgICBsZXQgc3BhbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICBpZihzcGFuLnBhcmVudEVsZW1lbnQuaWQgPT0gJ2lkLWxpbmsnKXtcbiAgICAgICAgICAgIHRhcmdldElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZi1pZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbWFudGljcyA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oXG4gICAgICAgICAgICAgICAgJ2ludGVycHJldCcsXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJTZW1hbnRpY3Mod2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbJ3dvcmxkJ10sIHdpbmRvdy5TeXN0ZW0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IG0gPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIubWF0Y2goc3Bhbi50ZXh0Q29udGVudCwgXCJPYmplY3RTcGVjaWZpZXJcIik7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobSkuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjYW5ub3QgbG9jYXRlICR7c3Bhbi50ZXh0Q29udGVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5maW5kVmlld3NCeUlkKHRhcmdldElkKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvckxvY2F0aW9uSW5mbyxcbiAgICBFZGl0b3JMb2NhdGlvbkluZm8gYXMgZGVmYXVsdFxufTtcbiIsIlxuXG4vLyBQUkVBTUJMRVxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cbiAgIFxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcmVzaXplOiBub25lO1xuICAgICAgICBmbGV4OiAwLjI1O1xuICAgIH1cbjwvc3R5bGU+XG48aDM+U2VuZCB0aGlzIDxzcGFuPjwvc3Bhbj4gYSBNZXNzYWdlOjwvaDM+XG48dGV4dGFyZWEgcGxhY2Vob2xkZXI9XCJUeXBlIHlvdXIgU2ltcGxldGFsayBtZXNzYWdlIGhlcmUuLi5cIj48L3RleHRhcmVhPlxuPGJ1dHRvbj5TZW5kPC9idXR0b24+XG5gO1xuXG5jbGFzcyBFZGl0b3JNZXNzZW5nZXIgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25NZXNzYWdlRmllbGRJbnB1dCA9IHRoaXMub25NZXNzYWdlRmllbGRJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQgPSB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQpO1xuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUZpZWxkID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uTWVzc2FnZUZpZWxkSW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5tZXNzYWdlRmllbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uTWVzc2FnZUZpZWxkSW5wdXQpO1xuICAgICAgICB0aGlzLnNlbmRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNlbmRNZXNzYWdlRnJvbVRleHQpO1xuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICBcbiAgICAgICAgbGV0IHBhcnRUeXBlTGFiZWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2gzID4gc3BhbicpO1xuICAgICAgICBwYXJ0VHlwZUxhYmVsLnRleHRDb250ZW50ID0gdGhpcy5tb2RlbC50eXBlO1xuICAgIH1cblxuICAgIG9uTWVzc2FnZUZpZWxkSW5wdXQoZXZlbnQpe1xuXG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2VGcm9tVGV4dCgpe1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMubWVzc2FnZUZpZWxkLnZhbHVlO1xuICAgICAgICBsZXQgc2NyaXB0ID0gYG9uIGRvSXRcXG5cXHQke3RleHR9XFxuZW5kIGRvSXRgO1xuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21waWxlJyxcbiAgICAgICAgICAgIGNvZGVTdHJpbmc6IHNjcmlwdCxcbiAgICAgICAgICAgIHRhcmdldElkOiB0aGlzLm1vZGVsLmlkXG4gICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnZG9JdCcsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvck1lc3NlbmdlcixcbiAgICBFZGl0b3JNZXNzZW5nZXIgYXMgZGVmYXVsdFxufTtcbiIsIi8vIFBSRUFNQkxFXG5cbmNvbnN0IGNoZWNrSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jaXJjbGUtY2hlY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwYjM0MVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjlcIiAvPlxuICA8cGF0aCBkPVwiTTkgMTJsMiAybDQgLTRcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjYW5jZWxJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNpcmNsZS14XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiNmZjI4MjVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI5XCIgLz5cbiAgPHBhdGggZD1cIk0xMCAxMGw0IDRtMCAtNGwtNCA0XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgbGkge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIHBhZGRpbmc6IDZweDtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcbiAgICAgICAgbWFyZ2luLXRvcDogNnB4O1xuICAgIH1cbiAgIFxuICAgIGxpID4gbGFiZWwge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cblxuICAgIDpob3N0IHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgOmhvc3QoLml0ZW0taGlkZGVuKSB7XG4gICAgICAgIGRpc3BsYXk6bm9uZTtcbiAgICB9XG5cbiAgICBidXR0b24ge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIG9wYWNpdHk6IDEuMDtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGxpbmVhcjtcbiAgICB9XG5cbiAgICBidXR0b246ZGlzYWJsZWQge1xuICAgICAgICBvcGFjaXR5OiAwLjA1O1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5OiAwLjFzIGxpbmVhcjtcbiAgICB9XG5cbiAgICBidXR0b246aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuXG4gICAgYnV0dG9uLmJ1dHRvbi1oaWRkZW4ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgIGxhYmVsIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICB9XG5cbiAgICBpbnB1dCB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjUpO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgIH1cbiAgICBcbiAgICBpbnB1dDpmb2N1cyB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC44KTtcbiAgICB9XG48L3N0eWxlPlxuPGxpPlxuICAgIDxsYWJlbCBmb3I9XCJwcm9wLXZhbHVlXCI+PC9sYWJlbD5cbiAgICA8aW5wdXQgaWQ9XCJwcm9wLXZhbHVlXCIgbmFtZT1cInByb3AtdmFsdWVcIi8+XG4gICAgPGJ1dHRvbiBpZD1cImFjY2VwdFwiIGRpc2FibGVkPiR7Y2hlY2tJY29ufTwvYnV0dG9uPlxuICAgIDxidXR0b24gaWQ9XCJjYW5jZWxcIiBkaXNhYmxlZD4ke2NhbmNlbEljb259PC9idXR0b24+XG48L2xpPlxuYDtcblxuY2xhc3MgRWRpdG9yUHJvcEl0ZW0gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlcmUgaXMgbm8gcHJvcGVydHlcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSW5wdXRDaGFuZ2UgPSB0aGlzLm9uSW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbklucHV0SW5wdXQgPSB0aGlzLm9uSW5wdXRJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQWNjZXB0Q2xpY2sgPSB0aGlzLm9uQWNjZXB0Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNhbmNlbENsaWNrID0gdGhpcy5vbkNhbmNlbENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25FbnRlcktleSA9IHRoaXMub25FbnRlcktleS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwTnVtZXJpY0lucHV0ID0gdGhpcy5zZXR1cE51bWVyaWNJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuYWJsZUJ1dHRvbnMgPSB0aGlzLmVuYWJsZUJ1dHRvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucyA9IHRoaXMuZGlzYWJsZUJ1dHRvbnMuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzZXRQcm9wZXJ0eShhUHJvcGVydHksIGFuT3duZXIpe1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IGFQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5vd25lciA9IGFuT3duZXI7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlbGVtZW50IGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCB0aGlzLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnb3duZXItaWQnLCB0aGlzLm93bmVyLmlkKTtcblxuICAgICAgICAvLyBBZGQgbmV3IGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMub25FbnRlcktleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5vbkVudGVyS2V5KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKXtcbiAgICAgICAgdGhpcy5sYWJlbEVsZW1lbnQgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJyk7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2FjY2VwdCcpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2NhbmNlbCcpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgaGlkZSBjbGFzc2VzXG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2J1dHRvbi1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYnV0dG9uLWhpZGRlbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBib3VuZCBldmVudHNcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXRJbnB1dCk7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25JbnB1dENoYW5nZSk7XG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkFjY2VwdENsaWNrKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2FuY2VsQ2xpY2spO1xuXG4gICAgICAgIC8vIEFkZCBuZXcgZXZlbnRzXG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0SW5wdXQpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uSW5wdXRDaGFuZ2UpO1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25BY2NlcHRDbGljayk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNhbmNlbENsaWNrKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubGFiZWxFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGhpcy5wcm9wZXJ0eS5uYW1lfTpgO1xuICAgICAgICBsZXQgY3VycmVudFZhbCA9IHRoaXMucHJvcGVydHkuZ2V0VmFsdWUodGhpcy5vd25lcik7XG4gICAgICAgIGlmKGN1cnJlbnRWYWwgPT0gbnVsbCB8fCBjdXJyZW50VmFsID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAvLyBEbyBzb21ldGhpbmcgZGlmZmVyZW50IGhlcmVcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihjdXJyZW50VmFsKSA9PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICB0aGlzLnNldHVwTnVtZXJpY0lucHV0KCk7XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YoY3VycmVudFZhbCkgPT0gJ2Jvb2xlYW4nKXtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuY2hlY2tlZCA9IGN1cnJlbnRWYWw7XG4gICAgICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidXR0b24taGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidXR0b24taGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIGN1cnJlbnRWYWwpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IGN1cnJlbnRWYWw7XG4gICAgfVxuXG4gICAgc2V0dXBOdW1lcmljSW5wdXQoKXtcbiAgICAgICAgaWYodGhpcy5wcm9wZXJ0eS5uYW1lLmVuZHNXaXRoKCctdHJhbnNwYXJlbmN5Jykpe1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3JhbmdlJyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0ZXAnLCAnMC4wNScpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdtaW4nLCAnMC4wJyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21heCcsICcxLjAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdudW1iZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSW5wdXRDaGFuZ2UoZXZlbnQpe1xuICAgICAgICBpZihldmVudC50YXJnZXQudHlwZSA9PSBcImNoZWNrYm94XCIpe1xuICAgICAgICAgICAgdGhpcy5vd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25JbnB1dElucHV0KGV2ZW50KXtcbiAgICAgICAgbGV0IGlucHV0VHlwZSA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgaWYoaW5wdXRUeXBlID09ICdyYW5nZScpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25BY2NlcHRDbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC52YWx1ZSAhPT0gdGhpcy5wcm9wZXJ0eS5nZXRWYWx1ZSh0aGlzLm93bmVyKSl7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRW50ZXJLZXkoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5rZXkgPT0gJ0VudGVyJyl7XG4gICAgICAgICAgICB0aGlzLm9uQWNjZXB0Q2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuYWJsZUJ1dHRvbnMoKXtcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgZGlzYWJsZUJ1dHRvbnMoKXtcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgb25BY2NlcHRDbGljayhldmVudCl7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgICAgICBpZih0aGlzLmlucHV0RWxlbWVudC50eXBlID09ICdudW1iZXInKXtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBpZihpc05hTih2YWx1ZSkpe1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IHBhcnNlIHRoZSB2YWx1ZSBqdXN0IGxldCBpdCBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQgbWlnaHQgYmUgYSBwcm9wIHN0eWxlIGtleXdvcmQgc3VjaCBhcyBcImZpbGxcIlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIG1pZ2h0IHdhbnQgdG8gbGltaXQgdGhpcyB0byBhIHNldCBvZiBwcm9wIGtleXdvcmRzXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuaW5wdXRFbGVtZW50LnR5cGUgPT0gJ3JhbmdlJyl7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5pbnB1dEVsZW1lbnQudHlwZSA9PSAnY2hlY2tib3gnKXtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnB1dEVsZW1lbnQuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm93bmVyLFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucygpO1xuICAgIH1cblxuICAgIG9uQ2FuY2VsQ2xpY2soZXZlbnQpe1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IHRoaXMub3duZXIucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMub3duZXIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5Lm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucygpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yUHJvcEl0ZW0sXG4gICAgRWRpdG9yUHJvcEl0ZW0gYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBFZGl0b3JQcm9wSXRlbSBmcm9tICcuL0VkaXRvclByb3BJdGVtLmpzJztcblxuLy8gUFJFQU1CTEVcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1wcm9wLWl0ZW0nLCBFZGl0b3JQcm9wSXRlbSk7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgICAgICBmb250LXNpemU6IDAuOHJlbTtcbiAgICB9XG5cbiAgICAjcHJvcHMtbGlzdCB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB9XG4gICAgI2ZpbHRlci1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuICAgICNmaWx0ZXItYXJlYSA+IGlucHV0IHtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOiAxLjByZW07XG4gICAgICAgIHBhZGRpbmctbGVmdDogNnB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiA2cHg7XG4gICAgICAgIHBhZGRpbmctdG9wOiAzcHg7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAzcHg7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC44KTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwiZmlsdGVyLWFyZWFcIj5cbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImZpbHRlci1pbnB1dFwiIG5hbWU9XCJmaWx0ZXItaW5wdXRcIiBwbGFjZWhvbGRlcj1cIkZpbHRlci4uLlwiLz5cbiAgICA8YnV0dG9uIGlkPVwiY2xlYXJcIj5DbGVhcjwvYnV0dG9uPlxuPC9kaXY+XG48dWwgaWQ9XCJwcm9wcy1saXN0XCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC91bD5cbmA7XG5cbmNvbnN0IHNwZWNpYWxQcm9wcyA9IFtcbiAgICAnY3NzU3R5bGUnLFxuICAgICdjc3NUZXh0U3R5bGUnLFxuICAgICdpZCcsXG4gICAgJ25hbWUnLFxuICAgICd0YXJnZXQnLFxuICAgICdldmVudHMnLFxuICAgICdjdXJyZW50JyxcbiAgICAnc2NyaXB0JyxcbiAgICAnY3VzdG9tLXByb3BlcnRpZXMnXG5dO1xuXG5jbGFzcyBFZGl0b3JQcm9wTGlzdCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbklucHV0ID0gdGhpcy5vbklucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25GaWx0ZXJDbGVhckNsaWNrID0gdGhpcy5vbkZpbHRlckNsZWFyQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5wdXRFbGVtZW50ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLWlucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnY2xlYXInKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcblxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgbWFpbiBET00gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBsZXQgaW5wdXRFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpO1xuICAgICAgICBpbnB1dEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0KTtcbiAgICAgICAgaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25JbnB1dCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc29ydGVkIGNvcHkgb2YgdGhlIHByb3BlcnR5IG9iamVjdHNcbiAgICAgICAgdGhpcy5wcm9wTGlzdCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuYWxsLnNsaWNlKCkuZmlsdGVyKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc3BlY2lhbFByb3BzLmluY2x1ZGVzKHByb3AubmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9wTGlzdFxuICAgICAgICAgICAgLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdC5uYW1lLmxvY2FsZUNvbXBhcmUoc2Vjb25kLm5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIGxpc3QgaXRlbSBlbGVtZW50cyBhbmQgaW5zZXJ0IHRoZW1cbiAgICAgICAgdGhpcy5wcm9wTGlzdC5mb3JFYWNoKHByb3BPYmplY3QgPT4ge1xuICAgICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLXByb3AtaXRlbScpO1xuICAgICAgICAgICAgZWwuc2V0UHJvcGVydHkocHJvcE9iamVjdCwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBwcm9wT2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZpbHRlckJ5KHRleHQpe1xuICAgICAgICAvLyBGaW5kIGFsbCBvZiB0aGUgcHJvcCBpdGVtIGVsZW1lbnRzIHdob3NlXG4gICAgICAgIC8vIHByb3BlcnR5IG5hbWUgZG9lcyAqbm90KiBpbmNsdWRlIHRoZSBzdWJzdHJpbmcsXG4gICAgICAgIC8vIGFuZCBzZXQgdGhvc2UgdG8gbm90IGRpc3BsYXlcbiAgICAgICAgbGV0IGFsbEVsZW1lbnRzID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2VkaXRvci1wcm9wLWl0ZW0nKSk7XG4gICAgICAgIGFsbEVsZW1lbnRzLmZvckVhY2gocHJvcEVsID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJvcEVsLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRleHQpKXtcbiAgICAgICAgICAgICAgICBwcm9wRWwuY2xhc3NMaXN0LnJlbW92ZSgnaXRlbS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcEVsLmNsYXNzTGlzdC5hZGQoJ2l0ZW0taGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uSW5wdXQoZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlckJ5KGV2ZW50LnRhcmdldC52YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBvbkZpbHRlckNsZWFyQ2xpY2soZXZlbnQpe1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0RWxlbWVudC52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZmlsdGVyQnkoXCJcIik7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JQcm9wTGlzdCxcbiAgICBFZGl0b3JQcm9wTGlzdCBhcyBkZWZhdWx0XG59O1xuIiwiLy8gUFJFQU1CTEVcbmltcG9ydCBFZGl0b3JMb2NhdGlvbkluZm8gZnJvbSAnLi9FZGl0b3JMb2NhdGlvbkluZm8uanMnO1xuaW1wb3J0IHBhcnRJY29ucyBmcm9tICcuLi8uLi91dGlscy9pY29ucy5qcyc7XG5pbXBvcnQge29uTG9jYXRpb25MaW5rQ2xpY2ssIGdldExvY2F0aW9uU3RyaW5nRm9yfSBmcm9tICcuL3V0aWxzL3N1YnBhcnRzLmpzJztcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLWxvY2F0aW9uLWluZm8nLCBFZGl0b3JMb2NhdGlvbkluZm8pO1xuXG5jb25zdCBjbGlwYm9hcmRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNsaXBib2FyZFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNOSA1aC0yYTIgMiAwIDAgMCAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTBhMiAyIDAgMCAwIDIgLTJ2LTEyYTIgMiAwIDAgMCAtMiAtMmgtMlwiIC8+XG4gIDxyZWN0IHg9XCI5XCIgeT1cIjNcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCI0XCIgcng9XCIyXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cblxuICAgIDpob3N0KCkgPiBsaSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgICB9XG5cbiAgICAuaWQtbGluayxcbiAgICAubG9jYXRpb24tbGluayB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGVhc2Utb3V0O1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbm1lbnQ6IGNlbnRlcjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIHBhZGRpbmc6IDBweDtcbiAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgfVxuXG4gICAgLmlkLWxpbms6aG92ZXIsXG4gICAgLmxvY2F0aW9uLWxpbms6aG92ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuNyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIC5pZC1saW5rID4gc3ZnLFxuICAgIC5sb2NhdGlvbi1saW5rID4gc3ZnIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgb3BhY2l0eTogMC43O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMHB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBlYXNlLW91dDtcbiAgICB9XG5cbiAgICAuaWQtbGluazpob3ZlciA+IHN2ZyxcbiAgICAubG9jYXRpb24tbGluazpob3ZlciA+IHN2ZyB7XG4gICAgICAgIG9wYWNpdHk6IDEuMDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01cHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIHNlY3Rpb24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBtYXJnaW46IDZweDtcbiAgICB9XG5cbiAgICAjYnV0dG9uLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsnXG4gICAgfVxuXG4gICAgI3N1YnBhcnRzLWxpc3Qtd3JhcHBlciB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuaGlkZGVuIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICAjc3VicGFydHMtYXJlYSB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBtYXJnaW4tbGVmdDogMzJweDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB9XG48L3N0eWxlPlxuPHNlY3Rpb24gaWQ9XCJidXR0b24tYXJlYVwiPlxuICAgIDxzbG90IG5hbWU9XCJidXR0b25cIj48L3Nsb3Q+XG48L3NlY3Rpb24+XG48c2VjdGlvbiBpZD1cImxvY2F0aW9uLWFyZWFcIj5cbiAgICA8aDM+UGFydCBMb2NhdGlvbiBhbmQgT3duZXJzPC9oMz5cbiAgICA8cCBjbGFzcz1cInBhcnQtaW5mb1wiPlxuICAgICAgICBJIGFtIGxvY2F0ZWQgYXQgPGJ1dHRvbiBjbGFzcz1cImxvY2F0aW9uLWxpbmtcIj48c3Bhbj48L3NwYW4+JHtjbGlwYm9hcmRJY29ufTwvYnV0dG9uPlxuICAgICAgICBhbmQgbXkgaWQgaXMgPGJ1dHRvbiBjbGFzcz1cImlkLWxpbmtcIj48c3Bhbj48L3NwYW4+JHtjbGlwYm9hcmRJY29ufTwvYnV0dG9uPlxuICAgIDwvcD5cbiAgICA8c2xvdCBuYW1lPVwiYW5jZXN0b3ItaW5mb1wiPjwvc2xvdD5cbjwvc2VjdGlvbj5cbjxzZWN0aW9uIGlkPVwic3VicGFydHMtbGlzdC13cmFwcGVyXCI+XG4gICAgPGgzPlN1YnBhcnRzPC9oMz5cbiAgICA8b2wgaWQ9XCJzdWJwYXJ0cy1hcmVhXCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L29sPlxuPC9zZWN0aW9uPlxuYDtcblxuY2xhc3MgRWRpdG9yU3VicGFydHNQYW5lIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGRlZmluZSBhbmQgYmluZCBtZXRob2RzXG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25TdHJpbmdGb3IgPSBnZXRMb2NhdGlvblN0cmluZ0Zvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2sgPSBvbkxvY2F0aW9uTGlua0NsaWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQWRkU3VicGFydCA9IHRoaXMub25BZGRTdWJwYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TdWJwYXJ0SXRlbUNsaWNrID0gdGhpcy5vblN1YnBhcnRJdGVtQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN1YnBhcnRJdGVtTW91c2VFbnRlciA9IHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN1YnBhcnRJdGVtTW91c2VMZWF2ZSA9IHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVBZGRQYXJ0QnV0dG9uID0gdGhpcy5jcmVhdGVBZGRQYXJ0QnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlU3VicGFydENvbXBvbmVudCA9IHRoaXMuY3JlYXRlU3VicGFydENvbXBvbmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MgPSB0aGlzLmdldExvY2F0aW9uVmlld3MuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1hcmVhJyk7XG4gICAgICAgICAgICB0aGlzLm15TG9jYXRpb25BcmVhID0gdGhpcy5oZWFkZXJFbC5xdWVyeVNlbGVjdG9yKCdwJyk7XG4gICAgICAgICAgICB0aGlzLm15TG9jYXRpb25CdXR0b24gPSB0aGlzLm15TG9jYXRpb25BcmVhLnF1ZXJ5U2VsZWN0b3IoJy5sb2NhdGlvbi1saW5rJyk7XG4gICAgICAgICAgICB0aGlzLm15SWRCdXR0b24gPSB0aGlzLm15TG9jYXRpb25BcmVhLnF1ZXJ5U2VsZWN0b3IoJy5pZC1saW5rJyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciB0byBidXR0b25zXG4gICAgICAgICAgICB0aGlzLm15TG9jYXRpb25CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5teUlkQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMubXlMb2NhdGlvbkJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayk7XG4gICAgICAgIHRoaXMubXlJZEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIHRoaXMuaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbi1hcmVhJyk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IERPTSBjaGlsZHJlblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cblxuICAgICAgICAvLyBDcmVhdGUgbG9jYXRpb24gbGluayBlbGVtZW50c1xuICAgICAgICAvLyBhbmQgYWxzbyB0aGUgc2VsZi1sb2NhdGlvbiBlbGVtZW50XG4gICAgICAgIGxldCBteUxvY2F0aW9uVGV4dCA9IHRoaXMuZ2V0TG9jYXRpb25TdHJpbmdGb3IodGhpcy5tb2RlbCk7XG4gICAgICAgIHRoaXMubXlMb2NhdGlvbkJ1dHRvbi5xdWVyeVNlbGVjdG9yKCdzcGFuJykudGV4dENvbnRlbnQgPSBteUxvY2F0aW9uVGV4dDtcbiAgICAgICAgdGhpcy5teUlkQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS50ZXh0Q29udGVudCA9IHRoaXMubW9kZWwuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICd3b3JsZCcpe1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgaW5mbyBlbGVtZW50c1xuICAgICAgICAgICAgWydzdGFjaycsICdjYXJkJywgJ293bmVyJ10uZm9yRWFjaChraW5kID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLWxvY2F0aW9uLWluZm8nKTtcbiAgICAgICAgICAgICAgICBpbmZvRWwuc2V0QXR0cmlidXRlKCdzbG90JywgJ2FuY2VzdG9yLWluZm8nKTtcbiAgICAgICAgICAgICAgICBpbmZvRWwuc2V0QXR0cmlidXRlKCdraW5kJywga2luZCk7XG4gICAgICAgICAgICAgICAgaW5mb0VsLnJlbmRlcih0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGluZm9FbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgXCJhZGQgc3VicGFydFwiIGJ1dHRvbnMgZm9yIHBhcnRzIHRoYXQgYXJlIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAgICAvLyBjdXJyZW50IE1vZGVsIHBhcnQuXG4gICAgICAgIHRoaXMubW9kZWwuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMuZm9yRWFjaChwYXJ0VHlwZSA9PiB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuY3JlYXRlQWRkUGFydEJ1dHRvbihwYXJ0VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbGFiZWxIZWFkZXIgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNzdWJwYXJ0cy1saXN0LXdyYXBwZXIgPiBoMycpO1xuICAgICAgICBpZih0aGlzLm1vZGVsLnN1YnBhcnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBsYWJlbEhlYWRlci50ZXh0Q29udGVudCA9IFwiQ3VycmVudCBTdWJwYXJ0c1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxIZWFkZXIudGV4dENvbnRlbnQgPSBcIlRoZXJlIGFyZSBubyBzdWJwYXJ0c1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RlbC5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZVN1YnBhcnRDb21wb25lbnQoc3VicGFydCk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjcmVhdGVTdWJwYXJ0Q29tcG9uZW50KGFQYXJ0KXtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ3N1YnBhcnQtaXRlbScpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgncmVmLWlkJywgYVBhcnQuaWQpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblN1YnBhcnRJdGVtQ2xpY2spO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uU3VicGFydEl0ZW1Nb3VzZUVudGVyKTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vblN1YnBhcnRJdGVtTW91c2VMZWF2ZSk7XG5cbiAgICAgICAgLy8gQWRkIGljb24gYXJlYSBhbiBTVkcgZm9yIFBhcnRcbiAgICAgICAgbGV0IGljb25BcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGljb25BcmVhLmNsYXNzTGlzdC5hZGQoJ2ljb24tZGlzcGxheS1hcmVhJyk7XG4gICAgICAgIGxldCBpY29uSW1hZ2U7XG4gICAgICAgIGlmKE9iamVjdC5rZXlzKHBhcnRJY29ucykuaW5jbHVkZXMoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgaWNvbkltYWdlID0gcGFydEljb25zW2FQYXJ0LnR5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWNvbkltYWdlID0gcGFydEljb25zLmdlbmVyaWM7XG4gICAgICAgIH1cbiAgICAgICAgaWNvbkFyZWEuaW5uZXJIVE1MID0gaWNvbkltYWdlO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZChpY29uQXJlYSk7XG5cbiAgICAgICAgLy8gQWRkIGxhYmVsLCBuYW1lLCBhbmQgaWQgaW5mb1xuICAgICAgICBsZXQgbGFiZWxBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICAgICAgbGFiZWxBcmVhLnRleHRDb250ZW50ID0gYGEgJHthUGFydC50eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHthUGFydC50eXBlLnNsaWNlKDEpfWA7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKGxhYmVsQXJlYSk7XG4gICAgICAgIGxldCBuYW1lID0gYVBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIGFQYXJ0LFxuICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICk7XG4gICAgICAgIGlmKG5hbWUgJiYgbmFtZSAhPSBcIlwiKXtcbiAgICAgICAgICAgIGxldCBuYW1lQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIG5hbWVBcmVhLmNsYXNzTGlzdC5hZGQoJ25hbWUtc3BhbicpO1xuICAgICAgICAgICAgbmFtZUFyZWEudGV4dENvbnRlbnQgPSBgXCIke25hbWV9XCJgO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmQobmFtZUFyZWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlkQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgaWRBcmVhLmNsYXNzTGlzdC5hZGQoJ2lkLXNwYW4nKTtcbiAgICAgICAgaWRBcmVhLnRleHRDb250ZW50ID0gYCgke2FQYXJ0LmlkfSlgO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZChpZEFyZWEpO1xuXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIGNyZWF0ZUFkZFBhcnRCdXR0b24oYVBhcnROYW1lKXtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBsZXQgaWNvbiA9IHBhcnRJY29uc1thUGFydE5hbWVdO1xuICAgICAgICBpZighaWNvbil7XG4gICAgICAgICAgICBpY29uID0gcGFydEljb25zLmdlbmVyaWM7XG4gICAgICAgIH1cbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnZGF0YS10eXBlJywgYVBhcnROYW1lKTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBgQWRkIGEgJHthUGFydE5hbWV9IHRvIHRoaXMgJHt0aGlzLm1vZGVsLnR5cGV9YCk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdhZGQtcGFydC1idXR0b24nKTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkFkZFN1YnBhcnQpO1xuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbjtcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG5cbiAgICBvblN1YnBhcnRJdGVtQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgaWQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgncmVmLWlkJyk7XG4gICAgICAgIGxldCB0YXJnZXRQYXJ0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbaWRdO1xuICAgICAgICBpZih0YXJnZXRQYXJ0KXtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZWRpdG9yLnJlbmRlcih0YXJnZXRQYXJ0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU3VicGFydEl0ZW1Nb3VzZUVudGVyKGV2ZW50KXtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzKGV2ZW50KS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LmhpZ2hsaWdodChcInJnYig1NCwgMTcyLCAxMDApXCIpOyAvLyBncmVlblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvblN1YnBhcnRJdGVtTW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyhldmVudCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkFkZFN1YnBhcnQoZXZlbnQpe1xuICAgICAgICBsZXQgdHlwZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKTtcbiAgICAgICAgaWYodHlwZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICduZXdNb2RlbCcsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5tb2RlbCk7XG4gICAgfVxuXG4gICAgZ2V0TG9jYXRpb25WaWV3cyhldmVudCl7XG4gICAgICAgIGxldCB0YXJnZXRJZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdyZWYtaWQnKTtcbiAgICAgICAgbGV0IHNwYW4gPSBldmVudC5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0YXJnZXRJZCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JTdWJwYXJ0c1BhbmUsXG4gICAgRWRpdG9yU3VicGFydHNQYW5lIGFzIGRlZmF1bHRcbn07XG4iLCIvLyBQUkVBTUJMRVxuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBwYWRkaW5nOiA2cHg7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC43KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgbGluZWFyLCBvcGFjaXR5IDAuMnMgbGluZWFyO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG5cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSl7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCByZ2JhKDIwMCwgMCwgMCwgMC45KTtcbiAgICAgICAgb3BhY2l0eTogMS4wO1xuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMC4ycyBsaW5lYXIsIG9wYWNpdHkgMC4ycyBsaW5lYXI7XG4gICAgfVxuXG4gICAgOmhvc3QoOmhvdmVyKXtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbjwvc3R5bGU+XG48c3BhbiBpZD1cImxhYmVsXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC9zcGFuPlxuYDtcblxuY2xhc3MgRWRpdG9yVGFiIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRhYiBpcyBjdXJyZW50bHkgYWN0aXZhdGVkLCBlbWl0XG4gICAgICAgICAgICAvLyB0aGUgdGFiLWFjdGl2YWVkIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKSA9PSBcInRydWVcIil7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwidGFiLWFjdGl2YXRlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGxldCBpc0FjdGl2ZSA9ICh0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlJykgPT0gXCJ0cnVlXCIpO1xuICAgICAgICBpZighaXNBY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJ0YWItYWN0aXZhdGVkXCIsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvclRhYixcbiAgICBFZGl0b3JUYWIgYXMgZGVmYXVsdFxufTtcbiIsIiBjb25zdCBnZXRMb2NhdGlvblN0cmluZ0ZvciA9IChhUGFydCkgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXJ0ID0gYVBhcnQ7XG4gICAgICAgIGxldCBjdXJyZW50T3duZXIgPSBhUGFydC5fb3duZXI7XG4gICAgICAgIHdoaWxlKGN1cnJlbnRPd25lcil7XG4gICAgICAgICAgICBsZXQgaW5kZXhJblBhcmVudCA9IGN1cnJlbnRPd25lci5zdWJwYXJ0cy5maWx0ZXIoKHN1YnBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09IGN1cnJlbnRQYXJ0LnR5cGU7XG4gICAgICAgICAgICB9KS5pbmRleE9mKGN1cnJlbnRQYXJ0KSArIDE7XG4gICAgICAgICAgICByZXN1bHQgKz0gYCR7Y3VycmVudFBhcnQudHlwZX0gJHtpbmRleEluUGFyZW50fSBvZiBgO1xuICAgICAgICAgICAgY3VycmVudFBhcnQgPSBjdXJyZW50UGFydC5fb3duZXI7XG4gICAgICAgICAgICBjdXJyZW50T3duZXIgPSBjdXJyZW50T3duZXIuX293bmVyO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAndGhpcyB3b3JsZCc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuY29uc3Qgb25Mb2NhdGlvbkxpbmtDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgdGV4dCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3Rvcignc3BhbicpLnRleHRDb250ZW50O1xuICAgICAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGlucHV0LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChpbnB1dCk7XG4gICAgICAgIGxldCBjdXJyZW50Rm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHRleHQ7XG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0LnZhbHVlKTtcbiAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgICAgIGlucHV0LnJlbW92ZSgpO1xuICAgICAgICBjdXJyZW50Rm9jdXMuZm9jdXMoKTtcbn1cblxuZXhwb3J0IHtcbiAgICBnZXRMb2NhdGlvblN0cmluZ0ZvcixcbiAgICBvbkxvY2F0aW9uTGlua0NsaWNrXG59O1xuIiwiLyoqXG4gKiBOYXZpZ2F0b3IgQ2FyZCBSb3dcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgdmlldyBvbiBhIGdpdmVuIFN0YWNrIHRoYXQgc2hvd3MgZWFjaFxuICogc3VicGFydCBjYXJkIGl0ZW0gYXMgYSB3cmFwcGVkIGxlbnMgdmlldyBhbG9uZ1xuICogYSByb3cuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgfVxuPC9zdHlsZT5cbjxzbG90IG5hbWU9XCJjYXJkc1wiPjwvc2xvdD5cbmA7XG5cbmNsYXNzIENhcmRSb3cgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCB1cCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuaW5pdFZpZXcgPSB0aGlzLmluaXRWaWV3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkV3JhcHBlZENhcmQgPSB0aGlzLmFkZFdyYXBwZWRDYXJkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSA9IHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRBZGRlZCA9IHRoaXMuaGFuZGxlUGFydEFkZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQgPSB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2hvd0luaXRpYWxseSA9IHRoaXMuc2hvd0luaXRpYWxseS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV3JhcHBlckNsaWNrID0gdGhpcy5vbldyYXBwZXJDbGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIGNvbnRleHQgbWVudSB0byBvcGVuIGluIHRoZSBuYXYgc2luY2VcbiAgICAgICAgLy8gaXQgZG9lbnMndCBtYWtlIHNlbnNlIGF0bSBhbmQgd2lsbCBlcnJvclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NhcmQtaWQnLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2N1cnJlbnQnLCB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIFN0YWNrIE1vZGVsJ3MgbWFpbiB2aWV3IGVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGFkZCB0aGUgc3Qtdmlldy1hZGRlZC9yZW1vdmVkIEN1c3RvbUV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAvLyBoZXJlIHNvIHdlIGNhbiByZWFjdCBvbmx5IHRvIGRpcmVjdCBzdGFjayBhZGRpdGlvbnNcbiAgICAgICAgLy8gdG8gdGhlIFN0YWNrIChhbmQgbm90LCBzYXksIHRvIFdpbmRvd3Mgb3Igb3RoZXIgbmVzdGVkIGtpbmRzKVxuICAgICAgICBsZXQgc3RhY2tWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHN0YWNrVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICBzdGFja1ZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFVuc2V0KHJlbW92ZWRNb2RlbCl7XG4gICAgICAgIGxldCBzdGFja1ZpZXcgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3QnlJZChyZW1vdmVkTW9kZWwuaWQpO1xuICAgICAgICBzdGFja1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1hZGRlZCcsIHRoaXMuaGFuZGxlUGFydEFkZGVkKTtcbiAgICAgICAgc3RhY2tWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctcmVtb3ZlZCcsIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQpO1xuICAgIH1cblxuICAgIGhhbmRsZUN1cnJlbnRDaGFuZ2UoKXtcbiAgICAgICAgaWYoIXRoaXMubW9kZWwuY3VycmVudENhcmQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwcGVycyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd3cmFwcGVkLXZpZXcnKSk7XG4gICAgICAgIHdyYXBwZXJzLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlZElkID0gd3JhcHBlci5nZXRBdHRyaWJ1dGUoJ3dyYXBwZWQtaWQnKTtcbiAgICAgICAgICAgIGlmKHdyYXBwZWRJZCA9PSB0aGlzLm1vZGVsLmN1cnJlbnRDYXJkLmlkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydEFkZGVkKGV2ZW50KXtcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVyIGlzIGZvciB0aGUgc3Qtdmlldy1hZGRlZFxuICAgICAgICAvLyBDdXN0b21FdmVudCB0aGF0IGlzIHRyaWdnZXJlZCBieSBTeXN0ZW0gd2hlblxuICAgICAgICAvLyBuZXdNb2RlbCgpIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnY2FyZCcpe1xuICAgICAgICAgICAgbGV0IGNhcmRQYXJ0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbZXZlbnQuZGV0YWlsLnBhcnRJZF07XG4gICAgICAgICAgICB0aGlzLmFkZFdyYXBwZWRDYXJkKGNhcmRQYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0luaXRpYWxseSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydFJlbW92ZWQoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ2NhcmQnKXtcbiAgICAgICAgICAgIGxldCB3cmFwcGVkVmlldyA9IHRoaXMucXVlcnlTZWxlY3Rvcihgd3JhcHBlZC12aWV3W3dyYXBwZWQtaWQ9XCIke2V2ZW50LmRldGFpbC5wYXJ0SWR9XCJdYCk7XG4gICAgICAgICAgICBpZih3cmFwcGVkVmlldyl7XG4gICAgICAgICAgICAgICAgd3JhcHBlZFZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBudW1iZXIgZGlzcGxheSBvZiBhbGwgd3JhcHBlZCB2aWV3cyBpbiB0aGUgcm93XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChgd3JhcHBlZC12aWV3YCkpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uV3JhcHBlckNsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IHdyYXBwZXJJc0N1cnJlbnQgPSBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjdXJyZW50Jyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwgJiYgIXdyYXBwZXJJc0N1cnJlbnQpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5nb1RvQ2FyZEJ5SWQoZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnd3JhcHBlZC1pZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRWaWV3KCl7XG4gICAgICAgIC8vIEZpcnN0LCB3ZSBjbGVhciBvdXQgYW55IGV4aXN0aW5nIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAvLyBXZSBpdGVyYXRlIG92ZXIgZWFjaCBjYXJkIG9mIHRoZSBzdGFjayBhbmQ6XG4gICAgICAgIC8vICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIGNhcmQgdmlldyBlbGVtZW50O1xuICAgICAgICAvLyAqIEF0dGFjaCB0aGUgY29ycmVjdCBtb2RlbDtcbiAgICAgICAgLy8gKiBTZXQgaXQgdG8gYmUgYSBsZW5zZWQgdmlldztcbiAgICAgICAgLy8gKiBEbyB0aGUgc2FtZSBmb3IgYWxsIGNoaWxkcmVuLCByZWN1cnNpdmVseVxuICAgICAgICB0aGlzLm1vZGVsLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KS5mb3JFYWNoKGNhcmRQYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlZENhcmQoY2FyZFBhcnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgc2V0dGluZyB0aGUgY3VycmVudFxuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzaG93SW5pdGlhbGx5KCl7XG4gICAgICAgIC8vIE5vdGhpbmcgZm9yIG5vd1xuICAgIH1cblxuICAgIGFkZFdyYXBwZWRDYXJkKGFDYXJkKXtcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBsZW5zZWQgQ2FyZFZpZXcgaW50byB0aGUgd3JhcHBlclxuICAgICAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3dyYXBwZWQtdmlldycpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdjYXJkcycpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbldyYXBwZXJDbGljayk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIHdyYXBwZXIuc2V0TW9kZWwoYUNhcmQpO1xuICAgIH1cblxuICAgIHN1YnBhcnRPcmRlckNoYW5nZWQoaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpe1xuICAgICAgICBsZXQgc3VicGFydE5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgaWYoIXN1YnBhcnROb2RlKXtcbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBtb2RlbCBzdWJwYXJ0IHdoaWNoIGlzIG5vdCBhIGNhcmQgYW5kIGhlbmNlIG5vdFxuICAgICAgICAgICAgLy8gZGlzcGxheWVkIGluIHRoZSBDYXJkUm93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYobmV3SW5kZXggPT0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdWJwYXJ0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHdoZXRoZXIgdGhlIGluZGV4IG9mIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGJlZm9yZSBvciBhZnRlciB0aGUgbmV3SW5kZXhcbiAgICAgICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IG5ld0luZGV4KXtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gdGhpcy5jaGlsZE5vZGVzW25ld0luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHN1YnBhcnROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIGRpc3BsYXkgb2YgYWxsIHdyYXBwZWQgdmlld3MgaW4gdGhlIHJvd1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChgd3JhcHBlZC12aWV3YCkpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5leHBvcnQge1xuICAgIENhcmRSb3csXG4gICAgQ2FyZFJvdyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTaW1wbGVUYWxrIE5hdmlnYXRvciBXZWJjb21wb25lbnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgY29tcG9uZW50IHRoYXQgYWxsb3dzXG4gKiBhdXRob3JzIHRvIG5hdmlnYXRlIHRoZSBXb3JsZFN0YWNrIGFuZCBpbmRpdmlkdWFsXG4gKiBTdGFja3MgdGhlcmVpbiB1c2luZyBhIGNvbnZlbmllbnQgcG9wLW91dCB0cmF5IGZyb21cbiAqIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbi5cbiAqKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5pbXBvcnQgV3JhcHBlZFZpZXcgZnJvbSAnLi9XcmFwcGVkVmlldy5qcyc7XG5pbXBvcnQgU3RhY2tSb3cgZnJvbSAnLi9TdGFja1Jvdy5qcyc7XG5pbXBvcnQgQ2FyZFJvdyBmcm9tICcuL0NhcmRSb3cuanMnO1xuXG4vLyBBZGQgYW55IG5lZWRlZCBjdXN0b21FbGVtZW50c1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbmF2LXN0YWNrLXJvdycsIFN0YWNrUm93KTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ25hdi1jYXJkLXJvdycsIENhcmRSb3cpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnd3JhcHBlZC12aWV3JywgV3JhcHBlZFZpZXcpO1xuXG5jb25zdCBzdGFja0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc3RhY2tcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxwb2x5bGluZSBwb2ludHM9XCIxMiA0IDQgOCAxMiAxMiAyMCA4IDEyIDRcIj48L3BvbHlsaW5lPlxuICAgPHBvbHlsaW5lIHBvaW50cz1cIjQgMTIgMTIgMTYgMjAgMTJcIj48L3BvbHlsaW5lPlxuICAgPHBvbHlsaW5lIHBvaW50cz1cIjQgMTYgMTIgMjAgMjAgMTZcIj48L3BvbHlsaW5lPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjYXJkSWNvbiA9IGBcbjxzdmdcbiAgIHhtbG5zOmRjPVwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIlxuICAgeG1sbnM6Y2M9XCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcIlxuICAgeG1sbnM6cmRmPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1wiXG4gICB4bWxuczpzdmc9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zdGFja1wiXG4gICB3aWR0aD1cIjUwXCJcbiAgIGhlaWdodD1cIjIwLjgzMzMwOVwiXG4gICB2aWV3Qm94PVwiMCAwIDI0IDkuOTk5OTg4NFwiXG4gICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICBmaWxsPVwibm9uZVwiXG4gICBzdHJva2UtbGluZWNhcD1cInJvdW5kXCJcbiAgIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCJcbiAgIHZlcnNpb249XCIxLjFcIlxuICAgaWQ9XCJzdmc4OTNcIj5cbiAgPG1ldGFkYXRhXG4gICAgIGlkPVwibWV0YWRhdGE4OTlcIj5cbiAgICA8cmRmOlJERj5cbiAgICAgIDxjYzpXb3JrXG4gICAgICAgICByZGY6YWJvdXQ9XCJcIj5cbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XG4gICAgICAgIDxkYzp0eXBlXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXCIgLz5cbiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+XG4gICAgICA8L2NjOldvcms+XG4gICAgPC9yZGY6UkRGPlxuICA8L21ldGFkYXRhPlxuICA8ZGVmc1xuICAgICBpZD1cImRlZnM4OTdcIiAvPlxuICA8cGF0aFxuICAgICBzdHJva2U9XCJub25lXCJcbiAgICAgZD1cIk0gLTIuNzY2OTE1MSwtMS4yNTY0OTQ4IEggMjEuMjMzMDg1IFYgMjIuNzQzNTA1IEggLTIuNzY2OTE1MSBaXCJcbiAgICAgZmlsbD1cIm5vbmVcIlxuICAgICBpZD1cInBhdGg4ODVcIiAvPlxuICA8cG9seWxpbmVcbiAgICAgcG9pbnRzPVwiMTIgNCA0IDggMTIgMTIgMjAgOCAxMiA0XCJcbiAgICAgaWQ9XCJwb2x5bGluZTg4N1wiXG4gICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLC0zKVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBtaW4taGVpZ2h0OiAyNzFweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig0cHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dDtcbiAgICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMCUpO1xuICAgICAgICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSg1MCwgNTAsIDUwLCAwLjQpO1xuICAgICAgICBvdmVyZmxvdy15OiBoaWRkZW47XG4gICAgICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgICAgIHotaW5kZXg6IDEwMDA7XG4gICAgfVxuXG4gICAgLm5hdi1kaXNwbGF5LXJvdyB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgIH1cbiAgICAubmF2LWljb24ge1xuICAgICAgICBjb2xvcjogZ3JheTtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAzMHB4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwic3RhY2tzLWRpc3BsYXlcIiBjbGFzcz1cIm5hdi1kaXNwbGF5LXJvd1wiPlxuICAgIDxkaXYgaWQ9XCJzdGFjay1pY29uXCIgY2xhc3M9XCJuYXYtaWNvblwiPiR7c3RhY2tJY29ufTwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJzdGFjay1yb3dcIj48L3Nsb3Q+XG48L2Rpdj5cbjxkaXYgaWQ9XCJjYXJkcy1kaXNwbGF5XCIgY2xhc3M9XCJuYXYtZGlzcGxheS1yb3dcIj5cbiAgICA8ZGl2IGlkPVwiY2FyZC1pY29uXCIgY2xhc3M9XCJuYXYtaWNvblwiPiR7Y2FyZEljb259PC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cImNhcmQtcm93XCI+PC9zbG90PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBTVE5hdmlnYXRvciBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgdXAgdGVtcGxhdGVcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnRvZ2dsZSA9IHRoaXMudG9nZ2xlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbiA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UgPSB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0QWRkZWQgPSB0aGlzLmhhbmRsZVBhcnRBZGRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkID0gdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNhcmRSb3dGb3IgPSB0aGlzLmNyZWF0ZUNhcmRSb3dGb3IuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBjb250ZXh0IG1lbnUgdG8gb3BlbiBpbiB0aGUgbmF2IHNpbmNlXG4gICAgICAgIC8vIGl0IGRvZW5zJ3QgbWFrZSBzZW5zZSBhdG0gYW5kIHdpbGwgZXJyb3JcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICBsZXQgd29ybGRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgd29ybGRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG5cbiAgICAgICAgLy8gUmVzcG9uZCB0byB0aGUgU3lzdGVtIHBhcnQtYWRkZWQgQ3VzdG9tRXZlbnRcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICB3b3JsZFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG5cbiAgICAgICAgLy8gQWRkIGEgU3RhY2tSb3cgdmlldy5cbiAgICAgICAgdGhpcy5zdGFja1Jvd0VsID0gdGhpcy5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBuYXYtc3RhY2stcm93Jyk7XG4gICAgICAgIGlmKCF0aGlzLnN0YWNrUm93RWwpe1xuICAgICAgICAgICAgdGhpcy5zdGFja1Jvd0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmF2LXN0YWNrLXJvdycpO1xuICAgICAgICAgICAgdGhpcy5zdGFja1Jvd0VsLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdzdGFjay1yb3cnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5zdGFja1Jvd0VsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWNrUm93RWwuc2V0TW9kZWwodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFueSBuZWVkZWQgQ2FyZFJvdyB2aWV3cyBmb3IgYWxsIHN0YWNrc1xuICAgICAgICAvLyBjdXJyZW50bHkgaW4gdGhlIHdvcmxkXG4gICAgICAgIHRoaXMubW9kZWwuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KS5mb3JFYWNoKHN0YWNrUGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNhcmRSb3dGb3Ioc3RhY2tQYXJ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5pdCB0aGUgU3RhY2tSb3dcbiAgICAgICAgdGhpcy5zdGFja1Jvd0VsLmluaXRWaWV3KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2FyZC9zdGFjayB2YWx1ZXNcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKCk7XG5cbiAgICAgICAgLy8gUmVzcG9uZCB0byBldmVudHVhbCBjdXJyZW50LW5lc3MgcHJvcFxuICAgICAgICAvLyBjaGFuZ2VzIGZyb20gdGhlIFdvcmxkU3RhY2suXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDdXJyZW50Q2hhbmdlKCl7XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGlzIG1lYW5zIHRoYXQgdGhlIGN1cnJlbnQgKnN0YWNrKiBoYXMgY2hhbmdlZC5cbiAgICAgICAgLy8gU28gd2UgbmVlZCB0byBmaW5kIHRoZSBjb3JyZWN0IENhcmRSb3cgZm9yIGl0IGFuZCBzZXQgaXRcbiAgICAgICAgLy8gdG8gYmUgdGhlIHNsb3R0ZWQgb25lIGluIHRoZSBzaGFkb3cgRE9NXG4gICAgICAgIGxldCBjdXJyZW50U3RhY2tJZCA9IHRoaXMubW9kZWwuY3VycmVudFN0YWNrLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCduYXYtY2FyZC1yb3cnKSkuZm9yRWFjaChjYXJkUm93ID0+IHtcbiAgICAgICAgICAgIGxldCByb3dJZCA9IGNhcmRSb3cuZ2V0QXR0cmlidXRlKCdzdGFjay1pZCcpO1xuICAgICAgICAgICAgY2FyZFJvdy5yZW1vdmVBdHRyaWJ1dGUoJ3Nsb3QnKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRTdGFja0lkID09IHJvd0lkKXtcbiAgICAgICAgICAgICAgICBjYXJkUm93LnNldEF0dHJpYnV0ZSgnc2xvdCcsICdjYXJkLXJvdycpO1xuICAgICAgICAgICAgICAgIEFycmF5LmZyb20oY2FyZFJvdy5xdWVyeVNlbGVjdG9yQWxsKCd3cmFwcGVkLXZpZXcnKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci51cGRhdGVTY2FsaW5nKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZVBhcnRBZGRlZChldmVudCl7XG4gICAgICAgIC8vIElmIGEgbmV3IHN0YWNrIGlzIGFkZGVkLCB3ZSBuZWVkIHRvIGNyZWF0ZVxuICAgICAgICAvLyBhIG5ldyBDYXJkUm93IGZvciBpdC5cbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgbGV0IHN0YWNrUGFydCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW2V2ZW50LmRldGFpbC5wYXJ0SWRdO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDYXJkUm93Rm9yKHN0YWNrUGFydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVQYXJ0UmVtb3ZlZChldmVudCl7XG4gICAgICAgIC8vIElmIGEgc3RhY2sgaGFzIGJlZW4gcmVtb3ZlZCwgd2UgbmVlZCB0b1xuICAgICAgICAvLyByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgQ2FyZFJvd1xuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICBsZXQgY2FyZFJvdyA9IHRoaXMucXVlcnlTZWxlY3RvcihgW3N0YWNrLWlkPVwiJHtldmVudC5kZXRhaWwucGFydElkfVwiXWApO1xuICAgICAgICAgICAgaWYoY2FyZFJvdyl7XG4gICAgICAgICAgICAgICAgY2FyZFJvdy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZUNhcmRSb3dGb3IoYVN0YWNrKXtcbiAgICAgICAgbGV0IGNhcmRSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYtY2FyZC1yb3cnKTtcbiAgICAgICAgY2FyZFJvdy5zZXRBdHRyaWJ1dGUoJ3N0YWNrLWlkJywgYVN0YWNrLmlkKTtcbiAgICAgICAgY2FyZFJvdy5zZXRNb2RlbChhU3RhY2spO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNhcmRSb3cpO1xuICAgICAgICBjYXJkUm93LmluaXRWaWV3KCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCl7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpO1xuICAgICAgICBpZih0aGlzLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKXtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3Blbigpe1xuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgwKVwiO1xuICAgIH1cblxuICAgIGNsb3NlKCl7XG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKDEwMCUpXCI7XG4gICAgfVxuXG4gICAgXG59O1xuXG5leHBvcnQge1xuICAgIFNUTmF2aWdhdG9yLFxuICAgIFNUTmF2aWdhdG9yIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIE5hdmlnYXRvciBTdGFjayBSb3dcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgdmlldyBvbiB0aGUgV29ybGRTdGFjayB0aGF0IHNob3dzIGVhY2hcbiAqIHN1YnBhcnQgc3RhY2sgaXRlbSBhcyBhIHdyYXBwZWQgbGVucyB2aWV3IGFsb25nXG4gKiBhIHJvdy5cbiAqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4uL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG48L3N0eWxlPlxuPHNsb3QgbmFtZT1cInN0YWNrc1wiPjwvc2xvdD5cbmA7XG5cbmNsYXNzIFN0YWNrUm93IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5pbml0VmlldyA9IHRoaXMuaW5pdFZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRXcmFwcGVkU3RhY2sgPSB0aGlzLmFkZFdyYXBwZWRTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UgPSB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0QWRkZWQgPSB0aGlzLmhhbmRsZVBhcnRBZGRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkID0gdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNob3dJbml0aWFsbHkgPSB0aGlzLnNob3dJbml0aWFsbHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldyYXBwZXJDbGljayA9IHRoaXMub25XcmFwcGVyQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBjb250ZXh0IG1lbnUgdG8gb3BlbiBpbiB0aGUgbmF2IHNpbmNlXG4gICAgICAgIC8vIGl0IGRvZW5zJ3QgbWFrZSBzZW5zZSBhdG0gYW5kIHdpbGwgZXJyb3JcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICB9XG5cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YWNrLWlkJywgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBXb3JsZCBNb2RlbCdzIG1haW4gdmlldyBlbGVtZW50LlxuICAgICAgICAvLyBXZSBhZGQgdGhlIHN0LXZpZXctYWRkZWQgQ3VzdG9tRXZlbnQgbGlzdGVuZXJcbiAgICAgICAgLy8gaGVyZSBzbyB3ZSBjYW4gcmVhY3Qgb25seSB0byBkaXJlY3Qgc3RhY2sgYWRkaXRpb25zXG4gICAgICAgIC8vIHRvIHRoZSBXb3JsZFN0YWNrIChhbmQgbm90LCBzYXksIHRvIFdpbmRvd3Mgb3Igb3RoZXIgbmVzdGVkIGtpbmRzKVxuICAgICAgICBsZXQgd29ybGRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgd29ybGRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHdvcmxkVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsVW5zZXQoKXtcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICB3b3JsZFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ3VycmVudENoYW5nZSgpe1xuICAgICAgICBsZXQgY3VycmVudElkID0gdGhpcy5tb2RlbC5jdXJyZW50U3RhY2suaWQ7XG4gICAgICAgIGxldCB3cmFwcGVkVmlld3MgPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd3cmFwcGVkLXZpZXcnKVxuICAgICAgICApO1xuICAgICAgICB3cmFwcGVkVmlld3MuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVkSWQgPSB3cmFwcGVyLmdldEF0dHJpYnV0ZSgnd3JhcHBlZC1pZCcpO1xuICAgICAgICAgICAgaWYod3JhcHBlZElkID09IHRoaXMubW9kZWwuY3VycmVudFN0YWNrLmlkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydEFkZGVkKGV2ZW50KXtcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVyIGlzIGZvciB0aGUgc3Qtdmlldy1hZGRlZFxuICAgICAgICAvLyBDdXN0b21FdmVudCB0aGF0IGlzIHRyaWdnZXJlZCBieSBTeXN0ZW0gd2hlblxuICAgICAgICAvLyBuZXdNb2RlbCgpIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIGxldCBzdGFja1BhcnQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtldmVudC5kZXRhaWwucGFydElkXTtcbiAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlZFN0YWNrKHN0YWNrUGFydCk7XG4gICAgICAgICAgICB0aGlzLnNob3dJbml0aWFsbHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVBhcnRSZW1vdmVkKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgbGV0IHdyYXBwZWRWaWV3ID0gdGhpcy5xdWVyeVNlbGVjdG9yKGB3cmFwcGVkLXZpZXdbd3JhcHBlZC1pZD1cIiR7ZXZlbnQuZGV0YWlsLnBhcnRJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmKHdyYXBwZWRWaWV3KXtcbiAgICAgICAgICAgICAgICB3cmFwcGVkVmlldy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIG51bWJlcnMgb2YgcmVtYWluaW5nIHdyYXBwZWQgdmlld3MgaW4gdGhpcyBTdGFja1Jvd1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3dyYXBwZWQtdmlldycpKS5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbldyYXBwZXJDbGljayhldmVudCl7XG4gICAgICAgIGxldCB3cmFwcGVySXNDdXJyZW50ID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnY3VycmVudCcpO1xuICAgICAgICBpZih0aGlzLm1vZGVsICYmICF3cmFwcGVySXNDdXJyZW50KXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuZ29Ub1N0YWNrQnlJZChcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCd3cmFwcGVkLWlkJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Vmlldygpe1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIHdyYXBwZWQgdmlld3NcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgb3ZlciBlYWNoIGNvcnJlc3BvbmRpbmcgU3RhY2sgYW5kOlxuICAgICAgICAvLyAqIENyZWF0ZSBhIGNsb25lIG9mIGl0cyB2aWV3IG5vZGU7XG4gICAgICAgIC8vICogQXR0YWNoIHRoZSBjb3JyZWN0IG1vZGVsO1xuICAgICAgICAvLyAqIFNldCBpdCB0byBiZSBhIGxlbnNlZCB2aWV3XG4gICAgICAgIC8vICogRG8gdGhlIHNhbWUgZm9yIGFsbCBjaGlsZHJlbiwgcmVjdXJzaXZlbHlcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pLmZvckVhY2goc3RhY2tQYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlZFN0YWNrKHN0YWNrUGFydCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSBpbml0aWFsIGN1cnJlbnQtbmVzcyBkaXNwbGF5XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSgpO1xuICAgIH1cblxuICAgIHNob3dJbml0aWFsbHkoKXtcbiAgICAgICAgLy8gTm90aGluZyBmb3Igbm93XG4gICAgfVxuXG4gICAgYWRkV3JhcHBlZFN0YWNrKGFTdGFjayl7ICBcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBsZW5zZWQgU3RhY2tWaWV3IGludG8gdGhlIHdyYXBwZXJcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd3cmFwcGVkLXZpZXcnKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJzbG90XCIsIFwic3RhY2tzXCIpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbldyYXBwZXJDbGljayk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIHdyYXBwZXIuc2V0TW9kZWwoYVN0YWNrKTtcbiAgICB9XG5cbiAgICBzdWJwYXJ0T3JkZXJDaGFuZ2VkKGlkLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4KXtcbiAgICAgICAgbGV0IHN1YnBhcnROb2RlID0gdGhpcy5jaGlsZE5vZGVzW2N1cnJlbnRJbmRleF07XG4gICAgICAgIGlmKCFzdWJwYXJ0Tm9kZSl7XG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgbW9kZWwgc3VicGFydCB3aGljaCBpcyBub3QgYSBzdGFjayBhbmQgaGVuY2Ugbm90XG4gICAgICAgICAgICAvLyBkaXNwbGF5ZWQgaW4gdGhlIFN0YWNrUm93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYobmV3SW5kZXggPT0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdWJwYXJ0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHdoZXRoZXIgdGhlIGluZGV4IG9mIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGJlZm9yZSBvciBhZnRlciB0aGUgbmV3SW5kZXhcbiAgICAgICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IG5ld0luZGV4KXtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gdGhpcy5jaGlsZE5vZGVzW25ld0luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHN1YnBhcnROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIGRpc3BsYXkgb2YgYWxsIHdyYXBwZWQgdmlld3MgaW4gdGhlIHJvd1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbChgd3JhcHBlZC12aWV3YCkpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTdGFja1JvdyxcbiAgICBTdGFja1JvdyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBXcmFwcGVkVmlldyBDb21wb25lbnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHBsYWluIFdlYmNvbXBvbmVudCB3aG9zZSBwdXJwb3NlIGlzIHRvXG4gKiB3cmFwIGEgdmlzdWFsIGNvcHkgb2YgYW4gYWN0dWFsIFNpbXBsZVRhbGsgVmlld1xuICogZWxlbWVudCBhbmQgZGlzcGxheSBpdCBpbiBhIHNjYWxlZCBkb3duIGZvcm1hdC5cbiAqIEkgbWFrZSBhIGNsb25lZCBjb3B5IG9mIHRoZSB1bmRlcmx5aW5nIHZpZXcgYW5kXG4gKiBhdHRhY2ggaXQgdG8gdGhlIHNhbWUgbW9kZWwgYXMgdGhlIG9yaWdpbmFsLlxuICoqL1xuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4uL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgI251bWJlci1kaXNwbGF5IHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW47XG4gICAgICAgIGZvbnQtc2l6ZTogMi4ycmVtO1xuICAgIH1cblxuICAgICNudW1iZXItZGlzcGxheSA+IHNwYW4ge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwcHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBsaW5lYXI7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIH1cblxuICAgIDpob3N0KDpub3QoLmN1cnJlbnQpKSA+ICNudW1iZXItZGlzcGxheSB7XG4gICAgICAgIG9wYWNpdHk6IDAuODtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjUpO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgICAgIHotaW5kZXg6IDEwMDA7XG4gICAgfVxuXG4gICAgOmhvc3QoOm5vdCguY3VycmVudCkpID4gI251bWJlci1kaXNwbGF5ID4gc3BhbiB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwcHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBsaW5lYXI7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJudW1iZXItZGlzcGxheVwiPlxuICAgIDxzcGFuPjwvc3Bhbj5cbjwvZGl2PlxuPHNsb3QgbmFtZT1cIndyYXBwZWQtdmlld1wiPjwvc2xvdD5cbmA7XG5cblxuY2xhc3MgV3JhcHBlZFZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgdXAgdGVtcGxhdGUgYW5kIHNoYWRvd0RvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbkNoaWxkU2xvdHRlZCA9IHRoaXMub25DaGlsZFNsb3R0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsaW5nID0gdGhpcy51cGRhdGVTY2FsaW5nLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlTnVtYmVyQ2hhbmdlID0gdGhpcy5oYW5kbGVOdW1iZXJDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRXcmFwcGVkVmlldyA9IHRoaXMuYWRkV3JhcHBlZFZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlbHlVcGRhdGVMZW5zVmlld3MgPSB0aGlzLl9yZWN1cnNpdmVseVVwZGF0ZUxlbnNWaWV3cy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgLy8gQmluZCBhIGxpc3RlbmVyIGZvciB0aGUgc2xvdCBjaGFuZ2UuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW5ldmVyIGFueVxuICAgICAgICAgICAgLy8gdW5kZXJseWluZyBlbGVtZW50IGlzIHNsb3R0ZWQsIHNvIHdlXG4gICAgICAgICAgICAvLyBrbm93IHRvIHJlY29tcHV0ZSB0aGUgYXBwcm9wcmlhdGUgc2l6aW5nXG4gICAgICAgICAgICAvLyBhbmQgc3R5bGluZ1xuICAgICAgICAgICAgbGV0IHNsb3RFbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc2xvdCcpO1xuICAgICAgICAgICAgc2xvdEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLm9uQ2hpbGRTbG90dGVkKTtcblxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgY29udGV4dCBtZW51IHRvIG9wZW4gaW4gdGhlIG5hdiBzaW5jZVxuICAgICAgICAgICAgLy8gaXQgZG9lbnMndCBtYWtlIHNlbnNlIGF0bSBhbmQgd2lsbCBlcnJvclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGxldCBzbG90RWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3Nsb3QnKTtcbiAgICAgICAgc2xvdEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLm9uQ2hpbGRTbG90dGVkKTtcbiAgICB9XG5cbiAgICBvbkNoaWxkU2xvdHRlZChldmVudCl7XG4gICAgICAgIC8vdGhpcy51cGRhdGVTY2FsaW5nKCk7XG4gICAgICAgIC8vdGhpcy51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbnVtYmVyJywgdGhpcy5oYW5kbGVOdW1iZXJDaGFuZ2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICB0aGlzLmFkZFdyYXBwZWRWaWV3KHRoaXMubW9kZWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTY2FsaW5nKCl7XG4gICAgICAgIGxldCBmaXJzdENoaWxkID0gdGhpcy5jaGlsZHJlblswXTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIHRoZSBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICAgIC8vIGFjdHVhbCB2aWV3IGZvciB0aGUgbGVucy1lZCBwYXJ0LCBpbiBvcmRlciB0byBnZXRcbiAgICAgICAgLy8gaXRzIGN1cnJlbnQgZGltZW5zaW9ucy5cbiAgICAgICAgbGV0IHBhcnRJZCA9IGZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnKTtcbiAgICAgICAgbGV0IHJlZkVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdC13b3JsZGApO1xuICAgICAgICBsZXQgd3JhcEJveCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBpbm5lckJveCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0LXdvcmxkYCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzY2FsaW5nWCA9ICh3cmFwQm94LndpZHRoIC8gaW5uZXJCb3gud2lkdGgpO1xuICAgICAgICBsZXQgcmVmRWxlbWVudEJveCA9IHJlZkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBgJHtyZWZFbGVtZW50Qm94LndpZHRofXB4YDtcbiAgICAgICAgZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBgJHtyZWZFbGVtZW50Qm94LmhlaWdodH1weGA7XG4gICAgICAgIGZpcnN0Q2hpbGQuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c2NhbGluZ1h9KWA7XG4gICAgICAgIGZpcnN0Q2hpbGQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCIwcHggMHB4XCI7XG4gICAgfVxuXG4gICAgdXBkYXRlTnVtYmVyRGlzcGxheSgpe1xuICAgICAgICBsZXQgZmlyc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bMF07XG4gICAgICAgIGxldCBtb2RlbCA9IGZpcnN0Q2hpbGQubW9kZWw7XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBsb29rIGF0IHN1YnBhcnRzIG9mIHRoZSBzYW1lIHR5cGUgKHN0YWNrIG9yIGNhcmQpXG4gICAgICAgIGxldCBzdWJwYXJ0cyA9IG1vZGVsLl9vd25lci5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC50eXBlID09IHBhcnQudHlwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBudW1EaXNwbGF5ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjbnVtYmVyLWRpc3BsYXkgPiBzcGFuJyk7XG4gICAgICAgIG51bURpc3BsYXkuaW5uZXJUZXh0ID0gc3VicGFydHMuaW5kZXhPZihtb2RlbCkgKyAxO1xuICAgIH1cblxuICAgIGhhbmRsZU51bWJlckNoYW5nZSgpe1xuICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIGRpc3BsYXkgb2YgYWxsIHdyYXBwZWQgdmlld3MgaW4gdGhlIHJvd1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKGB3cmFwcGVkLXZpZXdgKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRXcmFwcGVkVmlldyhhUGFydE1vZGVsKXtcbiAgICAgICAgLy8gRmlyc3QsIGNsZWFyIG91dCBhbnkgZXhpc3RpbmdcbiAgICAgICAgLy8gY2hpbGQgZWxlbWVudHNcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGxlbnNlZCBjb3B5IG9mIHRoZSBnaXZlblxuICAgICAgICAvLyB2aWV3IGFuZCB1cGRhdGUga2V5IGF0dHJpYnV0ZXMgb24gaXRcbiAgICAgICAgbGV0IG9yaWdpbmFsVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0LWlkPVwiJHthUGFydE1vZGVsLmlkfVwiXWApO1xuICAgICAgICBsZXQgbGVuc2VkVmlldyA9IG9yaWdpbmFsVmlldy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGxlbnNlZFZpZXcuc2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnLCBhUGFydE1vZGVsLmlkKTtcbiAgICAgICAgbGVuc2VkVmlldy5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnd3JhcHBlZC12aWV3Jyk7XG4gICAgICAgIGxlbnNlZFZpZXcuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICBsZW5zZWRWaWV3LndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIElubGluZSB0aGUgaW5pdGlhbCBzY2FsaW5nIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFdlIGJlZ2luIHdpdGggYW4gZXh0cmVtZWx5IHNtYWxsIGFtb3VudCB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGFkanVzdGVkIGxhdGVyIGR1cmluZyB1cGRhdGVTY2FsaW5nKCk7XG4gICAgICAgIGxlbnNlZFZpZXcuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7MC4wMDF9KWA7XG4gICAgICAgIGxlbnNlZFZpZXcuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCIwcHggMHB4XCI7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjcmVhdGUgbGVucyB2aWV3cyBvZiBhbGwgc3VicGFydCBjaGlsZHJlblxuICAgICAgICAvLyBhbmQgYXBwZW5kIHRoZW0gaW4gdGhlIGNvcnJlY3QgcGxhY2VzXG4gICAgICAgIGxlbnNlZFZpZXcuaXNMZW5zZWQgPSB0cnVlO1xuICAgICAgICBsZW5zZWRWaWV3LnNldE1vZGVsKGFQYXJ0TW9kZWwpO1xuICAgICAgICBsZW5zZWRWaWV3LnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICBpZihsZW5zZWRWaWV3LmhhbmRsZUN1cnJlbnRDaGFuZ2Upe1xuICAgICAgICAgICAgbGVuc2VkVmlldy5oYW5kbGVDdXJyZW50Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlbHlVcGRhdGVMZW5zVmlld3MobGVuc2VkVmlldywgYVBhcnRNb2RlbC5pZCk7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSByb290IGxlbnNlZCB2aWV3IGludG8gdGhlIHdyYXBwZXJcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dyYXBwZWQtaWQnLCBhUGFydE1vZGVsLmlkKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChsZW5zZWRWaWV3KTtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsaW5nKCk7XG4gICAgfVxuXG4gICAgX3JlY3Vyc2l2ZWx5VXBkYXRlTGVuc1ZpZXdzKGxlbnNlZFZpZXcsIGFuSWQpe1xuICAgICAgICBsZXQgc3ViVmlld3MgPSBBcnJheS5mcm9tKGxlbnNlZFZpZXcuY2hpbGRyZW4pLmZpbHRlcihjaGlsZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuaXNQYXJ0VmlldztcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YlZpZXdzLmZvckVhY2goc3ViVmlldyA9PiB7XG4gICAgICAgICAgICBzdWJWaWV3LmlzTGVuc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1YlZpZXcud2FudHNIYWxvID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3ViSWQgPSBzdWJWaWV3LmdldEF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgc3ViVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIHN1YklkKTtcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3N1YklkXTtcbiAgICAgICAgICAgIHN1YlZpZXcuc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgc3ViVmlldy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZWx5VXBkYXRlTGVuc1ZpZXdzKHN1YlZpZXcsIHN1YklkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFBhcnRWaWV3IE92ZXJyaWRlcyAqKi9cbiAgICBzdHlsZUNTUygpe1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuXG4gICAgc3R5bGVUZXh0Q1NTKCl7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICB9XG5cbiAgICBsYXlvdXRDaGFuZ2VkKCl7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFdyYXBwZWRWaWV3LFxuICAgIFdyYXBwZWRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQge0FjdGl2YXRpb25Db250ZXh0fSBmcm9tICcuLi9vYmplY3RzL0V4ZWN1dGlvblN0YWNrLmpzJztcblxuLy8gSGVscGVyc1xuZnVuY3Rpb24gZmluZE5lYXJlc3RQYXJlbnRPZktpbmQoYVBhcnQsIGFQYXJ0VHlwZSl7XG4gICAgbGV0IG93bmVyID0gYVBhcnQuX293bmVyO1xuICAgIHdoaWxlKG93bmVyKXtcbiAgICAgICAgaWYob3duZXIudHlwZSA9PSBhUGFydFR5cGUpe1xuICAgICAgICAgICAgcmV0dXJuIG93bmVyO1xuICAgICAgICB9XG4gICAgICAgIG93bmVyID0gb3duZXIuX293bmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCd0aGlzJyBpcyBhICR7YVBhcnQudHlwZX0sIG5vdCBhICR7YVBhcnRUeXBlfSBvciBkb2VzIG5vdCBoYXZlIGEgcGFyZW50IG9mIGEgJHthUGFydFR5cGV9IWApO1xufVxuXG4vLyBjaGVjayBmb3IgcG9zc2libGVBbmNlc3Rvci5hY2NlcHRzU3VicGFydChhUGFydC50eXBlKVxuLy8gYW5kIGlmIG5vdCBnbyB0byBvd25lciBhbmQgY2hlY2sgYWdhaW5cbmZ1bmN0aW9uIGZpbmRGaXJzdFBvc3NpYmxlQW5jZXN0b3IoYVBhcnQsIGFQYXJ0VHlwZSl7XG4gICAgaWYoX3N1YnBhcnRDaGVjayhhUGFydCwgYVBhcnRUeXBlKSl7XG4gICAgICAgIHJldHVybiBhUGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgb3duZXIgPSBhUGFydC5fb3duZXI7XG4gICAgICAgIHdoaWxlKG93bmVyKXtcbiAgICAgICAgICAgIGlmKF9zdWJwYXJ0Q2hlY2sob3duZXIsIGFQYXJ0VHlwZSkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBvd25lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG93bmVyID0gb3duZXIuX293bmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgYSAke2FQYXJ0LnR5cGV9LCBkb2VzIG5vdCBhY2NlcHQgbm9yIGhhcyBhbnkgYW5jZXN0b3JzIHdoaWNoIGFjY2VwdCBwYXJ0IHR5cGUgJHthUGFydFR5cGV9YCk7XG59XG5cbmZ1bmN0aW9uIF9zdWJwYXJ0Q2hlY2soYVBhcnQsIGFQYXJ0VHlwZSl7XG4gICAgaWYoYVBhcnRUeXBlID09ICdwYXJ0Jyl7XG4gICAgICAgIHJldHVybiBhUGFydC5hY2NlcHRlZFN1YnBhcnRUeXBlcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICByZXR1cm4gYVBhcnQuYWNjZXB0c1N1YnBhcnQoYVBhcnRUeXBlKTtcbn1cblxuY2xhc3MgU1RWYXJpYWJsZVJlZmVyZW5jZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIFNUVmFyaWFibGVSZWZlcmVuY2VFcnJvci5wcm90b3R5cGUsXG4gICAgJ25hbWUnLFxuICAgIHtcbiAgICAgICAgdmFsdWU6ICdTVFZhcmlhYmxlUmVmZXJlbmNlRXJyb3InXG4gICAgfVxuKTtcblxuY29uc3QgY3JlYXRlSW50ZXJwcmV0ZXJTZW1hbnRpY3MgPSAocGFydENvbnRleHQsIHN5c3RlbUNvbnRleHQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBTY3JpcHQ6IGZ1bmN0aW9uKHNjcmlwdFBhcnRzLCBfKXtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQYXJ0cy5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgTWVzc2FnZUhhbmRsZXI6IGZ1bmN0aW9uKGhhbmRsZXJPcGVuLCBsaW5lVGVybSwgb3B0aW9uYWxTdGF0ZW1lbnRMaXN0LCBoYW5kbGVyQ2xvc2Upe1xuICAgICAgICAgICAgbGV0IHttZXNzYWdlTmFtZSwgcGFyYW1ldGVyc30gPSBoYW5kbGVyT3Blbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyRnVuY3Rpb24gPSBmdW5jdGlvbihzZW5kZXJzLCAuLi5hcmdzKXtcblxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBncmFtbWFyLCB0aGUgU3RhdGVtZW50TGlzdCBpc1xuICAgICAgICAgICAgICAgIC8vIGFuIG9wdGlvbmFsIHJ1bGUsIG1lYW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgcnVsZVxuICAgICAgICAgICAgICAgIC8vIGlzIGFuIGVtcHR5IGFycmF5IChubyBzdGF0ZW1lbnRsaXN0KSBvciBhIHNpbmdsZVxuICAgICAgICAgICAgICAgIC8vIGl0ZW0gYXJyYXkgKHRoZSBzdGF0ZW1lbnRsaXN0KVxuICAgICAgICAgICAgICAgIGlmKG9wdGlvbmFsU3RhdGVtZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHN0YXRlbWVudExpc3QgPSBvcHRpb25hbFN0YXRlbWVudExpc3QuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgICAgICAvLyBOZXh0LCB3ZSBpbml0aWFsaXplIGEgbmV3IEFjdGl2YXRpb25Db250ZXh0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3aWxsIGhvbGQgYWxsIHZhcmlhYmxlIGluZm9ybWF0aW9uIGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBleGVjdXRpb24gb2YgdGhpcyBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIC8vIFdlIHB1c2ggaXQgdG8gdGhlIHRvcCBvZiB0aGUgY3VycmVudCBleGVjdXRpb24gc3RhY2tcbiAgICAgICAgICAgICAgICAvLyBhbmQgc2V0IHRoZSBhcmd1bWVudCB2YXJpYWJsZXMgdG8gbG9jYWxzXG4gICAgICAgICAgICAgICAgYXJncy5mb3JFYWNoKChhcmdWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ05hbWUgPSBwYXJhbWV0ZXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtQ29udGV4dC5leGVjdXRpb25TdGFjay5jdXJyZW50LnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIFN0YXRlbWVudExpc3QgaXMgYm90aCBvcHRpb25hbCAqYW5kKiBtYWRlIHVwXG4gICAgICAgICAgICAgICAgLy8gb2YgaXRlcmFibGUgU3RhdGVtZW50TGluZSBydWxlcyAoaWUsICdTdGF0ZW1lbnRMaW5lKycgaW4gZ3JhbW1hciksXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBcInVud3JhcFwiIHRoZXNlIG5vZGVzIHdpdGhvdXQgY2FsbGluZyBpbnRlcnByZXQoKSBvbiB0aGVtLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGV4cHJlc3Npb25zIHdpdGhpbiB0aGUgc3RhdGVtZW50cywgbGlrZSB2YXJpYWJsZSBsb29rdXBzLFxuICAgICAgICAgICAgICAgIC8vIGFyZSBub3QgY2FsbGVkIGJlZm9yZSBhbnkgcHJlY2VkaW5nIHN0YXRlbWVudHMgaGF2ZSBiZWVuIGludGVycHJldGVkIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2VzIGhhdmUgYWxyZWFkeSBiZWVuIHNlbnQuIEZvciBleGFtcGxlLCBzdGF0ZW1lbnQgMSBtaWdodFxuICAgICAgICAgICAgICAgIC8vIHNldCBhIHZhcmlhYmxlIHRoYXQgc3RhdGVtZW50IDIgbmVlZHMgdG8gbG9va3VwIGFuZCB1c2UsIHNvIHdlIHdhbnQgdGhlIGxvb2t1cCB0b1xuICAgICAgICAgICAgICAgIC8vIG9jY3VyIGFmdGVyIHN0YXRlbWVudCAxIGhhcyBiZWVuIGludGVycHJldGVkIGFuZCB0aGUgbWVzc2FnZSBmb3IgaXQgaGFzXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBzZW50LlxuICAgICAgICAgICAgICAgIHN0YXRlbWVudExpc3QuY2hpbGRyZW4uZm9yRWFjaChzdGF0ZW1lbnRMaW5lcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudExpbmVzLmNoaWxkcmVuLmZvckVhY2goc3RhdGVtZW50TGluZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHN0YXRlbWVudExpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcGFydENvbnRleHQuX2NvbW1hbmRIYW5kbGVyc1ttZXNzYWdlTmFtZV0gPSBoYW5kbGVyRnVuY3Rpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWVzc2FnZUhhbmRsZXJPcGVuOiBmdW5jdGlvbihsaXRlcmFsT24sIG1lc3NhZ2VOYW1lLCBvcHRpb25hbFBhcmFtZXRlckxpc3Qpe1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgUGFyYW1ldGVyTGlzdCBoZXJlIGlzIG9wdGlvbmFsLCBpZlxuICAgICAgICAgICAgLy8gaXQgaXMgc2V0IGl0IHdpbGwgYmUgaW4gdGhlIGZvcm0gb2YgYSBzaXplIDEgYXJyYXkuXG4gICAgICAgICAgICAvLyBUaGlzIHNpbmdsZSBhcnJheSBpdGVtIHdpbGwgaXRzZWxmIGJlIGFuIGFycmF5IG9mIHRoZVxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIHZhcmlhYmxlIG5hbWVzLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhbiBlbXB0eSBhcnJheSBpbmRpY2F0ZXMgbm8gcGFyYW1zXG4gICAgICAgICAgICAvLyBhcmUgcGFzc2VkIGluIGZvciB0aGlzIGhhbmRsZXJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBvcHRpb25hbFBhcmFtZXRlckxpc3QuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihwYXJhbXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlTmFtZTogbWVzc2FnZU5hbWUuc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBQYXJhbWV0ZXJMaXN0OiBmdW5jdGlvbihwYXJhbWV0ZXJTdHJpbmcpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlclN0cmluZy5hc0l0ZXJhdGlvbigpLmNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgSW5DbGF1c2U6IGZ1bmN0aW9uKGluTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hbnN3ZXI6IGZ1bmN0aW9uKGFuc3dlciwgZXhwcmVzc2lvbil7XG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImFuc3dlclwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5pbnRlcnByZXQoKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfZ29Ub0RpcmVjdGlvbjogZnVuY3Rpb24oZ29Ub0xpdGVyYWwsIG5leHRQcmV2aW91cywgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgICAgICBhcmdzLnB1c2gobmV4dFByZXZpb3VzLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICBpZiAoc3lzdGVtT2JqZWN0LnNvdXJjZVN0cmluZyl7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHN5c3RlbU9iamVjdC5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImdvIHRvIGRpcmVjdGlvblwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfZ29Ub0J5T2JqZWN0U3BlY2lmaWVyOiBmdW5jdGlvbihnb1RvTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKSAvLyBpZCBvZiB0aGUgb2JqZWN0XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImdvIHRvXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9nb1RvV2Vic2l0ZTogZnVuY3Rpb24oZ29Ub0xpdGVyYWwsIHdlYnNpdGVMaXRlcmFsLCB1cmwpe1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgdXJsLmludGVycHJldCgpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImdvIHRvIHdlYnNpdGVcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2FkZFByb3BlcnR5OiBmdW5jdGlvbihhZGRMaXRlcmFsLCBwcm9wZXJ0eUxpdGVyYWwsIHByb3BOYW1lQXNMaXRlcmFsLCB0b0xpdGVyYWwsIHN5c3RlbU9iamVjdCl7XG4gICAgICAgICAgICBsZXQgc3BlY2lmaWVkT2JqZWN0SWQgPSBzeXN0ZW1PYmplY3QuaW50ZXJwcmV0KClbMF0gfHwgbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHByb3BOYW1lQXNMaXRlcmFsLmludGVycHJldCgpLCAvLyBUaGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIHNwZWNpZmllZE9iamVjdElkXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcIm5ld1Byb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hZGRNb2RlbDogZnVuY3Rpb24oYWRkTGl0ZXJhbCwgbmV3UGFydFR5cGUsIG9wdGlvbmFsUGFydE5hbWUpe1xuICAgICAgICAgICAgLy8gaGVyZSBubyBvd25lciBoYXMgYmVlbiBwcm92aWRlZCBzbyB3ZSBhc3N1bWUgaXQgaXMgdGhlIGZpcnN0IHBvc3NpYmxlIG9uZVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGZpbmRGaXJzdFBvc3NpYmxlQW5jZXN0b3IocGFydENvbnRleHQsIG5ld1BhcnRUeXBlLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBuZXdQYXJ0VHlwZS5zb3VyY2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgcGFyZW50LmlkXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IG9wdGlvbmFsTmFtZSA9IG9wdGlvbmFsUGFydE5hbWUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihvcHRpb25hbE5hbWUgJiYgb3B0aW9uYWxOYW1lLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG9wdGlvbmFsTmFtZVswXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwibmV3TW9kZWxcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2FkZE1vZGVsVG86IGZ1bmN0aW9uKGFkZExpdGVyYWwsIG5ld1BhcnRUeXBlLCBvcHRpb25hbFBhcnROYW1lLCB0b0xpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBuZXdQYXJ0VHlwZS5zb3VyY2VTdHJpbmcsIC8vIFRoZSBraW5kIG9mIHBhcnQgdG8gYWRkXG4gICAgICAgICAgICAgICAgb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpIC8vIGlkIG9mIHRoZSBwYXJlbnQgbW9kZWwgcGFydFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG9wdGlvbmFsTmFtZSA9IG9wdGlvbmFsUGFydE5hbWUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihvcHRpb25hbE5hbWUgJiYgb3B0aW9uYWxOYW1lLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG9wdGlvbmFsTmFtZVswXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwibmV3TW9kZWxcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX3B1dFZhcmlhYmxlOiBmdW5jdGlvbihwdXRMaXRlcmFsLCB2YWx1ZSwgaW50b0xpdGVyYWwsIGdsb2JhbExpdGVyYWwsIGRlc3RpbmF0aW9uKXtcbiAgICAgICAgICAgIGxldCBnbG9iYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKGdsb2JhbExpdGVyYWwuc291cmNlU3RyaW5nKXtcbiAgICAgICAgICAgICAgICBnbG9iYWwgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHZhbHVlLmludGVycHJldCgpLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnNvdXJjZVN0cmluZyxcbiAgICAgICAgICAgICAgICBnbG9iYWxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAncHV0SW50bycsXG4gICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9kZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24oZGVsZXRlTGl0ZXJhbCwgcHJvcGVydHlMaXRlcmFsLCBwcm9wTmFtZUFzTGl0ZXJhbCwgZnJvbUxpdGVyYWwsIHN5c3RlbU9iamVjdCl7XG4gICAgICAgICAgICBsZXQgc3BlY2lmaWVkT2JqZWN0SWQgPSBzeXN0ZW1PYmplY3QuaW50ZXJwcmV0KClbMF0gfHwgbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHByb3BOYW1lQXNMaXRlcmFsLmludGVycHJldCgpLCAvLyBUaGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIHNwZWNpZmllZE9iamVjdElkXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImRlbGV0ZVByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9kZWxldGVNb2RlbDogZnVuY3Rpb24oZGVsZXRlTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKSAvLyBpZCBvZiB0aGUgb2JqZWN0XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImRlbGV0ZU1vZGVsXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9zZXRQcm9wZXJ0eTogZnVuY3Rpb24oc2V0TGl0ZXJhbCwgcHJvcE5hbWVBc0xpdGVyYWwsIHRvTGl0ZXJhbCwgbGl0ZXJhbE9yVmFyTmFtZSwgb3B0aW9uYWxJbkNsYXVzZSl7XG4gICAgICAgICAgICBsZXQgc3BlY2lmaWVkT2JqZWN0SWQgPSBvcHRpb25hbEluQ2xhdXNlLmludGVycHJldCgpWzBdIHx8IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZUFzTGl0ZXJhbC5pbnRlcnByZXQoKSwgLy8gVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBsaXRlcmFsT3JWYXJOYW1lLmludGVycHJldCgpLCAvLyBUaGUgdmFsdWUgb3IgYSB2YXIgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgIHNwZWNpZmllZE9iamVjdElkXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcInNldFByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9zZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHNldExpdGVyYWwsIHNlbGVjdGlvbkxpdGVyYWwsIHByb3BOYW1lQXNMaXRlcmFsLCB0b0xpdGVyYWwsIGxpdGVyYWxPclZhck5hbWUsIG9wdGlvbmFsSW5DbGF1c2Upe1xuICAgICAgICAgICAgbGV0IHNwZWNpZmllZE9iamVjdElkID0gb3B0aW9uYWxJbkNsYXVzZS5pbnRlcnByZXQoKVswXSB8fCBudWxsO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgcHJvcE5hbWVBc0xpdGVyYWwuaW50ZXJwcmV0KCksIC8vIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgbGl0ZXJhbE9yVmFyTmFtZS5pbnRlcnByZXQoKSwgLy8gVGhlIHZhbHVlIG9yIGEgdmFyIHJlcHJlc2VudGluZyB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICBzcGVjaWZpZWRPYmplY3RJZFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJzZXRTZWxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2FzazogZnVuY3Rpb24oYXNrTGl0ZXJhbCwgcXVlc3Rpb24pe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJhc2tcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbIHF1ZXN0aW9uLmludGVycHJldCgpIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF90ZWxsQ29tbWFuZDogZnVuY3Rpb24odGVsbExpdGVyYWwsIG9iamVjdFNwZWNpZmllciwgdG9MaXRlcmFsLCBjb21tYW5kKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAndGVsbCcsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCksXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuaW50ZXJwcmV0KClcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYXJiaXRyYXJ5Q29tbWFuZDogZnVuY3Rpb24oY29tbWFuZE5hbWUsIG9wdGlvbmFsQXJndW1lbnRMaXN0KXtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgaXMgb3B0aW9uYWwgaGVyZSwgaXQgd2lsbFxuICAgICAgICAgICAgLy8gYmUgZWl0aGVyIGFuIGVtcHR5IGFycmF5IChubyBhcmd1bWVudHMpIG9yIGEgc2l6ZSAxXG4gICAgICAgICAgICAvLyBhcnJheSAod2hpY2ggaXRzZWxmIHdpbGwgY29udGFpbiBhbiBhcnJheSBvZiB0aGUgYXJndW1lbnRzKVxuICAgICAgICAgICAgbGV0IG9wdGlvbmFsQXJndW1lbnRzID0gb3B0aW9uYWxBcmd1bWVudExpc3QuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihvcHRpb25hbEFyZ3VtZW50cy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICBvcHRpb25hbEFyZ3VtZW50cyA9IG9wdGlvbmFsQXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBjb21tYW5kTmFtZS5zb3VyY2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgYXJnczogb3B0aW9uYWxBcmd1bWVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZEFyZ3VtZW50TGlzdDogZnVuY3Rpb24obGlzdCl7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5hc0l0ZXJhdGlvbigpLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFN0YXRlbWVudExpbmU6IGZ1bmN0aW9uKHN0YXRlbWVudCwgbmV3bGluZSl7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHN0YXRlbWVudC5pbnRlcnByZXQoKTtcblxuICAgICAgICAgICAgLy8gU29tZSBzdGF0ZW1lbnRzLCBsaWtlIGlmLXRoZW4gY29udHJvbHNcbiAgICAgICAgICAgIC8vIGFuZCByZXBlYXQgY29udHJvbHMsIGRvIG5vdCByZXN1bHQgaW5cbiAgICAgICAgICAgIC8vIG1lc3NhZ2VzIGJ1dCByZXR1cm4gbnVsbC5cbiAgICAgICAgICAgIC8vIFdlIGlnbm9yZSB0aGVzZS5cbiAgICAgICAgICAgIGlmKG1lc3NhZ2UgJiYgdHlwZW9mKG1lc3NhZ2UpICE9PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1hbmRSZXN1bHQgPSBwYXJ0Q29udGV4dC5zZW5kTWVzc2FnZShtZXNzYWdlLCBwYXJ0Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgc3lzdGVtQ29udGV4dC5leGVjdXRpb25TdGFjay5jdXJyZW50LnNldExvY2FsKCdpdCcsIGNvbW1hbmRSZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGFjdHVhbFN0YXRlbWVudCwgb3B0aW9uYWxDb21tZW50KXtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWxTdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvbl9hZGRFeHByOiBmdW5jdGlvbihmaXJzdEV4cHJlc3Npb24sIG9wZXJhdGlvbiwgc2Vjb25kRXhwcmVzc2lvbil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmaXJzdEV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCArIHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX21pbnVzRXhwcjogZnVuY3Rpb24oZmlyc3RFeHByLCBvcGVyYXRpb24sIHNlY29uZEV4cHIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHNlY29uZEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgLSBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvbl9kaXZpZGVFeHByOiBmdW5jdGlvbihmaXJzdEV4cHIsIG9wZXJhdGlvbiwgc2Vjb25kRXhwcil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmaXJzdEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCAvIHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX21vZHVsb0RpdmlkZUV4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwciwgb3BlcmF0aW9uLCBzZWNvbmRFeHByKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ICUgc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fdGltZXNFeHByOiBmdW5jdGlvbihmaXJzdEV4cHJlc3Npb24sIG9wZXJhdGlvbiwgc2Vjb25kRXhwcmVzc2lvbil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmaXJzdEV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCAqIHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX3N0cmluZ0NvbmNhdEV4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwcmVzc2lvbiwgb3BlcmF0aW9uLCBzZWNvbmRFeHByZXNzaW9uKXtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgZW5jb3VudGVyIHRoZSBcIiZcIiBvcGVyYXRvciwgd2UgY29lcmNlIGJvdGggZXhwcmVzc2lvbnMgaW50b1xuICAgICAgICAgICAgLy8gYSBzdHJpbmdcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwcmVzc2lvbi5pbnRlcnByZXQoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHNlY29uZEV4cHJlc3Npb24uaW50ZXJwcmV0KCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtmaXJzdH0ke3NlY29uZH1gO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZhY3Rvcl9wYXJlbkZhY3RvcjogZnVuY3Rpb24obGVmdFBhcmVuLCBleHByZXNzaW9uLCByaWdodFBhcmVuKXtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZhY3Rvcl9ub3RGYWN0b3I6IGZ1bmN0aW9uKG5vdExpdGVyYWwsIGV4cHJlc3Npb24pe1xuICAgICAgICAgICAgcmV0dXJuICFleHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEVxdWFsaXR5Q29uZGl0aW9uYWw6IGZ1bmN0aW9uKGV4cHIxLCBjb21wYXJhdG9yTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPT09IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBOb25FcXVhbGl0eUNvbmRpdGlvbmFsOiBmdW5jdGlvbihleHByMSwgY29tcGFyYXRvckxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ICE9PSBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxfZ3RDb21wYXJpc29uOiBmdW5jdGlvbihleHByMSwgZ3RMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBleHByMS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBleHByMi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA+IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb25kaXRpb25hbF9sdENvbXBhcmlzb246IGZ1bmN0aW9uKGV4cHIxLCBsdExpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0IDwgc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsX2d0ZUNvbXBhcmlzb246IGZ1bmN0aW9uKGV4cHIxLCBndGVMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBleHByMS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBleHByMi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA+PSBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxfbHRlQ29tcGFyaXNvbjogZnVuY3Rpb24oZXhwcjEsIGx0ZUxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0IDw9IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVyZUlzQW5PYmplY3RDb25kaXRpb25hbDogZnVuY3Rpb24odGhlcmVMaXRlcmFsLCBpc0xpdGVyYWwsIGFPckFuTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlcmVJc05vdEFuT2JqZWN0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uKHRoZXJlTGl0ZXJhbCwgaXNMaXRlcmFsLCBub3RMaXRlcmFsLCBhT3JBbkxpdGVyYWwsIGluQ2xhdXNlKXtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlcmVJc0FQcm9wZXJ0eUNvbmRpdGlvbmFsX3dpdGhTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZXJlTGl0ZXJhbCwgaXNMaXRlcmFsLCBhTGl0ZXJhbCwgcHJvcGVydHlMaXRlcmFsLCBwcm9wTmFtZSwgb2ZMaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IHRhcmdldElkID0gb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHN5c3RlbUNvbnRleHQucGFydHNCeUlkW3RhcmdldElkXTtcbiAgICAgICAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcGFydCB3aXRoIGlkICR7dGFyZ2V0SWR9ICgke3RoaXMuc291cmNlU3RyaW5nfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZS5pbnRlcnByZXQoKSk7XG4gICAgICAgICAgICBpZihwcm9wZXJ0eSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlcmVJc0FQcm9wZXJ0eUNvbmRpdGlvbmFsX3dpdGhvdXRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZXJlTGl0ZXJhbCwgaXNMaXRlcmFsLCBhTGl0ZXJhbCwgcHJvcGVydHlMaXRlcmFsLCBwcm9wTmFtZSl7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBwYXJ0Q29udGV4dC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZS5pbnRlcnByZXQoKSk7XG4gICAgICAgICAgICBpZihwcm9wZXJ0eSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlcmVJc05vdEFQcm9wZXJ0eUNvbmRpdGlvbmFsX3dpdGhTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZXJlTGl0ZXJhbCwgaXNMaXRlcmFsLCBub3RMaXRlcmFsLCBhTGl0ZXJhbCwgcHJvcGVydHlMaXRlcmFsLCBwcm9wTmFtZSwgb2ZMaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IHRhcmdldElkID0gb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHN5c3RlbUNvbnRleHQucGFydHNCeUlkW3RhcmdldElkXTtcbiAgICAgICAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcGFydCB3aXRoIGlkICR7dGFyZ2V0SWR9ICgke3RoaXMuc291cmNlU3RyaW5nfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZS5pbnRlcnByZXQoKSk7XG4gICAgICAgICAgICBpZihwcm9wZXJ0eSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlcmVJc05vdEFQcm9wZXJ0eUNvbmRpdGlvbmFsX3dpdGhvdXRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRoZXJlTGl0ZXJhbCwgaXNMaXRlcmFsLCBub3RMaXRlcmFsLCBhTGl0ZXJhbCwgcHJvcExpdGVyYWwsIHByb3BOYW1lKXtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IHBhcnRDb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKHByb3BOYW1lLmludGVycHJldCgpKTtcbiAgICAgICAgICAgIGlmKHByb3BlcnR5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBJZlRoZW5JbmxpbmU6IGZ1bmN0aW9uKGlmTGl0ZXJhbCwgY29uZGl0aW9uYWwsIHRoZW5MaXRlcmFsLCBzdGF0ZW1lbnQsIG9wdGlvbmFsQ29tbWVudCl7XG4gICAgICAgICAgICBsZXQgc2hvdWxkRXZhbHVhdGUgPSBjb25kaXRpb25hbC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKHNob3VsZEV2YWx1YXRlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBJZlRoZW5TaW5nbGVsaW5lX3dpdGhvdXRFbHNlOiBmdW5jdGlvbihpZkxpbmUsIGxpbmVUZXJtMSwgdGhlbkxpbmUpe1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvbiA9IGlmTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKGNvbmRpdGlvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZW5MaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBJZlRoZW5TaW5nbGVsaW5lX3dpdGhFbHNlOiBmdW5jdGlvbihpZkxpbmUsIGxpbmVUZXJtMSwgdGhlbkxpbmUsIGxpbmVUZXJtMiwgZWxzZUxpbmUpe1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvbiA9IGlmTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKGNvbmRpdGlvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZW5MaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxzZUxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZUaGVuTXVsdGlsaW5lX3dpdGhFbHNlOiBmdW5jdGlvbihpZkxpbmUsIGxpbmVUZXJtLCBtdWx0aVRoZW4sIG11bHRpRWxzZSwgZW5kSWZMaW5lKXtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBpZkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihjb25kaXRpb24pe1xuICAgICAgICAgICAgICAgIHJldHVybiBtdWx0aVRoZW4uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtdWx0aUVsc2UuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZUaGVuTXVsdGlsaW5lX3dpdGhvdXRFbHNlOiBmdW5jdGlvbihpZkxpbmUsIGxpbmVUZXJtLCBtdWx0aVRoZW4sIGVuZElmTGluZSl7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gaWZMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoY29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXVsdGlUaGVuLmludGVycHJldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZMaW5lOiBmdW5jdGlvbihpZkxpdGVyYWwsIGNvbmRpdGlvbmFsLCBvcHRpb25hbENvbW1lbnQpe1xuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbmFsLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZW5MaW5lOiBmdW5jdGlvbih0aGVuTGl0ZXJhbCwgc3RhdGVtZW50LCBvcHRpb25hbENvbW1lbnQpe1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFbHNlTGluZTogZnVuY3Rpb24oZWxzZUxpdGVyYWwsIHN0YXRlbWVudCwgb3B0aW9uYWxDb21tZW50KXtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29udHJvbFN0YXRlbWVudExpbmU6IGZ1bmN0aW9uKHN0YXRlbWVudExpbmUpe1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudExpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTXVsdGlUaGVuOiBmdW5jdGlvbih0aGVuTGl0ZXJhbCwgb3B0aW9uYWxDb21tZW50LCBsaW50VGVybSwgY29udHJvbFN0YXRlbWVudExpbmVzKXtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sU3RhdGVtZW50TGluZXMuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTXVsdGlFbHNlOiBmdW5jdGlvbihlbHNlTGl0ZXJhbCwgb3B0aW9uYWxDb21tZW50LCBsaW5lVGVybSwgY29udHJvbFN0YXRlbWVudExpbmVzKXtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sU3RhdGVtZW50TGluZXMuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgS2luZENvbmRpdGlvbmFsOiBmdW5jdGlvbihleHByMSwgY29tcGFyYXRvckxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIC8vIFRPRE86IEZsZXNoIG91dCB0aGlzIGZ1bmN0aW9uIHRvIGFjY291bnQgZm9yXG4gICAgICAgICAgICAvLyB2YXJpb3VzIG9iamVjdCB0eXBlcyBhbmQgdGhlaXIga2luZCBjb21wYXJpc29uc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIE5vdEtpbmRDb25kaXRpb25hbDogZnVuY3Rpb24oZXhwcjEsIGNvbXBhcmF0b3JMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICAvLyBUT0RPOiBGbGVzaCBvdXQgdGhpcyBmdW5jdGlvbiB0byBhY2NvdW50IGZvclxuICAgICAgICAgICAgLy8gdmFyaW91cyBvYmplY3QgdHlwZXMgYW5kIHRoZWlyIGtpbmQgY29tcGFyaXNvbnNcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdENvbnRyb2xGb3JtX2Zvck51bVRpbWVzOiBmdW5jdGlvbihyZXBlYXRMaXQsIG9wdGlvbmFsRm9yTGl0LCBpbnRPclZhciwgdGltZXNMaXQpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXBlYXRUeXBlOiAnZm9yTnVtVGltZXMnLFxuICAgICAgICAgICAgICAgIG51bVRpbWVzOiBpbnRPclZhci5pbnRlcnByZXQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRDb250cm9sRm9ybV91bnRpbENvbmRpdGlvbjogZnVuY3Rpb24ocmVwZWF0TGl0LCB1bnRpbExpdCwgY29uZGl0aW9uYWwpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXBlYXRUeXBlOiAndW50aWxDb25kaXRpb24nLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0Q29udHJvbEZvcm1fd2hpbGVDb25kaXRpb246IGZ1bmN0aW9uKHJlcGVhdExpdCwgd2hpbGVMaXQsIGNvbmRpdGlvbmFsKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVwZWF0VHlwZTogJ3doaWxlQ29uZGl0aW9uJyxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGNvbmRpdGlvbmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdENvbnRyb2xGb3JtX3dpdGhTdGFydEZpbmlzaDogZnVuY3Rpb24ocmVwZWF0TGl0LCB3aXRoTGl0LCB2YXJOYW1lLCBlcUxpdCwgZmlyc3RWYWwsIHRvTGl0LCBzZWNvbmRWYWwpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXBlYXRUeXBlOiAnd2l0aFN0YXJ0RmluaXNoJyxcbiAgICAgICAgICAgICAgICB2YXJOYW1lOiB2YXJOYW1lLnNvdXJjZVN0cmluZyxcbiAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RWYWwuaW50ZXJwcmV0KCksXG4gICAgICAgICAgICAgICAgZmluaXNoOiBzZWNvbmRWYWwuaW50ZXJwcmV0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0QWRqdXN0X2V4aXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgcmV0dXJuICdleGl0IHJlcGVhdCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0QWRqdXN0X25leHQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgcmV0dXJuICduZXh0IHJlcGVhdCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0QmxvY2s6IGZ1bmN0aW9uKHJlcGVhdENvbnRyb2wsIGxpbmVUZXJtLCBzdGF0ZW1lbnRMaW5lT3JSZXBBZGp1c3RQbHVzLCBlbmRMaXRlcmFsKXtcbiAgICAgICAgICAgIGxldCByZXBlYXRJbmZvID0gcmVwZWF0Q29udHJvbC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzdGF0ZW1lbnRMaW5lcyA9IHN0YXRlbWVudExpbmVPclJlcEFkanVzdFBsdXMuY2hpbGRyZW47XG4gICAgICAgICAgICBzd2l0Y2gocmVwZWF0SW5mby5yZXBlYXRUeXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ2Zvck51bVRpbWVzJzpcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDw9IHJlcGVhdEluZm8ubnVtVGltZXM7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkUGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgc3RhdGVtZW50TGluZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRMaW5lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBjdXJyZW50U3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09ICdleGl0IHJlcGVhdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoaXMgaW5uZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHJlc3VsdCA9PSAnbmV4dCByZXBlYXQnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoaXMgaW5uZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHNob3VsZFBhc3Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHNob3VsZEJyZWFrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhlIG1haW4gZm9yIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhazsgLy8gQnJlYWsgb3V0IG9mIHRoZSBzd2l0Y2hcbiAgICAgICAgICAgIGNhc2UgJ3VudGlsQ29uZGl0aW9uJzpcbiAgICAgICAgICAgICAgICBsZXQgdW50aWxUZXN0Q29uZGl0aW9uID0gcmVwZWF0SW5mby5jb25kaXRpb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUoIXVudGlsVGVzdENvbmRpdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50TGluZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRMaW5lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBjdXJyZW50U3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT0gJ2V4aXQgcmVwZWF0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHJlc3VsdCA9PSAnbmV4dCByZXBlYXQnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHNob3VsZEJyZWFrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhlIG91dGVyIHdoaWxlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bnRpbFRlc3RDb25kaXRpb24gPSByZXBlYXRJbmZvLmNvbmRpdGlvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIEJyZWFrIG91dCBvZiB0aGUgc3dpdGNoIGNhc2VcbiAgICAgICAgICAgIGNhc2UgJ3doaWxlQ29uZGl0aW9uJzpcbiAgICAgICAgICAgICAgICBsZXQgd2hpbGVUZXN0Q29uZGl0aW9uID0gcmVwZWF0SW5mby5jb25kaXRpb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUod2hpbGVUZXN0Q29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdGF0ZW1lbnRMaW5lcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlbWVudCA9IHN0YXRlbWVudExpbmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGN1cnJlbnRTdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT0gJ2V4aXQgcmVwZWF0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzdWx0ID09IFwibmV4dCByZXBlYXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRCcmVhayl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIG91dGVyIHdoaWxlIGxvb3AgKGVuZCByZXBlYXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGVUZXN0Q29uZGl0aW9uID0gcmVwZWF0SW5mby5jb25kaXRpb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2Ygc3dpdGNoIGNhc2VcbiAgICAgICAgICAgIGNhc2UgJ3dpdGhTdGFydEZpbmlzaCc6XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdywgd2UgYXNzdW1lIHRoYXQgc3RhcnQgaXMgbGVzcyB0aGFuXG4gICAgICAgICAgICAgICAgLy8gZmluaXNoLiBXZSBzaG91bGQgcHJvYmFibHkgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICBpZihyZXBlYXRJbmZvLnN0YXJ0ID4gcmVwZWF0SW5mby5maW5pc2gpe1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcGVhdCBlcnJvcjogc3RhcnQgZ3JlYXRlciB0aGFuIGZpbmlzaGApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IHJlcGVhdEluZm8uc3RhcnQ7IGkgPD0gcmVwZWF0SW5mby5maW5pc2g7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIHN5c3RlbUNvbnRleHQuZXhlY3V0aW9uU3RhY2suY3VycmVudC5zZXRMb2NhbChyZXBlYXRJbmZvLnZhck5hbWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZFBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHN0YXRlbWVudExpbmVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGVtZW50ID0gc3RhdGVtZW50TGluZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudFN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PSBcImV4aXQgcmVwZWF0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoaXMgaW5uZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHJlc3VsdCA9PSBcIm5leHQgcmVwZWF0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkUGFzcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkQnJlYWspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGUgb3V0ZXIgKHJlcGVhdCkgbG9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUHJvcGVydHlWYWx1ZV93aXRoU3BlY2lmaWVyOiBmdW5jdGlvbih0aGVMaXRlcmFsLCBwcm9wTmFtZSwgb2ZMaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IHRhcmdldElkID0gb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHN5c3RlbUNvbnRleHQucGFydHNCeUlkW3RhcmdldElkXTtcbiAgICAgICAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcGFydCB3aXRoIGlkICR7dGFyZ2V0SWR9ICgke3RoaXMuc291cmNlU3RyaW5nfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUuaW50ZXJwcmV0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUHJvcGVydHlWYWx1ZV93aXRob3V0U3BlY2lmaWVyOiBmdW5jdGlvbih0aGVMaXRlcmFsLCBwcm9wTmFtZSl7XG4gICAgICAgICAgICByZXR1cm4gcGFydENvbnRleHQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBwYXJ0Q29udGV4dCxcbiAgICAgICAgICAgICAgICBwcm9wTmFtZS5pbnRlcnByZXQoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogT2JqZWN0IFNwZWNpZmllcnMgKiovXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnRCeVRhcmdldCBQYXJ0aWFsIFNwZWNpZmllclxuICAgICAgICAgKiByZWZlcnMgdG8gcGFydGlhbHMgdGhhdCBzcGVjaWZ5IGEgcGFydFxuICAgICAgICAgKiBzcGVjaWZpZWQgaW4gdGhlIFwidGFyZ2V0XCIgUGFydFByb3BlcnR5XG4gICAgICAgICAqIG9mIHRoZSBjb250ZXh0IHBhcnQuIFRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICogdGFyZ2V0IHByb3BlcnR5IGlzIGFueSB2YWxpZCBPYmplY3RTcGVjaWZpZXJcbiAgICAgICAgICogc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgUGFydGlhbFNwZWNpZmllcl9wYXJ0QnlUYXJnZXQodGFyZ2V0TGl0ZXJhbCl7XG4gICAgICAgICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0UHJvcFZhbHVlID0gY29udGV4dC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKGNvbnRleHQsIFwidGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcGFydENvbnRleHQgc2luY2UgdGhlIGNvbnRleHQgb2JqZWN0IG1pZ2h0IG5vdCBoYXZlIGFueSBzZW1hbnRpY3Mgc2V0IG9uIGl0XG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgY29udGV4dCBvYmplY3QvcGFydCB3aGljaCBkb2VzIG5vdCBoYXZlIGEgc2NyaXB0IHdoaWNoIGhhcyBiZWVuXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgd2lsbCBub3QgaGF2ZSBoYWQgY29udGV4dC5fc2VtYW50aWNzIHNldC5cbiAgICAgICAgICAgICAgICBsZXQgc2VtYW50aWNzID0gcGFydENvbnRleHQuX3NlbWFudGljcztcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hPYmplY3QgPSBzeXN0ZW1Db250ZXh0LmdyYW1tYXIubWF0Y2godGFyZ2V0UHJvcFZhbHVlLCAnT2JqZWN0U3BlY2lmaWVyJyk7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldElkID0gc2VtYW50aWNzKG1hdGNoT2JqZWN0KS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtQ29udGV4dC5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRDYXJkIFBhcnRpYWwgU3BlY2lmaWVyXG4gICAgICAgICAqIHJlZmVycyB0byBwYXJ0aWFscyB0aGF0IHNwZWNpZnkgdGhlIGN1cnJlbnQgY2FyZFxuICAgICAgICAgKiBkZXBlbmRpbmcgb24gdGhlIHN0YWNrIGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWFsU3BlY2lmaWVyX2N1cnJlbnRDYXJkOiBmdW5jdGlvbihjdXJyZW50TGl0ZXJhbCwgY2FyZExpdGVyYWwpe1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFBhcnQuY3VycmVudENhcmQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydEJ5SW5kZXggUGFydGlhbCBTcGVjaWZpZXJcbiAgICAgICAgICogcmVmZXJzIHRvIHBhcnRpYWxzIHRoYXQgc3BlY2lmeSBhIHBhcnRcbiAgICAgICAgICogdHlwZSBhbmQgYW4gaW50ZWdlciBsaXRlcmFsLCBmb3IgZXg6XG4gICAgICAgICAqICAgICBmaWVsZCAzXG4gICAgICAgICAqIFRoZSBhYm92ZSBleGFtcGxlIHJlZmVycyB0byB0aGUgdGhpcmRcbiAgICAgICAgICogZmllbGQgcGFydCBpbiBpdHMgb3duZXIvcGFyZW50IHBhcnQuXG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWFsU3BlY2lmaWVyX3BhcnRCeUluZGV4OiBmdW5jdGlvbihvYmplY3RUeXBlLCBpbnRlZ2VyTGl0ZXJhbCl7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBpbnRlZ2VyTGl0ZXJhbC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKGluZGV4IDwgMSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJ0IGluZGljZXMgbXVzdCBiZSAxIG9yIGdyZWF0ZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgaWYob2JqZWN0VHlwZS5zb3VyY2VTdHJpbmcgPT0gJ3BhcnQnKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPiBjb250ZXh0UGFydC5zdWJwYXJ0cy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHRQYXJ0LnR5cGV9WyR7Y29udGV4dFBhcnQuaWR9XSBkb2VzIG5vdCBoYXZlIGEgcGFydCBudW1iZXJlZCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0UGFydC5zdWJwYXJ0c1tpbmRleC0xXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHNPZlR5cGUgPSBjb250ZXh0UGFydC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09IG9iamVjdFR5cGUuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPiBwYXJ0c09mVHlwZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHRQYXJ0LnR5cGV9WyR7Y29udGV4dFBhcnQuaWR9XSBkb2VzIG5vdCBoYXZlIGEgJHtvYmplY3RUeXBlLnNvdXJjZVN0cmluZ30gbnVtYmVyZWQgJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydHNPZlR5cGVbaW5kZXgtMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnRCeU51bWVyaWNhbEluZGV4IFBhcnRpYWwgU3BlY2lmaWVyXG4gICAgICAgICAqIHJlZmVycyB0byBwYXJ0aWFsIHRoYXQgc3BlY2lmeSBhIHBhcnRcbiAgICAgICAgICogdHlwZSBwcmVjZWRlZCBieSB0aGUgRW5nbGlzaCB3b3JkIGZvciB0aGVcbiAgICAgICAgICogbnVtYmVyLiBGb3IgdGhlIG1vbWVudCB3ZSBhY2NlcHQgZmlyc3QgLSB0ZW50aFxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiAgICAgc2l4dGggYnV0dG9uXG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWFsU3BlY2lmaWVyX3BhcnRCeU51bWVyaWNhbEluZGV4OiBmdW5jdGlvbihudW1lcmljYWxLZXl3b3JkLCBvYmplY3RUeXBlKXtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IG51bWVyaWNhbEtleXdvcmQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIGlmKG9iamVjdFR5cGUuc291cmNlU3RyaW5nID09ICdwYXJ0Jyl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ID4gY29udGV4dFBhcnQuc3VicGFydHMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0UGFydC50eXBlfVske2NvbnRleHRQYXJ0LmlkfV0gZG9lcyBub3QgaGF2ZSBhIHBhcnQgbnVtYmVyZWQgJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA8IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoZSBcImxhc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBvZiB0aGUgZGVzaXJlZCBjb2xsZWN0aW9uIHdhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFBhcnQuc3VicGFydHNbY29udGV4dFBhcnQuc3VicGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFBhcnQuc3VicGFydHNbaW5kZXgtMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHNPZlR5cGUgPSBjb250ZXh0UGFydC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09IG9iamVjdFR5cGUuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPiBwYXJ0c09mVHlwZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHRQYXJ0LnR5cGV9WyR7Y29udGV4dFBhcnQuaWR9XSBkb2VzIG5vdCBoYXZlIGEgJHtvYmplY3RUeXBlLnNvdXJjZVN0cmluZ30gbnVtYmVyZWQgJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA8IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoZSBcImxhc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBvZiB0aGUgZGVzaXJlZCBjb2xsZWN0aW9uIHdhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydHNPZlR5cGVbcGFydHNPZlR5cGUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydHNPZlR5cGVbaW5kZXgtMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydEJ5TmFtZSBQYXJ0aWFsIFNwZWNpZmllclxuICAgICAgICAgKiByZWZlcnMgdG8gYSBwYXJ0aWFsIHRoYXQgc3BlY2lmaWVzIGEgcGFydFxuICAgICAgICAgKiBieSBpdHMgbmFtZSBwcm9wZXJ0eS4gRXhhbXBsZTpcbiAgICAgICAgICogICAgIGNhcmQgXCJNeSBDdXN0b20gQ2FyZFwiXG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWFsU3BlY2lmaWVyX3BhcnRCeU5hbWU6IGZ1bmN0aW9uKG9iamVjdFR5cGUsIHN0cmluZ0xpdGVyYWwpe1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBzdHJpbmdMaXRlcmFsLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYob2JqZWN0VHlwZS5zb3VyY2VTdHJpbmcgPT0gJ3BhcnQnKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb250ZXh0UGFydC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmROYW1lID0gc3VicGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnBhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT0gZm91bmROYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZm91bmQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSBwYXJ0IG5hbWVkIFwiJHtuYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29udGV4dFBhcnQuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSBvYmplY3RUeXBlLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfSkuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kTmFtZSA9IHN1YnBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJwYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZE5hbWUgPT0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGZvdW5kLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHRQYXJ0LnR5cGV9WyR7Y29udGV4dFBhcnQuaWR9XSBkb2VzIG5vdCBoYXZlIGEgJHtvYmplY3RUeXBlLnNvdXJjZVN0cmluZ30gbmFtZWQgXCIke25hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ3RoaXMnIHNwZWNpZmllciBpcyBhIHRlcm1pbmFsIChmaW5hbClcbiAgICAgICAgICogc3BlY2lmaWVyIHRoYXQgcmVmZXJzIHRvIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAgICAgICAqIDEuIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IHBhcnQgZXhlY3V0aW5nIHRoZSBzY3JpcHQsXG4gICAgICAgICAqICAgIGV4YW1wbGU6IHRoaXMgYnV0dG9uXG4gICAgICAgICAqIDIuIENhcmQsIHdoaWNoIHJlZmVycyB0byB0aGUgY2FyZCB0aGF0IG93bnMgdGhlXG4gICAgICAgICAqICAgIHBhcnQgdGhhdCBpcyBjdXJyZW50bHkgZXhlY3V0aW5nIHRoZSBzY3JpcHQsIGV4OlxuICAgICAgICAgKiAgICB0aGlzIGNhcmRcbiAgICAgICAgICogMy4gU3RhY2ssIHdoaWNoIHJlZmVycyB0byB0aGUgc3RhY2sgdGhhdCBvd25zIHRoZVxuICAgICAgICAgKiAgICBwYXJ0IHRoYXQgaXMgY3VycmVudGx5IGV4ZWN1dGluZyB0aGUgc2NyaXB0LCBleDpcbiAgICAgICAgICogICAgdGhpcyBzdGFja1xuICAgICAgICAgKi9cbiAgICAgICAgVGVybWluYWxTcGVjaWZpZXJfdGhpc1N5c3RlbU9iamVjdDogZnVuY3Rpb24odGhpc0xpdGVyYWwsIHN5c3RlbU9iamVjdCl7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VHlwZSA9IHN5c3RlbU9iamVjdC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIGlmKHRhcmdldFR5cGUgPT0gcGFydENvbnRleHQudHlwZSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0Q29udGV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZE5lYXJlc3RQYXJlbnRPZktpbmQocGFydENvbnRleHQsIHRhcmdldFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAnY3VycmVudCcgc3BlY2lmaWVyIGlzIGEgdGVybWluYWwgKGZpbmFsKVxuICAgICAgICAgKiBzcGVjaWZpZXIgdGhhdCByZWZlcnMgdG8gZWl0aGVyIHRoZSBjdXJyZW50IGNhcmQgb3Igc3RhY2tcbiAgICAgICAgICogYmVpbmcgZGlzcGxheWVkIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBUaGVyZSBhcmUgb25seSB0d28gcG9zc2libGUgdmFsaWQgb3B0aW9uczpcbiAgICAgICAgICogICAgIGBjdXJyZW50IGNhcmRgXG4gICAgICAgICAqICAgICBgY3VycmVudCBzdGFja2BcbiAgICAgICAgICovXG4gICAgICAgIFRlcm1pbmFsU3BlY2lmaWVyX2N1cnJlbnRTeXN0ZW1PYmplY3Q6IGZ1bmN0aW9uKGN1cnJlbnRMaXRlcmFsLCBzeXN0ZW1PYmplY3Qpe1xuICAgICAgICAgICAgbGV0IHRhcmdldFR5cGUgPSBzeXN0ZW1PYmplY3Quc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICBpZih0YXJnZXRUeXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtQ29udGV4dC5nZXRDdXJyZW50U3RhY2tNb2RlbCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0YXJnZXRUeXBlID09ICdjYXJkJyl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1Db250ZXh0LmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGFyZ2V0VHlwZX0gY2Fubm90IGJlIGEgJ2N1cnJlbnQnIHN5c3RlbSBvYmplY3RgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFydEJ5SWQgc3BlY2lmaWVyIGlzIGEgdGVybWluYWwgKGZpbmFsKVxuICAgICAgICAgKiBzcGVjaWZpZXIgdGhhdCByZWZlcnMgdG8gYSBnaXZlbiBwYXJ0IHR5cGVcbiAgICAgICAgICogYnkgaXRzIHVuaXF1ZSBzeXN0ZW0gaWQuIEZvciBhbnkga2luZCBvZiBwYXJ0LFxuICAgICAgICAgKiB3ZSB1c2UgYHBhcnQgaWQgPG9iamVjdElkPmBcbiAgICAgICAgICogRXhhbXBsZXM6IGBjYXJkIGlkIDI2NmAgYHBhcnQgaWQgNWBcbiAgICAgICAgICovXG4gICAgICAgIFRlcm1pbmFsU3BlY2lmaWVyX3BhcnRCeUlkOiBmdW5jdGlvbihvYmplY3RUeXBlLCBpZExpdGVyYWwsIG9iamVjdElkKXtcbiAgICAgICAgICAgIGxldCBpZCA9IG9iamVjdElkLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHN5c3RlbUNvbnRleHQucGFydHNCeUlkW2lkXTtcbiAgICAgICAgICAgIGlmKCFmb3VuZCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCAke29iamVjdFR5cGUuc291cmNlU3RyaW5nfSB3aXRoIGlkICR7b2JqZWN0SWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBcInByZWZpeGVkXCIgcXVlcmllZCBzcGVjaWZpZXIgaXMganVzdFxuICAgICAgICAgKiBhIFBhcnRpYWxTcGVjaWZpZXIgd2l0aCBcIm9mXCIgaW4gZnJvbnQgb2YgaXQsIGluZGljYXRpbmdcbiAgICAgICAgICogdGhhdCBhIGRpZmZlcmVudCBwYXJ0aWFsIHdpbGwgcHJlY2VkZSBpdCBiZSBxdWVyaWVkIGluc2lkZSBvZiBpdC5cbiAgICAgICAgICogRXhhbXBsZSBgb2YgYnV0dG9uIFwiTXkgQnV0dG9uXCJgXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyaWVkU3BlY2lmaWVyX3ByZWZpeGVkOiBmdW5jdGlvbihwYXJ0aWFsU3BlY2lmaWVyLCBvZkxpdGVyYWwpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWxTcGVjaWZpZXIuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbmVzdGVkIHF1ZXJpZWQgc3BlY2lmaWVyIGlzIG9uZSB0aGF0IGhhcyB0d29cbiAgICAgICAgICogb3IgbW9yZSBwcmVmaXhlZCBzcGVjaWZpZXJzLiBUaGUgc2ltcGxlc3Qgd291bGQgYmVcbiAgICAgICAgICogc29tZXRoaW5nIGxpa2U6XG4gICAgICAgICAqICAgICBgb2YgY2FyZCBcIk15IENhcmRcIiBvZiBzdGFjayBcIkFub3RoZXIgbmFtZWQgc3RhY2tcImBcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJpZWRTcGVjaWZpZXJfbmVzdGVkOiBmdW5jdGlvbihmaXJzdFF1ZXJ5LCBzZWNvbmRRdWVyeSl7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IHNlY29uZFF1ZXJ5LmludGVycHJldCgpKGNvbnRleHRQYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgb3V0ZXIgPSBmaXJzdFF1ZXJ5LmludGVycHJldCgpKGlubmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBPYmplY3RTcGVjaWZpZXIgd2l0aG91dCBhbiBhbm5vdGF0ZWRcbiAgICAgICAgICogcnVsZSBtZWFucyBpdCB3YXMgaW50ZXJwcmV0ZWQgYXMganVzdFxuICAgICAgICAgKiBhIFRlcm1pbmFsU3BlY2lmaWVyIG9mIHNvbWUgc29ydC5cbiAgICAgICAgICogSG93ZXZlciwgd2UgbmVlZCB0byBleHRyYWN0IHRoZSBpZFxuICAgICAgICAgKiBhbmQgcmV0dXJuIHRoYXQgcmVzdWx0LCBzaW5jZSB0aGF0IGlzIHdoYXQgaXNcbiAgICAgICAgICogZXhwZWN0ZWQgb2YgYWxsIGludGVycHJldGVkIE9iamVjdFNwZWNpZmllcnNcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdFNwZWNpZmllcl9zaW5nbGVUZXJtaW5hbDogZnVuY3Rpb24odGVybWluYWxTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGVybWluYWxTcGVjaWZpZXIuaW50ZXJwcmV0KCkoKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBDb21wb3VuZCB3aXRoIHRlcm1pbmFsIHNwZWNpZmllciBpcyBhIFF1ZXJpZWRTcGVjaWZpZXJcbiAgICAgICAgICogdGhhdCBmaW5pc2hlcyB3aXRoIGEgVGVybWluYWwgc3BlY2lmaWVyLlxuICAgICAgICAgKiBFeGFtcGxlOiBgb2YgYnV0dG9uIDMgb2YgY2FyZCBcIlNvbWUgbmFtZWQgY2FyZFwiIG9mIGN1cnJlbnQgc3RhY2tgXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3RTcGVjaWZpZXJfY29tcG91bmRRdWVyeVdpdGhUZXJtaW5hbDogZnVuY3Rpb24ocXVlcmllZFNwZWNpZmllciwgdGVybWluYWxTcGVjaWZpZXIpe1xuICAgICAgICAgICAgLy8gVGhlIHRlcm1pbmFsIGhlcmUgaXMgdGhlIHVsdGltYXRlIHBhcnQgY29udGV4dFxuICAgICAgICAgICAgbGV0IGZpbmFsUGFydCA9IHRlcm1pbmFsU3BlY2lmaWVyLmludGVycHJldCgpKCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcXVlcmllZFNwZWNpZmllci5pbnRlcnByZXQoKShmaW5hbFBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBDb21wb3VuZCB3aXRob3V0IHRlcm1pbmFsIHNwZWNpZmllciBpcyBhIFF1ZXJpZWRTcGVjaWZpZXJcbiAgICAgICAgICogdGhhdCBmaW5pc2hlcyB3aXRoIGEgUGFydGlhbCBzcGVjaWZpZXIuXG4gICAgICAgICAqIEV4YW1wbGU6IGBvZiBidXR0b24gMyBvZiBmaXJzdCBjYXJkYCAod2hpY2ggY2FuIGNvbnRpbnVlIGAuLm9mIGN1cnJlbnQgc3RhY2tgIGV0YylcbiAgICAgICAgICogYGZpcnN0IGJ1dHRvbiBvZiBmaXJzdCBhcmVhIG9mIHN0YWNrIDNgXG4gICAgICAgICAqIGBmaXJzdCBidXR0b24gb2YgYXJlYSB0d28gb2Ygc3RhY2sgM2BcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdFNwZWNpZmllcl9jb21wb3VuZFF1ZXJ5V2l0aG91dFRlcm1pbmFsOiBmdW5jdGlvbihxdWVyaWVkU3BlY2lmaWVyLCBwYXJ0aWFsU3BlY2lmaWVyKXtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJ0aWFsU3BlY2ZpZXIgcmVmZXJzIHRvIGVpdGhlciBhcmVhLCBjYXJkIG9yIHN0YWNrXG4gICAgICAgICAgICAvLyB0aGVuIGdvIHRvIGl0cyBvd25lciBmb3IgdGhlIGNvbnRleHRcbiAgICAgICAgICAgIC8vIGlmIGl0IHJlZmVycyB0byB0aGUgY3VycmVudCBjYXJkIHRoZW4gZmluZCB0aGUgb3duZXIgZm9yIHRoZSBjb250ZXh0XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBwYXJ0aWFsU3BlY2lmaWVyLmNoaWxkcmVuWzBdLmNoaWxkcmVuO1xuICAgICAgICAgICAgbGV0IHN5c3RlbU9iamVjdFN0cmluZztcbiAgICAgICAgICAgIGlmKGNoaWxkcmVuWzBdLnNvdXJjZVN0cmluZyA9PSBcImN1cnJlbnRcIiAmJiBjaGlsZHJlblsxXS5zb3VyY2VTdHJpbmcgPT0gXCJjYXJkXCIpe1xuICAgICAgICAgICAgICAgIHN5c3RlbU9iamVjdFN0cmluZyA9IFwiY2FyZFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5jdG9yTmFtZSA9PSBcInN5c3RlbU9iamVjdFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5c3RlbU9iamVjdFN0cmluZyA9IGNoaWxkLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpbmFsUGFydCA9IGZpbmRGaXJzdFBvc3NpYmxlQW5jZXN0b3IocGFydENvbnRleHQsIHN5c3RlbU9iamVjdFN0cmluZyk7XG4gICAgICAgICAgICBsZXQgZmluYWxQYXJ0aWFsID0gcGFydGlhbFNwZWNpZmllci5pbnRlcnByZXQoKShmaW5hbFBhcnQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHF1ZXJpZWRTcGVjaWZpZXIuaW50ZXJwcmV0KCkoZmluYWxQYXJ0aWFsKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xlIG5vbi10ZXJtaW5hbCBPYmplY3RTcGVjaWZpZXIgaXMganVzdCBhIFBhcnRpYWxcbiAgICAgICAgICogc3BlY2lmaWVyIGJ5IGl0c2VsZi4gV2hlbiBwcmVzZW50IG91dHNpZGUgb2YgYSBRdWVyaWVkU3BlY2lmaWVyLFxuICAgICAgICAgKiBpdCB3aWxsIGJlIGludGVycHJldGVkIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRyZWF0ZWRcbiAgICAgICAgICogYXMgdGVybWluYWwvZmluYWwuIEZvciBleGFtcGxlOlxuICAgICAgICAgKiAgICAgYnV0dG9uIDRcbiAgICAgICAgICogYnkgaXRzZWxmIGFzIGEgd2hvbGUgc3BlY2lmaWVyIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcbiAgICAgICAgICogYGJ1dHRvbiA0IG9mIHRoaXMgY2FyZGBcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdFNwZWNpZmllcl9zaW5nbGVOb25UZXJtaW5hbDogZnVuY3Rpb24ocGFydGlhbFNwZWNpZmllcil7XG4gICAgICAgICAgICAvLyBBIHNpbmdsZSBub24tdGVybWluYWwgb2JqZWN0IHNwZWNpZmllciBpcyBvbmVcbiAgICAgICAgICAgIC8vIHdob3NlIHRlcm1pbmFsIG9iamVjdCBpcyBpbXBsaWNpdGx5IGFzc3VtZWQgdG9cbiAgICAgICAgICAgIC8vIGJlIHRoZSBjYXJkIG9yIHRoZSBzdGFjayBpbiB3aGljaCB0aGUgY3VycmVudCBjb250ZXh0IHBhcnRcbiAgICAgICAgICAgIC8vIGV4aXN0cy5cbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHBhcnRpYWxTcGVjaWZpZXIuY2hpbGRyZW5bMF0uY2hpbGRyZW47XG4gICAgICAgICAgICBsZXQgc3lzdGVtT2JqZWN0U3RyaW5nO1xuICAgICAgICAgICAgaWYoY2hpbGRyZW5bMF0uc291cmNlU3RyaW5nID09IFwiY3VycmVudFwiICYmIGNoaWxkcmVuWzFdLnNvdXJjZVN0cmluZyA9PSBcImNhcmRcIil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbUNvbnRleHQuZ2V0Q3VycmVudENhcmRNb2RlbCgpLmlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5zb3VyY2VTdHJpbmcgPT0gXCJwYXJ0XCIgfHwgY2hpbGQuc291cmNlU3RyaW5nID09IFwidGFyZ2V0XCIgfHwgY2hpbGQuY3Rvck5hbWUgPT0gJ3N5c3RlbU9iamVjdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3lzdGVtT2JqZWN0U3RyaW5nID0gY2hpbGQuc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgc3lzdGVtT2JqZWN0IGlzIHRoZSB0YXJnZXQgKGRlZmluZWQgaW4gaXQncyBcInRhcmdldFwiIHBhcnQgcHJvcGVydHkpLCB0aGVuIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGZpcnN0IGdldCB0aGUgdGFyZ2V0IHByb3BlcnR5IHZhbHVlIChzdHJpbmcpIGFuZCBpbnRlcnByZXQgdGhhdFxuICAgICAgICAgICAgaWYoc3lzdGVtT2JqZWN0U3RyaW5nID09IFwidGFyZ2V0XCIpe1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRQcm9wVmFsdWUgPSBwYXJ0Q29udGV4dC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHBhcnRDb250ZXh0LCBcInRhcmdldFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VtYW50aWNzID0gcGFydENvbnRleHQuX3NlbWFudGljcztcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hPYmplY3QgPSBzeXN0ZW1Db250ZXh0LmdyYW1tYXIubWF0Y2godGFyZ2V0UHJvcFZhbHVlLCAnT2JqZWN0U3BlY2lmaWVyJyk7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldElkID0gc2VtYW50aWNzKG1hdGNoT2JqZWN0KS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYoc3lzdGVtT2JqZWN0U3RyaW5nID09IFwiY3VycmVudCBjYXJkXCIpe1xuICAgICAgICAgICAgICAgIHN5c3RlbU9iamVjdFN0cmluZyA9IFwiY2FyZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpbmFsUGFydCA9IGZpbmRGaXJzdFBvc3NpYmxlQW5jZXN0b3IocGFydENvbnRleHQsIHN5c3RlbU9iamVjdFN0cmluZyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFydGlhbFNwZWNpZmllci5pbnRlcnByZXQoKShmaW5hbFBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICBPYmplY3RTcGVjaWZpZXJfc2luZ2xlVGVybWluYWw6IGZ1bmN0aW9uKHRlcm1pbmFsU3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0ZXJtaW5hbFNwZWNpZmllci5pbnRlcnByZXQoKShwYXJ0Q29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFueUxpdGVyYWw6IGZ1bmN0aW9uKHRoZUxpdGVyYWwpe1xuICAgICAgICAgICAgcmV0dXJuIHRoZUxpdGVyYWwuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyaW5nTGl0ZXJhbDogZnVuY3Rpb24ob3BlblF1b3RlLCB0ZXh0LCBjbG9zZVF1b3RlKXtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnNvdXJjZVN0cmluZztcbiAgICAgICAgfSxcblxuICAgICAgICBib29sZWFuTGl0ZXJhbDogZnVuY3Rpb24odGV4dCl7XG4gICAgICAgICAgICBpZih0ZXh0LnNvdXJjZVN0cmluZyA9PSAndHJ1ZScpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGV4dC5zb3VyY2VTdHJpbmcgPT0gJ2ZhbHNlJyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJvb2xlYW4gbGl0ZXJhbDogJHt0ZXh0fWApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGludGVnZXJMaXRlcmFsOiBmdW5jdGlvbihuZWdhdGl2ZVNpZ24sIGludGVnZXIpe1xuICAgICAgICAgICAgbGV0IGludCA9IHBhcnNlSW50KGludGVnZXIuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgIGxldCBoYXNOZWdhdGl2ZSA9IChuZWdhdGl2ZVNpZ24uc291cmNlU3RyaW5nID09IFwiLVwiKTtcbiAgICAgICAgICAgIGlmKGhhc05lZ2F0aXZlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBpbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50OyBcbiAgICAgICAgfSxcblxuICAgICAgICBmbG9hdExpdGVyYWw6IGZ1bmN0aW9uKG5lZ2F0aXZlU2lnbiwgb25lc1BsYWNlLCBkZWNpbWFsLCByZXN0UGxhY2Upe1xuICAgICAgICAgICAgbGV0IGZsb2F0U3RyaW5nID0gYCR7b25lc1BsYWNlLnNvdXJjZVN0cmluZ30uJHtyZXN0UGxhY2Uuc291cmNlU3RyaW5nfWA7XG4gICAgICAgICAgICBsZXQgaGFzTmVnYXRpdmUgPSAobmVnYXRpdmVTaWduLnNvdXJjZVN0cmluZyA9PSBcIi1cIik7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGbG9hdChmbG9hdFN0cmluZyk7XG4gICAgICAgICAgICBpZihoYXNOZWdhdGl2ZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xICogcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBudW1lcmljYWxLZXl3b3JkOiBmdW5jdGlvbihudW1lcmFsTmFtZSl7XG4gICAgICAgICAgICBzd2l0Y2gobnVtZXJhbE5hbWUuc291cmNlU3RyaW5nKXtcbiAgICAgICAgICAgIGNhc2UgJ2ZpcnN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlICd0aGlyZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICBjYXNlICdmb3VydGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgY2FzZSAnZmlmdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgY2FzZSAnc2l4dGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICAgICAgY2FzZSAnc2V2ZW50aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgICAgICBjYXNlICdlaWdodGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgICAgY2FzZSAnbmludGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgY2FzZSAndGVudGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhcmlhYmxlTmFtZTogZnVuY3Rpb24obGV0dGVyUGx1cywgb3B0aW9uYWxEaWdpdHMpe1xuICAgICAgICAgICAgLy8gTG9va3VwIHRoZSB2YXJpYWJsZSBpbiB0aGUgcGFydCdzXG4gICAgICAgICAgICAvLyBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFyaWFibGUgaXMgbm90IGEga2V5IG9uIHRoZSBvYmplY3QsXG4gICAgICAgICAgICAvLyB3ZSB0aHJvdyBhbiBlcnJvcjogdGhpcyBtZWFucyB0aGUgdmFyaWFibGUgaGFzIG5vdCB5ZXRcbiAgICAgICAgICAgIC8vIGJlZW4gZGVmaW5lZCBidXQgaXMgYmVpbmcgbG9va2VkIHVwLlxuICAgICAgICAgICAgbGV0IHZhbHVlID0gc3lzdGVtQ29udGV4dC5leGVjdXRpb25TdGFjay5jdXJyZW50LmdldCh0aGlzLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTVFZhcmlhYmxlUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBWYXJpYWJsZSAke3RoaXMuc291cmNlU3RyaW5nfSBoYXMgbm90IGJlZW4gZGVmaW5lZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKGRhc2hlc0xpdGVyYWwsIG5vbkxpbmVUZXJtaW5hdG9yQ2hhcnMpe1xuICAgICAgICAgICAgLy8gSW50ZXJwcmV0IGRvZXNuJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgIC8vIHdpdGggY29tbWVudHMuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdGVybWluYWwoKXtcblxuICAgICAgICB9XG4gICAgfTtcbn07XG5cblxuZXhwb3J0IHtcbiAgICBjcmVhdGVJbnRlcnByZXRlclNlbWFudGljcyxcbiAgICBjcmVhdGVJbnRlcnByZXRlclNlbWFudGljcyBhcyBkZWZhdWx0XG59O1xuIiwidmFyIG9obSA9IHJlcXVpcmUoJy4uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG9obS5tYWtlUmVjaXBlKFtcImdyYW1tYXJcIix7XCJzb3VyY2VcIjpcIkJ1aWx0SW5SdWxlcyB7XFxuXFxuICBhbG51bSAgKGFuIGFscGhhLW51bWVyaWMgY2hhcmFjdGVyKVxcbiAgICA9IGxldHRlclxcbiAgICB8IGRpZ2l0XFxuXFxuICBsZXR0ZXIgIChhIGxldHRlcilcXG4gICAgPSBsb3dlclxcbiAgICB8IHVwcGVyXFxuICAgIHwgdW5pY29kZUx0bW9cXG5cXG4gIGRpZ2l0ICAoYSBkaWdpdClcXG4gICAgPSBcXFwiMFxcXCIuLlxcXCI5XFxcIlxcblxcbiAgaGV4RGlnaXQgIChhIGhleGFkZWNpbWFsIGRpZ2l0KVxcbiAgICA9IGRpZ2l0XFxuICAgIHwgXFxcImFcXFwiLi5cXFwiZlxcXCJcXG4gICAgfCBcXFwiQVxcXCIuLlxcXCJGXFxcIlxcblxcbiAgTGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgPSBOb25lbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgIHwgRW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcblxcbiAgTm9uZW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IGVsZW0gKHNlcCBlbGVtKSpcXG5cXG4gIEVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgPSAvKiBub3RoaW5nICovXFxuXFxuICBsaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IG5vbmVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgfCBlbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuXFxuICBub25lbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gZWxlbSAoc2VwIGVsZW0pKlxcblxcbiAgZW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IC8qIG5vdGhpbmcgKi9cXG5cXG59XCJ9LFwiQnVpbHRJblJ1bGVzXCIsbnVsbCxudWxsLHtcImFsbnVtXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTgsNzhdfSxcImFuIGFscGhhLW51bWVyaWMgY2hhcmFjdGVyXCIsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjAsNzhdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MCw2Nl19LFwibGV0dGVyXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzczLDc4XX0sXCJkaWdpdFwiLFtdXV1dLFwibGV0dGVyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODIsMTQyXX0sXCJhIGxldHRlclwiLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNywxNDJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDcsMTEyXX0sXCJsb3dlclwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTksMTI0XX0sXCJ1cHBlclwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEsMTQyXX0sXCJ1bmljb2RlTHRtb1wiLFtdXV1dLFwiZGlnaXRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDYsMTc3XX0sXCJhIGRpZ2l0XCIsW10sW1wicmFuZ2VcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjksMTc3XX0sXCIwXCIsXCI5XCJdXSxcImhleERpZ2l0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTgxLDI1NF19LFwiYSBoZXhhZGVjaW1hbCBkaWdpdFwiLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxOSwyNTRdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTksMjI0XX0sXCJkaWdpdFwiLFtdXSxbXCJyYW5nZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMSwyMzldfSxcImFcIixcImZcIl0sW1wicmFuZ2VcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDYsMjU0XX0sXCJBXCIsXCJGXCJdXV0sXCJMaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTgsMzM2XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjgyLDMzNl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI4MiwzMDddfSxcIk5vbmVtcHR5TGlzdE9mXCIsW1tcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjk3LDMwMV19LDBdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzAzLDMwNl19LDFdXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzE0LDMzNl19LFwiRW1wdHlMaXN0T2ZcIixbW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMjYsMzMwXX0sMF0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMzIsMzM1XX0sMV1dXV1dLFwiTm9uZW1wdHlMaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNDAsMzg4XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzcyLDM4OF19LFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzcyLDM3Nl19LDBdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNzcsMzg4XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzc4LDM4Nl19LFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzc4LDM4MV19LDFdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzgyLDM4Nl19LDBdXV1dXSxcIkVtcHR5TGlzdE9mXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzkyLDQzNF19LG51bGwsW1wiZWxlbVwiLFwic2VwXCJdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzQzOCw0MzhdfV1dLFwibGlzdE9mXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDM4LDUxNl19LG51bGwsW1wiZWxlbVwiLFwic2VwXCJdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ2Miw1MTZdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NjIsNDg3XX0sXCJub25lbXB0eUxpc3RPZlwiLFtbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ3Nyw0ODFdfSwwXSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ4Myw0ODZdfSwxXV1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ5NCw1MTZdfSxcImVtcHR5TGlzdE9mXCIsW1tcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTA2LDUxMF19LDBdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTEyLDUxNV19LDFdXV1dXSxcIm5vbmVtcHR5TGlzdE9mXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTIwLDU2OF19LG51bGwsW1wiZWxlbVwiLFwic2VwXCJdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU1Miw1NjhdfSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU1Miw1NTZdfSwwXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTU3LDU2OF19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU1OCw1NjZdfSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU1OCw1NjFdfSwxXSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU2Miw1NjZdfSwwXV1dXV0sXCJlbXB0eUxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzU3Miw2MTRdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MTYsNjE2XX1dXX1dKTtcbiIsInZhciBvaG0gPSByZXF1aXJlKCcuLicpO1xubW9kdWxlLmV4cG9ydHMgPSBvaG0ubWFrZVJlY2lwZShbXCJncmFtbWFyXCIse1wic291cmNlXCI6XCJPaG0ge1xcblxcbiAgR3JhbW1hcnNcXG4gICAgPSBHcmFtbWFyKlxcblxcbiAgR3JhbW1hclxcbiAgICA9IGlkZW50IFN1cGVyR3JhbW1hcj8gXFxcIntcXFwiIFJ1bGUqIFxcXCJ9XFxcIlxcblxcbiAgU3VwZXJHcmFtbWFyXFxuICAgID0gXFxcIjw6XFxcIiBpZGVudFxcblxcbiAgUnVsZVxcbiAgICA9IGlkZW50IEZvcm1hbHM/IHJ1bGVEZXNjcj8gXFxcIj1cXFwiICBSdWxlQm9keSAgLS0gZGVmaW5lXFxuICAgIHwgaWRlbnQgRm9ybWFscz8gICAgICAgICAgICBcXFwiOj1cXFwiIE92ZXJyaWRlUnVsZUJvZHkgIC0tIG92ZXJyaWRlXFxuICAgIHwgaWRlbnQgRm9ybWFscz8gICAgICAgICAgICBcXFwiKz1cXFwiIFJ1bGVCb2R5ICAtLSBleHRlbmRcXG5cXG4gIFJ1bGVCb2R5XFxuICAgID0gXFxcInxcXFwiPyBOb25lbXB0eUxpc3RPZjxUb3BMZXZlbFRlcm0sIFxcXCJ8XFxcIj5cXG5cXG4gIFRvcExldmVsVGVybVxcbiAgICA9IFNlcSBjYXNlTmFtZSAgLS0gaW5saW5lXFxuICAgIHwgU2VxXFxuXFxuICBPdmVycmlkZVJ1bGVCb2R5XFxuICAgID0gXFxcInxcXFwiPyBOb25lbXB0eUxpc3RPZjxPdmVycmlkZVRvcExldmVsVGVybSwgXFxcInxcXFwiPlxcblxcbiAgT3ZlcnJpZGVUb3BMZXZlbFRlcm1cXG4gICAgPSBcXFwiLi4uXFxcIiAgLS0gc3VwZXJTcGxpY2VcXG4gICAgfCBUb3BMZXZlbFRlcm1cXG5cXG4gIEZvcm1hbHNcXG4gICAgPSBcXFwiPFxcXCIgTGlzdE9mPGlkZW50LCBcXFwiLFxcXCI+IFxcXCI+XFxcIlxcblxcbiAgUGFyYW1zXFxuICAgID0gXFxcIjxcXFwiIExpc3RPZjxTZXEsIFxcXCIsXFxcIj4gXFxcIj5cXFwiXFxuXFxuICBBbHRcXG4gICAgPSBOb25lbXB0eUxpc3RPZjxTZXEsIFxcXCJ8XFxcIj5cXG5cXG4gIFNlcVxcbiAgICA9IEl0ZXIqXFxuXFxuICBJdGVyXFxuICAgID0gUHJlZCBcXFwiKlxcXCIgIC0tIHN0YXJcXG4gICAgfCBQcmVkIFxcXCIrXFxcIiAgLS0gcGx1c1xcbiAgICB8IFByZWQgXFxcIj9cXFwiICAtLSBvcHRcXG4gICAgfCBQcmVkXFxuXFxuICBQcmVkXFxuICAgID0gXFxcIn5cXFwiIExleCAgLS0gbm90XFxuICAgIHwgXFxcIiZcXFwiIExleCAgLS0gbG9va2FoZWFkXFxuICAgIHwgTGV4XFxuXFxuICBMZXhcXG4gICAgPSBcXFwiI1xcXCIgQmFzZSAgLS0gbGV4XFxuICAgIHwgQmFzZVxcblxcbiAgQmFzZVxcbiAgICA9IGlkZW50IFBhcmFtcz8gfihydWxlRGVzY3I/IFxcXCI9XFxcIiB8IFxcXCI6PVxcXCIgfCBcXFwiKz1cXFwiKSAgLS0gYXBwbGljYXRpb25cXG4gICAgfCBvbmVDaGFyVGVybWluYWwgXFxcIi4uXFxcIiBvbmVDaGFyVGVybWluYWwgICAgICAgICAgIC0tIHJhbmdlXFxuICAgIHwgdGVybWluYWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSB0ZXJtaW5hbFxcbiAgICB8IFxcXCIoXFxcIiBBbHQgXFxcIilcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gcGFyZW5cXG5cXG4gIHJ1bGVEZXNjciAgKGEgcnVsZSBkZXNjcmlwdGlvbilcXG4gICAgPSBcXFwiKFxcXCIgcnVsZURlc2NyVGV4dCBcXFwiKVxcXCJcXG5cXG4gIHJ1bGVEZXNjclRleHRcXG4gICAgPSAoflxcXCIpXFxcIiBhbnkpKlxcblxcbiAgY2FzZU5hbWVcXG4gICAgPSBcXFwiLS1cXFwiICh+XFxcIlxcXFxuXFxcIiBzcGFjZSkqIG5hbWUgKH5cXFwiXFxcXG5cXFwiIHNwYWNlKSogKFxcXCJcXFxcblxcXCIgfCAmXFxcIn1cXFwiKVxcblxcbiAgbmFtZSAgKGEgbmFtZSlcXG4gICAgPSBuYW1lRmlyc3QgbmFtZVJlc3QqXFxuXFxuICBuYW1lRmlyc3RcXG4gICAgPSBcXFwiX1xcXCJcXG4gICAgfCBsZXR0ZXJcXG5cXG4gIG5hbWVSZXN0XFxuICAgID0gXFxcIl9cXFwiXFxuICAgIHwgYWxudW1cXG5cXG4gIGlkZW50ICAoYW4gaWRlbnRpZmllcilcXG4gICAgPSBuYW1lXFxuXFxuICB0ZXJtaW5hbFxcbiAgICA9IFxcXCJcXFxcXFxcIlxcXCIgdGVybWluYWxDaGFyKiBcXFwiXFxcXFxcXCJcXFwiXFxuXFxuICBvbmVDaGFyVGVybWluYWxcXG4gICAgPSBcXFwiXFxcXFxcXCJcXFwiIHRlcm1pbmFsQ2hhciBcXFwiXFxcXFxcXCJcXFwiXFxuXFxuICB0ZXJtaW5hbENoYXJcXG4gICAgPSBlc2NhcGVDaGFyXFxuICAgIHwgflxcXCJcXFxcXFxcXFxcXCIgflxcXCJcXFxcXFxcIlxcXCIgflxcXCJcXFxcblxcXCIgYW55XFxuXFxuICBlc2NhcGVDaGFyICAoYW4gZXNjYXBlIHNlcXVlbmNlKVxcbiAgICA9IFxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBiYWNrc2xhc2hcXG4gICAgfCBcXFwiXFxcXFxcXFxcXFxcXFxcIlxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gZG91YmxlUXVvdGVcXG4gICAgfCBcXFwiXFxcXFxcXFxcXFxcJ1xcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gc2luZ2xlUXVvdGVcXG4gICAgfCBcXFwiXFxcXFxcXFxiXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gYmFja3NwYWNlXFxuICAgIHwgXFxcIlxcXFxcXFxcblxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIGxpbmVGZWVkXFxuICAgIHwgXFxcIlxcXFxcXFxcclxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIGNhcnJpYWdlUmV0dXJuXFxuICAgIHwgXFxcIlxcXFxcXFxcdFxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIHRhYlxcbiAgICB8IFxcXCJcXFxcXFxcXHVcXFwiIGhleERpZ2l0IGhleERpZ2l0IGhleERpZ2l0IGhleERpZ2l0ICAtLSB1bmljb2RlRXNjYXBlXFxuICAgIHwgXFxcIlxcXFxcXFxceFxcXCIgaGV4RGlnaXQgaGV4RGlnaXQgICAgICAgICAgICAgICAgICAgIC0tIGhleEVzY2FwZVxcblxcbiAgc3BhY2VcXG4gICArPSBjb21tZW50XFxuXFxuICBjb21tZW50XFxuICAgID0gXFxcIi8vXFxcIiAoflxcXCJcXFxcblxcXCIgYW55KSogJihcXFwiXFxcXG5cXFwiIHwgZW5kKSAgLS0gc2luZ2xlTGluZVxcbiAgICB8IFxcXCIvKlxcXCIgKH5cXFwiKi9cXFwiIGFueSkqIFxcXCIqL1xcXCIgIC0tIG11bHRpTGluZVxcblxcbiAgdG9rZW5zID0gdG9rZW4qXFxuXFxuICB0b2tlbiA9IGNhc2VOYW1lIHwgY29tbWVudCB8IGlkZW50IHwgb3BlcmF0b3IgfCBwdW5jdHVhdGlvbiB8IHRlcm1pbmFsIHwgYW55XFxuXFxuICBvcGVyYXRvciA9IFxcXCI8OlxcXCIgfCBcXFwiPVxcXCIgfCBcXFwiOj1cXFwiIHwgXFxcIis9XFxcIiB8IFxcXCIqXFxcIiB8IFxcXCIrXFxcIiB8IFxcXCI/XFxcIiB8IFxcXCJ+XFxcIiB8IFxcXCImXFxcIlxcblxcbiAgcHVuY3R1YXRpb24gPSBcXFwiPFxcXCIgfCBcXFwiPlxcXCIgfCBcXFwiLFxcXCIgfCBcXFwiLS1cXFwiXFxufVwifSxcIk9obVwiLG51bGwsXCJHcmFtbWFyc1wiLHtcIkdyYW1tYXJzXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOSwzMl19LG51bGwsW10sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0LDMyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQsMzFdfSxcIkdyYW1tYXJcIixbXV1dXSxcIkdyYW1tYXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNiw4M119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTAsODNdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MCw1NV19LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTYsNjldfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1Niw2OF19LFwiU3VwZXJHcmFtbWFyXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzcwLDczXX0sXCJ7XCJdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NCw3OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0LDc4XX0sXCJSdWxlXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgwLDgzXX0sXCJ9XCJdXV0sXCJTdXBlckdyYW1tYXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NywxMTZdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNiwxMTZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNiwxMTBdfSxcIjw6XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMSwxMTZdfSxcImlkZW50XCIsW11dXV0sXCJSdWxlX2RlZmluZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwxODFdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwxNzBdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEsMTM2XX0sXCJpZGVudFwiLFtdXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzcsMTQ1XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM3LDE0NF19LFwiRm9ybWFsc1wiLFtdXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ2LDE1Nl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NiwxNTVdfSxcInJ1bGVEZXNjclwiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTcsMTYwXX0sXCI9XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MiwxNzBdfSxcIlJ1bGVCb2R5XCIsW11dXV0sXCJSdWxlX292ZXJyaWRlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg4LDI0OF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg4LDIzNV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4OCwxOTNdfSxcImlkZW50XCIsW11dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5NCwyMDJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTQsMjAxXX0sXCJGb3JtYWxzXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxNCwyMThdfSxcIjo9XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxOSwyMzVdfSxcIk92ZXJyaWRlUnVsZUJvZHlcIixbXV1dXSxcIlJ1bGVfZXh0ZW5kXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU1LDMwNV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU1LDI5NF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NSwyNjBdfSxcImlkZW50XCIsW11dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI2MSwyNjldfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNjEsMjY4XX0sXCJGb3JtYWxzXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI4MSwyODVdfSxcIis9XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI4NiwyOTRdfSxcIlJ1bGVCb2R5XCIsW11dXV0sXCJSdWxlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIwLDMwNV19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDMwNV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwxNzBdfSxcIlJ1bGVfZGVmaW5lXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4OCwyMzVdfSxcIlJ1bGVfb3ZlcnJpZGVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU1LDI5NF19LFwiUnVsZV9leHRlbmRcIixbXV1dXSxcIlJ1bGVCb2R5XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzA5LDM2Ml19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI0LDM2Ml19LFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzMyNCwzMjhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzMyNCwzMjddfSxcInxcIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzMyOSwzNjJdfSxcIk5vbmVtcHR5TGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM0NCwzNTZdfSxcIlRvcExldmVsVGVybVwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM1OCwzNjFdfSxcInxcIl1dXV1dLFwiVG9wTGV2ZWxUZXJtX2lubGluZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4NSw0MDhdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4NSwzOTddfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODUsMzg4XX0sXCJTZXFcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg5LDM5N119LFwiY2FzZU5hbWVcIixbXV1dXSxcIlRvcExldmVsVGVybVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM2Niw0MThdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4NSw0MThdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODUsMzk3XX0sXCJUb3BMZXZlbFRlcm1faW5saW5lXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQxNSw0MThdfSxcIlNlcVwiLFtdXV1dLFwiT3ZlcnJpZGVSdWxlQm9keVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzQyMiw0OTFdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ0NSw0OTFdfSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NDUsNDQ5XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NDUsNDQ4XX0sXCJ8XCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NTAsNDkxXX0sXCJOb25lbXB0eUxpc3RPZlwiLFtbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NjUsNDg1XX0sXCJPdmVycmlkZVRvcExldmVsVGVybVwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ4Nyw0OTBdfSxcInxcIl1dXV1dLFwiT3ZlcnJpZGVUb3BMZXZlbFRlcm1fc3VwZXJTcGxpY2VcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MjIsNTQzXX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzUyMiw1MjddfSxcIi4uLlwiXV0sXCJPdmVycmlkZVRvcExldmVsVGVybVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzQ5NSw1NjJdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzUyMiw1NjJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MjIsNTI3XX0sXCJPdmVycmlkZVRvcExldmVsVGVybV9zdXBlclNwbGljZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NTAsNTYyXX0sXCJUb3BMZXZlbFRlcm1cIixbXV1dXSxcIkZvcm1hbHNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NjYsNjA2XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1ODAsNjA2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1ODAsNTgzXX0sXCI8XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU4NCw2MDJdfSxcIkxpc3RPZlwiLFtbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1OTEsNTk2XX0sXCJpZGVudFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU5OCw2MDFdfSxcIixcIl1dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYwMyw2MDZdfSxcIj5cIl1dXSxcIlBhcmFtc1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzYxMCw2NDddfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzYyMyw2NDddfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYyMyw2MjZdfSxcIjxcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjI3LDY0M119LFwiTGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYzNCw2MzddfSxcIlNlcVwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYzOSw2NDJdfSxcIixcIl1dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzY0NCw2NDddfSxcIj5cIl1dXSxcIkFsdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzY1MSw2ODVdfSxudWxsLFtdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzY2MSw2ODVdfSxcIk5vbmVtcHR5TGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzY3Niw2NzldfSxcIlNlcVwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzY4MSw2ODRdfSxcInxcIl1dXV0sXCJTZXFcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2ODksNzA0XX0sbnVsbCxbXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjk5LDcwNF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzY5OSw3MDNdfSxcIkl0ZXJcIixbXV1dXSxcIkl0ZXJfc3RhclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzcxOSw3MzZdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzcxOSw3MjddfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MTksNzIzXX0sXCJQcmVkXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzI0LDcyN119LFwiKlwiXV1dLFwiSXRlcl9wbHVzXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQzLDc2MF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQzLDc1MV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0Myw3NDddfSxcIlByZWRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDgsNzUxXX0sXCIrXCJdXV0sXCJJdGVyX29wdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc2Nyw3ODNdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc2Nyw3NzVdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NjcsNzcxXX0sXCJQcmVkXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzcyLDc3NV19LFwiP1wiXV1dLFwiSXRlclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzcwOCw3OTRdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzcxOSw3OTRdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MTksNzI3XX0sXCJJdGVyX3N0YXJcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQzLDc1MV19LFwiSXRlcl9wbHVzXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc2Nyw3NzVdfSxcIkl0ZXJfb3B0XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc5MCw3OTRdfSxcIlByZWRcIixbXV1dXSxcIlByZWRfbm90XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODA5LDgyNF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODA5LDgxNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODA5LDgxMl19LFwiflwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MTMsODE2XX0sXCJMZXhcIixbXV1dXSxcIlByZWRfbG9va2FoZWFkXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODMxLDg1Ml19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODMxLDgzOF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODMxLDgzNF19LFwiJlwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MzUsODM4XX0sXCJMZXhcIixbXV1dXSxcIlByZWRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3OTgsODYyXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MDksODYyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODA5LDgxNl19LFwiUHJlZF9ub3RcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODMxLDgzOF19LFwiUHJlZF9sb29rYWhlYWRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODU5LDg2Ml19LFwiTGV4XCIsW11dXV0sXCJMZXhfbGV4XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODc2LDg5Ml19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODc2LDg4NF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODc2LDg3OV19LFwiI1wiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4ODAsODg0XX0sXCJCYXNlXCIsW11dXV0sXCJMZXhcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NjYsOTAzXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NzYsOTAzXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODc2LDg4NF19LFwiTGV4X2xleFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4OTksOTAzXX0sXCJCYXNlXCIsW11dXV0sXCJCYXNlX2FwcGxpY2F0aW9uXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTE4LDk3OV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTE4LDk2M119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkxOCw5MjNdfSxcImlkZW50XCIsW11dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkyNCw5MzFdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MjQsOTMwXX0sXCJQYXJhbXNcIixbXV1dLFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkzMiw5NjNdfSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MzQsOTYyXX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTM0LDk0OF19LFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkzNCw5NDRdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MzQsOTQzXX0sXCJydWxlRGVzY3JcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTQ1LDk0OF19LFwiPVwiXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5NTEsOTU1XX0sXCI6PVwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk1OCw5NjJdfSxcIis9XCJdXV1dXSxcIkJhc2VfcmFuZ2VcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5ODYsMTA0MV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTg2LDEwMjJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5ODYsMTAwMV19LFwib25lQ2hhclRlcm1pbmFsXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTAwMiwxMDA2XX0sXCIuLlwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDA3LDEwMjJdfSxcIm9uZUNoYXJUZXJtaW5hbFwiLFtdXV1dLFwiQmFzZV90ZXJtaW5hbFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNDgsMTEwNl19LG51bGwsW10sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA0OCwxMDU2XX0sXCJ0ZXJtaW5hbFwiLFtdXV0sXCJCYXNlX3BhcmVuXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExMywxMTY4XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTEzLDExMjRdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMTMsMTExNl19LFwiKFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTE3LDExMjBdfSxcIkFsdFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMjEsMTEyNF19LFwiKVwiXV1dLFwiQmFzZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzkwNywxMTY4XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MTgsMTE2OF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkxOCw5NjNdfSxcIkJhc2VfYXBwbGljYXRpb25cIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTg2LDEwMjJdfSxcIkJhc2VfcmFuZ2VcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA0OCwxMDU2XX0sXCJCYXNlX3Rlcm1pbmFsXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMTMsMTEyNF19LFwiQmFzZV9wYXJlblwiLFtdXV1dLFwicnVsZURlc2NyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTE3MiwxMjMxXX0sXCJhIHJ1bGUgZGVzY3JpcHRpb25cIixbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjEwLDEyMzFdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMTAsMTIxM119LFwiKFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjE0LDEyMjddfSxcInJ1bGVEZXNjclRleHRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjI4LDEyMzFdfSxcIilcIl1dXSxcInJ1bGVEZXNjclRleHRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjM1LDEyNjZdfSxudWxsLFtdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjU1LDEyNjZdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjU2LDEyNjRdfSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjU2LDEyNjBdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNTcsMTI2MF19LFwiKVwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI2MSwxMjY0XX0sXCJhbnlcIixbXV1dXV0sXCJjYXNlTmFtZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNzAsMTMzOF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI4NSwxMzM4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjg1LDEyODldfSxcIi0tXCJdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjkwLDEzMDRdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjkxLDEzMDJdfSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjkxLDEyOTZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOTIsMTI5Nl19LFwiXFxuXCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjk3LDEzMDJdfSxcInNwYWNlXCIsW11dXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMwNSwxMzA5XX0sXCJuYW1lXCIsW11dLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEwLDEzMjRdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzExLDEzMjJdfSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzExLDEzMTZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMTIsMTMxNl19LFwiXFxuXCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzE3LDEzMjJdfSxcInNwYWNlXCIsW11dXV0sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMyNiwxMzM3XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzI2LDEzMzBdfSxcIlxcblwiXSxbXCJsb29rYWhlYWRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzMzLDEzMzddfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMzQsMTMzN119LFwifVwiXV1dXV0sXCJuYW1lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM0MiwxMzgyXX0sXCJhIG5hbWVcIixbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzYzLDEzODJdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzYzLDEzNzJdfSxcIm5hbWVGaXJzdFwiLFtdXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM3MywxMzgyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM3MywxMzgxXX0sXCJuYW1lUmVzdFwiLFtdXV1dXSxcIm5hbWVGaXJzdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzODYsMTQxOF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQwMiwxNDE4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDAyLDE0MDVdfSxcIl9cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQxMiwxNDE4XX0sXCJsZXR0ZXJcIixbXV1dXSxcIm5hbWVSZXN0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQyMiwxNDUyXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDM3LDE0NTJdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MzcsMTQ0MF19LFwiX1wiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDQ3LDE0NTJdfSxcImFsbnVtXCIsW11dXV0sXCJpZGVudFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NTYsMTQ4OV19LFwiYW4gaWRlbnRpZmllclwiLFtdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0ODUsMTQ4OV19LFwibmFtZVwiLFtdXV0sXCJ0ZXJtaW5hbFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0OTMsMTUzMV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUwOCwxNTMxXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTA4LDE1MTJdfSxcIlxcXCJcIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1MTMsMTUyNl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1MTMsMTUyNV19LFwidGVybWluYWxDaGFyXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1MjcsMTUzMV19LFwiXFxcIlwiXV1dLFwib25lQ2hhclRlcm1pbmFsXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUzNSwxNTc5XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTU3LDE1NzldfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NTcsMTU2MV19LFwiXFxcIlwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTYyLDE1NzRdfSxcInRlcm1pbmFsQ2hhclwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1NzUsMTU3OV19LFwiXFxcIlwiXV1dLFwidGVybWluYWxDaGFyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU4MywxNjQwXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjAyLDE2NDBdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjAyLDE2MTJdfSxcImVzY2FwZUNoYXJcIixbXV0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYxOSwxNjQwXX0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYxOSwxNjI0XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjIwLDE2MjRdfSxcIlxcXFxcIl1dLFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MjUsMTYzMF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYyNiwxNjMwXX0sXCJcXFwiXCJdXSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjMxLDE2MzZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MzIsMTYzNl19LFwiXFxuXCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjM3LDE2NDBdfSxcImFueVwiLFtdXV1dXSxcImVzY2FwZUNoYXJfYmFja3NsYXNoXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4MywxNzM4XX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2ODMsMTY4OV19LFwiXFxcXFxcXFxcIl1dLFwiZXNjYXBlQ2hhcl9kb3VibGVRdW90ZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE3NDUsMTgwMl19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNzQ1LDE3NTFdfSxcIlxcXFxcXFwiXCJdXSxcImVzY2FwZUNoYXJfc2luZ2xlUXVvdGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODA5LDE4NjZdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTgwOSwxODE1XX0sXCJcXFxcJ1wiXV0sXCJlc2NhcGVDaGFyX2JhY2tzcGFjZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4NzMsMTkyOF19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODczLDE4NzhdfSxcIlxcXFxiXCJdXSxcImVzY2FwZUNoYXJfbGluZUZlZWRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTM1LDE5ODldfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTkzNSwxOTQwXX0sXCJcXFxcblwiXV0sXCJlc2NhcGVDaGFyX2NhcnJpYWdlUmV0dXJuXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk5NiwyMDU2XX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5OTYsMjAwMV19LFwiXFxcXHJcIl1dLFwiZXNjYXBlQ2hhcl90YWJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDYzLDIxMTJdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjA2MywyMDY4XX0sXCJcXFxcdFwiXV0sXCJlc2NhcGVDaGFyX3VuaWNvZGVFc2NhcGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTE5LDIxNzhdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMTksMjE2MF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjExOSwyMTI0XX0sXCJcXFxcdVwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTI1LDIxMzNdfSxcImhleERpZ2l0XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMzQsMjE0Ml19LFwiaGV4RGlnaXRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE0MywyMTUxXX0sXCJoZXhEaWdpdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTUyLDIxNjBdfSxcImhleERpZ2l0XCIsW11dXV0sXCJlc2NhcGVDaGFyX2hleEVzY2FwZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxODUsMjI0MF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE4NSwyMjA4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTg1LDIxOTBdfSxcIlxcXFx4XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxOTEsMjE5OV19LFwiaGV4RGlnaXRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjIwMCwyMjA4XX0sXCJoZXhEaWdpdFwiLFtdXV1dLFwiZXNjYXBlQ2hhclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2NDQsMjI0MF19LFwiYW4gZXNjYXBlIHNlcXVlbmNlXCIsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4MywyMjQwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4MywxNjg5XX0sXCJlc2NhcGVDaGFyX2JhY2tzbGFzaFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNzQ1LDE3NTFdfSxcImVzY2FwZUNoYXJfZG91YmxlUXVvdGVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTgwOSwxODE1XX0sXCJlc2NhcGVDaGFyX3NpbmdsZVF1b3RlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4NzMsMTg3OF19LFwiZXNjYXBlQ2hhcl9iYWNrc3BhY2VcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTkzNSwxOTQwXX0sXCJlc2NhcGVDaGFyX2xpbmVGZWVkXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5OTYsMjAwMV19LFwiZXNjYXBlQ2hhcl9jYXJyaWFnZVJldHVyblwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMDYzLDIwNjhdfSxcImVzY2FwZUNoYXJfdGFiXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMTksMjE2MF19LFwiZXNjYXBlQ2hhcl91bmljb2RlRXNjYXBlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxODUsMjIwOF19LFwiZXNjYXBlQ2hhcl9oZXhFc2NhcGVcIixbXV1dXSxcInNwYWNlXCI6W1wiZXh0ZW5kXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI0NCwyMjYzXX0sbnVsbCxbXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjU2LDIyNjNdfSxcImNvbW1lbnRcIixbXV1dLFwiY29tbWVudF9zaW5nbGVMaW5lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4MSwyMzI3XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjgxLDIzMTJdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjI4NV19LFwiLy9cIl0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODYsMjI5OF19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODcsMjI5Nl19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODcsMjI5Ml19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4OCwyMjkyXX0sXCJcXG5cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyOTMsMjI5Nl19LFwiYW55XCIsW11dXV0sW1wibG9va2FoZWFkXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI5OSwyMzEyXX0sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMwMSwyMzExXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzAxLDIzMDVdfSxcIlxcblwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzA4LDIzMTFdfSxcImVuZFwiLFtdXV1dXV0sXCJjb21tZW50X211bHRpTGluZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzQsMjM3MF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMzNCwyMzU2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzM0LDIzMzhdfSxcIi8qXCJdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzM5LDIzNTFdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzQwLDIzNDldfSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzQwLDIzNDVdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNDEsMjM0NV19LFwiKi9cIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzNDYsMjM0OV19LFwiYW55XCIsW11dXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzUyLDIzNTZdfSxcIiovXCJdXV0sXCJjb21tZW50XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI2NywyMzcwXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjgxLDIzNzBdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjgxLDIzMTJdfSxcImNvbW1lbnRfc2luZ2xlTGluZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzM0LDIzNTZdfSxcImNvbW1lbnRfbXVsdGlMaW5lXCIsW11dXV0sXCJ0b2tlbnNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzc0LDIzODldfSxudWxsLFtdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzgzLDIzODldfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzgzLDIzODhdfSxcInRva2VuXCIsW11dXV0sXCJ0b2tlblwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzOTMsMjQ2OV19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQwMSwyNDY5XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQwMSwyNDA5XX0sXCJjYXNlTmFtZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDEyLDI0MTldfSxcImNvbW1lbnRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQyMiwyNDI3XX0sXCJpZGVudFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDMwLDI0MzhdfSxcIm9wZXJhdG9yXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NDEsMjQ1Ml19LFwicHVuY3R1YXRpb25cIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ1NSwyNDYzXX0sXCJ0ZXJtaW5hbFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDY2LDI0NjldfSxcImFueVwiLFtdXV1dLFwib3BlcmF0b3JcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDczLDI1MzhdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0ODQsMjUzOF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ4NCwyNDg4XX0sXCI8OlwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0OTEsMjQ5NF19LFwiPVwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0OTcsMjUwMV19LFwiOj1cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTA0LDI1MDhdfSxcIis9XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjUxMSwyNTE0XX0sXCIqXCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjUxNywyNTIwXX0sXCIrXCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjUyMywyNTI2XX0sXCI/XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjUyOSwyNTMyXX0sXCJ+XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjUzNSwyNTM4XX0sXCImXCJdXV0sXCJwdW5jdHVhdGlvblwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NDIsMjU3OF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU1NiwyNTc4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTU2LDI1NTldfSxcIjxcIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTYyLDI1NjVdfSxcIj5cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTY4LDI1NzFdfSxcIixcIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTc0LDI1NzhdfSxcIi0tXCJdXV19XSk7XG4iLCJ2YXIgb2htID0gcmVxdWlyZSgnLi4nKTtcbm1vZHVsZS5leHBvcnRzID0gb2htLm1ha2VSZWNpcGUoW1wiZ3JhbW1hclwiLHtcInNvdXJjZVwiOlwiT3BlcmF0aW9uc0FuZEF0dHJpYnV0ZXMge1xcblxcbiAgQXR0cmlidXRlU2lnbmF0dXJlID1cXG4gICAgbmFtZVxcblxcbiAgT3BlcmF0aW9uU2lnbmF0dXJlID1cXG4gICAgbmFtZSBGb3JtYWxzP1xcblxcbiAgRm9ybWFsc1xcbiAgICA9IFxcXCIoXFxcIiBMaXN0T2Y8bmFtZSwgXFxcIixcXFwiPiBcXFwiKVxcXCJcXG5cXG4gIG5hbWUgIChhIG5hbWUpXFxuICAgID0gbmFtZUZpcnN0IG5hbWVSZXN0KlxcblxcbiAgbmFtZUZpcnN0XFxuICAgID0gXFxcIl9cXFwiXFxuICAgIHwgbGV0dGVyXFxuXFxuICBuYW1lUmVzdFxcbiAgICA9IFxcXCJfXFxcIlxcbiAgICB8IGFsbnVtXFxuXFxufVwifSxcIk9wZXJhdGlvbnNBbmRBdHRyaWJ1dGVzXCIsbnVsbCxcIkF0dHJpYnV0ZVNpZ25hdHVyZVwiLHtcIkF0dHJpYnV0ZVNpZ25hdHVyZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI5LDU4XX0sbnVsbCxbXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NCw1OF19LFwibmFtZVwiLFtdXV0sXCJPcGVyYXRpb25TaWduYXR1cmVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MiwxMDBdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3LDEwMF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3LDkxXX0sXCJuYW1lXCIsW11dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkyLDEwMF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzkyLDk5XX0sXCJGb3JtYWxzXCIsW11dXV1dLFwiRm9ybWFsc1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNCwxNDNdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzExOCwxNDNdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzExOCwxMjFdfSxcIihcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIyLDEzOV19LFwiTGlzdE9mXCIsW1tcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyOSwxMzNdfSxcIm5hbWVcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzUsMTM4XX0sXCIsXCJdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDAsMTQzXX0sXCIpXCJdXV0sXCJuYW1lXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ3LDE4N119LFwiYSBuYW1lXCIsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY4LDE4N119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2OCwxNzddfSxcIm5hbWVGaXJzdFwiLFtdXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTc4LDE4N119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE3OCwxODZdfSxcIm5hbWVSZXN0XCIsW11dXV1dLFwibmFtZUZpcnN0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTkxLDIyM119LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjA3LDIyM119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjA3LDIxMF19LFwiX1wiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTcsMjIzXX0sXCJsZXR0ZXJcIixbXV1dXSxcIm5hbWVSZXN0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI3LDI1N119LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQyLDI1N119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQyLDI0NV19LFwiX1wiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTIsMjU3XX0sXCJhbG51bVwiLFtdXV1dfV0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vc3JjL2NvbW1vbicpLmFzc2VydDtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEhlbHBlcnNcblxuZnVuY3Rpb24gZ2V0UHJvcChuYW1lLCB0aGluZywgZm4pIHtcbiAgcmV0dXJuIGZuKHRoaW5nW25hbWVdKTtcbn1cblxuZnVuY3Rpb24gbWFwUHJvcChuYW1lLCB0aGluZywgZm4pIHtcbiAgcmV0dXJuIHRoaW5nW25hbWVdLm1hcChmbik7XG59XG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgd2FsayBhIHNpbmdsZSBwcm9wZXJ0eSBvZiBhIG5vZGUuXG4vLyBgZGVzY3JpcHRvcmAgaXMgYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgcHJvcGVydHkgbmFtZSwgb3B0aW9uYWxseSBlbmRpbmdcbi8vIHdpdGggJ1tdJyAoZS5nLiwgJ2NoaWxkcmVuW10nKS5cbmZ1bmN0aW9uIGdldFByb3BXYWxrRm4oZGVzY3JpcHRvcikge1xuICBjb25zdCBwYXJ0cyA9IGRlc2NyaXB0b3Iuc3BsaXQoLyA/XFxbXFxdLyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gbWFwUHJvcC5iaW5kKG51bGwsIHBhcnRzWzBdKTtcbiAgfVxuICByZXR1cm4gZ2V0UHJvcC5iaW5kKG51bGwsIGRlc2NyaXB0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wcyh3YWxrRm5zLCB0aGluZywgZm4pIHtcbiAgcmV0dXJuIHdhbGtGbnMubWFwKHdhbGtGbiA9PiB3YWxrRm4odGhpbmcsIGZuKSk7XG59XG5cbmZ1bmN0aW9uIGdldFdhbGtGbihzaGFwZSkge1xuICBpZiAodHlwZW9mIHNoYXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZXRQcm9wcy5iaW5kKG51bGwsIFtnZXRQcm9wV2Fsa0ZuKHNoYXBlKV0pO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2hhcGUpKSB7XG4gICAgcmV0dXJuIGdldFByb3BzLmJpbmQobnVsbCwgc2hhcGUubWFwKGdldFByb3BXYWxrRm4pKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQodHlwZW9mIHNoYXBlID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgYSBzdHJpbmcsIEFycmF5LCBvciBmdW5jdGlvbicpO1xuICAgIGFzc2VydChzaGFwZS5sZW5ndGggPT09IDIsICdFeHBlY3RlZCBhIGZ1bmN0aW9uIG9mIGFyaXR5IDIsIGdvdCAnICsgc2hhcGUubGVuZ3RoKTtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNSZXN0cmljdGVkSWRlbnRpZmllcihzdHIpIHtcbiAgcmV0dXJuIC9eW2EtekEtWl9dWzAtOWEtekEtWl9dKiQvLnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gdHJpbShzKSB7XG4gIHJldHVybiBzLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUoc2lnKSB7XG4gIGNvbnN0IHBhcnRzID0gc2lnLnNwbGl0KC9bKCldLykubWFwKHRyaW0pO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAzICYmIHBhcnRzWzJdID09PSAnJykge1xuICAgIGNvbnN0IG5hbWUgPSBwYXJ0c1swXTtcbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgaWYgKHBhcnRzWzFdLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcmFtcyA9IHBhcnRzWzFdLnNwbGl0KCcsJykubWFwKHRyaW0pO1xuICAgIH1cbiAgICBpZiAoaXNSZXN0cmljdGVkSWRlbnRpZmllcihuYW1lKSAmJiBwYXJhbXMuZXZlcnkoaXNSZXN0cmljdGVkSWRlbnRpZmllcikpIHtcbiAgICAgIHJldHVybiB7bmFtZSwgZm9ybWFsczogcGFyYW1zfTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhdGlvbiBzaWduYXR1cmU6ICcgKyBzaWcpO1xufVxuXG4vKlxuICBBIFZpc2l0b3JGYW1pbHkgY29udGFpbnMgYSBzZXQgb2YgcmVjdXJzaXZlIG9wZXJhdGlvbnMgdGhhdCBhcmUgZGVmaW5lZCBvdmVyIHNvbWUga2luZCBvZlxuICB0cmVlIHN0cnVjdHVyZS4gVGhlIGBjb25maWdgIHBhcmFtZXRlciBzcGVjaWZpZXMgaG93IHRvIHdhbGsgdGhlIHRyZWU6XG4gIC0gJ2dldFRhZycgaXMgZnVuY3Rpb24gd2hpY2gsIGdpdmVuIGEgbm9kZSBpbiB0aGUgdHJlZSwgcmV0dXJucyB0aGUgbm9kZSdzICd0YWcnICh0eXBlKVxuICAtICdzaGFwZXMnIGFuIG9iamVjdCB0aGF0IG1hcHMgZnJvbSBhIHRhZyB0byBhIHZhbHVlIHRoYXQgZGVzY3JpYmVzIGhvdyB0byByZWN1cnNpdmVseVxuICAgIGV2YWx1YXRlIHRoZSBvcGVyYXRpb24gZm9yIG5vZGVzIG9mIHRoYXQgdHlwZS4gVGhlIHZhbHVlIGNhbiBiZTpcbiAgICAqIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHByb3BlcnR5IG5hbWUgdGhhdCBob2xkcyB0aGF0IG5vZGUncyBvbmx5IGNoaWxkXG4gICAgKiBhbiBBcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyAob3IgYW4gZW1wdHkgYXJyYXkgaW5kaWNhdGluZyBhIGxlYWYgdHlwZSksIG9yXG4gICAgKiBhIGZ1bmN0aW9uIHRha2luZyB0d28gYXJndW1lbnRzIChub2RlLCBmbiksIGFuZCByZXR1cm5pbmcgYW4gQXJyYXkgd2hpY2ggaXMgdGhlIHJlc3VsdFxuICAgICAgb2YgYXBwbHkgYGZuYCB0byBlYWNoIG9mIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIFZpc2l0b3JGYW1pbHkoY29uZmlnKSB7XG4gIHRoaXMuX3NoYXBlcyA9IGNvbmZpZy5zaGFwZXM7XG4gIHRoaXMuX2dldFRhZyA9IGNvbmZpZy5nZXRUYWc7XG5cbiAgdGhpcy5BZGFwdGVyID0gZnVuY3Rpb24odGhpbmcsIGZhbWlseSkge1xuICAgIHRoaXMuX2FkYXB0ZWUgPSB0aGluZztcbiAgICB0aGlzLl9mYW1pbHkgPSBmYW1pbHk7XG4gIH07XG4gIHRoaXMuQWRhcHRlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaGVlZXkhJyk7XG4gIH07XG4gIHRoaXMub3BlcmF0aW9ucyA9IHt9O1xuXG4gIHRoaXMuX2FyaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9nZXRDaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIE9iamVjdC5rZXlzKHRoaXMuX3NoYXBlcykuZm9yRWFjaChrID0+IHtcbiAgICBjb25zdCBzaGFwZSA9IHNlbGYuX3NoYXBlc1trXTtcbiAgICBzZWxmLl9nZXRDaGlsZHJlbltrXSA9IGdldFdhbGtGbihzaGFwZSk7XG5cbiAgICAvLyBBIGZ1bmN0aW9uIG1lYW5zIHRoZSBhcml0eSBpc24ndCBmaXhlZCwgc28gZG9uJ3QgcHV0IGFuIGVudHJ5IGluIHRoZSBhcml0eSBtYXAuXG4gICAgaWYgKHR5cGVvZiBzaGFwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZi5fYXJpdGllc1trXSA9IEFycmF5LmlzQXJyYXkoc2hhcGUpID8gc2hhcGUubGVuZ3RoIDogMTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLl93cmFwID0gZnVuY3Rpb24odGhpbmcpIHsgcmV0dXJuIG5ldyBzZWxmLkFkYXB0ZXIodGhpbmcsIHNlbGYpOyB9O1xufVxuXG5WaXNpdG9yRmFtaWx5LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIHRoaXMuX3dyYXAodGhpbmcpO1xufTtcblxuVmlzaXRvckZhbWlseS5wcm90b3R5cGUuX2NoZWNrQWN0aW9uRGljdCA9IGZ1bmN0aW9uKGRpY3QpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIE9iamVjdC5rZXlzKGRpY3QpLmZvckVhY2goayA9PiB7XG4gICAgYXNzZXJ0KGsgaW4gc2VsZi5fZ2V0Q2hpbGRyZW4sIFwiVW5yZWNvZ25pemVkIGFjdGlvbiBuYW1lICdcIiArIGsgKyBcIidcIik7XG4gICAgY29uc3QgYWN0aW9uID0gZGljdFtrXTtcbiAgICBhc3NlcnQodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJywgXCJLZXkgJ1wiICsgayArIFwiJzogZXhwZWN0ZWQgZnVuY3Rpb24sIGdvdCBcIiArIGFjdGlvbik7XG4gICAgaWYgKGsgaW4gc2VsZi5fYXJpdGllcykge1xuICAgICAgY29uc3QgZXhwZWN0ZWQgPSBzZWxmLl9hcml0aWVzW2tdO1xuICAgICAgY29uc3QgYWN0dWFsID0gZGljdFtrXS5sZW5ndGg7XG4gICAgICBhc3NlcnQoYWN0dWFsID09PSBleHBlY3RlZCxcbiAgICAgICAgICBcIkFjdGlvbiAnXCIgKyBrICsgXCInIGhhcyB0aGUgd3JvbmcgYXJpdHk6IGV4cGVjdGVkIFwiICsgZXhwZWN0ZWQgKyAnLCBnb3QgJyArIGFjdHVhbCk7XG4gICAgfVxuICB9KTtcbn07XG5cblZpc2l0b3JGYW1pbHkucHJvdG90eXBlLmFkZE9wZXJhdGlvbiA9IGZ1bmN0aW9uKHNpZ25hdHVyZSwgYWN0aW9ucykge1xuICBjb25zdCBzaWcgPSBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICBjb25zdCBuYW1lID0gc2lnLm5hbWU7XG4gIHRoaXMuX2NoZWNrQWN0aW9uRGljdChhY3Rpb25zKTtcbiAgdGhpcy5vcGVyYXRpb25zW25hbWVdID0ge1xuICAgIG5hbWUsXG4gICAgZm9ybWFsczogc2lnLmZvcm1hbHMsXG4gICAgYWN0aW9uc1xuICB9O1xuXG4gIGNvbnN0IGZhbWlseSA9IHRoaXM7XG4gIHRoaXMuQWRhcHRlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0YWcgPSBmYW1pbHkuX2dldFRhZyh0aGlzLl9hZGFwdGVlKTtcbiAgICBhc3NlcnQodGFnIGluIGZhbWlseS5fZ2V0Q2hpbGRyZW4sIFwiZ2V0VGFnIHJldHVybmVkIHVucmVjb2duaXplZCB0YWcgJ1wiICsgdGFnICsgXCInXCIpO1xuICAgIGFzc2VydCh0YWcgaW4gYWN0aW9ucywgXCJObyBhY3Rpb24gZm9yICdcIiArIHRhZyArIFwiJyBpbiBvcGVyYXRpb24gJ1wiICsgbmFtZSArIFwiJ1wiKTtcblxuICAgIC8vIENyZWF0ZSBhbiBcImFyZ3VtZW50cyBvYmplY3RcIiBmcm9tIHRoZSBhcmd1bWVudHMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGlzXG4gICAgLy8gb3BlcmF0aW9uIC8gYXR0cmlidXRlLlxuICAgIGNvbnN0IGFyZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW3NpZy5mb3JtYWxzW2ldXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRBcmdzID0gdGhpcy5hcmdzO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgY29uc3QgYW5zID0gYWN0aW9uc1t0YWddLmFwcGx5KHRoaXMsIGZhbWlseS5fZ2V0Q2hpbGRyZW5bdGFnXSh0aGlzLl9hZGFwdGVlLCBmYW1pbHkuX3dyYXApKTtcbiAgICB0aGlzLmFyZ3MgPSBvbGRBcmdzO1xuICAgIHJldHVybiBhbnM7XG4gIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gVmlzaXRvckZhbWlseTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFZpc2l0b3JGYW1pbHk6IHJlcXVpcmUoJy4vVmlzaXRvckZhbWlseScpLFxuICBzZW1hbnRpY3NGb3JUb0FTVDogcmVxdWlyZSgnLi9zZW1hbnRpY3MtdG9BU1QnKS5zZW1hbnRpY3MsXG4gIHRvQVNUOiByZXF1aXJlKCcuL3NlbWFudGljcy10b0FTVCcpLmhlbHBlclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4uL3NyYy9wZXhwcnMnKTtcbmNvbnN0IE1hdGNoUmVzdWx0ID0gcmVxdWlyZSgnLi4vc3JjL01hdGNoUmVzdWx0Jyk7XG5jb25zdCBHcmFtbWFyID0gcmVxdWlyZSgnLi4vc3JjL0dyYW1tYXInKTtcbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3V0aWwtZXh0ZW5kJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBkZWZhdWx0T3BlcmF0aW9uID0ge1xuICBfdGVybWluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlVmFsdWU7XG4gIH0sXG5cbiAgX25vbnRlcm1pbmFsKGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY3Rvck5hbWUgPSB0aGlzLl9ub2RlLmN0b3JOYW1lO1xuICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLmFyZ3MubWFwcGluZztcblxuICAgIC8vIHdpdGhvdXQgY3VzdG9taXphdGlvblxuICAgIGlmICghbWFwcGluZy5oYXNPd25Qcm9wZXJ0eShjdG9yTmFtZSkpIHtcbiAgICAgIC8vIGludGVybWVkaWF0ZSBub2RlXG4gICAgICBpZiAodGhpcy5fbm9kZSBpbnN0YW5jZW9mIHBleHBycy5BbHQgfHwgdGhpcy5fbm9kZSBpbnN0YW5jZW9mIHBleHBycy5BcHBseSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF0udG9BU1QobWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxleGljYWwgcnVsZVxuICAgICAgaWYgKHRoaXMuaXNMZXhpY2FsKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICAvLyBzaW5ndWxhciBub2RlIChlLmcuIG9ubHkgc3Vycm91bmRlZCBieSBsaXRlcmFscyBvciBsb29rYWhlYWRzKVxuICAgICAgY29uc3QgcmVhbENoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5pc1Rlcm1pbmFsKCkpO1xuICAgICAgaWYgKHJlYWxDaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlYWxDaGlsZHJlblswXS50b0FTVChtYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdDogdGVybXMgd2l0aCBtdWx0aXBsZSBjaGlsZHJlblxuICAgIH1cblxuICAgIC8vIGRpcmVjdCBmb3J3YXJkXG4gICAgaWYgKHR5cGVvZiBtYXBwaW5nW2N0b3JOYW1lXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlblttYXBwaW5nW2N0b3JOYW1lXV0udG9BU1QobWFwcGluZyk7XG4gICAgfVxuXG4gICAgLy8gbmFtZWQvbWFwcGVkIGNoaWxkcmVuIG9yIHVubmFtZWQgY2hpbGRyZW4gKCcwJywgJzEnLCAnMicsIC4uLilcbiAgICBjb25zdCBwcm9wTWFwID0gbWFwcGluZ1tjdG9yTmFtZV0gfHwgY2hpbGRyZW47XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IGN0b3JOYW1lXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcE1hcCkge1xuICAgICAgY29uc3QgbWFwcGVkUHJvcCA9IG1hcHBpbmdbY3Rvck5hbWVdICYmIG1hcHBpbmdbY3Rvck5hbWVdW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBkaXJlY3QgZm9yd2FyZFxuICAgICAgICBub2RlW3Byb3BdID0gY2hpbGRyZW5bbWFwcGVkUHJvcF0udG9BU1QobWFwcGluZyk7XG4gICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbWFwcGVkUHJvcCA9PT0gJ3N0cmluZycpIHx8ICh0eXBlb2YgbWFwcGVkUHJvcCA9PT0gJ2Jvb2xlYW4nKSB8fFxuICAgICAgICAgIChtYXBwZWRQcm9wID09PSBudWxsKSkge1xuICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWVcbiAgICAgICAgbm9kZVtwcm9wXSA9IG1hcHBlZFByb3A7XG4gICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbWFwcGVkUHJvcCA9PT0gJ29iamVjdCcpICYmIChtYXBwZWRQcm9wIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuICAgICAgICAvLyBwcmltaXRpdmUgbnVtYmVyIChtdXN0IGJlIHVuYm94ZWQpXG4gICAgICAgIG5vZGVbcHJvcF0gPSBOdW1iZXIobWFwcGVkUHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXBwZWRQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNvbXB1dGVkIHZhbHVlXG4gICAgICAgIG5vZGVbcHJvcF0gPSBtYXBwZWRQcm9wLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIGlmIChtYXBwZWRQcm9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW3Byb3BdICYmICFjaGlsZHJlbltwcm9wXS5pc1Rlcm1pbmFsKCkpIHtcbiAgICAgICAgICBub2RlW3Byb3BdID0gY2hpbGRyZW5bcHJvcF0udG9BU1QobWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVsZXRlIHByZWRlZmluZWQgJ3R5cGUnIHByb3BlcnRpZXMsIGxpa2UgJ3R5cGUnLCBpZiBleHBsaWNpdGVseSByZW1vdmVkXG4gICAgICAgICAgZGVsZXRlIG5vZGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgX2l0ZXIoY2hpbGRyZW4pIHtcbiAgICBpZiAodGhpcy5fbm9kZS5pc09wdGlvbmFsKCkpIHtcbiAgICAgIGlmICh0aGlzLm51bUNoaWxkcmVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdLnRvQVNUKHRoaXMuYXJncy5tYXBwaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudG9BU1QodGhpcy5hcmdzLm1hcHBpbmcpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIE5vbmVtcHR5TGlzdE9mKGZpcnN0LCBzZXAsIHJlc3QpIHtcbiAgICByZXR1cm4gW2ZpcnN0LnRvQVNUKHRoaXMuYXJncy5tYXBwaW5nKV0uY29uY2F0KHJlc3QudG9BU1QodGhpcy5hcmdzLm1hcHBpbmcpKTtcbiAgfSxcblxuICBFbXB0eUxpc3RPZigpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8vIFJldHVybnMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGluY2x1ZGVzIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlIChBU1QpXG4vLyBmb3IgdGhlIGdpdmVuIG1hdGNoIHJlc3VsdCBgcmVzYCBjb250YWluZyBhIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIGFuZCBncmFtbWFyLlxuLy8gVGhlIG9wdGlvbmFsIGBtYXBwaW5nYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gY3VzdG9taXplIGhvdyB0aGUgbm9kZXMgb2YgdGhlIENTVFxuLy8gYXJlIG1hcHBlZCB0byB0aGUgQVNUIChzZWUgL2RvYy9leHRyYXMubWQjdG9hc3RtYXRjaHJlc3VsdC1tYXBwaW5nKS5cbmZ1bmN0aW9uIHRvQVNUKHJlcywgbWFwcGluZykge1xuICBpZiAoIShyZXMgaW5zdGFuY2VvZiBNYXRjaFJlc3VsdCkgfHwgcmVzLmZhaWxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b0FTVCgpIGV4cGVjdHMgYSBzdWNjZXNmdWxsIE1hdGNoUmVzdWx0IGFzIGZpcnN0IHBhcmFtZXRlcicpO1xuICB9XG5cbiAgbWFwcGluZyA9IGV4dGVuZCh7fSwgbWFwcGluZyk7XG4gIGNvbnN0IG9wZXJhdGlvbiA9IGV4dGVuZCh7fSwgZGVmYXVsdE9wZXJhdGlvbik7XG4gIGZvciAoY29uc3QgdGVybU5hbWUgaW4gbWFwcGluZykge1xuICAgIGlmICh0eXBlb2YgbWFwcGluZ1t0ZXJtTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wZXJhdGlvblt0ZXJtTmFtZV0gPSBtYXBwaW5nW3Rlcm1OYW1lXTtcbiAgICAgIGRlbGV0ZSBtYXBwaW5nW3Rlcm1OYW1lXTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZyA9IHJlcy5fY3N0LmdyYW1tYXI7XG4gIGNvbnN0IHMgPSBnLmNyZWF0ZVNlbWFudGljcygpLmFkZE9wZXJhdGlvbigndG9BU1QobWFwcGluZyknLCBvcGVyYXRpb24pO1xuICByZXR1cm4gcyhyZXMpLnRvQVNUKG1hcHBpbmcpO1xufVxuXG4vLyBSZXR1cm5zIGEgc2VtYW50aWNzIGNvbnRhaW5nIHRoZSB0b0FTVChtYXBwaW5nKSBvcGVyYXRpb24gZm9yIHRoZSBnaXZlbiBncmFtbWFyIGcuXG5mdW5jdGlvbiBzZW1hbnRpY3NGb3JUb0FTVChnKSB7XG4gIGlmICghKGcgaW5zdGFuY2VvZiBHcmFtbWFyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2VtYW50aWNzVG9BU1QoKSBleHBlY3RzIGEgR3JhbW1hciBhcyBwYXJhbWV0ZXInKTtcbiAgfVxuXG4gIHJldHVybiBnLmNyZWF0ZVNlbWFudGljcygpLmFkZE9wZXJhdGlvbigndG9BU1QobWFwcGluZyknLCBkZWZhdWx0T3BlcmF0aW9uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhlbHBlcjogdG9BU1QsXG4gIHNlbWFudGljczogc2VtYW50aWNzRm9yVG9BU1Rcbn07XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBHcmFtbWFyRGVjbCA9IHJlcXVpcmUoJy4vR3JhbW1hckRlY2wnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBCdWlsZGVyKCkge31cblxuQnVpbGRlci5wcm90b3R5cGUgPSB7XG4gIGN1cnJlbnREZWNsOiBudWxsLFxuICBjdXJyZW50UnVsZU5hbWU6IG51bGwsXG5cbiAgbmV3R3JhbW1hcihuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBHcmFtbWFyRGVjbChuYW1lKTtcbiAgfSxcblxuICBncmFtbWFyKG1ldGFJbmZvLCBuYW1lLCBzdXBlckdyYW1tYXIsIGRlZmF1bHRTdGFydFJ1bGUsIHJ1bGVzKSB7XG4gICAgY29uc3QgZ0RlY2wgPSBuZXcgR3JhbW1hckRlY2wobmFtZSk7XG4gICAgaWYgKHN1cGVyR3JhbW1hcikge1xuICAgICAgZ0RlY2wud2l0aFN1cGVyR3JhbW1hcih0aGlzLmZyb21SZWNpcGUoc3VwZXJHcmFtbWFyKSk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U3RhcnRSdWxlKSB7XG4gICAgICBnRGVjbC53aXRoRGVmYXVsdFN0YXJ0UnVsZShkZWZhdWx0U3RhcnRSdWxlKTtcbiAgICB9XG4gICAgaWYgKG1ldGFJbmZvICYmIG1ldGFJbmZvLnNvdXJjZSkge1xuICAgICAgZ0RlY2wud2l0aFNvdXJjZShtZXRhSW5mby5zb3VyY2UpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudERlY2wgPSBnRGVjbDtcbiAgICBPYmplY3Qua2V5cyhydWxlcykuZm9yRWFjaChydWxlTmFtZSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRSdWxlTmFtZSA9IHJ1bGVOYW1lO1xuICAgICAgY29uc3QgcnVsZVJlY2lwZSA9IHJ1bGVzW3J1bGVOYW1lXTtcblxuICAgICAgY29uc3QgYWN0aW9uID0gcnVsZVJlY2lwZVswXTsgLy8gZGVmaW5lL2V4dGVuZC9vdmVycmlkZVxuICAgICAgY29uc3QgbWV0YUluZm8gPSBydWxlUmVjaXBlWzFdO1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBydWxlUmVjaXBlWzJdO1xuICAgICAgY29uc3QgZm9ybWFscyA9IHJ1bGVSZWNpcGVbM107XG4gICAgICBjb25zdCBib2R5ID0gdGhpcy5mcm9tUmVjaXBlKHJ1bGVSZWNpcGVbNF0pO1xuXG4gICAgICBsZXQgc291cmNlO1xuICAgICAgaWYgKGdEZWNsLnNvdXJjZSAmJiBtZXRhSW5mbyAmJiBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbCkge1xuICAgICAgICBzb3VyY2UgPSBnRGVjbC5zb3VyY2Uuc3ViSW50ZXJ2YWwoXG4gICAgICAgICAgICBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbFswXSxcbiAgICAgICAgICAgIG1ldGFJbmZvLnNvdXJjZUludGVydmFsWzFdIC0gbWV0YUluZm8uc291cmNlSW50ZXJ2YWxbMF0pO1xuICAgICAgfVxuICAgICAgZ0RlY2xbYWN0aW9uXShydWxlTmFtZSwgZm9ybWFscywgYm9keSwgZGVzY3JpcHRpb24sIHNvdXJjZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50UnVsZU5hbWUgPSB0aGlzLmN1cnJlbnREZWNsID0gbnVsbDtcbiAgICByZXR1cm4gZ0RlY2wuYnVpbGQoKTtcbiAgfSxcblxuICB0ZXJtaW5hbCh4KSB7XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuVGVybWluYWwoeCk7XG4gIH0sXG5cbiAgcmFuZ2UoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IHBleHBycy5SYW5nZShmcm9tLCB0byk7XG4gIH0sXG5cbiAgcGFyYW0oaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IHBleHBycy5QYXJhbShpbmRleCk7XG4gIH0sXG5cbiAgYWx0KC8qIHRlcm0xLCB0ZXJtMiwgLi4uICovKSB7XG4gICAgbGV0IHRlcm1zID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYXJndW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGxldCBhcmcgPSBhcmd1bWVudHNbaWR4XTtcbiAgICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgICAgYXJnID0gdGhpcy5mcm9tUmVjaXBlKGFyZyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgcGV4cHJzLkFsdCkge1xuICAgICAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChhcmcudGVybXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVybXMucHVzaChhcmcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVybXMubGVuZ3RoID09PSAxID8gdGVybXNbMF0gOiBuZXcgcGV4cHJzLkFsdCh0ZXJtcyk7XG4gIH0sXG5cbiAgc2VxKC8qIGZhY3RvcjEsIGZhY3RvcjIsIC4uLiAqLykge1xuICAgIGxldCBmYWN0b3JzID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYXJndW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGxldCBhcmcgPSBhcmd1bWVudHNbaWR4XTtcbiAgICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgICAgYXJnID0gdGhpcy5mcm9tUmVjaXBlKGFyZyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgcGV4cHJzLlNlcSkge1xuICAgICAgICBmYWN0b3JzID0gZmFjdG9ycy5jb25jYXQoYXJnLmZhY3RvcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9ycy5wdXNoKGFyZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWN0b3JzLmxlbmd0aCA9PT0gMSA/IGZhY3RvcnNbMF0gOiBuZXcgcGV4cHJzLlNlcShmYWN0b3JzKTtcbiAgfSxcblxuICBzdGFyKGV4cHIpIHtcbiAgICBpZiAoIShleHByIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgZXhwciA9IHRoaXMuZnJvbVJlY2lwZShleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuU3RhcihleHByKTtcbiAgfSxcblxuICBwbHVzKGV4cHIpIHtcbiAgICBpZiAoIShleHByIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgZXhwciA9IHRoaXMuZnJvbVJlY2lwZShleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuUGx1cyhleHByKTtcbiAgfSxcblxuICBvcHQoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5PcHQoZXhwcik7XG4gIH0sXG5cbiAgbm90KGV4cHIpIHtcbiAgICBpZiAoIShleHByIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgZXhwciA9IHRoaXMuZnJvbVJlY2lwZShleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuTm90KGV4cHIpO1xuICB9LFxuXG4gIGxhKGV4cHIpIHtcbiAgICAvLyBUT0RPOiB0ZW1wb3JhcnkgdG8gc3RpbGwgYmUgYWJsZSB0byByZWFkIG9sZCByZWNpcGVzXG4gICAgcmV0dXJuIHRoaXMubG9va2FoZWFkKGV4cHIpO1xuICB9LFxuXG4gIGxvb2thaGVhZChleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLkxvb2thaGVhZChleHByKTtcbiAgfSxcblxuICBsZXgoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5MZXgoZXhwcik7XG4gIH0sXG5cbiAgYXBwKHJ1bGVOYW1lLCBvcHRQYXJhbXMpIHtcbiAgICBpZiAob3B0UGFyYW1zICYmIG9wdFBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBvcHRQYXJhbXMgPSBvcHRQYXJhbXMubWFwKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSBpbnN0YW5jZW9mIHBleHBycy5QRXhwciA/IHBhcmFtIDpcbiAgICAgICAgICB0aGlzLmZyb21SZWNpcGUocGFyYW0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLkFwcGx5KHJ1bGVOYW1lLCBvcHRQYXJhbXMpO1xuICB9LFxuXG4gIC8vIE5vdGUgdGhhdCB1bmxpa2Ugb3RoZXIgbWV0aG9kcyBpbiB0aGlzIGNsYXNzLCB0aGlzIG1ldGhvZCBjYW5ub3QgYmUgdXNlZCBhcyBhXG4gIC8vIGNvbnZlbmllbmNlIGNvbnN0cnVjdG9yLiBJdCBvbmx5IHdvcmtzIHdpdGggcmVjaXBlcywgYmVjYXVzZSBpdCByZWxpZXMgb25cbiAgLy8gYHRoaXMuY3VycmVudERlY2xgIGFuZCBgdGhpcy5jdXJyZW50UnVsZU5hbWVgIGJlaW5nIHNldC5cbiAgc3BsaWNlKGJlZm9yZVRlcm1zLCBhZnRlclRlcm1zKSB7XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuU3BsaWNlKFxuICAgICAgICB0aGlzLmN1cnJlbnREZWNsLnN1cGVyR3JhbW1hcixcbiAgICAgICAgdGhpcy5jdXJyZW50UnVsZU5hbWUsXG4gICAgICAgIGJlZm9yZVRlcm1zLm1hcCh0ZXJtID0+IHRoaXMuZnJvbVJlY2lwZSh0ZXJtKSksXG4gICAgICAgIGFmdGVyVGVybXMubWFwKHRlcm0gPT4gdGhpcy5mcm9tUmVjaXBlKHRlcm0pKSk7XG4gIH0sXG5cbiAgZnJvbVJlY2lwZShyZWNpcGUpIHtcbiAgICAvLyB0aGUgbWV0YS1pbmZvIG9mICdncmFtbWFyJyBpcyBwcm9jZXNzZWQgaW4gQnVpbGRlci5ncmFtbWFyXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpc1tyZWNpcGVbMF1dLmFwcGx5KHRoaXMsXG4gICAgICByZWNpcGVbMF0gPT09ICdncmFtbWFyJyA/IHJlY2lwZS5zbGljZSgxKSA6IHJlY2lwZS5zbGljZSgyKSk7XG5cbiAgICBjb25zdCBtZXRhSW5mbyA9IHJlY2lwZVsxXTtcbiAgICBpZiAobWV0YUluZm8pIHtcbiAgICAgIGlmIChtZXRhSW5mby5zb3VyY2VJbnRlcnZhbCAmJiB0aGlzLmN1cnJlbnREZWNsKSB7XG4gICAgICAgIHJlc3VsdC53aXRoU291cmNlKFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGVjbC5zb3VyY2VJbnRlcnZhbC5hcHBseSh0aGlzLmN1cnJlbnREZWNsLCBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gQnVpbGRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEZhaWx1cmUgPSByZXF1aXJlKCcuL0ZhaWx1cmUnKTtcbmNvbnN0IFRlcm1pbmFsTm9kZSA9IHJlcXVpcmUoJy4vbm9kZXMnKS5UZXJtaW5hbE5vZGU7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCcuL2NvbW1vbicpLmFzc2VydDtcbmNvbnN0IHtQRXhwciwgVGVybWluYWx9ID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuY2xhc3MgQ2FzZUluc2Vuc2l0aXZlVGVybWluYWwgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9iaiA9IHBhcmFtO1xuICB9XG5cbiAgX2dldFN0cmluZyhzdGF0ZSkge1xuICAgIGNvbnN0IHRlcm1pbmFsID0gc3RhdGUuY3VycmVudEFwcGxpY2F0aW9uKCkuYXJnc1t0aGlzLm9iai5pbmRleF07XG4gICAgYXNzZXJ0KHRlcm1pbmFsIGluc3RhbmNlb2YgVGVybWluYWwsICdleHBlY3RlZCBhIFRlcm1pbmFsIGV4cHJlc3Npb24nKTtcbiAgICByZXR1cm4gdGVybWluYWwub2JqO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50YXRpb24gb2YgdGhlIFBFeHByIEFQSVxuXG4gIGFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBldmFsKHN0YXRlKSB7XG4gICAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICAgIGNvbnN0IG1hdGNoU3RyID0gdGhpcy5fZ2V0U3RyaW5nKHN0YXRlKTtcbiAgICBpZiAoIWlucHV0U3RyZWFtLm1hdGNoU3RyaW5nKG1hdGNoU3RyLCB0cnVlKSkge1xuICAgICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgbWF0Y2hTdHIpLCBvcmlnUG9zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIGV4YW1wbGUgZ2VuZXJhdGVkIGZyb20gdGhlIFRlcm1pbmFsLi4uXG4gICAgY29uc3Qgc3RyID0gdGhpcy5vYmouZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpLnZhbHVlO1xuXG4gICAgLy8gLi4uYW5kIHJhbmRvbWx5IHN3aXRjaCBjaGFyYWN0ZXJzIHRvIHVwcGVyY2FzZS9sb3dlcmNhc2UuXG4gICAgbGV0IHZhbHVlID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhbHVlICs9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyBzdHJbaV0udG9Mb2NhbGVMb3dlckNhc2UoKSA6IHN0cltpXS50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4ge3ZhbHVlfTtcbiAgfVxuXG4gIGdldEFyaXR5KCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSB7XG4gICAgcmV0dXJuIG5ldyBDYXNlSW5zZW5zaXRpdmVUZXJtaW5hbCh0aGlzLm9iai5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpKTtcbiAgfVxuXG4gIHRvRGlzcGxheVN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5vYmoudG9EaXNwbGF5U3RyaW5nKCkgKyAnIChjYXNlLWluc2Vuc2l0aXZlKSc7XG4gIH1cblxuICB0b0ZhaWx1cmUoZ3JhbW1hcikge1xuICAgIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCB0aGlzLm9iai50b0ZhaWx1cmUoZ3JhbW1hcikgKyAnIChjYXNlLWluc2Vuc2l0aXZlKScsICdkZXNjcmlwdGlvbicpO1xuICB9XG5cbiAgX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbykge1xuICAgIHJldHVybiB0aGlzLm9iai5faXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgYEZhaWx1cmVgcyByZXByZXNlbnQgZXhwcmVzc2lvbnMgdGhhdCB3ZXJlbid0IG1hdGNoZWQgd2hpbGUgcGFyc2luZy4gVGhleSBhcmUgdXNlZCB0byBnZW5lcmF0ZVxuICBlcnJvciBtZXNzYWdlcyBhdXRvbWF0aWNhbGx5LiBUaGUgaW50ZXJmYWNlIG9mIGBGYWlsdXJlYHMgaW5jbHVkZXMgdGhlIGNvbGxvd2luZyBtZXRob2RzOlxuXG4gIC0gZ2V0VGV4dCgpIDogU3RyaW5nXG4gIC0gZ2V0VHlwZSgpIDogU3RyaW5nICAob25lIG9mIHtcImRlc2NyaXB0aW9uXCIsIFwic3RyaW5nXCIsIFwiY29kZVwifSlcbiAgLSBpc0Rlc2NyaXB0aW9uKCkgOiBib29sXG4gIC0gaXNTdHJpbmdUZXJtaW5hbCgpIDogYm9vbFxuICAtIGlzQ29kZSgpIDogYm9vbFxuICAtIGlzRmx1ZmZ5KCkgOiBib29sXG4gIC0gbWFrZUZsdWZmeSgpIDogdm9pZFxuICAtIHN1YnN1bWVzKEZhaWx1cmUpIDogYm9vbFxuKi9cblxuZnVuY3Rpb24gaXNWYWxpZFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSA9PT0gJ2Rlc2NyaXB0aW9uJyB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnY29kZSc7XG59XG5cbmZ1bmN0aW9uIEZhaWx1cmUocGV4cHIsIHRleHQsIHR5cGUpIHtcbiAgaWYgKCFpc1ZhbGlkVHlwZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBGYWlsdXJlIHR5cGU6ICcgKyB0eXBlKTtcbiAgfVxuICB0aGlzLnBleHByID0gcGV4cHI7XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuZmx1ZmZ5ID0gZmFsc2U7XG59XG5cbkZhaWx1cmUucHJvdG90eXBlLmdldFBFeHByID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBleHByO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50ZXh0O1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuaXNEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSAnZGVzY3JpcHRpb24nO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuaXNTdHJpbmdUZXJtaW5hbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSAnc3RyaW5nJztcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmlzQ29kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSAnY29kZSc7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5pc0ZsdWZmeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5mbHVmZnk7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5tYWtlRmx1ZmZ5ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZmx1ZmZ5ID0gdHJ1ZTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmNsZWFyRmx1ZmZ5ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZmx1ZmZ5ID0gZmFsc2U7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5zdWJzdW1lcyA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpID09PSB0aGF0LmdldFRleHQoKSAmJlxuICAgICAgdGhpcy50eXBlID09PSB0aGF0LnR5cGUgJiZcbiAgICAgICghdGhpcy5pc0ZsdWZmeSgpIHx8IHRoaXMuaXNGbHVmZnkoKSAmJiB0aGF0LmlzRmx1ZmZ5KCkpO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3N0cmluZycgP1xuICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0VGV4dCgpKSA6XG4gICAgdGhpcy5nZXRUZXh0KCk7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBmYWlsdXJlID0gbmV3IEZhaWx1cmUodGhpcy5wZXhwciwgdGhpcy50ZXh0LCB0aGlzLnR5cGUpO1xuICBpZiAodGhpcy5pc0ZsdWZmeSgpKSB7XG4gICAgZmFpbHVyZS5tYWtlRmx1ZmZ5KCk7XG4gIH1cbiAgcmV0dXJuIGZhaWx1cmU7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS50b0tleSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygpICsgJyMnICsgdGhpcy50eXBlO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gRmFpbHVyZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IENhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsID0gcmVxdWlyZSgnLi9DYXNlSW5zZW5zaXRpdmVUZXJtaW5hbCcpO1xuY29uc3QgTWF0Y2hlciA9IHJlcXVpcmUoJy4vTWF0Y2hlcicpO1xuY29uc3QgU2VtYW50aWNzID0gcmVxdWlyZSgnLi9TZW1hbnRpY3MnKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGdldFNvcnRlZFJ1bGVWYWx1ZXMoZ3JhbW1hcikge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZ3JhbW1hci5ydWxlcykuc29ydCgpLm1hcChuYW1lID0+IGdyYW1tYXIucnVsZXNbbmFtZV0pO1xufVxuXG5mdW5jdGlvbiBHcmFtbWFyKFxuICAgIG5hbWUsXG4gICAgc3VwZXJHcmFtbWFyLFxuICAgIHJ1bGVzLFxuICAgIG9wdERlZmF1bHRTdGFydFJ1bGUpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5zdXBlckdyYW1tYXIgPSBzdXBlckdyYW1tYXI7XG4gIHRoaXMucnVsZXMgPSBydWxlcztcbiAgaWYgKG9wdERlZmF1bHRTdGFydFJ1bGUpIHtcbiAgICBpZiAoIShvcHREZWZhdWx0U3RhcnRSdWxlIGluIHJ1bGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGFydCBydWxlOiAnXCIgKyBvcHREZWZhdWx0U3RhcnRSdWxlICtcbiAgICAgICAgICAgICAgICAgICAgICBcIicgaXMgbm90IGEgcnVsZSBpbiBncmFtbWFyICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgfVxuICAgIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSA9IG9wdERlZmF1bHRTdGFydFJ1bGU7XG4gIH1cbn1cblxubGV0IG9obUdyYW1tYXI7XG5sZXQgYnVpbGRHcmFtbWFyO1xuXG4vLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSBtYWluLmpzIG9uY2UgT2htIGhhcyBsb2FkZWQuXG5HcmFtbWFyLmluaXRBcHBsaWNhdGlvblBhcnNlciA9IGZ1bmN0aW9uKGdyYW1tYXIsIGJ1aWxkZXJGbikge1xuICBvaG1HcmFtbWFyID0gZ3JhbW1hcjtcbiAgYnVpbGRHcmFtbWFyID0gYnVpbGRlckZuO1xufTtcblxuR3JhbW1hci5wcm90b3R5cGUgPSB7XG4gIG1hdGNoZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRjaGVyKHRoaXMpO1xuICB9LFxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBncmFtbWFyIGlzIGEgYnVpbHQtaW4gZ3JhbW1hciwgb3RoZXJ3aXNlIGZhbHNlLlxuICAvLyBOT1RFOiBUaGlzIG1pZ2h0IGdpdmUgYW4gdW5leHBlY3RlZCByZXN1bHQgaWYgY2FsbGVkIGJlZm9yZSBCdWlsdEluUnVsZXMgaXMgZGVmaW5lZCFcbiAgaXNCdWlsdEluKCkge1xuICAgIHJldHVybiB0aGlzID09PSBHcmFtbWFyLlByb3RvQnVpbHRJblJ1bGVzIHx8IHRoaXMgPT09IEdyYW1tYXIuQnVpbHRJblJ1bGVzO1xuICB9LFxuXG4gIGVxdWFscyhnKSB7XG4gICAgaWYgKHRoaXMgPT09IGcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEbyB0aGUgY2hlYXBlc3QgY29tcGFyaXNvbnMgZmlyc3QuXG4gICAgaWYgKGcgPT0gbnVsbCB8fFxuICAgICAgICB0aGlzLm5hbWUgIT09IGcubmFtZSB8fFxuICAgICAgICB0aGlzLmRlZmF1bHRTdGFydFJ1bGUgIT09IGcuZGVmYXVsdFN0YXJ0UnVsZSB8fFxuICAgICAgICAhKHRoaXMuc3VwZXJHcmFtbWFyID09PSBnLnN1cGVyR3JhbW1hciB8fCB0aGlzLnN1cGVyR3JhbW1hci5lcXVhbHMoZy5zdXBlckdyYW1tYXIpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBteVJ1bGVzID0gZ2V0U29ydGVkUnVsZVZhbHVlcyh0aGlzKTtcbiAgICBjb25zdCBvdGhlclJ1bGVzID0gZ2V0U29ydGVkUnVsZVZhbHVlcyhnKTtcbiAgICByZXR1cm4gbXlSdWxlcy5sZW5ndGggPT09IG90aGVyUnVsZXMubGVuZ3RoICYmIG15UnVsZXMuZXZlcnkoKHJ1bGUsIGkpID0+IHtcbiAgICAgIHJldHVybiBydWxlLmRlc2NyaXB0aW9uID09PSBvdGhlclJ1bGVzW2ldLmRlc2NyaXB0aW9uICYmXG4gICAgICAgICAgICAgcnVsZS5mb3JtYWxzLmpvaW4oJywnKSA9PT0gb3RoZXJSdWxlc1tpXS5mb3JtYWxzLmpvaW4oJywnKSAmJlxuICAgICAgICAgICAgIHJ1bGUuYm9keS50b1N0cmluZygpID09PSBvdGhlclJ1bGVzW2ldLmJvZHkudG9TdHJpbmcoKTtcbiAgICB9KTtcbiAgfSxcblxuICBtYXRjaChpbnB1dCwgb3B0U3RhcnRBcHBsaWNhdGlvbikge1xuICAgIGNvbnN0IG0gPSB0aGlzLm1hdGNoZXIoKTtcbiAgICBtLnJlcGxhY2VJbnB1dFJhbmdlKDAsIDAsIGlucHV0KTtcbiAgICByZXR1cm4gbS5tYXRjaChvcHRTdGFydEFwcGxpY2F0aW9uKTtcbiAgfSxcblxuICB0cmFjZShpbnB1dCwgb3B0U3RhcnRBcHBsaWNhdGlvbikge1xuICAgIGNvbnN0IG0gPSB0aGlzLm1hdGNoZXIoKTtcbiAgICBtLnJlcGxhY2VJbnB1dFJhbmdlKDAsIDAsIGlucHV0KTtcbiAgICByZXR1cm4gbS50cmFjZShvcHRTdGFydEFwcGxpY2F0aW9uKTtcbiAgfSxcblxuICBzZW1hbnRpY3MoKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgZXZlbnR1YWxseSEgRGVwcmVjYXRlZCBpbiB2MC4xMi5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbWFudGljcygpIGlzIGRlcHJlY2F0ZWQgLS0gdXNlIGNyZWF0ZVNlbWFudGljcygpIGluc3RlYWQuJyk7XG4gIH0sXG5cbiAgY3JlYXRlU2VtYW50aWNzKCkge1xuICAgIHJldHVybiBTZW1hbnRpY3MuY3JlYXRlU2VtYW50aWNzKHRoaXMpO1xuICB9LFxuXG4gIGV4dGVuZFNlbWFudGljcyhzdXBlclNlbWFudGljcykge1xuICAgIHJldHVybiBTZW1hbnRpY3MuY3JlYXRlU2VtYW50aWNzKHRoaXMsIHN1cGVyU2VtYW50aWNzLl9nZXRTZW1hbnRpY3MoKSk7XG4gIH0sXG5cbiAgLy8gQ2hlY2sgdGhhdCBldmVyeSBrZXkgaW4gYGFjdGlvbkRpY3RgIGNvcnJlc3BvbmRzIHRvIGEgc2VtYW50aWMgYWN0aW9uLCBhbmQgdGhhdCBpdCBtYXBzIHRvXG4gIC8vIGEgZnVuY3Rpb24gb2YgdGhlIGNvcnJlY3QgYXJpdHkuIElmIG5vdCwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICBfY2hlY2tUb3BEb3duQWN0aW9uRGljdCh3aGF0LCBuYW1lLCBhY3Rpb25EaWN0KSB7XG4gICAgZnVuY3Rpb24gaXNTcGVjaWFsQWN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhID09PSAnX2l0ZXInIHx8IGEgPT09ICdfdGVybWluYWwnIHx8IGEgPT09ICdfbm9udGVybWluYWwnIHx8IGEgPT09ICdfZGVmYXVsdCc7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvYmxlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gYWN0aW9uRGljdCkge1xuICAgICAgY29uc3QgdiA9IGFjdGlvbkRpY3Rba107XG4gICAgICBpZiAoIWlzU3BlY2lhbEFjdGlvbihrKSAmJiAhKGsgaW4gdGhpcy5ydWxlcykpIHtcbiAgICAgICAgcHJvYmxlbXMucHVzaChcIidcIiArIGsgKyBcIicgaXMgbm90IGEgdmFsaWQgc2VtYW50aWMgYWN0aW9uIGZvciAnXCIgKyB0aGlzLm5hbWUgKyBcIidcIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2JsZW1zLnB1c2goXG4gICAgICAgICAgICBcIidcIiArIGsgKyBcIicgbXVzdCBiZSBhIGZ1bmN0aW9uIGluIGFuIGFjdGlvbiBkaWN0aW9uYXJ5IGZvciAnXCIgKyB0aGlzLm5hbWUgKyBcIidcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhY3R1YWwgPSB2Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSB0aGlzLl90b3BEb3duQWN0aW9uQXJpdHkoayk7XG4gICAgICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgcHJvYmxlbXMucHVzaChcbiAgICAgICAgICAgICAgXCJTZW1hbnRpYyBhY3Rpb24gJ1wiICsgayArIFwiJyBoYXMgdGhlIHdyb25nIGFyaXR5OiBcIiArXG4gICAgICAgICAgICAgICdleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnLCBnb3QgJyArIGFjdHVhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2JsZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHByZXR0eVByb2JsZW1zID0gcHJvYmxlbXMubWFwKHByb2JsZW0gPT4gJy0gJyArIHByb2JsZW0pO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJGb3VuZCBlcnJvcnMgaW4gdGhlIGFjdGlvbiBkaWN0aW9uYXJ5IG9mIHRoZSAnXCIgKyBuYW1lICsgXCInIFwiICsgd2hhdCArICc6XFxuJyArXG4gICAgICAgICAgcHJldHR5UHJvYmxlbXMuam9pbignXFxuJykpO1xuICAgICAgZXJyb3IucHJvYmxlbXMgPSBwcm9ibGVtcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXR1cm4gdGhlIGV4cGVjdGVkIGFyaXR5IGZvciBhIHNlbWFudGljIGFjdGlvbiBuYW1lZCBgYWN0aW9uTmFtZWAsIHdoaWNoXG4gIC8vIGlzIGVpdGhlciBhIHJ1bGUgbmFtZSBvciBhIHNwZWNpYWwgYWN0aW9uIG5hbWUgbGlrZSAnX25vbnRlcm1pbmFsJy5cbiAgX3RvcERvd25BY3Rpb25Bcml0eShhY3Rpb25OYW1lKSB7XG4gICAgaWYgKGFjdGlvbk5hbWUgPT09ICdfaXRlcicgfHwgYWN0aW9uTmFtZSA9PT0gJ19ub250ZXJtaW5hbCcgfHwgYWN0aW9uTmFtZSA9PT0gJ19kZWZhdWx0Jykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhY3Rpb25OYW1lID09PSAnX3Rlcm1pbmFsJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJ1bGVzW2FjdGlvbk5hbWVdLmJvZHkuZ2V0QXJpdHkoKTtcbiAgfSxcblxuICBfaW5oZXJpdHNGcm9tKGdyYW1tYXIpIHtcbiAgICBsZXQgZyA9IHRoaXMuc3VwZXJHcmFtbWFyO1xuICAgIHdoaWxlIChnKSB7XG4gICAgICBpZiAoZy5lcXVhbHMoZ3JhbW1hciwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBnID0gZy5zdXBlckdyYW1tYXI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICB0b1JlY2lwZShvcHRWYXJOYW1lKSB7XG4gICAgY29uc3QgbWV0YUluZm8gPSB7fTtcbiAgICAvLyBJbmNsdWRlIHRoZSBncmFtbWFyIHNvdXJjZSBpZiBpdCBpcyBhdmFpbGFibGUuXG4gICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICBtZXRhSW5mby5zb3VyY2UgPSB0aGlzLnNvdXJjZS5jb250ZW50cztcbiAgICB9XG5cbiAgICBsZXQgc3VwZXJHcmFtbWFyID0gbnVsbDtcbiAgICBpZiAodGhpcy5zdXBlckdyYW1tYXIgJiYgIXRoaXMuc3VwZXJHcmFtbWFyLmlzQnVpbHRJbigpKSB7XG4gICAgICBzdXBlckdyYW1tYXIgPSBKU09OLnBhcnNlKHRoaXMuc3VwZXJHcmFtbWFyLnRvUmVjaXBlKCkpO1xuICAgIH1cblxuICAgIGxldCBzdGFydFJ1bGUgPSBudWxsO1xuICAgIGlmICh0aGlzLmRlZmF1bHRTdGFydFJ1bGUpIHtcbiAgICAgIHN0YXJ0UnVsZSA9IHRoaXMuZGVmYXVsdFN0YXJ0UnVsZTtcbiAgICB9XG5cbiAgICBjb25zdCBydWxlcyA9IHt9O1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKHRoaXMucnVsZXMpLmZvckVhY2gocnVsZU5hbWUgPT4ge1xuICAgICAgY29uc3QgcnVsZUluZm8gPSBzZWxmLnJ1bGVzW3J1bGVOYW1lXTtcbiAgICAgIGNvbnN0IGJvZHkgPSBydWxlSW5mby5ib2R5O1xuICAgICAgY29uc3QgaXNEZWZpbml0aW9uID0gIXNlbGYuc3VwZXJHcmFtbWFyIHx8ICFzZWxmLnN1cGVyR3JhbW1hci5ydWxlc1tydWxlTmFtZV07XG5cbiAgICAgIGxldCBvcGVyYXRpb247XG4gICAgICBpZiAoaXNEZWZpbml0aW9uKSB7XG4gICAgICAgIG9wZXJhdGlvbiA9ICdkZWZpbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BlcmF0aW9uID0gYm9keSBpbnN0YW5jZW9mIHBleHBycy5FeHRlbmQgPyAnZXh0ZW5kJyA6ICdvdmVycmlkZSc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldGFJbmZvID0ge307XG4gICAgICBpZiAocnVsZUluZm8uc291cmNlICYmIHNlbGYuc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkID0gcnVsZUluZm8uc291cmNlLnJlbGF0aXZlVG8oc2VsZi5zb3VyY2UpO1xuICAgICAgICBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbCA9IFthZGp1c3RlZC5zdGFydElkeCwgYWRqdXN0ZWQuZW5kSWR4XTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBpc0RlZmluaXRpb24gPyBydWxlSW5mby5kZXNjcmlwdGlvbiA6IG51bGw7XG4gICAgICBjb25zdCBib2R5UmVjaXBlID0gYm9keS5vdXRwdXRSZWNpcGUocnVsZUluZm8uZm9ybWFscywgc2VsZi5zb3VyY2UpO1xuXG4gICAgICBydWxlc1tydWxlTmFtZV0gPSBbXG4gICAgICAgIG9wZXJhdGlvbiwgLy8gXCJkZWZpbmVcIi9cImV4dGVuZFwiL1wib3ZlcnJpZGVcIlxuICAgICAgICBtZXRhSW5mbyxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHJ1bGVJbmZvLmZvcm1hbHMsXG4gICAgICAgIGJvZHlSZWNpcGVcbiAgICAgIF07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgJ2dyYW1tYXInLFxuICAgICAgbWV0YUluZm8sXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICBzdXBlckdyYW1tYXIsXG4gICAgICBzdGFydFJ1bGUsXG4gICAgICBydWxlc1xuICAgIF0pO1xuICB9LFxuXG4gIC8vIFRPRE86IENvbWUgdXAgd2l0aCBiZXR0ZXIgbmFtZXMgZm9yIHRoZXNlIG1ldGhvZHMuXG4gIC8vIFRPRE86IFdyaXRlIHRoZSBhbmFsb2cgb2YgdGhlc2UgbWV0aG9kcyBmb3IgaW5oZXJpdGVkIGF0dHJpYnV0ZXMuXG4gIHRvT3BlcmF0aW9uQWN0aW9uRGljdGlvbmFyeVRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90b09wZXJhdGlvbk9yQXR0cmlidXRlQWN0aW9uRGljdGlvbmFyeVRlbXBsYXRlKCk7XG4gIH0sXG4gIHRvQXR0cmlidXRlQWN0aW9uRGljdGlvbmFyeVRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90b09wZXJhdGlvbk9yQXR0cmlidXRlQWN0aW9uRGljdGlvbmFyeVRlbXBsYXRlKCk7XG4gIH0sXG5cbiAgX3RvT3BlcmF0aW9uT3JBdHRyaWJ1dGVBY3Rpb25EaWN0aW9uYXJ5VGVtcGxhdGUoKSB7XG4gICAgLy8gVE9ETzogYWRkIHRoZSBzdXBlci1ncmFtbWFyJ3MgdGVtcGxhdGVzIGF0IHRoZSByaWdodCBwbGFjZSwgZS5nLiwgYSBjYXNlIGZvciBBZGRFeHByX3BsdXNcbiAgICAvLyBzaG91bGQgYXBwZWFyIG5leHQgdG8gb3RoZXIgY2FzZXMgb2YgQWRkRXhwci5cblxuICAgIGNvbnN0IHNiID0gbmV3IGNvbW1vbi5TdHJpbmdCdWZmZXIoKTtcbiAgICBzYi5hcHBlbmQoJ3snKTtcblxuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBydWxlTmFtZSBpbiB0aGlzLnJ1bGVzKSB7XG4gICAgICBjb25zdCBib2R5ID0gdGhpcy5ydWxlc1tydWxlTmFtZV0uYm9keTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2IuYXBwZW5kKCcsJyk7XG4gICAgICB9XG4gICAgICBzYi5hcHBlbmQoJ1xcbicpO1xuICAgICAgc2IuYXBwZW5kKCcgICcpO1xuICAgICAgdGhpcy5hZGRTZW1hbnRpY0FjdGlvblRlbXBsYXRlKHJ1bGVOYW1lLCBib2R5LCBzYik7XG4gICAgfVxuXG4gICAgc2IuYXBwZW5kKCdcXG59Jyk7XG4gICAgcmV0dXJuIHNiLmNvbnRlbnRzKCk7XG4gIH0sXG5cbiAgYWRkU2VtYW50aWNBY3Rpb25UZW1wbGF0ZShydWxlTmFtZSwgYm9keSwgc2IpIHtcbiAgICBzYi5hcHBlbmQocnVsZU5hbWUpO1xuICAgIHNiLmFwcGVuZCgnOiBmdW5jdGlvbignKTtcbiAgICBjb25zdCBhcml0eSA9IHRoaXMuX3RvcERvd25BY3Rpb25Bcml0eShydWxlTmFtZSk7XG4gICAgc2IuYXBwZW5kKGNvbW1vbi5yZXBlYXQoJ18nLCBhcml0eSkuam9pbignLCAnKSk7XG4gICAgc2IuYXBwZW5kKCcpIHtcXG4nKTtcbiAgICBzYi5hcHBlbmQoJyAgfScpO1xuICB9LFxuXG4gIC8vIFBhcnNlIGEgc3RyaW5nIHdoaWNoIGV4cHJlc3NlcyBhIHJ1bGUgYXBwbGljYXRpb24gaW4gdGhpcyBncmFtbWFyLCBhbmQgcmV0dXJuIHRoZVxuICAvLyByZXN1bHRpbmcgQXBwbHkgbm9kZS5cbiAgcGFyc2VBcHBsaWNhdGlvbihzdHIpIHtcbiAgICBsZXQgYXBwO1xuICAgIGlmIChzdHIuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgLy8gc2ltcGxlIGFwcGxpY2F0aW9uXG4gICAgICBhcHAgPSBuZXcgcGV4cHJzLkFwcGx5KHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmFtZXRlcml6ZWQgYXBwbGljYXRpb25cbiAgICAgIGNvbnN0IGNzdCA9IG9obUdyYW1tYXIubWF0Y2goc3RyLCAnQmFzZV9hcHBsaWNhdGlvbicpO1xuICAgICAgYXBwID0gYnVpbGRHcmFtbWFyKGNzdCwge30pO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBhcHBsaWNhdGlvbiBpcyB2YWxpZC5cbiAgICBpZiAoIShhcHAucnVsZU5hbWUgaW4gdGhpcy5ydWxlcykpIHtcbiAgICAgIHRocm93IGVycm9ycy51bmRlY2xhcmVkUnVsZShhcHAucnVsZU5hbWUsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hbHMgPSB0aGlzLnJ1bGVzW2FwcC5ydWxlTmFtZV0uZm9ybWFscztcbiAgICBpZiAoZm9ybWFscy5sZW5ndGggIT09IGFwcC5hcmdzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5ydWxlc1thcHAucnVsZU5hbWVdLnNvdXJjZTtcbiAgICAgIHRocm93IGVycm9ycy53cm9uZ051bWJlck9mUGFyYW1ldGVycyhhcHAucnVsZU5hbWUsIGZvcm1hbHMubGVuZ3RoLCBhcHAuYXJncy5sZW5ndGgsIHNvdXJjZSk7XG4gICAgfVxuICAgIHJldHVybiBhcHA7XG4gIH1cbn07XG5cbi8vIFRoZSBmb2xsb3dpbmcgZ3JhbW1hciBjb250YWlucyBhIGZldyBydWxlcyB0aGF0IGNvdWxkbid0IGJlIHdyaXR0ZW4gIGluIFwidXNlcmxhbmRcIi5cbi8vIEF0IHRoZSBib3R0b20gb2Ygc3JjL21haW4uanMsIHdlIGNyZWF0ZSBhIHN1Yi1ncmFtbWFyIG9mIHRoaXMgZ3JhbW1hciB0aGF0J3MgY2FsbGVkXG4vLyBgQnVpbHRJblJ1bGVzYC4gVGhhdCBncmFtbWFyIGNvbnRhaW5zIHNldmVyYWwgY29udmVuaWVuY2UgcnVsZXMsIGUuZy4sIGBsZXR0ZXJgIGFuZFxuLy8gYGRpZ2l0YCwgYW5kIGlzIGltcGxpY2l0bHkgdGhlIHN1cGVyLWdyYW1tYXIgb2YgYW55IGdyYW1tYXIgd2hvc2Ugc3VwZXItZ3JhbW1hclxuLy8gaXNuJ3Qgc3BlY2lmaWVkLlxuR3JhbW1hci5Qcm90b0J1aWx0SW5SdWxlcyA9IG5ldyBHcmFtbWFyKFxuICAgICdQcm90b0J1aWx0SW5SdWxlcycsIC8vIG5hbWVcbiAgICB1bmRlZmluZWQsIC8vIHN1cGVyZ3JhbW1hclxuICAgIHtcbiAgICAgIGFueToge1xuICAgICAgICBib2R5OiBwZXhwcnMuYW55LFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdhbnkgY2hhcmFjdGVyJyxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIGJvZHk6IHBleHBycy5lbmQsXG4gICAgICAgIGZvcm1hbHM6IFtdLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2VuZCBvZiBpbnB1dCcsXG4gICAgICAgIHByaW1pdGl2ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgY2FzZUluc2Vuc2l0aXZlOiB7XG4gICAgICAgIGJvZHk6IG5ldyBDYXNlSW5zZW5zaXRpdmVUZXJtaW5hbChuZXcgcGV4cHJzLlBhcmFtKDApKSxcbiAgICAgICAgZm9ybWFsczogWydzdHInXSxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgbG93ZXI6IHtcbiAgICAgICAgYm9keTogbmV3IHBleHBycy5Vbmljb2RlQ2hhcignTGwnKSxcbiAgICAgICAgZm9ybWFsczogW10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnYSBsb3dlcmNhc2UgbGV0dGVyJyxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBwZXI6IHtcbiAgICAgICAgYm9keTogbmV3IHBleHBycy5Vbmljb2RlQ2hhcignTHUnKSxcbiAgICAgICAgZm9ybWFsczogW10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnYW4gdXBwZXJjYXNlIGxldHRlcicsXG4gICAgICAgIHByaW1pdGl2ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIFVuaW9uIG9mIEx0ICh0aXRsZWNhc2UpLCBMbSAobW9kaWZpZXIpLCBhbmQgTG8gKG90aGVyKSwgaS5lLiBhbnkgbGV0dGVyIG5vdCBpbiBMbCBvciBMdS5cbiAgICAgIHVuaWNvZGVMdG1vOiB7XG4gICAgICAgIGJvZHk6IG5ldyBwZXhwcnMuVW5pY29kZUNoYXIoJ0x0bW8nKSxcbiAgICAgICAgZm9ybWFsczogW10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnYSBVbmljb2RlIGNoYXJhY3RlciBpbiBMdCwgTG0sIG9yIExvJyxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvLyBUaGVzZSBydWxlcyBhcmUgbm90IHRydWx5IHByaW1pdGl2ZSAodGhleSBjb3VsZCBiZSB3cml0dGVuIGluIHVzZXJsYW5kKSBidXQgYXJlIGRlZmluZWRcbiAgICAgIC8vIGhlcmUgZm9yIGJvb3RzdHJhcHBpbmcgcHVycG9zZXMuXG4gICAgICBzcGFjZXM6IHtcbiAgICAgICAgYm9keTogbmV3IHBleHBycy5TdGFyKG5ldyBwZXhwcnMuQXBwbHkoJ3NwYWNlJykpLFxuICAgICAgICBmb3JtYWxzOiBbXVxuICAgICAgfSxcbiAgICAgIHNwYWNlOiB7XG4gICAgICAgIGJvZHk6IG5ldyBwZXhwcnMuUmFuZ2UoJ1xceDAwJywgJyAnKSxcbiAgICAgICAgZm9ybWFsczogW10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnYSBzcGFjZSdcbiAgICAgIH1cbiAgICB9XG4pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFtbWFyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgR3JhbW1hciA9IHJlcXVpcmUoJy4vR3JhbW1hcicpO1xuY29uc3QgSW5wdXRTdHJlYW0gPSByZXF1aXJlKCcuL0lucHV0U3RyZWFtJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIFN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBDb25zdHJ1Y3RvcnNcblxuZnVuY3Rpb24gR3JhbW1hckRlY2wobmFtZSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufVxuXG4vLyBIZWxwZXJzXG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5zb3VyY2VJbnRlcnZhbCA9IGZ1bmN0aW9uKHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlLnN1YkludGVydmFsKHN0YXJ0SWR4LCBlbmRJZHggLSBzdGFydElkeCk7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuZW5zdXJlU3VwZXJHcmFtbWFyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5zdXBlckdyYW1tYXIpIHtcbiAgICB0aGlzLndpdGhTdXBlckdyYW1tYXIoXG4gICAgICAgIC8vIFRPRE86IFRoZSBjb25kaXRpb25hbCBleHByZXNzaW9uIGJlbG93IGlzIGFuIHVnbHkgaGFjay4gSXQncyBraW5kIG9mIG9rIGJlY2F1c2VcbiAgICAgICAgLy8gSSBkb3VidCBhbnlvbmUgd2lsbCBldmVyIHRyeSB0byBkZWNsYXJlIGEgZ3JhbW1hciBjYWxsZWQgYEJ1aWx0SW5SdWxlc2AuIFN0aWxsLFxuICAgICAgICAvLyB3ZSBzaG91bGQgdHJ5IHRvIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMuXG4gICAgICAgIHRoaXMubmFtZSA9PT0gJ0J1aWx0SW5SdWxlcycgP1xuICAgICAgICAgICAgR3JhbW1hci5Qcm90b0J1aWx0SW5SdWxlcyA6XG4gICAgICAgICAgICBHcmFtbWFyLkJ1aWx0SW5SdWxlcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc3VwZXJHcmFtbWFyO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLmVuc3VyZVN1cGVyR3JhbW1hclJ1bGVGb3JPdmVycmlkaW5nID0gZnVuY3Rpb24obmFtZSwgc291cmNlKSB7XG4gIGNvbnN0IHJ1bGVJbmZvID0gdGhpcy5lbnN1cmVTdXBlckdyYW1tYXIoKS5ydWxlc1tuYW1lXTtcbiAgaWYgKCFydWxlSW5mbykge1xuICAgIHRocm93IGVycm9ycy5jYW5ub3RPdmVycmlkZVVuZGVjbGFyZWRSdWxlKG5hbWUsIHRoaXMuc3VwZXJHcmFtbWFyLm5hbWUsIHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIHJ1bGVJbmZvO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLmluc3RhbGxPdmVycmlkZGVuT3JFeHRlbmRlZFJ1bGUgPSBmdW5jdGlvbihuYW1lLCBmb3JtYWxzLCBib2R5LCBzb3VyY2UpIHtcbiAgY29uc3QgZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMgPSBjb21tb24uZ2V0RHVwbGljYXRlcyhmb3JtYWxzKTtcbiAgaWYgKGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBlcnJvcnMuZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMobmFtZSwgZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMsIHNvdXJjZSk7XG4gIH1cbiAgY29uc3QgcnVsZUluZm8gPSB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hcigpLnJ1bGVzW25hbWVdO1xuICBjb25zdCBleHBlY3RlZEZvcm1hbHMgPSBydWxlSW5mby5mb3JtYWxzO1xuICBjb25zdCBleHBlY3RlZE51bUZvcm1hbHMgPSBleHBlY3RlZEZvcm1hbHMgPyBleHBlY3RlZEZvcm1hbHMubGVuZ3RoIDogMDtcbiAgaWYgKGZvcm1hbHMubGVuZ3RoICE9PSBleHBlY3RlZE51bUZvcm1hbHMpIHtcbiAgICB0aHJvdyBlcnJvcnMud3JvbmdOdW1iZXJPZlBhcmFtZXRlcnMobmFtZSwgZXhwZWN0ZWROdW1Gb3JtYWxzLCBmb3JtYWxzLmxlbmd0aCwgc291cmNlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5pbnN0YWxsKG5hbWUsIGZvcm1hbHMsIGJvZHksIHJ1bGVJbmZvLmRlc2NyaXB0aW9uLCBzb3VyY2UpO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbihuYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjcmlwdGlvbiwgc291cmNlKSB7XG4gIHRoaXMucnVsZXNbbmFtZV0gPSB7XG4gICAgYm9keTogYm9keS5pbnRyb2R1Y2VQYXJhbXMoZm9ybWFscyksXG4gICAgZm9ybWFscyxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzb3VyY2VcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBTdHVmZiB0aGF0IHlvdSBzaG91bGQgb25seSBkbyBvbmNlXG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS53aXRoU3VwZXJHcmFtbWFyID0gZnVuY3Rpb24oc3VwZXJHcmFtbWFyKSB7XG4gIGlmICh0aGlzLnN1cGVyR3JhbW1hcikge1xuICAgIHRocm93IG5ldyBFcnJvcigndGhlIHN1cGVyIGdyYW1tYXIgb2YgYSBHcmFtbWFyRGVjbCBjYW5ub3QgYmUgc2V0IG1vcmUgdGhhbiBvbmNlJyk7XG4gIH1cbiAgdGhpcy5zdXBlckdyYW1tYXIgPSBzdXBlckdyYW1tYXI7XG4gIHRoaXMucnVsZXMgPSBPYmplY3QuY3JlYXRlKHN1cGVyR3JhbW1hci5ydWxlcyk7XG5cbiAgLy8gR3JhbW1hcnMgd2l0aCBhbiBleHBsaWNpdCBzdXBlcmdyYW1tYXIgaW5oZXJpdCBhIGRlZmF1bHQgc3RhcnQgcnVsZS5cbiAgaWYgKCFzdXBlckdyYW1tYXIuaXNCdWlsdEluKCkpIHtcbiAgICB0aGlzLmRlZmF1bHRTdGFydFJ1bGUgPSBzdXBlckdyYW1tYXIuZGVmYXVsdFN0YXJ0UnVsZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS53aXRoRGVmYXVsdFN0YXJ0UnVsZSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIHRoaXMuZGVmYXVsdFN0YXJ0UnVsZSA9IHJ1bGVOYW1lO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS53aXRoU291cmNlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIHRoaXMuc291cmNlID0gbmV3IElucHV0U3RyZWFtKHNvdXJjZSkuaW50ZXJ2YWwoMCwgc291cmNlLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gQ3JlYXRlcyBhIEdyYW1tYXIgaW5zdGFuY2UsIGFuZCBpZiBpdCBwYXNzZXMgdGhlIHNhbml0eSBjaGVja3MsIHJldHVybnMgaXQuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZ3JhbW1hciA9IG5ldyBHcmFtbWFyKFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgdGhpcy5lbnN1cmVTdXBlckdyYW1tYXIoKSxcbiAgICAgIHRoaXMucnVsZXMsXG4gICAgICB0aGlzLmRlZmF1bHRTdGFydFJ1bGUpO1xuXG4gIC8vIFRPRE86IGNoYW5nZSB0aGUgcGV4cHIucHJvdG90eXBlLmFzc2VydC4uLiBtZXRob2RzIHRvIG1ha2UgdGhlbSBhZGRcbiAgLy8gZXhjZXB0aW9ucyB0byBhbiBhcnJheSB0aGF0J3MgcHJvdmlkZWQgYXMgYW4gYXJnLiBUaGVuIHdlJ2xsIGJlIGFibGUgdG9cbiAgLy8gc2hvdyBtb3JlIHRoYW4gb25lIGVycm9yIG9mIHRoZSBzYW1lIHR5cGUgYXQgYSB0aW1lLlxuICAvLyBUT0RPOiBpbmNsdWRlIHRoZSBvZmZlbmRpbmcgcGV4cHIgaW4gdGhlIGVycm9ycywgdGhhdCB3YXkgd2UgY2FuIHNob3dcbiAgLy8gdGhlIHBhcnQgb2YgdGhlIHNvdXJjZSB0aGF0IGNhdXNlZCBpdC5cbiAgY29uc3QgZ3JhbW1hckVycm9ycyA9IFtdO1xuICBsZXQgZ3JhbW1hckhhc0ludmFsaWRBcHBsaWNhdGlvbnMgPSBmYWxzZTtcbiAgT2JqZWN0LmtleXMoZ3JhbW1hci5ydWxlcykuZm9yRWFjaChydWxlTmFtZSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGdyYW1tYXIucnVsZXNbcnVsZU5hbWVdLmJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkocnVsZU5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGdyYW1tYXJFcnJvcnMucHVzaChlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkuYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGdyYW1tYXJFcnJvcnMucHVzaChlKTtcbiAgICAgIGdyYW1tYXJIYXNJbnZhbGlkQXBwbGljYXRpb25zID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIWdyYW1tYXJIYXNJbnZhbGlkQXBwbGljYXRpb25zKSB7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBjYW4gb25seSBiZSBkb25lIGlmIHRoZSBncmFtbWFyIGhhcyBubyBpbnZhbGlkIGFwcGxpY2F0aW9ucy5cbiAgICBPYmplY3Qua2V5cyhncmFtbWFyLnJ1bGVzKS5mb3JFYWNoKHJ1bGVOYW1lID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBncmFtbWFyLnJ1bGVzW3J1bGVOYW1lXS5ib2R5O1xuICAgICAgdHJ5IHtcbiAgICAgICAgYm9keS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUoZ3JhbW1hciwgW10pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBncmFtbWFyRXJyb3JzLnB1c2goZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKGdyYW1tYXJFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIGVycm9ycy50aHJvd0Vycm9ycyhncmFtbWFyRXJyb3JzKTtcbiAgfVxuICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICBncmFtbWFyLnNvdXJjZSA9IHRoaXMuc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIGdyYW1tYXI7XG59O1xuXG4vLyBSdWxlIGRlY2xhcmF0aW9uc1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24obmFtZSwgZm9ybWFscywgYm9keSwgZGVzY3JpcHRpb24sIHNvdXJjZSkge1xuICB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hcigpO1xuICBpZiAodGhpcy5zdXBlckdyYW1tYXIucnVsZXNbbmFtZV0pIHtcbiAgICB0aHJvdyBlcnJvcnMuZHVwbGljYXRlUnVsZURlY2xhcmF0aW9uKG5hbWUsIHRoaXMubmFtZSwgdGhpcy5zdXBlckdyYW1tYXIubmFtZSwgc291cmNlKTtcbiAgfSBlbHNlIGlmICh0aGlzLnJ1bGVzW25hbWVdKSB7XG4gICAgdGhyb3cgZXJyb3JzLmR1cGxpY2F0ZVJ1bGVEZWNsYXJhdGlvbihuYW1lLCB0aGlzLm5hbWUsIHRoaXMubmFtZSwgc291cmNlKTtcbiAgfVxuICBjb25zdCBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyA9IGNvbW1vbi5nZXREdXBsaWNhdGVzKGZvcm1hbHMpO1xuICBpZiAoZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IGVycm9ycy5kdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyhuYW1lLCBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcywgc291cmNlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5pbnN0YWxsKG5hbWUsIGZvcm1hbHMsIGJvZHksIGRlc2NyaXB0aW9uLCBzb3VyY2UpO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLm92ZXJyaWRlID0gZnVuY3Rpb24obmFtZSwgZm9ybWFscywgYm9keSwgZGVzY0lnbm9yZWQsIHNvdXJjZSkge1xuICB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hclJ1bGVGb3JPdmVycmlkaW5nKG5hbWUsIHNvdXJjZSk7XG4gIHRoaXMuaW5zdGFsbE92ZXJyaWRkZW5PckV4dGVuZGVkUnVsZShuYW1lLCBmb3JtYWxzLCBib2R5LCBzb3VyY2UpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihuYW1lLCBmb3JtYWxzLCBmcmFnbWVudCwgZGVzY0lnbm9yZWQsIHNvdXJjZSkge1xuICBjb25zdCBydWxlSW5mbyA9IHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyKCkucnVsZXNbbmFtZV07XG4gIGlmICghcnVsZUluZm8pIHtcbiAgICB0aHJvdyBlcnJvcnMuY2Fubm90RXh0ZW5kVW5kZWNsYXJlZFJ1bGUobmFtZSwgdGhpcy5zdXBlckdyYW1tYXIubmFtZSwgc291cmNlKTtcbiAgfVxuICBjb25zdCBib2R5ID0gbmV3IHBleHBycy5FeHRlbmQodGhpcy5zdXBlckdyYW1tYXIsIG5hbWUsIGZyYWdtZW50KTtcbiAgYm9keS5zb3VyY2UgPSBmcmFnbWVudC5zb3VyY2U7XG4gIHRoaXMuaW5zdGFsbE92ZXJyaWRkZW5PckV4dGVuZGVkUnVsZShuYW1lLCBmb3JtYWxzLCBib2R5LCBzb3VyY2UpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYW1tYXJEZWNsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBJbnB1dFN0cmVhbShzb3VyY2UpIHtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5leGFtaW5lZExlbmd0aCA9IDA7XG59XG5cbklucHV0U3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgYXRFbmQoKSB7XG4gICAgY29uc3QgYW5zID0gdGhpcy5wb3MgPT09IHRoaXMuc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLmV4YW1pbmVkTGVuZ3RoID0gTWF0aC5tYXgodGhpcy5leGFtaW5lZExlbmd0aCwgdGhpcy5wb3MgKyAxKTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIG5leHQoKSB7XG4gICAgY29uc3QgYW5zID0gdGhpcy5zb3VyY2VbdGhpcy5wb3MrK107XG4gICAgdGhpcy5leGFtaW5lZExlbmd0aCA9IE1hdGgubWF4KHRoaXMuZXhhbWluZWRMZW5ndGgsIHRoaXMucG9zKTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIG1hdGNoU3RyaW5nKHMsIG9wdElnbm9yZUNhc2UpIHtcbiAgICBsZXQgaWR4O1xuICAgIGlmIChvcHRJZ25vcmVDYXNlKSB7XG4gICAgICAvKlxuICAgICAgICBDYXNlLWluc2Vuc2l0aXZlIGNvbXBhcmlzb24gaXMgYSB0cmlja3kgYnVzaW5lc3MuIFNvbWUgbm90YWJsZSBnb3RjaGFzIGluY2x1ZGUgdGhlXG4gICAgICAgIFwiVHVya2lzaCBJXCIgcHJvYmxlbSAoaHR0cDovL3d3dy5pMThuZ3V5LmNvbS91bmljb2RlL3R1cmtpc2gtaTE4bi5odG1sKSBhbmQgdGhlIGZhY3RcbiAgICAgICAgdGhhdCB0aGUgR2VybWFuIEVzc3pldCAow58pIHR1cm5zIGludG8gXCJTU1wiIGluIHVwcGVyIGNhc2UuXG5cbiAgICAgICAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhIGxvY2FsZS1pbnZhcmlhbnQgY29tcGFyaXNvbiwgd2hpY2ggbWVhbnMgaXQgbWF5IG5vdCBvYmV5XG4gICAgICAgIGxvY2FsZS1zcGVjaWZpYyBleHBlY3RhdGlvbnMgKGUuZy4gXCJpXCIgPT4gXCLEsFwiKS5cbiAgICAgICAqL1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgY29uc3QgYWN0dWFsID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gc1tpZHhdO1xuICAgICAgICBpZiAoYWN0dWFsID09IG51bGwgfHwgYWN0dWFsLnRvVXBwZXJDYXNlKCkgIT09IGV4cGVjdGVkLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IGlzIGNhc2Utc2Vuc2l0aXZlIGNvbXBhcmlzb24uXG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmICh0aGlzLm5leHQoKSAhPT0gc1tpZHhdKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBzb3VyY2VTbGljZShzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpO1xuICB9LFxuXG4gIGludGVydmFsKHN0YXJ0SWR4LCBvcHRFbmRJZHgpIHtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlLCBzdGFydElkeCwgb3B0RW5kSWR4ID8gb3B0RW5kSWR4IDogdGhpcy5wb3MpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dFN0cmVhbTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJy4vY29tbW9uJykuYXNzZXJ0O1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEludGVydmFsKHNvdXJjZVN0cmluZywgc3RhcnRJZHgsIGVuZElkeCkge1xuICB0aGlzLnNvdXJjZVN0cmluZyA9IHNvdXJjZVN0cmluZztcbiAgdGhpcy5zdGFydElkeCA9IHN0YXJ0SWR4O1xuICB0aGlzLmVuZElkeCA9IGVuZElkeDtcbn1cblxuSW50ZXJ2YWwuY292ZXJhZ2UgPSBmdW5jdGlvbigvKiBpbnRlcnZhbDEsIGludGVydmFsMiwgLi4uICovKSB7XG4gIGNvbnN0IHNvdXJjZVN0cmluZyA9IGFyZ3VtZW50c1swXS5zb3VyY2VTdHJpbmc7XG4gIGxldCBzdGFydElkeCA9IGFyZ3VtZW50c1swXS5zdGFydElkeDtcbiAgbGV0IGVuZElkeCA9IGFyZ3VtZW50c1swXS5lbmRJZHg7XG4gIGZvciAobGV0IGlkeCA9IDE7IGlkeCA8IGFyZ3VtZW50cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBhcmd1bWVudHNbaWR4XTtcbiAgICBpZiAoaW50ZXJ2YWwuc291cmNlU3RyaW5nICE9PSBzb3VyY2VTdHJpbmcpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbnRlcnZhbFNvdXJjZXNEb250TWF0Y2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJZHggPSBNYXRoLm1pbihzdGFydElkeCwgYXJndW1lbnRzW2lkeF0uc3RhcnRJZHgpO1xuICAgICAgZW5kSWR4ID0gTWF0aC5tYXgoZW5kSWR4LCBhcmd1bWVudHNbaWR4XS5lbmRJZHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEludGVydmFsKHNvdXJjZVN0cmluZywgc3RhcnRJZHgsIGVuZElkeCk7XG59O1xuXG5JbnRlcnZhbC5wcm90b3R5cGUgPSB7XG4gIGNvdmVyYWdlV2l0aCgvKiBpbnRlcnZhbDEsIGludGVydmFsMiwgLi4uICovKSB7XG4gICAgY29uc3QgaW50ZXJ2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpbnRlcnZhbHMucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuY292ZXJhZ2UuYXBwbHkodW5kZWZpbmVkLCBpbnRlcnZhbHMpO1xuICB9LFxuXG4gIGNvbGxhcHNlZExlZnQoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCwgdGhpcy5zdGFydElkeCk7XG4gIH0sXG5cbiAgY29sbGFwc2VkUmlnaHQoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5lbmRJZHgsIHRoaXMuZW5kSWR4KTtcbiAgfSxcblxuICBnZXRMaW5lQW5kQ29sdW1uKCkge1xuICAgIHJldHVybiB1dGlsLmdldExpbmVBbmRDb2x1bW4odGhpcy5zb3VyY2VTdHJpbmcsIHRoaXMuc3RhcnRJZHgpO1xuICB9LFxuXG4gIGdldExpbmVBbmRDb2x1bW5NZXNzYWdlKCkge1xuICAgIGNvbnN0IHJhbmdlID0gW3RoaXMuc3RhcnRJZHgsIHRoaXMuZW5kSWR4XTtcbiAgICByZXR1cm4gdXRpbC5nZXRMaW5lQW5kQ29sdW1uTWVzc2FnZSh0aGlzLnNvdXJjZVN0cmluZywgdGhpcy5zdGFydElkeCwgcmFuZ2UpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgMCwgMSwgb3IgMiBpbnRlcnZhbHMgdGhhdCByZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgdGhlXG4gIC8vIGludGVydmFsIGRpZmZlcmVuY2Ugb3BlcmF0aW9uLlxuICBtaW51cyh0aGF0KSB7XG4gICAgaWYgKHRoaXMuc291cmNlU3RyaW5nICE9PSB0aGF0LnNvdXJjZVN0cmluZykge1xuICAgICAgdGhyb3cgZXJyb3JzLmludGVydmFsU291cmNlc0RvbnRNYXRjaCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGFydElkeCA9PT0gdGhhdC5zdGFydElkeCAmJiB0aGlzLmVuZElkeCA9PT0gdGhhdC5lbmRJZHgpIHtcbiAgICAgIC8vIGB0aGlzYCBhbmQgYHRoYXRgIGFyZSB0aGUgc2FtZSBpbnRlcnZhbCFcbiAgICAgIHJldHVybiBbXG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGFydElkeCA8IHRoYXQuc3RhcnRJZHggJiYgdGhhdC5lbmRJZHggPCB0aGlzLmVuZElkeCkge1xuICAgICAgLy8gYHRoYXRgIHNwbGl0cyBgdGhpc2AgaW50byB0d28gaW50ZXJ2YWxzXG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHRoaXMuc3RhcnRJZHgsIHRoYXQuc3RhcnRJZHgpLFxuICAgICAgICBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHRoYXQuZW5kSWR4LCB0aGlzLmVuZElkeClcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0SWR4IDwgdGhhdC5lbmRJZHggJiYgdGhhdC5lbmRJZHggPCB0aGlzLmVuZElkeCkge1xuICAgICAgLy8gYHRoYXRgIGNvbnRhaW5zIGEgcHJlZml4IG9mIGB0aGlzYFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGF0LmVuZElkeCwgdGhpcy5lbmRJZHgpXG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGFydElkeCA8IHRoYXQuc3RhcnRJZHggJiYgdGhhdC5zdGFydElkeCA8IHRoaXMuZW5kSWR4KSB7XG4gICAgICAvLyBgdGhhdGAgY29udGFpbnMgYSBzdWZmaXggb2YgYHRoaXNgXG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHRoaXMuc3RhcnRJZHgsIHRoYXQuc3RhcnRJZHgpXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBgdGhhdGAgYW5kIGB0aGlzYCBkbyBub3Qgb3ZlcmxhcFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpc1xuICAgICAgXTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIG5ldyBJbnRlcnZhbCB0aGF0IGhhcyB0aGUgc2FtZSBleHRlbnQgYXMgdGhpcyBvbmUsIGJ1dCB3aGljaCBpcyByZWxhdGl2ZVxuICAvLyB0byBgdGhhdGAsIGFuIEludGVydmFsIHRoYXQgZnVsbHkgY292ZXJzIHRoaXMgb25lLlxuICByZWxhdGl2ZVRvKHRoYXQpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VTdHJpbmcgIT09IHRoYXQuc291cmNlU3RyaW5nKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW50ZXJ2YWxTb3VyY2VzRG9udE1hdGNoKCk7XG4gICAgfVxuICAgIGFzc2VydCh0aGlzLnN0YXJ0SWR4ID49IHRoYXQuc3RhcnRJZHggJiYgdGhpcy5lbmRJZHggPD0gdGhhdC5lbmRJZHgsXG4gICAgICAgICdvdGhlciBpbnRlcnZhbCBkb2VzIG5vdCBjb3ZlciB0aGlzIG9uZScpO1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsXG4gICAgICAgIHRoaXMuc3RhcnRJZHggLSB0aGF0LnN0YXJ0SWR4LFxuICAgICAgICB0aGlzLmVuZElkeCAtIHRoYXQuc3RhcnRJZHgpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBuZXcgSW50ZXJ2YWwgd2hpY2ggY29udGFpbnMgdGhlIHNhbWUgY29udGVudHMgYXMgdGhpcyBvbmUsXG4gIC8vIGJ1dCB3aXRoIHdoaXRlc3BhY2UgdHJpbW1lZCBmcm9tIGJvdGggZW5kcy4gKFRoaXMgb25seSBtYWtlcyBzZW5zZSB3aGVuXG4gIC8vIHRoZSBpbnB1dCBzdHJlYW0gaXMgYSBzdHJpbmcuKVxuICB0cmltbWVkKCkge1xuICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb250ZW50cztcbiAgICBjb25zdCBzdGFydElkeCA9IHRoaXMuc3RhcnRJZHggKyBjb250ZW50cy5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG4gICAgY29uc3QgZW5kSWR4ID0gdGhpcy5lbmRJZHggLSBjb250ZW50cy5tYXRjaCgvXFxzKiQvKVswXS5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgc3RhcnRJZHgsIGVuZElkeCk7XG4gIH0sXG5cbiAgc3ViSW50ZXJ2YWwob2Zmc2V0LCBsZW4pIHtcbiAgICBjb25zdCBuZXdTdGFydElkeCA9IHRoaXMuc3RhcnRJZHggKyBvZmZzZXQ7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgbmV3U3RhcnRJZHgsIG5ld1N0YXJ0SWR4ICsgbGVuKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSW50ZXJ2YWwucHJvdG90eXBlLCB7XG4gIGNvbnRlbnRzOiB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fY29udGVudHMgPSB0aGlzLnNvdXJjZVN0cmluZy5zbGljZSh0aGlzLnN0YXJ0SWR4LCB0aGlzLmVuZElkeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudHM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sXG4gIGxlbmd0aDoge1xuICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuZW5kSWR4IC0gdGhpcy5zdGFydElkeDsgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnZhbDtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEludGVydmFsID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gTWF0Y2hSZXN1bHQoXG4gICAgbWF0Y2hlcixcbiAgICBpbnB1dCxcbiAgICBzdGFydEV4cHIsXG4gICAgY3N0LFxuICAgIGNzdE9mZnNldCxcbiAgICByaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sXG4gICAgb3B0UmVjb3JkZWRGYWlsdXJlcykge1xuXG4gIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5zdGFydEV4cHIgPSBzdGFydEV4cHI7XG4gIHRoaXMuX2NzdCA9IGNzdDtcbiAgdGhpcy5fY3N0T2Zmc2V0ID0gY3N0T2Zmc2V0O1xuICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSByaWdodG1vc3RGYWlsdXJlUG9zaXRpb247XG4gIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVzID0gb3B0UmVjb3JkZWRGYWlsdXJlcztcblxuICBpZiAodGhpcy5mYWlsZWQoKSkge1xuICAgIGNvbW1vbi5kZWZpbmVMYXp5UHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGRldGFpbCA9ICdFeHBlY3RlZCAnICsgdGhpcy5nZXRFeHBlY3RlZFRleHQoKTtcbiAgICAgIHJldHVybiB1dGlsLmdldExpbmVBbmRDb2x1bW5NZXNzYWdlKHRoaXMuaW5wdXQsIHRoaXMuZ2V0UmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKCkpICsgZGV0YWlsO1xuICAgIH0pO1xuICAgIGNvbW1vbi5kZWZpbmVMYXp5UHJvcGVydHkodGhpcywgJ3Nob3J0TWVzc2FnZScsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGV0YWlsID0gJ2V4cGVjdGVkICcgKyB0aGlzLmdldEV4cGVjdGVkVGV4dCgpO1xuICAgICAgY29uc3QgZXJyb3JJbmZvID0gdXRpbC5nZXRMaW5lQW5kQ29sdW1uKHRoaXMuaW5wdXQsIHRoaXMuZ2V0UmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKCkpO1xuICAgICAgcmV0dXJuICdMaW5lICcgKyBlcnJvckluZm8ubGluZU51bSArICcsIGNvbCAnICsgZXJyb3JJbmZvLmNvbE51bSArICc6ICcgKyBkZXRhaWw7XG4gICAgfSk7XG4gIH1cbn1cblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLnN1Y2NlZWRlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLl9jc3Q7XG59O1xuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuZmFpbGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5zdWNjZWVkZWQoKTtcbn07XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbjtcbn07XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS5nZXRSaWdodG1vc3RGYWlsdXJlcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVzKSB7XG4gICAgdGhpcy5tYXRjaGVyLnNldElucHV0KHRoaXMuaW5wdXQpO1xuICAgIGNvbnN0IG1hdGNoUmVzdWx0V2l0aEZhaWx1cmVzID1cbiAgICAgICAgdGhpcy5tYXRjaGVyLl9tYXRjaCh0aGlzLnN0YXJ0RXhwciwgZmFsc2UsIHRoaXMuZ2V0UmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKCkpO1xuICAgIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVzID0gbWF0Y2hSZXN1bHRXaXRoRmFpbHVyZXMuZ2V0UmlnaHRtb3N0RmFpbHVyZXMoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fcmlnaHRtb3N0RmFpbHVyZXM7XG59O1xuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3VjY2VlZGVkKCkgP1xuICAgICAgJ1ttYXRjaCBzdWNjZWVkZWRdJyA6XG4gICAgICAnW21hdGNoIGZhaWxlZCBhdCBwb3NpdGlvbiAnICsgdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSArICddJztcbn07XG5cbi8vIFJldHVybiBhIHN0cmluZyBzdW1tYXJpemluZyB0aGUgZXhwZWN0ZWQgY29udGVudHMgb2YgdGhlIGlucHV0IHN0cmVhbSB3aGVuXG4vLyB0aGUgbWF0Y2ggZmFpbHVyZSBvY2N1cnJlZC5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS5nZXRFeHBlY3RlZFRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3VjY2VlZGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgZXhwZWN0ZWQgdGV4dCBvZiBhIHN1Y2Nlc3NmdWwgTWF0Y2hSZXN1bHQnKTtcbiAgfVxuXG4gIGNvbnN0IHNiID0gbmV3IGNvbW1vbi5TdHJpbmdCdWZmZXIoKTtcbiAgbGV0IGZhaWx1cmVzID0gdGhpcy5nZXRSaWdodG1vc3RGYWlsdXJlcygpO1xuXG4gIC8vIEZpbHRlciBvdXQgdGhlIGZsdWZmeSBmYWlsdXJlcyB0byBtYWtlIHRoZSBkZWZhdWx0IGVycm9yIG1lc3NhZ2VzIG1vcmUgdXNlZnVsXG4gIGZhaWx1cmVzID0gZmFpbHVyZXMuZmlsdGVyKGZhaWx1cmUgPT4gIWZhaWx1cmUuaXNGbHVmZnkoKSk7XG5cbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZmFpbHVyZXMubGVuZ3RoOyBpZHgrKykge1xuICAgIGlmIChpZHggPiAwKSB7XG4gICAgICBpZiAoaWR4ID09PSBmYWlsdXJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHNiLmFwcGVuZChmYWlsdXJlcy5sZW5ndGggPiAyID8gJywgb3IgJyA6ICcgb3IgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzYi5hcHBlbmQoJywgJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHNiLmFwcGVuZChmYWlsdXJlc1tpZHhdLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBzYi5jb250ZW50cygpO1xufTtcblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmdldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKCk7XG4gIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5pbnB1dCwgcG9zLCBwb3MpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0Y2hSZXN1bHQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBJbnB1dFN0cmVhbSA9IHJlcXVpcmUoJy4vSW5wdXRTdHJlYW0nKTtcbmNvbnN0IE1hdGNoUmVzdWx0ID0gcmVxdWlyZSgnLi9NYXRjaFJlc3VsdCcpO1xuY29uc3QgUG9zSW5mbyA9IHJlcXVpcmUoJy4vUG9zSW5mbycpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL1RyYWNlJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYXBwbHlTcGFjZXMgPSBuZXcgcGV4cHJzLkFwcGx5KCdzcGFjZXMnKTtcblxuZnVuY3Rpb24gTWF0Y2hTdGF0ZShtYXRjaGVyLCBzdGFydEV4cHIsIG9wdFBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcykge1xuICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuICB0aGlzLnN0YXJ0RXhwciA9IHN0YXJ0RXhwcjtcblxuICB0aGlzLmdyYW1tYXIgPSBtYXRjaGVyLmdyYW1tYXI7XG4gIHRoaXMuaW5wdXQgPSBtYXRjaGVyLmlucHV0O1xuICB0aGlzLmlucHV0U3RyZWFtID0gbmV3IElucHV0U3RyZWFtKG1hdGNoZXIuaW5wdXQpO1xuICB0aGlzLm1lbW9UYWJsZSA9IG1hdGNoZXIubWVtb1RhYmxlO1xuXG4gIHRoaXMuX2JpbmRpbmdzID0gW107XG4gIHRoaXMuX2JpbmRpbmdPZmZzZXRzID0gW107XG4gIHRoaXMuX2FwcGxpY2F0aW9uU3RhY2sgPSBbXTtcbiAgdGhpcy5fcG9zU3RhY2sgPSBbMF07XG4gIHRoaXMuaW5MZXhpZmllZENvbnRleHRTdGFjayA9IFtmYWxzZV07XG5cbiAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSAtMTtcbiAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uU3RhY2sgPSBbXTtcbiAgdGhpcy5fcmVjb3JkZWRGYWlsdXJlc1N0YWNrID0gW107XG5cbiAgaWYgKG9wdFBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMgPSBvcHRQb3NpdGlvblRvUmVjb3JkRmFpbHVyZXM7XG4gICAgdGhpcy5yZWNvcmRlZEZhaWx1cmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxufVxuXG5NYXRjaFN0YXRlLnByb3RvdHlwZSA9IHtcbiAgcG9zVG9PZmZzZXQocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAtIHRoaXMuX3Bvc1N0YWNrW3RoaXMuX3Bvc1N0YWNrLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIGVudGVyQXBwbGljYXRpb24ocG9zSW5mbywgYXBwKSB7XG4gICAgdGhpcy5fcG9zU3RhY2sucHVzaCh0aGlzLmlucHV0U3RyZWFtLnBvcyk7XG4gICAgdGhpcy5fYXBwbGljYXRpb25TdGFjay5wdXNoKGFwcCk7XG4gICAgdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrLnB1c2goZmFsc2UpO1xuICAgIHBvc0luZm8uZW50ZXIoYXBwKTtcbiAgICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb25TdGFjay5wdXNoKHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKTtcbiAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IC0xO1xuICB9LFxuXG4gIGV4aXRBcHBsaWNhdGlvbihwb3NJbmZvLCBvcHROb2RlKSB7XG4gICAgY29uc3Qgb3JpZ1BvcyA9IHRoaXMuX3Bvc1N0YWNrLnBvcCgpO1xuICAgIHRoaXMuX2FwcGxpY2F0aW9uU3RhY2sucG9wKCk7XG4gICAgdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrLnBvcCgpO1xuICAgIHBvc0luZm8uZXhpdCgpO1xuXG4gICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24sXG4gICAgICAgIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvblN0YWNrLnBvcCgpKTtcblxuICAgIGlmIChvcHROb2RlKSB7XG4gICAgICB0aGlzLnB1c2hCaW5kaW5nKG9wdE5vZGUsIG9yaWdQb3MpO1xuICAgIH1cbiAgfSxcblxuICBlbnRlckxleGlmaWVkQ29udGV4dCgpIHtcbiAgICB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2sucHVzaCh0cnVlKTtcbiAgfSxcblxuICBleGl0TGV4aWZpZWRDb250ZXh0KCkge1xuICAgIHRoaXMuaW5MZXhpZmllZENvbnRleHRTdGFjay5wb3AoKTtcbiAgfSxcblxuICBjdXJyZW50QXBwbGljYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FwcGxpY2F0aW9uU3RhY2tbdGhpcy5fYXBwbGljYXRpb25TdGFjay5sZW5ndGggLSAxXTtcbiAgfSxcblxuICBpblN5bnRhY3RpY0NvbnRleHQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmlucHV0U3RyZWFtLnNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEFwcGxpY2F0aW9uID0gdGhpcy5jdXJyZW50QXBwbGljYXRpb24oKTtcbiAgICBpZiAoY3VycmVudEFwcGxpY2F0aW9uKSB7XG4gICAgICByZXR1cm4gY3VycmVudEFwcGxpY2F0aW9uLmlzU3ludGFjdGljKCkgJiYgIXRoaXMuaW5MZXhpZmllZENvbnRleHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHRvcC1sZXZlbCBjb250ZXh0IGlzIHN5bnRhY3RpYyBpZiB0aGUgc3RhcnQgYXBwbGljYXRpb24gaXMuXG4gICAgICByZXR1cm4gdGhpcy5zdGFydEV4cHIuZmFjdG9yc1swXS5pc1N5bnRhY3RpYygpO1xuICAgIH1cbiAgfSxcblxuICBpbkxleGlmaWVkQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrW3RoaXMuaW5MZXhpZmllZENvbnRleHRTdGFjay5sZW5ndGggLSAxXTtcbiAgfSxcblxuICBza2lwU3BhY2VzKCkge1xuICAgIHRoaXMucHVzaEZhaWx1cmVzSW5mbygpO1xuICAgIHRoaXMuZXZhbChhcHBseVNwYWNlcyk7XG4gICAgdGhpcy5wb3BCaW5kaW5nKCk7XG4gICAgdGhpcy5wb3BGYWlsdXJlc0luZm8oKTtcbiAgICByZXR1cm4gdGhpcy5pbnB1dFN0cmVhbS5wb3M7XG4gIH0sXG5cbiAgc2tpcFNwYWNlc0lmSW5TeW50YWN0aWNDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmluU3ludGFjdGljQ29udGV4dCgpID9cbiAgICAgICAgdGhpcy5za2lwU3BhY2VzKCkgOlxuICAgICAgICB0aGlzLmlucHV0U3RyZWFtLnBvcztcbiAgfSxcblxuICBtYXliZVNraXBTcGFjZXNCZWZvcmUoZXhwcikge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgcGV4cHJzLkFwcGx5ICYmIGV4cHIuaXNTeW50YWN0aWMoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcFNwYWNlcygpO1xuICAgIH0gZWxzZSBpZiAoZXhwci5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlKCkgJiYgZXhwciAhPT0gYXBwbHlTcGFjZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraXBTcGFjZXNJZkluU3ludGFjdGljQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnB1dFN0cmVhbS5wb3M7XG4gICAgfVxuICB9LFxuXG4gIHB1c2hCaW5kaW5nKG5vZGUsIG9yaWdQb3MpIHtcbiAgICB0aGlzLl9iaW5kaW5ncy5wdXNoKG5vZGUpO1xuICAgIHRoaXMuX2JpbmRpbmdPZmZzZXRzLnB1c2godGhpcy5wb3NUb09mZnNldChvcmlnUG9zKSk7XG4gIH0sXG5cbiAgcG9wQmluZGluZygpIHtcbiAgICB0aGlzLl9iaW5kaW5ncy5wb3AoKTtcbiAgICB0aGlzLl9iaW5kaW5nT2Zmc2V0cy5wb3AoKTtcbiAgfSxcblxuICBudW1CaW5kaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuICB9LFxuXG4gIHRydW5jYXRlQmluZGluZ3MobmV3TGVuZ3RoKSB7XG4gICAgLy8gWWVzLCB0aGlzIGlzIHRoaXMgcmVhbGx5IGZhc3RlciB0aGFuIHNldHRpbmcgdGhlIGBsZW5ndGhgIHByb3BlcnR5ICh0ZXN0ZWQgd2l0aFxuICAgIC8vIGJpbi9lczViZW5jaCBvbiBOb2RlIHY2LjEuMCkuXG4gICAgd2hpbGUgKHRoaXMuX2JpbmRpbmdzLmxlbmd0aCA+IG5ld0xlbmd0aCkge1xuICAgICAgdGhpcy5wb3BCaW5kaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIGdldEN1cnJlbnRQb3NJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvc0luZm8odGhpcy5pbnB1dFN0cmVhbS5wb3MpO1xuICB9LFxuXG4gIGdldFBvc0luZm8ocG9zKSB7XG4gICAgbGV0IHBvc0luZm8gPSB0aGlzLm1lbW9UYWJsZVtwb3NdO1xuICAgIGlmICghcG9zSW5mbykge1xuICAgICAgcG9zSW5mbyA9IHRoaXMubWVtb1RhYmxlW3Bvc10gPSBuZXcgUG9zSW5mbygpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zSW5mbztcbiAgfSxcblxuICBwcm9jZXNzRmFpbHVyZShwb3MsIGV4cHIpIHtcbiAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IE1hdGgubWF4KHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uLCBwb3MpO1xuXG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcyAmJiBwb3MgPT09IHRoaXMucG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzLmN1cnJlbnRBcHBsaWNhdGlvbigpO1xuICAgICAgaWYgKGFwcCkge1xuICAgICAgICAvLyBTdWJzdGl0dXRlIHBhcmFtZXRlcnMgd2l0aCB0aGUgYWN0dWFsIHBleHBycyB0aGF0IHdlcmUgcGFzc2VkIHRvXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHJ1bGUuXG4gICAgICAgIGV4cHIgPSBleHByLnN1YnN0aXR1dGVQYXJhbXMoYXBwLmFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBicmFuY2ggaXMgb25seSByZWFjaGVkIGZvciB0aGUgXCJlbmQtY2hlY2tcIiB0aGF0IGlzXG4gICAgICAgIC8vIHBlcmZvcm1lZCBhZnRlciB0aGUgdG9wLWxldmVsIGFwcGxpY2F0aW9uLiBJbiB0aGF0IGNhc2UsXG4gICAgICAgIC8vIGV4cHIgPT09IHBleHBycy5lbmQgc28gdGhlcmUgaXMgbm8gbmVlZCB0byBzdWJzdGl0dXRlXG4gICAgICAgIC8vIHBhcmFtZXRlcnMuXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVjb3JkRmFpbHVyZShleHByLnRvRmFpbHVyZSh0aGlzLmdyYW1tYXIpLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIHJlY29yZEZhaWx1cmUoZmFpbHVyZSwgc2hvdWxkQ2xvbmVJZk5ldykge1xuICAgIGNvbnN0IGtleSA9IGZhaWx1cmUudG9LZXkoKTtcbiAgICBpZiAoIXRoaXMucmVjb3JkZWRGYWlsdXJlc1trZXldKSB7XG4gICAgICB0aGlzLnJlY29yZGVkRmFpbHVyZXNba2V5XSA9IHNob3VsZENsb25lSWZOZXcgPyBmYWlsdXJlLmNsb25lKCkgOiBmYWlsdXJlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzW2tleV0uaXNGbHVmZnkoKSAmJiAhZmFpbHVyZS5pc0ZsdWZmeSgpKSB7XG4gICAgICB0aGlzLnJlY29yZGVkRmFpbHVyZXNba2V5XS5jbGVhckZsdWZmeSgpO1xuICAgIH1cbiAgfSxcblxuICByZWNvcmRGYWlsdXJlcyhmYWlsdXJlcywgc2hvdWxkQ2xvbmVJZk5ldykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGZhaWx1cmVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBzZWxmLnJlY29yZEZhaWx1cmUoZmFpbHVyZXNba2V5XSwgc2hvdWxkQ2xvbmVJZk5ldyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgY2xvbmVSZWNvcmRlZEZhaWx1cmVzKCkge1xuICAgIGlmICghdGhpcy5yZWNvcmRlZEZhaWx1cmVzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGFucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcy5yZWNvcmRlZEZhaWx1cmVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBhbnNba2V5XSA9IHNlbGYucmVjb3JkZWRGYWlsdXJlc1trZXldLmNsb25lKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBnZXRSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uO1xuICB9LFxuXG4gIF9nZXRSaWdodG1vc3RGYWlsdXJlT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA+PSAwID9cbiAgICAgICAgdGhpcy5wb3NUb09mZnNldCh0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbikgOlxuICAgICAgICAtMTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBtZW1vaXplZCB0cmFjZSBlbnRyeSBmb3IgYGV4cHJgIGF0IGBwb3NgLCBpZiBvbmUgZXhpc3RzLCBgbnVsbGAgb3RoZXJ3aXNlLlxuICBnZXRNZW1vaXplZFRyYWNlRW50cnkocG9zLCBleHByKSB7XG4gICAgY29uc3QgcG9zSW5mbyA9IHRoaXMubWVtb1RhYmxlW3Bvc107XG4gICAgaWYgKHBvc0luZm8gJiYgZXhwci5ydWxlTmFtZSkge1xuICAgICAgY29uc3QgbWVtb1JlYyA9IHBvc0luZm8ubWVtb1tleHByLnRvTWVtb0tleSgpXTtcbiAgICAgIGlmIChtZW1vUmVjICYmIG1lbW9SZWMudHJhY2VFbnRyeSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1lbW9SZWMudHJhY2VFbnRyeS5jbG9uZVdpdGhFeHByKGV4cHIpO1xuICAgICAgICBlbnRyeS5pc01lbW9pemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgbmV3IHRyYWNlIGVudHJ5LCB3aXRoIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRyYWNlIGFycmF5IGFzIGl0cyBjaGlsZHJlbi5cbiAgZ2V0VHJhY2VFbnRyeShwb3MsIGV4cHIsIHN1Y2NlZWRlZCwgYmluZGluZ3MpIHtcbiAgICBpZiAoZXhwciBpbnN0YW5jZW9mIHBleHBycy5BcHBseSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcy5jdXJyZW50QXBwbGljYXRpb24oKTtcbiAgICAgIGNvbnN0IGFjdHVhbHMgPSBhcHAgPyBhcHAuYXJncyA6IFtdO1xuICAgICAgZXhwciA9IGV4cHIuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWVtb2l6ZWRUcmFjZUVudHJ5KHBvcywgZXhwcikgfHxcbiAgICAgICAgICAgbmV3IFRyYWNlKHRoaXMuaW5wdXQsIHBvcywgdGhpcy5pbnB1dFN0cmVhbS5wb3MsIGV4cHIsIHN1Y2NlZWRlZCwgYmluZGluZ3MsIHRoaXMudHJhY2UpO1xuICB9LFxuXG4gIGlzVHJhY2luZygpIHtcbiAgICByZXR1cm4gISF0aGlzLnRyYWNlO1xuICB9LFxuXG4gIGhhc05lY2Vzc2FyeUluZm8obWVtb1JlYykge1xuICAgIGlmICh0aGlzLnRyYWNlICYmICFtZW1vUmVjLnRyYWNlRW50cnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzICYmXG4gICAgICAgIHRoaXMuaW5wdXRTdHJlYW0ucG9zICsgbWVtb1JlYy5yaWdodG1vc3RGYWlsdXJlT2Zmc2V0ID09PSB0aGlzLnBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcykge1xuICAgICAgcmV0dXJuICEhbWVtb1JlYy5mYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cblxuICB1c2VNZW1vaXplZFJlc3VsdChvcmlnUG9zLCBtZW1vUmVjKSB7XG4gICAgaWYgKHRoaXMudHJhY2UpIHtcbiAgICAgIHRoaXMudHJhY2UucHVzaChtZW1vUmVjLnRyYWNlRW50cnkpO1xuICAgIH1cblxuICAgIGNvbnN0IG1lbW9SZWNSaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSB0aGlzLmlucHV0U3RyZWFtLnBvcyArIG1lbW9SZWMucmlnaHRtb3N0RmFpbHVyZU9mZnNldDtcbiAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9XG4gICAgICAgIE1hdGgubWF4KHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uLCBtZW1vUmVjUmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKTtcbiAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzICYmXG4gICAgICAgIHRoaXMucG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzID09PSBtZW1vUmVjUmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uICYmXG4gICAgICAgIG1lbW9SZWMuZmFpbHVyZXNBdFJpZ2h0bW9zdFBvc2l0aW9uKSB7XG4gICAgICB0aGlzLnJlY29yZEZhaWx1cmVzKG1lbW9SZWMuZmFpbHVyZXNBdFJpZ2h0bW9zdFBvc2l0aW9uLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoID1cbiAgICAgICAgTWF0aC5tYXgodGhpcy5pbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCwgbWVtb1JlYy5leGFtaW5lZExlbmd0aCArIG9yaWdQb3MpO1xuXG4gICAgaWYgKG1lbW9SZWMudmFsdWUpIHtcbiAgICAgIHRoaXMuaW5wdXRTdHJlYW0ucG9zICs9IG1lbW9SZWMubWF0Y2hMZW5ndGg7XG4gICAgICB0aGlzLnB1c2hCaW5kaW5nKG1lbW9SZWMudmFsdWUsIG9yaWdQb3MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvLyBFdmFsdWF0ZSBgZXhwcmAgYW5kIHJldHVybiBgdHJ1ZWAgaWYgaXQgc3VjY2VlZGVkLCBgZmFsc2VgIG90aGVyd2lzZS4gT24gc3VjY2VzcywgYGJpbmRpbmdzYFxuICAvLyB3aWxsIGhhdmUgYGV4cHIuZ2V0QXJpdHkoKWAgbW9yZSBlbGVtZW50cyB0aGFuIGJlZm9yZSwgYW5kIHRoZSBpbnB1dCBzdHJlYW0ncyBwb3NpdGlvbiBtYXlcbiAgLy8gaGF2ZSBpbmNyZWFzZWQuIE9uIGZhaWx1cmUsIGBiaW5kaW5nc2AgYW5kIHBvc2l0aW9uIHdpbGwgYmUgdW5jaGFuZ2VkLlxuICBldmFsKGV4cHIpIHtcbiAgICBjb25zdCBpbnB1dFN0cmVhbSA9IHRoaXMuaW5wdXRTdHJlYW07XG4gICAgY29uc3Qgb3JpZ051bUJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuXG4gICAgbGV0IG9yaWdSZWNvcmRlZEZhaWx1cmVzO1xuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMpIHtcbiAgICAgIG9yaWdSZWNvcmRlZEZhaWx1cmVzID0gdGhpcy5yZWNvcmRlZEZhaWx1cmVzO1xuICAgICAgdGhpcy5yZWNvcmRlZEZhaWx1cmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICAgIGNvbnN0IG1lbW9Qb3MgPSB0aGlzLm1heWJlU2tpcFNwYWNlc0JlZm9yZShleHByKTtcblxuICAgIGxldCBvcmlnVHJhY2U7XG4gICAgaWYgKHRoaXMudHJhY2UpIHtcbiAgICAgIG9yaWdUcmFjZSA9IHRoaXMudHJhY2U7XG4gICAgICB0aGlzLnRyYWNlID0gW107XG4gICAgfVxuXG4gICAgLy8gRG8gdGhlIGFjdHVhbCBldmFsdWF0aW9uLlxuICAgIGNvbnN0IGFucyA9IGV4cHIuZXZhbCh0aGlzKTtcblxuICAgIGlmICh0aGlzLnRyYWNlKSB7XG4gICAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLnNsaWNlKG9yaWdOdW1CaW5kaW5ncyk7XG4gICAgICBjb25zdCB0cmFjZUVudHJ5ID0gdGhpcy5nZXRUcmFjZUVudHJ5KG1lbW9Qb3MsIGV4cHIsIGFucywgYmluZGluZ3MpO1xuICAgICAgdHJhY2VFbnRyeS5pc0ltcGxpY2l0U3BhY2VzID0gZXhwciA9PT0gYXBwbHlTcGFjZXM7XG4gICAgICB0cmFjZUVudHJ5LmlzUm9vdE5vZGUgPSBleHByID09PSB0aGlzLnN0YXJ0RXhwcjtcbiAgICAgIG9yaWdUcmFjZS5wdXNoKHRyYWNlRW50cnkpO1xuICAgICAgdGhpcy50cmFjZSA9IG9yaWdUcmFjZTtcbiAgICB9XG5cbiAgICBpZiAoYW5zKSB7XG4gICAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzICYmIGlucHV0U3RyZWFtLnBvcyA9PT0gdGhpcy5wb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucmVjb3JkZWRGYWlsdXJlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIHNlbGYucmVjb3JkZWRGYWlsdXJlc1trZXldLm1ha2VGbHVmZnkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBhbmQgdGhlIGJpbmRpbmdzLlxuICAgICAgaW5wdXRTdHJlYW0ucG9zID0gb3JpZ1BvcztcbiAgICAgIHRoaXMudHJ1bmNhdGVCaW5kaW5ncyhvcmlnTnVtQmluZGluZ3MpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMpIHtcbiAgICAgIHRoaXMucmVjb3JkRmFpbHVyZXMob3JpZ1JlY29yZGVkRmFpbHVyZXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIGdldE1hdGNoUmVzdWx0KCkge1xuICAgIHRoaXMuZXZhbCh0aGlzLnN0YXJ0RXhwcik7XG4gICAgbGV0IHJpZ2h0bW9zdEZhaWx1cmVzO1xuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmlnaHRtb3N0RmFpbHVyZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJlY29yZGVkRmFpbHVyZXMpLm1hcChrZXkgPT4gc2VsZi5yZWNvcmRlZEZhaWx1cmVzW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1hdGNoUmVzdWx0KFxuICAgICAgICB0aGlzLm1hdGNoZXIsXG4gICAgICAgIHRoaXMuaW5wdXQsXG4gICAgICAgIHRoaXMuc3RhcnRFeHByLFxuICAgICAgICB0aGlzLl9iaW5kaW5nc1swXSxcbiAgICAgICAgdGhpcy5fYmluZGluZ09mZnNldHNbMF0sXG4gICAgICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uLFxuICAgICAgICByaWdodG1vc3RGYWlsdXJlcyk7XG4gIH0sXG5cbiAgZ2V0VHJhY2UoKSB7XG4gICAgdGhpcy50cmFjZSA9IFtdO1xuICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gdGhpcy5nZXRNYXRjaFJlc3VsdCgpO1xuXG4gICAgLy8gVGhlIHRyYWNlIG5vZGUgZm9yIHRoZSBzdGFydCBydWxlIGlzIGFsd2F5cyB0aGUgbGFzdCBlbnRyeS4gSWYgaXQgaXMgYSBzeW50YWN0aWMgcnVsZSxcbiAgICAvLyB0aGUgZmlyc3QgZW50cnkgaXMgZm9yIGFuIGFwcGxpY2F0aW9uIG9mICdzcGFjZXMnLlxuICAgIC8vIFRPRE8ocGR1YnJveSk6IENsZWFuIHRoaXMgdXAgYnkgaW50cm9kdWNpbmcgYSBzcGVjaWFsIGBNYXRjaDxzdGFydEFwcGw+YCBydWxlLCB3aGljaCB3aWxsXG4gICAgLy8gZW5zdXJlIHRoYXQgdGhlcmUgaXMgYWx3YXlzIGEgc2luZ2xlIHJvb3QgdHJhY2Ugbm9kZS5cbiAgICBjb25zdCByb290VHJhY2UgPSB0aGlzLnRyYWNlW3RoaXMudHJhY2UubGVuZ3RoIC0gMV07XG4gICAgcm9vdFRyYWNlLnJlc3VsdCA9IG1hdGNoUmVzdWx0O1xuICAgIHJldHVybiByb290VHJhY2U7XG4gIH0sXG5cbiAgcHVzaEZhaWx1cmVzSW5mbygpIHtcbiAgICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb25TdGFjay5wdXNoKHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKTtcbiAgICB0aGlzLl9yZWNvcmRlZEZhaWx1cmVzU3RhY2sucHVzaCh0aGlzLnJlY29yZGVkRmFpbHVyZXMpO1xuICB9LFxuXG4gIHBvcEZhaWx1cmVzSW5mbygpIHtcbiAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiA9IHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvblN0YWNrLnBvcCgpO1xuICAgIHRoaXMucmVjb3JkZWRGYWlsdXJlcyA9IHRoaXMuX3JlY29yZGVkRmFpbHVyZXNTdGFjay5wb3AoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0Y2hTdGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IE1hdGNoU3RhdGUgPSByZXF1aXJlKCcuL01hdGNoU3RhdGUnKTtcblxuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIE1hdGNoZXIoZ3JhbW1hcikge1xuICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuICB0aGlzLm1lbW9UYWJsZSA9IFtdO1xuICB0aGlzLmlucHV0ID0gJyc7XG59XG5cbk1hdGNoZXIucHJvdG90eXBlLmdldElucHV0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlucHV0O1xufTtcblxuTWF0Y2hlci5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKHRoaXMuaW5wdXQgIT09IHN0cikge1xuICAgIHRoaXMucmVwbGFjZUlucHV0UmFuZ2UoMCwgdGhpcy5pbnB1dC5sZW5ndGgsIHN0cik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYXRjaGVyLnByb3RvdHlwZS5yZXBsYWNlSW5wdXRSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0SWR4LCBlbmRJZHgsIHN0cikge1xuICBjb25zdCBjdXJyZW50SW5wdXQgPSB0aGlzLmlucHV0O1xuICBpZiAoc3RhcnRJZHggPCAwIHx8IHN0YXJ0SWR4ID4gY3VycmVudElucHV0Lmxlbmd0aCB8fFxuICAgICAgZW5kSWR4IDwgMCB8fCBlbmRJZHggPiBjdXJyZW50SW5wdXQubGVuZ3RoIHx8XG4gICAgICBzdGFydElkeCA+IGVuZElkeCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRpY2VzOiAnICsgc3RhcnRJZHggKyAnIGFuZCAnICsgZW5kSWR4KTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBpbnB1dFxuICB0aGlzLmlucHV0ID0gY3VycmVudElucHV0LnNsaWNlKDAsIHN0YXJ0SWR4KSArIHN0ciArIGN1cnJlbnRJbnB1dC5zbGljZShlbmRJZHgpO1xuXG4gIC8vIHVwZGF0ZSBtZW1vIHRhYmxlIChzaW1pbGFyIHRvIHRoZSBhYm92ZSlcbiAgY29uc3QgcmVzdE9mTWVtb1RhYmxlID0gdGhpcy5tZW1vVGFibGUuc2xpY2UoZW5kSWR4KTtcbiAgdGhpcy5tZW1vVGFibGUubGVuZ3RoID0gc3RhcnRJZHg7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHN0ci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy5tZW1vVGFibGUucHVzaCh1bmRlZmluZWQpO1xuICB9XG4gIHJlc3RPZk1lbW9UYWJsZS5mb3JFYWNoKFxuICAgICAgZnVuY3Rpb24ocG9zSW5mbykgeyB0aGlzLm1lbW9UYWJsZS5wdXNoKHBvc0luZm8pOyB9LFxuICAgICAgdGhpcyk7XG5cbiAgLy8gSW52YWxpZGF0ZSBtZW1vUmVjc1xuICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBzdGFydElkeDsgcG9zKyspIHtcbiAgICBjb25zdCBwb3NJbmZvID0gdGhpcy5tZW1vVGFibGVbcG9zXTtcbiAgICBpZiAocG9zSW5mbykge1xuICAgICAgcG9zSW5mby5jbGVhck9ic29sZXRlRW50cmllcyhwb3MsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ob3B0U3RhcnRBcHBsaWNhdGlvblN0cikge1xuICByZXR1cm4gdGhpcy5fbWF0Y2godGhpcy5fZ2V0U3RhcnRFeHByKG9wdFN0YXJ0QXBwbGljYXRpb25TdHIpLCBmYWxzZSk7XG59O1xuXG5NYXRjaGVyLnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uKG9wdFN0YXJ0QXBwbGljYXRpb25TdHIpIHtcbiAgcmV0dXJuIHRoaXMuX21hdGNoKHRoaXMuX2dldFN0YXJ0RXhwcihvcHRTdGFydEFwcGxpY2F0aW9uU3RyKSwgdHJ1ZSk7XG59O1xuXG5NYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2ggPSBmdW5jdGlvbihzdGFydEV4cHIsIHRyYWNpbmcsIG9wdFBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcykge1xuICBjb25zdCBzdGF0ZSA9IG5ldyBNYXRjaFN0YXRlKHRoaXMsIHN0YXJ0RXhwciwgb3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKTtcbiAgcmV0dXJuIHRyYWNpbmcgPyBzdGF0ZS5nZXRUcmFjZSgpIDogc3RhdGUuZ2V0TWF0Y2hSZXN1bHQoKTtcbn07XG5cbi8qXG4gIFJldHVybnMgdGhlIHN0YXJ0aW5nIGV4cHJlc3Npb24gZm9yIHRoaXMgTWF0Y2hlcidzIGFzc29jaWF0ZWQgZ3JhbW1hci4gSWYgYG9wdFN0YXJ0QXBwbGljYXRpb25TdHJgXG4gIGlzIHNwZWNpZmllZCwgaXQgaXMgYSBzdHJpbmcgZXhwcmVzc2luZyBhIHJ1bGUgYXBwbGljYXRpb24gaW4gdGhlIGdyYW1tYXIuIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICBncmFtbWFyJ3MgZGVmYXVsdCBzdGFydCBydWxlIHdpbGwgYmUgdXNlZC5cbiovXG5NYXRjaGVyLnByb3RvdHlwZS5fZ2V0U3RhcnRFeHByID0gZnVuY3Rpb24ob3B0U3RhcnRBcHBsaWNhdGlvblN0cikge1xuICBjb25zdCBhcHBsaWNhdGlvblN0ciA9IG9wdFN0YXJ0QXBwbGljYXRpb25TdHIgfHwgdGhpcy5ncmFtbWFyLmRlZmF1bHRTdGFydFJ1bGU7XG4gIGlmICghYXBwbGljYXRpb25TdHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc3RhcnQgcnVsZSBhcmd1bWVudCAtLSB0aGUgZ3JhbW1hciBoYXMgbm8gZGVmYXVsdCBzdGFydCBydWxlLicpO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRBcHAgPSB0aGlzLmdyYW1tYXIucGFyc2VBcHBsaWNhdGlvbihhcHBsaWNhdGlvblN0cik7XG4gIHJldHVybiBuZXcgcGV4cHJzLlNlcShbc3RhcnRBcHAsIHBleHBycy5lbmRdKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGNoZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd1dGlsLWV4dGVuZCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gTmFtZXNwYWNlKCkge1xufVxuTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbk5hbWVzcGFjZS5hc05hbWVzcGFjZSA9IGZ1bmN0aW9uKG9iak9yTmFtZXNwYWNlKSB7XG4gIGlmIChvYmpPck5hbWVzcGFjZSBpbnN0YW5jZW9mIE5hbWVzcGFjZSkge1xuICAgIHJldHVybiBvYmpPck5hbWVzcGFjZTtcbiAgfVxuICByZXR1cm4gTmFtZXNwYWNlLmNyZWF0ZU5hbWVzcGFjZShvYmpPck5hbWVzcGFjZSk7XG59O1xuXG4vLyBDcmVhdGUgYSBuZXcgbmFtZXNwYWNlLiBJZiBgb3B0UHJvcHNgIGlzIHNwZWNpZmllZCwgYWxsIG9mIGl0cyBwcm9wZXJ0aWVzXG4vLyB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IG5hbWVzcGFjZS5cbk5hbWVzcGFjZS5jcmVhdGVOYW1lc3BhY2UgPSBmdW5jdGlvbihvcHRQcm9wcykge1xuICByZXR1cm4gTmFtZXNwYWNlLmV4dGVuZChOYW1lc3BhY2UucHJvdG90eXBlLCBvcHRQcm9wcyk7XG59O1xuXG4vLyBDcmVhdGUgYSBuZXcgbmFtZXNwYWNlIHdoaWNoIGV4dGVuZHMgYW5vdGhlciBuYW1lc3BhY2UuIElmIGBvcHRQcm9wc2AgaXNcbi8vIHNwZWNpZmllZCwgYWxsIG9mIGl0cyBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgbmFtZXNwYWNlLlxuTmFtZXNwYWNlLmV4dGVuZCA9IGZ1bmN0aW9uKG5hbWVzcGFjZSwgb3B0UHJvcHMpIHtcbiAgaWYgKG5hbWVzcGFjZSAhPT0gTmFtZXNwYWNlLnByb3RvdHlwZSAmJiAhKG5hbWVzcGFjZSBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBOYW1lc3BhY2Ugb2JqZWN0OiAnICsgbmFtZXNwYWNlKTtcbiAgfVxuICBjb25zdCBucyA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBOYW1lc3BhY2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV4dGVuZChucywgb3B0UHJvcHMpO1xufTtcblxuLy8gVE9ETzogU2hvdWxkIHRoaXMgYmUgYSByZWd1bGFyIG1ldGhvZD9cbk5hbWVzcGFjZS50b1N0cmluZyA9IGZ1bmN0aW9uKG5zKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnMpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gTmFtZXNwYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gUG9zSW5mbygpIHtcbiAgdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjayA9IFtdOyAvLyBhY3RpdmUgYXBwbGljYXRpb25zIGF0IHRoaXMgcG9zaXRpb25cbiAgdGhpcy5tZW1vID0ge307XG4gIHRoaXMubWF4RXhhbWluZWRMZW5ndGggPSAwO1xuICB0aGlzLm1heFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPSAtMTtcbiAgdGhpcy5jdXJyZW50TGVmdFJlY3Vyc2lvbiA9IHVuZGVmaW5lZDtcbn1cblxuUG9zSW5mby5wcm90b3R5cGUgPSB7XG4gIGlzQWN0aXZlKGFwcGxpY2F0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2suaW5kZXhPZihhcHBsaWNhdGlvbi50b01lbW9LZXkoKSkgPj0gMDtcbiAgfSxcblxuICBlbnRlcihhcHBsaWNhdGlvbikge1xuICAgIHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2sucHVzaChhcHBsaWNhdGlvbi50b01lbW9LZXkoKSk7XG4gIH0sXG5cbiAgZXhpdCgpIHtcbiAgICB0aGlzLmFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLnBvcCgpO1xuICB9LFxuXG4gIHN0YXJ0TGVmdFJlY3Vyc2lvbihoZWFkQXBwbGljYXRpb24sIG1lbW9SZWMpIHtcbiAgICBtZW1vUmVjLmlzTGVmdFJlY3Vyc2lvbiA9IHRydWU7XG4gICAgbWVtb1JlYy5oZWFkQXBwbGljYXRpb24gPSBoZWFkQXBwbGljYXRpb247XG4gICAgbWVtb1JlYy5uZXh0TGVmdFJlY3Vyc2lvbiA9IHRoaXMuY3VycmVudExlZnRSZWN1cnNpb247XG4gICAgdGhpcy5jdXJyZW50TGVmdFJlY3Vyc2lvbiA9IG1lbW9SZWM7XG5cbiAgICBjb25zdCBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjayA9IHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2s7XG4gICAgY29uc3QgaW5kZXhPZkZpcnN0SW52b2x2ZWRSdWxlID1cbiAgICAgICAgYXBwbGljYXRpb25NZW1vS2V5U3RhY2suaW5kZXhPZihoZWFkQXBwbGljYXRpb24udG9NZW1vS2V5KCkpICsgMTtcbiAgICBjb25zdCBpbnZvbHZlZEFwcGxpY2F0aW9uTWVtb0tleXMgPSBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5zbGljZShpbmRleE9mRmlyc3RJbnZvbHZlZFJ1bGUpO1xuXG4gICAgbWVtb1JlYy5pc0ludm9sdmVkID0gZnVuY3Rpb24oYXBwbGljYXRpb25NZW1vS2V5KSB7XG4gICAgICByZXR1cm4gaW52b2x2ZWRBcHBsaWNhdGlvbk1lbW9LZXlzLmluZGV4T2YoYXBwbGljYXRpb25NZW1vS2V5KSA+PSAwO1xuICAgIH07XG5cbiAgICBtZW1vUmVjLnVwZGF0ZUludm9sdmVkQXBwbGljYXRpb25NZW1vS2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yIChsZXQgaWR4ID0gaW5kZXhPZkZpcnN0SW52b2x2ZWRSdWxlOyBpZHggPCBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9uTWVtb0tleSA9IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrW2lkeF07XG4gICAgICAgIGlmICghdGhpcy5pc0ludm9sdmVkKGFwcGxpY2F0aW9uTWVtb0tleSkpIHtcbiAgICAgICAgICBpbnZvbHZlZEFwcGxpY2F0aW9uTWVtb0tleXMucHVzaChhcHBsaWNhdGlvbk1lbW9LZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBlbmRMZWZ0UmVjdXJzaW9uKCkge1xuICAgIHRoaXMuY3VycmVudExlZnRSZWN1cnNpb24gPSB0aGlzLmN1cnJlbnRMZWZ0UmVjdXJzaW9uLm5leHRMZWZ0UmVjdXJzaW9uO1xuICB9LFxuXG4gIC8vIE5vdGU6IHRoaXMgbWV0aG9kIGRvZXNuJ3QgZ2V0IGNhbGxlZCBmb3IgdGhlIFwiaGVhZFwiIG9mIGEgbGVmdCByZWN1cnNpb24gLS0gZm9yIExSIGhlYWRzLFxuICAvLyB0aGUgbWVtb2l6ZWQgcmVzdWx0ICh3aGljaCBzdGFydHMgb3V0IGJlaW5nIGEgZmFpbHVyZSkgaXMgYWx3YXlzIHVzZWQuXG4gIHNob3VsZFVzZU1lbW9pemVkUmVzdWx0KG1lbW9SZWMpIHtcbiAgICBpZiAoIW1lbW9SZWMuaXNMZWZ0UmVjdXJzaW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYXBwbGljYXRpb25NZW1vS2V5U3RhY2sgPSB0aGlzLmFwcGxpY2F0aW9uTWVtb0tleVN0YWNrO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IGFwcGxpY2F0aW9uTWVtb0tleSA9IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrW2lkeF07XG4gICAgICBpZiAobWVtb1JlYy5pc0ludm9sdmVkKGFwcGxpY2F0aW9uTWVtb0tleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBtZW1vaXplKG1lbW9LZXksIG1lbW9SZWMpIHtcbiAgICB0aGlzLm1lbW9bbWVtb0tleV0gPSBtZW1vUmVjO1xuICAgIHRoaXMubWF4RXhhbWluZWRMZW5ndGggPSBNYXRoLm1heCh0aGlzLm1heEV4YW1pbmVkTGVuZ3RoLCBtZW1vUmVjLmV4YW1pbmVkTGVuZ3RoKTtcbiAgICB0aGlzLm1heFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPVxuICAgICAgICBNYXRoLm1heCh0aGlzLm1heFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQsIG1lbW9SZWMucmlnaHRtb3N0RmFpbHVyZU9mZnNldCk7XG4gICAgcmV0dXJuIG1lbW9SZWM7XG4gIH0sXG5cbiAgY2xlYXJPYnNvbGV0ZUVudHJpZXMocG9zLCBpbnZhbGlkYXRlZElkeCkge1xuICAgIGlmIChwb3MgKyB0aGlzLm1heEV4YW1pbmVkTGVuZ3RoIDw9IGludmFsaWRhdGVkSWR4KSB7XG4gICAgICAvLyBPcHRpbWl6YXRpb246IG5vbmUgb2YgdGhlIHJ1bGUgYXBwbGljYXRpb25zIHRoYXQgd2VyZSBtZW1vaXplZCBoZXJlIGV4YW1pbmVkIHRoZVxuICAgICAgLy8gaW50ZXJ2YWwgb2YgdGhlIGlucHV0IHRoYXQgY2hhbmdlZCwgc28gbm90aGluZyBoYXMgdG8gYmUgaW52YWxpZGF0ZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVtbyA9IHRoaXMubWVtbztcbiAgICB0aGlzLm1heEV4YW1pbmVkTGVuZ3RoID0gMDtcbiAgICB0aGlzLm1heFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPSAtMTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhtZW1vKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgY29uc3QgbWVtb1JlYyA9IG1lbW9ba107XG4gICAgICBpZiAocG9zICsgbWVtb1JlYy5leGFtaW5lZExlbmd0aCA+IGludmFsaWRhdGVkSWR4KSB7XG4gICAgICAgIGRlbGV0ZSBtZW1vW2tdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5tYXhFeGFtaW5lZExlbmd0aCA9IE1hdGgubWF4KHNlbGYubWF4RXhhbWluZWRMZW5ndGgsIG1lbW9SZWMuZXhhbWluZWRMZW5ndGgpO1xuICAgICAgICBzZWxmLm1heFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQgPVxuICAgICAgICAgICAgTWF0aC5tYXgoc2VsZi5tYXhSaWdodG1vc3RGYWlsdXJlT2Zmc2V0LCBtZW1vUmVjLnJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBQb3NJbmZvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgSW5wdXRTdHJlYW0gPSByZXF1aXJlKCcuL0lucHV0U3RyZWFtJyk7XG5jb25zdCBJdGVyYXRpb25Ob2RlID0gcmVxdWlyZSgnLi9ub2RlcycpLkl0ZXJhdGlvbk5vZGU7XG5jb25zdCBNYXRjaFJlc3VsdCA9IHJlcXVpcmUoJy4vTWF0Y2hSZXN1bHQnKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZ2xvYmFsQWN0aW9uU3RhY2sgPSBbXTtcbmxldCBwcm90b3R5cGVHcmFtbWFyO1xubGV0IHByb3RvdHlwZUdyYW1tYXJTZW1hbnRpY3M7XG5cbi8vIEpTT04gaXMgbm90IGEgdmFsaWQgc3Vic2V0IG9mIEphdmFTY3JpcHQgYmVjYXVzZSB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIGxpbmUgdGVybWluYXRvcnMsXG4vLyBVKzIwMjggKGxpbmUgc2VwYXJhdG9yKSBhbmQgVSsyMDI5IChwYXJhZ3JhcGggc2VwYXJhdG9yKSB0aGF0IGFyZSBhbGxvd2VkIGluIEpTT04gc3RyaW5nc1xuLy8gYnV0IG5vdCBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXG4vLyBqc29uVG9KUygpIHByb3Blcmx5IGVuY29kZXMgdGhvc2UgdHdvIGNoYXJhY3RlcnMgaW4gSlNPTiBzbyB0aGF0IGl0IGNhbiBzZWFtbGVzc2x5IGJlXG4vLyBpbnNlcnRlZCBpbnRvIEphdmFTY3JpcHQgY29kZSAocGx1cyB0aGUgZW5jb2RlZCB2ZXJzaW9uIGlzIHN0aWxsIHZhbGlkIEpTT04pXG5mdW5jdGlvbiBqc29uVG9KUyhzdHIpIHtcbiAgY29uc3Qgb3V0cHV0ID0gc3RyLnJlcGxhY2UoL1tcXHUyMDI4XFx1MjAyOV0vZywgKGNoYXIsIHBvcywgc3RyKSA9PiB7XG4gICAgY29uc3QgaGV4ID0gY2hhci5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuICdcXFxcdScgKyAnMDAwMCcuc2xpY2UoaGV4Lmxlbmd0aCkgKyBoZXg7XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBXcmFwcGVycyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBXcmFwcGVycyBkZWNvcmF0ZSBDU1Qgbm9kZXMgd2l0aCBhbGwgb2YgdGhlIGZ1bmN0aW9uYWxpdHkgKGkuZS4sIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMpXG4vLyBwcm92aWRlZCBieSBhIFNlbWFudGljcyAoc2VlIGJlbG93KS4gYFdyYXBwZXJgIGlzIHRoZSBhYnN0cmFjdCBzdXBlcmNsYXNzIG9mIGFsbCB3cmFwcGVycy4gQVxuLy8gYFdyYXBwZXJgIG11c3QgaGF2ZSBgX25vZGVgIGFuZCBgX3NlbWFudGljc2AgaW5zdGFuY2UgdmFyaWFibGVzLCB3aGljaCByZWZlciB0byB0aGUgQ1NUIG5vZGUgYW5kXG4vLyBTZW1hbnRpY3MgKHJlc3AuKSBmb3Igd2hpY2ggaXQgd2FzIGNyZWF0ZWQsIGFuZCBhIGBfY2hpbGRXcmFwcGVyc2AgaW5zdGFuY2UgdmFyaWFibGUgd2hpY2ggaXNcbi8vIHVzZWQgdG8gY2FjaGUgdGhlIHdyYXBwZXIgaW5zdGFuY2VzIHRoYXQgYXJlIGNyZWF0ZWQgZm9yIGl0cyBjaGlsZCBub2Rlcy4gU2V0dGluZyB0aGVzZSBpbnN0YW5jZVxuLy8gdmFyaWFibGVzIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY29uc3RydWN0b3Igb2YgZWFjaCBTZW1hbnRpY3Mtc3BlY2lmaWMgc3ViY2xhc3Mgb2Zcbi8vIGBXcmFwcGVyYC5cbmNsYXNzIFdyYXBwZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBzb3VyY2VJbnRlcnZhbCwgYmFzZUludGVydmFsKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2VJbnRlcnZhbDtcblxuICAgIC8vIFRoZSBpbnRlcnZhbCB0aGF0IHRoZSBjaGlsZE9mZnNldHMgb2YgYG5vZGVgIGFyZSByZWxhdGl2ZSB0by4gSXQgc2hvdWxkIGJlIHRoZSBzb3VyY2VcbiAgICAvLyBvZiB0aGUgY2xvc2VzdCBOb250ZXJtaW5hbCBub2RlLlxuICAgIHRoaXMuX2Jhc2VJbnRlcnZhbCA9IGJhc2VJbnRlcnZhbDtcblxuICAgIGlmIChub2RlLmlzTm9udGVybWluYWwoKSkge1xuICAgICAgY29tbW9uLmFzc2VydChzb3VyY2VJbnRlcnZhbCA9PT0gYmFzZUludGVydmFsKTtcbiAgICB9XG4gICAgdGhpcy5fY2hpbGRXcmFwcGVycyA9IFtdO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbc2VtYW50aWNzIHdyYXBwZXIgZm9yICcgKyB0aGlzLl9ub2RlLmdyYW1tYXIubmFtZSArICddJztcbiAgfTtcblxuICAvLyBUaGlzIGlzIHVzZWQgYnkgb2htIGVkaXRvciB0byBkaXNwbGF5IGEgbm9kZSB3cmFwcGVyIGFwcHJvcHJpYXRlbHkuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG5cbiAgX2ZvcmdldE1lbW9pemVkUmVzdWx0Rm9yKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAvLyBSZW1vdmUgdGhlIG1lbW9pemVkIGF0dHJpYnV0ZSBmcm9tIHRoZSBjc3ROb2RlIGFuZCBhbGwgaXRzIGNoaWxkcmVuLlxuICAgIGRlbGV0ZSB0aGlzLl9ub2RlW3RoaXMuX3NlbWFudGljcy5hdHRyaWJ1dGVLZXlzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY2hpbGQuX2ZvcmdldE1lbW9pemVkUmVzdWx0Rm9yKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgd3JhcHBlciBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkIG5vZGUuIENoaWxkIHdyYXBwZXJzIGFyZSBjcmVhdGVkIGxhemlseSBhbmRcbiAgLy8gY2FjaGVkIGluIHRoZSBwYXJlbnQgd3JhcHBlcidzIGBfY2hpbGRXcmFwcGVyc2AgaW5zdGFuY2UgdmFyaWFibGUuXG4gIGNoaWxkKGlkeCkge1xuICAgIGlmICghKDAgPD0gaWR4ICYmIGlkeCA8IHRoaXMuX25vZGUubnVtQ2hpbGRyZW4oKSkpIHtcbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIHRocm93aW5nIGFuIGV4Y2VwdGlvbiBoZXJlLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGNoaWxkV3JhcHBlciA9IHRoaXMuX2NoaWxkV3JhcHBlcnNbaWR4XTtcbiAgICBpZiAoIWNoaWxkV3JhcHBlcikge1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gdGhpcy5fbm9kZS5jaGlsZEF0KGlkeCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9ub2RlLmNoaWxkT2Zmc2V0c1tpZHhdO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9iYXNlSW50ZXJ2YWwuc3ViSW50ZXJ2YWwob2Zmc2V0LCBjaGlsZE5vZGUubWF0Y2hMZW5ndGgpO1xuICAgICAgY29uc3QgYmFzZSA9IGNoaWxkTm9kZS5pc05vbnRlcm1pbmFsKCkgPyBzb3VyY2UgOiB0aGlzLl9iYXNlSW50ZXJ2YWw7XG4gICAgICBjaGlsZFdyYXBwZXIgPSB0aGlzLl9jaGlsZFdyYXBwZXJzW2lkeF0gPSB0aGlzLl9zZW1hbnRpY3Mud3JhcChjaGlsZE5vZGUsIHNvdXJjZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZFdyYXBwZXI7XG4gIH1cblxuICAvLyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHdyYXBwZXJzIG9mIGFsbCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIG5vZGUgYXNzb2NpYXRlZFxuICAvLyB3aXRoIHRoaXMgd3JhcHBlci5cbiAgX2NoaWxkcmVuKCkge1xuICAgIC8vIEZvcmNlIHRoZSBjcmVhdGlvbiBvZiBhbGwgY2hpbGQgd3JhcHBlcnNcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9ub2RlLm51bUNoaWxkcmVuKCk7IGlkeCsrKSB7XG4gICAgICB0aGlzLmNoaWxkKGlkeCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jaGlsZFdyYXBwZXJzO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgY29ycmVzcG9uZHMgdG8gYW4gaXRlcmF0aW9uXG4gIC8vIGV4cHJlc3Npb24sIGkuZS4sIGEgS2xlZW5lLSosIEtsZWVuZS0rLCBvciBhbiBvcHRpb25hbC4gUmV0dXJucyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgaXNJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuaXNJdGVyYXRpb24oKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3cmFwcGVyIGlzIGEgdGVybWluYWwgbm9kZSwgYGZhbHNlYFxuICAvLyBvdGhlcndpc2UuXG4gIGlzVGVybWluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuaXNUZXJtaW5hbCgpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgaXMgYSBub250ZXJtaW5hbCBub2RlLCBgZmFsc2VgXG4gIC8vIG90aGVyd2lzZS5cbiAgaXNOb250ZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5pc05vbnRlcm1pbmFsKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBpcyBhIG5vbnRlcm1pbmFsIG5vZGVcbiAgLy8gY29ycmVzcG9uZGluZyB0byBhIHN5bnRhY3RpYyBydWxlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgaXNTeW50YWN0aWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb250ZXJtaW5hbCgpICYmIHRoaXMuX25vZGUuaXNTeW50YWN0aWMoKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3cmFwcGVyIGlzIGEgbm9udGVybWluYWwgbm9kZVxuICAvLyBjb3JyZXNwb25kaW5nIHRvIGEgbGV4aWNhbCBydWxlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgaXNMZXhpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLmlzTm9udGVybWluYWwoKSAmJiB0aGlzLl9ub2RlLmlzTGV4aWNhbCgpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgaXMgYW4gaXRlcmF0b3Igbm9kZVxuICAvLyBoYXZpbmcgZWl0aGVyIG9uZSBvciBubyBjaGlsZCAoPyBvcGVyYXRvciksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLyBPdGhlcndpc2UsIHRocm93cyBhbiBleGNlcHRpb24uXG4gIGlzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuaXNPcHRpb25hbCgpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IF9pdGVyIHdyYXBwZXIgaW4gdGhlIHNhbWUgc2VtYW50aWNzIGFzIHRoaXMgd3JhcHBlci5cbiAgaXRlcmF0aW9uKG9wdENoaWxkV3JhcHBlcnMpIHtcbiAgICBjb25zdCBjaGlsZFdyYXBwZXJzID0gb3B0Q2hpbGRXcmFwcGVycyB8fCBbXTtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBjaGlsZFdyYXBwZXJzLm1hcChjID0+IGMuX25vZGUpO1xuICAgIGNvbnN0IGl0ZXIgPSBuZXcgSXRlcmF0aW9uTm9kZSh0aGlzLl9ub2RlLmdyYW1tYXIsIGNoaWxkTm9kZXMsIFtdLCAtMSwgZmFsc2UpO1xuXG4gICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuX3NlbWFudGljcy53cmFwKGl0ZXIsIG51bGwsIG51bGwpO1xuICAgIHdyYXBwZXIuX2NoaWxkV3JhcHBlcnMgPSBjaGlsZFdyYXBwZXJzO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBjaGlsZHJlbiBvZiB0aGlzIENTVCBub2RlLlxuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBuYW1lIG9mIGdyYW1tYXIgcnVsZSB0aGF0IGNyZWF0ZWQgdGhpcyBDU1Qgbm9kZS5cbiAgZ2V0IGN0b3JOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLmN0b3JOYW1lO1xuICB9XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgZXZlbnR1YWxseSAoZGVwcmVjYXRlZCBpbiB2MC4xMikuXG4gIGdldCBpbnRlcnZhbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgaW50ZXJ2YWxgIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQgLS0gdXNlIGBzb3VyY2VgIGluc3RlYWQnKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBvZiB0aGlzIENTVCBub2RlLlxuICBnZXQgbnVtQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUubnVtQ2hpbGRyZW4oKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHByaW1pdGl2ZSB2YWx1ZSBvZiB0aGlzIENTVCBub2RlLCBpZiBpdCdzIGEgdGVybWluYWwgbm9kZS4gT3RoZXJ3aXNlLFxuICAvLyB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICBnZXQgcHJpbWl0aXZlVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuaXNUZXJtaW5hbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbm9kZS5wcmltaXRpdmVWYWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJ0cmllZCB0byBhY2Nlc3MgdGhlICdwcmltaXRpdmVWYWx1ZScgYXR0cmlidXRlIG9mIGEgbm9uLXRlcm1pbmFsIENTVCBub2RlXCIpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIGlucHV0IHN0cmVhbSBjb25zdW1lZCBieSB0aGlzIENTVCBub2RlLlxuICBnZXQgc291cmNlU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5jb250ZW50cztcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBTZW1hbnRpY3MgLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQSBTZW1hbnRpY3MgaXMgYSBjb250YWluZXIgZm9yIGEgZmFtaWx5IG9mIE9wZXJhdGlvbnMgYW5kIEF0dHJpYnV0ZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hci5cbi8vIFNlbWFudGljcyBlbmFibGUgbW9kdWxhcml0eSAoZGlmZmVyZW50IGNsaWVudHMgb2YgYSBncmFtbWFyIGNhbiBjcmVhdGUgdGhlaXIgc2V0IG9mIG9wZXJhdGlvbnNcbi8vIGFuZCBhdHRyaWJ1dGVzIGluIGlzb2xhdGlvbikgYW5kIGV4dGVuc2liaWxpdHkgZXZlbiB3aGVuIG9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgYXJlIG11dHVhbGx5LVxuLy8gcmVjdXJzaXZlLiBUaGlzIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGV4Y2VwdCBmcm9tXG4vLyBgU2VtYW50aWNzLmNyZWF0ZVNlbWFudGljc2AuIFRoZSBub3JtYWwgd2F5cyB0byBjcmVhdGUgYSBTZW1hbnRpY3MsIGdpdmVuIGEgZ3JhbW1hciAnZycsIGFyZVxuLy8gYGcuY3JlYXRlU2VtYW50aWNzKClgIGFuZCBgZy5leHRlbmRTZW1hbnRpY3MocGFyZW50U2VtYW50aWNzKWAuXG5mdW5jdGlvbiBTZW1hbnRpY3MoZ3JhbW1hciwgc3VwZXJTZW1hbnRpY3MpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG4gIHRoaXMuY2hlY2tlZEFjdGlvbkRpY3RzID0gZmFsc2U7XG5cbiAgLy8gQ29uc3RydWN0b3IgZm9yIHdyYXBwZXIgaW5zdGFuY2VzLCB3aGljaCBhcmUgcGFzc2VkIGFzIHRoZSBhcmd1bWVudHMgdG8gdGhlIHNlbWFudGljIGFjdGlvbnNcbiAgLy8gb2YgYW4gb3BlcmF0aW9uIG9yIGF0dHJpYnV0ZS4gT3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcyByZXF1aXJlIGRvdWJsZSBkaXNwYXRjaDogdGhlIHNlbWFudGljXG4gIC8vIGFjdGlvbiBpcyBjaG9zZW4gYmFzZWQgb24gYm90aCB0aGUgbm9kZSdzIHR5cGUgYW5kIHRoZSBzZW1hbnRpY3MuIFdyYXBwZXJzIGVuc3VyZSB0aGF0XG4gIC8vIHRoZSBgZXhlY3V0ZWAgbWV0aG9kIGlzIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IChtb3N0IHNwZWNpZmljKSBzZW1hbnRpY3Mgb2JqZWN0IGFzIGFuXG4gIC8vIGFyZ3VtZW50LlxuICB0aGlzLldyYXBwZXIgPSBjbGFzcyBleHRlbmRzIChzdXBlclNlbWFudGljcyA/IHN1cGVyU2VtYW50aWNzLldyYXBwZXIgOiBXcmFwcGVyKSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgc291cmNlSW50ZXJ2YWwsIGJhc2VJbnRlcnZhbCkge1xuICAgICAgc3VwZXIobm9kZSwgc291cmNlSW50ZXJ2YWwsIGJhc2VJbnRlcnZhbCk7XG4gICAgICBzZWxmLmNoZWNrQWN0aW9uRGljdHNJZkhhdmVudEFscmVhZHkoKTtcbiAgICAgIHRoaXMuX3NlbWFudGljcyA9IHNlbGY7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc3VwZXIgPSBzdXBlclNlbWFudGljcztcbiAgaWYgKHN1cGVyU2VtYW50aWNzKSB7XG4gICAgaWYgKCEoZ3JhbW1hci5lcXVhbHModGhpcy5zdXBlci5ncmFtbWFyKSB8fCBncmFtbWFyLl9pbmhlcml0c0Zyb20odGhpcy5zdXBlci5ncmFtbWFyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCBleHRlbmQgYSBzZW1hbnRpY3MgZm9yIGdyYW1tYXIgJ1wiICsgdGhpcy5zdXBlci5ncmFtbWFyLm5hbWUgK1xuICAgICAgICAgIFwiJyBmb3IgdXNlIHdpdGggZ3JhbW1hciAnXCIgKyBncmFtbWFyLm5hbWUgKyBcIicgKG5vdCBhIHN1Yi1ncmFtbWFyKVwiKTtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnN1cGVyLm9wZXJhdGlvbnMpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IE9iamVjdC5jcmVhdGUodGhpcy5zdXBlci5hdHRyaWJ1dGVzKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gQXNzaWduIHVuaXF1ZSBzeW1ib2xzIGZvciBlYWNoIG9mIHRoZSBhdHRyaWJ1dGVzIGluaGVyaXRlZCBmcm9tIHRoZSBzdXBlci1zZW1hbnRpY3Mgc28gdGhhdFxuICAgIC8vIHRoZXkgYXJlIG1lbW9pemVkIGluZGVwZW5kZW50bHkuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuYXR0cmlidXRlS2V5cywgYXR0cmlidXRlTmFtZSwge1xuICAgICAgICB2YWx1ZTogdXRpbC51bmlxdWVJZChhdHRyaWJ1dGVOYW1lKVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMub3BlcmF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG59XG5cblNlbWFudGljcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdbc2VtYW50aWNzIGZvciAnICsgdGhpcy5ncmFtbWFyLm5hbWUgKyAnXSc7XG59O1xuXG5TZW1hbnRpY3MucHJvdG90eXBlLmNoZWNrQWN0aW9uRGljdHNJZkhhdmVudEFscmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNoZWNrZWRBY3Rpb25EaWN0cykge1xuICAgIHRoaXMuY2hlY2tBY3Rpb25EaWN0cygpO1xuICAgIHRoaXMuY2hlY2tlZEFjdGlvbkRpY3RzID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ2hlY2tzIHRoYXQgdGhlIGFjdGlvbiBkaWN0aW9uYXJpZXMgZm9yIGFsbCBvcGVyYXRpb25zIGFuZCBhdHRyaWJ1dGVzIGluIHRoaXMgc2VtYW50aWNzLFxuLy8gaW5jbHVkaW5nIHRoZSBvbmVzIHRoYXQgd2VyZSBpbmhlcml0ZWQgZnJvbSB0aGUgc3VwZXItc2VtYW50aWNzLCBhZ3JlZSB3aXRoIHRoZSBncmFtbWFyLlxuLy8gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBvbmUgb3IgbW9yZSBvZiB0aGVtIGRvZXNuJ3QuXG5TZW1hbnRpY3MucHJvdG90eXBlLmNoZWNrQWN0aW9uRGljdHMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IG5hbWU7XG4gIGZvciAobmFtZSBpbiB0aGlzLm9wZXJhdGlvbnMpIHtcbiAgICB0aGlzLm9wZXJhdGlvbnNbbmFtZV0uY2hlY2tBY3Rpb25EaWN0KHRoaXMuZ3JhbW1hcik7XG4gIH1cbiAgZm9yIChuYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXS5jaGVja0FjdGlvbkRpY3QodGhpcy5ncmFtbWFyKTtcbiAgfVxufTtcblxuU2VtYW50aWNzLnByb3RvdHlwZS50b1JlY2lwZSA9IGZ1bmN0aW9uKHNlbWFudGljc09ubHkpIHtcbiAgZnVuY3Rpb24gaGFzU3VwZXJTZW1hbnRpY3Mocykge1xuICAgIHJldHVybiBzLnN1cGVyICE9PSBTZW1hbnRpY3MuQnVpbHRJblNlbWFudGljcy5fZ2V0U2VtYW50aWNzKCk7XG4gIH1cblxuICBsZXQgc3RyID0gJyhmdW5jdGlvbihnKSB7XFxuJztcbiAgaWYgKGhhc1N1cGVyU2VtYW50aWNzKHRoaXMpKSB7XG4gICAgc3RyICs9ICcgIHZhciBzZW1hbnRpY3MgPSAnICsgdGhpcy5zdXBlci50b1JlY2lwZSh0cnVlKSArICcoZyc7XG5cbiAgICBjb25zdCBzdXBlclNlbWFudGljc0dyYW1tYXIgPSB0aGlzLnN1cGVyLmdyYW1tYXI7XG4gICAgbGV0IHJlbGF0ZWRHcmFtbWFyID0gdGhpcy5ncmFtbWFyO1xuICAgIHdoaWxlIChyZWxhdGVkR3JhbW1hciAhPT0gc3VwZXJTZW1hbnRpY3NHcmFtbWFyKSB7XG4gICAgICBzdHIgKz0gJy5zdXBlckdyYW1tYXInO1xuICAgICAgcmVsYXRlZEdyYW1tYXIgPSByZWxhdGVkR3JhbW1hci5zdXBlckdyYW1tYXI7XG4gICAgfVxuXG4gICAgc3RyICs9ICcpO1xcbic7XG4gICAgc3RyICs9ICcgIHJldHVybiBnLmV4dGVuZFNlbWFudGljcyhzZW1hbnRpY3MpJztcbiAgfSBlbHNlIHtcbiAgICBzdHIgKz0gJyAgcmV0dXJuIGcuY3JlYXRlU2VtYW50aWNzKCknO1xuICB9XG4gIFsnT3BlcmF0aW9uJywgJ0F0dHJpYnV0ZSddLmZvckVhY2godHlwZSA9PiB7XG4gICAgY29uc3Qgc2VtYW50aWNPcGVyYXRpb25zID0gdGhpc1t0eXBlLnRvTG93ZXJDYXNlKCkgKyAncyddO1xuICAgIE9iamVjdC5rZXlzKHNlbWFudGljT3BlcmF0aW9ucykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IHthY3Rpb25EaWN0LCBmb3JtYWxzLCBidWlsdEluRGVmYXVsdH0gPSBzZW1hbnRpY09wZXJhdGlvbnNbbmFtZV07XG5cbiAgICAgIGxldCBzaWduYXR1cmUgPSBuYW1lO1xuICAgICAgaWYgKGZvcm1hbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzaWduYXR1cmUgKz0gJygnICsgZm9ybWFscy5qb2luKCcsICcpICsgJyknO1xuICAgICAgfVxuXG4gICAgICBsZXQgbWV0aG9kO1xuICAgICAgaWYgKGhhc1N1cGVyU2VtYW50aWNzKHRoaXMpICYmIHRoaXMuc3VwZXJbdHlwZS50b0xvd2VyQ2FzZSgpICsgJ3MnXVtuYW1lXSkge1xuICAgICAgICBtZXRob2QgPSAnZXh0ZW5kJyArIHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRob2QgPSAnYWRkJyArIHR5cGU7XG4gICAgICB9XG4gICAgICBzdHIgKz0gJ1xcbiAgICAuJyArIG1ldGhvZCArICcoJyArIEpTT04uc3RyaW5naWZ5KHNpZ25hdHVyZSkgKyAnLCB7JztcblxuICAgICAgY29uc3Qgc3JjQXJyYXkgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKGFjdGlvbkRpY3QpLmZvckVhY2goYWN0aW9uTmFtZSA9PiB7XG4gICAgICAgIGlmIChhY3Rpb25EaWN0W2FjdGlvbk5hbWVdICE9PSBidWlsdEluRGVmYXVsdCkge1xuICAgICAgICAgIGxldCBzb3VyY2UgPSBhY3Rpb25EaWN0W2FjdGlvbk5hbWVdLnRvU3RyaW5nKCkudHJpbSgpO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBtZXRob2Qgc2hvcnRoYW5kIHRvIHBsYWluIG9sZCBmdW5jdGlvbiBzeW50YXguXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hhcmMvb2htL2lzc3Vlcy8yNjNcbiAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvXi4qXFwoLywgJ2Z1bmN0aW9uKCcpO1xuXG4gICAgICAgICAgc3JjQXJyYXkucHVzaCgnXFxuICAgICAgJyArIEpTT04uc3RyaW5naWZ5KGFjdGlvbk5hbWUpICsgJzogJyArIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc3RyICs9IHNyY0FycmF5LmpvaW4oJywnKSArICdcXG4gICAgfSknO1xuICAgIH0pO1xuICB9KTtcbiAgc3RyICs9ICc7XFxuICB9KSc7XG5cbiAgaWYgKCFzZW1hbnRpY3NPbmx5KSB7XG4gICAgc3RyID1cbiAgICAgICcoZnVuY3Rpb24oKSB7XFxuJyArXG4gICAgICAnICB2YXIgZ3JhbW1hciA9IHRoaXMuZnJvbVJlY2lwZSgnICsganNvblRvSlModGhpcy5ncmFtbWFyLnRvUmVjaXBlKCkpICsgJyk7XFxuJyArXG4gICAgICAnICB2YXIgc2VtYW50aWNzID0gJyArIHN0ciArICcoZ3JhbW1hcik7XFxuJyArXG4gICAgICAnICByZXR1cm4gc2VtYW50aWNzO1xcbicgK1xuICAgICAgJ30pO1xcbic7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlLCB0eXBlKSB7XG4gIGlmICghcHJvdG90eXBlR3JhbW1hcikge1xuICAgIC8vIFRoZSBPcGVyYXRpb25zIGFuZCBBdHRyaWJ1dGVzIGdyYW1tYXIgd29uJ3QgYmUgYXZhaWxhYmxlIHdoaWxlIE9obSBpcyBsb2FkaW5nLFxuICAgIC8vIGJ1dCB3ZSBjYW4gZ2V0IGF3YXkgdGhlIGZvbGxvd2luZyBzaW1wbGlmaWNhdGlvbiBiL2Mgbm9uZSBvZiB0aGUgb3BlcmF0aW9uc1xuICAgIC8vIHRoYXQgYXJlIHVzZWQgd2hpbGUgbG9hZGluZyB0YWtlIGFyZ3VtZW50cy5cbiAgICBjb21tb24uYXNzZXJ0KHNpZ25hdHVyZS5pbmRleE9mKCcoJykgPT09IC0xKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogc2lnbmF0dXJlLFxuICAgICAgZm9ybWFsczogW11cbiAgICB9O1xuICB9XG5cbiAgY29uc3QgciA9IHByb3RvdHlwZUdyYW1tYXIubWF0Y2goXG4gICAgICBzaWduYXR1cmUsXG4gICAgICB0eXBlID09PSAnb3BlcmF0aW9uJyA/ICdPcGVyYXRpb25TaWduYXR1cmUnIDogJ0F0dHJpYnV0ZVNpZ25hdHVyZScpO1xuICBpZiAoci5mYWlsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihyLm1lc3NhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHByb3RvdHlwZUdyYW1tYXJTZW1hbnRpY3MocikucGFyc2UoKTtcbn1cblxuZnVuY3Rpb24gbmV3RGVmYXVsdEFjdGlvbih0eXBlLCBuYW1lLCBkb0l0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHRoaXNUaGluZyA9IHRoaXMuX3NlbWFudGljcy5vcGVyYXRpb25zW25hbWVdIHx8IHRoaXMuX3NlbWFudGljcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzVGhpbmcuZm9ybWFscy5tYXAoZm9ybWFsID0+IHNlbGYuYXJnc1tmb3JtYWxdKTtcblxuICAgIGlmICh0aGlzLmlzSXRlcmF0aW9uKCkpIHtcbiAgICAgIC8vIFRoaXMgQ1NUIG5vZGUgY29ycmVzcG9uZHMgdG8gYW4gaXRlcmF0aW9uIGV4cHJlc3Npb24gaW4gdGhlIGdyYW1tYXIgKCosICssIG9yID8pLiBUaGVcbiAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gbWFwIHRoaXMgb3BlcmF0aW9uIG9yIGF0dHJpYnV0ZSBvdmVyIGFsbCBvZiBpdHMgY2hpbGQgbm9kZXMuXG4gICAgICByZXR1cm4gY2hpbGRyZW4ubWFwKGNoaWxkID0+IGRvSXQuYXBwbHkoY2hpbGQsIGFyZ3MpKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIENTVCBub2RlIGNvcnJlc3BvbmRzIHRvIGEgbm9uLXRlcm1pbmFsIGluIHRoZSBncmFtbWFyIChlLmcuLCBBZGRFeHByKS4gVGhlIGZhY3QgdGhhdFxuICAgIC8vIHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhpcyBhY3Rpb24gZGljdGlvbmFyeSBkb2Vzbid0IGhhdmUgYW4gYWN0aW9uIGZvciB0aGlzIHBhcnRpY3VsYXJcbiAgICAvLyBub24tdGVybWluYWwgb3IgYSBnZW5lcmljIGBfbm9udGVybWluYWxgIGFjdGlvbi5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBBcyBhIGNvbnZlbmllbmNlLCBpZiB0aGlzIG5vZGUgb25seSBoYXMgb25lIGNoaWxkLCB3ZSBqdXN0IHJldHVybiB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyBhcHBseWluZyB0aGlzIG9wZXJhdGlvbiAvIGF0dHJpYnV0ZSB0byB0aGUgY2hpbGQgbm9kZS5cbiAgICAgIHJldHVybiBkb0l0LmFwcGx5KGNoaWxkcmVuWzBdLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0aHJvdyBhbiBleGNlcHRpb24gdG8gbGV0IHRoZSBwcm9ncmFtbWVyIGtub3cgdGhhdCB3ZSBkb24ndCBrbm93IHdoYXRcbiAgICAgIC8vIHRvIGRvIHdpdGggdGhpcyBub2RlLlxuICAgICAgdGhyb3cgZXJyb3JzLm1pc3NpbmdTZW1hbnRpY0FjdGlvbih0aGlzLmN0b3JOYW1lLCBuYW1lLCB0eXBlLCBnbG9iYWxBY3Rpb25TdGFjayk7XG4gICAgfVxuICB9O1xufVxuXG5TZW1hbnRpY3MucHJvdG90eXBlLmFkZE9wZXJhdGlvbk9yQXR0cmlidXRlID0gZnVuY3Rpb24odHlwZSwgc2lnbmF0dXJlLCBhY3Rpb25EaWN0KSB7XG4gIGNvbnN0IHR5cGVQbHVyYWwgPSB0eXBlICsgJ3MnO1xuXG4gIGNvbnN0IHBhcnNlZE5hbWVBbmRGb3JtYWxBcmdzID0gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlLCB0eXBlKTtcbiAgY29uc3QgbmFtZSA9IHBhcnNlZE5hbWVBbmRGb3JtYWxBcmdzLm5hbWU7XG4gIGNvbnN0IGZvcm1hbHMgPSBwYXJzZWROYW1lQW5kRm9ybWFsQXJncy5mb3JtYWxzO1xuXG4gIC8vIFRPRE86IGNoZWNrIHRoYXQgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZSBmb3JtYWwgYXJndW1lbnRzXG5cbiAgdGhpcy5hc3NlcnROZXdOYW1lKG5hbWUsIHR5cGUpO1xuXG4gIC8vIENyZWF0ZSB0aGUgYWN0aW9uIGRpY3Rpb25hcnkgZm9yIHRoaXMgb3BlcmF0aW9uIC8gYXR0cmlidXRlIHRoYXQgY29udGFpbnMgYSBgX2RlZmF1bHRgIGFjdGlvblxuICAvLyB3aGljaCBkZWZpbmVzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGl0ZXJhdGlvbiwgdGVybWluYWwsIGFuZCBub24tdGVybWluYWwgbm9kZXMuLi5cbiAgY29uc3QgYnVpbHRJbkRlZmF1bHQgPSBuZXdEZWZhdWx0QWN0aW9uKHR5cGUsIG5hbWUsIGRvSXQpO1xuICBjb25zdCByZWFsQWN0aW9uRGljdCA9IHtfZGVmYXVsdDogYnVpbHRJbkRlZmF1bHR9O1xuICAvLyAuLi4gYW5kIGFkZCBpbiB0aGUgYWN0aW9ucyBzdXBwbGllZCBieSB0aGUgcHJvZ3JhbW1lciwgd2hpY2ggbWF5IG92ZXJyaWRlIHNvbWUgb3IgYWxsIG9mIHRoZVxuICAvLyBkZWZhdWx0IG9uZXMuXG4gIE9iamVjdC5rZXlzKGFjdGlvbkRpY3QpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgcmVhbEFjdGlvbkRpY3RbbmFtZV0gPSBhY3Rpb25EaWN0W25hbWVdO1xuICB9KTtcblxuICBjb25zdCBlbnRyeSA9IHR5cGUgPT09ICdvcGVyYXRpb24nID9cbiAgICAgIG5ldyBPcGVyYXRpb24obmFtZSwgZm9ybWFscywgcmVhbEFjdGlvbkRpY3QsIGJ1aWx0SW5EZWZhdWx0KSA6XG4gICAgICBuZXcgQXR0cmlidXRlKG5hbWUsIHJlYWxBY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCk7XG5cbiAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBpcyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IChpdCB3aWxsIGhhcHBlbiBsYXRlciBhbnl3YXkpIGJ1dCBpdCdzIGJldHRlciB0b1xuICAvLyBjYXRjaCBlcnJvcnMgZWFybHkuXG4gIGVudHJ5LmNoZWNrQWN0aW9uRGljdCh0aGlzLmdyYW1tYXIpO1xuXG4gIHRoaXNbdHlwZVBsdXJhbF1bbmFtZV0gPSBlbnRyeTtcblxuICBmdW5jdGlvbiBkb0l0KCkge1xuICAgIC8vIERpc3BhdGNoIHRvIG1vc3Qgc3BlY2lmaWMgdmVyc2lvbiBvZiB0aGlzIG9wZXJhdGlvbiAvIGF0dHJpYnV0ZSAtLSBpdCBtYXkgaGF2ZSBiZWVuXG4gICAgLy8gb3ZlcnJpZGRlbiBieSBhIHN1Yi1zZW1hbnRpY3MuXG4gICAgY29uc3QgdGhpc1RoaW5nID0gdGhpcy5fc2VtYW50aWNzW3R5cGVQbHVyYWxdW25hbWVdO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgY2FsbGVyIHBhc3NlZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSB0aGlzVGhpbmcuZm9ybWFscy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCB0byAnICsgbmFtZSArICcgJyArIHR5cGUgKyAnIChleHBlY3RlZCAnICtcbiAgICAgICAgICB0aGlzVGhpbmcuZm9ybWFscy5sZW5ndGggKyAnLCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnKScpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbiBcImFyZ3VtZW50cyBvYmplY3RcIiBmcm9tIHRoZSBhcmd1bWVudHMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGlzXG4gICAgLy8gb3BlcmF0aW9uIC8gYXR0cmlidXRlLlxuICAgIGNvbnN0IGFyZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFyZ3VtZW50cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBmb3JtYWwgPSB0aGlzVGhpbmcuZm9ybWFsc1tpZHhdO1xuICAgICAgYXJnc1tmb3JtYWxdID0gYXJndW1lbnRzW2lkeF07XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkQXJncyA9IHRoaXMuYXJncztcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIGNvbnN0IGFucyA9IHRoaXNUaGluZy5leGVjdXRlKHRoaXMuX3NlbWFudGljcywgdGhpcyk7XG4gICAgdGhpcy5hcmdzID0gb2xkQXJncztcbiAgICByZXR1cm4gYW5zO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdvcGVyYXRpb24nKSB7XG4gICAgdGhpcy5XcmFwcGVyLnByb3RvdHlwZVtuYW1lXSA9IGRvSXQ7XG4gICAgdGhpcy5XcmFwcGVyLnByb3RvdHlwZVtuYW1lXS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdbJyArIG5hbWUgKyAnIG9wZXJhdGlvbl0nO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuV3JhcHBlci5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgIGdldDogZG9JdCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSAvLyBTbyB0aGUgcHJvcGVydHkgY2FuIGJlIGRlbGV0ZWQuXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuYXR0cmlidXRlS2V5cywgbmFtZSwge1xuICAgICAgdmFsdWU6IHV0aWwudW5pcXVlSWQobmFtZSlcbiAgICB9KTtcbiAgfVxufTtcblxuU2VtYW50aWNzLnByb3RvdHlwZS5leHRlbmRPcGVyYXRpb25PckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIGFjdGlvbkRpY3QpIHtcbiAgY29uc3QgdHlwZVBsdXJhbCA9IHR5cGUgKyAncyc7XG5cbiAgLy8gTWFrZSBzdXJlIHRoYXQgYG5hbWVgIHJlYWxseSBpcyBqdXN0IGEgbmFtZSwgaS5lLiwgdGhhdCBpdCBkb2Vzbid0IGFsc28gY29udGFpbiBmb3JtYWxzLlxuICBwYXJzZVNpZ25hdHVyZShuYW1lLCAnYXR0cmlidXRlJyk7XG5cbiAgaWYgKCEodGhpcy5zdXBlciAmJiBuYW1lIGluIHRoaXMuc3VwZXJbdHlwZVBsdXJhbF0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kICcgKyB0eXBlICsgXCIgJ1wiICsgbmFtZSArXG4gICAgICAgIFwiJzogZGlkIG5vdCBpbmhlcml0IGFuIFwiICsgdHlwZSArICcgd2l0aCB0aGF0IG5hbWUnKTtcbiAgfVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXNbdHlwZVBsdXJhbF0sIG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kICcgKyB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJyBhZ2FpblwiKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUgd2hvc2UgYWN0aW9uRGljdCBkZWxlZ2F0ZXMgdG8gdGhlIHN1cGVyIG9wZXJhdGlvbiAvXG4gIC8vIGF0dHJpYnV0ZSdzIGFjdGlvbkRpY3QsIGFuZCB3aGljaCBoYXMgYWxsIHRoZSBrZXlzIGZyb20gYGluaGVyaXRlZEFjdGlvbkRpY3RgLlxuICBjb25zdCBpbmhlcml0ZWRGb3JtYWxzID0gdGhpc1t0eXBlUGx1cmFsXVtuYW1lXS5mb3JtYWxzO1xuICBjb25zdCBpbmhlcml0ZWRBY3Rpb25EaWN0ID0gdGhpc1t0eXBlUGx1cmFsXVtuYW1lXS5hY3Rpb25EaWN0O1xuICBjb25zdCBuZXdBY3Rpb25EaWN0ID0gT2JqZWN0LmNyZWF0ZShpbmhlcml0ZWRBY3Rpb25EaWN0KTtcbiAgT2JqZWN0LmtleXMoYWN0aW9uRGljdCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICBuZXdBY3Rpb25EaWN0W25hbWVdID0gYWN0aW9uRGljdFtuYW1lXTtcbiAgfSk7XG5cbiAgdGhpc1t0eXBlUGx1cmFsXVtuYW1lXSA9IHR5cGUgPT09ICdvcGVyYXRpb24nID9cbiAgICAgIG5ldyBPcGVyYXRpb24obmFtZSwgaW5oZXJpdGVkRm9ybWFscywgbmV3QWN0aW9uRGljdCkgOlxuICAgICAgbmV3IEF0dHJpYnV0ZShuYW1lLCBuZXdBY3Rpb25EaWN0KTtcblxuICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgKGl0IHdpbGwgaGFwcGVuIGxhdGVyIGFueXdheSkgYnV0IGl0J3MgYmV0dGVyIHRvXG4gIC8vIGNhdGNoIGVycm9ycyBlYXJseS5cbiAgdGhpc1t0eXBlUGx1cmFsXVtuYW1lXS5jaGVja0FjdGlvbkRpY3QodGhpcy5ncmFtbWFyKTtcbn07XG5cblNlbWFudGljcy5wcm90b3R5cGUuYXNzZXJ0TmV3TmFtZSA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgaWYgKFdyYXBwZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGFkZCAnICsgdHlwZSArIFwiICdcIiArIG5hbWUgKyBcIic6IHRoYXQncyBhIHJlc2VydmVkIG5hbWVcIik7XG4gIH1cbiAgaWYgKG5hbWUgaW4gdGhpcy5vcGVyYXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGFkZCAnICsgdHlwZSArIFwiICdcIiArIG5hbWUgKyBcIic6IGFuIG9wZXJhdGlvbiB3aXRoIHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgfVxuICBpZiAobmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgYWRkICcgKyB0eXBlICsgXCIgJ1wiICsgbmFtZSArIFwiJzogYW4gYXR0cmlidXRlIHdpdGggdGhhdCBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICB9XG59O1xuXG4vLyBSZXR1cm5zIGEgd3JhcHBlciBmb3IgdGhlIGdpdmVuIENTVCBgbm9kZWAgaW4gdGhpcyBzZW1hbnRpY3MuXG4vLyBJZiBgbm9kZWAgaXMgYWxyZWFkeSBhIHdyYXBwZXIsIHJldHVybnMgYG5vZGVgIGl0c2VsZi4gIC8vIFRPRE86IHdoeSBpcyB0aGlzIG5lZWRlZD9cblNlbWFudGljcy5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKG5vZGUsIHNvdXJjZSwgb3B0QmFzZUludGVydmFsKSB7XG4gIGNvbnN0IGJhc2VJbnRlcnZhbCA9IG9wdEJhc2VJbnRlcnZhbCB8fCBzb3VyY2U7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGhpcy5XcmFwcGVyID8gbm9kZSA6IG5ldyB0aGlzLldyYXBwZXIobm9kZSwgc291cmNlLCBiYXNlSW50ZXJ2YWwpO1xufTtcblxuLy8gQ3JlYXRlcyBhIG5ldyBTZW1hbnRpY3MgaW5zdGFuY2UgZm9yIGBncmFtbWFyYCwgaW5oZXJpdGluZyBvcGVyYXRpb25zIGFuZCBhdHRyaWJ1dGVzIGZyb21cbi8vIGBvcHRTdXBlclNlbWFudGljc2AsIGlmIGl0IGlzIHNwZWNpZmllZC4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWN0cyBhcyBhIHByb3h5IGZvciB0aGUgbmV3XG4vLyBTZW1hbnRpY3MgaW5zdGFuY2UuIFdoZW4gdGhhdCBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggYSBDU1Qgbm9kZSBhcyBhbiBhcmd1bWVudCwgaXQgcmV0dXJuc1xuLy8gYSB3cmFwcGVyIGZvciB0aGF0IG5vZGUgd2hpY2ggZ2l2ZXMgYWNjZXNzIHRvIHRoZSBvcGVyYXRpb25zIGFuZCBhdHRyaWJ1dGVzIHByb3ZpZGVkIGJ5IHRoaXNcbi8vIHNlbWFudGljcy5cblNlbWFudGljcy5jcmVhdGVTZW1hbnRpY3MgPSBmdW5jdGlvbihncmFtbWFyLCBvcHRTdXBlclNlbWFudGljcykge1xuICBjb25zdCBzID0gbmV3IFNlbWFudGljcyhcbiAgICAgIGdyYW1tYXIsXG4gICAgICBvcHRTdXBlclNlbWFudGljcyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBvcHRTdXBlclNlbWFudGljcyA6XG4gICAgICAgICAgU2VtYW50aWNzLkJ1aWx0SW5TZW1hbnRpY3MuX2dldFNlbWFudGljcygpKTtcblxuICAvLyBUbyBlbmFibGUgY2xpZW50cyB0byBpbnZva2UgYSBzZW1hbnRpY3MgbGlrZSBhIGZ1bmN0aW9uLCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXMgYSBwcm94eVxuICAvLyBmb3IgYHNgLCB3aGljaCBpcyB0aGUgcmVhbCBgU2VtYW50aWNzYCBpbnN0YW5jZS5cbiAgY29uc3QgcHJveHkgPSBmdW5jdGlvbiBBU2VtYW50aWNzKG1hdGNoUmVzdWx0KSB7XG4gICAgaWYgKCEobWF0Y2hSZXN1bHQgaW5zdGFuY2VvZiBNYXRjaFJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1NlbWFudGljcyBleHBlY3RlZCBhIE1hdGNoUmVzdWx0LCBidXQgZ290ICcgKyBjb21tb24udW5leHBlY3RlZE9ialRvU3RyaW5nKG1hdGNoUmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChtYXRjaFJlc3VsdC5mYWlsZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IGFwcGx5IFNlbWFudGljcyB0byAnICsgbWF0Y2hSZXN1bHQudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3N0ID0gbWF0Y2hSZXN1bHQuX2NzdDtcbiAgICBpZiAoY3N0LmdyYW1tYXIgIT09IGdyYW1tYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCB1c2UgYSBNYXRjaFJlc3VsdCBmcm9tIGdyYW1tYXIgJ1wiICsgY3N0LmdyYW1tYXIubmFtZSArXG4gICAgICAgICAgXCInIHdpdGggYSBzZW1hbnRpY3MgZm9yICdcIiArIGdyYW1tYXIubmFtZSArIFwiJ1wiKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRTdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0obWF0Y2hSZXN1bHQuaW5wdXQpO1xuICAgIHJldHVybiBzLndyYXAoY3N0LCBpbnB1dFN0cmVhbS5pbnRlcnZhbChtYXRjaFJlc3VsdC5fY3N0T2Zmc2V0LCBtYXRjaFJlc3VsdC5pbnB1dC5sZW5ndGgpKTtcbiAgfTtcblxuICAvLyBGb3J3YXJkIHB1YmxpYyBtZXRob2RzIGZyb20gdGhlIHByb3h5IHRvIHRoZSBzZW1hbnRpY3MgaW5zdGFuY2UuXG4gIHByb3h5LmFkZE9wZXJhdGlvbiA9IGZ1bmN0aW9uKHNpZ25hdHVyZSwgYWN0aW9uRGljdCkge1xuICAgIHMuYWRkT3BlcmF0aW9uT3JBdHRyaWJ1dGUoJ29wZXJhdGlvbicsIHNpZ25hdHVyZSwgYWN0aW9uRGljdCk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICBwcm94eS5leHRlbmRPcGVyYXRpb24gPSBmdW5jdGlvbihuYW1lLCBhY3Rpb25EaWN0KSB7XG4gICAgcy5leHRlbmRPcGVyYXRpb25PckF0dHJpYnV0ZSgnb3BlcmF0aW9uJywgbmFtZSwgYWN0aW9uRGljdCk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICBwcm94eS5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCBhY3Rpb25EaWN0KSB7XG4gICAgcy5hZGRPcGVyYXRpb25PckF0dHJpYnV0ZSgnYXR0cmlidXRlJywgbmFtZSwgYWN0aW9uRGljdCk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICBwcm94eS5leHRlbmRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCBhY3Rpb25EaWN0KSB7XG4gICAgcy5leHRlbmRPcGVyYXRpb25PckF0dHJpYnV0ZSgnYXR0cmlidXRlJywgbmFtZSwgYWN0aW9uRGljdCk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICBwcm94eS5fZ2V0QWN0aW9uRGljdCA9IGZ1bmN0aW9uKG9wZXJhdGlvbk9yQXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHMub3BlcmF0aW9uc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdIHx8IHMuYXR0cmlidXRlc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG9wZXJhdGlvbk9yQXR0cmlidXRlTmFtZSArICdcIiBpcyBub3QgYSB2YWxpZCBvcGVyYXRpb24gb3IgYXR0cmlidXRlICcgK1xuICAgICAgICAnbmFtZSBpbiB0aGlzIHNlbWFudGljcyBmb3IgXCInICsgZ3JhbW1hci5uYW1lICsgJ1wiJyk7XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb24uYWN0aW9uRGljdDtcbiAgfTtcbiAgcHJveHkuX3JlbW92ZSA9IGZ1bmN0aW9uKG9wZXJhdGlvbk9yQXR0cmlidXRlTmFtZSkge1xuICAgIGxldCBzZW1hbnRpYztcbiAgICBpZiAob3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lIGluIHMub3BlcmF0aW9ucykge1xuICAgICAgc2VtYW50aWMgPSBzLm9wZXJhdGlvbnNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGRlbGV0ZSBzLm9wZXJhdGlvbnNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbk9yQXR0cmlidXRlTmFtZSBpbiBzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIHNlbWFudGljID0gcy5hdHRyaWJ1dGVzW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV07XG4gICAgICBkZWxldGUgcy5hdHRyaWJ1dGVzW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV07XG4gICAgfVxuICAgIGRlbGV0ZSBzLldyYXBwZXIucHJvdG90eXBlW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV07XG4gICAgcmV0dXJuIHNlbWFudGljO1xuICB9O1xuICBwcm94eS5nZXRPcGVyYXRpb25OYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzLm9wZXJhdGlvbnMpO1xuICB9O1xuICBwcm94eS5nZXRBdHRyaWJ1dGVOYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzLmF0dHJpYnV0ZXMpO1xuICB9O1xuICBwcm94eS5nZXRHcmFtbWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHMuZ3JhbW1hcjtcbiAgfTtcbiAgcHJveHkudG9SZWNpcGUgPSBmdW5jdGlvbihzZW1hbnRpY3NPbmx5KSB7XG4gICAgcmV0dXJuIHMudG9SZWNpcGUoc2VtYW50aWNzT25seSk7XG4gIH07XG5cbiAgLy8gTWFrZSB0aGUgcHJveHkncyB0b1N0cmluZygpIHdvcmsuXG4gIHByb3h5LnRvU3RyaW5nID0gcy50b1N0cmluZy5iaW5kKHMpO1xuXG4gIC8vIFJldHVybnMgdGhlIHNlbWFudGljcyBmb3IgdGhlIHByb3h5LlxuICBwcm94eS5fZ2V0U2VtYW50aWNzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHM7XG4gIH07XG5cbiAgcmV0dXJuIHByb3h5O1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gT3BlcmF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEFuIE9wZXJhdGlvbiByZXByZXNlbnRzIGEgZnVuY3Rpb24gdG8gYmUgYXBwbGllZCB0byBhIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIC0tIGl0J3MgdmVyeVxuLy8gc2ltaWxhciB0byBhIFZpc2l0b3IgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmlzaXRvcl9wYXR0ZXJuKS4gQW4gb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIGJ5XG4vLyByZWN1cnNpdmVseSB3YWxraW5nIHRoZSBDU1QsIGFuZCBhdCBlYWNoIG5vZGUsIGludm9raW5nIHRoZSBtYXRjaGluZyBzZW1hbnRpYyBhY3Rpb24gZnJvbVxuLy8gYGFjdGlvbkRpY3RgLiBTZWUgYE9wZXJhdGlvbi5wcm90b3R5cGUuZXhlY3V0ZWAgZm9yIGRldGFpbHMgb2YgaG93IGEgQ1NUIG5vZGUncyBtYXRjaGluZyBzZW1hbnRpY1xuLy8gYWN0aW9uIGlzIGZvdW5kLlxuY2xhc3MgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IobmFtZSwgZm9ybWFscywgYWN0aW9uRGljdCwgYnVpbHRJbkRlZmF1bHQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZm9ybWFscyA9IGZvcm1hbHM7XG4gICAgdGhpcy5hY3Rpb25EaWN0ID0gYWN0aW9uRGljdDtcbiAgICB0aGlzLmJ1aWx0SW5EZWZhdWx0ID0gYnVpbHRJbkRlZmF1bHQ7XG4gIH1cblxuICBjaGVja0FjdGlvbkRpY3QoZ3JhbW1hcikge1xuICAgIGdyYW1tYXIuX2NoZWNrVG9wRG93bkFjdGlvbkRpY3QodGhpcy50eXBlTmFtZSwgdGhpcy5uYW1lLCB0aGlzLmFjdGlvbkRpY3QpO1xuICB9XG5cbiAgLy8gRXhlY3V0ZSB0aGlzIG9wZXJhdGlvbiBvbiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIGBub2RlV3JhcHBlcmAgaW4gdGhlIGNvbnRleHQgb2YgdGhlXG4gIC8vIGdpdmVuIFNlbWFudGljcyBpbnN0YW5jZS5cbiAgZXhlY3V0ZShzZW1hbnRpY3MsIG5vZGVXcmFwcGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvb2sgZm9yIGEgc2VtYW50aWMgYWN0aW9uIHdob3NlIG5hbWUgbWF0Y2hlcyB0aGUgbm9kZSdzIGNvbnN0cnVjdG9yIG5hbWUsIHdoaWNoIGlzIGVpdGhlclxuICAgICAgLy8gdGhlIG5hbWUgb2YgYSBydWxlIGluIHRoZSBncmFtbWFyLCBvciAnX3Rlcm1pbmFsJyAoZm9yIGEgdGVybWluYWwgbm9kZSksIG9yICdfaXRlcicgKGZvciBhblxuICAgICAgLy8gaXRlcmF0aW9uIG5vZGUpLiBJbiB0aGUgbGF0dGVyIGNhc2UsIHRoZSBhY3Rpb24gZnVuY3Rpb24gcmVjZWl2ZXMgYSBzaW5nbGUgYXJndW1lbnQsIHdoaWNoXG4gICAgICAvLyBpcyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIENTVCBub2RlLlxuICAgICAgY29uc3QgY3Rvck5hbWUgPSBub2RlV3JhcHBlci5fbm9kZS5jdG9yTmFtZTtcbiAgICAgIGxldCBhY3Rpb25GbiA9IHRoaXMuYWN0aW9uRGljdFtjdG9yTmFtZV07XG4gICAgICBsZXQgYW5zO1xuICAgICAgaWYgKGFjdGlvbkZuKSB7XG4gICAgICAgIGdsb2JhbEFjdGlvblN0YWNrLnB1c2goW3RoaXMsIGN0b3JOYW1lXSk7XG4gICAgICAgIGFucyA9IHRoaXMuZG9BY3Rpb24oc2VtYW50aWNzLCBub2RlV3JhcHBlciwgYWN0aW9uRm4sIG5vZGVXcmFwcGVyLmlzSXRlcmF0aW9uKCkpO1xuICAgICAgICByZXR1cm4gYW5zO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgYWN0aW9uIGRpY3Rpb25hcnkgZG9lcyBub3QgY29udGFpbiBhIHNlbWFudGljIGFjdGlvbiBmb3IgdGhpcyBzcGVjaWZpYyB0eXBlIG9mIG5vZGUuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgbm9udGVybWluYWwgbm9kZSBhbmQgdGhlIHByb2dyYW1tZXIgaGFzIHByb3ZpZGVkIGEgYF9ub250ZXJtaW5hbGAgc2VtYW50aWNcbiAgICAgIC8vIGFjdGlvbiwgd2UgaW52b2tlIGl0OlxuICAgICAgaWYgKG5vZGVXcmFwcGVyLmlzTm9udGVybWluYWwoKSkge1xuICAgICAgICBhY3Rpb25GbiA9IHRoaXMuYWN0aW9uRGljdC5fbm9udGVybWluYWw7XG4gICAgICAgIGlmIChhY3Rpb25Gbikge1xuICAgICAgICAgIGdsb2JhbEFjdGlvblN0YWNrLnB1c2goW3RoaXMsICdfbm9udGVybWluYWwnLCBjdG9yTmFtZV0pO1xuICAgICAgICAgIGFucyA9IHRoaXMuZG9BY3Rpb24oc2VtYW50aWNzLCBub2RlV3JhcHBlciwgYWN0aW9uRm4sIHRydWUpO1xuICAgICAgICAgIHJldHVybiBhbnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBpbnZva2UgdGhlICdfZGVmYXVsdCcgc2VtYW50aWMgYWN0aW9uLlxuICAgICAgZ2xvYmFsQWN0aW9uU3RhY2sucHVzaChbdGhpcywgJ2RlZmF1bHQgYWN0aW9uJywgY3Rvck5hbWVdKTtcbiAgICAgIGFucyA9IHRoaXMuZG9BY3Rpb24oc2VtYW50aWNzLCBub2RlV3JhcHBlciwgdGhpcy5hY3Rpb25EaWN0Ll9kZWZhdWx0LCB0cnVlKTtcbiAgICAgIHJldHVybiBhbnM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGdsb2JhbEFjdGlvblN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEludm9rZSBgYWN0aW9uRm5gIG9uIHRoZSBDU1Qgbm9kZSB0aGF0IGNvcnJlc3BvbmRzIHRvIGBub2RlV3JhcHBlcmAsIGluIHRoZSBjb250ZXh0IG9mXG4gIC8vIGBzZW1hbnRpY3NgLiBJZiBgb3B0UGFzc0NoaWxkcmVuQXNBcnJheWAgaXMgdHJ1dGh5LCBgYWN0aW9uRm5gIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBzaW5nbGVcbiAgLy8gYXJndW1lbnQsIHdoaWNoIGlzIGFuIGFycmF5IG9mIHdyYXBwZXJzLiBPdGhlcndpc2UsIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGBhY3Rpb25GbmAgd2lsbFxuICAvLyBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoZSBDU1Qgbm9kZS5cbiAgZG9BY3Rpb24oc2VtYW50aWNzLCBub2RlV3JhcHBlciwgYWN0aW9uRm4sIG9wdFBhc3NDaGlsZHJlbkFzQXJyYXkpIHtcbiAgICByZXR1cm4gb3B0UGFzc0NoaWxkcmVuQXNBcnJheSA/XG4gICAgICAgIGFjdGlvbkZuLmNhbGwobm9kZVdyYXBwZXIsIG5vZGVXcmFwcGVyLl9jaGlsZHJlbigpKSA6XG4gICAgICAgIGFjdGlvbkZuLmFwcGx5KG5vZGVXcmFwcGVyLCBub2RlV3JhcHBlci5fY2hpbGRyZW4oKSk7XG4gIH1cbn1cblxuT3BlcmF0aW9uLnByb3RvdHlwZS50eXBlTmFtZSA9ICdvcGVyYXRpb24nO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBBdHRyaWJ1dGUgLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQXR0cmlidXRlcyBhcmUgT3BlcmF0aW9ucyB3aG9zZSByZXN1bHRzIGFyZSBtZW1vaXplZC4gVGhpcyBtZWFucyB0aGF0LCBmb3IgYW55IGdpdmVuIHNlbWFudGljcyxcbi8vIHRoZSBzZW1hbnRpYyBhY3Rpb24gZm9yIGEgQ1NUIG5vZGUgd2lsbCBiZSBpbnZva2VkIG5vIG1vcmUgdGhhbiBvbmNlLlxuY2xhc3MgQXR0cmlidXRlIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IobmFtZSwgYWN0aW9uRGljdCwgYnVpbHRJbkRlZmF1bHQpIHtcbiAgICBzdXBlcihuYW1lLCBbXSwgYWN0aW9uRGljdCwgYnVpbHRJbkRlZmF1bHQpO1xuICB9XG5cbiAgZXhlY3V0ZShzZW1hbnRpY3MsIG5vZGVXcmFwcGVyKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVXcmFwcGVyLl9ub2RlO1xuICAgIGNvbnN0IGtleSA9IHNlbWFudGljcy5hdHRyaWJ1dGVLZXlzW3RoaXMubmFtZV07XG4gICAgaWYgKCFub2RlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYSBzdXBlci1zZW5kIC0tIGlzbid0IEpTIGJlYXV0aWZ1bD8gOi9cbiAgICAgIG5vZGVba2V5XSA9IE9wZXJhdGlvbi5wcm90b3R5cGUuZXhlY3V0ZS5jYWxsKHRoaXMsIHNlbWFudGljcywgbm9kZVdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZVtrZXldO1xuICB9XG59XG5cbkF0dHJpYnV0ZS5wcm90b3R5cGUudHlwZU5hbWUgPSAnYXR0cmlidXRlJztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBEZWZlcnJlZCBpbml0aWFsaXphdGlvbiAtLS0tLS0tLS0tLS0tLS0tLVxuXG51dGlsLmF3YWl0QnVpbHRJblJ1bGVzKGJ1aWx0SW5SdWxlcyA9PiB7XG4gIGNvbnN0IG9wZXJhdGlvbnNBbmRBdHRyaWJ1dGVzR3JhbW1hciA9IHJlcXVpcmUoJy4uL2Rpc3Qvb3BlcmF0aW9ucy1hbmQtYXR0cmlidXRlcycpO1xuICBpbml0QnVpbHRJblNlbWFudGljcyhidWlsdEluUnVsZXMpO1xuICBpbml0UHJvdG90eXBlUGFyc2VyKG9wZXJhdGlvbnNBbmRBdHRyaWJ1dGVzR3JhbW1hcik7IC8vIHJlcXVpcmVzIEJ1aWx0SW5TZW1hbnRpY3Ncbn0pO1xuXG5mdW5jdGlvbiBpbml0QnVpbHRJblNlbWFudGljcyhidWlsdEluUnVsZXMpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICBlbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZXJhdGlvbigpO1xuICAgIH0sXG4gICAgbm9uRW1wdHkoZmlyc3QsIF8sIHJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZXJhdGlvbihbZmlyc3RdLmNvbmNhdChyZXN0LmNoaWxkcmVuKSk7XG4gICAgfVxuICB9O1xuXG4gIFNlbWFudGljcy5CdWlsdEluU2VtYW50aWNzID0gU2VtYW50aWNzXG4gICAgICAuY3JlYXRlU2VtYW50aWNzKGJ1aWx0SW5SdWxlcywgbnVsbClcbiAgICAgIC5hZGRPcGVyYXRpb24oJ2FzSXRlcmF0aW9uJywge1xuICAgICAgICBlbXB0eUxpc3RPZjogYWN0aW9ucy5lbXB0eSxcbiAgICAgICAgbm9uZW1wdHlMaXN0T2Y6IGFjdGlvbnMubm9uRW1wdHksXG4gICAgICAgIEVtcHR5TGlzdE9mOiBhY3Rpb25zLmVtcHR5LFxuICAgICAgICBOb25lbXB0eUxpc3RPZjogYWN0aW9ucy5ub25FbXB0eVxuICAgICAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRQcm90b3R5cGVQYXJzZXIoZ3JhbW1hcikge1xuICBwcm90b3R5cGVHcmFtbWFyU2VtYW50aWNzID0gZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKS5hZGRPcGVyYXRpb24oJ3BhcnNlJywge1xuICAgIEF0dHJpYnV0ZVNpZ25hdHVyZShuYW1lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLnBhcnNlKCksXG4gICAgICAgIGZvcm1hbHM6IFtdXG4gICAgICB9O1xuICAgIH0sXG4gICAgT3BlcmF0aW9uU2lnbmF0dXJlKG5hbWUsIG9wdEZvcm1hbHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUucGFyc2UoKSxcbiAgICAgICAgZm9ybWFsczogb3B0Rm9ybWFscy5wYXJzZSgpWzBdIHx8IFtdXG4gICAgICB9O1xuICAgIH0sXG4gICAgRm9ybWFscyhvcGFyZW4sIGZzLCBjcGFyZW4pIHtcbiAgICAgIHJldHVybiBmcy5hc0l0ZXJhdGlvbigpLnBhcnNlKCk7XG4gICAgfSxcbiAgICBuYW1lKGZpcnN0LCByZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VTdHJpbmc7XG4gICAgfVxuICB9KTtcbiAgcHJvdG90eXBlR3JhbW1hciA9IGdyYW1tYXI7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1hbnRpY3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWwnKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgYHRvU3RyaW5nYCBvdXRwdXQuXG5jb25zdCBCQUxMT1RfWCA9ICdcXHUyNzE3JztcbmNvbnN0IENIRUNLX01BUksgPSAnXFx1MjcxMyc7XG5jb25zdCBET1RfT1BFUkFUT1IgPSAnXFx1MjJDNSc7XG5jb25zdCBSSUdIVFdBUkRTX0RPVUJMRV9BUlJPVyA9ICdcXHUyMUQyJztcbmNvbnN0IFNZTUJPTF9GT1JfSE9SSVpPTlRBTF9UQUJVTEFUSU9OID0gJ1xcdTI0MDknO1xuY29uc3QgU1lNQk9MX0ZPUl9MSU5FX0ZFRUQgPSAnXFx1MjQwQSc7XG5jb25zdCBTWU1CT0xfRk9SX0NBUlJJQUdFX1JFVFVSTiA9ICdcXHUyNDBEJztcblxuY29uc3QgRmxhZ3MgPSB7XG4gIHN1Y2NlZWRlZDogMSA8PCAwLFxuICBpc1Jvb3ROb2RlOiAxIDw8IDEsXG4gIGlzSW1wbGljaXRTcGFjZXM6IDEgPDwgMixcbiAgaXNNZW1vaXplZDogMSA8PCAzLFxuICBpc0hlYWRPZkxlZnRSZWN1cnNpb246IDEgPDwgNCxcbiAgdGVybWluYXRlc0xSOiAxIDw8IDVcbn07XG5cbmZ1bmN0aW9uIHNwYWNlcyhuKSB7XG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgbikuam9pbignJyk7XG59XG5cbi8vIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHBvcnRpb24gb2YgYGlucHV0YCBhdCBvZmZzZXQgYHBvc2AuXG4vLyBUaGUgcmVzdWx0IHdpbGwgY29udGFpbiBleGFjdGx5IGBsZW5gIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiBnZXRJbnB1dEV4Y2VycHQoaW5wdXQsIHBvcywgbGVuKSB7XG4gIGNvbnN0IGV4Y2VycHQgPSBhc0VzY2FwZWRTdHJpbmcoaW5wdXQuc2xpY2UocG9zLCBwb3MgKyBsZW4pKTtcblxuICAvLyBQYWQgdGhlIG91dHB1dCBpZiBuZWNlc3NhcnkuXG4gIGlmIChleGNlcnB0Lmxlbmd0aCA8IGxlbikge1xuICAgIHJldHVybiBleGNlcnB0ICsgY29tbW9uLnJlcGVhdCgnICcsIGxlbiAtIGV4Y2VycHQubGVuZ3RoKS5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gZXhjZXJwdDtcbn1cblxuZnVuY3Rpb24gYXNFc2NhcGVkU3RyaW5nKG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBSZXBsYWNlIG5vbi1wcmludGFibGUgY2hhcmFjdGVycyB3aXRoIHZpc2libGUgc3ltYm9scy5cbiAgICByZXR1cm4gb2JqXG4gICAgICAgIC5yZXBsYWNlKC8gL2csIERPVF9PUEVSQVRPUilcbiAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCBTWU1CT0xfRk9SX0hPUklaT05UQUxfVEFCVUxBVElPTilcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBTWU1CT0xfRk9SX0xJTkVfRkVFRClcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCBTWU1CT0xfRk9SX0NBUlJJQUdFX1JFVFVSTik7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBUcmFjZSAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBUcmFjZShpbnB1dCwgcG9zMSwgcG9zMiwgZXhwciwgc3VjY2VlZGVkLCBiaW5kaW5ncywgb3B0Q2hpbGRyZW4pIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB0aGlzLnBvcyA9IHRoaXMucG9zMSA9IHBvczE7XG4gIHRoaXMucG9zMiA9IHBvczI7XG4gIHRoaXMuc291cmNlID0gbmV3IEludGVydmFsKGlucHV0LCBwb3MxLCBwb3MyKTtcbiAgdGhpcy5leHByID0gZXhwcjtcbiAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICB0aGlzLmNoaWxkcmVuID0gb3B0Q2hpbGRyZW4gfHwgW107XG4gIHRoaXMudGVybWluYXRpbmdMUkVudHJ5ID0gbnVsbDtcblxuICB0aGlzLl9mbGFncyA9IHN1Y2NlZWRlZCA/IEZsYWdzLnN1Y2NlZWRlZCA6IDA7XG59XG5cbi8vIEEgdmFsdWUgdGhhdCBjYW4gYmUgcmV0dXJuZWQgZnJvbSB2aXNpdG9yIGZ1bmN0aW9ucyB0byBpbmRpY2F0ZSB0aGF0IGFcbi8vIG5vZGUgc2hvdWxkIG5vdCBiZSByZWN1cnNlZCBpbnRvLlxuVHJhY2UucHJvdG90eXBlLlNLSVAgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYWNlLnByb3RvdHlwZSwgJ2Rpc3BsYXlTdHJpbmcnLCB7XG4gIGdldCgpIHsgcmV0dXJuIHRoaXMuZXhwci50b0Rpc3BsYXlTdHJpbmcoKTsgfVxufSk7XG5cbi8vIEZvciBjb252ZW5pZW5jZSwgY3JlYXRlIGEgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHRoZSBib29sZWFuIGZsYWdzIGluIGBGbGFnc2AuXG5PYmplY3Qua2V5cyhGbGFncykuZm9yRWFjaChuYW1lID0+IHtcbiAgY29uc3QgbWFzayA9IEZsYWdzW25hbWVdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2UucHJvdG90eXBlLCBuYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIG1hc2spICE9PSAwO1xuICAgIH0sXG4gICAgc2V0KHZhbCkge1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLl9mbGFncyB8PSBtYXNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MgJj0gfm1hc2s7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pO1xuXG5UcmFjZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmVXaXRoRXhwcih0aGlzLmV4cHIpO1xufTtcblxuVHJhY2UucHJvdG90eXBlLmNsb25lV2l0aEV4cHIgPSBmdW5jdGlvbihleHByKSB7XG4gIGNvbnN0IGFucyA9IG5ldyBUcmFjZShcbiAgICAgIHRoaXMuaW5wdXQsIHRoaXMucG9zLCB0aGlzLnBvczIsIGV4cHIsIHRoaXMuc3VjY2VlZGVkLCB0aGlzLmJpbmRpbmdzLCB0aGlzLmNoaWxkcmVuKTtcblxuICBhbnMuaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uID0gdGhpcy5pc0hlYWRPZkxlZnRSZWN1cnNpb247XG4gIGFucy5pc0ltcGxpY2l0U3BhY2VzID0gdGhpcy5pc0ltcGxpY2l0U3BhY2VzO1xuICBhbnMuaXNNZW1vaXplZCA9IHRoaXMuaXNNZW1vaXplZDtcbiAgYW5zLmlzUm9vdE5vZGUgPSB0aGlzLmlzUm9vdE5vZGU7XG4gIGFucy50ZXJtaW5hdGVzTFIgPSB0aGlzLnRlcm1pbmF0ZXNMUjtcbiAgYW5zLnRlcm1pbmF0aW5nTFJFbnRyeSA9IHRoaXMudGVybWluYXRpbmdMUkVudHJ5O1xuICByZXR1cm4gYW5zO1xufTtcblxuLy8gUmVjb3JkIHRoZSB0cmFjZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHRlcm1pbmF0aW5nIGNvbmRpdGlvbiBvZiB0aGUgTFIgbG9vcC5cblRyYWNlLnByb3RvdHlwZS5yZWNvcmRMUlRlcm1pbmF0aW9uID0gZnVuY3Rpb24ocnVsZUJvZHlUcmFjZSwgdmFsdWUpIHtcbiAgdGhpcy50ZXJtaW5hdGluZ0xSRW50cnkgPVxuICAgICAgbmV3IFRyYWNlKHRoaXMuaW5wdXQsIHRoaXMucG9zLCB0aGlzLnBvczIsIHRoaXMuZXhwciwgZmFsc2UsIFt2YWx1ZV0sIFtydWxlQm9keVRyYWNlXSk7XG4gIHRoaXMudGVybWluYXRpbmdMUkVudHJ5LnRlcm1pbmF0ZXNMUiA9IHRydWU7XG59O1xuXG4vLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSB0aGlzIHRyYWNlIG5vZGUgYW5kIGFsbCBpdHMgZGVzY2VuZGVudHMsIGNhbGxpbmcgYSB2aXNpdG9yIGZ1bmN0aW9uXG4vLyBmb3IgZWFjaCBub2RlIHRoYXQgaXMgdmlzaXRlZC4gSWYgYHZpc3Rvck9iak9yRm5gIGlzIGFuIG9iamVjdCwgdGhlbiBpdHMgJ2VudGVyJyBwcm9wZXJ0eVxuLy8gaXMgYSBmdW5jdGlvbiB0byBjYWxsIGJlZm9yZSB2aXNpdGluZyB0aGUgY2hpbGRyZW4gb2YgYSBub2RlLCBhbmQgaXRzICdleGl0JyBwcm9wZXJ0eSBpc1xuLy8gYSBmdW5jdGlvbiB0byBjYWxsIGFmdGVyd2FyZHMuIElmIGB2aXNpdG9yT2JqT3JGbmAgaXMgYSBmdW5jdGlvbiwgaXQgcmVwcmVzZW50cyB0aGUgJ2VudGVyJ1xuLy8gZnVuY3Rpb24uXG4vL1xuLy8gVGhlIGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiB0aGUgVHJhY2Ugbm9kZSwgaXRzIHBhcmVudCBUcmFjZSwgYW5kIGEgbnVtYmVyXG4vLyByZXByZXNlbnRpbmcgdGhlIGRlcHRoIG9mIHRoZSBub2RlIGluIHRoZSB0cmVlLiAoVGhlIHJvb3Qgbm9kZSBoYXMgZGVwdGggMC4pIGBvcHRUaGlzQXJnYCwgaWZcbi8vIHNwZWNpZmllZCwgaXMgdGhlIHZhbHVlIHRvIHVzZSBmb3IgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIHRoZSB2aXNpdG9yIGZ1bmN0aW9ucy5cblRyYWNlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24odmlzaXRvck9iak9yRm4sIG9wdFRoaXNBcmcpIHtcbiAgbGV0IHZpc2l0b3IgPSB2aXNpdG9yT2JqT3JGbjtcbiAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmlzaXRvciA9IHtlbnRlcjogdmlzaXRvcn07XG4gIH1cblxuICBmdW5jdGlvbiBfd2Fsayhub2RlLCBwYXJlbnQsIGRlcHRoKSB7XG4gICAgbGV0IHJlY3Vyc2UgPSB0cnVlO1xuICAgIGlmICh2aXNpdG9yLmVudGVyKSB7XG4gICAgICBpZiAodmlzaXRvci5lbnRlci5jYWxsKG9wdFRoaXNBcmcsIG5vZGUsIHBhcmVudCwgZGVwdGgpID09PSBUcmFjZS5wcm90b3R5cGUuU0tJUCkge1xuICAgICAgICByZWN1cnNlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICBfd2FsayhjaGlsZCwgbm9kZSwgZGVwdGggKyAxKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHZpc2l0b3IuZXhpdCkge1xuICAgICAgICB2aXNpdG9yLmV4aXQuY2FsbChvcHRUaGlzQXJnLCBub2RlLCBwYXJlbnQsIGRlcHRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuaXNSb290Tm9kZSkge1xuICAgIC8vIERvbid0IHZpc2l0IHRoZSByb290IG5vZGUgaXRzZWxmLCBvbmx5IGl0cyBjaGlsZHJlbi5cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goYyA9PiB7IF93YWxrKGMsIG51bGwsIDApOyB9KTtcbiAgfSBlbHNlIHtcbiAgICBfd2Fsayh0aGlzLCBudWxsLCAwKTtcbiAgfVxufTtcblxuLy8gUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFjZS5cbi8vIFNhbXBsZTpcbi8vICAgICAxMuKLhSvii4Uy4ouFKuKLhTMg4pyTIGV4cCDih5IgIFwiMTJcIlxuLy8gICAgIDEy4ouFK+KLhTLii4Uq4ouFMyAgIOKckyBhZGRFeHAgKExSKSDih5IgIFwiMTJcIlxuLy8gICAgIDEy4ouFK+KLhTLii4Uq4ouFMyAgICAgICDinJcgYWRkRXhwX3BsdXNcblRyYWNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzYiA9IG5ldyBjb21tb24uU3RyaW5nQnVmZmVyKCk7XG4gIHRoaXMud2Fsaygobm9kZSwgcGFyZW50LCBkZXB0aCkgPT4ge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuU0tJUDtcbiAgICB9XG4gICAgY29uc3QgY3Rvck5hbWUgPSBub2RlLmV4cHIuY29uc3RydWN0b3IubmFtZTtcbiAgICAvLyBEb24ndCBwcmludCBhbnl0aGluZyBmb3IgQWx0IG5vZGVzLlxuICAgIGlmIChjdG9yTmFtZSA9PT0gJ0FsdCcpIHtcbiAgICAgIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgIH1cbiAgICBzYi5hcHBlbmQoZ2V0SW5wdXRFeGNlcnB0KG5vZGUuaW5wdXQsIG5vZGUucG9zLCAxMCkgKyBzcGFjZXMoZGVwdGggKiAyICsgMSkpO1xuICAgIHNiLmFwcGVuZCgobm9kZS5zdWNjZWVkZWQgPyBDSEVDS19NQVJLIDogQkFMTE9UX1gpICsgJyAnICsgbm9kZS5kaXNwbGF5U3RyaW5nKTtcbiAgICBpZiAobm9kZS5pc0hlYWRPZkxlZnRSZWN1cnNpb24pIHtcbiAgICAgIHNiLmFwcGVuZCgnIChMUiknKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuc3VjY2VlZGVkKSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IGFzRXNjYXBlZFN0cmluZyhub2RlLnNvdXJjZS5jb250ZW50cyk7XG4gICAgICBzYi5hcHBlbmQoJyAnICsgUklHSFRXQVJEU19ET1VCTEVfQVJST1cgKyAnICAnKTtcbiAgICAgIHNiLmFwcGVuZCh0eXBlb2YgY29udGVudHMgPT09ICdzdHJpbmcnID8gJ1wiJyArIGNvbnRlbnRzICsgJ1wiJyA6IGNvbnRlbnRzKTtcbiAgICB9XG4gICAgc2IuYXBwZW5kKCdcXG4nKTtcbiAgfSk7XG4gIHJldHVybiBzYi5jb250ZW50cygpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd1dGlsLWV4dGVuZCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBTdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gSGVscGVyc1xuXG5jb25zdCBlc2NhcGVTdHJpbmdGb3IgPSB7fTtcbmZvciAobGV0IGMgPSAwOyBjIDwgMTI4OyBjKyspIHtcbiAgZXNjYXBlU3RyaW5nRm9yW2NdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbn1cbmVzY2FwZVN0cmluZ0ZvcltcIidcIi5jaGFyQ29kZUF0KDApXSA9IFwiXFxcXCdcIjtcbmVzY2FwZVN0cmluZ0ZvclsnXCInLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxcIic7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcXFwnLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxcXFxcJztcbmVzY2FwZVN0cmluZ0ZvclsnXFxiJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcYic7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcZicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXGYnO1xuZXNjYXBlU3RyaW5nRm9yWydcXG4nLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxuJztcbmVzY2FwZVN0cmluZ0ZvclsnXFxyJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxccic7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcdCcuY2hhckNvZGVBdCgwKV0gPSAnXFxcXHQnO1xuZXNjYXBlU3RyaW5nRm9yWydcXHUwMDBiJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcdic7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLmFic3RyYWN0ID0gZnVuY3Rpb24ob3B0TWV0aG9kTmFtZSkge1xuICBjb25zdCBtZXRob2ROYW1lID0gb3B0TWV0aG9kTmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3RoaXMgbWV0aG9kICcgKyBtZXRob2ROYW1lICsgJyBpcyBhYnN0cmFjdCEgJyArXG4gICAgICAnKGl0IGhhcyBubyBpbXBsZW1lbnRhdGlvbiBpbiBjbGFzcyAnICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyknKTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuYXNzZXJ0ID0gZnVuY3Rpb24oY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5cbi8vIERlZmluZSBhIGxhemlseS1jb21wdXRlZCwgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgbmFtZWQgYHByb3BOYW1lYFxuLy8gb24gdGhlIG9iamVjdCBgb2JqYC4gYGdldHRlckZuYCB3aWxsIGJlIGNhbGxlZCB0byBjb21wdXRlIHRoZSB2YWx1ZSB0aGVcbi8vIGZpcnN0IHRpbWUgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuZXhwb3J0cy5kZWZpbmVMYXp5UHJvcGVydHkgPSBmdW5jdGlvbihvYmosIHByb3BOYW1lLCBnZXR0ZXJGbikge1xuICBsZXQgbWVtbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcE5hbWUsIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAoIW1lbW8pIHtcbiAgICAgICAgbWVtbyA9IGdldHRlckZuLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAob2JqKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5cbmV4cG9ydHMucmVwZWF0Rm4gPSBmdW5jdGlvbihmbiwgbikge1xuICBjb25zdCBhcnIgPSBbXTtcbiAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICBhcnIucHVzaChmbigpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuZXhwb3J0cy5yZXBlYXRTdHIgPSBmdW5jdGlvbihzdHIsIG4pIHtcbiAgcmV0dXJuIG5ldyBBcnJheShuICsgMSkuam9pbihzdHIpO1xufTtcblxuZXhwb3J0cy5yZXBlYXQgPSBmdW5jdGlvbih4LCBuKSB7XG4gIHJldHVybiBleHBvcnRzLnJlcGVhdEZuKCgpID0+IHgsIG4pO1xufTtcblxuZXhwb3J0cy5nZXREdXBsaWNhdGVzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgY29uc3QgZHVwbGljYXRlcyA9IFtdO1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcnJheS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgY29uc3QgeCA9IGFycmF5W2lkeF07XG4gICAgaWYgKGFycmF5Lmxhc3RJbmRleE9mKHgpICE9PSBpZHggJiYgZHVwbGljYXRlcy5pbmRleE9mKHgpIDwgMCkge1xuICAgICAgZHVwbGljYXRlcy5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVwbGljYXRlcztcbn07XG5cbmV4cG9ydHMuY29weVdpdGhvdXREdXBsaWNhdGVzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgY29uc3Qgbm9EdXBsaWNhdGVzID0gW107XG4gIGFycmF5LmZvckVhY2goZW50cnkgPT4ge1xuICAgIGlmIChub0R1cGxpY2F0ZXMuaW5kZXhPZihlbnRyeSkgPCAwKSB7XG4gICAgICBub0R1cGxpY2F0ZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5vRHVwbGljYXRlcztcbn07XG5cbmV4cG9ydHMuaXNTeW50YWN0aWMgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICBjb25zdCBmaXJzdENoYXIgPSBydWxlTmFtZVswXTtcbiAgcmV0dXJuIGZpcnN0Q2hhciA9PT0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5leHBvcnRzLmlzTGV4aWNhbCA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIHJldHVybiAhZXhwb3J0cy5pc1N5bnRhY3RpYyhydWxlTmFtZSk7XG59O1xuXG5leHBvcnRzLnBhZExlZnQgPSBmdW5jdGlvbihzdHIsIGxlbiwgb3B0Q2hhcikge1xuICBjb25zdCBjaCA9IG9wdENoYXIgfHwgJyAnO1xuICBpZiAoc3RyLmxlbmd0aCA8IGxlbikge1xuICAgIHJldHVybiBleHBvcnRzLnJlcGVhdFN0cihjaCwgbGVuIC0gc3RyLmxlbmd0aCkgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8vIFN0cmluZ0J1ZmZlclxuXG5leHBvcnRzLlN0cmluZ0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0cmluZ3MgPSBbXTtcbn07XG5cbmV4cG9ydHMuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihzdHIpIHtcbiAgdGhpcy5zdHJpbmdzLnB1c2goc3RyKTtcbn07XG5cbmV4cG9ydHMuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jb250ZW50cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zdHJpbmdzLmpvaW4oJycpO1xufTtcblxuLy8gQ2hhcmFjdGVyIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nXG5cbmV4cG9ydHMuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKGMsIG9wdERlbGltKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICBpZiAoKGMgPT09ICdcIicgfHwgYyA9PT0gXCInXCIpICYmIG9wdERlbGltICYmIGMgIT09IG9wdERlbGltKSB7XG4gICAgcmV0dXJuIGM7XG4gIH0gZWxzZSBpZiAoY2hhckNvZGUgPCAxMjgpIHtcbiAgICByZXR1cm4gZXNjYXBlU3RyaW5nRm9yW2NoYXJDb2RlXTtcbiAgfSBlbHNlIGlmICgxMjggPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPCAyNTYpIHtcbiAgICByZXR1cm4gJ1xcXFx4JyArIGV4cG9ydHMucGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNiksIDIsICcwJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdcXFxcdScgKyBleHBvcnRzLnBhZExlZnQoY2hhckNvZGUudG9TdHJpbmcoMTYpLCA0LCAnMCcpO1xuICB9XG59O1xuXG5leHBvcnRzLnVuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKHMpIHtcbiAgaWYgKHMuY2hhckF0KDApID09PSAnXFxcXCcpIHtcbiAgICBzd2l0Y2ggKHMuY2hhckF0KDEpKSB7XG4gICAgICBjYXNlICdiJzogcmV0dXJuICdcXGInO1xuICAgICAgY2FzZSAnZic6IHJldHVybiAnXFxmJztcbiAgICAgIGNhc2UgJ24nOiByZXR1cm4gJ1xcbic7XG4gICAgICBjYXNlICdyJzogcmV0dXJuICdcXHInO1xuICAgICAgY2FzZSAndCc6IHJldHVybiAnXFx0JztcbiAgICAgIGNhc2UgJ3YnOiByZXR1cm4gJ1xcdic7XG4gICAgICBjYXNlICd4JzogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocy5zdWJzdHJpbmcoMiwgNCksIDE2KSk7XG4gICAgICBjYXNlICd1JzogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocy5zdWJzdHJpbmcoMiwgNiksIDE2KSk7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gcy5jaGFyQXQoMSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZm9yIHByb2R1Y2luZyBhIGRlc2NyaXB0aW9uIG9mIGFuIHVua25vd24gb2JqZWN0IGluIGEgc2FmZSB3YXkuXG4vLyBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgZXJyb3IgbWVzc2FnZXMgd2hlcmUgYW4gdW5leHBlY3RlZCB0eXBlIG9mIG9iamVjdCB3YXMgZW5jb3VudGVyZWQuXG5leHBvcnRzLnVuZXhwZWN0ZWRPYmpUb1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gU3RyaW5nKG9iaik7XG4gIH1cbiAgY29uc3QgYmFzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIHRyeSB7XG4gICAgbGV0IHR5cGVOYW1lO1xuICAgIGlmIChvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHR5cGVOYW1lID0gb2JqLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfSBlbHNlIGlmIChiYXNlVG9TdHJpbmcuaW5kZXhPZignW29iamVjdCAnKSA9PT0gMCkge1xuICAgICAgdHlwZU5hbWUgPSBiYXNlVG9TdHJpbmcuc2xpY2UoOCwgLTEpOyAvLyBFeHRyYWN0IGUuZy4gXCJBcnJheVwiIGZyb20gXCJbb2JqZWN0IEFycmF5XVwiLlxuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlTmFtZSA9IHR5cGVvZiBvYmo7XG4gICAgfVxuICAgIHJldHVybiB0eXBlTmFtZSArICc6ICcgKyBKU09OLnN0cmluZ2lmeShTdHJpbmcob2JqKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gYmFzZVRvU3RyaW5nO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuY29uc3QgTmFtZXNwYWNlID0gcmVxdWlyZSgnLi9OYW1lc3BhY2UnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIG9wdEludGVydmFsKSB7XG4gIGxldCBlO1xuICBpZiAob3B0SW50ZXJ2YWwpIHtcbiAgICBlID0gbmV3IEVycm9yKG9wdEludGVydmFsLmdldExpbmVBbmRDb2x1bW5NZXNzYWdlKCkgKyBtZXNzYWdlKTtcbiAgICBlLnNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgZS5pbnRlcnZhbCA9IG9wdEludGVydmFsO1xuICB9IGVsc2Uge1xuICAgIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIGVycm9ycyBhYm91dCBpbnRlcnZhbHMgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaW50ZXJ2YWxTb3VyY2VzRG9udE1hdGNoKCkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXCJJbnRlcnZhbCBzb3VyY2VzIGRvbid0IG1hdGNoXCIpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBlcnJvcnMgYWJvdXQgZ3JhbW1hcnMgLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gR3JhbW1hciBzeW50YXggZXJyb3JcblxuZnVuY3Rpb24gZ3JhbW1hclN5bnRheEVycm9yKG1hdGNoRmFpbHVyZSkge1xuICBjb25zdCBlID0gbmV3IEVycm9yKCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnbWVzc2FnZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBtYXRjaEZhaWx1cmUubWVzc2FnZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ3Nob3J0TWVzc2FnZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiAnRXhwZWN0ZWQgJyArIG1hdGNoRmFpbHVyZS5nZXRFeHBlY3RlZFRleHQoKTtcbiAgICB9XG4gIH0pO1xuICBlLmludGVydmFsID0gbWF0Y2hGYWlsdXJlLmdldEludGVydmFsKCk7XG4gIHJldHVybiBlO1xufVxuXG4vLyBVbmRlY2xhcmVkIGdyYW1tYXJcblxuZnVuY3Rpb24gdW5kZWNsYXJlZEdyYW1tYXIoZ3JhbW1hck5hbWUsIG5hbWVzcGFjZSwgaW50ZXJ2YWwpIHtcbiAgY29uc3QgbWVzc2FnZSA9IG5hbWVzcGFjZSA/XG4gICAgICAnR3JhbW1hciAnICsgZ3JhbW1hck5hbWUgKyAnIGlzIG5vdCBkZWNsYXJlZCBpbiBuYW1lc3BhY2UgJyArIE5hbWVzcGFjZS50b1N0cmluZyhuYW1lc3BhY2UpIDpcbiAgICAgICdVbmRlY2xhcmVkIGdyYW1tYXIgJyArIGdyYW1tYXJOYW1lO1xuICByZXR1cm4gY3JlYXRlRXJyb3IobWVzc2FnZSwgaW50ZXJ2YWwpO1xufVxuXG4vLyBEdXBsaWNhdGUgZ3JhbW1hciBkZWNsYXJhdGlvblxuXG5mdW5jdGlvbiBkdXBsaWNhdGVHcmFtbWFyRGVjbGFyYXRpb24oZ3JhbW1hciwgbmFtZXNwYWNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcignR3JhbW1hciAnICsgZ3JhbW1hci5uYW1lICsgJyBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoaXMgbmFtZXNwYWNlJyk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIHJ1bGVzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFVuZGVjbGFyZWQgcnVsZVxuXG5mdW5jdGlvbiB1bmRlY2xhcmVkUnVsZShydWxlTmFtZSwgZ3JhbW1hck5hbWUsIG9wdEludGVydmFsKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdSdWxlICcgKyBydWxlTmFtZSArICcgaXMgbm90IGRlY2xhcmVkIGluIGdyYW1tYXIgJyArIGdyYW1tYXJOYW1lLFxuICAgICAgb3B0SW50ZXJ2YWwpO1xufVxuXG4vLyBDYW5ub3Qgb3ZlcnJpZGUgdW5kZWNsYXJlZCBydWxlXG5cbmZ1bmN0aW9uIGNhbm5vdE92ZXJyaWRlVW5kZWNsYXJlZFJ1bGUocnVsZU5hbWUsIGdyYW1tYXJOYW1lLCBvcHRTb3VyY2UpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ0Nhbm5vdCBvdmVycmlkZSBydWxlICcgKyBydWxlTmFtZSArICcgYmVjYXVzZSBpdCBpcyBub3QgZGVjbGFyZWQgaW4gJyArIGdyYW1tYXJOYW1lLFxuICAgICAgb3B0U291cmNlKTtcbn1cblxuLy8gQ2Fubm90IGV4dGVuZCB1bmRlY2xhcmVkIHJ1bGVcblxuZnVuY3Rpb24gY2Fubm90RXh0ZW5kVW5kZWNsYXJlZFJ1bGUocnVsZU5hbWUsIGdyYW1tYXJOYW1lLCBvcHRTb3VyY2UpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ0Nhbm5vdCBleHRlbmQgcnVsZSAnICsgcnVsZU5hbWUgKyAnIGJlY2F1c2UgaXQgaXMgbm90IGRlY2xhcmVkIGluICcgKyBncmFtbWFyTmFtZSxcbiAgICAgIG9wdFNvdXJjZSk7XG59XG5cbi8vIER1cGxpY2F0ZSBydWxlIGRlY2xhcmF0aW9uXG5cbmZ1bmN0aW9uIGR1cGxpY2F0ZVJ1bGVEZWNsYXJhdGlvbihydWxlTmFtZSwgZ3JhbW1hck5hbWUsIGRlY2xHcmFtbWFyTmFtZSwgb3B0U291cmNlKSB7XG4gIGxldCBtZXNzYWdlID0gXCJEdXBsaWNhdGUgZGVjbGFyYXRpb24gZm9yIHJ1bGUgJ1wiICsgcnVsZU5hbWUgK1xuICAgICAgXCInIGluIGdyYW1tYXIgJ1wiICsgZ3JhbW1hck5hbWUgKyBcIidcIjtcbiAgaWYgKGdyYW1tYXJOYW1lICE9PSBkZWNsR3JhbW1hck5hbWUpIHtcbiAgICBtZXNzYWdlICs9IFwiIChvcmlnaW5hbGx5IGRlY2xhcmVkIGluICdcIiArIGRlY2xHcmFtbWFyTmFtZSArIFwiJylcIjtcbiAgfVxuICByZXR1cm4gY3JlYXRlRXJyb3IobWVzc2FnZSwgb3B0U291cmNlKTtcbn1cblxuLy8gV3JvbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnNcblxuZnVuY3Rpb24gd3JvbmdOdW1iZXJPZlBhcmFtZXRlcnMocnVsZU5hbWUsIGV4cGVjdGVkLCBhY3R1YWwsIHNvdXJjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnV3JvbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMgZm9yIHJ1bGUgJyArIHJ1bGVOYW1lICtcbiAgICAgICAgICAnIChleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnLCBnb3QgJyArIGFjdHVhbCArICcpJyxcbiAgICAgIHNvdXJjZSk7XG59XG5cbi8vIFdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcblxuZnVuY3Rpb24gd3JvbmdOdW1iZXJPZkFyZ3VtZW50cyhydWxlTmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCwgZXhwcikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgcnVsZSAnICsgcnVsZU5hbWUgK1xuICAgICAgICAgICcgKGV4cGVjdGVkICcgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsICsgJyknLFxuICAgICAgZXhwci5zb3VyY2UpO1xufVxuXG4vLyBEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzXG5cbmZ1bmN0aW9uIGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzKHJ1bGVOYW1lLCBkdXBsaWNhdGVzLCBzb3VyY2UpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ0R1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMgaW4gcnVsZSAnICsgcnVsZU5hbWUgKyAnOiAnICsgZHVwbGljYXRlcy5qb2luKCcsICcpLFxuICAgICAgc291cmNlKTtcbn1cblxuLy8gSW52YWxpZCBwYXJhbWV0ZXIgZXhwcmVzc2lvblxuXG5mdW5jdGlvbiBpbnZhbGlkUGFyYW1ldGVyKHJ1bGVOYW1lLCBleHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdJbnZhbGlkIHBhcmFtZXRlciB0byBydWxlICcgKyBydWxlTmFtZSArICc6ICcgKyBleHByICsgJyBoYXMgYXJpdHkgJyArIGV4cHIuZ2V0QXJpdHkoKSArXG4gICAgICAgICAnLCBidXQgcGFyYW1ldGVyIGV4cHJlc3Npb25zIG11c3QgaGF2ZSBhcml0eSAxJyxcbiAgICAgIGV4cHIuc291cmNlKTtcbn1cblxuLy8gQXBwbGljYXRpb24gb2Ygc3ludGFjdGljIHJ1bGUgZnJvbSBsZXhpY2FsIHJ1bGVcblxuZnVuY3Rpb24gYXBwbGljYXRpb25PZlN5bnRhY3RpY1J1bGVGcm9tTGV4aWNhbENvbnRleHQocnVsZU5hbWUsIGFwcGx5RXhwcikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnQ2Fubm90IGFwcGx5IHN5bnRhY3RpYyBydWxlICcgKyBydWxlTmFtZSArICcgZnJvbSBoZXJlIChpbnNpZGUgYSBsZXhpY2FsIGNvbnRleHQpJyxcbiAgICAgIGFwcGx5RXhwci5zb3VyY2UpO1xufVxuXG4vLyBJbmNvcnJlY3QgYXJndW1lbnQgdHlwZVxuXG5mdW5jdGlvbiBpbmNvcnJlY3RBcmd1bWVudFR5cGUoZXhwZWN0ZWRUeXBlLCBleHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcignSW5jb3JyZWN0IGFyZ3VtZW50IHR5cGU6IGV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGUsIGV4cHIuc291cmNlKTtcbn1cblxuLy8gTXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZSBzdXBlci1zcGxpY2Ugb3BlcmF0b3IgKGAuLi5gKSBpbiB0aGUgcnVsZSBib2R5LlxuXG5mdW5jdGlvbiBtdWx0aXBsZVN1cGVyU3BsaWNlcyhleHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcIicuLi4nIGNhbiBhcHBlYXIgYXQgbW9zdCBvbmNlIGluIGEgcnVsZSBib2R5XCIsIGV4cHIuc291cmNlKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gS2xlZW5lIG9wZXJhdG9ycyAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBrbGVlbmVFeHBySGFzTnVsbGFibGVPcGVyYW5kKGtsZWVuZUV4cHIsIGFwcGxpY2F0aW9uU3RhY2spIHtcbiAgY29uc3QgYWN0dWFscyA9IGFwcGxpY2F0aW9uU3RhY2subGVuZ3RoID4gMCA/XG4gICAgYXBwbGljYXRpb25TdGFja1thcHBsaWNhdGlvblN0YWNrLmxlbmd0aCAtIDFdLmFyZ3MgOlxuICAgIFtdO1xuICBjb25zdCBleHByID0ga2xlZW5lRXhwci5leHByLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscyk7XG4gIGxldCBtZXNzYWdlID1cbiAgICAnTnVsbGFibGUgZXhwcmVzc2lvbiAnICsgZXhwciArIFwiIGlzIG5vdCBhbGxvd2VkIGluc2lkZSAnXCIgK1xuICAgIGtsZWVuZUV4cHIub3BlcmF0b3IgKyBcIicgKHBvc3NpYmxlIGluZmluaXRlIGxvb3ApXCI7XG4gIGlmIChhcHBsaWNhdGlvblN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzdGFja1RyYWNlID0gYXBwbGljYXRpb25TdGFja1xuICAgICAgICAubWFwKGFwcCA9PiBuZXcgcGV4cHJzLkFwcGx5KGFwcC5ydWxlTmFtZSwgYXBwLmFyZ3MpKVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgbWVzc2FnZSArPSAnXFxuQXBwbGljYXRpb24gc3RhY2sgKG1vc3QgcmVjZW50IGFwcGxpY2F0aW9uIGxhc3QpOlxcbicgKyBzdGFja1RyYWNlO1xuICB9XG4gIHJldHVybiBjcmVhdGVFcnJvcihtZXNzYWdlLCBrbGVlbmVFeHByLmV4cHIuc291cmNlKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gYXJpdHkgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaW5jb25zaXN0ZW50QXJpdHkocnVsZU5hbWUsIGV4cGVjdGVkLCBhY3R1YWwsIGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ1J1bGUgJyArIHJ1bGVOYW1lICsgJyBpbnZvbHZlcyBhbiBhbHRlcm5hdGlvbiB3aGljaCBoYXMgaW5jb25zaXN0ZW50IGFyaXR5ICcgK1xuICAgICAgICAgICcoZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJywgZ290ICcgKyBhY3R1YWwgKyAnKScsXG4gICAgICBleHByLnNvdXJjZSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIHByb3BlcnRpZXMgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZHVwbGljYXRlUHJvcGVydHlOYW1lcyhkdXBsaWNhdGVzKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcignT2JqZWN0IHBhdHRlcm4gaGFzIGR1cGxpY2F0ZSBwcm9wZXJ0eSBuYW1lczogJyArIGR1cGxpY2F0ZXMuam9pbignLCAnKSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIGNvbnN0cnVjdG9ycyAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpbnZhbGlkQ29uc3RydWN0b3JDYWxsKGdyYW1tYXIsIGN0b3JOYW1lLCBjaGlsZHJlbikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnQXR0ZW1wdCB0byBpbnZva2UgY29uc3RydWN0b3IgJyArIGN0b3JOYW1lICsgJyB3aXRoIGludmFsaWQgb3IgdW5leHBlY3RlZCBhcmd1bWVudHMnKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gY29udmVuaWVuY2UgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gbXVsdGlwbGVFcnJvcnMoZXJyb3JzKSB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gZXJyb3JzLm1hcChlID0+IGUubWVzc2FnZSk7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgIFsnRXJyb3JzOiddLmNvbmNhdChtZXNzYWdlcykuam9pbignXFxuLSAnKSxcbiAgICAgIGVycm9yc1swXS5pbnRlcnZhbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIHNlbWFudGljIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIG1pc3NpbmdTZW1hbnRpY0FjdGlvbihjdG9yTmFtZSwgbmFtZSwgdHlwZSwgc3RhY2spIHtcbiAgbGV0IHN0YWNrVHJhY2UgPSBzdGFjay5zbGljZSgwLCAtMSkubWFwKGluZm8gPT4ge1xuICAgIGNvbnN0IGFucyA9ICcgICcgKyBpbmZvWzBdLm5hbWUgKyAnID4gJyArIGluZm9bMV07XG4gICAgcmV0dXJuIGluZm8ubGVuZ3RoID09PSAzXG4gICAgICAgID8gYW5zICsgXCIgZm9yICdcIiArIGluZm9bMl0gKyBcIidcIlxuICAgICAgICA6IGFucztcbiAgfSkuam9pbignXFxuJyk7XG4gIHN0YWNrVHJhY2UgKz0gJ1xcbiAgJyArIG5hbWUgKyAnID4gJyArIGN0b3JOYW1lO1xuXG4gIGNvbnN0IHdoZXJlID0gdHlwZSArIFwiICdcIiArIG5hbWUgKyBcIidcIjtcbiAgY29uc3QgbWVzc2FnZSA9IFwiTWlzc2luZyBzZW1hbnRpYyBhY3Rpb24gZm9yICdcIiArIGN0b3JOYW1lICsgXCInIGluIFwiICsgd2hlcmUgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ0FjdGlvbiBzdGFjayAobW9zdCByZWNlbnQgY2FsbCBsYXN0KTpcXG4nICsgc3RhY2tUcmFjZTtcblxuICBjb25zdCBlID0gY3JlYXRlRXJyb3IobWVzc2FnZSk7XG4gIGUubmFtZSA9ICdtaXNzaW5nU2VtYW50aWNBY3Rpb24nO1xuICByZXR1cm4gZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcHBsaWNhdGlvbk9mU3ludGFjdGljUnVsZUZyb21MZXhpY2FsQ29udGV4dCxcbiAgY2Fubm90RXh0ZW5kVW5kZWNsYXJlZFJ1bGUsXG4gIGNhbm5vdE92ZXJyaWRlVW5kZWNsYXJlZFJ1bGUsXG4gIGR1cGxpY2F0ZUdyYW1tYXJEZWNsYXJhdGlvbixcbiAgZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMsXG4gIGR1cGxpY2F0ZVByb3BlcnR5TmFtZXMsXG4gIGR1cGxpY2F0ZVJ1bGVEZWNsYXJhdGlvbixcbiAgaW5jb25zaXN0ZW50QXJpdHksXG4gIGluY29ycmVjdEFyZ3VtZW50VHlwZSxcbiAgaW50ZXJ2YWxTb3VyY2VzRG9udE1hdGNoLFxuICBpbnZhbGlkQ29uc3RydWN0b3JDYWxsLFxuICBpbnZhbGlkUGFyYW1ldGVyLFxuICBncmFtbWFyU3ludGF4RXJyb3IsXG4gIGtsZWVuZUV4cHJIYXNOdWxsYWJsZU9wZXJhbmQsXG4gIG1pc3NpbmdTZW1hbnRpY0FjdGlvbixcbiAgbXVsdGlwbGVTdXBlclNwbGljZXMsXG4gIHVuZGVjbGFyZWRHcmFtbWFyLFxuICB1bmRlY2xhcmVkUnVsZSxcbiAgd3JvbmdOdW1iZXJPZkFyZ3VtZW50cyxcbiAgd3JvbmdOdW1iZXJPZlBhcmFtZXRlcnMsXG5cbiAgdGhyb3dFcnJvcnMoZXJyb3JzKSB7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yc1swXTtcbiAgICB9XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBtdWx0aXBsZUVycm9ycyhlcnJvcnMpO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qIGdsb2JhbCBkb2N1bWVudCwgWE1MSHR0cFJlcXVlc3QgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgQnVpbGRlciA9IHJlcXVpcmUoJy4vQnVpbGRlcicpO1xuY29uc3QgR3JhbW1hciA9IHJlcXVpcmUoJy4vR3JhbW1hcicpO1xuY29uc3QgTmFtZXNwYWNlID0gcmVxdWlyZSgnLi9OYW1lc3BhY2UnKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IHZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuY29uc3QgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFRoZSBtZXRhZ3JhbW1hciwgaS5lLiB0aGUgZ3JhbW1hciBmb3IgT2htIGdyYW1tYXJzLiBJbml0aWFsaXplZCBhdCB0aGVcbi8vIGJvdHRvbSBvZiB0aGlzIGZpbGUgYmVjYXVzZSBsb2FkaW5nIHRoZSBncmFtbWFyIHJlcXVpcmVzIE9obSBpdHNlbGYuXG5sZXQgb2htR3JhbW1hcjtcblxuLy8gQW4gb2JqZWN0IHdoaWNoIG1ha2VzIGl0IHBvc3NpYmxlIHRvIHN0dWIgb3V0IHRoZSBkb2N1bWVudCBBUEkgZm9yIHRlc3RpbmcuXG5sZXQgZG9jdW1lbnRJbnRlcmZhY2UgPSB7XG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbCk7IH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbCk7IH1cbn07XG5cbmNvbnN0IHN1cGVyU3BsaWNlUGxhY2Vob2xkZXIgPSBPYmplY3QuY3JlYXRlKHBleHBycy5QRXhwci5wcm90b3R5cGUpO1xuXG4vLyBDaGVjayBpZiBgb2JqYCBpcyBhIERPTSBlbGVtZW50LlxuZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICByZXR1cm4gb2JqID09PSB2b2lkIDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdm9pZFxufVxuXG5jb25zdCBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gIHJldHVybiB0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xufVxuXG4vLyBUT0RPOiBqdXN0IHVzZSB0aGUgalF1ZXJ5IHRoaW5nXG5mdW5jdGlvbiBsb2FkKHVybCkge1xuICBjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICB0cnkge1xuICAgIHJlcS5zZW5kKCk7XG4gICAgaWYgKHJlcS5zdGF0dXMgPT09IDAgfHwgcmVxLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICByZXR1cm4gcmVxLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvYWQgdXJsICcgKyB1cmwpO1xufVxuXG4vLyBSZXR1cm5zIGEgR3JhbW1hciBpbnN0YW5jZSAoaS5lLiwgYW4gb2JqZWN0IHdpdGggYSBgbWF0Y2hgIG1ldGhvZCkgZm9yXG4vLyBgdHJlZWAsIHdoaWNoIGlzIHRoZSBjb25jcmV0ZSBzeW50YXggdHJlZSBvZiBhIHVzZXItd3JpdHRlbiBncmFtbWFyLlxuLy8gVGhlIGdyYW1tYXIgd2lsbCBiZSBhc3NpZ25lZCBpbnRvIGBuYW1lc3BhY2VgIHVuZGVyIHRoZSBuYW1lIG9mIHRoZSBncmFtbWFyXG4vLyBhcyBzcGVjaWZpZWQgaW4gdGhlIHNvdXJjZS5cbmZ1bmN0aW9uIGJ1aWxkR3JhbW1hcihtYXRjaCwgbmFtZXNwYWNlLCBvcHRPaG1HcmFtbWFyRm9yVGVzdGluZykge1xuICBjb25zdCBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgbGV0IGRlY2w7XG4gIGxldCBjdXJyZW50UnVsZU5hbWU7XG4gIGxldCBjdXJyZW50UnVsZUZvcm1hbHM7XG4gIGxldCBvdmVycmlkaW5nID0gZmFsc2U7XG4gIGNvbnN0IG1ldGFHcmFtbWFyID0gb3B0T2htR3JhbW1hckZvclRlc3RpbmcgfHwgb2htR3JhbW1hcjtcblxuICAvLyBBIHZpc2l0b3IgdGhhdCBwcm9kdWNlcyBhIEdyYW1tYXIgaW5zdGFuY2UgZnJvbSB0aGUgQ1NULlxuICBjb25zdCBoZWxwZXJzID0gbWV0YUdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCkuYWRkT3BlcmF0aW9uKCd2aXNpdCcsIHtcbiAgICBHcmFtbWFyKG4sIHMsIG9wZW4sIHJzLCBjbG9zZSkge1xuICAgICAgY29uc3QgZ3JhbW1hck5hbWUgPSBuLnZpc2l0KCk7XG4gICAgICBkZWNsID0gYnVpbGRlci5uZXdHcmFtbWFyKGdyYW1tYXJOYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgcy52aXNpdCgpO1xuICAgICAgcnMudmlzaXQoKTtcbiAgICAgIGNvbnN0IGcgPSBkZWNsLmJ1aWxkKCk7XG4gICAgICBnLnNvdXJjZSA9IHRoaXMuc291cmNlLnRyaW1tZWQoKTtcbiAgICAgIGlmIChncmFtbWFyTmFtZSBpbiBuYW1lc3BhY2UpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLmR1cGxpY2F0ZUdyYW1tYXJEZWNsYXJhdGlvbihnLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgICAgbmFtZXNwYWNlW2dyYW1tYXJOYW1lXSA9IGc7XG4gICAgICByZXR1cm4gZztcbiAgICB9LFxuXG4gICAgU3VwZXJHcmFtbWFyKF8sIG4pIHtcbiAgICAgIGNvbnN0IHN1cGVyR3JhbW1hck5hbWUgPSBuLnZpc2l0KCk7XG4gICAgICBpZiAoc3VwZXJHcmFtbWFyTmFtZSA9PT0gJ251bGwnKSB7XG4gICAgICAgIGRlY2wud2l0aFN1cGVyR3JhbW1hcihudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbmFtZXNwYWNlIHx8ICEoc3VwZXJHcmFtbWFyTmFtZSBpbiBuYW1lc3BhY2UpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JzLnVuZGVjbGFyZWRHcmFtbWFyKHN1cGVyR3JhbW1hck5hbWUsIG5hbWVzcGFjZSwgbi5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGRlY2wud2l0aFN1cGVyR3JhbW1hcihuYW1lc3BhY2Vbc3VwZXJHcmFtbWFyTmFtZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBSdWxlX2RlZmluZShuLCBmcywgZCwgXywgYikge1xuICAgICAgY3VycmVudFJ1bGVOYW1lID0gbi52aXNpdCgpO1xuICAgICAgY3VycmVudFJ1bGVGb3JtYWxzID0gZnMudmlzaXQoKVswXSB8fCBbXTtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGRlZmF1bHQgc3RhcnQgcnVsZSB5ZXQsIHNldCBpdCBub3cuIFRoaXMgbXVzdCBiZSBkb25lIGJlZm9yZSB2aXNpdGluZ1xuICAgICAgLy8gdGhlIGJvZHksIGJlY2F1c2UgaXQgbWlnaHQgY29udGFpbiBhbiBpbmxpbmUgcnVsZSBkZWZpbml0aW9uLlxuICAgICAgaWYgKCFkZWNsLmRlZmF1bHRTdGFydFJ1bGUgJiYgZGVjbC5lbnN1cmVTdXBlckdyYW1tYXIoKSAhPT0gR3JhbW1hci5Qcm90b0J1aWx0SW5SdWxlcykge1xuICAgICAgICBkZWNsLndpdGhEZWZhdWx0U3RhcnRSdWxlKGN1cnJlbnRSdWxlTmFtZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0gYi52aXNpdCgpO1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBkLnZpc2l0KClbMF07XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICByZXR1cm4gZGVjbC5kZWZpbmUoY3VycmVudFJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIGRlc2NyaXB0aW9uLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgUnVsZV9vdmVycmlkZShuLCBmcywgXywgYikge1xuICAgICAgY3VycmVudFJ1bGVOYW1lID0gbi52aXNpdCgpO1xuICAgICAgY3VycmVudFJ1bGVGb3JtYWxzID0gZnMudmlzaXQoKVswXSB8fCBbXTtcblxuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UudHJpbW1lZCgpO1xuICAgICAgZGVjbC5lbnN1cmVTdXBlckdyYW1tYXJSdWxlRm9yT3ZlcnJpZGluZyhjdXJyZW50UnVsZU5hbWUsIHNvdXJjZSk7XG5cbiAgICAgIG92ZXJyaWRpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgYm9keSA9IGIudmlzaXQoKTtcbiAgICAgIG92ZXJyaWRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBkZWNsLm92ZXJyaWRlKGN1cnJlbnRSdWxlTmFtZSwgY3VycmVudFJ1bGVGb3JtYWxzLCBib2R5LCBudWxsLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgUnVsZV9leHRlbmQobiwgZnMsIF8sIGIpIHtcbiAgICAgIGN1cnJlbnRSdWxlTmFtZSA9IG4udmlzaXQoKTtcbiAgICAgIGN1cnJlbnRSdWxlRm9ybWFscyA9IGZzLnZpc2l0KClbMF0gfHwgW107XG4gICAgICBjb25zdCBib2R5ID0gYi52aXNpdCgpO1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UudHJpbW1lZCgpO1xuICAgICAgcmV0dXJuIGRlY2wuZXh0ZW5kKGN1cnJlbnRSdWxlTmFtZSwgY3VycmVudFJ1bGVGb3JtYWxzLCBib2R5LCBudWxsLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgUnVsZUJvZHkoXywgdGVybXMpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0ZXJtcy52aXNpdCgpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuYWx0LmFwcGx5KGJ1aWxkZXIsIGFyZ3MpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgT3ZlcnJpZGVSdWxlQm9keShfLCB0ZXJtcykge1xuICAgICAgY29uc3QgYXJncyA9IHRlcm1zLnZpc2l0KCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzdXBlci1zcGxpY2Ugb3BlcmF0b3IgKGAuLi5gKSBhcHBlYXJzIGluIHRoZSB0ZXJtcy5cbiAgICAgIGNvbnN0IGV4cGFuc2lvblBvcyA9IGFyZ3MuaW5kZXhPZihzdXBlclNwbGljZVBsYWNlaG9sZGVyKTtcbiAgICAgIGlmIChleHBhbnNpb25Qb3MgPj0gMCkge1xuICAgICAgICBjb25zdCBiZWZvcmVUZXJtcyA9IGFyZ3Muc2xpY2UoMCwgZXhwYW5zaW9uUG9zKTtcbiAgICAgICAgY29uc3QgYWZ0ZXJUZXJtcyA9IGFyZ3Muc2xpY2UoZXhwYW5zaW9uUG9zICsgMSk7XG5cbiAgICAgICAgLy8gRW5zdXJlIGl0IGFwcGVhcnMgbm8gbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIGFmdGVyVGVybXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAodCA9PT0gc3VwZXJTcGxpY2VQbGFjZWhvbGRlcikgdGhyb3cgZXJyb3JzLm11bHRpcGxlU3VwZXJTcGxpY2VzKHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IHBleHBycy5TcGxpY2UoXG4gICAgICAgICAgICBkZWNsLnN1cGVyR3JhbW1hciwgY3VycmVudFJ1bGVOYW1lLCBiZWZvcmVUZXJtcywgYWZ0ZXJUZXJtcykud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVpbGRlci5hbHQuYXBwbHkoYnVpbGRlciwgYXJncykud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBGb3JtYWxzKG9wb2ludHksIGZzLCBjcG9pbnR5KSB7XG4gICAgICByZXR1cm4gZnMudmlzaXQoKTtcbiAgICB9LFxuXG4gICAgUGFyYW1zKG9wb2ludHksIHBzLCBjcG9pbnR5KSB7XG4gICAgICByZXR1cm4gcHMudmlzaXQoKTtcbiAgICB9LFxuXG4gICAgQWx0KHNlcXMpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBzZXFzLnZpc2l0KCk7XG4gICAgICByZXR1cm4gYnVpbGRlci5hbHQuYXBwbHkoYnVpbGRlciwgYXJncykud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcblxuICAgIFRvcExldmVsVGVybV9pbmxpbmUoYiwgbikge1xuICAgICAgY29uc3QgaW5saW5lUnVsZU5hbWUgPSBjdXJyZW50UnVsZU5hbWUgKyAnXycgKyBuLnZpc2l0KCk7XG4gICAgICBjb25zdCBib2R5ID0gYi52aXNpdCgpO1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UudHJpbW1lZCgpO1xuICAgICAgY29uc3QgaXNOZXdSdWxlRGVjbGFyYXRpb24gPVxuICAgICAgICAgICEoZGVjbC5zdXBlckdyYW1tYXIgJiYgZGVjbC5zdXBlckdyYW1tYXIucnVsZXNbaW5saW5lUnVsZU5hbWVdKTtcbiAgICAgIGlmIChvdmVycmlkaW5nICYmICFpc05ld1J1bGVEZWNsYXJhdGlvbikge1xuICAgICAgICBkZWNsLm92ZXJyaWRlKGlubGluZVJ1bGVOYW1lLCBjdXJyZW50UnVsZUZvcm1hbHMsIGJvZHksIG51bGwsIHNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsLmRlZmluZShpbmxpbmVSdWxlTmFtZSwgY3VycmVudFJ1bGVGb3JtYWxzLCBib2R5LCBudWxsLCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyYW1zID0gY3VycmVudFJ1bGVGb3JtYWxzLm1hcChmb3JtYWwgPT4gYnVpbGRlci5hcHAoZm9ybWFsKSk7XG4gICAgICByZXR1cm4gYnVpbGRlci5hcHAoaW5saW5lUnVsZU5hbWUsIHBhcmFtcykud2l0aFNvdXJjZShib2R5LnNvdXJjZSk7XG4gICAgfSxcbiAgICBPdmVycmlkZVRvcExldmVsVGVybV9zdXBlclNwbGljZShfKSB7XG4gICAgICByZXR1cm4gc3VwZXJTcGxpY2VQbGFjZWhvbGRlcjtcbiAgICB9LFxuXG4gICAgU2VxKGV4cHIpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLnNlcS5hcHBseShidWlsZGVyLCBleHByLnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG5cbiAgICBJdGVyX3N0YXIoeCwgXykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuc3Rhcih4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgSXRlcl9wbHVzKHgsIF8pIHtcbiAgICAgIHJldHVybiBidWlsZGVyLnBsdXMoeC52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIEl0ZXJfb3B0KHgsIF8pIHtcbiAgICAgIHJldHVybiBidWlsZGVyLm9wdCh4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG5cbiAgICBQcmVkX25vdChfLCB4KSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5ub3QoeC52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIFByZWRfbG9va2FoZWFkKF8sIHgpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLmxvb2thaGVhZCh4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG5cbiAgICBMZXhfbGV4KF8sIHgpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLmxleCh4LnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG5cbiAgICBCYXNlX2FwcGxpY2F0aW9uKHJ1bGUsIHBzKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5hcHAocnVsZS52aXNpdCgpLCBwcy52aXNpdCgpWzBdIHx8IFtdKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIEJhc2VfcmFuZ2UoZnJvbSwgXywgdG8pIHtcbiAgICAgIHJldHVybiBidWlsZGVyLnJhbmdlKGZyb20udmlzaXQoKSwgdG8udmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBCYXNlX3Rlcm1pbmFsKGV4cHIpIHtcbiAgICAgIHJldHVybiBidWlsZGVyLnRlcm1pbmFsKGV4cHIudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBCYXNlX3BhcmVuKG9wZW4sIHgsIGNsb3NlKSB7XG4gICAgICByZXR1cm4geC52aXNpdCgpO1xuICAgIH0sXG5cbiAgICBydWxlRGVzY3Iob3BlbiwgdCwgY2xvc2UpIHtcbiAgICAgIHJldHVybiB0LnZpc2l0KCk7XG4gICAgfSxcbiAgICBydWxlRGVzY3JUZXh0KF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVN0cmluZy50cmltKCk7XG4gICAgfSxcblxuICAgIGNhc2VOYW1lKF8sIHNwYWNlMSwgbiwgc3BhY2UyLCBlbmQpIHtcbiAgICAgIHJldHVybiBuLnZpc2l0KCk7XG4gICAgfSxcblxuICAgIG5hbWUoZmlyc3QsIHJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVN0cmluZztcbiAgICB9LFxuICAgIG5hbWVGaXJzdChleHByKSB7fSxcbiAgICBuYW1lUmVzdChleHByKSB7fSxcblxuICAgIHRlcm1pbmFsKG9wZW4sIGNzLCBjbG9zZSkge1xuICAgICAgcmV0dXJuIGNzLnZpc2l0KCkuam9pbignJyk7XG4gICAgfSxcblxuICAgIG9uZUNoYXJUZXJtaW5hbChvcGVuLCBjLCBjbG9zZSkge1xuICAgICAgcmV0dXJuIGMudmlzaXQoKTtcbiAgICB9LFxuXG4gICAgdGVybWluYWxDaGFyKF8pIHtcbiAgICAgIHJldHVybiBjb21tb24udW5lc2NhcGVDaGFyKHRoaXMuc291cmNlU3RyaW5nKTtcbiAgICB9LFxuXG4gICAgZXNjYXBlQ2hhcihfKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VTdHJpbmc7XG4gICAgfSxcblxuICAgIE5vbmVtcHR5TGlzdE9mKHgsIF8sIHhzKSB7XG4gICAgICByZXR1cm4gW3gudmlzaXQoKV0uY29uY2F0KHhzLnZpc2l0KCkpO1xuICAgIH0sXG4gICAgRW1wdHlMaXN0T2YoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIF90ZXJtaW5hbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByaW1pdGl2ZVZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoZWxwZXJzKG1hdGNoKS52aXNpdCgpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlQW5kTG9hZChzb3VyY2UsIG5hbWVzcGFjZSkge1xuICBjb25zdCBtID0gb2htR3JhbW1hci5tYXRjaChzb3VyY2UsICdHcmFtbWFycycpO1xuICBpZiAobS5mYWlsZWQoKSkge1xuICAgIHRocm93IGVycm9ycy5ncmFtbWFyU3ludGF4RXJyb3IobSk7XG4gIH1cbiAgcmV0dXJuIGJ1aWxkR3JhbW1hcihtLCBuYW1lc3BhY2UpO1xufVxuXG4vLyBSZXR1cm4gdGhlIGNvbnRlbnRzIG9mIGEgc2NyaXB0IGVsZW1lbnQsIGZldGNoaW5nIGl0IHZpYSBYSFIgaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gZ2V0U2NyaXB0RWxlbWVudENvbnRlbnRzKGVsKSB7XG4gIGlmICghaXNFbGVtZW50KGVsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgRE9NIE5vZGUsIGdvdCAnICsgY29tbW9uLnVuZXhwZWN0ZWRPYmpUb1N0cmluZyhlbCkpO1xuICB9XG4gIGlmIChlbC50eXBlICE9PSAndGV4dC9vaG0tanMnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHNjcmlwdCB0YWcgd2l0aCB0eXBlPVwidGV4dC9vaG0tanNcIiwgZ290ICcgKyBlbCk7XG4gIH1cbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnc3JjJykgPyBsb2FkKGVsLmdldEF0dHJpYnV0ZSgnc3JjJykpIDogZWwuaW5uZXJIVE1MO1xufVxuXG5mdW5jdGlvbiBncmFtbWFyKHNvdXJjZSwgb3B0TmFtZXNwYWNlKSB7XG4gIGNvbnN0IG5zID0gZ3JhbW1hcnMoc291cmNlLCBvcHROYW1lc3BhY2UpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBzb3VyY2UgY29udGFpbmVkIG5vIG1vcmUgdGhhbiBvbmUgZ3JhbW1hciBkZWZpbml0aW9uLlxuICBjb25zdCBncmFtbWFyTmFtZXMgPSBPYmplY3Qua2V5cyhucyk7XG4gIGlmIChncmFtbWFyTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdyYW1tYXIgZGVmaW5pdGlvbicpO1xuICB9IGVsc2UgaWYgKGdyYW1tYXJOYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3Qgc2Vjb25kR3JhbW1hciA9IG5zW2dyYW1tYXJOYW1lc1sxXV07XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZWNvbmRHcmFtbWFyLnNvdXJjZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHV0aWwuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UoaW50ZXJ2YWwuc291cmNlU3RyaW5nLCBpbnRlcnZhbC5zdGFydElkeCkgK1xuICAgICAgICAnRm91bmQgbW9yZSB0aGFuIG9uZSBncmFtbWFyIGRlZmluaXRpb24gLS0gdXNlIG9obS5ncmFtbWFycygpIGluc3RlYWQuJyk7XG4gIH1cbiAgcmV0dXJuIG5zW2dyYW1tYXJOYW1lc1swXV07IC8vIFJldHVybiB0aGUgb25lIGFuZCBvbmx5IGdyYW1tYXIuXG59XG5cbmZ1bmN0aW9uIGdyYW1tYXJzKHNvdXJjZSwgb3B0TmFtZXNwYWNlKSB7XG4gIGNvbnN0IG5zID0gTmFtZXNwYWNlLmV4dGVuZChOYW1lc3BhY2UuYXNOYW1lc3BhY2Uob3B0TmFtZXNwYWNlKSk7XG4gIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIEZvciBjb252ZW5pZW5jZSwgZGV0ZWN0IE5vZGUuanMgQnVmZmVyIG9iamVjdHMgYW5kIGF1dG9tYXRpY2FsbHkgY2FsbCB0b1N0cmluZygpLlxuICAgIGlmIChpc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2UudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnRXhwZWN0ZWQgc3RyaW5nIGFzIGZpcnN0IGFyZ3VtZW50LCBnb3QgJyArIGNvbW1vbi51bmV4cGVjdGVkT2JqVG9TdHJpbmcoc291cmNlKSk7XG4gICAgfVxuICB9XG4gIGNvbXBpbGVBbmRMb2FkKHNvdXJjZSwgbnMpO1xuICByZXR1cm4gbnM7XG59XG5cbmZ1bmN0aW9uIGdyYW1tYXJGcm9tU2NyaXB0RWxlbWVudChvcHROb2RlKSB7XG4gIGxldCBub2RlID0gb3B0Tm9kZTtcbiAgaWYgKGlzVW5kZWZpbmVkKG5vZGUpKSB7XG4gICAgY29uc3Qgbm9kZUxpc3QgPSBkb2N1bWVudEludGVyZmFjZS5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbdHlwZT1cInRleHQvb2htLWpzXCJdJyk7XG4gICAgaWYgKG5vZGVMaXN0Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCBleGFjdGx5IG9uZSBzY3JpcHQgdGFnIHdpdGggdHlwZT1cInRleHQvb2htLWpzXCIsIGZvdW5kICcgKyBub2RlTGlzdC5sZW5ndGgpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZUxpc3RbMF07XG4gIH1cbiAgcmV0dXJuIGdyYW1tYXIoZ2V0U2NyaXB0RWxlbWVudENvbnRlbnRzKG5vZGUpKTtcbn1cblxuZnVuY3Rpb24gZ3JhbW1hcnNGcm9tU2NyaXB0RWxlbWVudHMob3B0Tm9kZU9yTm9kZUxpc3QpIHtcbiAgLy8gU2ltcGxlIGNhc2U6IHRoZSBhcmd1bWVudCBpcyBhIERPTSBub2RlLlxuICBpZiAoaXNFbGVtZW50KG9wdE5vZGVPck5vZGVMaXN0KSkge1xuICAgIHJldHVybiBncmFtbWFycyhvcHROb2RlT3JOb2RlTGlzdCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBpdCBtdXN0IGJlIGVpdGhlciB1bmRlZmluZWQgb3IgYSBOb2RlTGlzdC5cbiAgbGV0IG5vZGVMaXN0ID0gb3B0Tm9kZU9yTm9kZUxpc3Q7XG4gIGlmIChpc1VuZGVmaW5lZChub2RlTGlzdCkpIHtcbiAgICAvLyBGaW5kIGFsbCBzY3JpcHQgZWxlbWVudHMgd2l0aCB0eXBlPVwidGV4dC9vaG0tanNcIi5cbiAgICBub2RlTGlzdCA9IGRvY3VtZW50SW50ZXJmYWNlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFt0eXBlPVwidGV4dC9vaG0tanNcIl0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZUxpc3QgPT09ICdzdHJpbmcnIHx8ICghaXNFbGVtZW50KG5vZGVMaXN0KSAmJiAhaXNBcnJheUxpa2Uobm9kZUxpc3QpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgTm9kZSwgTm9kZUxpc3QsIG9yIEFycmF5LCBidXQgZ290ICcgKyBub2RlTGlzdCk7XG4gIH1cbiAgY29uc3QgbnMgPSBOYW1lc3BhY2UuY3JlYXRlTmFtZXNwYWNlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBDb3B5IHRoZSBuZXcgZ3JhbW1hcnMgaW50byBgbnNgIHRvIGtlZXAgdGhlIG5hbWVzcGFjZSBmbGF0LlxuICAgIGNvbW1vbi5leHRlbmQobnMsIGdyYW1tYXJzKGdldFNjcmlwdEVsZW1lbnRDb250ZW50cyhub2RlTGlzdFtpXSksIG5zKSk7XG4gIH1cbiAgcmV0dXJuIG5zO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVjaXBlKHJlY2lwZSkge1xuICBpZiAodHlwZW9mIHJlY2lwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiByZWNpcGUuY2FsbChuZXcgQnVpbGRlcigpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHJlY2lwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHN0cmluZ2lmaWVkIEpTT04gcmVjaXBlXG4gICAgICByZWNpcGUgPSBKU09OLnBhcnNlKHJlY2lwZSk7XG4gICAgfVxuICAgIHJldHVybiAobmV3IEJ1aWxkZXIoKSkuZnJvbVJlY2lwZShyZWNpcGUpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBTdHVmZiB0aGF0IHVzZXJzIHNob3VsZCBrbm93IGFib3V0XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTmFtZXNwYWNlOiBOYW1lc3BhY2UuY3JlYXRlTmFtZXNwYWNlLFxuICBncmFtbWFyLFxuICBncmFtbWFycyxcbiAgZ3JhbW1hckZyb21TY3JpcHRFbGVtZW50LFxuICBncmFtbWFyc0Zyb21TY3JpcHRFbGVtZW50cyxcbiAgbWFrZVJlY2lwZSxcbiAgb2htR3JhbW1hcjogbnVsbCwgLy8gSW5pdGlhbGl6ZWQgYmVsb3csIGFmdGVyIEdyYW1tYXIuQnVpbHRJblJ1bGVzLlxuICBwZXhwcnMsXG4gIHV0aWwsXG4gIGV4dHJhczogcmVxdWlyZSgnLi4vZXh0cmFzJyksXG4gIHZlcnNpb25cbn07XG5cbi8vIFN0dWZmIGZvciB0ZXN0aW5nLCBldGMuXG5tb2R1bGUuZXhwb3J0cy5fYnVpbGRHcmFtbWFyID0gYnVpbGRHcmFtbWFyO1xubW9kdWxlLmV4cG9ydHMuX3NldERvY3VtZW50SW50ZXJmYWNlRm9yVGVzdGluZyA9IGZ1bmN0aW9uKGRvYykgeyBkb2N1bWVudEludGVyZmFjZSA9IGRvYzsgfTtcblxuLy8gTGF0ZSBpbml0aWFsaXphdGlvbiBmb3Igc3R1ZmYgdGhhdCBpcyBib290c3RyYXBwZWQuXG5cbkdyYW1tYXIuQnVpbHRJblJ1bGVzID0gcmVxdWlyZSgnLi4vZGlzdC9idWlsdC1pbi1ydWxlcycpO1xudXRpbC5hbm5vdW5jZUJ1aWx0SW5SdWxlcyhHcmFtbWFyLkJ1aWx0SW5SdWxlcyk7XG5cbm1vZHVsZS5leHBvcnRzLm9obUdyYW1tYXIgPSBvaG1HcmFtbWFyID0gcmVxdWlyZSgnLi4vZGlzdC9vaG0tZ3JhbW1hcicpO1xuR3JhbW1hci5pbml0QXBwbGljYXRpb25QYXJzZXIob2htR3JhbW1hciwgYnVpbGRHcmFtbWFyKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNsYXNzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihncmFtbWFyLCBjdG9yTmFtZSwgbWF0Y2hMZW5ndGgpIHtcbiAgICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuICAgIHRoaXMuY3Rvck5hbWUgPSBjdG9yTmFtZTtcbiAgICB0aGlzLm1hdGNoTGVuZ3RoID0gbWF0Y2hMZW5ndGg7XG4gIH1cblxuICBudW1DaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDogMDtcbiAgfVxuXG4gIGNoaWxkQXQoaWR4KSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2lkeF07XG4gICAgfVxuICB9XG5cbiAgaW5kZXhPZkNoaWxkKGFyZykge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2YoYXJnKTtcbiAgfVxuXG4gIGhhc0NoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLm51bUNoaWxkcmVuKCkgPiAxO1xuICB9XG5cbiAgaGFzTm9DaGlsZHJlbigpIHtcbiAgICByZXR1cm4gIXRoaXMuaGFzQ2hpbGRyZW4oKTtcbiAgfVxuXG4gIG9ubHlDaGlsZCgpIHtcbiAgICBpZiAodGhpcy5udW1DaGlsZHJlbigpICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBnZXQgb25seSBjaGlsZCBvZiBhIG5vZGUgb2YgdHlwZSAnICsgdGhpcy5jdG9yTmFtZSArXG4gICAgICAgICAgJyAoaXQgaGFzICcgKyB0aGlzLm51bUNoaWxkcmVuKCkgKyAnIGNoaWxkcmVuKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5maXJzdENoaWxkKCk7XG4gICAgfVxuICB9XG5cbiAgZmlyc3RDaGlsZCgpIHtcbiAgICBpZiAodGhpcy5oYXNOb0NoaWxkcmVuKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IGdldCBmaXJzdCBjaGlsZCBvZiBhICcgKyB0aGlzLmN0b3JOYW1lICsgJyBub2RlLCB3aGljaCBoYXMgbm8gY2hpbGRyZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKTtcbiAgICB9XG4gIH1cblxuICBsYXN0Q2hpbGQoKSB7XG4gICAgaWYgKHRoaXMuaGFzTm9DaGlsZHJlbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBnZXQgbGFzdCBjaGlsZCBvZiBhICcgKyB0aGlzLmN0b3JOYW1lICsgJyBub2RlLCB3aGljaCBoYXMgbm8gY2hpbGRyZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRBdCh0aGlzLm51bUNoaWxkcmVuKCkgLSAxKTtcbiAgICB9XG4gIH1cblxuICBjaGlsZEJlZm9yZShjaGlsZCkge1xuICAgIGNvbnN0IGNoaWxkSWR4ID0gdGhpcy5pbmRleE9mQ2hpbGQoY2hpbGQpO1xuICAgIGlmIChjaGlsZElkeCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZS5jaGlsZEJlZm9yZSgpIGNhbGxlZCB3LyBhbiBhcmd1bWVudCB0aGF0IGlzIG5vdCBhIGNoaWxkJyk7XG4gICAgfSBlbHNlIGlmIChjaGlsZElkeCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2V0IGNoaWxkIGJlZm9yZSBmaXJzdCBjaGlsZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZEF0KGNoaWxkSWR4IC0gMSk7XG4gICAgfVxuICB9XG5cbiAgY2hpbGRBZnRlcihjaGlsZCkge1xuICAgIGNvbnN0IGNoaWxkSWR4ID0gdGhpcy5pbmRleE9mQ2hpbGQoY2hpbGQpO1xuICAgIGlmIChjaGlsZElkeCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZS5jaGlsZEFmdGVyKCkgY2FsbGVkIHcvIGFuIGFyZ3VtZW50IHRoYXQgaXMgbm90IGEgY2hpbGQnKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkSWR4ID09PSB0aGlzLm51bUNoaWxkcmVuKCkgLSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgY2hpbGQgYWZ0ZXIgbGFzdCBjaGlsZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZEF0KGNoaWxkSWR4ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgaXNUZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc05vbnRlcm1pbmFsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzSXRlcmF0aW9uKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7W3RoaXMuY3Rvck5hbWVdOiB0aGlzLmNoaWxkcmVufTtcbiAgfVxufVxuXG4vLyBUZXJtaW5hbHNcblxuY2xhc3MgVGVybWluYWxOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYW1tYXIsIHZhbHVlKSB7XG4gICAgY29uc3QgbWF0Y2hMZW5ndGggPSB2YWx1ZSA/IHZhbHVlLmxlbmd0aCA6IDA7XG4gICAgc3VwZXIoZ3JhbW1hciwgJ190ZXJtaW5hbCcsIG1hdGNoTGVuZ3RoKTtcbiAgICB0aGlzLnByaW1pdGl2ZVZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBpc1Rlcm1pbmFsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7W3RoaXMuY3Rvck5hbWVdOiB0aGlzLnByaW1pdGl2ZVZhbHVlfTtcbiAgfVxufVxuXG4vLyBOb250ZXJtaW5hbHNcblxuY2xhc3MgTm9udGVybWluYWxOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYW1tYXIsIHJ1bGVOYW1lLCBjaGlsZHJlbiwgY2hpbGRPZmZzZXRzLCBtYXRjaExlbmd0aCkge1xuICAgIHN1cGVyKGdyYW1tYXIsIHJ1bGVOYW1lLCBtYXRjaExlbmd0aCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2hpbGRPZmZzZXRzID0gY2hpbGRPZmZzZXRzO1xuICB9XG5cbiAgaXNOb250ZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzTGV4aWNhbCgpIHtcbiAgICByZXR1cm4gY29tbW9uLmlzTGV4aWNhbCh0aGlzLmN0b3JOYW1lKTtcbiAgfVxuXG4gIGlzU3ludGFjdGljKCkge1xuICAgIHJldHVybiBjb21tb24uaXNTeW50YWN0aWModGhpcy5jdG9yTmFtZSk7XG4gIH1cbn1cblxuLy8gSXRlcmF0aW9uc1xuXG5jbGFzcyBJdGVyYXRpb25Ob2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYW1tYXIsIGNoaWxkcmVuLCBjaGlsZE9mZnNldHMsIG1hdGNoTGVuZ3RoLCBpc09wdGlvbmFsKSB7XG4gICAgc3VwZXIoZ3JhbW1hciwgJ19pdGVyJywgbWF0Y2hMZW5ndGgpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmNoaWxkT2Zmc2V0cyA9IGNoaWxkT2Zmc2V0cztcbiAgICB0aGlzLm9wdGlvbmFsID0gaXNPcHRpb25hbDtcbiAgfVxuXG4gIGlzSXRlcmF0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbDtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE5vZGUsXG4gIFRlcm1pbmFsTm9kZSxcbiAgTm9udGVybWluYWxOb2RlLFxuICBJdGVyYXRpb25Ob2RlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBSZXR1cm4gdHJ1ZSBpZiB3ZSBzaG91bGQgc2tpcCBzcGFjZXMgcHJlY2VkaW5nIHRoaXMgZXhwcmVzc2lvbiBpbiBhIHN5bnRhY3RpYyBjb250ZXh0LlxuKi9cbnBleHBycy5QRXhwci5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9IGNvbW1vbi5hYnN0cmFjdChcbiAgICAnYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSdcbik7XG5cbi8qXG4gIEdlbmVyYWxseSwgdGhlc2UgYXJlIGFsbCBmaXJzdC1vcmRlciBleHByZXNzaW9ucyBhbmQgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBBcHBseSlcbiAgZGlyZWN0bHkgcmVhZCBmcm9tIHRoZSBpbnB1dCBzdHJlYW0uXG4qL1xucGV4cHJzLmFueS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5lbmQuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKlxuICBIaWdoZXItb3JkZXIgZXhwcmVzc2lvbnMgdGhhdCBkb24ndCBkaXJlY3RseSBjb25zdW1lIGlucHV0LlxuKi9cbnBleHBycy5BbHQucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5Ob3QucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5TZXEucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IEJ1aWx0SW5SdWxlcztcblxudXRpbC5hd2FpdEJ1aWx0SW5SdWxlcyhnID0+IHsgQnVpbHRJblJ1bGVzID0gZzsgfSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgbGV4aWZ5Q291bnQ7XG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBmdW5jdGlvbihydWxlTmFtZSwgZ3JhbW1hcikge1xuICBsZXhpZnlDb3VudCA9IDA7XG4gIHRoaXMuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbn07XG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gY29tbW9uLmFic3RyYWN0KFxuICAgICdfYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQnXG4pO1xuXG5wZXhwcnMuYW55Ll9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuZW5kLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIC8vIG5vLW9wXG59O1xuXG5wZXhwcnMuTGV4LnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBmdW5jdGlvbihydWxlTmFtZSwgZ3JhbW1hcikge1xuICBsZXhpZnlDb3VudCsrO1xuICB0aGlzLmV4cHIuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbiAgbGV4aWZ5Q291bnQtLTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMudGVybXMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXMudGVybXNbaWR4XS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xuICB9XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBmdW5jdGlvbihydWxlTmFtZSwgZ3JhbW1hcikge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXMuZmFjdG9yc1tpZHhdLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG4gIH1cbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGZ1bmN0aW9uKHJ1bGVOYW1lLCBncmFtbWFyKSB7XG4gIHRoaXMuZXhwci5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBmdW5jdGlvbihydWxlTmFtZSwgZ3JhbW1hcikge1xuICBjb25zdCBydWxlSW5mbyA9IGdyYW1tYXIucnVsZXNbdGhpcy5ydWxlTmFtZV07XG5cbiAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHJ1bGUgZXhpc3RzLi4uXG4gIGlmICghcnVsZUluZm8pIHtcbiAgICB0aHJvdyBlcnJvcnMudW5kZWNsYXJlZFJ1bGUodGhpcy5ydWxlTmFtZSwgZ3JhbW1hci5uYW1lLCB0aGlzLnNvdXJjZSk7XG4gIH1cblxuICAvLyAuLi5hbmQgdGhhdCB0aGlzIGFwcGxpY2F0aW9uIGlzIGFsbG93ZWRcbiAgaWYgKGNvbW1vbi5pc1N5bnRhY3RpYyh0aGlzLnJ1bGVOYW1lKSAmJiAoIWNvbW1vbi5pc1N5bnRhY3RpYyhydWxlTmFtZSkgfHwgbGV4aWZ5Q291bnQgPiAwKSkge1xuICAgIHRocm93IGVycm9ycy5hcHBsaWNhdGlvbk9mU3ludGFjdGljUnVsZUZyb21MZXhpY2FsQ29udGV4dCh0aGlzLnJ1bGVOYW1lLCB0aGlzKTtcbiAgfVxuXG4gIC8vIC4uLmFuZCB0aGF0IHRoaXMgYXBwbGljYXRpb24gaGFzIHRoZSBjb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcbiAgY29uc3QgYWN0dWFsID0gdGhpcy5hcmdzLmxlbmd0aDtcbiAgY29uc3QgZXhwZWN0ZWQgPSBydWxlSW5mby5mb3JtYWxzLmxlbmd0aDtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBlcnJvcnMud3JvbmdOdW1iZXJPZkFyZ3VtZW50cyh0aGlzLnJ1bGVOYW1lLCBleHBlY3RlZCwgYWN0dWFsLCB0aGlzLnNvdXJjZSk7XG4gIH1cblxuICAvLyAuLi5hbmQgdGhhdCBhbGwgb2YgdGhlIGFyZ3VtZW50IGV4cHJlc3Npb25zIG9ubHkgaGF2ZSB2YWxpZCBhcHBsaWNhdGlvbnMgYW5kIGhhdmUgYXJpdHkgMS5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHRoaXMuYXJncy5mb3JFYWNoKGFyZyA9PiB7XG4gICAgYXJnLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG4gICAgaWYgKGFyZy5nZXRBcml0eSgpICE9PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW52YWxpZFBhcmFtZXRlcihzZWxmLnJ1bGVOYW1lLCBhcmcpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRXh0cmEgY2hlY2tzIGZvciBcInNwZWNpYWxcIiBhcHBsaWNhdGlvbnNcblxuICAvLyBJZiBpdCdzIGFuIGFwcGxpY2F0aW9uIG9mICdjYXNlSW5zZW5zaXRpdmUnLCBlbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYSBUZXJtaW5hbC5cbiAgaWYgKEJ1aWx0SW5SdWxlcyAmJiBydWxlSW5mbyA9PT0gQnVpbHRJblJ1bGVzLnJ1bGVzLmNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGlmICghKHRoaXMuYXJnc1swXSBpbnN0YW5jZW9mIHBleHBycy5UZXJtaW5hbCkpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbmNvcnJlY3RBcmd1bWVudFR5cGUoJ2EgVGVybWluYWwgKGUuZy4gXFxcImFiY1xcXCIpJywgdGhpcy5hcmdzWzBdKTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gY29tbW9uLmFic3RyYWN0KFxuICAgICdhc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSdcbik7XG5cbnBleHBycy5hbnkuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPVxucGV4cHJzLmVuZC5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgLy8gbm8tb3Bcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgaWYgKHRoaXMudGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFyaXR5ID0gdGhpcy50ZXJtc1swXS5nZXRBcml0eSgpO1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnRlcm1zLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCB0ZXJtID0gdGhpcy50ZXJtc1tpZHhdO1xuICAgIHRlcm0uYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkoKTtcbiAgICBjb25zdCBvdGhlckFyaXR5ID0gdGVybS5nZXRBcml0eSgpO1xuICAgIGlmIChhcml0eSAhPT0gb3RoZXJBcml0eSkge1xuICAgICAgdGhyb3cgZXJyb3JzLmluY29uc2lzdGVudEFyaXR5KHJ1bGVOYW1lLCBhcml0eSwgb3RoZXJBcml0eSwgdGVybSk7XG4gICAgfVxuICB9XG59O1xuXG5wZXhwcnMuRXh0ZW5kLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIC8vIEV4dGVuZCBpcyBhIHNwZWNpYWwgY2FzZSBvZiBBbHQgdGhhdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBleGFjdGx5IHR3b1xuICAvLyBjYXNlczogW2V4dGVuc2lvbnMsIG9yaWdCb2R5XS5cbiAgY29uc3QgYWN0dWFsQXJpdHkgPSB0aGlzLnRlcm1zWzBdLmdldEFyaXR5KCk7XG4gIGNvbnN0IGV4cGVjdGVkQXJpdHkgPSB0aGlzLnRlcm1zWzFdLmdldEFyaXR5KCk7XG4gIGlmIChhY3R1YWxBcml0eSAhPT0gZXhwZWN0ZWRBcml0eSkge1xuICAgIHRocm93IGVycm9ycy5pbmNvbnNpc3RlbnRBcml0eShydWxlTmFtZSwgZXhwZWN0ZWRBcml0eSwgYWN0dWFsQXJpdHksIHRoaXMudGVybXNbMF0pO1xuICB9XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuZmFjdG9ycy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy5mYWN0b3JzW2lkeF0uYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkocnVsZU5hbWUpO1xuICB9XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICB0aGlzLmV4cHIuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkocnVsZU5hbWUpO1xufTtcblxucGV4cHJzLk5vdC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICAvLyBuby1vcCAobm90IHJlcXVpcmVkIGIvYyB0aGUgbmVzdGVkIGV4cHIgZG9lc24ndCBzaG93IHVwIGluIHRoZSBDU1QpXG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIHRoaXMuZXhwci5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eShydWxlTmFtZSk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgLy8gVGhlIGFyaXRpZXMgb2YgdGhlIHBhcmFtZXRlciBleHByZXNzaW9ucyBpcyByZXF1aXJlZCB0byBiZSAxIGJ5XG4gIC8vIGBhc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCgpYC5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGNvbW1vbi5hYnN0cmFjdChcbiAgICAnYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlJ1xuKTtcblxucGV4cHJzLmFueS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLmVuZC5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIC8vIG5vLW9wXG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMudGVybXMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXMudGVybXNbaWR4XS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUoZ3JhbW1hcik7XG4gIH1cbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLmZhY3RvcnNbaWR4XS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUoZ3JhbW1hcik7XG4gIH1cbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIC8vIE5vdGU6IHRoaXMgaXMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGZvciBgU3RhcmAgYW5kIGBQbHVzYCBleHByZXNzaW9ucy5cbiAgLy8gSXQgaXMgb3ZlcnJpZGRlbiBmb3IgYE9wdGAgYmVsb3cuXG4gIHRoaXMuZXhwci5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUoZ3JhbW1hcik7XG4gIGlmICh0aGlzLmV4cHIuaXNOdWxsYWJsZShncmFtbWFyKSkge1xuICAgIHRocm93IGVycm9ycy5rbGVlbmVFeHBySGFzTnVsbGFibGVPcGVyYW5kKHRoaXMsIFtdKTtcbiAgfVxufTtcblxucGV4cHJzLk9wdC5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5Ob3QucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICB0aGlzLmV4cHIuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlKGdyYW1tYXIpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHRoaXMuYXJncy5mb3JFYWNoKGFyZyA9PiB7XG4gICAgYXJnLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuY2hlY2sgPSBjb21tb24uYWJzdHJhY3QoJ2NoZWNrJyk7XG5cbnBleHBycy5hbnkuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB2YWxzLmxlbmd0aCA+PSAxO1xufTtcblxucGV4cHJzLmVuZC5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHNbMF0gaW5zdGFuY2VvZiBub2Rlcy5Ob2RlICYmXG4gICAgICAgICB2YWxzWzBdLmlzVGVybWluYWwoKSAmJlxuICAgICAgICAgdmFsc1swXS5wcmltaXRpdmVWYWx1ZSA9PT0gdW5kZWZpbmVkO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHNbMF0gaW5zdGFuY2VvZiBub2Rlcy5Ob2RlICYmXG4gICAgICAgICB2YWxzWzBdLmlzVGVybWluYWwoKSAmJlxuICAgICAgICAgdmFsc1swXS5wcmltaXRpdmVWYWx1ZSA9PT0gdGhpcy5vYmo7XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgIHZhbHNbMF0uaXNUZXJtaW5hbCgpICYmXG4gICAgICAgICB0eXBlb2YgdmFsc1swXS5wcmltaXRpdmVWYWx1ZSA9PT0gdHlwZW9mIHRoaXMuZnJvbTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB2YWxzLmxlbmd0aCA+PSAxO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50ZXJtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRlcm0gPSB0aGlzLnRlcm1zW2ldO1xuICAgIGlmICh0ZXJtLmNoZWNrKGdyYW1tYXIsIHZhbHMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIGxldCBwb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IHRoaXMuZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yLmNoZWNrKGdyYW1tYXIsIHZhbHMuc2xpY2UocG9zKSkpIHtcbiAgICAgIHBvcyArPSBmYWN0b3IuZ2V0QXJpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgY29uc3QgYXJpdHkgPSB0aGlzLmdldEFyaXR5KCk7XG4gIGNvbnN0IGNvbHVtbnMgPSB2YWxzLnNsaWNlKDAsIGFyaXR5KTtcbiAgaWYgKGNvbHVtbnMubGVuZ3RoICE9PSBhcml0eSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByb3dDb3VudCA9IGNvbHVtbnNbMF0ubGVuZ3RoO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IGFyaXR5OyBpKyspIHtcbiAgICBpZiAoY29sdW1uc1tpXS5sZW5ndGggIT09IHJvd0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFyaXR5OyBqKyspIHtcbiAgICAgIHJvdy5wdXNoKGNvbHVtbnNbal1baV0pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZXhwci5jaGVjayhncmFtbWFyLCByb3cpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5jaGVjayA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHRoaXMuZXhwci5jaGVjayhncmFtbWFyLCB2YWxzKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIGlmICghKHZhbHNbMF0gaW5zdGFuY2VvZiBub2Rlcy5Ob2RlICYmXG4gICAgICAgIHZhbHNbMF0uZ3JhbW1hciA9PT0gZ3JhbW1hciAmJlxuICAgICAgICB2YWxzWzBdLmN0b3JOYW1lID09PSB0aGlzLnJ1bGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRPRE86IHRoaW5rIGFib3V0ICpub3QqIGRvaW5nIHRoZSBmb2xsb3dpbmcgY2hlY2tzLCBpLmUuLCB0cnVzdGluZyB0aGF0IHRoZSBydWxlXG4gIC8vIHdhcyBjb3JyZWN0bHkgY29uc3RydWN0ZWQuXG4gIGNvbnN0IHJ1bGVOb2RlID0gdmFsc1swXTtcbiAgY29uc3QgYm9keSA9IGdyYW1tYXIucnVsZXNbdGhpcy5ydWxlTmFtZV0uYm9keTtcbiAgcmV0dXJuIGJvZHkuY2hlY2soZ3JhbW1hciwgcnVsZU5vZGUuY2hpbGRyZW4pICYmIHJ1bGVOb2RlLm51bUNoaWxkcmVuKCkgPT09IGJvZHkuZ2V0QXJpdHkoKTtcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB2YWxzWzBdIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSAmJlxuICAgICAgICAgdmFsc1swXS5pc1Rlcm1pbmFsKCkgJiZcbiAgICAgICAgIHR5cGVvZiB2YWxzWzBdLnByaW1pdGl2ZVZhbHVlID09PSAnc3RyaW5nJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vVHJhY2UnKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3Qgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG5jb25zdCBUZXJtaW5hbE5vZGUgPSBub2Rlcy5UZXJtaW5hbE5vZGU7XG5jb25zdCBOb250ZXJtaW5hbE5vZGUgPSBub2Rlcy5Ob250ZXJtaW5hbE5vZGU7XG5jb25zdCBJdGVyYXRpb25Ob2RlID0gbm9kZXMuSXRlcmF0aW9uTm9kZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIEV2YWx1YXRlIHRoZSBleHByZXNzaW9uIGFuZCByZXR1cm4gYHRydWVgIGlmIGl0IHN1Y2NlZWRzLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhpcyBtZXRob2Qgc2hvdWxkXG4gIG9ubHkgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IGBTdGF0ZS5wcm90b3R5cGUuZXZhbChleHByKWAsIHdoaWNoIGFsc28gdXBkYXRlcyB0aGUgZGF0YSBzdHJ1Y3R1cmVzXG4gIHRoYXQgYXJlIHVzZWQgZm9yIHRyYWNpbmcuIChNYWtpbmcgdGhvc2UgdXBkYXRlcyBpbiBhIG1ldGhvZCBvZiBgU3RhdGVgIGVuYWJsZXMgdGhlIHRyYWNlLXNwZWNpZmljXG4gIGRhdGEgc3RydWN0dXJlcyB0byBiZSBcInNlY3JldHNcIiBvZiB0aGF0IGNsYXNzLCB3aGljaCBpcyBnb29kIGZvciBtb2R1bGFyaXR5LilcblxuICBUaGUgY29udHJhY3Qgb2YgdGhpcyBtZXRob2QgaXMgYXMgZm9sbG93czpcbiAgKiBXaGVuIHRoZSByZXR1cm4gdmFsdWUgaXMgYHRydWVgLFxuICAgIC0gdGhlIHN0YXRlIG9iamVjdCB3aWxsIGhhdmUgYGV4cHIuZ2V0QXJpdHkoKWAgbW9yZSBiaW5kaW5ncyB0aGFuIGl0IGRpZCBiZWZvcmUgdGhlIGNhbGwuXG4gICogV2hlbiB0aGUgcmV0dXJuIHZhbHVlIGlzIGBmYWxzZWAsXG4gICAgLSB0aGUgc3RhdGUgb2JqZWN0IG1heSBoYXZlIG1vcmUgYmluZGluZ3MgdGhhbiBpdCBkaWQgYmVmb3JlIHRoZSBjYWxsLCBhbmRcbiAgICAtIGl0cyBpbnB1dCBzdHJlYW0ncyBwb3NpdGlvbiBtYXkgYmUgYW55d2hlcmUuXG5cbiAgTm90ZSB0aGF0IGBTdGF0ZS5wcm90b3R5cGUuZXZhbChleHByKWAsIHVubGlrZSB0aGlzIG1ldGhvZCwgZ3VhcmFudGVlcyB0aGF0IG5laXRoZXIgdGhlIHN0YXRlXG4gIG9iamVjdCdzIGJpbmRpbmdzIG5vciBpdHMgaW5wdXQgc3RyZWFtJ3MgcG9zaXRpb24gd2lsbCBjaGFuZ2UgaWYgdGhlIGV4cHJlc3Npb24gZmFpbHMgdG8gbWF0Y2guXG4qL1xucGV4cHJzLlBFeHByLnByb3RvdHlwZS5ldmFsID0gY29tbW9uLmFic3RyYWN0KCdldmFsJyk7IC8vIGZ1bmN0aW9uKHN0YXRlKSB7IC4uLiB9XG5cbnBleHBycy5hbnkuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGNvbnN0IGNoID0gaW5wdXRTdHJlYW0ubmV4dCgpO1xuICBpZiAoY2gpIHtcbiAgICBzdGF0ZS5wdXNoQmluZGluZyhuZXcgVGVybWluYWxOb2RlKHN0YXRlLmdyYW1tYXIsIGNoKSwgb3JpZ1Bvcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5wZXhwcnMuZW5kLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBpZiAoaW5wdXRTdHJlYW0uYXRFbmQoKSkge1xuICAgIHN0YXRlLnB1c2hCaW5kaW5nKG5ldyBUZXJtaW5hbE5vZGUoc3RhdGUuZ3JhbW1hciwgdW5kZWZpbmVkKSwgb3JpZ1Bvcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBpZiAoIWlucHV0U3RyZWFtLm1hdGNoU3RyaW5nKHRoaXMub2JqKSkge1xuICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5wdXNoQmluZGluZyhuZXcgVGVybWluYWxOb2RlKHN0YXRlLmdyYW1tYXIsIHRoaXMub2JqKSwgb3JpZ1Bvcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGNvbnN0IGNoID0gaW5wdXRTdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggJiYgdGhpcy5mcm9tIDw9IGNoICYmIGNoIDw9IHRoaXMudG8pIHtcbiAgICBzdGF0ZS5wdXNoQmluZGluZyhuZXcgVGVybWluYWxOb2RlKHN0YXRlLmdyYW1tYXIsIGNoKSwgb3JpZ1Bvcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZXZhbChzdGF0ZS5jdXJyZW50QXBwbGljYXRpb24oKS5hcmdzW3RoaXMuaW5kZXhdKTtcbn07XG5cbnBleHBycy5MZXgucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5lbnRlckxleGlmaWVkQ29udGV4dCgpO1xuICBjb25zdCBhbnMgPSBzdGF0ZS5ldmFsKHRoaXMuZXhwcik7XG4gIHN0YXRlLmV4aXRMZXhpZmllZENvbnRleHQoKTtcbiAgcmV0dXJuIGFucztcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnRlcm1zLmxlbmd0aDsgaWR4KyspIHtcbiAgICBpZiAoc3RhdGUuZXZhbCh0aGlzLnRlcm1zW2lkeF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuZmFjdG9ycy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gdGhpcy5mYWN0b3JzW2lkeF07XG4gICAgaWYgKCFzdGF0ZS5ldmFsKGZhY3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGNvbnN0IGFyaXR5ID0gdGhpcy5nZXRBcml0eSgpO1xuICBjb25zdCBjb2xzID0gW107XG4gIGNvbnN0IGNvbE9mZnNldHMgPSBbXTtcbiAgd2hpbGUgKGNvbHMubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICBjb2xzLnB1c2goW10pO1xuICAgIGNvbE9mZnNldHMucHVzaChbXSk7XG4gIH1cblxuICBsZXQgbnVtTWF0Y2hlcyA9IDA7XG4gIGxldCBwcmV2UG9zID0gb3JpZ1BvcztcbiAgbGV0IGlkeDtcbiAgd2hpbGUgKG51bU1hdGNoZXMgPCB0aGlzLm1heE51bU1hdGNoZXMgJiYgc3RhdGUuZXZhbCh0aGlzLmV4cHIpKSB7XG4gICAgaWYgKGlucHV0U3RyZWFtLnBvcyA9PT0gcHJldlBvcykge1xuICAgICAgdGhyb3cgZXJyb3JzLmtsZWVuZUV4cHJIYXNOdWxsYWJsZU9wZXJhbmQodGhpcywgc3RhdGUuX2FwcGxpY2F0aW9uU3RhY2spO1xuICAgIH1cbiAgICBwcmV2UG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICAgIG51bU1hdGNoZXMrKztcbiAgICBjb25zdCByb3cgPSBzdGF0ZS5fYmluZGluZ3Muc3BsaWNlKHN0YXRlLl9iaW5kaW5ncy5sZW5ndGggLSBhcml0eSwgYXJpdHkpO1xuICAgIGNvbnN0IHJvd09mZnNldHMgPSBzdGF0ZS5fYmluZGluZ09mZnNldHMuc3BsaWNlKHN0YXRlLl9iaW5kaW5nT2Zmc2V0cy5sZW5ndGggLSBhcml0eSwgYXJpdHkpO1xuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgcm93Lmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGNvbHNbaWR4XS5wdXNoKHJvd1tpZHhdKTtcbiAgICAgIGNvbE9mZnNldHNbaWR4XS5wdXNoKHJvd09mZnNldHNbaWR4XSk7XG4gICAgfVxuICB9XG4gIGlmIChudW1NYXRjaGVzIDwgdGhpcy5taW5OdW1NYXRjaGVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBvZmZzZXQgPSBzdGF0ZS5wb3NUb09mZnNldChvcmlnUG9zKTtcbiAgbGV0IG1hdGNoTGVuZ3RoID0gMDtcbiAgaWYgKG51bU1hdGNoZXMgPiAwKSB7XG4gICAgY29uc3QgbGFzdENvbCA9IGNvbHNbYXJpdHkgLSAxXTtcbiAgICBjb25zdCBsYXN0Q29sT2Zmc2V0cyA9IGNvbE9mZnNldHNbYXJpdHkgLSAxXTtcblxuICAgIGNvbnN0IGVuZE9mZnNldCA9XG4gICAgICAgIGxhc3RDb2xPZmZzZXRzW2xhc3RDb2xPZmZzZXRzLmxlbmd0aCAtIDFdICsgbGFzdENvbFtsYXN0Q29sLmxlbmd0aCAtIDFdLm1hdGNoTGVuZ3RoO1xuICAgIG9mZnNldCA9IGNvbE9mZnNldHNbMF1bMF07XG4gICAgbWF0Y2hMZW5ndGggPSBlbmRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cbiAgY29uc3QgaXNPcHRpb25hbCA9IHRoaXMgaW5zdGFuY2VvZiBwZXhwcnMuT3B0O1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGNvbHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHN0YXRlLl9iaW5kaW5ncy5wdXNoKFxuICAgICAgICBuZXcgSXRlcmF0aW9uTm9kZShzdGF0ZS5ncmFtbWFyLCBjb2xzW2lkeF0sIGNvbE9mZnNldHNbaWR4XSwgbWF0Y2hMZW5ndGgsIGlzT3B0aW9uYWwpKTtcbiAgICBzdGF0ZS5fYmluZGluZ09mZnNldHMucHVzaChvZmZzZXQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLk5vdC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIC8qXG4gICAgVE9ETzpcbiAgICAtIFJpZ2h0IG5vdyB3ZSdyZSBqdXN0IHRocm93aW5nIGF3YXkgYWxsIG9mIHRoZSBmYWlsdXJlcyB0aGF0IGhhcHBlbiBpbnNpZGUgYSBgbm90YCwgYW5kXG4gICAgICByZWNvcmRpbmcgYHRoaXNgIGFzIGEgZmFpbGVkIGV4cHJlc3Npb24uXG4gICAgLSBEb3VibGUgbmVnYXRpb24gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gbG9va2FoZWFkLCBidXQgdGhhdCdzIG5vdCB0aGUgY2FzZSByaWdodCBub3cgd3J0XG4gICAgICBmYWlsdXJlcy4gRS5nLiwgfn4nZm9vJyBwcm9kdWNlcyBhIGZhaWx1cmUgZm9yIH5+J2ZvbycsIGJ1dCBtYXliZSBpdCBzaG91bGQgcHJvZHVjZVxuICAgICAgYSBmYWlsdXJlIGZvciAnZm9vJyBpbnN0ZWFkLlxuICAqL1xuXG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIHN0YXRlLnB1c2hGYWlsdXJlc0luZm8oKTtcblxuICBjb25zdCBhbnMgPSBzdGF0ZS5ldmFsKHRoaXMuZXhwcik7XG5cbiAgc3RhdGUucG9wRmFpbHVyZXNJbmZvKCk7XG4gIGlmIChhbnMpIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpbnB1dFN0cmVhbS5wb3MgPSBvcmlnUG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBpZiAoc3RhdGUuZXZhbCh0aGlzLmV4cHIpKSB7XG4gICAgaW5wdXRTdHJlYW0ucG9zID0gb3JpZ1BvcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGNhbGxlciA9IHN0YXRlLmN1cnJlbnRBcHBsaWNhdGlvbigpO1xuICBjb25zdCBhY3R1YWxzID0gY2FsbGVyID8gY2FsbGVyLmFyZ3MgOiBbXTtcbiAgY29uc3QgYXBwID0gdGhpcy5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpO1xuXG4gIGNvbnN0IHBvc0luZm8gPSBzdGF0ZS5nZXRDdXJyZW50UG9zSW5mbygpO1xuICBpZiAocG9zSW5mby5pc0FjdGl2ZShhcHApKSB7XG4gICAgLy8gVGhpcyBydWxlIGlzIGFscmVhZHkgYWN0aXZlIGF0IHRoaXMgcG9zaXRpb24sIGkuZS4sIGl0IGlzIGxlZnQtcmVjdXJzaXZlLlxuICAgIHJldHVybiBhcHAuaGFuZGxlQ3ljbGUoc3RhdGUpO1xuICB9XG5cbiAgY29uc3QgbWVtb0tleSA9IGFwcC50b01lbW9LZXkoKTtcbiAgY29uc3QgbWVtb1JlYyA9IHBvc0luZm8ubWVtb1ttZW1vS2V5XTtcblxuICBpZiAobWVtb1JlYyAmJiBwb3NJbmZvLnNob3VsZFVzZU1lbW9pemVkUmVzdWx0KG1lbW9SZWMpKSB7XG4gICAgaWYgKHN0YXRlLmhhc05lY2Vzc2FyeUluZm8obWVtb1JlYykpIHtcbiAgICAgIHJldHVybiBzdGF0ZS51c2VNZW1vaXplZFJlc3VsdChzdGF0ZS5pbnB1dFN0cmVhbS5wb3MsIG1lbW9SZWMpO1xuICAgIH1cbiAgICBkZWxldGUgcG9zSW5mby5tZW1vW21lbW9LZXldO1xuICB9XG4gIHJldHVybiBhcHAucmVhbGx5RXZhbChzdGF0ZSk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmhhbmRsZUN5Y2xlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgcG9zSW5mbyA9IHN0YXRlLmdldEN1cnJlbnRQb3NJbmZvKCk7XG4gIGNvbnN0IGN1cnJlbnRMZWZ0UmVjdXJzaW9uID0gcG9zSW5mby5jdXJyZW50TGVmdFJlY3Vyc2lvbjtcbiAgY29uc3QgbWVtb0tleSA9IHRoaXMudG9NZW1vS2V5KCk7XG4gIGxldCBtZW1vUmVjID0gcG9zSW5mby5tZW1vW21lbW9LZXldO1xuXG4gIGlmIChjdXJyZW50TGVmdFJlY3Vyc2lvbiAmJiBjdXJyZW50TGVmdFJlY3Vyc2lvbi5oZWFkQXBwbGljYXRpb24udG9NZW1vS2V5KCkgPT09IG1lbW9LZXkpIHtcbiAgICAvLyBXZSBhbHJlYWR5IGtub3cgYWJvdXQgdGhpcyBsZWZ0IHJlY3Vyc2lvbiwgYnV0IGl0J3MgcG9zc2libGUgdGhlcmUgYXJlIFwiaW52b2x2ZWRcbiAgICAvLyBhcHBsaWNhdGlvbnNcIiB0aGF0IHdlIGRvbid0IGFscmVhZHkga25vdyBhYm91dCwgc28uLi5cbiAgICBtZW1vUmVjLnVwZGF0ZUludm9sdmVkQXBwbGljYXRpb25NZW1vS2V5cygpO1xuICB9IGVsc2UgaWYgKCFtZW1vUmVjKSB7XG4gICAgLy8gTmV3IGxlZnQgcmVjdXJzaW9uIGRldGVjdGVkISBNZW1vaXplIGEgZmFpbHVyZSB0byB0cnkgdG8gZ2V0IGEgc2VlZCBwYXJzZS5cbiAgICBtZW1vUmVjID0gcG9zSW5mby5tZW1vaXplKFxuICAgICAgICBtZW1vS2V5LFxuICAgICAgICB7bWF0Y2hMZW5ndGg6IDAsIGV4YW1pbmVkTGVuZ3RoOiAwLCB2YWx1ZTogZmFsc2UsIHJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQ6IC0xfSk7XG4gICAgcG9zSW5mby5zdGFydExlZnRSZWN1cnNpb24odGhpcywgbWVtb1JlYyk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnVzZU1lbW9pemVkUmVzdWx0KHN0YXRlLmlucHV0U3RyZWFtLnBvcywgbWVtb1JlYyk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLnJlYWxseUV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBjb25zdCBvcmlnUG9zSW5mbyA9IHN0YXRlLmdldEN1cnJlbnRQb3NJbmZvKCk7XG4gIGNvbnN0IHJ1bGVJbmZvID0gc3RhdGUuZ3JhbW1hci5ydWxlc1t0aGlzLnJ1bGVOYW1lXTtcbiAgY29uc3QgYm9keSA9IHJ1bGVJbmZvLmJvZHk7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gcnVsZUluZm8uZGVzY3JpcHRpb247XG5cbiAgc3RhdGUuZW50ZXJBcHBsaWNhdGlvbihvcmlnUG9zSW5mbywgdGhpcyk7XG5cbiAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgc3RhdGUucHVzaEZhaWx1cmVzSW5mbygpO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGlucHV0IHN0cmVhbSdzIGV4YW1pbmVkTGVuZ3RoIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIHRyYWNrXG4gIC8vIHRoZSBleGFtaW5lZCBsZW5ndGggb2YgdGhpcyBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uLlxuICBjb25zdCBvcmlnSW5wdXRTdHJlYW1FeGFtaW5lZExlbmd0aCA9IGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoO1xuICBpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCA9IDA7XG5cbiAgbGV0IHZhbHVlID0gdGhpcy5ldmFsT25jZShib2R5LCBzdGF0ZSk7XG4gIGNvbnN0IGN1cnJlbnRMUiA9IG9yaWdQb3NJbmZvLmN1cnJlbnRMZWZ0UmVjdXJzaW9uO1xuICBjb25zdCBtZW1vS2V5ID0gdGhpcy50b01lbW9LZXkoKTtcbiAgY29uc3QgaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uID0gY3VycmVudExSICYmIGN1cnJlbnRMUi5oZWFkQXBwbGljYXRpb24udG9NZW1vS2V5KCkgPT09IG1lbW9LZXk7XG4gIGxldCBtZW1vUmVjO1xuXG4gIGlmIChpc0hlYWRPZkxlZnRSZWN1cnNpb24pIHtcbiAgICB2YWx1ZSA9IHRoaXMuZ3Jvd1NlZWRSZXN1bHQoYm9keSwgc3RhdGUsIG9yaWdQb3MsIGN1cnJlbnRMUiwgdmFsdWUpO1xuICAgIG9yaWdQb3NJbmZvLmVuZExlZnRSZWN1cnNpb24oKTtcbiAgICBtZW1vUmVjID0gY3VycmVudExSO1xuICAgIG1lbW9SZWMuZXhhbWluZWRMZW5ndGggPSBpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCAtIG9yaWdQb3M7XG4gICAgbWVtb1JlYy5yaWdodG1vc3RGYWlsdXJlT2Zmc2V0ID0gc3RhdGUuX2dldFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQoKTtcbiAgICBvcmlnUG9zSW5mby5tZW1vaXplKG1lbW9LZXksIG1lbW9SZWMpOyAvLyB1cGRhdGVzIG9yaWdQb3NJbmZvJ3MgbWF4RXhhbWluZWRMZW5ndGhcbiAgfSBlbHNlIGlmICghY3VycmVudExSIHx8ICFjdXJyZW50TFIuaXNJbnZvbHZlZChtZW1vS2V5KSkge1xuICAgIC8vIFRoaXMgYXBwbGljYXRpb24gaXMgbm90IGludm9sdmVkIGluIGxlZnQgcmVjdXJzaW9uLCBzbyBpdCdzIG9rIHRvIG1lbW9pemUgaXQuXG4gICAgbWVtb1JlYyA9IG9yaWdQb3NJbmZvLm1lbW9pemUobWVtb0tleSwge1xuICAgICAgbWF0Y2hMZW5ndGg6IGlucHV0U3RyZWFtLnBvcyAtIG9yaWdQb3MsXG4gICAgICBleGFtaW5lZExlbmd0aDogaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGggLSBvcmlnUG9zLFxuICAgICAgdmFsdWUsXG4gICAgICBmYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb246IHN0YXRlLmNsb25lUmVjb3JkZWRGYWlsdXJlcygpLFxuICAgICAgcmlnaHRtb3N0RmFpbHVyZU9mZnNldDogc3RhdGUuX2dldFJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQoKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHN1Y2NlZWRlZCA9ICEhdmFsdWU7XG5cbiAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgc3RhdGUucG9wRmFpbHVyZXNJbmZvKCk7XG4gICAgaWYgKCFzdWNjZWVkZWQpIHtcbiAgICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWVtb1JlYykge1xuICAgICAgbWVtb1JlYy5mYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb24gPSBzdGF0ZS5jbG9uZVJlY29yZGVkRmFpbHVyZXMoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWNvcmQgdHJhY2UgaW5mb3JtYXRpb24gaW4gdGhlIG1lbW8gdGFibGUsIHNvIHRoYXQgaXQgaXMgYXZhaWxhYmxlIGlmIHRoZSBtZW1vaXplZCByZXN1bHRcbiAgLy8gaXMgdXNlZCBsYXRlci5cbiAgaWYgKHN0YXRlLmlzVHJhY2luZygpICYmIG1lbW9SZWMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHN0YXRlLmdldFRyYWNlRW50cnkob3JpZ1BvcywgdGhpcywgc3VjY2VlZGVkLCBzdWNjZWVkZWQgPyBbdmFsdWVdIDogW10pO1xuICAgIGlmIChpc0hlYWRPZkxlZnRSZWN1cnNpb24pIHtcbiAgICAgIGNvbW1vbi5hc3NlcnQoZW50cnkudGVybWluYXRpbmdMUkVudHJ5ICE9IG51bGwgfHwgIXN1Y2NlZWRlZCk7XG4gICAgICBlbnRyeS5pc0hlYWRPZkxlZnRSZWN1cnNpb24gPSB0cnVlO1xuICAgIH1cbiAgICBtZW1vUmVjLnRyYWNlRW50cnkgPSBlbnRyeTtcbiAgfVxuXG4gIC8vIEZpeCB0aGUgaW5wdXQgc3RyZWFtJ3MgZXhhbWluZWRMZW5ndGggLS0gaXQgc2hvdWxkIGJlIHRoZSBtYXhpbXVtIGV4YW1pbmVkIGxlbmd0aFxuICAvLyBhY3Jvc3MgYWxsIGFwcGxpY2F0aW9ucywgbm90IGp1c3QgdGhpcyBvbmUuXG4gIGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoID0gTWF0aC5tYXgoaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGgsIG9yaWdJbnB1dFN0cmVhbUV4YW1pbmVkTGVuZ3RoKTtcblxuICBzdGF0ZS5leGl0QXBwbGljYXRpb24ob3JpZ1Bvc0luZm8sIHZhbHVlKTtcblxuICByZXR1cm4gc3VjY2VlZGVkO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5ldmFsT25jZSA9IGZ1bmN0aW9uKGV4cHIsIHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG5cbiAgaWYgKHN0YXRlLmV2YWwoZXhwcikpIHtcbiAgICBjb25zdCBhcml0eSA9IGV4cHIuZ2V0QXJpdHkoKTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHN0YXRlLl9iaW5kaW5ncy5zcGxpY2Uoc3RhdGUuX2JpbmRpbmdzLmxlbmd0aCAtIGFyaXR5LCBhcml0eSk7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHN0YXRlLl9iaW5kaW5nT2Zmc2V0cy5zcGxpY2Uoc3RhdGUuX2JpbmRpbmdPZmZzZXRzLmxlbmd0aCAtIGFyaXR5LCBhcml0eSk7XG4gICAgcmV0dXJuIG5ldyBOb250ZXJtaW5hbE5vZGUoXG4gICAgICAgIHN0YXRlLmdyYW1tYXIsIHRoaXMucnVsZU5hbWUsIGJpbmRpbmdzLCBvZmZzZXRzLCBpbnB1dFN0cmVhbS5wb3MgLSBvcmlnUG9zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuZ3Jvd1NlZWRSZXN1bHQgPSBmdW5jdGlvbihib2R5LCBzdGF0ZSwgb3JpZ1BvcywgbHJNZW1vUmVjLCBuZXdWYWx1ZSkge1xuICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxyTWVtb1JlYy5tYXRjaExlbmd0aCA9IGlucHV0U3RyZWFtLnBvcyAtIG9yaWdQb3M7XG4gICAgbHJNZW1vUmVjLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgbHJNZW1vUmVjLmZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbiA9IHN0YXRlLmNsb25lUmVjb3JkZWRGYWlsdXJlcygpO1xuXG4gICAgaWYgKHN0YXRlLmlzVHJhY2luZygpKSB7XG4gICAgICAvLyBCZWZvcmUgZXZhbHVhdGluZyB0aGUgYm9keSBhZ2FpbiwgYWRkIGEgdHJhY2Ugbm9kZSBmb3IgdGhpcyBhcHBsaWNhdGlvbiB0byB0aGUgbWVtbyBlbnRyeS5cbiAgICAgIC8vIEl0cyBvbmx5IGNoaWxkIGlzIGEgY29weSBvZiB0aGUgdHJhY2Ugbm9kZSBmcm9tIGBuZXdWYWx1ZWAsIHdoaWNoIHdpbGwgYWx3YXlzIGJlIHRoZSBsYXN0XG4gICAgICAvLyBlbGVtZW50IGluIGBzdGF0ZS50cmFjZWAuXG4gICAgICBjb25zdCBzZWVkVHJhY2UgPSBzdGF0ZS50cmFjZVtzdGF0ZS50cmFjZS5sZW5ndGggLSAxXTtcbiAgICAgIGxyTWVtb1JlYy50cmFjZUVudHJ5ID0gbmV3IFRyYWNlKFxuICAgICAgICAgIHN0YXRlLmlucHV0LCBvcmlnUG9zLCBpbnB1dFN0cmVhbS5wb3MsIHRoaXMsIHRydWUsIFtuZXdWYWx1ZV0sIFtzZWVkVHJhY2UuY2xvbmUoKV0pO1xuICAgIH1cbiAgICBpbnB1dFN0cmVhbS5wb3MgPSBvcmlnUG9zO1xuICAgIG5ld1ZhbHVlID0gdGhpcy5ldmFsT25jZShib2R5LCBzdGF0ZSk7XG4gICAgaWYgKGlucHV0U3RyZWFtLnBvcyAtIG9yaWdQb3MgPD0gbHJNZW1vUmVjLm1hdGNoTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHN0YXRlLmlzVHJhY2luZygpKSB7XG4gICAgICBzdGF0ZS50cmFjZS5zcGxpY2UoLTIsIDEpOyAvLyBEcm9wIHRoZSB0cmFjZSBmb3IgdGhlIG9sZCBzZWVkLlxuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUuaXNUcmFjaW5nKCkpIHtcbiAgICAvLyBUaGUgbGFzdCBlbnRyeSBpcyBmb3IgYW4gdW51c2VkIHJlc3VsdCAtLSBwb3AgaXQgYW5kIHNhdmUgaXQgaW4gdGhlIFwicmVhbFwiIGVudHJ5LlxuICAgIGxyTWVtb1JlYy50cmFjZUVudHJ5LnJlY29yZExSVGVybWluYXRpb24oc3RhdGUudHJhY2UucG9wKCksIG5ld1ZhbHVlKTtcbiAgfVxuICBpbnB1dFN0cmVhbS5wb3MgPSBvcmlnUG9zICsgbHJNZW1vUmVjLm1hdGNoTGVuZ3RoO1xuICByZXR1cm4gbHJNZW1vUmVjLnZhbHVlO1xufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3QgY2ggPSBpbnB1dFN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCAmJiB0aGlzLnBhdHRlcm4udGVzdChjaCkpIHtcbiAgICBzdGF0ZS5wdXNoQmluZGluZyhuZXcgVGVybWluYWxOb2RlKHN0YXRlLmdyYW1tYXIsIGNoKSwgb3JpZ1Bvcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBmbGF0dGVuKGxpc3RPZkxpc3RzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBsaXN0T2ZMaXN0cyk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGNvbW1vbi5hYnN0cmFjdCgnZ2VuZXJhdGVFeGFtcGxlJyk7XG5cbmZ1bmN0aW9uIGNhdGVnb3JpemVFeGFtcGxlcyhleGFtcGxlcykge1xuICAvLyBBIGxpc3Qgb2YgcnVsZXMgdGhhdCB0aGUgc3lzdGVtIG5lZWRzIGV4YW1wbGVzIG9mLCBpbiBvcmRlciB0byBnZW5lcmF0ZSBhbiBleGFtcGxlXG4gIC8vICAgZm9yIHRoZSBjdXJyZW50IHJ1bGVcbiAgbGV0IGV4YW1wbGVzTmVlZGVkID0gZXhhbXBsZXMuZmlsdGVyKGV4YW1wbGUgPT4gZXhhbXBsZS5oYXNPd25Qcm9wZXJ0eSgnZXhhbXBsZXNOZWVkZWQnKSlcbiAgICAgIC5tYXAoZXhhbXBsZSA9PiBleGFtcGxlLmV4YW1wbGVzTmVlZGVkKTtcblxuICBleGFtcGxlc05lZWRlZCA9IGZsYXR0ZW4oZXhhbXBsZXNOZWVkZWQpO1xuXG4gIGNvbnN0IHVuaXF1ZUV4YW1wbGVzTmVlZGVkID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhhbXBsZXNOZWVkZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50RXhhbXBsZU5lZWRlZCA9IGV4YW1wbGVzTmVlZGVkW2ldO1xuICAgIHVuaXF1ZUV4YW1wbGVzTmVlZGVkW2N1cnJlbnRFeGFtcGxlTmVlZGVkXSA9IHRydWU7XG4gIH1cbiAgZXhhbXBsZXNOZWVkZWQgPSBPYmplY3Qua2V5cyh1bmlxdWVFeGFtcGxlc05lZWRlZCk7XG5cbiAgLy8gQSBsaXN0IG9mIHN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQgZXhhbXBsZXNcbiAgY29uc3Qgc3VjY2Vzc2Z1bEV4YW1wbGVzID0gZXhhbXBsZXMuZmlsdGVyKGV4YW1wbGUgPT4gZXhhbXBsZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSlcbiAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLnZhbHVlKTtcblxuICAvLyBUaGlzIGZsYWcgcmV0dXJucyB0cnVlIGlmIHRoZSBzeXN0ZW0gY2Fubm90IGdlbmVyYXRlIHRoZSBydWxlIGl0IGlzIGN1cnJlbnRseVxuICAvLyAgIGF0dGVtcHRpbmcgdG8gZ2VuZXJhdGUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgaXQgaGFzIHRoZSBleGFtcGxlcyBpdCBuZWVkcy5cbiAgLy8gICBDdXJyZW50bHksIHRoaXMgaXMgb25seSB1c2VkIGluIG92ZXJyaWRpbmcgZ2VuZXJhdG9ycyB0byBwcmV2ZW50IHRoZSBzeXN0ZW0gZnJvbVxuICAvLyAgIGdlbmVyYXRpbmcgZXhhbXBsZXMgZm9yIGNlcnRhaW4gcnVsZXMgKGUuZy4gJ2lkZW50JykuXG4gIGNvbnN0IG5lZWRIZWxwID0gZXhhbXBsZXMuc29tZShpdGVtID0+IGl0ZW0ubmVlZEhlbHApO1xuXG4gIHJldHVybiB7XG4gICAgZXhhbXBsZXNOZWVkZWQsXG4gICAgc3VjY2Vzc2Z1bEV4YW1wbGVzLFxuICAgIG5lZWRIZWxwXG4gIH07XG59XG5cbnBleHBycy5hbnkuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICByZXR1cm4ge3ZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NSkpfTtcbn07XG5cbi8vIEFzc3VtZXMgdGhhdCB0ZXJtaW5hbCdzIG9iamVjdCBpcyBhbHdheXMgYSBzdHJpbmdcbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCkge1xuICByZXR1cm4ge3ZhbHVlOiB0aGlzLm9ian07XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQpIHtcbiAgY29uc3QgcmFuZ2VTaXplID0gdGhpcy50by5jaGFyQ29kZUF0KDApIC0gdGhpcy5mcm9tLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiB7dmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICB0aGlzLmZyb20uY2hhckNvZGVBdCgwKSArIE1hdGguZmxvb3IocmFuZ2VTaXplICogTWF0aC5yYW5kb20oKSlcbiAgKX07XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgcmV0dXJuIGFjdHVhbHNbdGhpcy5pbmRleF0uZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICAvLyBpdGVtcyAtPiB0ZXJtRXhhbXBsZXNcbiAgY29uc3QgdGVybUV4YW1wbGVzID0gdGhpcy50ZXJtcy5tYXAodGVybSA9PiB7XG4gICAgcmV0dXJuIHRlcm0uZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpO1xuICB9KTtcblxuICBjb25zdCBjYXRlZ29yaXplZEV4YW1wbGVzID0gY2F0ZWdvcml6ZUV4YW1wbGVzKHRlcm1FeGFtcGxlcyk7XG5cbiAgY29uc3QgZXhhbXBsZXNOZWVkZWQgPSBjYXRlZ29yaXplZEV4YW1wbGVzLmV4YW1wbGVzTmVlZGVkO1xuICBjb25zdCBzdWNjZXNzZnVsRXhhbXBsZXMgPSBjYXRlZ29yaXplZEV4YW1wbGVzLnN1Y2Nlc3NmdWxFeGFtcGxlcztcbiAgY29uc3QgbmVlZEhlbHAgPSBjYXRlZ29yaXplZEV4YW1wbGVzLm5lZWRIZWxwO1xuXG4gIGNvbnN0IGFucyA9IHt9O1xuXG4gIC8vIEFsdCBjYW4gY29udGFpbiBib3RoIGFuIGV4YW1wbGUgYW5kIGEgcmVxdWVzdCBmb3IgZXhhbXBsZXNcbiAgaWYgKHN1Y2Nlc3NmdWxFeGFtcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHN1Y2Nlc3NmdWxFeGFtcGxlcy5sZW5ndGgpO1xuICAgIGFucy52YWx1ZSA9IHN1Y2Nlc3NmdWxFeGFtcGxlc1tpXTtcbiAgfVxuICBpZiAoZXhhbXBsZXNOZWVkZWQubGVuZ3RoID4gMCkge1xuICAgIGFucy5leGFtcGxlc05lZWRlZCA9IGV4YW1wbGVzTmVlZGVkO1xuICB9XG4gIGFucy5uZWVkSGVscCA9IG5lZWRIZWxwO1xuXG4gIHJldHVybiBhbnM7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIGNvbnN0IGZhY3RvckV4YW1wbGVzID0gdGhpcy5mYWN0b3JzLm1hcChmYWN0b3IgPT4ge1xuICAgIHJldHVybiBmYWN0b3IuZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpO1xuICB9KTtcbiAgY29uc3QgY2F0ZWdvcml6ZWRFeGFtcGxlcyA9IGNhdGVnb3JpemVFeGFtcGxlcyhmYWN0b3JFeGFtcGxlcyk7XG5cbiAgY29uc3QgZXhhbXBsZXNOZWVkZWQgPSBjYXRlZ29yaXplZEV4YW1wbGVzLmV4YW1wbGVzTmVlZGVkO1xuICBjb25zdCBzdWNjZXNzZnVsRXhhbXBsZXMgPSBjYXRlZ29yaXplZEV4YW1wbGVzLnN1Y2Nlc3NmdWxFeGFtcGxlcztcbiAgY29uc3QgbmVlZEhlbHAgPSBjYXRlZ29yaXplZEV4YW1wbGVzLm5lZWRIZWxwO1xuXG4gIGNvbnN0IGFucyA9IHt9O1xuXG4gIC8vIEluIGEgU2VxLCBhbGwgcGllY2VzIG11c3Qgc3VjY2VlZCBpbiBvcmRlciB0byBoYXZlIGEgc3VjY2Vzc2Z1bCBleGFtcGxlLlxuICBpZiAoZXhhbXBsZXNOZWVkZWQubGVuZ3RoID4gMCB8fCBuZWVkSGVscCkge1xuICAgIGFucy5leGFtcGxlc05lZWRlZCA9IGV4YW1wbGVzTmVlZGVkO1xuICAgIGFucy5uZWVkSGVscCA9IG5lZWRIZWxwO1xuICB9IGVsc2Uge1xuICAgIGFucy52YWx1ZSA9IHN1Y2Nlc3NmdWxFeGFtcGxlcy5qb2luKGluU3ludGFjdGljQ29udGV4dCA/ICcgJyA6ICcnKTtcbiAgfVxuXG4gIHJldHVybiBhbnM7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICBjb25zdCByYW5nZVRpbWVzID0gTWF0aC5taW4odGhpcy5tYXhOdW1NYXRjaGVzIC0gdGhpcy5taW5OdW1NYXRjaGVzLCAzKTtcbiAgY29uc3QgbnVtVGltZXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAocmFuZ2VUaW1lcyArIDEpICsgdGhpcy5taW5OdW1NYXRjaGVzKTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzOyBpKyspIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuZXhwci5nZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykpO1xuICB9XG5cbiAgY29uc3QgY2F0ZWdvcml6ZWRFeGFtcGxlcyA9IGNhdGVnb3JpemVFeGFtcGxlcyhpdGVtcyk7XG5cbiAgY29uc3QgZXhhbXBsZXNOZWVkZWQgPSBjYXRlZ29yaXplZEV4YW1wbGVzLmV4YW1wbGVzTmVlZGVkO1xuICBjb25zdCBzdWNjZXNzZnVsRXhhbXBsZXMgPSBjYXRlZ29yaXplZEV4YW1wbGVzLnN1Y2Nlc3NmdWxFeGFtcGxlcztcblxuICBjb25zdCBhbnMgPSB7fTtcblxuICAvLyBJdCdzIGFsd2F5cyBlaXRoZXIgb25lIG9yIHRoZSBvdGhlci5cbiAgLy8gVE9ETzogaW5zdGVhZCBvZiAnICcsIGNhbGwgJ3NwYWNlcy5nZW5lcmF0ZUV4YW1wbGUoKSdcbiAgYW5zLnZhbHVlID0gc3VjY2Vzc2Z1bEV4YW1wbGVzLmpvaW4oaW5TeW50YWN0aWNDb250ZXh0ID8gJyAnIDogJycpO1xuICBpZiAoZXhhbXBsZXNOZWVkZWQubGVuZ3RoID4gMCkge1xuICAgIGFucy5leGFtcGxlc05lZWRlZCA9IGV4YW1wbGVzTmVlZGVkO1xuICB9XG5cbiAgcmV0dXJuIGFucztcbn07XG5cbi8vIFJpZ2h0IG5vdywgJ05vdCcgYW5kICdMb29rYWhlYWQnIGdlbmVyYXRlIG5vdGhpbmcgYW5kIGFzc3VtZSB0aGF0IHdoYXRldmVyIGZvbGxvd3Mgd2lsbFxuLy8gICB3b3JrIGFjY29yZGluZyB0byB0aGUgZW5jb2RlZCBjb25zdHJhaW50cy5cbnBleHBycy5Ob3QucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQpIHtcbiAgcmV0dXJuIHt2YWx1ZTogJyd9O1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCkge1xuICByZXR1cm4ge3ZhbHVlOiAnJ307XG59O1xuXG5wZXhwcnMuTGV4LnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIHJldHVybiB0aGlzLmV4cHIuZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBmYWxzZSwgYWN0dWFscyk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgY29uc3QgYW5zID0ge307XG5cbiAgY29uc3QgcnVsZU5hbWUgPSB0aGlzLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykudG9TdHJpbmcoKTtcblxuICBpZiAoIWV4YW1wbGVzLmhhc093blByb3BlcnR5KHJ1bGVOYW1lKSkge1xuICAgIGFucy5leGFtcGxlc05lZWRlZCA9IFtydWxlTmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVsZXZhbnRFeGFtcGxlcyA9IGV4YW1wbGVzW3J1bGVOYW1lXTtcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVsZXZhbnRFeGFtcGxlcy5sZW5ndGgpO1xuICAgIGFucy52YWx1ZSA9IHJlbGV2YW50RXhhbXBsZXNbaV07XG4gIH1cblxuICByZXR1cm4gYW5zO1xufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihcbiAgICBncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIGxldCBjaGFyO1xuICBzd2l0Y2ggKHRoaXMuY2F0ZWdvcnkpIHtcbiAgICBjYXNlICdMdSc6IGNoYXIgPSAnw4EnOyBicmVhaztcbiAgICBjYXNlICdMbCc6IGNoYXIgPSAnxY8nOyBicmVhaztcbiAgICBjYXNlICdMdCc6IGNoYXIgPSAnx4UnOyBicmVhaztcbiAgICBjYXNlICdMbSc6IGNoYXIgPSAny64nOyBicmVhaztcbiAgICBjYXNlICdMbyc6IGNoYXIgPSAnxrsnOyBicmVhaztcblxuICAgIGNhc2UgJ05sJzogY2hhciA9ICfihoInOyBicmVhaztcbiAgICBjYXNlICdOZCc6IGNoYXIgPSAnwr0nOyBicmVhaztcblxuICAgIGNhc2UgJ01uJzogY2hhciA9ICdcXHUwNDg3JzsgYnJlYWs7XG4gICAgY2FzZSAnTWMnOiBjaGFyID0gJ+Ckvyc7IGJyZWFrO1xuXG4gICAgY2FzZSAnUGMnOiBjaGFyID0gJ+KBgCc7IGJyZWFrO1xuXG4gICAgY2FzZSAnWnMnOiBjaGFyID0gJ1xcdTIwMDEnOyBicmVhaztcblxuICAgIGNhc2UgJ0wnOiBjaGFyID0gJ8OBJzsgYnJlYWs7XG4gICAgY2FzZSAnTHRtbyc6IGNoYXIgPSAnx4UnOyBicmVhaztcbiAgfVxuICByZXR1cm4ge3ZhbHVlOiBjaGFyfTsgLy8g8J+SqVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5nZXRBcml0eSA9IGNvbW1vbi5hYnN0cmFjdCgnZ2V0QXJpdHknKTtcblxucGV4cHJzLmFueS5nZXRBcml0eSA9XG5wZXhwcnMuZW5kLmdldEFyaXR5ID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuZ2V0QXJpdHkgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5nZXRBcml0eSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmdldEFyaXR5ID1cbnBleHBycy5BcHBseS5wcm90b3R5cGUuZ2V0QXJpdHkgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5nZXRBcml0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgaXMgb2sgYi9jIGFsbCB0ZXJtcyBtdXN0IGhhdmUgdGhlIHNhbWUgYXJpdHkgLS0gdGhpcyBwcm9wZXJ0eSBpc1xuICAvLyBjaGVja2VkIGJ5IHRoZSBHcmFtbWFyIGNvbnN0cnVjdG9yLlxuICByZXR1cm4gdGhpcy50ZXJtcy5sZW5ndGggPT09IDAgPyAwIDogdGhpcy50ZXJtc1swXS5nZXRBcml0eSgpO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgbGV0IGFyaXR5ID0gMDtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBhcml0eSArPSB0aGlzLmZhY3RvcnNbaWR4XS5nZXRBcml0eSgpO1xuICB9XG4gIHJldHVybiBhcml0eTtcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5nZXRBcml0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5leHByLmdldEFyaXR5KCk7XG59O1xuXG5wZXhwcnMuTm90LnByb3RvdHlwZS5nZXRBcml0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmdldEFyaXR5ID1cbnBleHBycy5MZXgucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmV4cHIuZ2V0QXJpdHkoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIENhbGxlZCBhdCBncmFtbWFyIGNyZWF0aW9uIHRpbWUgdG8gcmV3cml0ZSBhIHJ1bGUgYm9keSwgcmVwbGFjaW5nIGVhY2ggcmVmZXJlbmNlIHRvIGEgZm9ybWFsXG4gIHBhcmFtZXRlciB3aXRoIGEgYFBhcmFtYCBub2RlLiBSZXR1cm5zIGEgUEV4cHIgLS0gZWl0aGVyIGEgbmV3IG9uZSwgb3IgdGhlIG9yaWdpbmFsIG9uZSBpZlxuICBpdCB3YXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4qL1xucGV4cHJzLlBFeHByLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBjb21tb24uYWJzdHJhY3QoJ2ludHJvZHVjZVBhcmFtcycpO1xuXG5wZXhwcnMuYW55LmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuZW5kLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGZ1bmN0aW9uKGZvcm1hbHMpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIHRoaXMudGVybXMuZm9yRWFjaCgodGVybSwgaWR4LCB0ZXJtcykgPT4ge1xuICAgIHRlcm1zW2lkeF0gPSB0ZXJtLmludHJvZHVjZVBhcmFtcyhmb3JtYWxzKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID0gZnVuY3Rpb24oZm9ybWFscykge1xuICB0aGlzLmZhY3RvcnMuZm9yRWFjaCgoZmFjdG9yLCBpZHgsIGZhY3RvcnMpID0+IHtcbiAgICBmYWN0b3JzW2lkeF0gPSBmYWN0b3IuaW50cm9kdWNlUGFyYW1zKGZvcm1hbHMpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5Ob3QucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID0gZnVuY3Rpb24oZm9ybWFscykge1xuICB0aGlzLmV4cHIgPSB0aGlzLmV4cHIuaW50cm9kdWNlUGFyYW1zKGZvcm1hbHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID0gZnVuY3Rpb24oZm9ybWFscykge1xuICBjb25zdCBpbmRleCA9IGZvcm1hbHMuaW5kZXhPZih0aGlzLnJ1bGVOYW1lKTtcbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICBpZiAodGhpcy5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIHN1cHBvcnRlZD8gU2VlIGlzc3VlICM2NC5cbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyaXplZCBydWxlcyBjYW5ub3QgYmUgcGFzc2VkIGFzIGFyZ3VtZW50cyB0byBhbm90aGVyIHJ1bGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLlBhcmFtKGluZGV4KS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaCgoYXJnLCBpZHgsIGFyZ3MpID0+IHtcbiAgICAgIGFyZ3NbaWR4XSA9IGFyZy5pbnRyb2R1Y2VQYXJhbXMoZm9ybWFscyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFJldHVybnMgYHRydWVgIGlmIHRoaXMgcGFyc2luZyBleHByZXNzaW9uIG1heSBhY2NlcHQgd2l0aG91dCBjb25zdW1pbmcgYW55IGlucHV0LlxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gdGhpcy5faXNOdWxsYWJsZShncmFtbWFyLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn07XG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBjb21tb24uYWJzdHJhY3QoJ19pc051bGxhYmxlJyk7XG5cbnBleHBycy5hbnkuX2lzTnVsbGFibGUgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5QbHVzLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5wZXhwcnMuZW5kLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5vYmogPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBvdmVyLXNpbXBsaWZpY2F0aW9uOiBpdCdzIG9ubHkgY29ycmVjdCBpZiB0aGUgaW5wdXQgaXMgYSBzdHJpbmcuIElmIGl0J3MgYW4gYXJyYXlcbiAgICAvLyBvciBhbiBvYmplY3QsIHRoZW4gdGhlIGVtcHR5IHN0cmluZyBwYXJzaW5nIGV4cHJlc3Npb24gaXMgbm90IG51bGxhYmxlLlxuICAgIHJldHVybiB0aGlzLm9iaiA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgcmV0dXJuIHRoaXMudGVybXMubGVuZ3RoID09PSAwIHx8XG4gICAgICB0aGlzLnRlcm1zLnNvbWUodGVybSA9PiB0ZXJtLl9pc051bGxhYmxlKGdyYW1tYXIsIG1lbW8pKTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICByZXR1cm4gdGhpcy5mYWN0b3JzLmV2ZXJ5KGZhY3RvciA9PiBmYWN0b3IuX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbykpO1xufTtcblxucGV4cHJzLlN0YXIucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5PcHQucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5Ob3QucHJvdG90eXBlLl9pc051bGxhYmxlID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5MZXgucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICByZXR1cm4gdGhpcy5leHByLl9pc051bGxhYmxlKGdyYW1tYXIsIG1lbW8pO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgY29uc3Qga2V5ID0gdGhpcy50b01lbW9LZXkoKTtcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWVtbywga2V5KSkge1xuICAgIGNvbnN0IGJvZHkgPSBncmFtbWFyLnJ1bGVzW3RoaXMucnVsZU5hbWVdLmJvZHk7XG4gICAgY29uc3QgaW5saW5lZCA9IGJvZHkuc3Vic3RpdHV0ZVBhcmFtcyh0aGlzLmFyZ3MpO1xuICAgIG1lbW9ba2V5XSA9IGZhbHNlOyAvLyBQcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbiBmb3IgcmVjdXJzaXZlIHJ1bGVzLlxuICAgIG1lbW9ba2V5XSA9IGlubGluZWQuX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbyk7XG4gIH1cbiAgcmV0dXJuIG1lbW9ba2V5XTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGdldE1ldGFJbmZvKGV4cHIsIGdyYW1tYXJJbnRlcnZhbCkge1xuICBjb25zdCBtZXRhSW5mbyA9IHt9O1xuICBpZiAoZXhwci5zb3VyY2UgJiYgZ3JhbW1hckludGVydmFsKSB7XG4gICAgY29uc3QgYWRqdXN0ZWQgPSBleHByLnNvdXJjZS5yZWxhdGl2ZVRvKGdyYW1tYXJJbnRlcnZhbCk7XG4gICAgbWV0YUluZm8uc291cmNlSW50ZXJ2YWwgPSBbYWRqdXN0ZWQuc3RhcnRJZHgsIGFkanVzdGVkLmVuZElkeF07XG4gIH1cbiAgcmV0dXJuIG1ldGFJbmZvO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBjb21tb24uYWJzdHJhY3QoJ291dHB1dFJlY2lwZScpO1xuXG5wZXhwcnMuYW55Lm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gWydhbnknLCBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpXTtcbn07XG5cbnBleHBycy5lbmQub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbJ2VuZCcsIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCldO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAndGVybWluYWwnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgdGhpcy5vYmpcbiAgXTtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ3JhbmdlJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMuZnJvbSxcbiAgICB0aGlzLnRvXG4gIF07XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICdwYXJhbScsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLmluZGV4XG4gIF07XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAnYWx0JyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpXG4gIF0uY29uY2F0KHRoaXMudGVybXMubWFwKHRlcm0gPT4gdGVybS5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKSkpO1xufTtcblxucGV4cHJzLkV4dGVuZC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMudGVybXNbMF07IC8vIFtleHRlbnNpb24sIG9yaWdpbmFsXVxuICByZXR1cm4gZXh0ZW5zaW9uLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpO1xufTtcblxucGV4cHJzLlNwbGljZS5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIGNvbnN0IGJlZm9yZVRlcm1zID0gdGhpcy50ZXJtcy5zbGljZSgwLCB0aGlzLmV4cGFuc2lvblBvcyk7XG4gIGNvbnN0IGFmdGVyVGVybXMgPSB0aGlzLnRlcm1zLnNsaWNlKHRoaXMuZXhwYW5zaW9uUG9zICsgMSk7XG4gIHJldHVybiBbXG4gICAgJ3NwbGljZScsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICBiZWZvcmVUZXJtcy5tYXAodGVybSA9PiB0ZXJtLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpKSxcbiAgICBhZnRlclRlcm1zLm1hcCh0ZXJtID0+IHRlcm0ub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkpXG4gIF07XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAnc2VxJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpXG4gIF0uY29uY2F0KHRoaXMuZmFjdG9ycy5tYXAoZmFjdG9yID0+IGZhY3Rvci5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKSkpO1xufTtcblxucGV4cHJzLlN0YXIucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9XG5wZXhwcnMuUGx1cy5wcm90b3R5cGUub3V0cHV0UmVjaXBlID1cbnBleHBycy5PcHQucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID1cbnBleHBycy5MZXgucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgIHRoaXMuY29uc3RydWN0b3IubmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgdGhpcy5leHByLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpXG4gIF07XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICdhcHAnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgdGhpcy5ydWxlTmFtZSxcbiAgICB0aGlzLmFyZ3MubWFwKGFyZyA9PiBhcmcub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkpXG4gIF07XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICd1bmljb2RlQ2hhcicsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLmNhdGVnb3J5XG4gIF07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBSZXR1cm5zIGEgUEV4cHIgdGhhdCByZXN1bHRzIGZyb20gcmVjdXJzaXZlbHkgcmVwbGFjaW5nIGV2ZXJ5IGZvcm1hbCBwYXJhbWV0ZXIgKGkuZS4sIGluc3RhbmNlXG4gIG9mIGBQYXJhbWApIGluc2lkZSB0aGlzIFBFeHByIHdpdGggaXRzIGFjdHVhbCB2YWx1ZSBmcm9tIGBhY3R1YWxzYCAoYW4gQXJyYXkpLlxuXG4gIFRoZSByZWNlaXZlciBtdXN0IG5vdCBiZSBtb2RpZmllZDsgYSBuZXcgUEV4cHIgbXVzdCBiZSByZXR1cm5lZCBpZiBhbnkgcmVwbGFjZW1lbnQgaXMgbmVjZXNzYXJ5LlxuKi9cbi8vIGZ1bmN0aW9uKGFjdHVhbHMpIHsgLi4uIH1cbnBleHBycy5QRXhwci5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9IGNvbW1vbi5hYnN0cmFjdCgnc3Vic3RpdHV0ZVBhcmFtcycpO1xuXG5wZXhwcnMuYW55LnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLmVuZC5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICByZXR1cm4gdGhpcztcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9IGZ1bmN0aW9uKGFjdHVhbHMpIHtcbiAgcmV0dXJuIGFjdHVhbHNbdGhpcy5pbmRleF07XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICByZXR1cm4gbmV3IHBleHBycy5BbHQoXG4gICAgICB0aGlzLnRlcm1zLm1hcCh0ZXJtID0+IHRlcm0uc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSkpO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9IGZ1bmN0aW9uKGFjdHVhbHMpIHtcbiAgcmV0dXJuIG5ldyBwZXhwcnMuU2VxKFxuICAgICAgdGhpcy5mYWN0b3JzLm1hcChmYWN0b3IgPT4gZmFjdG9yLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykpKTtcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5Ob3QucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5leHByLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID0gZnVuY3Rpb24oYWN0dWFscykge1xuICBpZiAodGhpcy5hcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIEF2b2lkIG1ha2luZyBhIGNvcHkgb2YgdGhpcyBhcHBsaWNhdGlvbiwgYXMgYW4gb3B0aW1pemF0aW9uXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpKTtcbiAgICByZXR1cm4gbmV3IHBleHBycy5BcHBseSh0aGlzLnJ1bGVOYW1lLCBhcmdzKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG5jb25zdCB7Y29weVdpdGhvdXREdXBsaWNhdGVzfSA9IGNvbW1vbjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGlzUmVzdHJpY3RlZEpTSWRlbnRpZmllcihzdHIpIHtcbiAgcmV0dXJuIC9eW2EtekEtWl8kXVswLTlhLXpBLVpfJF0qJC8udGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRHVwbGljYXRlZE5hbWVzKGFyZ3VtZW50TmFtZUxpc3QpIHtcbiAgLy8gYGNvdW50YCBpcyB1c2VkIHRvIHJlY29yZCB0aGUgbnVtYmVyIG9mIHRpbWVzIGVhY2ggYXJndW1lbnQgbmFtZSBvY2N1cnMgaW4gdGhlIGxpc3QsXG4gIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBjaGVja2luZyBkdXBsaWNhdGVkIGFyZ3VtZW50IG5hbWUuIEl0IG1hcHMgYXJndW1lbnQgbmFtZXMgdG8gaW50cy5cbiAgY29uc3QgY291bnQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBhcmd1bWVudE5hbWVMaXN0LmZvckVhY2goYXJnTmFtZSA9PiB7XG4gICAgY291bnRbYXJnTmFtZV0gPSAoY291bnRbYXJnTmFtZV0gfHwgMCkgKyAxO1xuICB9KTtcblxuICAvLyBBcHBlbmQgc3Vic2NyaXB0cyAoJ18xJywgJ18yJywgLi4uKSB0byBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuXG4gIE9iamVjdC5rZXlzKGNvdW50KS5mb3JFYWNoKGR1cEFyZ05hbWUgPT4ge1xuICAgIGlmIChjb3VudFtkdXBBcmdOYW1lXSA8PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBuYW1lIHNob3dzIHVwIG1vcmUgdGhhbiBvbmNlLCBzbyBhZGQgc3Vic2NyaXB0cy5cbiAgICBsZXQgc3Vic2NyaXB0ID0gMTtcbiAgICBhcmd1bWVudE5hbWVMaXN0LmZvckVhY2goKGFyZ05hbWUsIGlkeCkgPT4ge1xuICAgICAgaWYgKGFyZ05hbWUgPT09IGR1cEFyZ05hbWUpIHtcbiAgICAgICAgYXJndW1lbnROYW1lTGlzdFtpZHhdID0gYXJnTmFtZSArICdfJyArIHN1YnNjcmlwdCsrO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIFJldHVybnMgYSBsaXN0IG9mIHN0cmluZ3MgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGRlZmF1bHQgYXJndW1lbnQgbmFtZXMgZm9yIGl0cyByZWNlaXZlclxuICAoYSBwZXhwcikgaW4gYSBzZW1hbnRpYyBhY3Rpb24uIFRoaXMgaXMgdXNlZCBleGNsdXNpdmVseSBieSB0aGUgU2VtYW50aWNzIEVkaXRvci5cblxuICBgZmlyc3RBcmdJbmRleGAgaXMgdGhlIDEtYmFzZWQgaW5kZXggb2YgdGhlIGZpcnN0IGFyZ3VtZW50IG5hbWUgdGhhdCB3aWxsIGJlIGdlbmVyYXRlZCBmb3IgdGhpc1xuICBwZXhwci4gSXQgZW5hYmxlcyB1cyB0byBuYW1lIGFyZ3VtZW50cyBwb3NpdGlvbmFsbHksIGUuZy4sIGlmIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYVxuICBub24tYWxwaGFudW1lcmljIHRlcm1pbmFsIGxpa2UgXCIrXCIsIGl0IHdpbGwgYmUgbmFtZWQgJyQyJy5cblxuICBgbm9EdXBDaGVja2AgaXMgdHJ1ZSBpZiB0aGUgY2FsbGVyIG9mIGB0b0FyZ3VtZW50TmFtZUxpc3RgIGlzIG5vdCBhIHRvcCBsZXZlbCBjYWxsZXIuIEl0IGVuYWJsZXNcbiAgdXMgdG8gYXZvaWQgbmVzdGVkIGR1cGxpY2F0aW9uIHN1YnNjcmlwdHMgYXBwZW5kaW5nLCBlLmcuLCAnXzFfMScsICdfMV8yJywgYnkgb25seSBjaGVja2luZ1xuICBkdXBsaWNhdGVzIGF0IHRoZSB0b3AgbGV2ZWwuXG5cbiAgSGVyZSBpcyBhIG1vcmUgZWxhYm9yYXRlIGV4YW1wbGUgdGhhdCBpbGx1c3RyYXRlcyBob3cgdGhpcyBtZXRob2Qgd29ya3M6XG4gIGAoYSBcIitcIiBiKS50b0FyZ3VtZW50TmFtZUxpc3QoMSlgIGV2YWx1YXRlcyB0byBgWydhJywgJyQyJywgJ2InXWAgd2l0aCB0aGUgZm9sbG93aW5nIHJlY3Vyc2l2ZVxuICBjYWxsczpcblxuICAgIChhKS50b0FyZ3VtZW50TmFtZUxpc3QoMSkgLT4gWydhJ10sXG4gICAgKFwiK1wiKS50b0FyZ3VtZW50TmFtZUxpc3QoMikgLT4gWyckMiddLFxuICAgIChiKS50b0FyZ3VtZW50TmFtZUxpc3QoMykgLT4gWydiJ11cblxuICBOb3RlczpcbiAgKiBUaGlzIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIG9uIHdlbGwtZm9ybWVkIGV4cHJlc3Npb25zLCBlLmcuLCB0aGUgcmVjZWl2ZXIgbXVzdFxuICAgIG5vdCBoYXZlIGFueSBBbHQgc3ViLWV4cHJlc3Npb25zIHdpdGggaW5jb25zaXN0ZW50IGFyaXRpZXMuXG4gICogZS5nZXRBcml0eSgpID09PSBlLnRvQXJndW1lbnROYW1lTGlzdCgxKS5sZW5ndGhcbiovXG4vLyBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7IC4uLiB9XG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGNvbW1vbi5hYnN0cmFjdCgndG9Bcmd1bWVudE5hbWVMaXN0Jyk7XG5cbnBleHBycy5hbnkudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gWydhbnknXTtcbn07XG5cbnBleHBycy5lbmQudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gWydlbmQnXTtcbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICBpZiAodHlwZW9mIHRoaXMub2JqID09PSAnc3RyaW5nJyAmJiAvXltfYS16QS1aMC05XSskLy50ZXN0KHRoaXMub2JqKSkge1xuICAgIC8vIElmIHRoaXMgdGVybWluYWwgaXMgYSB2YWxpZCBzdWZmaXggZm9yIGEgSlMgaWRlbnRpZmllciwganVzdCBwcmVwZW5kIGl0IHdpdGggJ18nXG4gICAgcmV0dXJuIFsnXycgKyB0aGlzLm9ial07XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBuYW1lIGl0IHBvc2l0aW9uYWxseS5cbiAgICByZXR1cm4gWyckJyArIGZpcnN0QXJnSW5kZXhdO1xuICB9XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgbGV0IGFyZ05hbWUgPSB0aGlzLmZyb20gKyAnX3RvXycgKyB0aGlzLnRvO1xuICAvLyBJZiB0aGUgYGFyZ05hbWVgIGlzIG5vdCB2YWxpZCB0aGVuIHRyeSB0byBwcmVwZW5kIGEgYF9gLlxuICBpZiAoIWlzUmVzdHJpY3RlZEpTSWRlbnRpZmllcihhcmdOYW1lKSkge1xuICAgIGFyZ05hbWUgPSAnXycgKyBhcmdOYW1lO1xuICB9XG4gIC8vIElmIHRoZSBgYXJnTmFtZWAgc3RpbGwgbm90IHZhbGlkIGFmdGVyIHByZXBlbmRpbmcgYSBgX2AsIHRoZW4gbmFtZSBpdCBwb3NpdGlvbmFsbHkuXG4gIGlmICghaXNSZXN0cmljdGVkSlNJZGVudGlmaWVyKGFyZ05hbWUpKSB7XG4gICAgYXJnTmFtZSA9ICckJyArIGZpcnN0QXJnSW5kZXg7XG4gIH1cbiAgcmV0dXJuIFthcmdOYW1lXTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgLy8gYHRlcm1BcmdOYW1lTGlzdHNgIGlzIGFuIGFycmF5IG9mIGFycmF5cyB3aGVyZSBlYWNoIHJvdyBpcyB0aGVcbiAgLy8gYXJndW1lbnQgbmFtZSBsaXN0IHRoYXQgY29ycmVzcG9uZHMgdG8gYSB0ZXJtIGluIHRoaXMgYWx0ZXJuYXRpb24uXG4gIGNvbnN0IHRlcm1BcmdOYW1lTGlzdHMgPSB0aGlzLnRlcm1zLm1hcCh0ZXJtID0+IHRlcm0udG9Bcmd1bWVudE5hbWVMaXN0KGZpcnN0QXJnSW5kZXgsIHRydWUpKTtcblxuICBjb25zdCBhcmd1bWVudE5hbWVMaXN0ID0gW107XG4gIGNvbnN0IG51bUFyZ3MgPSB0ZXJtQXJnTmFtZUxpc3RzWzBdLmxlbmd0aDtcbiAgZm9yIChsZXQgY29sSWR4ID0gMDsgY29sSWR4IDwgbnVtQXJnczsgY29sSWR4KyspIHtcbiAgICBjb25zdCBjb2wgPSBbXTtcbiAgICBmb3IgKGxldCByb3dJZHggPSAwOyByb3dJZHggPCB0aGlzLnRlcm1zLmxlbmd0aDsgcm93SWR4KyspIHtcbiAgICAgIGNvbC5wdXNoKHRlcm1BcmdOYW1lTGlzdHNbcm93SWR4XVtjb2xJZHhdKTtcbiAgICB9XG4gICAgY29uc3QgdW5pcXVlTmFtZXMgPSBjb3B5V2l0aG91dER1cGxpY2F0ZXMoY29sKTtcbiAgICBhcmd1bWVudE5hbWVMaXN0LnB1c2godW5pcXVlTmFtZXMuam9pbignX29yXycpKTtcbiAgfVxuXG4gIGlmICghbm9EdXBDaGVjaykge1xuICAgIHJlc29sdmVEdXBsaWNhdGVkTmFtZXMoYXJndW1lbnROYW1lTGlzdCk7XG4gIH1cbiAgcmV0dXJuIGFyZ3VtZW50TmFtZUxpc3Q7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIC8vIEdlbmVyYXRlIHRoZSBhcmd1bWVudCBuYW1lIGxpc3QsIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgZHVwbGljYXRlcy5cbiAgbGV0IGFyZ3VtZW50TmFtZUxpc3QgPSBbXTtcbiAgdGhpcy5mYWN0b3JzLmZvckVhY2goZmFjdG9yID0+IHtcbiAgICBjb25zdCBmYWN0b3JBcmd1bWVudE5hbWVMaXN0ID0gZmFjdG9yLnRvQXJndW1lbnROYW1lTGlzdChmaXJzdEFyZ0luZGV4LCB0cnVlKTtcbiAgICBhcmd1bWVudE5hbWVMaXN0ID0gYXJndW1lbnROYW1lTGlzdC5jb25jYXQoZmFjdG9yQXJndW1lbnROYW1lTGlzdCk7XG5cbiAgICAvLyBTaGlmdCB0aGUgZmlyc3RBcmdJbmRleCB0byB0YWtlIHRoaXMgZmFjdG9yJ3MgYXJndW1lbnQgbmFtZXMgaW50byBhY2NvdW50LlxuICAgIGZpcnN0QXJnSW5kZXggKz0gZmFjdG9yQXJndW1lbnROYW1lTGlzdC5sZW5ndGg7XG4gIH0pO1xuICBpZiAoIW5vRHVwQ2hlY2spIHtcbiAgICByZXNvbHZlRHVwbGljYXRlZE5hbWVzKGFyZ3VtZW50TmFtZUxpc3QpO1xuICB9XG4gIHJldHVybiBhcmd1bWVudE5hbWVMaXN0O1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgY29uc3QgYXJndW1lbnROYW1lTGlzdCA9IHRoaXMuZXhwci50b0FyZ3VtZW50TmFtZUxpc3QoZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaylcbiAgICAgIC5tYXAoZXhwckFyZ3VtZW50U3RyaW5nID0+IGV4cHJBcmd1bWVudFN0cmluZ1tleHByQXJndW1lbnRTdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdzJyA/XG4gICAgICAgICAgZXhwckFyZ3VtZW50U3RyaW5nICsgJ2VzJyA6XG4gICAgICAgICAgZXhwckFyZ3VtZW50U3RyaW5nICsgJ3MnKTtcbiAgaWYgKCFub0R1cENoZWNrKSB7XG4gICAgcmVzb2x2ZUR1cGxpY2F0ZWROYW1lcyhhcmd1bWVudE5hbWVMaXN0KTtcbiAgfVxuICByZXR1cm4gYXJndW1lbnROYW1lTGlzdDtcbn07XG5cbnBleHBycy5PcHQucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIHRoaXMuZXhwci50b0FyZ3VtZW50TmFtZUxpc3QoZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykubWFwKGFyZ05hbWUgPT4ge1xuICAgIHJldHVybiAnb3B0JyArIGFyZ05hbWVbMF0udG9VcHBlckNhc2UoKSArIGFyZ05hbWUuc2xpY2UoMSk7XG4gIH0pO1xufTtcblxucGV4cHJzLk5vdC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gW107XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPVxucGV4cHJzLkxleC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gdGhpcy5leHByLnRvQXJndW1lbnROYW1lTGlzdChmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gW3RoaXMucnVsZU5hbWVdO1xufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbJyQnICsgZmlyc3RBcmdJbmRleF07XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIFsncGFyYW0nICsgdGhpcy5pbmRleF07XG59O1xuXG4vLyBcIlZhbHVlIHBleHByc1wiIChWYWx1ZSwgU3RyLCBBcnIsIE9iaikgYXJlIGdvaW5nIGF3YXkgc29vbiwgc28gd2UgZG9uJ3Qgd29ycnkgYWJvdXQgdGhlbSBoZXJlLlxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgUEV4cHIsIGZvciB1c2UgYXMgYSBVSSBsYWJlbCwgZXRjLlxucGV4cHJzLlBFeHByLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPSBjb21tb24uYWJzdHJhY3QoJ3RvRGlzcGxheVN0cmluZycpO1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLlNlcS5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS50cmltbWVkKCkuY29udGVudHM7XG4gIH1cbiAgcmV0dXJuICdbJyArIHRoaXMuY29uc3RydWN0b3IubmFtZSArICddJztcbn07XG5cbnBleHBycy5hbnkudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5lbmQudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5JdGVyLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBzID0gdGhpcy5hcmdzLm1hcChhcmcgPT4gYXJnLnRvRGlzcGxheVN0cmluZygpKTtcbiAgICByZXR1cm4gdGhpcy5ydWxlTmFtZSArICc8JyArIHBzLmpvaW4oJywnKSArICc+JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlTmFtZTtcbiAgfVxufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdVbmljb2RlIFsnICsgdGhpcy5jYXRlZ29yeSArICddIGNoYXJhY3Rlcic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRmFpbHVyZSA9IHJlcXVpcmUoJy4vRmFpbHVyZScpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLnRvRmFpbHVyZSA9IGNvbW1vbi5hYnN0cmFjdCgndG9GYWlsdXJlJyk7XG5cbnBleHBycy5hbnkudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgJ2FueSBvYmplY3QnLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5lbmQudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgJ2VuZCBvZiBpbnB1dCcsICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCB0aGlzLm9iaiwgJ3N0cmluZycpO1xufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIC8vIFRPRE86IGNvbWUgdXAgd2l0aCBzb21ldGhpbmcgYmV0dGVyXG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBKU09OLnN0cmluZ2lmeSh0aGlzLmZyb20pICsgJy4uJyArIEpTT04uc3RyaW5naWZ5KHRoaXMudG8pLCAnY29kZScpO1xufTtcblxucGV4cHJzLk5vdC5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMuZXhwciA9PT0gcGV4cHJzLmFueSA/XG4gICAgICAnbm90aGluZycgOlxuICAgICAgJ25vdCAnICsgdGhpcy5leHByLnRvRmFpbHVyZShncmFtbWFyKTtcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIGRlc2NyaXB0aW9uLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgcmV0dXJuIHRoaXMuZXhwci50b0ZhaWx1cmUoZ3JhbW1hcik7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgbGV0IGRlc2NyaXB0aW9uID0gZ3JhbW1hci5ydWxlc1t0aGlzLnJ1bGVOYW1lXS5kZXNjcmlwdGlvbjtcbiAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgIGNvbnN0IGFydGljbGUgPSAoL15bYWVpb3VBRUlPVV0vLnRlc3QodGhpcy5ydWxlTmFtZSkgPyAnYW4nIDogJ2EnKTtcbiAgICBkZXNjcmlwdGlvbiA9IGFydGljbGUgKyAnICcgKyB0aGlzLnJ1bGVOYW1lO1xuICB9XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBkZXNjcmlwdGlvbiwgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsICdhIFVuaWNvZGUgWycgKyB0aGlzLmNhdGVnb3J5ICsgJ10gY2hhcmFjdGVyJywgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGNvbnN0IGZzID0gdGhpcy50ZXJtcy5tYXAodCA9PiB0LnRvRmFpbHVyZShncmFtbWFyKSk7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gJygnICsgZnMuam9pbignIG9yICcpICsgJyknO1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgZGVzY3JpcHRpb24sICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBjb25zdCBmcyA9IHRoaXMuZmFjdG9ycy5tYXAoZiA9PiBmLnRvRmFpbHVyZShncmFtbWFyKSk7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gJygnICsgZnMuam9pbignICcpICsgJyknO1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgZGVzY3JpcHRpb24sICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSAnKCcgKyB0aGlzLmV4cHIudG9GYWlsdXJlKGdyYW1tYXIpICsgdGhpcy5vcGVyYXRvciArICcpJztcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIGRlc2NyaXB0aW9uLCAnZGVzY3JpcHRpb24nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIGUxLnRvU3RyaW5nKCkgPT09IGUyLnRvU3RyaW5nKCkgPT0+IGUxIGFuZCBlMiBhcmUgc2VtYW50aWNhbGx5IGVxdWl2YWxlbnQuXG4gIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhbiBpZmYgKDw9PT4pOiBlLmcuLFxuICAoflwiYlwiIFwiYVwiKS50b1N0cmluZygpICE9PSAoXCJhXCIpLnRvU3RyaW5nKCksIGV2ZW4gdGhvdWdoXG4gIH5cImJcIiBcImFcIiBhbmQgXCJhXCIgYXJlIGludGVyY2hhbmdlYWJsZSBpbiBhbnkgZ3JhbW1hcixcbiAgYm90aCBpbiB0ZXJtcyBvZiB0aGUgbGFuZ3VhZ2VzIHRoZXkgYWNjZXB0IGFuZCB0aGVpciBhcml0aWVzLlxuKi9cbnBleHBycy5QRXhwci5wcm90b3R5cGUudG9TdHJpbmcgPSBjb21tb24uYWJzdHJhY3QoJ3RvU3RyaW5nJyk7XG5cbnBleHBycy5hbnkudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdhbnknO1xufTtcblxucGV4cHJzLmVuZC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ2VuZCc7XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLm9iaik7XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmZyb20pICsgJy4uJyArIEpTT04uc3RyaW5naWZ5KHRoaXMudG8pO1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJyQnICsgdGhpcy5pbmRleDtcbn07XG5cbnBleHBycy5MZXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnIygnICsgdGhpcy5leHByLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50ZXJtcy5sZW5ndGggPT09IDEgP1xuICAgIHRoaXMudGVybXNbMF0udG9TdHJpbmcoKSA6XG4gICAgJygnICsgdGhpcy50ZXJtcy5tYXAodGVybSA9PiB0ZXJtLnRvU3RyaW5nKCkpLmpvaW4oJyB8ICcpICsgJyknO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmFjdG9ycy5sZW5ndGggPT09IDEgP1xuICAgIHRoaXMuZmFjdG9yc1swXS50b1N0cmluZygpIDpcbiAgICAnKCcgKyB0aGlzLmZhY3RvcnMubWFwKGZhY3RvciA9PiBmYWN0b3IudG9TdHJpbmcoKSkuam9pbignICcpICsgJyknO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmV4cHIgKyB0aGlzLm9wZXJhdG9yO1xufTtcblxucGV4cHJzLk5vdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICd+JyArIHRoaXMuZXhwcjtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJicgKyB0aGlzLmV4cHI7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBzID0gdGhpcy5hcmdzLm1hcChhcmcgPT4gYXJnLnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lICsgJzwnICsgcHMuam9pbignLCcpICsgJz4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICB9XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnXFxcXHB7JyArIHRoaXMuY2F0ZWdvcnkgKyAnfSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgVW5pY29kZUNhdGVnb3JpZXMgPSByZXF1aXJlKCcuLi90aGlyZF9wYXJ0eS9Vbmljb2RlQ2F0ZWdvcmllcycpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEdlbmVyYWwgc3R1ZmZcblxuY2xhc3MgUEV4cHIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gUEV4cHIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBFeHByIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgLS0gaXQncyBhYnN0cmFjdFwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIHRoZSBpbnRlcnZhbCBjb250YWluaW5nIHRoZSBzb3VyY2UgZm9yIHRoaXMgZXhwcmVzc2lvbi5cbiAgd2l0aFNvdXJjZShpbnRlcnZhbCkge1xuICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBpbnRlcnZhbC50cmltbWVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8vIEFueVxuXG5jb25zdCBhbnkgPSBPYmplY3QuY3JlYXRlKFBFeHByLnByb3RvdHlwZSk7XG5cbi8vIEVuZFxuXG5jb25zdCBlbmQgPSBPYmplY3QuY3JlYXRlKFBFeHByLnByb3RvdHlwZSk7XG5cbi8vIFRlcm1pbmFsc1xuXG5jbGFzcyBUZXJtaW5hbCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9iaiA9IG9iajtcbiAgfVxufVxuXG4vLyBSYW5nZXNcblxuY2xhc3MgUmFuZ2UgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIHRoaXMudG8gPSB0bztcbiAgfVxufVxuXG4vLyBQYXJhbWV0ZXJzXG5cbmNsYXNzIFBhcmFtIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihpbmRleCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5cbi8vIEFsdGVybmF0aW9uXG5cbmNsYXNzIEFsdCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IodGVybXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGVybXMgPSB0ZXJtcztcbiAgfVxufVxuXG4vLyBFeHRlbmQgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIHJ1bGUgZXh0ZW5zaW9uXG5cbmNsYXNzIEV4dGVuZCBleHRlbmRzIEFsdCB7XG4gIGNvbnN0cnVjdG9yKHN1cGVyR3JhbW1hciwgbmFtZSwgYm9keSkge1xuICAgIGNvbnN0IG9yaWdCb2R5ID0gc3VwZXJHcmFtbWFyLnJ1bGVzW25hbWVdLmJvZHk7XG4gICAgc3VwZXIoW2JvZHksIG9yaWdCb2R5XSk7XG5cbiAgICB0aGlzLnN1cGVyR3JhbW1hciA9IHN1cGVyR3JhbW1hcjtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gIH1cbn1cblxuLy8gU3BsaWNlIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBydWxlIG92ZXJyaWRpbmcgd2l0aCB0aGUgYC4uLmAgb3BlcmF0b3IuXG5jbGFzcyBTcGxpY2UgZXh0ZW5kcyBBbHQge1xuICBjb25zdHJ1Y3RvcihzdXBlckdyYW1tYXIsIHJ1bGVOYW1lLCBiZWZvcmVUZXJtcywgYWZ0ZXJUZXJtcykge1xuICAgIGNvbnN0IG9yaWdCb2R5ID0gc3VwZXJHcmFtbWFyLnJ1bGVzW3J1bGVOYW1lXS5ib2R5O1xuICAgIHN1cGVyKFsuLi5iZWZvcmVUZXJtcywgb3JpZ0JvZHksIC4uLmFmdGVyVGVybXNdKTtcblxuICAgIHRoaXMuc3VwZXJHcmFtbWFyID0gc3VwZXJHcmFtbWFyO1xuICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgICB0aGlzLmV4cGFuc2lvblBvcyA9IGJlZm9yZVRlcm1zLmxlbmd0aDtcbiAgfVxufVxuXG4vLyBTZXF1ZW5jZXNcblxuY2xhc3MgU2VxIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihmYWN0b3JzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZhY3RvcnMgPSBmYWN0b3JzO1xuICB9XG59XG5cbi8vIEl0ZXJhdG9ycyBhbmQgb3B0aW9uYWxzXG5cbmNsYXNzIEl0ZXIgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGV4cHIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gIH1cbn1cblxuY2xhc3MgU3RhciBleHRlbmRzIEl0ZXIge31cbmNsYXNzIFBsdXMgZXh0ZW5kcyBJdGVyIHt9XG5jbGFzcyBPcHQgZXh0ZW5kcyBJdGVyIHt9XG5cblN0YXIucHJvdG90eXBlLm9wZXJhdG9yID0gJyonO1xuUGx1cy5wcm90b3R5cGUub3BlcmF0b3IgPSAnKyc7XG5PcHQucHJvdG90eXBlLm9wZXJhdG9yID0gJz8nO1xuXG5TdGFyLnByb3RvdHlwZS5taW5OdW1NYXRjaGVzID0gMDtcblBsdXMucHJvdG90eXBlLm1pbk51bU1hdGNoZXMgPSAxO1xuT3B0LnByb3RvdHlwZS5taW5OdW1NYXRjaGVzID0gMDtcblxuU3Rhci5wcm90b3R5cGUubWF4TnVtTWF0Y2hlcyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblBsdXMucHJvdG90eXBlLm1heE51bU1hdGNoZXMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5PcHQucHJvdG90eXBlLm1heE51bU1hdGNoZXMgPSAxO1xuXG4vLyBQcmVkaWNhdGVzXG5cbmNsYXNzIE5vdCBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZXhwcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgfVxufVxuXG5jbGFzcyBMb29rYWhlYWQgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGV4cHIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gIH1cbn1cblxuLy8gXCJMZXhpZmljYXRpb25cIlxuXG5jbGFzcyBMZXggZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGV4cHIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gIH1cbn1cblxuLy8gUnVsZSBhcHBsaWNhdGlvblxuXG5jbGFzcyBBcHBseSBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWUsIGFyZ3M9W10pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG5cbiAgaXNTeW50YWN0aWMoKSB7XG4gICAgcmV0dXJuIGNvbW1vbi5pc1N5bnRhY3RpYyh0aGlzLnJ1bGVOYW1lKTtcbiAgfVxuXG4gIC8vIFRoaXMgbWV0aG9kIGp1c3QgY2FjaGVzIHRoZSByZXN1bHQgb2YgYHRoaXMudG9TdHJpbmcoKWAgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgdG9NZW1vS2V5KCkge1xuICAgIGlmICghdGhpcy5fbWVtb0tleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfbWVtb0tleScsIHt2YWx1ZTogdGhpcy50b1N0cmluZygpfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tZW1vS2V5O1xuICB9XG59XG5cbi8vIFVuaWNvZGUgY2hhcmFjdGVyXG5cbmNsYXNzIFVuaWNvZGVDaGFyIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihjYXRlZ29yeSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgIHRoaXMucGF0dGVybiA9IFVuaWNvZGVDYXRlZ29yaWVzW2NhdGVnb3J5XTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5QRXhwciA9IFBFeHByO1xuZXhwb3J0cy5hbnkgPSBhbnk7XG5leHBvcnRzLmVuZCA9IGVuZDtcbmV4cG9ydHMuVGVybWluYWwgPSBUZXJtaW5hbDtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuUGFyYW0gPSBQYXJhbTtcbmV4cG9ydHMuQWx0ID0gQWx0O1xuZXhwb3J0cy5FeHRlbmQgPSBFeHRlbmQ7XG5leHBvcnRzLlNwbGljZSA9IFNwbGljZTtcbmV4cG9ydHMuU2VxID0gU2VxO1xuZXhwb3J0cy5JdGVyID0gSXRlcjtcbmV4cG9ydHMuU3RhciA9IFN0YXI7XG5leHBvcnRzLlBsdXMgPSBQbHVzO1xuZXhwb3J0cy5PcHQgPSBPcHQ7XG5leHBvcnRzLk5vdCA9IE5vdDtcbmV4cG9ydHMuTG9va2FoZWFkID0gTG9va2FoZWFkO1xuZXhwb3J0cy5MZXggPSBMZXg7XG5leHBvcnRzLkFwcGx5ID0gQXBwbHk7XG5leHBvcnRzLlVuaWNvZGVDaGFyID0gVW5pY29kZUNoYXI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHRlbnNpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5yZXF1aXJlKCcuL3BleHBycy1hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlJyk7XG5yZXF1aXJlKCcuL3BleHBycy1hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCcpO1xucmVxdWlyZSgnLi9wZXhwcnMtYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHknKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZScpO1xucmVxdWlyZSgnLi9wZXhwcnMtY2hlY2snKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWV2YWwnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWdldEFyaXR5Jyk7XG5yZXF1aXJlKCcuL3BleHBycy1nZW5lcmF0ZUV4YW1wbGUnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLW91dHB1dFJlY2lwZScpO1xucmVxdWlyZSgnLi9wZXhwcnMtaW50cm9kdWNlUGFyYW1zJyk7XG5yZXF1aXJlKCcuL3BleHBycy1pc051bGxhYmxlJyk7XG5yZXF1aXJlKCcuL3BleHBycy1zdWJzdGl0dXRlUGFyYW1zJyk7XG5yZXF1aXJlKCcuL3BleHBycy10b0Rpc3BsYXlTdHJpbmcnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXRvQXJndW1lbnROYW1lTGlzdCcpO1xucmVxdWlyZSgnLi9wZXhwcnMtdG9GYWlsdXJlJyk7XG5yZXF1aXJlKCcuL3BleHBycy10b1N0cmluZycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEdpdmVuIGFuIGFycmF5IG9mIG51bWJlcnMgYGFycmAsIHJldHVybiBhbiBhcnJheSBvZiB0aGUgbnVtYmVycyBhcyBzdHJpbmdzLFxuLy8gcmlnaHQtanVzdGlmaWVkIGFuZCBwYWRkZWQgdG8gdGhlIHNhbWUgbGVuZ3RoLlxuZnVuY3Rpb24gcGFkTnVtYmVyc1RvRXF1YWxMZW5ndGgoYXJyKSB7XG4gIGxldCBtYXhMZW4gPSAwO1xuICBjb25zdCBzdHJpbmdzID0gYXJyLm1hcChuID0+IHtcbiAgICBjb25zdCBzdHIgPSBuLnRvU3RyaW5nKCk7XG4gICAgbWF4TGVuID0gTWF0aC5tYXgobWF4TGVuLCBzdHIubGVuZ3RoKTtcbiAgICByZXR1cm4gc3RyO1xuICB9KTtcbiAgcmV0dXJuIHN0cmluZ3MubWFwKHMgPT4gY29tbW9uLnBhZExlZnQocywgbWF4TGVuKSk7XG59XG5cbi8vIFByb2R1Y2UgYSBuZXcgc3RyaW5nIHRoYXQgd291bGQgYmUgdGhlIHJlc3VsdCBvZiBjb3B5aW5nIHRoZSBjb250ZW50c1xuLy8gb2YgdGhlIHN0cmluZyBgc3JjYCBvbnRvIGBkZXN0YCBhdCBvZmZzZXQgYG9mZmVzdGAuXG5mdW5jdGlvbiBzdHJjcHkoZGVzdCwgc3JjLCBvZmZzZXQpIHtcbiAgY29uc3Qgb3JpZ0Rlc3RMZW4gPSBkZXN0Lmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBkZXN0LnNsaWNlKDAsIG9mZnNldCk7XG4gIGNvbnN0IGVuZCA9IGRlc3Quc2xpY2Uob2Zmc2V0ICsgc3JjLmxlbmd0aCk7XG4gIHJldHVybiAoc3RhcnQgKyBzcmMgKyBlbmQpLnN1YnN0cigwLCBvcmlnRGVzdExlbik7XG59XG5cbi8vIENhc3RzIHRoZSB1bmRlcmx5aW5nIGxpbmVBbmRDb2wgb2JqZWN0IHRvIGEgZm9ybWF0dGVkIG1lc3NhZ2Ugc3RyaW5nLFxuLy8gaGlnaGxpZ2h0aW5nIGByYW5nZXNgLlxuZnVuY3Rpb24gbGluZUFuZENvbHVtblRvTWVzc2FnZSguLi5yYW5nZXMpIHtcbiAgY29uc3QgbGluZUFuZENvbCA9IHRoaXM7XG4gIGNvbnN0IG9mZnNldCA9IGxpbmVBbmRDb2wub2Zmc2V0O1xuICBjb25zdCByZXBlYXRTdHIgPSBjb21tb24ucmVwZWF0U3RyO1xuXG4gIGNvbnN0IHNiID0gbmV3IGNvbW1vbi5TdHJpbmdCdWZmZXIoKTtcbiAgc2IuYXBwZW5kKCdMaW5lICcgKyBsaW5lQW5kQ29sLmxpbmVOdW0gKyAnLCBjb2wgJyArIGxpbmVBbmRDb2wuY29sTnVtICsgJzpcXG4nKTtcblxuICAvLyBBbiBhcnJheSBvZiB0aGUgcHJldmlvdXMsIGN1cnJlbnQsIGFuZCBuZXh0IGxpbmUgbnVtYmVycyBhcyBzdHJpbmdzIG9mIGVxdWFsIGxlbmd0aC5cbiAgY29uc3QgbGluZU51bWJlcnMgPSBwYWROdW1iZXJzVG9FcXVhbExlbmd0aChbXG4gICAgbGluZUFuZENvbC5wcmV2TGluZSA9PSBudWxsID8gMCA6IGxpbmVBbmRDb2wubGluZU51bSAtIDEsXG4gICAgbGluZUFuZENvbC5saW5lTnVtLFxuICAgIGxpbmVBbmRDb2wubmV4dExpbmUgPT0gbnVsbCA/IDAgOiBsaW5lQW5kQ29sLmxpbmVOdW0gKyAxXG4gIF0pO1xuXG4gIC8vIEhlbHBlciBmb3IgYXBwZW5kaW5nIGZvcm1hdHRpbmcgaW5wdXQgbGluZXMgdG8gdGhlIGJ1ZmZlci5cbiAgY29uc3QgYXBwZW5kTGluZSA9IChudW0sIGNvbnRlbnQsIHByZWZpeCkgPT4ge1xuICAgIHNiLmFwcGVuZChwcmVmaXggKyBsaW5lTnVtYmVyc1tudW1dICsgJyB8ICcgKyBjb250ZW50ICsgJ1xcbicpO1xuICB9O1xuXG4gIC8vIEluY2x1ZGUgdGhlIHByZXZpb3VzIGxpbmUgZm9yIGNvbnRleHQgaWYgcG9zc2libGUuXG4gIGlmIChsaW5lQW5kQ29sLnByZXZMaW5lICE9IG51bGwpIHtcbiAgICBhcHBlbmRMaW5lKDAsIGxpbmVBbmRDb2wucHJldkxpbmUsICcgICcpO1xuICB9XG4gIC8vIExpbmUgdGhhdCB0aGUgZXJyb3Igb2NjdXJyZWQgb24uXG4gIGFwcGVuZExpbmUoMSwgbGluZUFuZENvbC5saW5lLCAnPiAnKTtcblxuICAvLyBCdWlsZCB1cCB0aGUgbGluZSB0aGF0IHBvaW50cyB0byB0aGUgb2Zmc2V0IGFuZCBwb3NzaWJsZSBpbmRpY2F0ZXMgb25lIG9yIG1vcmUgcmFuZ2VzLlxuICAvLyBTdGFydCB3aXRoIGEgYmxhbmsgbGluZSwgYW5kIGluZGljYXRlIGVhY2ggcmFuZ2UgYnkgb3ZlcmxheWluZyBhIHN0cmluZyBvZiBgfmAgY2hhcnMuXG4gIGNvbnN0IGxpbmVMZW4gPSBsaW5lQW5kQ29sLmxpbmUubGVuZ3RoO1xuICBsZXQgaW5kaWNhdGlvbkxpbmUgPSByZXBlYXRTdHIoJyAnLCBsaW5lTGVuICsgMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IHN0YXJ0SWR4ID0gcmFuZ2VzW2ldWzBdO1xuICAgIGxldCBlbmRJZHggPSByYW5nZXNbaV1bMV07XG4gICAgY29tbW9uLmFzc2VydChzdGFydElkeCA+PSAwICYmIHN0YXJ0SWR4IDw9IGVuZElkeCwgJ3JhbmdlIHN0YXJ0IG11c3QgYmUgPj0gMCBhbmQgPD0gZW5kJyk7XG5cbiAgICBjb25zdCBsaW5lU3RhcnRPZmZzZXQgPSBvZmZzZXQgLSBsaW5lQW5kQ29sLmNvbE51bSArIDE7XG4gICAgc3RhcnRJZHggPSBNYXRoLm1heCgwLCBzdGFydElkeCAtIGxpbmVTdGFydE9mZnNldCk7XG4gICAgZW5kSWR4ID0gTWF0aC5taW4oZW5kSWR4IC0gbGluZVN0YXJ0T2Zmc2V0LCBsaW5lTGVuKTtcblxuICAgIGluZGljYXRpb25MaW5lID0gc3RyY3B5KGluZGljYXRpb25MaW5lLCByZXBlYXRTdHIoJ34nLCBlbmRJZHggLSBzdGFydElkeCksIHN0YXJ0SWR4KTtcbiAgfVxuICBjb25zdCBndXR0ZXJXaWR0aCA9IDIgKyBsaW5lTnVtYmVyc1sxXS5sZW5ndGggKyAzO1xuICBzYi5hcHBlbmQocmVwZWF0U3RyKCcgJywgZ3V0dGVyV2lkdGgpKTtcbiAgaW5kaWNhdGlvbkxpbmUgPSBzdHJjcHkoaW5kaWNhdGlvbkxpbmUsICdeJywgbGluZUFuZENvbC5jb2xOdW0gLSAxKTtcbiAgc2IuYXBwZW5kKGluZGljYXRpb25MaW5lLnJlcGxhY2UoLyArJC8sICcnKSArICdcXG4nKTtcblxuICAvLyBJbmNsdWRlIHRoZSBuZXh0IGxpbmUgZm9yIGNvbnRleHQgaWYgcG9zc2libGUuXG4gIGlmIChsaW5lQW5kQ29sLm5leHRMaW5lICE9IG51bGwpIHtcbiAgICBhcHBlbmRMaW5lKDIsIGxpbmVBbmRDb2wubmV4dExpbmUsICcgICcpO1xuICB9XG4gIHJldHVybiBzYi5jb250ZW50cygpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmxldCBidWlsdEluUnVsZXNDYWxsYmFja3MgPSBbXTtcblxuLy8gU2luY2UgR3JhbW1hci5CdWlsdEluUnVsZXMgaXMgYm9vdHN0cmFwcGVkLCBtb3N0IG9mIE9obSBjYW4ndCBkaXJlY3RseSBkZXBlbmQgaXQuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyBtb2R1bGVzIHRoYXQgZG8gZGVwZW5kIG9uIHRoZSBidWlsdC1pbiBydWxlcyB0byByZWdpc3RlciBhIGNhbGxiYWNrXG4vLyB0aGF0IHdpbGwgYmUgY2FsbGVkIGxhdGVyIGluIHRoZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzLlxuZXhwb3J0cy5hd2FpdEJ1aWx0SW5SdWxlcyA9IGNiID0+IHtcbiAgYnVpbHRJblJ1bGVzQ2FsbGJhY2tzLnB1c2goY2IpO1xufTtcblxuZXhwb3J0cy5hbm5vdW5jZUJ1aWx0SW5SdWxlcyA9IGdyYW1tYXIgPT4ge1xuICBidWlsdEluUnVsZXNDYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgY2IoZ3JhbW1hcik7XG4gIH0pO1xuICBidWlsdEluUnVsZXNDYWxsYmFja3MgPSBudWxsO1xufTtcblxuLy8gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnaXZlblxuLy8gb2Zmc2V0IGluIGBzdHJgLlxuZXhwb3J0cy5nZXRMaW5lQW5kQ29sdW1uID0gKHN0ciwgb2Zmc2V0KSA9PiB7XG4gIGxldCBsaW5lTnVtID0gMTtcbiAgbGV0IGNvbE51bSA9IDE7XG5cbiAgbGV0IGN1cnJPZmZzZXQgPSAwO1xuICBsZXQgbGluZVN0YXJ0T2Zmc2V0ID0gMDtcblxuICBsZXQgbmV4dExpbmUgPSBudWxsO1xuICBsZXQgcHJldkxpbmUgPSBudWxsO1xuICBsZXQgcHJldkxpbmVTdGFydE9mZnNldCA9IC0xO1xuXG4gIHdoaWxlIChjdXJyT2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoY3Vyck9mZnNldCsrKTtcbiAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgIGxpbmVOdW0rKztcbiAgICAgIGNvbE51bSA9IDE7XG4gICAgICBwcmV2TGluZVN0YXJ0T2Zmc2V0ID0gbGluZVN0YXJ0T2Zmc2V0O1xuICAgICAgbGluZVN0YXJ0T2Zmc2V0ID0gY3Vyck9mZnNldDtcbiAgICB9IGVsc2UgaWYgKGMgIT09ICdcXHInKSB7XG4gICAgICBjb2xOdW0rKztcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBlbmQgb2YgdGhlIHRhcmdldCBsaW5lLlxuICBsZXQgbGluZUVuZE9mZnNldCA9IHN0ci5pbmRleE9mKCdcXG4nLCBsaW5lU3RhcnRPZmZzZXQpO1xuICBpZiAobGluZUVuZE9mZnNldCA9PT0gLTEpIHtcbiAgICBsaW5lRW5kT2Zmc2V0ID0gc3RyLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgbGluZS5cbiAgICBjb25zdCBuZXh0TGluZUVuZE9mZnNldCA9IHN0ci5pbmRleE9mKCdcXG4nLCBsaW5lRW5kT2Zmc2V0ICsgMSk7XG4gICAgbmV4dExpbmUgPSBuZXh0TGluZUVuZE9mZnNldCA9PT0gLTEgPyBzdHIuc2xpY2UobGluZUVuZE9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN0ci5zbGljZShsaW5lRW5kT2Zmc2V0LCBuZXh0TGluZUVuZE9mZnNldCk7XG4gICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgRU9MIGNoYXIocykuXG4gICAgbmV4dExpbmUgPSBuZXh0TGluZS5yZXBsYWNlKC9eXFxyP1xcbi8sICcnKS5yZXBsYWNlKC9cXHIkLywgJycpO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBwcmV2aW91cyBsaW5lLlxuICBpZiAocHJldkxpbmVTdGFydE9mZnNldCA+PSAwKSB7XG4gICAgcHJldkxpbmUgPSBzdHIuc2xpY2UocHJldkxpbmVTdGFydE9mZnNldCwgbGluZVN0YXJ0T2Zmc2V0KVxuICAgICAgICAucmVwbGFjZSgvXFxyP1xcbiQvLCAnJyk7IC8vIFN0cmlwIHRyYWlsaW5nIEVPTCBjaGFyKHMpLlxuICB9XG5cbiAgLy8gR2V0IHRoZSB0YXJnZXQgbGluZSwgc3RyaXBwaW5nIGEgdHJhaWxpbmcgY2FycmlhZ2UgcmV0dXJuIGlmIG5lY2Vzc2FyeS5cbiAgY29uc3QgbGluZSA9IHN0ci5zbGljZShsaW5lU3RhcnRPZmZzZXQsIGxpbmVFbmRPZmZzZXQpLnJlcGxhY2UoL1xcciQvLCAnJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBvZmZzZXQsXG4gICAgbGluZU51bSxcbiAgICBjb2xOdW0sXG4gICAgbGluZSxcbiAgICBwcmV2TGluZSxcbiAgICBuZXh0TGluZSxcbiAgICB0b1N0cmluZzogbGluZUFuZENvbHVtblRvTWVzc2FnZVxuICB9O1xufTtcblxuLy8gUmV0dXJuIGEgbmljZWx5LWZvcm1hdHRlZCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgbGluZSBhbmQgY29sdW1uIGZvciB0aGVcbi8vIGdpdmVuIG9mZnNldCBpbiBgc3RyYCBoaWdobGlnaHRpbmcgYHJhbmdlc2AuXG5leHBvcnRzLmdldExpbmVBbmRDb2x1bW5NZXNzYWdlID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQsIC4uLnJhbmdlcykge1xuICByZXR1cm4gZXhwb3J0cy5nZXRMaW5lQW5kQ29sdW1uKHN0ciwgb2Zmc2V0KS50b1N0cmluZyguLi5yYW5nZXMpO1xufTtcblxuZXhwb3J0cy51bmlxdWVJZCA9ICgoKSA9PiB7XG4gIGxldCBpZENvdW50ZXIgPSAwO1xuICByZXR1cm4gcHJlZml4ID0+ICcnICsgcHJlZml4ICsgaWRDb3VudGVyKys7XG59KSgpO1xuIiwiLyogZ2xvYmFsIF9fR0xPQkFMX09ITV9WRVJTSU9OX18gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBXaGVuIHJ1bm5pbmcgdW5kZXIgTm9kZSwgcmVhZCB0aGUgdmVyc2lvbiBmcm9tIHBhY2thZ2UuanNvbi4gRm9yIHRoZSBicm93c2VyLFxuLy8gdXNlIGEgc3BlY2lhbCBnbG9iYWwgdmFyaWFibGUgZGVmaW5lZCBpbiB0aGUgYnVpbGQgcHJvY2VzcyAoc2VlIHdlYnBhY2suY29uZmlnLmpzKS5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIF9fR0xPQkFMX09ITV9WRVJTSU9OX18gPT09ICdzdHJpbmcnXG4gICAgPyBfX0dMT0JBTF9PSE1fVkVSU0lPTl9fXG4gICAgOiByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuIiwiLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvdW5pY29kZS05LjAuMC5cbi8vIFRoZXNlIGFyZSBqdXN0IGNhdGVnb3JpZXMgdGhhdCBhcmUgdXNlZCBpbiBFUzUvRVMyMDE1LlxuLy8gVGhlIGZ1bGwgbGlzdCBvZiBVbmljb2RlIGNhdGVnb3JpZXMgaXMgaGVyZTogaHR0cDovL3d3dy5maWxlZm9ybWF0LmluZm8vaW5mby91bmljb2RlL2NhdGVnb3J5L2luZGV4Lmh0bS5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBMZXR0ZXJzXG4gIEx1OiAvW0EtWlxceEMwLVxceEQ2XFx4RDgtXFx4REVcXHUwMTAwXFx1MDEwMlxcdTAxMDRcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDEwRVxcdTAxMTBcXHUwMTEyXFx1MDExNFxcdTAxMTZcXHUwMTE4XFx1MDExQVxcdTAxMUNcXHUwMTFFXFx1MDEyMFxcdTAxMjJcXHUwMTI0XFx1MDEyNlxcdTAxMjhcXHUwMTJBXFx1MDEyQ1xcdTAxMkVcXHUwMTMwXFx1MDEzMlxcdTAxMzRcXHUwMTM2XFx1MDEzOVxcdTAxM0JcXHUwMTNEXFx1MDEzRlxcdTAxNDFcXHUwMTQzXFx1MDE0NVxcdTAxNDdcXHUwMTRBXFx1MDE0Q1xcdTAxNEVcXHUwMTUwXFx1MDE1MlxcdTAxNTRcXHUwMTU2XFx1MDE1OFxcdTAxNUFcXHUwMTVDXFx1MDE1RVxcdTAxNjBcXHUwMTYyXFx1MDE2NFxcdTAxNjZcXHUwMTY4XFx1MDE2QVxcdTAxNkNcXHUwMTZFXFx1MDE3MFxcdTAxNzJcXHUwMTc0XFx1MDE3NlxcdTAxNzhcXHUwMTc5XFx1MDE3QlxcdTAxN0RcXHUwMTgxXFx1MDE4MlxcdTAxODRcXHUwMTg2XFx1MDE4N1xcdTAxODktXFx1MDE4QlxcdTAxOEUtXFx1MDE5MVxcdTAxOTNcXHUwMTk0XFx1MDE5Ni1cXHUwMTk4XFx1MDE5Q1xcdTAxOURcXHUwMTlGXFx1MDFBMFxcdTAxQTJcXHUwMUE0XFx1MDFBNlxcdTAxQTdcXHUwMUE5XFx1MDFBQ1xcdTAxQUVcXHUwMUFGXFx1MDFCMS1cXHUwMUIzXFx1MDFCNVxcdTAxQjdcXHUwMUI4XFx1MDFCQ1xcdTAxQzRcXHUwMUM3XFx1MDFDQVxcdTAxQ0RcXHUwMUNGXFx1MDFEMVxcdTAxRDNcXHUwMUQ1XFx1MDFEN1xcdTAxRDlcXHUwMURCXFx1MDFERVxcdTAxRTBcXHUwMUUyXFx1MDFFNFxcdTAxRTZcXHUwMUU4XFx1MDFFQVxcdTAxRUNcXHUwMUVFXFx1MDFGMVxcdTAxRjRcXHUwMUY2LVxcdTAxRjhcXHUwMUZBXFx1MDFGQ1xcdTAxRkVcXHUwMjAwXFx1MDIwMlxcdTAyMDRcXHUwMjA2XFx1MDIwOFxcdTAyMEFcXHUwMjBDXFx1MDIwRVxcdTAyMTBcXHUwMjEyXFx1MDIxNFxcdTAyMTZcXHUwMjE4XFx1MDIxQVxcdTAyMUNcXHUwMjFFXFx1MDIyMFxcdTAyMjJcXHUwMjI0XFx1MDIyNlxcdTAyMjhcXHUwMjJBXFx1MDIyQ1xcdTAyMkVcXHUwMjMwXFx1MDIzMlxcdTAyM0FcXHUwMjNCXFx1MDIzRFxcdTAyM0VcXHUwMjQxXFx1MDI0My1cXHUwMjQ2XFx1MDI0OFxcdTAyNEFcXHUwMjRDXFx1MDI0RVxcdTAzNzBcXHUwMzcyXFx1MDM3NlxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEVcXHUwMzhGXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0FCXFx1MDNDRlxcdTAzRDItXFx1MDNENFxcdTAzRDhcXHUwM0RBXFx1MDNEQ1xcdTAzREVcXHUwM0UwXFx1MDNFMlxcdTAzRTRcXHUwM0U2XFx1MDNFOFxcdTAzRUFcXHUwM0VDXFx1MDNFRVxcdTAzRjRcXHUwM0Y3XFx1MDNGOVxcdTAzRkFcXHUwM0ZELVxcdTA0MkZcXHUwNDYwXFx1MDQ2MlxcdTA0NjRcXHUwNDY2XFx1MDQ2OFxcdTA0NkFcXHUwNDZDXFx1MDQ2RVxcdTA0NzBcXHUwNDcyXFx1MDQ3NFxcdTA0NzZcXHUwNDc4XFx1MDQ3QVxcdTA0N0NcXHUwNDdFXFx1MDQ4MFxcdTA0OEFcXHUwNDhDXFx1MDQ4RVxcdTA0OTBcXHUwNDkyXFx1MDQ5NFxcdTA0OTZcXHUwNDk4XFx1MDQ5QVxcdTA0OUNcXHUwNDlFXFx1MDRBMFxcdTA0QTJcXHUwNEE0XFx1MDRBNlxcdTA0QThcXHUwNEFBXFx1MDRBQ1xcdTA0QUVcXHUwNEIwXFx1MDRCMlxcdTA0QjRcXHUwNEI2XFx1MDRCOFxcdTA0QkFcXHUwNEJDXFx1MDRCRVxcdTA0QzBcXHUwNEMxXFx1MDRDM1xcdTA0QzVcXHUwNEM3XFx1MDRDOVxcdTA0Q0JcXHUwNENEXFx1MDREMFxcdTA0RDJcXHUwNEQ0XFx1MDRENlxcdTA0RDhcXHUwNERBXFx1MDREQ1xcdTA0REVcXHUwNEUwXFx1MDRFMlxcdTA0RTRcXHUwNEU2XFx1MDRFOFxcdTA0RUFcXHUwNEVDXFx1MDRFRVxcdTA0RjBcXHUwNEYyXFx1MDRGNFxcdTA0RjZcXHUwNEY4XFx1MDRGQVxcdTA0RkNcXHUwNEZFXFx1MDUwMFxcdTA1MDJcXHUwNTA0XFx1MDUwNlxcdTA1MDhcXHUwNTBBXFx1MDUwQ1xcdTA1MEVcXHUwNTEwXFx1MDUxMlxcdTA1MTRcXHUwNTE2XFx1MDUxOFxcdTA1MUFcXHUwNTFDXFx1MDUxRVxcdTA1MjBcXHUwNTIyXFx1MDUyNFxcdTA1MjZcXHUwNTI4XFx1MDUyQVxcdTA1MkNcXHUwNTJFXFx1MDUzMS1cXHUwNTU2XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxM0EwLVxcdTEzRjVcXHUxRTAwXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MUUwOFxcdTFFMEFcXHUxRTBDXFx1MUUwRVxcdTFFMTBcXHUxRTEyXFx1MUUxNFxcdTFFMTZcXHUxRTE4XFx1MUUxQVxcdTFFMUNcXHUxRTFFXFx1MUUyMFxcdTFFMjJcXHUxRTI0XFx1MUUyNlxcdTFFMjhcXHUxRTJBXFx1MUUyQ1xcdTFFMkVcXHUxRTMwXFx1MUUzMlxcdTFFMzRcXHUxRTM2XFx1MUUzOFxcdTFFM0FcXHUxRTNDXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MUU0NFxcdTFFNDZcXHUxRTQ4XFx1MUU0QVxcdTFFNENcXHUxRTRFXFx1MUU1MFxcdTFFNTJcXHUxRTU0XFx1MUU1NlxcdTFFNThcXHUxRTVBXFx1MUU1Q1xcdTFFNUVcXHUxRTYwXFx1MUU2MlxcdTFFNjRcXHUxRTY2XFx1MUU2OFxcdTFFNkFcXHUxRTZDXFx1MUU2RVxcdTFFNzBcXHUxRTcyXFx1MUU3NFxcdTFFNzZcXHUxRTc4XFx1MUU3QVxcdTFFN0NcXHUxRTdFXFx1MUU4MFxcdTFFODJcXHUxRTg0XFx1MUU4NlxcdTFFODhcXHUxRThBXFx1MUU4Q1xcdTFFOEVcXHUxRTkwXFx1MUU5MlxcdTFFOTRcXHUxRTlFXFx1MUVBMFxcdTFFQTJcXHUxRUE0XFx1MUVBNlxcdTFFQThcXHUxRUFBXFx1MUVBQ1xcdTFFQUVcXHUxRUIwXFx1MUVCMlxcdTFFQjRcXHUxRUI2XFx1MUVCOFxcdTFFQkFcXHUxRUJDXFx1MUVCRVxcdTFFQzBcXHUxRUMyXFx1MUVDNFxcdTFFQzZcXHUxRUM4XFx1MUVDQVxcdTFFQ0NcXHUxRUNFXFx1MUVEMFxcdTFFRDJcXHUxRUQ0XFx1MUVENlxcdTFFRDhcXHUxRURBXFx1MUVEQ1xcdTFFREVcXHUxRUUwXFx1MUVFMlxcdTFFRTRcXHUxRUU2XFx1MUVFOFxcdTFFRUFcXHUxRUVDXFx1MUVFRVxcdTFFRjBcXHUxRUYyXFx1MUVGNFxcdTFFRjZcXHUxRUY4XFx1MUVGQVxcdTFFRkNcXHUxRUZFXFx1MUYwOC1cXHUxRjBGXFx1MUYxOC1cXHUxRjFEXFx1MUYyOC1cXHUxRjJGXFx1MUYzOC1cXHUxRjNGXFx1MUY0OC1cXHUxRjREXFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1RlxcdTFGNjgtXFx1MUY2RlxcdTFGQjgtXFx1MUZCQlxcdTFGQzgtXFx1MUZDQlxcdTFGRDgtXFx1MUZEQlxcdTFGRTgtXFx1MUZFQ1xcdTFGRjgtXFx1MUZGQlxcdTIxMDJcXHUyMTA3XFx1MjEwQi1cXHUyMTBEXFx1MjExMC1cXHUyMTEyXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMzAtXFx1MjEzM1xcdTIxM0VcXHUyMTNGXFx1MjE0NVxcdTIxODNcXHUyQzAwLVxcdTJDMkVcXHUyQzYwXFx1MkM2Mi1cXHUyQzY0XFx1MkM2N1xcdTJDNjlcXHUyQzZCXFx1MkM2RC1cXHUyQzcwXFx1MkM3MlxcdTJDNzVcXHUyQzdFLVxcdTJDODBcXHUyQzgyXFx1MkM4NFxcdTJDODZcXHUyQzg4XFx1MkM4QVxcdTJDOENcXHUyQzhFXFx1MkM5MFxcdTJDOTJcXHUyQzk0XFx1MkM5NlxcdTJDOThcXHUyQzlBXFx1MkM5Q1xcdTJDOUVcXHUyQ0EwXFx1MkNBMlxcdTJDQTRcXHUyQ0E2XFx1MkNBOFxcdTJDQUFcXHUyQ0FDXFx1MkNBRVxcdTJDQjBcXHUyQ0IyXFx1MkNCNFxcdTJDQjZcXHUyQ0I4XFx1MkNCQVxcdTJDQkNcXHUyQ0JFXFx1MkNDMFxcdTJDQzJcXHUyQ0M0XFx1MkNDNlxcdTJDQzhcXHUyQ0NBXFx1MkNDQ1xcdTJDQ0VcXHUyQ0QwXFx1MkNEMlxcdTJDRDRcXHUyQ0Q2XFx1MkNEOFxcdTJDREFcXHUyQ0RDXFx1MkNERVxcdTJDRTBcXHUyQ0UyXFx1MkNFQlxcdTJDRURcXHUyQ0YyXFx1QTY0MFxcdUE2NDJcXHVBNjQ0XFx1QTY0NlxcdUE2NDhcXHVBNjRBXFx1QTY0Q1xcdUE2NEVcXHVBNjUwXFx1QTY1MlxcdUE2NTRcXHVBNjU2XFx1QTY1OFxcdUE2NUFcXHVBNjVDXFx1QTY1RVxcdUE2NjBcXHVBNjYyXFx1QTY2NFxcdUE2NjZcXHVBNjY4XFx1QTY2QVxcdUE2NkNcXHVBNjgwXFx1QTY4MlxcdUE2ODRcXHVBNjg2XFx1QTY4OFxcdUE2OEFcXHVBNjhDXFx1QTY4RVxcdUE2OTBcXHVBNjkyXFx1QTY5NFxcdUE2OTZcXHVBNjk4XFx1QTY5QVxcdUE3MjJcXHVBNzI0XFx1QTcyNlxcdUE3MjhcXHVBNzJBXFx1QTcyQ1xcdUE3MkVcXHVBNzMyXFx1QTczNFxcdUE3MzZcXHVBNzM4XFx1QTczQVxcdUE3M0NcXHVBNzNFXFx1QTc0MFxcdUE3NDJcXHVBNzQ0XFx1QTc0NlxcdUE3NDhcXHVBNzRBXFx1QTc0Q1xcdUE3NEVcXHVBNzUwXFx1QTc1MlxcdUE3NTRcXHVBNzU2XFx1QTc1OFxcdUE3NUFcXHVBNzVDXFx1QTc1RVxcdUE3NjBcXHVBNzYyXFx1QTc2NFxcdUE3NjZcXHVBNzY4XFx1QTc2QVxcdUE3NkNcXHVBNzZFXFx1QTc3OVxcdUE3N0JcXHVBNzdEXFx1QTc3RVxcdUE3ODBcXHVBNzgyXFx1QTc4NFxcdUE3ODZcXHVBNzhCXFx1QTc4RFxcdUE3OTBcXHVBNzkyXFx1QTc5NlxcdUE3OThcXHVBNzlBXFx1QTc5Q1xcdUE3OUVcXHVBN0EwXFx1QTdBMlxcdUE3QTRcXHVBN0E2XFx1QTdBOFxcdUE3QUEtXFx1QTdBRVxcdUE3QjAtXFx1QTdCNFxcdUE3QjZcXHVGRjIxLVxcdUZGM0FdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzI3XFx1RENCMC1cXHVEQ0QzXXxcXHVEODAzW1xcdURDODAtXFx1RENCMl18XFx1RDgwNltcXHVEQ0EwLVxcdURDQkZdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzE5XFx1REMzNC1cXHVEQzREXFx1REM2OC1cXHVEQzgxXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I1XFx1RENEMC1cXHVEQ0U5XFx1REQwNFxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDM4XFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDZDLVxcdUREODVcXHVEREEwLVxcdUREQjlcXHVEREQ0LVxcdURERURcXHVERTA4LVxcdURFMjFcXHVERTNDLVxcdURFNTVcXHVERTcwLVxcdURFODlcXHVERUE4LVxcdURFQzBcXHVERUUyLVxcdURFRkFcXHVERjFDLVxcdURGMzRcXHVERjU2LVxcdURGNkVcXHVERjkwLVxcdURGQThcXHVERkNBXXxcXHVEODNBW1xcdUREMDAtXFx1REQyMV0vLFxuICBMbDogL1thLXpcXHhCNVxceERGLVxceEY2XFx4RjgtXFx4RkZcXHUwMTAxXFx1MDEwM1xcdTAxMDVcXHUwMTA3XFx1MDEwOVxcdTAxMEJcXHUwMTBEXFx1MDEwRlxcdTAxMTFcXHUwMTEzXFx1MDExNVxcdTAxMTdcXHUwMTE5XFx1MDExQlxcdTAxMURcXHUwMTFGXFx1MDEyMVxcdTAxMjNcXHUwMTI1XFx1MDEyN1xcdTAxMjlcXHUwMTJCXFx1MDEyRFxcdTAxMkZcXHUwMTMxXFx1MDEzM1xcdTAxMzVcXHUwMTM3XFx1MDEzOFxcdTAxM0FcXHUwMTNDXFx1MDEzRVxcdTAxNDBcXHUwMTQyXFx1MDE0NFxcdTAxNDZcXHUwMTQ4XFx1MDE0OVxcdTAxNEJcXHUwMTREXFx1MDE0RlxcdTAxNTFcXHUwMTUzXFx1MDE1NVxcdTAxNTdcXHUwMTU5XFx1MDE1QlxcdTAxNURcXHUwMTVGXFx1MDE2MVxcdTAxNjNcXHUwMTY1XFx1MDE2N1xcdTAxNjlcXHUwMTZCXFx1MDE2RFxcdTAxNkZcXHUwMTcxXFx1MDE3M1xcdTAxNzVcXHUwMTc3XFx1MDE3QVxcdTAxN0NcXHUwMTdFLVxcdTAxODBcXHUwMTgzXFx1MDE4NVxcdTAxODhcXHUwMThDXFx1MDE4RFxcdTAxOTJcXHUwMTk1XFx1MDE5OS1cXHUwMTlCXFx1MDE5RVxcdTAxQTFcXHUwMUEzXFx1MDFBNVxcdTAxQThcXHUwMUFBXFx1MDFBQlxcdTAxQURcXHUwMUIwXFx1MDFCNFxcdTAxQjZcXHUwMUI5XFx1MDFCQVxcdTAxQkQtXFx1MDFCRlxcdTAxQzZcXHUwMUM5XFx1MDFDQ1xcdTAxQ0VcXHUwMUQwXFx1MDFEMlxcdTAxRDRcXHUwMUQ2XFx1MDFEOFxcdTAxREFcXHUwMURDXFx1MDFERFxcdTAxREZcXHUwMUUxXFx1MDFFM1xcdTAxRTVcXHUwMUU3XFx1MDFFOVxcdTAxRUJcXHUwMUVEXFx1MDFFRlxcdTAxRjBcXHUwMUYzXFx1MDFGNVxcdTAxRjlcXHUwMUZCXFx1MDFGRFxcdTAxRkZcXHUwMjAxXFx1MDIwM1xcdTAyMDVcXHUwMjA3XFx1MDIwOVxcdTAyMEJcXHUwMjBEXFx1MDIwRlxcdTAyMTFcXHUwMjEzXFx1MDIxNVxcdTAyMTdcXHUwMjE5XFx1MDIxQlxcdTAyMURcXHUwMjFGXFx1MDIyMVxcdTAyMjNcXHUwMjI1XFx1MDIyN1xcdTAyMjlcXHUwMjJCXFx1MDIyRFxcdTAyMkZcXHUwMjMxXFx1MDIzMy1cXHUwMjM5XFx1MDIzQ1xcdTAyM0ZcXHUwMjQwXFx1MDI0MlxcdTAyNDdcXHUwMjQ5XFx1MDI0QlxcdTAyNERcXHUwMjRGLVxcdTAyOTNcXHUwMjk1LVxcdTAyQUZcXHUwMzcxXFx1MDM3M1xcdTAzNzdcXHUwMzdCLVxcdTAzN0RcXHUwMzkwXFx1MDNBQy1cXHUwM0NFXFx1MDNEMFxcdTAzRDFcXHUwM0Q1LVxcdTAzRDdcXHUwM0Q5XFx1MDNEQlxcdTAzRERcXHUwM0RGXFx1MDNFMVxcdTAzRTNcXHUwM0U1XFx1MDNFN1xcdTAzRTlcXHUwM0VCXFx1MDNFRFxcdTAzRUYtXFx1MDNGM1xcdTAzRjVcXHUwM0Y4XFx1MDNGQlxcdTAzRkNcXHUwNDMwLVxcdTA0NUZcXHUwNDYxXFx1MDQ2M1xcdTA0NjVcXHUwNDY3XFx1MDQ2OVxcdTA0NkJcXHUwNDZEXFx1MDQ2RlxcdTA0NzFcXHUwNDczXFx1MDQ3NVxcdTA0NzdcXHUwNDc5XFx1MDQ3QlxcdTA0N0RcXHUwNDdGXFx1MDQ4MVxcdTA0OEJcXHUwNDhEXFx1MDQ4RlxcdTA0OTFcXHUwNDkzXFx1MDQ5NVxcdTA0OTdcXHUwNDk5XFx1MDQ5QlxcdTA0OURcXHUwNDlGXFx1MDRBMVxcdTA0QTNcXHUwNEE1XFx1MDRBN1xcdTA0QTlcXHUwNEFCXFx1MDRBRFxcdTA0QUZcXHUwNEIxXFx1MDRCM1xcdTA0QjVcXHUwNEI3XFx1MDRCOVxcdTA0QkJcXHUwNEJEXFx1MDRCRlxcdTA0QzJcXHUwNEM0XFx1MDRDNlxcdTA0QzhcXHUwNENBXFx1MDRDQ1xcdTA0Q0VcXHUwNENGXFx1MDREMVxcdTA0RDNcXHUwNEQ1XFx1MDREN1xcdTA0RDlcXHUwNERCXFx1MDRERFxcdTA0REZcXHUwNEUxXFx1MDRFM1xcdTA0RTVcXHUwNEU3XFx1MDRFOVxcdTA0RUJcXHUwNEVEXFx1MDRFRlxcdTA0RjFcXHUwNEYzXFx1MDRGNVxcdTA0RjdcXHUwNEY5XFx1MDRGQlxcdTA0RkRcXHUwNEZGXFx1MDUwMVxcdTA1MDNcXHUwNTA1XFx1MDUwN1xcdTA1MDlcXHUwNTBCXFx1MDUwRFxcdTA1MEZcXHUwNTExXFx1MDUxM1xcdTA1MTVcXHUwNTE3XFx1MDUxOVxcdTA1MUJcXHUwNTFEXFx1MDUxRlxcdTA1MjFcXHUwNTIzXFx1MDUyNVxcdTA1MjdcXHUwNTI5XFx1MDUyQlxcdTA1MkRcXHUwNTJGXFx1MDU2MS1cXHUwNTg3XFx1MTNGOC1cXHUxM0ZEXFx1MUM4MC1cXHUxQzg4XFx1MUQwMC1cXHUxRDJCXFx1MUQ2Qi1cXHUxRDc3XFx1MUQ3OS1cXHUxRDlBXFx1MUUwMVxcdTFFMDNcXHUxRTA1XFx1MUUwN1xcdTFFMDlcXHUxRTBCXFx1MUUwRFxcdTFFMEZcXHUxRTExXFx1MUUxM1xcdTFFMTVcXHUxRTE3XFx1MUUxOVxcdTFFMUJcXHUxRTFEXFx1MUUxRlxcdTFFMjFcXHUxRTIzXFx1MUUyNVxcdTFFMjdcXHUxRTI5XFx1MUUyQlxcdTFFMkRcXHUxRTJGXFx1MUUzMVxcdTFFMzNcXHUxRTM1XFx1MUUzN1xcdTFFMzlcXHUxRTNCXFx1MUUzRFxcdTFFM0ZcXHUxRTQxXFx1MUU0M1xcdTFFNDVcXHUxRTQ3XFx1MUU0OVxcdTFFNEJcXHUxRTREXFx1MUU0RlxcdTFFNTFcXHUxRTUzXFx1MUU1NVxcdTFFNTdcXHUxRTU5XFx1MUU1QlxcdTFFNURcXHUxRTVGXFx1MUU2MVxcdTFFNjNcXHUxRTY1XFx1MUU2N1xcdTFFNjlcXHUxRTZCXFx1MUU2RFxcdTFFNkZcXHUxRTcxXFx1MUU3M1xcdTFFNzVcXHUxRTc3XFx1MUU3OVxcdTFFN0JcXHUxRTdEXFx1MUU3RlxcdTFFODFcXHUxRTgzXFx1MUU4NVxcdTFFODdcXHUxRTg5XFx1MUU4QlxcdTFFOERcXHUxRThGXFx1MUU5MVxcdTFFOTNcXHUxRTk1LVxcdTFFOURcXHUxRTlGXFx1MUVBMVxcdTFFQTNcXHUxRUE1XFx1MUVBN1xcdTFFQTlcXHUxRUFCXFx1MUVBRFxcdTFFQUZcXHUxRUIxXFx1MUVCM1xcdTFFQjVcXHUxRUI3XFx1MUVCOVxcdTFFQkJcXHUxRUJEXFx1MUVCRlxcdTFFQzFcXHUxRUMzXFx1MUVDNVxcdTFFQzdcXHUxRUM5XFx1MUVDQlxcdTFFQ0RcXHUxRUNGXFx1MUVEMVxcdTFFRDNcXHUxRUQ1XFx1MUVEN1xcdTFFRDlcXHUxRURCXFx1MUVERFxcdTFFREZcXHUxRUUxXFx1MUVFM1xcdTFFRTVcXHUxRUU3XFx1MUVFOVxcdTFFRUJcXHUxRUVEXFx1MUVFRlxcdTFFRjFcXHUxRUYzXFx1MUVGNVxcdTFFRjdcXHUxRUY5XFx1MUVGQlxcdTFFRkRcXHUxRUZGLVxcdTFGMDdcXHUxRjEwLVxcdTFGMTVcXHUxRjIwLVxcdTFGMjdcXHUxRjMwLVxcdTFGMzdcXHUxRjQwLVxcdTFGNDVcXHUxRjUwLVxcdTFGNTdcXHUxRjYwLVxcdTFGNjdcXHUxRjcwLVxcdTFGN0RcXHUxRjgwLVxcdTFGODdcXHUxRjkwLVxcdTFGOTdcXHUxRkEwLVxcdTFGQTdcXHUxRkIwLVxcdTFGQjRcXHUxRkI2XFx1MUZCN1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2XFx1MUZDN1xcdTFGRDAtXFx1MUZEM1xcdTFGRDZcXHUxRkQ3XFx1MUZFMC1cXHUxRkU3XFx1MUZGMi1cXHUxRkY0XFx1MUZGNlxcdTFGRjdcXHUyMTBBXFx1MjEwRVxcdTIxMEZcXHUyMTEzXFx1MjEyRlxcdTIxMzRcXHUyMTM5XFx1MjEzQ1xcdTIxM0RcXHUyMTQ2LVxcdTIxNDlcXHUyMTRFXFx1MjE4NFxcdTJDMzAtXFx1MkM1RVxcdTJDNjFcXHUyQzY1XFx1MkM2NlxcdTJDNjhcXHUyQzZBXFx1MkM2Q1xcdTJDNzFcXHUyQzczXFx1MkM3NFxcdTJDNzYtXFx1MkM3QlxcdTJDODFcXHUyQzgzXFx1MkM4NVxcdTJDODdcXHUyQzg5XFx1MkM4QlxcdTJDOERcXHUyQzhGXFx1MkM5MVxcdTJDOTNcXHUyQzk1XFx1MkM5N1xcdTJDOTlcXHUyQzlCXFx1MkM5RFxcdTJDOUZcXHUyQ0ExXFx1MkNBM1xcdTJDQTVcXHUyQ0E3XFx1MkNBOVxcdTJDQUJcXHUyQ0FEXFx1MkNBRlxcdTJDQjFcXHUyQ0IzXFx1MkNCNVxcdTJDQjdcXHUyQ0I5XFx1MkNCQlxcdTJDQkRcXHUyQ0JGXFx1MkNDMVxcdTJDQzNcXHUyQ0M1XFx1MkNDN1xcdTJDQzlcXHUyQ0NCXFx1MkNDRFxcdTJDQ0ZcXHUyQ0QxXFx1MkNEM1xcdTJDRDVcXHUyQ0Q3XFx1MkNEOVxcdTJDREJcXHUyQ0REXFx1MkNERlxcdTJDRTFcXHUyQ0UzXFx1MkNFNFxcdTJDRUNcXHUyQ0VFXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1QTY0MVxcdUE2NDNcXHVBNjQ1XFx1QTY0N1xcdUE2NDlcXHVBNjRCXFx1QTY0RFxcdUE2NEZcXHVBNjUxXFx1QTY1M1xcdUE2NTVcXHVBNjU3XFx1QTY1OVxcdUE2NUJcXHVBNjVEXFx1QTY1RlxcdUE2NjFcXHVBNjYzXFx1QTY2NVxcdUE2NjdcXHVBNjY5XFx1QTY2QlxcdUE2NkRcXHVBNjgxXFx1QTY4M1xcdUE2ODVcXHVBNjg3XFx1QTY4OVxcdUE2OEJcXHVBNjhEXFx1QTY4RlxcdUE2OTFcXHVBNjkzXFx1QTY5NVxcdUE2OTdcXHVBNjk5XFx1QTY5QlxcdUE3MjNcXHVBNzI1XFx1QTcyN1xcdUE3MjlcXHVBNzJCXFx1QTcyRFxcdUE3MkYtXFx1QTczMVxcdUE3MzNcXHVBNzM1XFx1QTczN1xcdUE3MzlcXHVBNzNCXFx1QTczRFxcdUE3M0ZcXHVBNzQxXFx1QTc0M1xcdUE3NDVcXHVBNzQ3XFx1QTc0OVxcdUE3NEJcXHVBNzREXFx1QTc0RlxcdUE3NTFcXHVBNzUzXFx1QTc1NVxcdUE3NTdcXHVBNzU5XFx1QTc1QlxcdUE3NURcXHVBNzVGXFx1QTc2MVxcdUE3NjNcXHVBNzY1XFx1QTc2N1xcdUE3NjlcXHVBNzZCXFx1QTc2RFxcdUE3NkZcXHVBNzcxLVxcdUE3NzhcXHVBNzdBXFx1QTc3Q1xcdUE3N0ZcXHVBNzgxXFx1QTc4M1xcdUE3ODVcXHVBNzg3XFx1QTc4Q1xcdUE3OEVcXHVBNzkxXFx1QTc5My1cXHVBNzk1XFx1QTc5N1xcdUE3OTlcXHVBNzlCXFx1QTc5RFxcdUE3OUZcXHVBN0ExXFx1QTdBM1xcdUE3QTVcXHVBN0E3XFx1QTdBOVxcdUE3QjVcXHVBN0I3XFx1QTdGQVxcdUFCMzAtXFx1QUI1QVxcdUFCNjAtXFx1QUI2NVxcdUFCNzAtXFx1QUJCRlxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZGNDEtXFx1RkY1QV18XFx1RDgwMVtcXHVEQzI4LVxcdURDNEZcXHVEQ0Q4LVxcdURDRkJdfFxcdUQ4MDNbXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA2W1xcdURDQzAtXFx1RENERl18XFx1RDgzNVtcXHVEQzFBLVxcdURDMzNcXHVEQzRFLVxcdURDNTRcXHVEQzU2LVxcdURDNjdcXHVEQzgyLVxcdURDOUJcXHVEQ0I2LVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVEQ0NGXFx1RENFQS1cXHVERDAzXFx1REQxRS1cXHVERDM3XFx1REQ1Mi1cXHVERDZCXFx1REQ4Ni1cXHVERDlGXFx1RERCQS1cXHVEREQzXFx1RERFRS1cXHVERTA3XFx1REUyMi1cXHVERTNCXFx1REU1Ni1cXHVERTZGXFx1REU4QS1cXHVERUE1XFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUUxXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjFCXFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjU1XFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERjhGXFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkM5XFx1REZDQl18XFx1RDgzQVtcXHVERDIyLVxcdURENDNdLyxcbiAgTHQ6IC9bXFx1MDFDNVxcdTAxQzhcXHUwMUNCXFx1MDFGMlxcdTFGODgtXFx1MUY4RlxcdTFGOTgtXFx1MUY5RlxcdTFGQTgtXFx1MUZBRlxcdTFGQkNcXHUxRkNDXFx1MUZGQ10vLFxuICBMbTogL1tcXHUwMkIwLVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzRcXHUwMzdBXFx1MDU1OVxcdTA2NDBcXHUwNkU1XFx1MDZFNlxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA5NzFcXHUwRTQ2XFx1MEVDNlxcdTEwRkNcXHUxN0Q3XFx1MTg0M1xcdTFBQTdcXHUxQzc4LVxcdTFDN0RcXHUxRDJDLVxcdTFENkFcXHUxRDc4XFx1MUQ5Qi1cXHUxREJGXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyQzdDXFx1MkM3RFxcdTJENkZcXHUyRTJGXFx1MzAwNVxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDlEXFx1MzA5RVxcdTMwRkMtXFx1MzBGRVxcdUEwMTVcXHVBNEY4LVxcdUE0RkRcXHVBNjBDXFx1QTY3RlxcdUE2OUNcXHVBNjlEXFx1QTcxNy1cXHVBNzFGXFx1QTc3MFxcdUE3ODhcXHVBN0Y4XFx1QTdGOVxcdUE5Q0ZcXHVBOUU2XFx1QUE3MFxcdUFBRERcXHVBQUYzXFx1QUFGNFxcdUFCNUMtXFx1QUI1RlxcdUZGNzBcXHVGRjlFXFx1RkY5Rl18XFx1RDgxQVtcXHVERjQwLVxcdURGNDNdfFxcdUQ4MUJbXFx1REY5My1cXHVERjlGXFx1REZFMF0vLFxuICBMbzogL1tcXHhBQVxceEJBXFx1MDFCQlxcdTAxQzAtXFx1MDFDM1xcdTAyOTRcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2M0ZcXHUwNjQxLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA4MDAtXFx1MDgxNVxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3Mi1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ1XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEQwLVxcdTEwRkFcXHUxMEZELVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RENcXHUxODIwLVxcdTE4NDJcXHUxODQ0LVxcdTE4NzdcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDNzdcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTIxMzUtXFx1MjEzOFxcdTJEMzAtXFx1MkQ2N1xcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDZcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUEwMTRcXHVBMDE2LVxcdUE0OENcXHVBNEQwLVxcdUE0RjdcXHVBNTAwLVxcdUE2MEJcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NkVcXHVBNkEwLVxcdUE2RTVcXHVBNzhGXFx1QTdGN1xcdUE3RkItXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlFMC1cXHVBOUU0XFx1QTlFNy1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTZGXFx1QUE3MS1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQlxcdUFBRENcXHVBQUUwLVxcdUFBRUFcXHVBQUYyXFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkY2Ni1cXHVGRjZGXFx1RkY3MS1cXHVGRjlEXFx1RkZBMC1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjQwXFx1REY0Mi1cXHVERjQ5XFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXXxcXHVEODAxW1xcdURDNTAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXXxcXHVEODIxW1xcdURDMDAtXFx1REZFQ118XFx1RDgyMltcXHVEQzAwLVxcdURFRjJdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcblxuICAvLyBOdW1iZXJzXG4gIE5sOiAvW1xcdTE2RUUtXFx1MTZGMFxcdTIxNjAtXFx1MjE4MlxcdTIxODUtXFx1MjE4OFxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0FcXHVBNkU2LVxcdUE2RUZdfFxcdUQ4MDBbXFx1REQ0MC1cXHVERDc0XFx1REY0MVxcdURGNEFcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXS8sXG4gIE5kOiAvWzAtOVxcdTA2NjAtXFx1MDY2OVxcdTA2RjAtXFx1MDZGOVxcdTA3QzAtXFx1MDdDOVxcdTA5NjYtXFx1MDk2RlxcdTA5RTYtXFx1MDlFRlxcdTBBNjYtXFx1MEE2RlxcdTBBRTYtXFx1MEFFRlxcdTBCNjYtXFx1MEI2RlxcdTBCRTYtXFx1MEJFRlxcdTBDNjYtXFx1MEM2RlxcdTBDRTYtXFx1MENFRlxcdTBENjYtXFx1MEQ2RlxcdTBERTYtXFx1MERFRlxcdTBFNTAtXFx1MEU1OVxcdTBFRDAtXFx1MEVEOVxcdTBGMjAtXFx1MEYyOVxcdTEwNDAtXFx1MTA0OVxcdTEwOTAtXFx1MTA5OVxcdTE3RTAtXFx1MTdFOVxcdTE4MTAtXFx1MTgxOVxcdTE5NDYtXFx1MTk0RlxcdTE5RDAtXFx1MTlEOVxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFCNTAtXFx1MUI1OVxcdTFCQjAtXFx1MUJCOVxcdTFDNDAtXFx1MUM0OVxcdTFDNTAtXFx1MUM1OVxcdUE2MjAtXFx1QTYyOVxcdUE4RDAtXFx1QThEOVxcdUE5MDAtXFx1QTkwOVxcdUE5RDAtXFx1QTlEOVxcdUE5RjAtXFx1QTlGOVxcdUFBNTAtXFx1QUE1OVxcdUFCRjAtXFx1QUJGOVxcdUZGMTAtXFx1RkYxOV18XFx1RDgwMVtcXHVEQ0EwLVxcdURDQTldfFxcdUQ4MDRbXFx1REM2Ni1cXHVEQzZGXFx1RENGMC1cXHVEQ0Y5XFx1REQzNi1cXHVERDNGXFx1REREMC1cXHVEREQ5XFx1REVGMC1cXHVERUY5XXxbXFx1RDgwNVxcdUQ4MDddW1xcdURDNTAtXFx1REM1OVxcdURDRDAtXFx1RENEOVxcdURFNTAtXFx1REU1OVxcdURFQzAtXFx1REVDOVxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0UwLVxcdURDRTldfFxcdUQ4MUFbXFx1REU2MC1cXHVERTY5XFx1REY1MC1cXHVERjU5XXxcXHVEODM1W1xcdURGQ0UtXFx1REZGRl18XFx1RDgzQVtcXHVERDUwLVxcdURENTldLyxcblxuICAvLyBNYXJrc1xuICBNbjogL1tcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUUyXFx1MDlFM1xcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQjAxXFx1MEIzQ1xcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NlxcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQzBcXHUwQkNEXFx1MEMwMFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0UyXFx1MENFM1xcdTBEMDFcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ2MlxcdTBENjNcXHUwRENBXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjAzXFx1MUIzNFxcdTFCMzYtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjVcXHUxREZCLVxcdTFERkZcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRFxcdTMwOTlcXHUzMDlBXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDQS1cXHVERENDXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0NcXHVERjQwXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNl18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY4Ri1cXHVERjkyXXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjctXFx1REQ2OVxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQV18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS8sXG4gIE1jOiAvW1xcdTA5MDMtXFx1MDkwM118W1xcdTA5M0UtXFx1MDk0MF18W1xcdTA5NDktXFx1MDk0Q118W1xcdTA5ODItXFx1MDk4M118W1xcdTA5QkUtXFx1MDlDMF18W1xcdTA5QzctXFx1MDlDOF18W1xcdTA5Q0ItXFx1MDlDQ118W1xcdTA5RDctXFx1MDlEN118W1xcdTBBM0UtXFx1MEE0MF18W1xcdTBBODMtXFx1MEE4M118W1xcdTBBQkUtXFx1MEFDMF18W1xcdTBBQzktXFx1MEFDOV18W1xcdTBBQ0ItXFx1MEFDQ118W1xcdTBCMDItXFx1MEIwM118W1xcdTBCM0UtXFx1MEIzRV18W1xcdTBCNDAtXFx1MEI0MF18W1xcdTBCNDctXFx1MEI0OF18W1xcdTBCNEItXFx1MEI0Q118W1xcdTBCNTctXFx1MEI1N118W1xcdTBCODMtXFx1MEI4M118W1xcdTBCQkUtXFx1MEJCRl18W1xcdTBCQzEtXFx1MEJDMl18W1xcdTBCQzYtXFx1MEJDOF18W1xcdTBCQ0EtXFx1MEJDQ118W1xcdTBCRDctXFx1MEJEN118W1xcdTBDMDEtXFx1MEMwM118W1xcdTBDNDEtXFx1MEM0NF18W1xcdTBDODItXFx1MEM4M118W1xcdTBDQkUtXFx1MENCRV18W1xcdTBDQzAtXFx1MENDNF18W1xcdTBDQzctXFx1MENDOF18W1xcdTBDQ0EtXFx1MENDQl18W1xcdTBDRDUtXFx1MENENl18W1xcdTBEMDItXFx1MEQwM118W1xcdTBEM0UtXFx1MEQ0MF18W1xcdTBENDYtXFx1MEQ0OF18W1xcdTBENEEtXFx1MEQ0Q118W1xcdTBENTctXFx1MEQ1N118W1xcdTBGM0UtXFx1MEYzRl18W1xcdTBGN0YtXFx1MEY3Rl0vLFxuXG4gIC8vIFB1bmN0dWF0aW9uLCBDb25uZWN0b3JcbiAgUGM6IC9bX1xcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkYzRl0vLFxuXG4gIC8vIFNlcGFyYXRvciwgU3BhY2VcbiAgWnM6IC9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vLFxuXG4gIC8vIFRoZXNlIHR3byBhcmUgbm90IHJlYWwgVW5pY29kZSBjYXRlZ29yaWVzLCBidXQgb3VyIHVzZWZ1bCBmb3IgT2htLlxuICAvLyBMIGlzIGEgY29tYmluYXRpb24gb2YgYWxsIHRoZSBsZXR0ZXIgY2F0ZWdvcmllcy5cbiAgLy8gTHRtbyBpcyBhIGNvbWJpbmF0aW9uIG9mIEx0LCBMbSwgYW5kIExvLlxuICBMOiAvW0EtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE4M1xcdTIxODRcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1XFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4Rl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXXxcXHVEODIxW1xcdURDMDAtXFx1REZFQ118XFx1RDgyMltcXHVEQzAwLVxcdURFRjJdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1REQwMC1cXHVERDQzXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuICBMdG1vOiAvW1xcdTAxQzVcXHUwMUM4XFx1MDFDQlxcdTAxRjJcXHUxRjg4LVxcdTFGOEZcXHUxRjk4LVxcdTFGOUZcXHUxRkE4LVxcdTFGQUZcXHUxRkJDXFx1MUZDQ1xcdTFGRkNdfFtcXHUwMkIwLVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzRcXHUwMzdBXFx1MDU1OVxcdTA2NDBcXHUwNkU1XFx1MDZFNlxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA5NzFcXHUwRTQ2XFx1MEVDNlxcdTEwRkNcXHUxN0Q3XFx1MTg0M1xcdTFBQTdcXHUxQzc4LVxcdTFDN0RcXHUxRDJDLVxcdTFENkFcXHUxRDc4XFx1MUQ5Qi1cXHUxREJGXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyQzdDXFx1MkM3RFxcdTJENkZcXHUyRTJGXFx1MzAwNVxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDlEXFx1MzA5RVxcdTMwRkMtXFx1MzBGRVxcdUEwMTVcXHVBNEY4LVxcdUE0RkRcXHVBNjBDXFx1QTY3RlxcdUE2OUNcXHVBNjlEXFx1QTcxNy1cXHVBNzFGXFx1QTc3MFxcdUE3ODhcXHVBN0Y4XFx1QTdGOVxcdUE5Q0ZcXHVBOUU2XFx1QUE3MFxcdUFBRERcXHVBQUYzXFx1QUFGNFxcdUFCNUMtXFx1QUI1RlxcdUZGNzBcXHVGRjlFXFx1RkY5Rl18XFx1RDgxQVtcXHVERjQwLVxcdURGNDNdfFxcdUQ4MUJbXFx1REY5My1cXHVERjlGXFx1REZFMF18W1xceEFBXFx4QkFcXHUwMUJCXFx1MDFDMC1cXHUwMUMzXFx1MDI5NFxcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDYzRlxcdTA2NDEtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDgwMC1cXHUwODE1XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcyLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDVcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwRDAtXFx1MTBGQVxcdTEwRkQtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEQ1xcdTE4MjAtXFx1MTg0MlxcdTE4NDQtXFx1MTg3N1xcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3N1xcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MjEzNS1cXHUyMTM4XFx1MkQzMC1cXHUyRDY3XFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTAxNFxcdUEwMTYtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGN1xcdUE1MDAtXFx1QTYwQlxcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY2RVxcdUE2QTAtXFx1QTZFNVxcdUE3OEZcXHVBN0Y3XFx1QTdGQi1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUUwLVxcdUE5RTRcXHVBOUU3LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNkZcXHVBQTcxLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCXFx1QUFEQ1xcdUFBRTAtXFx1QUFFQVxcdUFBRjJcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjY2LVxcdUZGNkZcXHVGRjcxLVxcdUZGOURcXHVGRkEwLVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MDFbXFx1REM1MC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4Rl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vXG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuZnVuY3Rpb24gZXh0ZW5kKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgdHlwZW9mIGFkZCAhPT0gJ29iamVjdCcpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59XG4iLCJ2YXIgdjEgPSByZXF1aXJlKCcuL3YxJyk7XG52YXIgdjQgPSByZXF1aXJlKCcuL3Y0Jyk7XG5cbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXVxuICBdKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbnZhciBfbm9kZUlkO1xudmFyIF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW1xuICAgICAgICBzZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgICAgICBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XVxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiY29uc3QgbWVycmlhbSA9IHtcbiAgICBuYW1lOiBcIk1lcnJpYW1BUElcIixcbiAgICBsb2FkOiBmdW5jdGlvbih1cmwpe1xuICAgICAgICB0aGlzLnNyYyA9IHVybDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICByZXNwb25zZTogbnVsbCxcbiAgICBjYWNoZTogbnVsbCxcbiAgICBjYWNoZU5leHRJdGVtOiBudWxsLFxuICAgIGN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleDogLTEsXG4gICAgc3JjOiBudWxsLFxuICAgIGdldDogYXN5bmMgZnVuY3Rpb24ocHJlcmVxdWlzaXRlLCBhcmcpe1xuICAgICAgICBpZihhcmcpe1xuICAgICAgICAgICAgaWYoIXRoaXMuY2FjaGUpe1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm8gcmVzdWx0IGhhcyBiZWVuIGZldGNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhcmcgPT0gXCJuZXh0XCIpe1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRzID0gdGhpcy5jYWNoZS5yZXN1bHRzO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlSXRlbUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jdXJyZW50UmVzcG9uc2VJdGVtSW5kZXggPj0gcmVzdWx0cy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLmNhY2hlLnJlc3VsdHNbdGhpcy5jdXJyZW50UmVzcG9uc2VJdGVtSW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIHB1dCB0aGUgcmVzdWx0IGluIHRoZSBuZXh0IGl0ZW0gY2FjaGVcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTmV4dEl0ZW0gPSB0aGlzLmNhY2hlLnJlc3VsdHNbdGhpcy5jdXJyZW50UmVzcG9uc2VJdGVtSW5kZXhdO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJlc3BvbnNlLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZXJlIHdlIGFzc3VtZSB0aGF0IHRoZSBhcmcgaXMgYSBrZXkgaW4gdGhlIG5leHQgaXRlbSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMuY2FjaGVOZXh0SXRlbVthcmddO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHBhcnNlUHJlcmVxdWlzaXRlKHByZXJlcXVpc2l0ZSk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICAgICAgXCJoZWFkZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYm9keVwiOiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnNyYywgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7IC8vIGlmIEhUVFAtc3RhdHVzIGlzIDIwMC0yOTlcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcmVzcG9uc2UgYm9keSAodGhlIG1ldGhvZCBleHBsYWluZWQgYmVsb3cpXG4gICAgICAgICAgICBsZXQganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBqc29uO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IGpzb247XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5yZXNwb25zZSwgbnVsbCwgJ1xcdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkhUVFAtRXJyb3I6IFwiICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cblxubGV0IHBhcnNlUHJlcmVxdWlzaXRlID0gKHApID0+IHtcbiAgICBsZXQgcExpc3QgPSBwLnNwbGl0KFwiO1wiKTtcbiAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgIHBMaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IGtleSA9IGl0ZW0uc3BsaXQoXCI6XCIpWzBdO1xuICAgICAgICBsZXQgdmFsdWUgPSBpdGVtLnJlcGxhY2UoYCR7a2V5fTpgLCBcIlwiKTtcbiAgICAgICAgc3dpdGNoKGtleSl7XG4gICAgICAgIGNhc2UgXCJmaWVsZHNcIjpcbiAgICAgICAgICAgIHBheWxvYWRbXCJmaWVsZHNcIl0gPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ3ZWlnaHRzXCI6XG4gICAgICAgICAgICBsZXQgd2VpZ2h0cyA9IHt9O1xuICAgICAgICAgICAgdmFsdWUuc3BsaXQoXCIsXCIpLmZvckVhY2goKHcpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgW3dfbmFtZSwgd192YWx1ZV0gPSB3LnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzW3dfbmFtZV0gPSBOdW1iZXIod192YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBheWxvYWRbXCJ3ZWlnaHRzXCJdID0gd2VpZ2h0cztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZG9jX2lkc1wiOlxuICAgICAgICAgICAgcGF5bG9hZFtcImRvY19pZHNcIl0gPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxpbWl0XCI6XG4gICAgICAgICAgICBwYXlsb2FkW1wibGltaXRcIl0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cblxuXG5leHBvcnQge1xuICAgIG1lcnJpYW0sXG4gICAgbWVycmlhbSBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IFRlc3QgZnJvbSAnLi90ZXN0QVBJLmpzJztcbmltcG9ydCBNZXJyaWFtIGZyb20gJy4vbWVycmlhbS5qcyc7XG5cbmNvbnN0IHBsdWdpbnMgPSB7XG4gICAgXCJNZXJyaWFtQVBJXCI6IE1lcnJpYW0sXG4gICAgXCJUZXN0QVBJXCI6IFRlc3Rcbn1cblxuZXhwb3J0IHtcbiAgICBwbHVnaW5zLFxuICAgIHBsdWdpbnMgYXMgZGVmYXVsdFxufVxuIiwiY29uc3QgdGVzdCA9IHtcbiAgICBuYW1lOiBcIlRlc3RBUElcIixcbiAgICBsb2FkOiBmdW5jdGlvbih1cmwpe1xuICAgICAgICB0aGlzLnNyYyA9IHVybDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICByZXNwb25zZTogbnVsbCxcbiAgICBzcmM6IG51bGwsXG4gICAgZ2V0OiBhc3luYyBmdW5jdGlvbihwcmVyZXF1aXNpdGUsIGtleSl7XG4gICAgICAgIGlmKGtleSl7XG4gICAgICAgICAgICBpZighdGhpcy5yZXNwb25zZSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJObyByZXN1bHQgaGFzIGJlZW4gZmV0Y2hlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNyYyA9IHRoaXMuc3JjO1xuICAgICAgICBpZihwcmVyZXF1aXNpdGUpe1xuICAgICAgICAgICAgc3JjID0gc3JjICsgXCIvXCIgKyBwcmVyZXF1aXNpdGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goc3JjKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7IC8vIGlmIEhUVFAtc3RhdHVzIGlzIDIwMC0yOTlcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcmVzcG9uc2UgYm9keSAodGhlIG1ldGhvZCBleHBsYWluZWQgYmVsb3cpXG4gICAgICAgICAgICBsZXQganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkhUVFAtRXJyb3I6IFwiICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IHtcbiAgICB0ZXN0LFxuICAgIHRlc3QgYXMgZGVmYXVsdFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=