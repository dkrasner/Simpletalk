/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/objects/System.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/objects/ExecutionStack.js":
/*!**************************************!*\
  !*** ./js/objects/ExecutionStack.js ***!
  \**************************************/
/*! exports provided: ExecutionStack, ActivationContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExecutionStack", function() { return ExecutionStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActivationContext", function() { return ActivationContext; });
/**
 * ExecutionStack
 * ---------------------------------
 * I am an object that manages a stack of
 * ActivationContext objects.
 * I am designed to be used by System as the
 * global execution stack.
 *
 */

class ExecutionStack {
    constructor(){
        this._stack = [];
        this._globals = {};

        // Bound methods
        this.pop = this.pop.bind(this);
        this.push = this.push.bind(this);
        this.setGlobal = this.setGlobal.bind(this);
        this.getGlobal = this.getGlobal.bind(this);
    }

    pop(){
        if(!this._stack.length){
            return null;
        }
        return this._stack.pop();
    }

    push(anActivation){
        this._stack.push(anActivation);
    }

    setGlobal(varName, value){
        this._globals[varName] = value;
    }

    getGlobal(varName){
        return this._globals[varName];
    }

    get current(){
        if(!this._stack.length){
            return null;
        }
        return this._stack[this._stack.length - 1];
    }

    get previous(){
        if(!this._stack.length >= 2){
            return null;
        }
        return this._stack[this._stack.length - 2];
    }
};

class ActivationContext {
    constructor(messageName, part, incomingMessage, handlerFunction){
        this.part = part;
        this.messageName = messageName;
        this.message = incomingMessage;
        this.handlerFunction = handlerFunction;
        this._locals = {};

        // Bound methods
        this.get = this.get.bind(this);
        this.getLocal = this.getLocal.bind(this);
        this.setLocal = this.setLocal.bind(this);
    }

    get(varName){
        let localValue = this.getLocal(varName);
        if(localValue !== undefined){
            return localValue;
        };
        // otherwise try to return a global
        // variable
        return window.System.executionStack.getGlobal(varName);
    }

    getLocal(varName){
        return this._locals[varName];
    }

    setLocal(varName, value){
        this._locals[varName] = value;
    }
}




/***/ }),

/***/ "./js/objects/System.js":
/*!******************************!*\
  !*** ./js/objects/System.js ***!
  \******************************/
/*! exports provided: System, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return System; });
/* harmony import */ var _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parts/Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parts/Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parts/Button.js */ "./js/objects/parts/Button.js");
/* harmony import */ var _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parts/Field.js */ "./js/objects/parts/Field.js");
/* harmony import */ var _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parts/WorldStack.js */ "./js/objects/parts/WorldStack.js");
/* harmony import */ var _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parts/Window.js */ "./js/objects/parts/Window.js");
/* harmony import */ var _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parts/Drawing.js */ "./js/objects/parts/Drawing.js");
/* harmony import */ var _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parts/Audio.js */ "./js/objects/parts/Audio.js");
/* harmony import */ var _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parts/Browser.js */ "./js/objects/parts/Browser.js");
/* harmony import */ var _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parts/Resource.js */ "./js/objects/parts/Resource.js");
/* harmony import */ var _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parts/Image.js */ "./js/objects/parts/Image.js");
/* harmony import */ var _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parts/Area.js */ "./js/objects/parts/Area.js");
/* harmony import */ var _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./views/WorldView.js */ "./js/objects/views/WorldView.js");
/* harmony import */ var _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./views/StackView.js */ "./js/objects/views/StackView.js");
/* harmony import */ var _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./views/ButtonView.js */ "./js/objects/views/ButtonView.js");
/* harmony import */ var _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./views/CardView.js */ "./js/objects/views/CardView.js");
/* harmony import */ var _views_WindowView__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./views/WindowView */ "./js/objects/views/WindowView.js");
/* harmony import */ var _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./views/FieldView.js */ "./js/objects/views/FieldView.js");
/* harmony import */ var _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./views/drawing/DrawingView.js */ "./js/objects/views/drawing/DrawingView.js");
/* harmony import */ var _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./views/ImageView.js */ "./js/objects/views/ImageView.js");
/* harmony import */ var _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./views/AreaView.js */ "./js/objects/views/AreaView.js");
/* harmony import */ var _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./views/AudioView.js */ "./js/objects/views/AudioView.js");
/* harmony import */ var _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./views/BrowserView.js */ "./js/objects/views/BrowserView.js");
/* harmony import */ var _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./views/ResourceView.js */ "./js/objects/views/ResourceView.js");
/* harmony import */ var _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./views/Halo.js */ "./js/objects/views/Halo.js");
/* harmony import */ var _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./views/navigator/Navigator.js */ "./js/objects/views/navigator/Navigator.js");
/* harmony import */ var _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./views/editors/Editor.js */ "./js/objects/views/editors/Editor.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ohm-js */ "./node_modules/ohm-js/src/main.js");
/* harmony import */ var ohm_js__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(ohm_js__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./utils/clipboard.js */ "./js/objects/utils/clipboard.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./utils/handInterface.js */ "./js/objects/utils/handInterface.js");
/* harmony import */ var _utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./utils/merriamInterface.js */ "./js/objects/utils/merriamInterface.js");
/* harmony import */ var _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./utils/serialization.js */ "./js/objects/utils/serialization.js");
/* harmony import */ var _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../../plugins/plugins.js */ "./plugins/plugins.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * System Object
 * -------------------------------------
 * I am an object representing the "top" of the
 * sytem. I am the point of communication between
 * Models and Views.
 */
















































const DOMparser = new DOMParser();




const System = {
    name: "System",
    id: -1,
    isLoaded: false,
    partsById: {},
    _commandHandlers: {},
    _functionHandlers: {},
    _deserializer: null,

    // A dictionary mapping available ST resource (such as plugin) names
    availableResources: {},

    // A dictionary mapping part types like
    // 'button' to their classes (Button)
    availableParts: {},

    // A dictionary mapping part types like
    // 'button' to their view classes (ButtonView)
    availableViews: {},

    // A registry that keeps all system messages from
    // beginnign of time; TODO in the future we might want
    // to note keep all this in memory
    // each log consists of:
    // [aMessage, (sourceName, sourceId), (targetName, targetId)]
    messageLog: [],

    // Will be called when a page loads.
    // Checks for any view elements in the
    // page and attempts to find serialized
    // model state for each of them. If present,
    // deserializes the model and attaches it
    // to the view.
    initialLoad: function(){
        // load the available resources
        // these might be needed down the line
        this.loadResources();

        // If we have a serialization script tag
        // containing JSON of serialized information,
        // attempt to load from it
        let serializationEl = document.getElementById('serialization');
        if(serializationEl && serializationEl.text != ""){
            this.deserialize()
                .then(() => {
                    this.sendInitialOpenMessages();
                    System.navigator.setModel(
                        System.partsById['world']
                    );

                    // By default, we render the World in the
                    // Comprehensive Editor
                    this.editor.render(this.world);
                });
        } else {
            this.loadFromEmpty();
 
            // By default, we render the World in the
            // Comprehensive Editor
            this.editor.render(this.world);
        }

        // Attach a new clipboard instance
        this.clipboard = new _utils_clipboard_js__WEBPACK_IMPORTED_MODULE_31__["default"](this);

        // By this point we should have a WorldView with
        // a model attached.
        this.isLoaded = true;
    },

    loadResources: function() {
        Object.keys(_plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"]).forEach((k) => {
            this.availableResources[k] = _plugins_plugins_js__WEBPACK_IMPORTED_MODULE_36__["default"][k];
        });
    },

    loadFromEmpty: function(){
        let worldModel = new this.availableParts['world']();
        this.partsById[worldModel.id] = worldModel;
        let worldView = document.createElement(
            this.tagNameForViewNamed('world')
        );
        worldView.setModel(worldModel);
        document.body.appendChild(worldView);

        // Create initial stack model
        let initStack = this.newModel('stack', worldModel.id);

        // Create initial card model for that stack
        let initCard = this.newModel('card', initStack.id);

        // Update current stack and card ids 
        worldModel.partProperties.setPropertyNamed(
            worldModel,
            'current',
            initStack.id
        );
        initStack.partProperties.setPropertyNamed(
            initStack,
            'current',
            initCard.id
        );
        // Update serialization
        this.serialize();

        this.sendInitialOpenMessages();
        System.navigator.setModel(
            System.partsById['world']
        );
    },

    sendInitialOpenMessages: function(){
        // Send the openWorld message to the WorldStack
        let world = this.partsById['world'];
        world.sendMessage({
            type: 'command',
            commandName: 'openWorld',
            args: [],
            shouldIgnore: true
        }, world);
        world.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, world.currentStack);
        world.currentStack.sendMessage({
            type: 'command',
            commandName: 'openCard',
            args: [],
            shouldIgnore: true
        }, world.currentStack.currentCard);
    },

    sendMessage: function(aMessage, source, target){
        if(!target || target == undefined){
            throw new Error('Messages must be sent with target receivers specified!');
        }

        // keep track of all sources which pass this message
        if (!("senders" in aMessage)) {
            aMessage["senders"] = [];
        }
        aMessage.senders.push({
            name: source.name,
            id: source.id,
        });

        return target.receiveMessage(aMessage);
    },

    receiveMessage: function(aMessage){
        switch(aMessage.type){
            case 'newView':
                return this.newView(
                    aMessage.viewType,
                    aMessage.modelId
                );
            case 'compile':
                return this.compile(aMessage);
            case 'command':
                return this.receiveCommand(aMessage);
            default:
                return this.doesNotUnderstand(aMessage);
        }
    },

    doesNotUnderstand: function(aMessage){
        // If the message has the shouldIgnore property
        // set to true, it means we should just swallow
        // this message if we don't understand it. This is
        // useful for messages like mouse events on buttons
        // which are not captured by default and would otherwise
        // end up arriving to this System object via the
        // message delegation chain.
        if(aMessage.shouldIgnore){
            return;
        }
        let originalSender = this.partsById[aMessage.senders[0].id];
        let msg = {
            type: "error",
            name: "MessageNotUnderstood",
            message: aMessage
        };
        originalSender.sendMessage(msg, originalSender);
    },

    compile: function(aMessage){
        let targetObject = this.partsById[aMessage.targetId];
        if(!targetObject || targetObject == undefined){
            throw new Error(`System could not compile target object ${aMessage.targetId}`);
        }


        // Attempt to parse the incoming SimpleTalk script string.
        // If there are grammatical errors, report them and bail.
        // Otherwise, create a new semantics on the targetPart, add
        // the required semantic operations, and interpret the top
        // level of the script, which will create the JS handler functions
        let parsedScript = languageGrammar.match(aMessage.codeString);
        if(parsedScript.failed()){
            // consider using the parse data from trace
            // example: let tracedScript = languageGrammar.trace(aMessage.codeString);
            // let tree = tracedScript.toString();
            let msg = {
                type: "error",
                name: "GrammarMatchError",
                parsedScript: parsedScript,
                partId: aMessage.targetId
            };
            targetObject.sendMessage(msg, targetObject);
        } else {
            // First, clear out any currently compiled handlers
            // since the incoming script might get rid of them
            targetObject._commandHandlers = {};

            // Create a semantics object whose partContext
            // attribute is set to be the target object.
            targetObject._semantics = languageGrammar.createSemantics();
            targetObject._semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(targetObject, this)
            );
            targetObject._semantics(parsedScript).interpret();
        }


        // Be sure to then update the
        // serialization for the target
        // part, thus adding the script to
        // its serialization
        if(aMessage.serialize){
            this.serialize();
        }
    },

    receiveCommand: function(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            let boundHandler = handler.bind(this);
            let activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            this.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            this.executionStack.pop();
            return result;
        } else {
            return this.doesNotUnderstand(aMessage);
        }
    },

    newModel: function(kind, ownerId, name, buildView=true){
        // Lookup the instance of the model that
        // matches the owner's id
        let ownerPart = this.partsById[ownerId];
        if(!ownerPart || ownerPart == undefined){
            throw new Error(`System could not locate owner part with id ${ownerId}`);
        }

        // Find the class constructor for the kind of
        // part requested as a new model. If not known,
        // throw an error
        let modelClass = this.availableParts[kind];
        if(!modelClass){
            throw new Error(`Cannot create unknown part type: ${kind}`);
        }
        let model = new modelClass(ownerPart);
        if(name){
            model.partProperties.setPropertyNamed(model, 'name', name);
        }
        this.partsById[model.id] = model;

        // Any created part might initialize its
        // own subparts. We need to let the System know
        // about those too
        model.subparts.forEach(subpart => {
            this.partsById[subpart.id] = subpart;
        });

        // If there is a valid owner part for
        // the newly created part model,
        // add the new model to the owner's
        // subparts list
        if(ownerPart){
            ownerPart.addPart(model);
        }

        // Add the System as a property subscriber to
        // the new model. This will send a message to
        // this System object whenever any of this model's
        // properties have changed
        model.addPropertySubscriber(this);

        if(buildView){
            // See if there is already a view for the model.
            // If not, create and attach it.
            let viewForModel = this.findViewById(model.id);
            if(!viewForModel){
                this.newView(model.type, model.id);
            }
        }

        // Finally if the owner part is either a world or a stack
        // and has only one stack or card child, respectively, set
        // that child to be the current
        if(ownerPart.type == "world" || ownerPart.type == "stack"){
            let currentId = ownerPart.partProperties.getPropertyNamed(ownerPart, "current");
            if(!currentId){
                ownerPart.partProperties.setPropertyNamed(ownerPart, "current", model.id);
            }
        }

        return model;
    },

    newProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find newProperty target!`);
        }

        if(target.partProperties.findPropertyNamed(propName)){
            // TODO this should be a ST error
            throw new Error(`Part ${target.id} already has property "${propName}"`);
        }
        // we only add basic property and the default value is null
        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_32__["BasicProperty"](propName, null);
        customProp.add(newProp);
    },

    deleteProperty(senders, propName, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find deleteProperty target!`);
        }

        // Note: this will only delete custom properties which is what we want
        let prop = target.partProperties.findPropertyNamed(propName);

        let customProp = target.partProperties.findPropertyNamed("custom-properties");
        customProp.delete(prop);
    },

    setProperty(senders, propName, value, objectId){
        let target;
        let originalSender = senders[0].id;

        if(objectId){
            // Otherwise, if there is an objectId, we are
            // setting the property of a specific part by
            // id
            target = this.partsById[objectId];
        } else {
            // Otherwise we are setting the property on the part
            // that originally sent the message
            target = this.partsById[originalSender];
        }

        if(!target){
            throw new Error(`Could not find setProperty target!`);
        }

        target.partProperties.setPropertyNamed(
            target,
            propName,
            value
        );

        // If the target part is a Stack, we also
        // set this property on all of its Card
        // subparts
        if(target.type == 'stack'){
            target.subparts.filter(subpart => {
                return subpart.type == 'card';
            }).forEach(card => {
                card.partProperties.setPropertyNamed(
                    card,
                    propName,
                    value
                );
            });
        }
    },

    // Remove the model with the given ID from
    // the System's registry, as well as from the subparts
    // array of any owners
    deleteModel: function(modelId){
        let foundModel = this.partsById[modelId];
        if(!foundModel){
            return false;
        }
        // When removing a card or a stack be sure it is not the only one
        // and if it is the current card or stack we should go to the next one
        // before removing it
        if(foundModel.type == "card" || foundModel.type == "stack"){
            let sameTypeSubparts = foundModel._owner.subparts.filter((p) => {return p.type == foundModel.type;});
            if(sameTypeSubparts.length == 1){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the only ${foundModel.type}`);
            } else if(modelId == this.getCurrentStackModel().id  || modelId == this.getCurrentCardModel().id){
                // TODO this should be a ST error
                throw new Error(`Cannot remove the current ${foundModel.type}`);
            }
        }

        // Make sure to stop all stepping
        // on the Part, otherwise stepping
        // intervals will error infinitely
        foundModel.stopStepping();

        // make sure the editor is closed
        foundModel.closeEditorCmdHandler();

        let ownerModel = foundModel._owner;
        if(ownerModel){
            ownerModel.removePart(foundModel);
        }

        delete this.partsById[modelId];
        this.removeViews(modelId);

        // Serialize the state
        this.serialize();
        return true;
    },

    // Remove all views with the corresponding
    // model id from the DOM
    removeViews: function(modelId){
        let views = Array.from(this.findViewsById(modelId));
        views.forEach(view => {
            let parentEl = view.parentElement;
            view.parentElement.removeChild(view);
            // Dispatch a CustomEvent on the parentElement
            // indicating that this part has been removed, and
            // any view utilities that care can be notified.
            let event = new CustomEvent('st-view-removed', {
                detail: {
                    partType: view.model.type,
                    partId: modelId,
                    ownerId: null
                } 
            });
            parentEl.dispatchEvent(event);
        });
        let lenses = this.findLensViewsById(modelId);
        lenses.forEach(lensView => {
            lensView.parentElement.removeChild(lensView);
        });
    },

    newView: function(partName, modelId, parentId){
        let model = this.partsById[modelId];
        if(!model || model == undefined){
            throw new Error(`System does not know part ${partName}[${modelId}]`);
        }
        if(!partName){
            partName = model.type;
        }

        // Find the parent model id. This will
        // help us find the parent view element for
        // appending the new element.
        if (!parentId){
            parentId = model._owner.id;
        }
        let parentElement = this.findViewById(parentId);
        if(!parentElement){
            throw new Error(`Could not find parent element for ${partName}[${modelId}] (model owner id: ${model._owner.id})`);
        }

        // Create the new view instance,
        // append to parent, and set the model
        let newView = document.createElement(
            this.tagNameForViewNamed(partName)
        );
        newView.setModel(model);
        this.sendMessage({
            type: "viewChanged",
            changeName: "subpart-new",
            args: [newView]
        }, model._owner, parentElement);

        // Dispatch a CustomEvent on the parentElement
        // indicating that this part has been created, and
        // any view utilities that care can be notified.
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: model.type,
                partId: model.id,
                ownerId: model._owner.id || null
            } 
        });
        parentElement.dispatchEvent(event);

        // See if there are lens views and update
        // those as well
        let lensViews = this.findLensViewsById(parentId);
        lensViews.forEach(lensView => {
            let newLensView = document.createElement(
                this.tagNameForViewNamed(partName)
            );
            newLensView.setModel(model);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', modelId);
            newLensView.setAttribute('role', 'lens');
            lensView.appendChild(newLensView);
        });

        // TODO do we want to allow the possibiliy of a view on an
        // element but no subpart of that view on the element?

        // For all subparts of this model, call
        // the newView method recursively
        model.subparts.forEach(subpart => {
            this.newView(subpart.type, subpart.id);
        });

        return newView;
    },

    registerPart: function(name, cls){
        this.availableParts[name] = cls;
    },

    registerView: function(name, cls){
        this.availableViews[name] = cls;
    },

    tagNameForViewNamed: function(name){
        return `st-${name}`;
    },

    // Find the first matching view element
    // with the given id
    findViewById: function(id){
        return document.querySelector(`[part-id="${id}"]`);
    },

    findLensViewsById: function(id){
        return Array.from(document.querySelectorAll(`[lens-part-id="${id}"]`));
    },

    // Find all matching view elements with
    // the given part id
    findViewsById: function(id){
        return document.querySelectorAll(`[part-id="${id}"]`);
    },

    // return the model corresponding to the current stack
    getCurrentStackModel: function(){
        let world = this.getWorldStackModel();
        return world.currentStack;
    },

    // return the model corresponding to the current card
    getCurrentCardModel: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.currentCard;
    },

    // return the model corresponding to the world stack
    getWorldStackModel: function(){
        return this.partsById['world'];
    },

    // return the model corresponding script editor st-field
    // Note: we use the window.model.target to locate the corresponding window
    // but return its st-field subpart
    findScriptEditorByTargetId: function(id){
        let scriptEditorField;
        let windows = document.querySelectorAll("st-window");
        windows.forEach((w) => {
            let target = w.model.target;
            if(target && target.id === id){
                scriptEditorField = w.querySelector("st-field");
            }
        });
        return scriptEditorField;
    },

    serialize: function(){
        let world = this.partsById['world'];
        if(!world){
            throw new Error(`No world found!`);
        }
        let serializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STSerializer"](this);
        let serialString = serializer.serialize(this.partsById['world'], true);

        // If there is not a script tag in the
        // body for the serialization, create it
        let serializationScriptEl = document.getElementById('serialization');
        if(!serializationScriptEl){
            serializationScriptEl = document.createElement('script');
            serializationScriptEl.id = 'serialization';
            serializationScriptEl.type = 'application/json';
            document.body.append(serializationScriptEl);
        }
        serializationScriptEl.textContent = serialString;
    },

    deserialize: function(){
        let serializationEl = document.getElementById('serialization');
        if(!serializationEl){
            throw new Error(`No serialization found for this page`);
        }
        this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
        return this._deserializer.deserialize(serializationEl.textContent);
    },

    // Return a *complete* HTML
    // representation of the current application
    // that can later be saved to a file
    getFullHTMLString: function(){
        let clonedDocument = document.cloneNode(true);
        let world = clonedDocument.querySelector('st-world');
        let nav = clonedDocument.querySelector('st-navigator');
        if(world){
            world.remove();
        }
        if(nav){
            nav.remove();
        }

        return clonedDocument.documentElement.outerHTML;
    },


    /** Navigation of Current World **/
    goToNextStack: function(){
        let world = this.partsById['world'];
        return world.goToNextStack();
    },

    goToPrevStack: function(){
        let world = this.partsById['world'];
        return world.goToPrevStack();
    },

    goToStackById: function(stackId){
        let world = this.partsById['world'];
        return world.goToStackById(stackId);
    },

    /** Navigation of Current Stack **/
    goToNextCard: function(){
        let currentStack = this.getCurrentStackModel(); 
        return currentStack.goToNextCard();
    },

    goToPrevCard: function(){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToPrevCard();
    },

    goToCardById: function(cardId){
        let currentStack = this.getCurrentStackModel();
        return currentStack.goToCardById(cardId);
    },

    openEditorForPart: function(partId){
        this.editor.render(
            this.partsById[partId]
        );
        this.editor.open();
    },

    closeEditorForPart: function(partId){
        this.editor.close();
    }
};

/** Add Default System Command Handlers **/
//System._commandHandlers['deleteModel'] = System.deleteModel;
System._commandHandlers['deleteModel'] = function(senders, ...rest){
    System.deleteModel(...rest);
};
//System._commandHandlers['newModel'] = System.newModel;
System._commandHandlers['newModel'] = function(senders, ...rest){
    System.newModel(...rest);
    this.serialize();
};
//System._commandHandlers['newView'] = System.newView;
System._commandHandlers['newView'] = function(senders, ...rest){
    System.newView(...rest);
};
System._commandHandlers['newProperty'] = System.newProperty;
System._commandHandlers['setProperty'] = System.setProperty;
System._commandHandlers['deleteProperty'] = System.deleteProperty;

System._commandHandlers['ask'] = function(senders, question){
    // Use the native JS prompt function to ask the question
    // and return its value.
    // By returning here, we expect the implicit variable
    // "it" to be set inside any calling script
    return prompt(question);
};

System._commandHandlers['putInto'] = function(senders, value, variableName, global){
    if(global){
        System.executionStack.setGlobal(variableName, value);
        return;
    }
    // Because we push all handlers onto the execution stack,
    // the putInto handler is currently at the top of the stack.
    // In order to modify the caller's variables, we need to
    // find the context that is one previous on the stack
    if(System.executionStack.previous){
        System.executionStack.previous.setLocal(variableName, value);
    } else {
        throw new Error(`ExecutionStack Error: #putInto on top of empty stack!`);
    }
};

System._commandHandlers['answer'] = function(senders, value){
    alert(value.toString());
};

System._commandHandlers['go to direction'] = function(senders, directive, objectName){
    switch(objectName) {
        case 'card':
            switch(directive){
                case 'next':
                    this.goToNextCard();
                    break;

                case 'previous':
                    this.goToPrevCard();
                    break;
            }
            break;

        case 'stack':
            switch(directive){
                case 'next':
                    this.goToNextStack();
                    break;

                case 'previous':
                    this.goToPrevStack();
                    break;
            }
            break;

        default:
            alert(`"go to" not implemented for ${objectName}`);

    }
};

System._commandHandlers['go to'] = function(senders, id){
    let model = this.partsById[id];
    if(!model){
        alert(`"go to" target not found`);
    }
    switch(model.type) {
    case 'card':
        this.goToCardById(id);
        break;

    case 'stack':
        this.goToStackById(id);
        break;

    default:
        alert(`"go to" not implemented for ${model.type}`);

    }
};

System._commandHandlers['go to website'] = function(senders, url){
    window.location.href = url;
};

//Import a world, i.e. its stacks from another source
System._commandHandlers['importWorld'] = function(sender, sourceUrl){
    if(!sourceUrl){
        sourceUrl = window.prompt("Choose World location");
    }
    fetch(sourceUrl)
        .then(response => {
            let contentType = response.headers.get('content-type');
            if(!contentType.startsWith('text/html')){
                throw new Error(`Invalid content type: ${contentType}`);
            }
            return response.blob().then(blob => {
                let reader = new FileReader();
                reader.readAsText(blob);
                reader.onloadend = () => {
                    let parsedDocument = DOMparser.parseFromString(reader.result, "text/html");
                    // there is no .getElementById() for a node HTML parsed document!
                    let serializationEl = parsedDocument.querySelector('#serialization');
                    if(!serializationEl){
                        console.log(`No serialization found for ${sourceUrl}`);
                        alert(`World "${sourceUrl}" not found`);
                        return;
                    }
                    this._deserializer = new _utils_serialization_js__WEBPACK_IMPORTED_MODULE_35__["STDeserializer"](this);
                    this._deserializer.targetId = 'world'; // We will insert the stacks into the world
                    return this._deserializer.importFromSerialization(
                        serializationEl.textContent,
                        (part) => {
                            // Return only Stacks that are direct subparts
                            // of the world.
                            let isStack = part.type == 'stack';
                            let isWorldSubpart = part._owner && part._owner.type == 'world';
                            return isStack && isWorldSubpart;
                        }
                    );
                };
            });
        })
        .then(() => {
            // Manually set the _src.
            // This ensures that we don't infinitely
            // call the load operation
            this._src = sourceUrl;
            /*
            // Stop and restart hand interface if it's running.
            if (handInterface.handDetectionRunning) {
                handInterface.stop();
                handInterface.start();
            }
            */
        })
        .catch(err => {
            alert("Could not load world");
            console.error(err);
        });
};

System._commandHandlers['openScriptEditor'] = function(senders, targetId){
    let target = this.partsById[targetId];
    let targetName = target.partProperties.getPropertyNamed(target, "name");
    if(targetName){
        targetName = `"${targetName}"`;
    }
    let name = `Script For ${target.name} ${targetName}`;

    // If there is already a dinwo opened with this name, then
    // we return without creating anything new.
    let found = Object.values(System.partsById).filter(part => {
        let partName;
        if(part.type == 'window'){
            partName = part.partProperties.getPropertyNamed(
                part,
                'title'
            );
        }
        return (part.type == 'window' && name == partName);
    });
    if(found.length){
        return;
    }

    let currentCard = this.getCurrentCardModel();
    let window = this.newModel('window', currentCard.id);
    let area = this.newModel('area', window.id);
    let scriptField = this.newModel('field', area.id);
    let saveButton = this.newModel('button', area.id);


    // setup the window and stack properties
    window.setTarget(target);
    window.partProperties.setPropertyNamed(window, "title", name);
    window.partProperties.setPropertyNamed(window, "height", 200);
    window.partProperties.setPropertyNamed(window, "width", 500);
    window.partProperties.setPropertyNamed(window, 'top', 100);
    window.partProperties.setPropertyNamed(window, 'left', 100);

    area.partProperties.setPropertyNamed(area, "layout", "list");
    area.partProperties.setPropertyNamed(area, "list-direction", "column");
    area.partProperties.setPropertyNamed(area, "width", "fill");
    area.partProperties.setPropertyNamed(area, "height", "fill");

    // script field
    let targetScript = target.partProperties.getPropertyNamed(target, "script"); 
    scriptField.partProperties.setPropertyNamed(scriptField, "text", targetScript);
    scriptField.partProperties.setPropertyNamed(scriptField, "height", "fill");
    scriptField.partProperties.setPropertyNamed(scriptField, "width", "fill");

    // Setup syntax highlight
    scriptField.sendMessage({
        type: "command",
        commandName: "highlightSyntax",
        args: []
    }, scriptField);


    // setup up the save button properties
    saveButton.partProperties.setPropertyNamed(saveButton, "name", "Save Script");
    saveButton.partProperties.setPropertyNamed(saveButton, "width", "fill");
    saveButton.partProperties.setPropertyNamed(saveButton, "text-size", 20);
    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);

    saveButton.partProperties.setPropertyNamed(saveButton, "target", `part id ${target.id}`);
    let saveScript = `on click\n\ttell target to set "script" to the "text" of first field\nend click`; 
    saveButton.partProperties.setPropertyNamed(saveButton, "script", saveScript);
};

System._commandHandlers['SimpleTalk'] = function(senders){
    return System.grammar.source.sourceString;
}

System._commandHandlers['openDebugger'] = function(senders, partId){
    let target = this.partsById[partId];
    // Create the Field model and attach to current card
    let currentCard = this.getCurrentCardModel();
    let fieldModel = this.newModel('field', currentCard.id);
    let text = `Available Commands for ${target.name} (id ${target.id})\n\n`;
    Object.keys(target.commandHandlerRegistry).forEach((name) =>{
        let info = target.commandHandlerRegistry[name];
        text += `${name}: ${JSON.stringify(info)}\n`;
    });
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'text',
        text
    );
    fieldModel.partProperties.setPropertyNamed(
        fieldModel,
        'editable',
        false
    );
};

System._commandHandlers['saveHTML'] = function(senders){
    // Stop hand recognition if it's running.
    let handRecognitionOriginallyRunning = _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionRunning;
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
    this.serialize();

    let stamp = Date.now().toString();
    let serializedPage = this.getFullHTMLString();
    let typeInfo = "data:text/plain;charset=utf-8";
    let url = `${typeInfo},${encodeURIComponent(serializedPage)}`;

    let anchor = document.createElement('a');
    anchor.style.display = "none";
    document.body.append(anchor);
    anchor.href = url;
    anchor.download = `SimpleTalkSnapshot_${stamp}.html`;
    anchor.click();
    window.URL.revokeObjectURL(url);
    anchor.parentElement.removeChild(anchor);
    // Start hand recognition if it was running.
    if (handRecognitionOriginallyRunning) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    }
};

System._commandHandlers['tell'] = (senders, targetId, deferredMessage) => {
    let targetPart = System.partsById[targetId];
    if(!targetPart){
        throw new Error(`Attempted to tell part id ${targetId}: no such part!`);
    }
    targetPart.sendMessage(deferredMessage, targetPart);
};

System._commandHandlers['toggleHandDetection'] = () => {
    if (_utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].handDetectionModel === null) {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].start();
    } else {
        _utils_handInterface_js__WEBPACK_IMPORTED_MODULE_33__["default"].stop();
    }
};

System._commandHandlers['merriam'] = (senders, docId) => {
    const sender = System.partsById[senders[0].id];
    Object(_utils_merriamInterface_js__WEBPACK_IMPORTED_MODULE_34__["default"])(sender, docId);
};

System._commandHandlers['globalInterrupt'] = () => {
    // cycle through all the parts and set the "stepping" property to false
    Object.values(System.partsById).forEach((part) => {
        if(part.isStepping){
            part.partProperties.setPropertyNamed(part, "stepping", false);
        }
    });
};


/** Register the initial set of parts in the system **/
System.registerPart('card', _parts_Card_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
System.registerPart('stack', _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('button', _parts_Button_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
System.registerPart('world', _parts_WorldStack_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
System.registerPart('window', _parts_Window_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
System.registerPart('field', _parts_Field_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
System.registerPart('drawing', _parts_Drawing_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
System.registerPart('image', _parts_Image_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
System.registerPart('area', _parts_Area_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
System.registerPart('audio', _parts_Audio_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
System.registerPart('browser', _parts_Browser_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
System.registerPart('resource', _parts_Resource_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/** Register the initial set of views in the system **/
System.registerView('button', _views_ButtonView_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
System.registerView('stack', _views_StackView_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
System.registerView('world', _views_WorldView_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
System.registerView('card', _views_CardView_js__WEBPACK_IMPORTED_MODULE_15__["default"]);
System.registerView('window', _views_WindowView__WEBPACK_IMPORTED_MODULE_16__["default"]);
System.registerView('field', _views_FieldView_js__WEBPACK_IMPORTED_MODULE_17__["default"]);
System.registerView('drawing', _views_drawing_DrawingView_js__WEBPACK_IMPORTED_MODULE_18__["default"]);
System.registerView('image', _views_ImageView_js__WEBPACK_IMPORTED_MODULE_19__["default"]);
System.registerView('area', _views_AreaView_js__WEBPACK_IMPORTED_MODULE_20__["default"]);
System.registerView('audio', _views_AudioView_js__WEBPACK_IMPORTED_MODULE_21__["default"]);
System.registerView('browser', _views_BrowserView_js__WEBPACK_IMPORTED_MODULE_22__["default"]);
System.registerView('resource', _views_ResourceView_js__WEBPACK_IMPORTED_MODULE_23__["default"]);


// Convenience method for adding all of the
// available custom elements to the window object's
// customElements registry
System.registerCustomElements = function(){
    Object.keys(System.availableViews).forEach(partName => {
        let viewClass = System.availableViews[partName];
        let elementName = System.tagNameForViewNamed(partName);
        window.customElements.define(elementName, viewClass);
    });
};

// iniitalize the compiler and add it to the system
// Instantiate the grammar.
let languageGrammar;
if (window.grammar){
    // for testing it is sometimes convenient to load the grammar and add to window
    // see ./tests/preload.js for example
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammar(window.grammar);
} else {
    languageGrammar = ohm_js__WEBPACK_IMPORTED_MODULE_27___default.a.grammarFromScriptElement();
}

System.grammar = languageGrammar;

// Set the exection stack on the
// System
System.executionStack = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_29__["ExecutionStack"]();

// Add a dynamic getter for the World for convenience
Object.defineProperty(System, 'world', {
    get: function(){
        return this.partsById['world'];
    }
});

document.addEventListener('DOMContentLoaded', () => {
    // Add the System object to window so
    // that it is global on the page. We do this
    // for both debugging and testing.
    window.System = System;
    // Add the possible views as webcomponents
    // in the custom element registry
    System.registerCustomElements();

    // Add any other non-part view CustomElements,
    // like the halo
    window.customElements.define('st-halo', _views_Halo_js__WEBPACK_IMPORTED_MODULE_24__["default"]);
    window.customElements.define('st-navigator', _views_navigator_Navigator_js__WEBPACK_IMPORTED_MODULE_25__["default"]);
    window.customElements.define('st-editor', _views_editors_Editor_js__WEBPACK_IMPORTED_MODULE_26__["default"]);

    // Add nav
    System.navigator = document.createElement('st-navigator');
    document.body.appendChild(System.navigator);

    // Add comprehensive editor pane
    // if one is not already present in the markup
    let existingEditors = Array.from(document.querySelectorAll('st-editor'));
    existingEditors.forEach(editorEl => {
        editorEl.remove();
    });
    System.editor = document.createElement('st-editor');
    document.body.appendChild(System.editor);

    // Perform the initial setup of
    // the system
    System.initialLoad();
});

// add a message listener on window
// these can include message from a browser part
// for now filter those not coming from the origin
window.addEventListener("message", (event) => {
    if (event.origin !== window.origin)
        return;
    console.log(`Message to browser`);
    // TODO: maybe we need to deal with quote escapes directly
    // in the grammar
    let script = event.data.replaceAll("'", '"');
    // only statements are accepted for now
    let parsedScript = languageGrammar.match(script, "Statement");
    if(parsedScript.failed()){
        // for now just log that it failed
        console.log("failed to parse script for browser");
    } else {
        let semantics = languageGrammar.createSemantics();
        let world = System.partsById["world"];
        semantics.addOperation(
            'interpret',
            Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_28__["default"])(world, System)
        );
        let msg = semantics(parsedScript).interpret();
        System.sendMessage(msg, world, System);
    }
});

// global interrupt
document.addEventListener('keydown', (event) => {
    if(event.ctrlKey && event.key == 'c'){
        System.sendMessage({
            type: "command",
            commandName: "globalInterrupt",
            args: []
        }, System, System);
    }
});





/***/ }),

/***/ "./js/objects/parts/Area.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Area.js ***!
  \**********************************/
/*! exports provided: Area, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Area", function() { return Area; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Area; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Area
 * ----------------------------------
 * I am a Area Part.
 * I represent a 'grouping' of subparts within
 * my owner part.
 * I contain the Layout properties set, and therefore
 * can display my contained subparts according to 
 * different layout properties than my ancestor
 * Card.
 *
 */



const sides = ["top", "bottom", "left", "right"];

class Area extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(...args){
        super(...args);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
            "browser",
            "window"
        ];

        // Add style props
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addLayoutStyleProps"])(this);

        // Set default width and height
        // for an empty area
        this.partProperties.setPropertyNamed(
            this,
            'width',
            50
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            50
        );
        this.partProperties.newBasicProp(
            'clipping',
            false
        );
        this.partProperties.newBasicProp(
            'allow-scrolling',
            false
        );
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
    }


    get type(){
        return 'area';
    }
};




/***/ }),

/***/ "./js/objects/parts/Audio.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Audio.js ***!
  \***********************************/
/*! exports provided: Audio, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Audio; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Audio extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadAudioFromSource", this.loadAudioFromSource);
        this.setPrivateCommandHandler("play", () => {this.play(true);});
        this.setPrivateCommandHandler("pause", () => {this.play(false);});
        this.setPrivateCommandHandler("stop", this.stop);

        // Bind component methods
        this.loadAudioFromSource = this.loadAudioFromSource.bind(this);
        this.play = this.play.bind(this);
        this.stop = this.stop.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'audio';
    }

    loadAudioFromSource(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    play(value){
        this.partProperties.setPropertyNamed(this, "play", value);
        this.partProperties.setPropertyNamed(this, "stop", false);
    }

    stop(){
        this.partProperties.setPropertyNamed(this, "play", false);
        this.partProperties.setPropertyNamed(this, "stop", true);
    }
};




/***/ }),

/***/ "./js/objects/parts/Browser.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Browser.js ***!
  \*************************************/
/*! exports provided: Browser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Browser", function() { return Browser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Browser; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Browser extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;
        this.partProperties.newBasicProp(
            'readyState',
            "HAVE_NOTHING"
        );

        this.partProperties.newBasicProp(
            "play",
            false
        );

        this.partProperties.newBasicProp(
            "stop",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("setURLTo", this.setURL);
        this.setPrivateCommandHandler("forward", this.sendMessageToBrowser);

        // Bind component methods
        this.setURL = this.setURL.bind(this);
        this.sendMessageToBrowser = this.sendMessageToBrowser.bind(this);


        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                5
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );
    }

    get type(){
        return 'browser';
    }

    setURL(senders, sourceUrl){
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
    }

    sendMessageToBrowser(senders, message){
        let views = window.System.findViewsById(this.id);
        views.forEach((v) => {
            let iframe = v._shadowRoot.querySelector("iframe");
            iframe.contentWindow.postMessage(message, window.origin);
        });
    }
};




/***/ }),

/***/ "./js/objects/parts/Button.js":
/*!************************************!*\
  !*** ./js/objects/parts/Button.js ***!
  \************************************/
/*! exports provided: Button, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Button; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Button
 * ----------------------------------
 * I am a Button Part.
 * My owner is always a Card.
 * I am a clickable point of interaction on a Card,
 * whose functionality can be customized by the author.
 */




class Button extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner){
        super(owner);

        this.isButton = true;

        // Add Button-specific part properties
        this.partProperties.newDynamicProp(
            'selectedText',
            null, // readOnly (for now)
            this.getSelectedText,
            true, // readOnly,
        );

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 234, 149)", // var(--palette-yellow)
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-top-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-left-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'corner-bottom-right-round',
            3
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-top-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-bottom-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-left-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'border-right-width',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-left',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-top',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );
        this.partProperties.setPropertyNamed(
            this,
            'shadow-blur',
            1
        );

    }

    get type(){
        return 'button';
    }

    //TODO: implement this property
    // getter for real
    getSelectedText(propName, propVal){
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Card.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Card.js ***!
  \**********************************/
/*! exports provided: Card, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Card", function() { return Card; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Card; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Card
 * --------------------------
 * I am a Card Part.
 * I represent a collection of Parts that is
 * displayed on the screen. My owner is always
 * a Stack Part.
 * I can contain any kind of Part, including
 * buttons and fields.
 */





class Card extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, name){
        super(owner);
        this.stack = this._owner;
        this.acceptedSubpartTypes = [
            "window", "button",
            "field", "field", "area", "drawing",
            "image", "audio", "browser", "resource"
        ];
        this.isCard = true;

        // Add Card-specific part
        // properties
        this.partProperties.newBasicProp(
            'marked',
            false
        );
        this.partProperties.newBasicProp(
            'cantDelete',
            false
        );
        this.partProperties.newBasicProp(
            'dontSearch',
            false
        );
        this.partProperties.newBasicProp(
            'showPict',
            false
        );

        // If we are initializing with a name
        // set the name property
        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Styling
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addLayoutStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(0, 75, 103)" // palette-blue
        );
    }

    get type(){
        return 'card';
    }
};




/***/ }),

/***/ "./js/objects/parts/Drawing.js":
/*!*************************************!*\
  !*** ./js/objects/parts/Drawing.js ***!
  \*************************************/
/*! exports provided: Drawing, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Drawing", function() { return Drawing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Drawing; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Basic User Drawing Part
 */



const sides = ["top", "bottom", "left", "right"];

class Drawing extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner){
        super(owner);

        // Set new properties for this
        // part type
        this.partProperties.newBasicProp(
            'image',
            null
        );
        this.partProperties.newBasicProp(
            'mode',
            'drawing'
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                1,
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "rgb(238, 238, 238)", //grey
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-transparency`,
                0.5,
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            'width',
            300
        );
        this.partProperties.setPropertyNamed(
            this,
            'height',
            200
        );

        // We are using a distinct show-border
        // property to deal with being able to see
        // a drawing that is empty
        this.partProperties.newBasicProp(
            'show-border',
            true
        );

        // When drawing from a script/commands,
        // we will use this as the open canvas
        // whose image bytes will be set to the
        // image property
        this.activeCanvas = null;

        // Set up the drawing commands
        this.setupDrawingCommands();


        // Bind component methods
        this.setupDrawingCommands = this.setupDrawingCommands.bind(this);
        this.stroke = this.stroke.bind(this);
        this.moveTo = this.moveTo.bind(this);
        this.lineTo = this.lineTo.bind(this);
        this.beginDraw = this.beginDraw.bind(this);
        this.endDraw = this.endDraw.bind(this);
        this.clear = this.clear.bind(this);
        this.coordsFromString = this.coordsFromString.bind(this);
    }

    get type(){
        return 'drawing';
    }

    setupDrawingCommands(){
        this.setPrivateCommandHandler('lineTo', (senders, ...args) => {
            this.lineTo(...args);
        });
        this.setPrivateCommandHandler('moveTo', (senders, ...args) => {
            this.moveTo(...args);
        });
        this.setPrivateCommandHandler('beginDraw', (senders, ...args) => {
            this.beginDraw(...args);
        });
        this.setPrivateCommandHandler('finishDraw', (senders, ...args) => {
            this.endDraw(...args);
        });
        this.setPrivateCommandHandler('stroke', (senders, ...args) => {
            this.stroke(...args);
        });
        this.setPrivateCommandHandler('clear', (senders, ...args) => {
            this.clear(...args);
        });
    }

    /* Scriptable Drawing Commands */
    stroke(){
        if(this.isDrawing){
            // Hard-coded. Get from props
            // and link to views
            this.activeContext.strokeWidth = 10;
            this.activeContext.stroke();
        }
    }
    moveTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.moveTo(
                x,
                y
            );
        }
    }

    lineTo(x, y){
        if(this.isDrawing){
            //let coords = this.coordsFromString(coordPair);
            this.activeContext.lineTo(
                x,
                y
            );
        }
    }

    beginDraw(){
        if(this.isDrawing){
            return;
        }
        this.isDrawing = true;
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');

        // If there is currently image data set to the
        // image part property, we need to draw that image
        // onto the canvas first.
        let currentImage = this.partProperties.getPropertyNamed(
            this,
            'image'
        );
        if(currentImage){
            let img = new Image();
            img.onload = () => {
                this.activeContext.drawImage(img, 0, 0);
            };
            img.src = currentImage;
        }

        // Begin a drawing path
        this.activeContext.beginPath();
    }

    endDraw(){
        if(this.isDrawing){
            this.activeContext.closePath();
            this.activeContext.stroke();

            // Update the image property to be the
            // serialized version of the current image.
            // This will update any subscribed views
            this.partProperties.setPropertyNamed(
                this,
                'image',
                this.activeCanvas.toDataURL()
            );
            this.activeCanvas = null;
            this.activeContext = null;
            this.isDrawing = false;
        }
    }

    clear(){
        if(this.isDrawing){
            return;
        }
        this.activeCanvas = document.createElement('canvas');
        this.activeCanvas.width = this.partProperties.getPropertyNamed(
            this,
            'width'
        );
        this.activeCanvas.height = this.partProperties.getPropertyNamed(
            this,
            'height'
        );
        this.activeContext = this.activeCanvas.getContext('2d');
        this.partProperties.setPropertyNamed(
            this,
            'image',
            this.activeCanvas.toDataURL()
        );
        this.activeCanvas = null;
        this.activeContext = null;
    }

    /* Utility Methods for Scriptable Drawing */
    coordsFromString(coordString){
        let pair = coordString.split(",");
        let x = parseInt(pair[0]);
        let y = parseInt(pair[1]);
        return {x, y};
    }
};




/***/ }),

/***/ "./js/objects/parts/Field.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Field.js ***!
  \***********************************/
/*! exports provided: Field, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return Field; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Field
 * -----------------------------------------
 * I am a Field Part.
 * I am a container that holds text. I also allow
 * a user to edit my text.
 */





const sides = ["top", "bottom", "left", "right"];

class Field extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name){
        super(owner);

        this.acceptedSubpartTypes = ["field"];

        this.isField = true;

        if(name){
            this.partProperties.setPropertyNamed(
                this,
                'name',
                name
            );
        }

        // Set the Field-specific
        // Part Properties
        this.partProperties.newBasicProp(
            'mode',
            'editing' //TODO this should be either "bravo" or "simpletalk"
        );

        this.partProperties.newBasicProp(
            'innerHTML',
            ''
        );

        this.partProperties.newBasicProp(
            'targetRangeId',
            null
        );

        // 'text' is a DynamicProperty configured to also set the innerHTML
        // BasicProperty when changed. The basic idea is that 'text' will be
        // the property that ST will interface with and everytime it
        // is changed the 'innerHTML' property should follow.
        this.partProperties.newDynamicProp(
            'text',
            (owner, prop, value, notify) => {
                prop._value = value;
                if(notify){
                    /*
                    if(!value){
                        value = "<br>";
                    }
                    // replace all newline characters with <br>
                    value = value.replace(/\n/g, "<br>");
                    */
                    owner.partProperties.setPropertyNamed(owner, 'innerHTML', value, notify);
                }
            },
            (owner, prop) => {
                return prop._value;
            },
            false, // not read only
            ''     // default is empty string
        );

        this.partProperties.newBasicProp(
            'editable',
            true
        );


        // A number of the props deal with direct text editing,
        // and so they are like commands. Examples include "undo"
        // "redo" "clear" etc. Here we use dynami props which the
        // view can respond to accordingly, but having these props have
        // no actual 'state'
        /** TODO: these should be private commands
        this.partProperties.newDynamicProp(
            "undo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "redo",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        this.partProperties.newDynamicProp(
            "remove-format",
            () => {}, // all we is a notification
            () => {} // no getter
        );
        **/

        // Styling
        // setting width and height to null
        // effectively forces to the default size
        // of the button to fit the button name
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "rgb(255, 248, 220)", // var(--palette-cornsik)
        );
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "medium",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-style`,
                "solid",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-color`,
                "black",
            );
        });
        sides.forEach((s) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${s}-width`,
                "1",
            );
        });
        this.partProperties.setPropertyNamed(
            this,
            "width",
            400,
        );

        // Private command handlers

        this.insertRange = this.insertRange.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.setPrivateCommandHandler("insertRange", this.insertRange);
        this.setPrivateCommandHandler("setSelection", this.setSelection);
        this.setPrivateCommandHandler("highlightSyntax", this.highlightSyntax);
        this.setPrivateCommandHandler("unhighlightSyntax", this.unhighlightSyntax);
    }

    insertRange(senders, rangeId, html, css){
        window.System.findViewsById(this.id).forEach((view) => {
            view.insertRange(rangeId, html, css);
        });
    }

    setSelection(senders, propertyName, propertyValue){
        // for now just allow properties of type "text-*" to be set
        if(propertyName.startsWith("text-")){
            window.System.findViewsById(this.id).forEach((view) => {
                view.setSelection(propertyName, propertyValue);
            });
        }
    }

    highlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.highlightSyntax();
        }
    }

    unhighlightSyntax(){
        let view = window.System.findViewById(this.id);
        if(view){
            view.unhighlightSyntax();
        }
    }

    get type(){
        return 'field';
    }
};




/***/ }),

/***/ "./js/objects/parts/Image.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Image.js ***!
  \***********************************/
/*! exports provided: Image, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return Image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Image; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");




class Image extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);

        // Properties
        this.partProperties.newDynamicProp(
            "src",
            this.setSource,
            this.getSource
        );

        this._src = src;

        this.partProperties.newBasicProp(
            "mimeType",
            "unknown"
        );

        this.partProperties.newBasicProp(
            "imageData",
            null
        );

        this.partProperties.newBasicProp(
            'draggable',
            false
        );

        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        this.partProperties.setPropertyNamed(
            this,
            'background-color',
            "black"
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadImageFrom", this.loadImageFromSource);
        this.setPrivateCommandHandler("loadImageFromFile", this.loadImageFromFile);

        // Bind component methods
        this.loadImageFromSource = this.loadImageFromSource.bind(this);
        this.loadImageFromFile = this.loadImageFromFile.bind(this);
    }


    loadImageFromSource(senders, sourceUrl){
        fetch(sourceUrl)
            .then(response => {
                let contentType = response.headers.get('content-type');
                if(!contentType.startsWith('image')){
                    throw new Error(`Invalid image mimeType: ${contentType}`);
                }
                this.partProperties.setPropertyNamed(
                    this,
                    "mimeType",
                    contentType
                );
                if(contentType.startsWith("image/svg")){
                    return response.text().then(text => {
                        this.partProperties.setPropertyNamed(
                            this,
                            'imageData',
                            text
                        );
                    });
                } else {
                    return response.blob().then(blob => {
                        let reader = new FileReader();
                        reader.onloadend = () => {
                            this.partProperties.setPropertyNamed(
                                this,
                                'imageData',
                                reader.result // will be the base64 encoded data
                            );
                        };
                        reader.readAsDataURL(blob);
                    });
                }
            })
            .then(() => {
                // Manually set the _src.
                // This ensures that we don't infinitely
                // call the load operation
                this._src = sourceUrl;
            })
            .catch(err => {
                console.error(err);
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    null
                );
            });
    }

    loadImageFromFile(){
        let filePicker = document.createElement('input');
        filePicker.type = 'file';
        filePicker.setAttribute('accept', 'image/*');
        filePicker.style.display = 'none';
        filePicker.addEventListener('change', (event) => {
            // Handle the file here
            let reader = new FileReader();
            reader.onloadend = () => {
                this.partProperties.setPropertyNamed(
                    this,
                    'mimeType',
                    filePicker.files[0].type
                );
                this.partProperties.setPropertyNamed(
                    this,
                    'imageData',
                    reader.result
                );
            };
            let imageFile = filePicker.files[0];
            if(imageFile.type.includes('svg')){
                reader.readAsText(imageFile);
            } else {
                reader.readAsDataURL(imageFile);
            }
            filePicker.remove();
        });
        document.body.append(filePicker);
        filePicker.click();
    }

    setSource(owner, property, value){
        owner._src = value;
        if(value){
            owner.loadImageFromSource([this], value);
        }
    }

    getSource(owner, property){
        return owner._src;
    }

    get type(){
        return 'image';
    }

    get isSvg(){
        let mimeType = this.partProperties.getPropertyNamed(
            this,
            "mimeType"
        );
        if(!mimeType){
            return false;
        }

        return mimeType.startsWith('image/svg');
    }
};




/***/ }),

/***/ "./js/objects/parts/Part.js":
/*!**********************************!*\
  !*** ./js/objects/parts/Part.js ***!
  \**********************************/
/*! exports provided: Part, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Part", function() { return Part; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Part; });
/* harmony import */ var _utils_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/errorHandler.js */ "./js/objects/utils/errorHandler.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/* harmony import */ var _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ExecutionStack.js */ "./js/objects/ExecutionStack.js");
/**
 * Part
 * -------------------------------
 * I represent the prototype object for all
 * SimpleTalk parts.
 */







class Part {
    constructor(anOwnerPart, name, deserializing=false){

        this.name = this.constructor.name;

        // An array of child parts
        this.subparts = [];
        // a list of all accepted subparts by type
        // By default this is null and each Part subclcass should
        // specify if otherwise
        this.acceptedSubpartTypes = [];

        this.partProperties = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["PartProperties"]();
        this._owner = anOwnerPart;
        this._commandHandlers = {};
        this._privateCommandHandlers = {};
        this._functionHandlers = {};
        this._scriptSemantics = {};
        this._propertySubscribers = new Set();
        this._viewSubscribers = new Set();
        this._stepIntervalId = null;

        this.isPart = true;

        // Bind methods
        this.setupProperties = this.setupProperties.bind(this);
        this.setupStyleProperties = this.setupStyleProperties.bind(this);

        this.addPart = this.addPart.bind(this);
        this.removePart = this.removePart.bind(this);
        this.acceptsSubpart = this.acceptsSubpart.bind(this);
        this.setPrivateCommandHandler = this.setPrivateCommandHandler.bind(this);
        this.removePrivateCommandHandler = this.removePrivateCommandHandler.bind(this);
        this.setFuncHandler = this.setFuncHandler.bind(this);
        this.receiveCmd = this.receiveCmd.bind(this);
        this.receiveFunc = this.receiveFunc.bind(this);
        this.receiveError = this.receiveError.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.delegateMessage = this.delegateMessage.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.addPropertySubscriber = this.addPropertySubscriber.bind(this);
        this.removePropertySubscriber = this.removePropertySubscriber.bind(this);
        this.addViewSubscriber = this.addViewSubscriber.bind(this);
        this.removeViewSubscriber = this.removeViewSubscriber.bind(this);
        this.serialize = this.serialize.bind(this);
        this.toJSON = this.toJSON.bind(this);
        this.setPropsFromDeserializer = this.setPropsFromDeserializer.bind(this);
        this.findAncestorOfType = this.findAncestorOfType.bind(this);
        this.openEditorCmdHandler = this.openEditorCmdHandler.bind(this);
        this.closeEditorCmdHandler = this.closeEditorCmdHandler.bind(this);
        this.copyCmdHandler = this.copyCmdHandler.bind(this);
        this.pasteCmdHandler = this.pasteCmdHandler.bind(this);
        this.isSubpartOfCurrentCard = this.isSubpartOfCurrentCard.bind(this);
        this.isSubpartOfCurrentStack = this.isSubpartOfCurrentStack.bind(this);
        this.getOwnerBranch = this.getOwnerBranch.bind(this);
        this.startStepping = this.startStepping.bind(this);
        this.stopStepping = this.stopStepping.bind(this);
        this.setTargetProp = this.setTargetProp.bind(this);
        this.move = this.move.bind(this);
        this.moveSubpartUp = this.moveSubpartUp.bind(this);
        this.moveSubpartDown = this.moveSubpartDown.bind(this);
        this.moveSubpartToFirst = this.moveSubpartToFirst.bind(this);
        this.moveSubpartToLast = this.moveSubpartToLast.bind(this);



        // Finally, we finish initialization
        this.setupProperties();

        // command handlers
        this.setPrivateCommandHandler("openEditor", this.openEditorCmdHandler);
        this.setPrivateCommandHandler("closeEditor", this.closeEditorCmdHandler);
        this.setPrivateCommandHandler("setTargetTo", this.setTargetProp);
        this.setPrivateCommandHandler("copy", this.copyCmdHandler);
        this.setPrivateCommandHandler("paste", this.pasteCmdHandler);
        this.setPrivateCommandHandler("move", this.move);
        this.setPrivateCommandHandler("moveUp", () => {this._owner.moveSubpartUp(this);});
        this.setPrivateCommandHandler("moveDown", () => {this._owner.moveSubpartDown(this);});
        this.setPrivateCommandHandler("moveToFirst", () => {this._owner.moveSubpartToFirst(this);});
        this.setPrivateCommandHandler("moveToLast", () => {this._owner.moveSubpartToLast(this);});
    }

    // Convenience getter to get the id
    // from the partProperties
    get id(){
        return this.partProperties.getPropertyNamed(this, 'id');
    }

    set id(val){
        return this.partProperties.setPropertyNamed(this, 'id', val);
    }


    // Return an array of names of all of my and my ancestors' handlers
    // for the moment this is just names, type, id and whether the handler overrides
    // an owner's, but could be richer info, such as arguments, documentation etc
    get commandHandlerRegistry(){
        let handlersInfo = {};
        let ownerBranch = this.getOwnerBranch();
        for(let i = 1; i <= ownerBranch.length; i++){
            let part = ownerBranch[ownerBranch.length - i];
            let partType = part.type;
            if(part.id === -1){
                partType = "System";
            } else {
                // System doesn't have private command handlers
                Object.keys(part._privateCommandHandlers).forEach((h) => {
                    let override = false;
                    if(handlersInfo[h]){
                        override = true;
                    }
                    handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: true};
                });
            }
            Object.keys(part._commandHandlers).forEach((h) => {
                let override = false;
                if(handlersInfo[h]){
                    override = true;
                }
                handlersInfo[h] = {partId: part.id, partType: partType, override: override, private: false};
            });
        }
        return handlersInfo;
    }

    // returns the this.part -> System branch by part id
    getOwnerBranch(branch){
        if(!branch){
            branch = [this];
        }
        if(this.type === "world"){
            branch.push(window.System);
            return branch;
        } else {
            branch.push(this._owner);
        };
        return this._owner.getOwnerBranch(branch);
    }

    // Configures the specific properties that the
    // given part can expect, along with any default
    // values.
    // Descendant Parts should override this method
    // in their own constructor after calling super,
    // so that they get the parent's general properties
    // too.
    setupProperties(){
        // Here, we set up properties common
        // to ALL Parts in the system.
        let basicProps = [
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'target',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'contents',
                null,
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'enabled',
                true
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'wants-move',
                false
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'id',
                _utils_id_js__WEBPACK_IMPORTED_MODULE_0__["idMaker"].new()
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'name',
                `New ${this.type}`
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'rectangle',
                "0, 0, 0, 0",
                true,
                ['rect']
            ),
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'script',
                null // For now
            ),

            // Styling
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssStyle',
                {},
                false,
            ),
            // css (really JS style) key-values
            new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](
                'cssTextStyle',
                {},
                false,
            )
        ];
        basicProps.forEach(prop => {
            this.partProperties.addProperty(prop);
        });

        // the index number of the part in part._owner.subpart
        // array. Note: this is 1-indexed
        this.partProperties.newDynamicProp(
            'number',
            null, // no setter
            function(propOwner, propObject){
                if(propOwner.type == "world"){
                    return 1;
                }
                return propOwner._owner.subparts.indexOf(propOwner) + 1;
            },
            true // readonly
        );

        this.partProperties.newDynamicProp(
            'target',
            function(propOwner, propObject, val){
                // check to see if the target is a non-ID
                let id = Object(_utils_id_js__WEBPACK_IMPORTED_MODULE_0__["isValidId"])(val);
                if(id){
                    // if it is an ID insert "part" since our
                    // grammar doesn't handle ID without system object
                    // prefixes
                    propObject._value = `part id ${val}`;
                } else {
                    propObject._value = val;
                }
            },
            function(propOwner, propObject){
                return propObject._value;
            },
            false,
            null,
        ),

        // Custom Properties store props defined within the
        // ST environment
        this.partProperties.newCustomProp(
        ),

        // Stepping related props

        this.partProperties.newDynamicProp(
            // The time in milliseconds between
            // sends of the step command if the
            // stepping property is set to true
            'stepTime',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(propOwner.isStepping){
                    // Interrupt the current interval
                    // and restart with new stepTime
                    propOwner.stopStepping();
                    this._value = value;
                    propOwner.startStepping();
                } else{
                    this._value = value;
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                return this._value;
            },
            false, // can read and write
            500 // Default to half a second
        );

        this.partProperties.newDynamicProp(
            'stepping',
            // Dynamic setter
            function(propOwner, propObject, value){
                if(value === false && propOwner.isStepping){
                    propOwner.stopStepping();
                } else if(value === true && !propOwner.isStepping){
                    propOwner.startStepping();
                }
            },
            // Dynamic getter
            function(propOwner, propObject){
                // If the intervalId is set, then
                // the Part is currently stepping
                return propOwner.isStepping;
            },
        );

    }

    // To be called in each sub-class that has StyleProperties
    // called after the style props are configured
    setupStyleProperties(){
        this.partProperties._properties.forEach((prop) => {
            if(prop.constructor.name === "StyleProperty"){
                // setting the value on itself ensures that the cssStyle
                // BasicProperty is updated with the appropriate styler
                // conversion css key-val
                prop.setValue(this, prop._value);
            }
        });
    }

    /** Subpart Access **/
    /**
     * Each subclass will implement its own set of checks,
     * and throw an approprite error if the subpart type is invalid.
     */
    acceptsSubpart(aPartType){
        if (this.acceptedSubpartTypes[0] === "*"){
            return true;
        }
        return this.acceptedSubpartTypes.includes(aPartType.toLowerCase());
    }

    /**
     * Adds a part to this part's subparts
     * collection, if not already present.
     * It will also set the owner of the
     * added part to be this part.
     */
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            this.subparts.push(aPart);
            aPart._owner = this;
        }
    }

    /**
     * Removes the given part from this
     * part's list of subparts (if present).
     * It will also unset the owner of the
     * given part.
     */
    removePart(aPart){
        let partIndex = this.subparts.indexOf(aPart);
        if(partIndex >= 0){
            this.subparts.splice(partIndex, 1);
            aPart._owner = null;
        }
    }

    /** Checks whether the Part instance is a subpart of the current
     * Card.
     */
    isSubpartOfCurrentCard(){
    }

    /** Checks whether the Part instance is a subpart of the current
     * Stack.
     */
    isSubpartOfCurrentStack(){
    }

    /** Logging and Reporting **/
    shouldBeImplemented(functionName){
        let msg = `${this.constructor.name} should implement ${functionName}`;
        throw new Error(msg);
    }

    /** Message Handling and Delegation **/
    delegateMessage(aMessage){
        return this.sendMessage(
            aMessage,
            this._owner
        );
    }

    sendMessage(aMessage, target){
        return window.System.sendMessage(aMessage, this, target);
    }

    receiveMessage(aMessage){
        // By default, Parts will only handle
        // messages of type 'command' and 'function'
        switch(aMessage.type){
            case 'command':
                return this.receiveCmd(aMessage);
                //break;
            case 'function':
                return this.receiveFunc(aMessage);
                //break;
            case 'error':
                return this.receiveError(aMessage);
            default:
                return this.delegateMessage(aMessage);
        }
    }

    receiveError(aMessage){
        return _utils_errorHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].handle(aMessage);
    }

    receiveCmd(aMessage){
        let handler = this._commandHandlers[aMessage.commandName];
        if(handler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = handler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        let privateHandler = this._privateCommandHandlers[aMessage.commandName];
        if(privateHandler){
            // If this Part has a handler for
            // the given command, we run it.
            // We also late-bind the current part
            // instance as the 'this' context for
            // the handler
            let boundHandler = privateHandler.bind(this);
            var activation = new _ExecutionStack_js__WEBPACK_IMPORTED_MODULE_3__["ActivationContext"](
                aMessage.commandName,
                this,
                aMessage,
                boundHandler
            );
            window.System.executionStack.push(activation);
            var result = boundHandler(aMessage.senders, ...aMessage.args);
            window.System.executionStack.pop();
            return result;
        }

        // Otherwise, we have no handler for
        // it. Unless the message indicates shouldNotDelegate
        // we delegate along the
        // message delegation chain. It is up
        // to Parts to properly implement delegation
        // for themselves!
        if(aMessage.shouldNotDelegate){
            return aMessage;
        }
        return this.delegateMessage(aMessage);
    }

    receiveFunc(aMessage){
        let handler = this._functionHandlers[aMessage.functionName];

        if(handler){
            let boundHandler = handler.bind(this);
            return boundHandler();
        } else {
            return this.delegateMessage(aMessage);
        }
    }

    setPrivateCommandHandler(commandName, handler){
        this._privateCommandHandlers[commandName] = handler;
    }

    removePrivateCommandHandler(commandName){
        delete this._privateCommandHandlers[commandName];
    }

    setFuncHandler(funcName, handler){
        this._functionHandlers[funcName] = handler;
    }

    /** Command Handlers
        ----------------
        Command handlers which are invoked at the Part level
        which are not immediately delegaed to the Part._owner
    **/

    openEditorCmdHandler(){
        let editor = document.querySelector('st-editor');
        editor.render(this);
        if(!editor.isOpen){
            editor.open();
        }
    }

    closeEditorCmdHandler(){
        let editor = document.querySelector('st-editor.open');
        if(editor){
            editor.close();
        }
    }

    setTargetProp(senders, ...args){
        let target = args.join(" ");
        this.partProperties.setPropertyNamed(this, "target", target);
    }

    copyCmdHandler(){
        window.System.clipboard.copyPart(this);
    }

    pasteCmdHandler(){
        if(!window.System.clipboard.isEmpty){
            let item = window.System.clipboard.contents[0];
            if(item.type == 'simpletalk/json' && this.acceptsSubpart(item.partType)){
                window.System.clipboard.pasteContentsInto(this);
            }
        }
    }

    move(senders, movementX, movementY){
        if(!this.partProperties.getPropertyNamed(this, "wants-move")){
            throw Error(`Part ${this.id} trying to move with 'wants-move' property false`);
        }
        let top = this.partProperties.getPropertyNamed(this, "top");
        top += movementY;
        this.partProperties.setPropertyNamed(this, "top", top);
        let left = this.partProperties.getPropertyNamed(this, "left");
        left += movementX;
        this.partProperties.setPropertyNamed(this, "left", left);
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex < this.subparts.length - 1){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        if(currentIndex > 0){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    // Note: moveSubpartToFirst means move to first in the view
    // i.e. last as a subaprt
    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, 0);
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        this.subpartOrderChanged(part.id, currentIndex, this.subparts.length - 1);
    }

    /** Property Subscribers
        ------------------------
        Objects added as property subscribers
        will be 'notified' whenever one of this
        Part's properties changes
    **/
    addPropertySubscriber(anObject){
        this._propertySubscribers.add(anObject);
    }

    removePropertySubscriber(anObject){
        this._propertySubscribers.delete(anObject);
    }

    propertyChanged(propertyName, newValue){
        let message = {
            type: 'propertyChanged',
            propertyName: propertyName,
            value: newValue,
            partId: this.id
        };
        this._propertySubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    /** View Subscribers
        ------------------------
        Objects added as view subscribers
        will be 'notified' whenever this Part
        incurrs a view change (add, delete subparts, reorder etc)
    **/
    addViewSubscriber(anObject){
        this._viewSubscribers.add(anObject);
    }

    removeViewSubscriber(anObject){
        this._viewSubscribers.delete(anObject);
    }

    viewChanged(changeName, ...args){
        let message = {
            type: 'viewChanged',
            changeName: changeName,
            partId: this.id,
            args: args
        };
        this._viewSubscribers.forEach(subscriber => {
            this.sendMessage(message, subscriber);
        });
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpart = this.subparts.splice(currentIndex, 1)[0];
        this.subparts.splice(newIndex, 0, subpart);
        this.viewChanged("subpart-order", id, currentIndex, newIndex);
    }

    startStepping(){
        if(this._stepIntervalId){
            this.stopStepping();
        }
        let stepTime = this.partProperties.getPropertyNamed(
            this,
            'stepTime'
        );
        if(stepTime > 0){
            this._stepIntervalId = setInterval(() => {
                this.sendMessage({
                    type: 'command',
                    commandName: 'step',
                    args: []
                }, this);
            }, stepTime);
        }
    }

    stopStepping(){
        clearInterval(this._stepIntervalId);
        this._stepIntervalId = null;
    }

    get isStepping(){
        // We know the Part is currently stepping
        // of the stored intervalId is set to
        // something besides null
        return this._stepIntervalId !== null;
    }

    /**
     * Serialize this Part's state as JSON.
     * By default, we do not serialize specific
     * PartCollection information (recursively),
     * and only include basics including the current
     * state of all properties.
     */
    serialize(){
        let ownerId = null;
        if(this._owner){
            ownerId = this._owner.id;
        }
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: ownerId
        };
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    /**
     * Set the properties and other
     * attributes of this Part model
     * from a deserialized JSON object.
     */
    setPropsFromDeserializer(incomingProps, deserializer){
        Object.keys(incomingProps).forEach(propName => {
            let property = this.partProperties.findPropertyNamed(propName);
            if(!property){
                // If some old or invalid property is
                // present in the deserialization, simply provide
                // a warning and then skip this one.
                console.warn(`Deserialized property "${propName}" is not a valid property name for ${this.type} (id ${this.id}) and will be ignored`);
            } else if(propName == "custom-properties"){
                // custom properties are serialized as an object like other props
                // and we need to create properties from these and set their respective
                // values. Then we need to set the value of "custom-properties" prop
                // itself to be the object containing all of these
                let customPropsData = incomingProps[propName];
                let newCustomPropsObject = {};
                Object.values(customPropsData).forEach((propData) => {
                    let newProp = new _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__["BasicProperty"](propData.name, null);
                    newProp.setValue(this, propData._value, false); // no need to notify
                    newCustomPropsObject[propData.name] = newProp;
                });
                property.setValue(this, newCustomPropsObject, false); // no need to notify
            } else if(!property.readOnly){
                // Last arg is false, which tells the property
                // not to notify its owner's subscribers of
                // property changes. We don't need that when
                // deserializing
                property.setValue(this, incomingProps[propName], false);
            }
        });
    }

    toJSON(){
        return this.serialize();
    }

    findAncestorOfType(aPartType){
        let owner = this._owner;
        while(owner){
            if(owner.type == aPartType){
                return owner;
            }
            owner = owner._owner;
        }
        return null;
    }
};




/***/ }),

/***/ "./js/objects/parts/Resource.js":
/*!**************************************!*\
  !*** ./js/objects/parts/Resource.js ***!
  \**************************************/
/*! exports provided: Resource, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return Resource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Resource; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");



class Resource extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["Part"] {
    constructor(owner, src) {
        super(owner);
        this.resource = null;

        // Properties
        this.partProperties.newBasicProp(
            "src",
            null
        );

        this.src = null;

        this.partProperties.newBasicProp(
            'readyState',
            "notReady"
        );

        this.partProperties.newBasicProp(
            "prerequisite",
            null
        );

        this.partProperties.newBasicProp(
            "resourceName",
            null
        );

        this.partProperties.newBasicProp(
            "response",
            null
        );

        // Private command handlers
        this.setPrivateCommandHandler("loadResource", this.loadResource);
        this.setPrivateCommandHandler("setSourceTo", this.setSourceTo);
        this.setPrivateCommandHandler("get", this.get);

        // Bind component methods
        this.loadResource = this.loadResource.bind(this);
        this.get = this.get.bind(this);
        this.reset = this.reset.bind(this);

        // load the src if provided
        if(src){
            this.partProperties.setPropertyNamed(this, "src", url);
        }
        // Style properties
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addPositioningStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_1__["addTextStyleProps"])(this);
        this.setupStyleProperties();
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.partProperties.setPropertyNamed(
                this,
                `border-${side}-width`,
                1
            );
        });
    }

    get type(){
        return 'resource';
    }

    loadResource(senders, resourceName){
        if(!window.System.availableResources || !window.System.availableResources[resourceName]){
            // TODO this should be a ST error
            throw Error(`resource ${resourceName} not found`);
        }
        this.resource = window.System.availableResources[resourceName];
        this.partProperties.setPropertyNamed(this, "resourceName", resourceName);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();
    }

    setSourceTo(senders, sourceUrl){
        if(!this.resource){
            // TODO this should be a ST error
            throw Error(`no resource loaded for resource part id ${this.id}`);
        }
        this.partProperties.setPropertyNamed(this, "src", sourceUrl);
        this.resource.load(sourceUrl);
        // we can't guarantee the state of a resource and so it should be re-set every time
        this.reset();

    }

    get(senders, ...args){
        this.partProperties.setPropertyNamed(this, "readyState", "fetching");
        let prerequisite = this.partProperties.getPropertyNamed(this, "prerequisite");
        this.resource.get(prerequisite, ...args).then((response) => {
            this.partProperties.setPropertyNamed(this, "response", response);
            this.partProperties.setPropertyNamed(this, "readyState", "ready");
            this.sendMessage({
                type: "command",
                commandName: "responded",
                args: [this.id, this.resource.name],
                shouldIgnore: true
            }, this);
        }, (error) => {
            this.partProperties.setPropertyNamed(this, "readyState", "error");
            this.partProperties.setPropertyNamed(this, "response", null);
            this.sendMessage({
                type: "command",
                commandName: "errored",
                args: [this.id, this.resource.name, error.message],
                shouldIgnore: true
            }, this);
        });
    }

    reset(){
        this.partProperties.setPropertyNamed(this, "readyState", "notReady");
        this.partProperties.setPropertyNamed(this, "response", null);
    }
};




/***/ }),

/***/ "./js/objects/parts/Stack.js":
/*!***********************************!*\
  !*** ./js/objects/parts/Stack.js ***!
  \***********************************/
/*! exports provided: Stack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Card_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Card.js */ "./js/objects/parts/Card.js");
/* harmony import */ var _properties_PartProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../properties/PartProperties.js */ "./js/objects/properties/PartProperties.js");
/**
 * Stack
 * ----------------------------
 * I am the Stack Part.
 * I represent a collection of Card parts,
 * along with some extra configurability.
 */




class Stack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, deserializing=false){
        super(owner);
        this.acceptedSubpartTypes = [
            "card", "window", "button", "area", "field",
            "drawing", "image", "audio", "browser"
        ];

        // Set up Stack specific
        // PartProperties
        this.partProperties.newBasicProp(
            'cantPeek',
            false
        );
        this.partProperties.newBasicProp(
            'resizable',
            false
        );


        // Will hold the card-based index,
        // which here is zero-indexed, of the
        // card that is the current card for this
        // Stack.
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Bind general methods
        this.sendOpenCardTo = this.sendOpenCardTo.bind(this);
        this.sendCloseCardTo = this.sendCloseCardTo.bind(this);

        // Bind stack navigation methods
        this.goToNextCard = this.goToNextCard.bind(this);
        this.goToPrevCard = this.goToPrevCard.bind(this);
        this.goToCardById = this.goToCardById.bind(this);
        this.goToNthCard = this.goToNthCard.bind(this);
    }

    goToNextCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= cards.length){
            nextIdx = (nextIdx % cards.length);
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToCardById(anId){
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let cards = Object.values(window.System.partsById).filter((part) => {
            return part.type == "card";
        });
        let nextCard = cards.find(card => {
            return card.id == anId;
        });
        if(!nextCard){
            throw new Error(`The card id: ${anId} cant be found stack`);
        }
        // if the card is not on this stack we should go to the corresponding stack
        if(nextCard._owner != this){
            this._owner.goToStackById(nextCard._owner.id);
        }
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToPrevCard(){
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(cards.length < 2){
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let currentIdx = cards.indexOf(currentCard);

        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = cards.length + nextIdx;
        }
        let nextCard = cards[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    goToNthCard(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let cards = this.subparts.filter(subpart => {
            return subpart.type == 'card';
        });
        if(trueIndex < 0 || trueIndex > cards.length -1){
            console.warn(`Cannot navigate to card number ${anIndex} -- out of bounds`);
            return;
        }
        let currentCardId = this.currentCardId;
        let currentCard = this.currentCard;
        let nextCard = cards[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
           nextCard.id
        );
        if(currentCardId != nextCard.id){
            this.sendCloseCardTo(currentCard);
            this.sendOpenCardTo(nextCard);
        }
    }

    sendCloseCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    sendOpenCardTo(aCard){
        this.sendMessage(
            {
                type: 'command',
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            },
            aCard
        );
    }

    get type(){
        return 'stack';
    }

    get currentCardId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentCard(){
        return window.System.partsById[this.currentCardId];
    }

    // override the base class methods
    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            lastValidPartIndex = allCards.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "card"){
            let allCards = this.subparts.filter((part) => {
                return part.type == "card";
            });
            firstValidPartIndex = allCards.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a card then append after the last card
            if(aPart.type == "card"){
                let allCards = this.subparts.filter((part) => {
                    return part.type == "card";
                });
                this.subparts.splice(allCards.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }
};




/***/ }),

/***/ "./js/objects/parts/Window.js":
/*!************************************!*\
  !*** ./js/objects/parts/Window.js ***!
  \************************************/
/*! exports provided: Window, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Window", function() { return Window; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Window; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stack.js */ "./js/objects/parts/Stack.js");
/* harmony import */ var _utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/styleProperties.js */ "./js/objects/utils/styleProperties.js");
/**
 * Window Part
 * ------------------------
 * A Window is a Part that wraps another
 * Part of type Card, Stack, or WorldStack
 * in a moveable window.
 * I can also optionally hold a reference
 * to a target Part that I do not own. I call
 * this JS property target and I store the
 * target part's id as a HyperTalk property
 * called targetId.
 * When my owner part is the current view, I
 * will be visible on top of everything else.
 */




class Window extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(owner, name, target, deserializing=false){
        super(owner, name);

        this.acceptedSubpartTypes = [
            "area",
            "button",
            "field",
            "image",
            "audio",
            "resource",
            "drawing",
        ];

        // If we pass in a target,
        // set it.
        if(target){
            this.setTarget(target);
        }

        // Set up Window specific
        // part ptoperties
        this.partProperties.newBasicProp(
            'targetId',
            null
        );

        this.partProperties.newBasicProp(
            'title',
            "New Window Title"
        );

        this.partProperties.newBasicProp(
            'isResizable',
            true
        );
        // Style
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addBasicStyleProps"])(this);
        Object(_utils_styleProperties_js__WEBPACK_IMPORTED_MODULE_2__["addPositioningStyleProps"])(this);
        this.setupStyleProperties();
        // part specific default style properties
        this.partProperties.setPropertyNamed(
            this,
            'background-transparency',
            0
        );

        // Bind methods
        this.setTarget = this.setTarget.bind(this);
        this.onWindowClose = this.onWindowClose.bind(this);

        // Add private handlers
        this.setPrivateCommandHandler('windowClose', this.onWindowClose);
    }

    setTarget(aPart){
        this.target = aPart;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            this.target.id
        );
    }

    unsetTarget(){
        this.target = null;
        this.partProperties.setPropertyNamed(
            this,
            'targetId',
            null
        );
    }

    /**
     * Override
     * Unlike other kinds of Parts, a window
     * has only one subpart, which should be
     * Card, Stack, or WorldStack.
     */
    addPart(aPart){
        let isValid = this.acceptsSubpart(aPart.type);
        if(!isValid){
            // Consider replacing this generic exception
            // with a message based approach that sends
            // these sorts of non-fatal errors to System
            // as a kind of message. This way we can display
            // errors in SimpltTalk objects.
            throw new Error(`Windows cannot wrap parts of type ${aPart.type}`);
        }
        this.subparts.forEach(subpart => {
            this.removePart(subpart);
        });
        this.subparts.push(aPart);
        aPart._owner = this;
    }

    onWindowClose(senders, ...args){
        // Default behavior is to delete
        // the window model from the System.
        // Scripts can override this handler
        this.sendMessage(
            {
                type: 'command',
                commandName: 'deleteModel',
                args: [ this.id ]
            },
            window.System
        );
    }

    get type(){
        return 'window';
    }
}




/***/ }),

/***/ "./js/objects/parts/WorldStack.js":
/*!****************************************!*\
  !*** ./js/objects/parts/WorldStack.js ***!
  \****************************************/
/*! exports provided: WorldStack, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldStack", function() { return WorldStack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldStack; });
/* harmony import */ var _Part_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Part.js */ "./js/objects/parts/Part.js");
/**
 * WorldStack
 * ---------------------------------------------------
 * I am a Stack part that represents the root of a
 * hierarchy of parts. I am the end of the ownership
 * chain for any given configuration of Parts.
 * I am also the final resolver of all unhandled
 * messages sent along the delegation chain for parts.
 * All parts can eventually resolve to me via the delegation
 * chain or ownership hierarchy.
 * There should only be one instance of me in any given
 * SimpleTalk environment.
 */



class WorldStack extends _Part_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super(null);

        this.acceptedSubpartTypes = ["stack", "image"];

        this.isWorld = true;

        // This property specifies the stack
        // id of the current stack
        this.partProperties.newBasicProp(
            'current',
            null
        );

        // Set the id property to always
        // be 'world'
        this.id = 'world';

        // Bind general methods
        this.sendOpenStackTo = this.sendOpenStackTo.bind(this);
        this.sendCloseStackTo = this.sendCloseStackTo.bind(this);

        // Bind navigation methods
        this.goToNextStack = this.goToNextStack.bind(this);
        this.goToPrevStack = this.goToPrevStack.bind(this);
        this.goToNthStack = this.goToNthStack.bind(this);
        this.goToStackById = this.goToStackById.bind(this);

        // remove command handlers which are not needed for world
        this.removePrivateCommandHandler("moveUp");
        this.removePrivateCommandHandler("moveDown");
        this.removePrivateCommandHandler("moveToFirst");
        this.removePrivateCommandHandler("moveToLast");
    }

    goToNextStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx + 1;
        if(nextIdx >= stacks.length){
            nextIdx = (nextIdx % stacks.length);
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToStackById(anId){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        let nextStack = stacks.find(stack => {
            return stack.id == anId;
        });
        if(!nextStack){
            throw new Error(`The stack id: ${anId} cant be found on this stack`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToPrevStack(){
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(stacks.length < 2){
            return;
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let currentIdx = stacks.indexOf(currentStack);
        let nextIdx = currentIdx - 1;
        if(nextIdx < 0){
            nextIdx = stacks.length + nextIdx;
        }
        let nextStack = stacks[nextIdx];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    goToNthStack(anIndex){
        // NOTE: We are using 1-indexed values
        // per the SimpleTalk system
        let trueIndex = anIndex - 1;
        let stacks = this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
        if(trueIndex < 0 || trueIndex > stacks.length -1){
            throw new Error(`Cannot navigate to stack number ${anIndex} -- out of bounds`);
        }
        let currentStack = this.currentStack;
        let currentStackId = this.currentStackId;
        let nextStack = stacks[trueIndex];
        this.partProperties.setPropertyNamed(
            this,
            'current',
            nextStack.id
        );
        if(currentStackId != nextStack.id){
            this.sendCloseStackTo(currentStack);
            this.sendOpenStackTo(nextStack);
        }
    }

    sendCloseStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'closeStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command',
                commandName: 'closeCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    sendOpenStackTo(aStack){
        this.sendMessage({
            type: 'command',
            commandName: 'openStack',
            args: [],
            shouldIgnore: true
        }, aStack);
        let currentCard = aStack.currentCard;
        if(currentCard){
            aStack.sendMessage({
                type: 'command', 
                commandName: 'openCard',
                args: [],
                shouldIgnore: true
            }, aStack.currentCard);
        }
    }

    get type(){
        return 'world';
    }

    get loadedStacks(){
        return this.subparts.filter(subpart => {
            return subpart.type == 'stack';
        });
    }

    // Override normal Part serialization.
    // Here we need to also include an array of ids of
    // loaded stacks and the id of the current stack
    serialize(){
        let result = {
            type: this.type,
            id: this.id,
            properties: {},
            subparts: this.subparts.map(subpart => {
                return subpart.id;
            }),
            ownerId: null,
            loadedStacks: (this.loadedStacks.map(stack => {
                return stack.id;
            })),
        };

        // Serialize current part properties
        // values
        this.partProperties._properties.forEach(prop => {
            let name = prop.name;
            let value = prop.getValue(this);
            result.properties[name] = value;
        });
        return result;
    }

    // Override for delegation.
    // We send any messages that should be delegated
    // to the global System object, which has any
    // 'handlers of last resort'
    delegateMessage(aMessage){
        return this.sendMessage(aMessage, window.System);
    }

    get currentStackId(){
        return this.partProperties.getPropertyNamed(
            this,
            'current'
        );
    }

    get currentStack(){
        return window.System.partsById[this.currentStackId];
    }

    // override the base class methods
    addPart(aPart){
        if(!this.acceptsSubpart(aPart.type)){
            throw new Error(`${this.type} does not accept subparts of type ${aPart.type}`);
        }

        let found = this.subparts.indexOf(aPart);
        if(found < 0){
            // if the part is a stack then append after the last stack
            if(aPart.type == "stack"){
                let allStacks = this.subparts.filter((part) => {
                    return part.type == "stack";
                });
                this.subparts.splice(allStacks.length, 0, aPart);
            } else {
                this.subparts.push(aPart);
            }
            aPart._owner = this;
        }
    }

    moveSubpartDown(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex + 1);
        }
    }

    moveSubpartToLast(part){
        let currentIndex = this.subparts.indexOf(part);
        let lastValidPartIndex = this.subparts.length - 1;
        if(part.type == "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            lastValidPartIndex = allStacks.length - 1;
        }
        if(currentIndex < lastValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, lastValidPartIndex);
        }
    }

    moveSubpartUp(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, currentIndex - 1);
        }
    }

    moveSubpartToFirst(part){
        let currentIndex = this.subparts.indexOf(part);
        let firstValidPartIndex = 0;
        if(part.type != "stack"){
            let allStacks = this.subparts.filter((part) => {
                return part.type == "stack";
            });
            firstValidPartIndex = allStacks.length;
        }
        if(currentIndex > firstValidPartIndex){
            this.subpartOrderChanged(part.id, currentIndex, firstValidPartIndex);
        }
    }

};




/***/ }),

/***/ "./js/objects/properties/PartProperties.js":
/*!*************************************************!*\
  !*** ./js/objects/properties/PartProperties.js ***!
  \*************************************************/
/*! exports provided: PartProperties, BasicProperty, CustomProperty, DynamicProperty, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartProperties", function() { return PartProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicProperty", function() { return BasicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomProperty", function() { return CustomProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicProperty", function() { return DynamicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartProperties; });
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");


/**
 * PartProperties
 * ------------------------------------
 * I am an object representing the base
 * Part Properties for all Parts.
 * I also include some convenience methods
 * on my prototype that should be used by
 * other Parts when they inherit from me.
 * For now, we use Object.create() for inheritance.
 */

class BasicProperty {
    constructor(name, defaultValue, readOnly=false, aliases=[]){
        this.name = name;
        this._value = defaultValue;
        this.readOnly = readOnly;
        this.aliases = aliases;

        // Bound methods
        this.getValue = this.getValue.bind(this);
        this.setValue = this.setValue.bind(this);
        this.hasAlias = this.hasAlias.bind(this);
        this.matches = this.matches.bind(this);
        this.matchesNameOrAlias = this.matchesNameOrAlias.bind(this);
    }

    // For basic properties, we return
    // the set/stored value
    getValue(owner){
        return this._value;
    }

    // For the basic properties, we set
    // based on the incoming desired value
    // alone (nothing is computed)
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }

    // Returns true if this property
    // goes by the given alias
    hasAlias(anAlias){
        return this.aliases.includes(anAlias);
    }

    // Returns true if the given name is
    // either an alias or the exact name
    // for this property
    matchesNameOrAlias(aNameOrAlias){
        if(this.hasAlias(aNameOrAlias)){
            return true;
        } else if(aNameOrAlias == this.name){
            return true;
        }
        return false;
    }

    // Returns true if the incoming Property
    // has the same name and/or one of the same
    // aliases as this Property
    matches(aProperty){
        if(aProperty.name == this.name){
            return true;
        } else {
            for(let i = 0; i < this.aliases.length; i++){
                let myAlias = this.aliases[i];
                if(aProperty.hasAlias(myAlias)){
                    return true;
                }
            }
        }
        return false;
    }
};


/** Custom Properties are similar to dynamic props, except that
  * under the hood they store an object of properties
  * storing props defined within the ST environment. The find()
  * add() delete() methods find, add, or remove properties from the
  * this.customProperties object.
 **/
class CustomProperty extends BasicProperty {
    constructor(name="custom-properties", defaultValue={}, readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly=false, aliases);
    }

    find(name){
        let prop = this._value[name];
        if(prop){
            return prop;
        }
        return null;
    }

    add(aProperty){
        // NOTE: aliases are completed ignored for now
        if(!this.find(aProperty.name)){
            this._value[aProperty.name] = aProperty;
        }
    }

    delete(aProperty){
        delete this._value[aProperty.name];
    }



};

class DynamicProperty extends BasicProperty {
    constructor(name, setter, getter, readOnly=false, defaultValue=null, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.valueSetter = setter;
        this.valueGetter = getter;
    }

    // In this override, we use the getter
    // if available, to dynamically get the
    // incoming value.
    getValue(owner){
        return this.valueGetter(owner, this);
    }

    // In this override, we use the setter
    // if available, to dynamically set the
    // incoming value
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            this.valueSetter(owner, this, val, notify);
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};


/** I am a special property which handles interfacing with the
  * the cssStyle basic property. Whenever I am updated I make
  * sure to update the cssStyle property via the styler utility
  * function. I can be used to create different and indepent
  * styling options.
  **/
class StyleProperty extends BasicProperty {
    constructor(name, defaultValue,  propName='cssStyle', styler=_utils_styler_js__WEBPACK_IMPORTED_MODULE_0__["default"], readOnly=false, aliases=[]){
        super(name, defaultValue, readOnly, aliases);
        this.propName = propName;
        this.styler = styler;
    }

    // In this override, we update the cssStyle property
    setValue(owner, val, notify=true){
        if(!this.readOnly){
            let styleProperty = owner.partProperties.findPropertyNamed(this.propName);
            let style = styleProperty.getValue(owner);
            let newStyle = this.styler(style, this.name, val);
            styleProperty.setValue(owner, newStyle, notify);

            // set my value as well
            this._value = val;
            if(notify){
                owner.propertyChanged(
                    this.name,
                    val
                );
            }
        }
    }
};

class PartProperties {
    constructor(){
        this._properties = [];

        // Bound methods
        this.hasProperty = this.hasProperty.bind(this);
        this.addProperty = this.addProperty.bind(this);
        this.removeProperty = this.removeProperty.bind(this);
        this.findPropertyNamed = this.findPropertyNamed.bind(this);
        this.setPropertyNamed = this.setPropertyNamed.bind(this);
        this.getPropertyNamed = this.getPropertyNamed.bind(this);
        this.newBasicProp = this.newBasicProp.bind(this);
        this.newStyleProp = this.newStyleProp.bind(this);
        this.newDynamicProp = this.newDynamicProp.bind(this);
        this._indexOfProperty = this._indexOfProperty.bind(this);
    }

    get all(){
        return this._properties;
    }

    // This collection 'has' a property if it contains
    // a Property object with matching name or alias
    // of the incoming property.
    hasProperty(aProperty){
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return true;
            }
        }
        return false;
    }

    // Find one of my Properties by
    // a name or alias. Returns null
    // if no match found. Perhaps we should
    // throw an error
    findPropertyNamed(aName){
        let found = null;
        let customPropertiesProp;
        for(let i = 0; i < this._properties.length; i++){
            let prop = this._properties[i];
            if(prop.matchesNameOrAlias(aName)){
                found = prop;
            }
            // grab the custom properties prop, as we might need it
            // for later
            if(prop.matchesNameOrAlias("custom-properties")){
                customPropertiesProp = prop;
            }
        }
        // see if the property is custom
        if(!found && customPropertiesProp){
            found = customPropertiesProp.find(aName);
        }
        return found;
    }

    // Attempts to get the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    getPropertyNamed(owner, aName){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.getValue(owner);
    }

    // Attempts to set the *value* of the property
    // with the given name or alias.
    // If the property is not found, we throw an
    // error
    setPropertyNamed(owner, aName, aValue, notify=true){
        let found = this.findPropertyNamed(aName);
        if(!found){
            throw new Error(`${owner} does not have property "${aName}"`);
        }
        return found.setValue(owner, aValue, notify);
    }

    // If you add a property with a name or alias
    // that is already present in the collection,
    // then we 'overwrite' it by removing the exising
    // property and replacing it with the incoming one.
    // Otherwise, we just add the property
    addProperty(aProperty){
        if(this.hasProperty(aProperty)){
            this.removeProperty(aProperty);
        }
        this._properties.push(aProperty);
    }

    // Removing a property here means removing
    // it from the stored array. If the property
    // is not in the array, we do NOT throw an error.
    // We just go on with our lives, because who cares?
    removeProperty(aProperty){
        let propIndex = this._indexOfProperty(aProperty);
        if(propIndex >= 0){
            this._properties.splice(propIndex, 1);
        }
    }

    // Convenience method for creating a new basic
    // property.
    newBasicProp(...args){
        let newProp = new BasicProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new custom
    // property.
    newCustomProp(...args){
        let newProp = new CustomProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new style
    // property.
    newStyleProp(...args){
        let newProp = new StyleProperty(...args);
        this.addProperty(newProp);
    }

    // Convenience method for creating a new
    // dynamic prop
    newDynamicProp(...args){
        let newProp = new DynamicProperty(...args);
        this.addProperty(newProp);
    }

    // Private method. Finds the first occurring
    // index of the given Property in the array
    // of properties in this collection. Returns
    // -1 if not found, per JS implementation.
    _indexOfProperty(aProperty){
        for(let i = 0; this._properties.length; i++){
            let prop = this._properties[i];
            if(aProperty.matches(prop)){
                return i;
            }
        }
        return -1;
    }
};




/***/ }),

/***/ "./js/objects/utils/AltSyntaxHighlighter.js":
/*!**************************************************!*\
  !*** ./js/objects/utils/AltSyntaxHighlighter.js ***!
  \**************************************************/
/*! exports provided: createHighlighter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHighlighter", function() { return createHighlighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createHighlighter; });
/** Second pass at syntax highlighter semantics **/
const syntaxSpan = (ruleName) => {
    let span = document.createElement('span');
    span.classList.add('st-syntax');
    span.setAttribute('data-st-rule', ruleName);
    return span;
}

const createHighlighter = (fieldElement) => {
    return {
        MessageHandlerOpen: function(literalOn, messageName, optionalParamList){
            let span = syntaxSpan("MessageHandlerOpen");
            let onSpan = syntaxSpan("keyword");
            onSpan.append("on ");
            span.append(onSpan);

            // Append sub-rules
            span.append(messageName.highlightSyntax());
            span.append(...optionalParamList.highlightSyntax());

            return span;
        },

        MessageHandlerClose(literalEnd, messageName){
            let span = syntaxSpan("MessageHandlerClose");
            let endSpan = syntaxSpan("keyword");
            endSpan.append("end ");
            span.append(endSpan);

            // Add the parts
            span.append(messageName.highlightSyntax());

            return span;
        },

        ParameterList: function(paramString){
            let outer = syntaxSpan("ParameterList");
            let innerItems = paramString.asIteration().children.map(paramName => {
                let span = syntaxSpan("ParameterList-item");
                span.append(paramName.sourceString);
                return span.outerHTML;
            });
            outer.innerHTML = innerItems.join(", ");
            return outer;
            
        },

        messageName: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'messageName');
            span.append(string.sourceString + " ");
            return span;
        },

        keyword: function(string){
            let span = document.createElement('span');
            span.classList.add('st-syntax');
            span.setAttribute('data-st-rule', 'keyword');
            span.append(string.sourceString);
            return span;
        }
    };
};




/***/ }),

/***/ "./js/objects/utils/clipboard.js":
/*!***************************************!*\
  !*** ./js/objects/utils/clipboard.js ***!
  \***************************************/
/*! exports provided: STClipboard, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STClipboard", function() { return STClipboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STClipboard; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/* harmony import */ var _serialization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serialization.js */ "./js/objects/utils/serialization.js");
/**
 * Utilities for Clipboard Functionality
 * ------------------------------------------
 * For the moment we use a very primitive stand-in
 * since the Clipboard API is not standardized across
 * browser implementations.
 **/



class STClipboard {
    constructor(aSystem){
        this.system = aSystem;
        this.contents = [];

        // Bound methods
        this.copyPart = this.copyPart.bind(this);
        this.pasteContentsInto = this.pasteContentsInto.bind(this);
        this._createLensedChildren = this._createLensedChildren.bind(this);
    }

    copyPart(aPart){
        let serializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STSerializer"](this.system);
        let rootSerialization = serializer.serialize(aPart, false);
        let item = new STClipboardItem(
            'simpletalk/json',
            rootSerialization,
            aPart.type
        );
        this.contents = [item];
    }

    pasteContentsInto(aTargetPart){
        let promises = this.contents.map(clipboardContent => {
            let serializedContent = clipboardContent.data;
            let deserializer = new _serialization_js__WEBPACK_IMPORTED_MODULE_1__["STDeserializer"](this.system);
            deserializer.targetId = aTargetPart.id;
            return deserializer.deserialize(serializedContent)
                .then(() => {
                    // Reset the top and left values to that
                    // the pasted part doesn't run outside of the new
                    // relative bounds in which it has been pasted
                    let newPart = deserializer.rootParts[0];
                    let hasTop = newPart.partProperties.findPropertyNamed('top');
                    let hasLeft = newPart.partProperties.findPropertyNamed('left');
                    if(hasTop){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'top',
                            10
                        );
                    }
                    if(hasLeft){
                        newPart.partProperties.setPropertyNamed(
                            newPart,
                            'left',
                            10
                        );
                    }
                    
                    // Open Halo on the new view
                    deserializer.rootViews[0].openHalo();

                    // Dispatch the CustomEvent that notifies listeners
                    // that a new view was added (used by Nav etc)
                    let event = new CustomEvent('st-view-added', {
                        detail: {
                            partType: newPart.type,
                            partId: newPart.id,
                            ownerId: newPart._owner.id
                        }
                    });
                    deserializer.rootViews[0].dispatchEvent(event);

                    // Add any lensed views that might be needed
                    let rootLensViews = this.system.findLensViewsById(newPart._owner.id);
                    rootLensViews.forEach(lensView => {
                        let newLensView = document.createElement(
                            this.system.tagNameForViewNamed(newPart.type)
                        );
                        newLensView.setModel(newPart);
                        newLensView.removeAttribute('part-id');
                        newLensView.setAttribute('lens-part-id', newPart.id);
                        newLensView.setAttribute('role', 'lens');
                        lensView.appendChild(newLensView);
                        this._createLensedChildren(newLensView, newPart.subparts);
                    });
                    
                    return;
                })
                .catch(err => {
                    throw err;
                });
        });
        return Promise.all(promises);
    }

    _createLensedChildren(aLensView, subparts){
        subparts.forEach(subpart => {
            let newLensView = document.createElement(
                this.system.tagNameForViewNamed(subpart.type)
            );
            newLensView.setModel(subpart);
            newLensView.removeAttribute('part-id');
            newLensView.setAttribute('lens-part-id', subpart.id);
            newLensView.setAttribute('role', 'lens');
            aLensView.appendChild(newLensView);
            this._createLensedChildren(newLensView, subpart.subparts);
        });
    }
    
    get isEmpty(){
        return this.contents.length <= 0;
    }
}

class STClipboardItem {
    constructor(mimeType, data, partType){
        if(mimeType){
            this.type = mimeType;
        }
        if(partType){
            this._partType = partType;
        }
        if(data){
            this.data = data;
        }
    }

    get partType(){
        if(this.type == 'simpletalk/json'){
            return this._partType;
        }
        return null;
    }

    set partType(val){
        this._partType = val;
    }
};




/***/ }),

/***/ "./js/objects/utils/errorHandler.js":
/*!******************************************!*\
  !*** ./js/objects/utils/errorHandler.js ***!
  \******************************************/
/*! exports provided: errorHandler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorHandler", function() { return errorHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return errorHandler; });
/**
 * Error Handler
 * ------------------------------------
 * I am responsible for handler all
 * System-wide errors
 */

const errorHandler = {

    handle: function(aMessage){
        switch(aMessage.name){
            case 'GrammarMatchError':
                return this.handleGrammarMatchError(aMessage);
            case 'MessageNotUnderstood':
                return this.handleMessageNotUnderstood(aMessage);
            default:
                // if I don't know what to do with this message
                // I send it along to the System
                return window.System.receiveMessage(aMessage);
        }
    },

    handleGrammarMatchError: function(aMessage){
        // TODO is there a more structured way to get this out of ohm?
        let regex = /Line (?<line>\d), col (?<column>\d)/;
        let match = aMessage.parsedScript.message.match(regex);
        let errorLineNum = parseInt(match.groups["line"]) - 1; // ohm lines start with 1 
        // see if the grammar rule has been identified
        let ruleName;
        let rightMostFailures = aMessage.parsedScript.getRightmostFailures();
        if(rightMostFailures[1]){
            ruleName = rightMostFailures[1].pexpr.ruleName;
        }
        // get some more info about what the parser expected
        let expectedText = aMessage.parsedScript.getExpectedText();
        // get the original script
        let text = aMessage.parsedScript.input;
        let textLines = text.split("\n");
        // replace said text line with an error marker
        textLines[errorLineNum] += ` --<<<[Expected:${expectedText}; ruleName: "${ruleName}"]`;
        text = textLines.join("\n");
        // if the first message in the parsed script is "doIt" then the statementLines are
        // located in the corresponding field text, not the script, property and
        // we want the error to be marked up in the field textarea
        if(aMessage.parsedScript.input.startsWith("on doIt")){
            let originalSenderModel = window.System.partsById[aMessage.partId];
            // we need to get the original text so as not to completely replace it
            // then insert the markup in the appropriate line
            let fieldText = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, "text");
            let script = aMessage.parsedScript.input;
            script = this._cleanDoItSCript(script);
            // we don't want the "doIt" handler inserted back in, since it's just a hidden wrapper for the
            // statement lines
            text = this._cleanDoItSCript(text);
            fieldText = fieldText.replace(script, text);
            originalSenderModel.partProperties.setPropertyNamed(originalSenderModel, "text", fieldText);
        } else {
            // first locate the script editor in question
            let scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            if(!scriptEditor){
                this._openScriptEditor(aMessage.partId);
                scriptEditor = window.System.findScriptEditorByTargetId(aMessage.partId);
            }
            scriptEditor.model.partProperties.setPropertyNamed(scriptEditor.model, "text", text);
        }
        // open the grammar if there is not one open already
        let currentCard = window.System.getCurrentCardModel();
        let grammar = currentCard.subparts.filter((part) => {
            return (part.type == "field") && (part.partProperties.getPropertyNamed(part, "name") == "SimpleTalk");
        });
        if(grammar.length == 0){
            this._openGrammar(aMessage.partId, ruleName);
        }
    },

    handleMessageNotUnderstood(aMessage){
        let offendingMessage = aMessage.message;
        let originalSender = offendingMessage.senders[0];
        // Are we ever going to have MNU errors on messages that
        // are not type: command?
        if(offendingMessage.type === "command"){
            let commandName = offendingMessage.commandName;
            let originalSenderModel = window.System.partsById[originalSender.id];
            let regex = new RegExp(`\\s*${commandName}(\s|\n|$)`, 'g');
            let text;
            let target;
            let executionStack = window.System.executionStack._stack;
            // if the first message in the execution stack is "doIt" then the statementLines are
            // located in the corresponding field text, not the script, property and
            // we want the error to be marked up in the field textarea
            if(executionStack[0] && executionStack[0].messageName == "doIt"){
                target = executionStack[0].part;
                text = target.partProperties.getPropertyNamed(originalSenderModel, 'text');
            } else {
                text = originalSenderModel.partProperties.getPropertyNamed(originalSenderModel, 'script');
                let scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                if(!scriptEditor){
                    this._openScriptEditor(originalSender.id);
                    scriptEditor = window.System.findScriptEditorByTargetId(originalSender.id);
                }
                if(scriptEditor){
                    target = scriptEditor.model;
                }
            }
            // TODO Sort this out
            if(target){
                let textLines = text.split("\n");
                // offending command text line with an error marker
                for(let i = 0; i < textLines.length; i++){
                    let line = textLines[i];
                    if(line.match(regex)){
                        textLines[i] = line += ` --<<<[MessageNotUnderstood: command; commandName: "${commandName}"]`;
                    }
                }
                text = textLines.join("\n");
                target.partProperties.setPropertyNamed(target, "text", text);

            }
            // finally open the debugger (or current version thereof)
            // NOTE: this is a bit dangerous, b/c if the System doesn't
            // handle the `openDebugger` command anywhere it will throw
            // a MNU error, which will then invoke this handler cuasing
            // an infinite loop!
            this._openDebugger(originalSender.id);
        }
    },

    _cleanDoItSCript(script){
        // clean up the DoIt script by removing the handler
        // newlines, tabs and spaces
        script = script.replace("on doIt", "");
        script = script.replace("end doIt", "");
        script = script.replace(/^[\n\t ]+/, "");
        script = script.replace(/[\n\t ]+$/, "");
        return script;
    },

    _openScriptEditor: function(partId){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openScriptEditor",
            args: [partId]
        };
        target.sendMessage(msg, target);
    },

    _openGrammar: function(partId, ruleName){
        let target = window.System.partsById[partId];
        let statementLines = [
            'if there is not a field "SimpleTalk" of current card',
            'then',
            'add field "SimpleTalk" to current card',
            'tell field "SimpleTalk" of current card to set "editable" to false',
            'SimpleTalk',
            'tell field "SimpleTalk"of current card to set "text" to it',
            'end if'
        ];
        let script = `on doIt\n   ${statementLines.join('\n')}\nend doIt`;
        target.sendMessage(
            {
                type: "compile",
                codeString: script,
                targetId: target.id
            },
            target
        );
        target.sendMessage(
            {
                type: "command",
                commandName: "doIt",
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            },
            target
        );
    },

    // At the moment this simply opens a st-window st-field with
    // information about the available commands for said parts
    _openDebugger: function(partId){
        let target = window.System.partsById[partId];
        let msg = {
            type: "command",
            "commandName": "openDebugger",
            args: [partId]
        };
        target.sendMessage(msg, target);
    }
};




/***/ }),

/***/ "./js/objects/utils/handInterface.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/handInterface.js ***!
  \*******************************************/
/*! exports provided: Testables, handInterface, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Testables", function() { return Testables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handInterface", function() { return handInterface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return handInterface; });
const video = document.createElement('video');
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

const scaleDim = (dim) => {
    const scale = 0.7;
    const stride = 16;
    const evenRes = dim * scale - 1;
    return evenRes - (evenRes % stride) + 1;
};

const detectHands = async () => {
    if (!handInterface.handDetectionRunning) {
        return;
    }
    const scaledWidth = scaleDim(canvas.width);
    const scaledHeight = scaleDim(canvas.height);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const image = tf.tidy(() => {
        return tf.fromPixels(canvas).resizeBilinear([scaledHeight, scaledWidth]).expandDims(0);
    });
    const [scores, tboxes] = await handInterface.handDetectionModel.executeAsync(image);
    image.dispose();
    const handsDetected = tf.tidy(() => {
        const indices = tf.image.nonMaxSuppression(
            tboxes.reshape([tboxes.shape[1], tboxes.shape[3]]),
            scores.reshape([scores.shape[1]]),
            20,
            0.5,
            0.85).dataSync();
        var boxes = [];
        var idx;
        for (let i = 0; i < indices.length; i++) {
            idx = indices[i];
            var score = scores.get(0, idx, 0);
            // Original order is [minY, minX, maxY, maxX] so we reorder.
            var box = {
                upperLeft: [tboxes.get(0, idx, 0, 1), tboxes.get(0, idx, 0, 0)],
                lowerRight: [tboxes.get(0, idx, 0, 3), tboxes.get(0, idx, 0, 2)]
            };
            boxes.push({score: score, box: box});
        }
        return {boxes: boxes, timestamp: Date.now()};
    });
    scores.dispose();
    tboxes.dispose();
    if (handsDetected.boxes.length !== 1) {
        if (handInterface.handDetectionRunning) {
            window.requestAnimationFrame(detectHands);
        }
        return;
    }
    const box = handsDetected.boxes[0].box;
    const [x1, y1] = box.upperLeft;
    const [x2, y2] = box.lowerRight;
    const area = {area: (x2 - x1) * (y2 - y1), timestamp: Date.now()};
    handInterface.handDetectionAreas = [].concat(handInterface.handDetectionAreas.slice(-2), [area]);
    // Update hand location
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
    const p = [0.5 * (x1 + x2) * vw, 0.5 * (y1 + y2) * vh];
    handInterface.positions = [].concat(handInterface.positions.slice(-2), [p]);
    var target = handInterface.targetElement;
    if (target === null) {
        target = handInterface.leninHand;
    }
    // Compute average position
    const [p1, p2, p3] = handInterface.positions;
    const [ap1, ap2] = [(1/3)*(p1[0] + p2[0] + p3[0]), (1/3)*(p1[1] + p2[1] + p3[1])];
    target.partProperties.setPropertyNamed(target, "left", ap1);
    target.partProperties.setPropertyNamed(target, "top", ap2);
    // Extract area information without any timestamps
    var justAreas = [];
    for (var i = 0; i < handInterface.handDetectionAreas.length; ++i) {
        justAreas.push(handInterface.handDetectionAreas[i].area);
    }
    var justAreas = [].concat(Array(3 - justAreas.length).fill(0), justAreas);
    // Check if hand is pushing in
    const [a1, a2, a3] = justAreas;
    const aveArea = (1/3) * (a1 + a2 + a3);
    if (aveArea > 0.25) {
        if (!handInterface.handMasked) {
            handInterface.handMasked = true;
            setTimeout(() => { handInterface.handMasked = false; }, 3000);
            if (handInterface.targetElement === null) {
                let closestView = findClosestView([p1, p2]);
                if (closestView !== null) {
                    handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", true);
                    handInterface.targetElement = closestView.model;
                }
            } else {
                handInterface.leninHand.partProperties.setPropertyNamed(handInterface.leninHand, "hide", false);
                handInterface.targetElement = null;
            }
        }
    }
    if (handInterface.handDetectionRunning) {
        window.requestAnimationFrame(detectHands);
    }
};

const findClosestView = (point) => {
    let views = [];
    window.System.getCurrentCardModel().subparts.forEach((part) => {
        let partViews = window.System.findViewsById(part.id);
        partViews.forEach((view) => {
            views.push(view);
        })
    });
    var [closestDist, closestView] = [Infinity, null];
    views.forEach((view) => {
        let viewDist = dist(point, getVertices(view));
        if (viewDist < closestDist) {
            closestDist = viewDist;
            closestView = view;
        }
    });
    return closestView;
}

// https://aaronsmith.online/easily-load-an-external-script-using-javascript/
const loadScript = src => {
    return new Promise((resolve, reject) => {
        if (typeof window.tf !== 'undefined') {
            console.log("tensorflowjs already loaded");
            resolve();
            return;
        }
        console.log("loading tensorflowjs");
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.onload = resolve;
        script.onerror = reject;
        script.src = src;
        document.head.append(script);
    });
};

const loadHandDetectionModel = () => {
    handInterface.handDetectionAreas = [];
    loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.5/dist/tf.js").then(() => {
        window.tf.loadFrozenModel(
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/tensorflowjs_model.pb",
            "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/ssdlitemobilenetv2/weights_manifest.json"
        ).then(model => {
            console.log("hand detection model loaded");
            handInterface.handDetectionModel = model;
        }).then(() => {
            return navigator.mediaDevices.getUserMedia({ video: true });
        }).then(stream => {
            video.srcObject = stream;
            return video.play();
        }).then(() => {
            console.log("video started");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0); // Mirror incoming video
            handInterface.handDetectionRunning = true;
            handInterface.leninHand = window.System.newModel('image', window.System.getWorldStackModel().id, "/images/leninHand.png");
            handInterface.targetElement = null;
            window.requestAnimationFrame(detectHands);
        }).catch(err => {
            console.log("error loading hand detection model");
            console.log(err);
        });
    });
}

const unloadHandDetectionModel = () => {
    handInterface.handDetectionRunning = false;
    window.System.deleteModel(handInterface.leninHand.id)
    handInterface.leninHand = null;
    video.pause();
    const tracks = video.srcObject.getTracks();
    for (var i = 0; i < tracks.length; i++) {
        tracks[i].stop();
    }
    video.srcObject = null;
    console.log("video stopped");
    handInterface.handDetectionModel = null;
    console.log("unloading hand detection model");
}

const getVertices = (element) => {
    const rect = element.getBoundingClientRect();
    const upperLeft = [rect.x, rect.y];
    const upperRight = [rect.x + rect.width, rect.y];
    const lowerLeft = [rect.x, rect.y + rect.height];
    const lowerRight = [rect.x + rect.width, rect.y + rect.height];
    return {
        upperLeft: upperLeft,
        upperRight: upperRight,
        lowerLeft: lowerLeft,
        lowerRight: lowerRight
    };
}

const dist = (point, vertices) => {
    const [p1, p2] = point;
    const [ul1, ul2] = vertices.upperLeft;
    const [ll1, ll2] = vertices.lowerLeft;
    const [ur1, ur2] = vertices.upperRight;
    const [lr1, lr2] = vertices.lowerRight;
    // First check if the point is inside the rectangle
    // Next we compute the vector pointing from the point to the closest point
    // on the rectangle. There are 9 cases. The first is when the poinst is
    // inside the rectangle. The next four cases are if the point in one of
    // the four corners and the final four cases are when the point is on one
    // of the four sides.
    var [v1, v2] = [null, null];
    if ((ul1 <= p1) && (p1 <= lr1) && (ul2 <= p2) && (p2 <= lr2)) {
        // Case 0: inside the rectangle
        [v1, v2] = [0, 0];
    } else if ((p1 <= ul1) && (p2 <= ul2)) {
        // Case 1: upper left
        [v1, v2] = [ul1 - p1, ul2 - p2];
    } else if ((p1 >= ur1) && (p2 <= ur2)) {
        // Case 2: upper right
        [v1, v2] = [ur1 - p1, ur2 - p2];
    } else if ((p1 <= ll1) && (p2 >= ll2)) {
        // Case 3: lower left
        [v1, v2] = [ll1 - p1, ll2 - p2];
    } else if ((p1 >= lr1) && (p2 >= lr2)) {
        // Case 4: lower right
        [v1, v2] = [lr1 - p1, lr2 - p2];
    } else if (p1 <= ul1) {
        // Case 5: side left
        [v1, v2] = [ul1 - p1, 0];
    } else if (p1 >= lr1) {
        // Case 6: side right
        [v1, v2] = [lr1 - p1, 0];
    } else if (p2 <= ul2) {
        // Case 7: side top
        [v1, v2] = [0, ul2 - p2];
    } else if (p2 >= lr2) {
        // Case 8: side bottom
        [v1, v2] = [0, lr2 - p2];
    } else {
        // Case 9: inside
        [v1, v2] = [0, 0];
    }
    return Math.sqrt(v1*v1 + v2*v2);
}

class HandInterface {
    constructor() {
        this.handDetectionModel = null;
        this.handDetectionRunning = false;
        this.leninHand = null;
        this.handMasked = false;
        this.targetElement = null;
        this.handDetectionAreas = [];
        this.positions = [[0, 0], [0, 0], [0, 0]];
        // XXX - Only here to ignore the tensorflow warnings
        console.warn = () => {};
    }

    start() {
        loadHandDetectionModel();
    }

    stop() {
        unloadHandDetectionModel();
    }
}

const Testables = {
    dist: dist
}

const handInterface = new HandInterface();




/***/ }),

/***/ "./js/objects/utils/icons.js":
/*!***********************************!*\
  !*** ./js/objects/utils/icons.js ***!
  \***********************************/
/*! exports provided: partIcons, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partIcons", function() { return partIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return partIcons; });
let partIcons = {};

partIcons.world = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-world" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <line x1="3.6" y1="9" x2="20.4" y2="9" />
  <line x1="3.6" y1="15" x2="20.4" y2="15" />
  <path d="M11.5 3a17 17 0 0 0 0 18" />
  <path d="M12.5 3a17 17 0 0 1 0 18" />
</svg>
`;

partIcons.stack = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="12 4 4 8 12 12 20 8 12 4" />
  <polyline points="4 12 12 16 20 12" />
  <polyline points="4 16 12 20 20 16" />
</svg>
`;

partIcons.card = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-square" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="4" y="4" width="16" height="16" rx="2" />
</svg>
`;

partIcons.button = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hand-finger" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M8 13v-8.5a1.5 1.5 0 0 1 3 0v7.5" />
  <path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0v2.5" />
  <path d="M14 10.5a1.5 1.5 0 0 1 3 0v1.5" />
  <path d="M17 11.5a1.5 1.5 0 0 1 3 0v4.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" />
</svg>
`;

partIcons.window = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-window" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3c-3.866 0 -7 3.272 -7 7v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1 -1v-10c0 -3.728 -3.134 -7 -7 -7z" />
  <line x1="5" y1="13" x2="19" y2="13" />
  <line x1="12" y1="3" x2="12" y2="21" />
</svg>
`;

partIcons.area = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-shape" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="5" cy="5" r="2" />
  <circle cx="19" cy="5" r="2" />
  <circle cx="5" cy="19" r="2" />
  <circle cx="19" cy="19" r="2" />
  <line x1="5" y1="7" x2="5" y2="17" />
  <line x1="7" y1="5" x2="17" y2="5" />
  <line x1="7" y1="19" x2="17" y2="19" />
  <line x1="19" y1="7" x2="19" y2="17" />
</svg>
`;

partIcons.field = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-forms" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3a3 3 0 0 0 -3 3v12a3 3 0 0 0 3 3" />
  <path d="M6 3a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3" />
  <path d="M13 7h7a1 1 0 0 1 1 1v8a1 1 0 0 1 -1 1h-7" />
  <path d="M5 7h-1a1 1 0 0 0 -1 1v8a1 1 0 0 0 1 1h1" />
  <path d="M17 12h.01" />
  <path d="M13 12h.01" />
</svg>
`;

partIcons.drawing = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-palette" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 21a9 9 0 1 1 0 -18a9 8 0 0 1 9 8a4.5 4 0 0 1 -4.5 4h-2.5a2 2 0 0 0 -1 3.75a1.3 1.3 0 0 1 -1 2.25" />
  <circle cx="7.5" cy="10.5" r=".5" fill="currentColor" />
  <circle cx="12" cy="7.5" r=".5" fill="currentColor" />
  <circle cx="16.5" cy="10.5" r=".5" fill="currentColor" />
</svg>
`;

partIcons.image = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="15" y1="8" x2="15.01" y2="8" />
  <rect x="4" y="4" width="16" height="16" rx="3" />
  <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5" />
  <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2" />
</svg>
`;

partIcons.generic = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-puzzle" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 7h3a1 1 0 0 0 1 -1v-1a2 2 0 0 1 4 0v1a1 1 0 0 0 1 1h3a1 1 0 0 1 1 1v3a1 1 0 0 0 1 1h1a2 2 0 0 1 0 4h-1a1 1 0 0 0 -1 1v3a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-1a2 2 0 0 0 -4 0v1a1 1 0 0 1 -1 1h-3a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1h1a2 2 0 0 0 0 -4h-1a1 1 0 0 1 -1 -1v-3a1 1 0 0 1 1 -1" />
</svg>
`;




/***/ }),

/***/ "./js/objects/utils/id.js":
/*!********************************!*\
  !*** ./js/objects/utils/id.js ***!
  \********************************/
/*! exports provided: idMaker, isValidId, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idMaker", function() { return idMaker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidId", function() { return isValidId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return idMaker; });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_0__);
// ID related utilities



/**
 * ID Maker
 * ------------------------------------
 * I am responsible for creating globally
 * unique ID values for Parts in the SimpleTalk
 * world.
 * HC requires that all Parts have unique ids and
 * that these should not be repeated in any given
 * "application" instance.
 * We need to determine what an "application" is
 * in our context, but regardless we can use this
 * module as a drop in replacement, implementing
 * UUIDs or URLs or whatever we want.
 * For now we just increment an integer.
 */
const idMaker = {
    new: function(){
        let id = Object(uuid__WEBPACK_IMPORTED_MODULE_0__["v4"])();
        return id.replace(/-/g, '');
    }
};

/* ID checker
 * --------------------------------------
 * I am responsible for checking whether an id is
 * is valid and returning it if so
 */
const isValidId = function(id) {
    if(id === null || id === undefined || id === ""){
        return false;
    }
    if(id.length != 32 || id.match('[a-z0-9]*')[0].length != 32) {
        return false;
    }
    return id;
};




/***/ }),

/***/ "./js/objects/utils/merriamInterface.js":
/*!**********************************************!*\
  !*** ./js/objects/utils/merriamInterface.js ***!
  \**********************************************/
/*! exports provided: merriamSimScore, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriamSimScore", function() { return merriamSimScore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriamSimScore; });
const merriamSimScore = async (sender, docId) => {
    const url = "https://patents.merriamtech.com/_api/merriam/"
    const payload = {
        "fields": [
            "title",
            "date_publ"
        ],
        "weights": {
            "merriam":0.7,
            "date":0.3,
            "hierarchy":0.1
        },
        "doc_ids": [
            docId
        ],
        "limit": 5}
    const params = {
        "method": "POST",
        "headers": {
            "content-type": "application/json"
        },
        "body": JSON.stringify(payload)
    }
    fetch(url, params).then(data => {
        return data.json();
    }).then(json => {
        const msg = {
            type: 'command',
            commandName: 'merriamresult',
            args: [
                JSON.stringify(json)
            ]
        };
        sender.sendMessage(msg, sender);
    });
}




/***/ }),

/***/ "./js/objects/utils/serialization.js":
/*!*******************************************!*\
  !*** ./js/objects/utils/serialization.js ***!
  \*******************************************/
/*! exports provided: STSerializer, STDeserializer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STSerializer", function() { return STSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STDeserializer", function() { return STDeserializer; });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./js/objects/utils/id.js");
/**
 * Serialization and Deserialization Utility Classes
 */


const version = "0.0.2";

class STDeserializer {
    constructor(aSystem){
        this.system = aSystem;

        // These caches are used during the process
        // as optimizations
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];

        // The targetId is the id of
        // the Part that we wish to append any
        // deserialized subpart tree into.
        // By default we assume the whole system,
        // ie full deserialization.
        this.targetId = 'system';
        // the root id is the id of the root part instance
        // being attached
        this.rootId = null;

        // Bound methods
        this.deserialize = this.deserialize.bind(this);
        this.deserializeData = this.deserializeData.bind(this);
        this.deserializePart = this.deserializePart.bind(this);
        this.attachSubparts = this.attachSubparts.bind(this);
        this.setProperties = this.setProperties.bind(this);
        this.createView = this.createView.bind(this);
        this.attachView = this.attachView.bind(this);
        this.setViewModel = this.setViewModel.bind(this);
        this.compilePartScript = this.compilePartScript.bind(this);
        this.refreshWorld = this.refreshWorld.bind(this);
        this.appendWorld = this.appendWorld.bind(this);
        this.addPartsToSystem = this.addPartsToSystem.bind(this);
        this.compileScripts = this.compileScripts.bind(this);
        this.getFlattenedPartTree = this.getFlattenedPartTree.bind(this);
        this.getModelClass = this.getModelClass.bind(this);
        this.handleId = this.handleId.bind(this);
        this.throwError = this.throwError.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
        this.dispatchViewAdded = this.dispatchViewAdded.bind(this);
    }

    deserialize(aJSONString){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        return this.deserializeData()
            .then(() => {
                // Add all deserialized Parts to the System dict,
                // including the new World.
                this.addPartsToSystem(this._instanceCache);
            })
            .then(() => {
                // Compile the scripts on *all* deserialized
                // parts
                this.compileScripts(this._instanceCache);
            })
            .then(() => {
                // Insert the root Part into whatever
                // target it should go into.
                let rootPart = this.rootParts[0];
                let rootView = this.rootViews[0];
                if(this.targetId == 'system'){
                    this.refreshWorld();
                } else {
                    target.addPart(rootPart);
                }

                // Finally, append the PartView root node
                // where it should go in the view tree.
                if(this.targetId == 'system'){
                    this.appendWorld();
                } else {
                    let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
                    targetView.appendChild(rootView);
                    this.dispatchViewAdded(rootView);
                }
                return this;
            });
    }

    deserializeData(){
        return new Promise((resolve, reject) => {
            this.flushCaches();
            // First, we ensure that the target we
            // should be deserializing into actually exists
            let target = this.system.partsById[this.targetId];
            if(!target && this.targetId != 'system'){
                this.throwError(`Target id ${this.targetId} does not exist in System`);
            }

            // Second, we create instances of all models in the serialization
            // but we do not yet attach their subparts.
            Object.values(this.data.parts).forEach(partData => {
                this.deserializePart(Object.assign({}, partData));
            });

            // Translate targets
            for (let modelId in this._propsCache) {
                let props = this._propsCache[modelId];
                if (props.target !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        if (props.target === 'part id ' + oldId) {
                            props.target = 'part id ' + newId;
                            break;
                        }
                    }
                }
            }
            // Translate scripts
            for (let modelId in this._scriptCache) {
                let script = this._scriptCache[modelId];
                if (script !== null && script.match('part id') !== null) {
                    for (let oldId in this._idCache) {
                        let newId = this._idCache[oldId];
                        let oldRe = 'part id ' + oldId;
                        let newRe = 'part id ' + newId;
                        if (this._scriptCache[modelId].match(oldRe) !== null) {
                            console.log(modelId);
                            let re = new RegExp(oldRe, "g");
                            this._scriptCache[modelId] = script.replace(re, newRe);
                        }
                    }
                }
            }

            // Third, we go through each created Part instance
            // and add any subparts to it. Note that this is not
            // recursive
            this._instanceCache.forEach(partInstance => {
                this.attachSubparts(partInstance);
            });

            // Forth and fifth. Create and attach views
            // Note this is recursive to preserve the subpart + view children order
            let root = this._instanceCache.filter((part) => {
                return part.partProperties.getPropertyNamed(part, "id") == this.rootId;
            })[0];
            this.createAndAttachViews(root);

            // Sixth, we set all properties on each created
            // Part model from the deserialized data.
            // We do this using a visitor method on the instances
            // themselves.
            // This gives the in-memory views the ability to
            // react to any initial changes to their models.
            this._instanceCache.forEach(partInstance => {
                this.setProperties(partInstance);
                // We need to translate new ids to old ones
                if (partInstance.name == "WorldStack") {
                    let world = partInstance;
                    world.partProperties.setPropertyNamed(
                        world,
                        "current",
                        this._idCache[world.currentStackId]
                    );
                }
                if (partInstance.name == "Stack") {
                    let stack = partInstance;
                    stack.partProperties.setPropertyNamed(
                        stack,
                        "current",
                        this._idCache[stack.currentCardId]
                    );
                }
                this.setViewModel(partInstance);
            });

            // We determine which of the instances is a "root",
            // meaning that it has, at this point, no owner in
            // the deserialized data. There can be multiple roots
            // (and therefore multiple trees) in a single deserialization
            this._rootsCache = this._instanceCache.filter(instance => {
                return instance._owner == null || instance._owner == undefined;
            });

            // Insertion should be handled by composed
            // promises elsewhere (see imports and deserialize()
            // for examples)

            return resolve(this);
        });
    }

    createAndAttachViews(partInstance){
        this.createView(partInstance);
        this.attachView(partInstance);
        if(partInstance.subparts.length){
            partInstance.subparts.forEach((subpartInstance) => {
                this.createAndAttachViews(subpartInstance);
            });
        }
    }

    importFromSerialization(aJSONString, filterFunction){
        this.data = JSON.parse(aJSONString);
        let target = this.system.partsById[this.targetId];
        let targetView = document.querySelector(`[part-id="${this.targetId}"]`);
        return this.deserializeData()
            .then(() => {
                // The caller will provide a filter function over
                // all deserialized part instances, returning only
                // those that should be inserted into the target.
                // For example, all Stacks in the WorldStack.
                return this._instanceCache.filter(filterFunction);
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.addPartsToSystem(allTreeParts);
                });
                return rootParts;

            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let allTreeParts = this.getFlattenedPartTree(rootPart);
                    this.compileScripts(allTreeParts);
                });
                return rootParts;
            })
            .then((rootParts) => {
                rootParts.forEach(rootPart => {
                    let view = this._viewsCache[rootPart.id];
                    target.addPart(rootPart);
                    targetView.appendChild(view);
                    this.dispatchViewAdded(view);
                });
            });
    }

    deserializePart(partData){
        let partClass = this.getModelClass(partData.type);
        let instance = new partClass();

        // We create a new ID for this part, since we cannot
        // guarantee ID clashes with the existing System.
        // Exception is if the useOriginalids flag is set,
        // such as at load time
        let {newId, oldId} = this.handleId(instance, partData);
        instance.id = newId;
        // cache the new root ID if this is a root instance
        if(this.data.rootId == oldId){
            this.rootId = newId;
        }

        // Add to our caches and also to the System
        this._idCache[oldId] = newId;
        this._scriptCache[newId] = partData.properties.script;
        this._propsCache[newId] = partData.properties;
        this._modelCache[newId] = instance;
        this._subpartMapCache[newId] = partData.subparts;
        this._instanceCache.push(instance);
    }

    handleId(aPart, partData){
        let newId, oldId;
        oldId = partData.id;
        newId = aPart.id;
        if(aPart.type !== 'world'){
            newId = _id_js__WEBPACK_IMPORTED_MODULE_0__["default"].new();
        }
        return {
            newId,
            oldId
        };
    }

    addPartsToSystem(aListOfParts){
        aListOfParts.forEach(part => {
            this.system.partsById[part.id] = part;
        });
    }

    compileScripts(aListOfParts){
        aListOfParts.forEach(part => {
            this.compilePartScript(part);
        });
    }

    attachSubparts(aPart){
        // At this point, the _subpartMapCache should
        // have an entry mapping from this aPart's (new)
        // id to an array of ids of also-initialized
        // subpart models
        let subpartIds = this._subpartMapCache[aPart.id];
        subpartIds.forEach(subpartId => {
            let newId = this._idCache[subpartId];
            let subpartModel = this._modelCache[newId];
            if(!subpartModel){
                debugger;
            }
            aPart.addPart(subpartModel);
        });
    }

    setProperties(aPart){
        let props = this._propsCache[aPart.id];
        delete props['id'];
        aPart.setPropsFromDeserializer(props, this);
    }

    createView(aPart){
        let newView = document.createElement(
            this.system.tagNameForViewNamed(aPart.type)
        );
        // we need to set the part-id attribute since these
        // are used for queries needed for things like
        // current stack and card
        newView.setAttribute("part-id", aPart.id);
        this._viewsCache[aPart.id] = newView;
    }

    setViewModel(aPart){
        let view = this._viewsCache[aPart.id];
        view.setModel(aPart);
    }
    
    attachView(aPart){
        let owner = aPart._owner;
        if(owner){
            let ownerView = this._viewsCache[owner.id];
            let partView = this._viewsCache[aPart.id];
            owner.sendMessage({
                type: "viewChanged",
                changeName: "subpart-new",
                args: [partView]
            }, ownerView);
        }
    }

    compilePartScript(aPart){
        let scriptString = this._scriptCache[aPart.id];
        if(scriptString && scriptString != ""){
            this.system.compile({
                type: 'compile',
                targetId: aPart.id,
                codeString: scriptString,
                serialize: false
            });
        }
    }

    refreshWorld(){
        // We assume a single root part was deserialized and
        // attach it as the World accordingly
        let newWorld = this.rootParts[0];
        if(newWorld.type !== 'world'){
            this.throwError(`Found ${this.rootParts.length} roots, but no world!`);
        }
        this.system.partsById['world'] = this.rootParts[0];
    }

    appendWorld(){
        // We assume a single root view that is an st-world.
        let found = document.querySelector('st-world');
        if(found){
            document.body.replaceChild(this.rootViews[0], found);
        } else {
            document.body.prepend(this.rootViews[0]);
        }
        this.dispatchViewAdded(document.querySelector('st-world'));
    }

    getFlattenedPartTree(aPart, list=[]){
        list.push(aPart);
        aPart.subparts.forEach(subpart => {
            this.getFlattenedPartTree(subpart, list);
        });
        return list;
    }

    throwError(message){
        throw new Error(`Deserialization Error: ${message}`);
    }

    getModelClass(aPartTypeStr){
        let cls = this.system.availableParts[aPartTypeStr];
        if(!cls){
            this.throwError(`Part type "${aPartTypeStr}" does not exist in system`);
        }
        return cls;
    }

    flushCaches(){
        this._modelCache = {};
        this._subpartMapCache = {};
        this._idCache = {};
        this._instanceCache = [];
        this._propsCache = {};
        this._viewsCache = {};
        this._scriptCache = {};
        this._rootsCache = [];
    }

    dispatchViewAdded(aView){
        let event = new CustomEvent('st-view-added', {
            detail: {
                partType: aView.model.type,
                partId: aView.model.id,
                //ownerId: aView.model._owner.id || null
            } 
        });
        aView.parentElement.dispatchEvent(event);
    }

    get rootParts(){
        return this._rootsCache;
    }

    get rootViews(){
        return this.rootParts.map(part => {
            return this._viewsCache[part.id];
        });
    }
}


class STSerializer {
    constructor(aSystem){
        this.system = aSystem;
        this._objectCache = {};

        // Bound methods
        this.serializePart = this.serializePart.bind(this);
        this.flushCaches = this.flushCaches.bind(this);
    }

    serialize(aRootPart, pretty=true){
        this.flushCaches();
        let result = {
            version: version,
            rootId: aRootPart.id,
            type: aRootPart.type,
            id: aRootPart.id
        };

        // Recursively serialize Parts and
        // store in flat list
        this.serializePart(aRootPart);

        // We set the result objects parts
        // dict to be the same as the cache
        result.parts = this._objectCache;

        // Finally, we convert to a string and
        // return
        if(pretty){
            return JSON.stringify(result, null, 4);
        } else {
            return JSON.stringify(result);
        }
    }

    serializePart(aPart){
        // We use the serialize method available on
        // base Parts, passing in this serializer instance
        // as the sole arg
        this._objectCache[aPart.id] = aPart.serialize(this);
        aPart.subparts.forEach(subpart => {
            this.serializePart(subpart);
        });
    }

    flushCaches(){
        this._objectCache = {};
    }
}




/***/ }),

/***/ "./js/objects/utils/styleProperties.js":
/*!*********************************************!*\
  !*** ./js/objects/utils/styleProperties.js ***!
  \*********************************************/
/*! exports provided: addBasicStyleProps, addPositioningStyleProps, addTextStyleProps, addLayoutStyleProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addBasicStyleProps", function() { return addBasicStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPositioningStyleProps", function() { return addPositioningStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTextStyleProps", function() { return addTextStyleProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLayoutStyleProps", function() { return addLayoutStyleProps; });
/**
 * Helpers for setting up various
 * style properties
 */


/**
 * Basic style properties are those
 * common to all (visual) Parts
 */
const sides = ["top", "bottom", "left", "right"];

const addBasicStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'background-transparency',
        1,
    );
    target.partProperties.newStyleProp(
        'background-color',
        "rgb(255, 255, 255)", // white 
    );
    target.partProperties.newStyleProp(
        'transparency',
        1.0,
    );
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-style`,
            'solid'
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-width`,
            0,
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-color`,
            "rgb(0, 0, 0)", // black
        );
    });
    sides.forEach((s) => {
        target.partProperties.newStyleProp(
            `border-${s}-transparency`,
            1
        );
    });
    target.partProperties.newStyleProp(
        'shadow-left',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-top',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-blur',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-spread',
        0
    );
    target.partProperties.newStyleProp(
        'shadow-color',
        "rgb(238, 238, 238)", // grey
    );
    target.partProperties.newStyleProp(
        'shadow-transparency',
        1
    );
    target.partProperties.newStyleProp(
        'corner-top-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-top-right-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-left-round',
        0
    );
    target.partProperties.newStyleProp(
        'corner-bottom-right-round',
        0
    );
};

/**
 * Style properties for Parts that can
 * be moved and that can have explicit
 * dimensions. Examples: buttons, fields.
 * Examples of those that can't: Cards, Stacks
 */
const addPositioningStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'hide',
        false,
    );
    // setting width and height to null
    // effectively forces to the default size
    // of the button to fit the button name
    target.partProperties.newStyleProp(
        'width',
        100,
    );
    target.partProperties.newStyleProp(
        'height',
        null,
    );
    target.partProperties.newStyleProp(
        'top',
        0,
    );
    target.partProperties.newStyleProp(
        'left',
        0,
    );
    target.partProperties.newStyleProp(
        'rotate',
        null,
    );

    // horizontal-resizing specifies a strategy
    // for how this Part should adjust its
    // horizontal axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // horizontal axis in the parent Part.
    target.partProperties.newStyleProp(
        'horizontal-resizing',
        'rigid'
    );

    // vertical-resizing specifies a strategy
    // for how this Part should adjust its
    // vertical axis relative to the parent.
    // Possible values are:
    // * rigid - Stick to the top, left, width
    // and height properties as they are explicitly
    // set;
    // * shrink-wrap - Become large enough on the hori-
    // zontal axis only to fit any child contents;
    // * space-fill - Fill as much as we can in the
    // vertical axis in the parent Part.
    target.partProperties.newStyleProp(
        'vertical-resizing',
        'rigid'
    );

    // Margin specifies some space between the
    // target Part and any other Parts that might
    // be adjacent to it in a common Owner. It will
    // not be in effect when the owner is using a
    // strict layout.
    target.partProperties.newStyleProp(
        'top-margin',
        null
    );
    target.partProperties.newStyleProp(
        'right-margin',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-margin',
        null
    );
    target.partProperties.newStyleProp(
        'left-margin',
        null
    );

    // Pinning specifies whether or not
    // a given part should "stick" to a
    // particular side of its owner Part.
    // Pinning properties only have effect
    // inside of Parts with a strict layout
    target.partProperties.newDynamicProp(
        'pinning-top',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-left',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value

    );
    target.partProperties.newDynamicProp(
        'pinning-bottom',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        'pinning-right',
        pinningSetter,
        function(propOwner, propObject){
            return propObject._value;
        },
        false, // not read only
        false // default value
    );
    target.partProperties.newDynamicProp(
        // Possible values for the compound
        // 'pinning' property are:
        // *"none" or null
        // *top
        // *top-right
        // *top-left
        // *bottom
        // *bottom-right
        // *bottom-left
        // *left
        // *right
        'pinning',
        // Setter
        function(propOwner, propObject, value){
            if(!value || value == "none"){
                ['top', 'left', 'right', 'bottom'].forEach(side => {
                    let pin = `pinning-${side}`;
                    propOwner.partProperties.setPropertyNamed(
                        propOwner,
                        pin,
                        false
                    );
                });
                return;
            }
            pinningAdjust(propOwner, value);
        },

        // Getter
        function(propOwner, propObject){
            let top = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-top'
            );
            let bottom = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-bottom'
            );
            let left = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-left'
            );
            let right = propOwner.partProperties.getPropertyNamed(
                propOwner,
                'pinning-right'
            );
            let result = [];
            if(top){
                result.push('top');
            } else if(bottom){
                result.push('bottom');
            }
            if(left){
                result.push('left');
            } else if(right){
                result.push('right');
            }

            return result.join('-');
        }
    );
};

/**
 * Style properties for Parts that display
 * text
 */
const addTextStyleProps = (target) => {
    target.partProperties.newStyleProp(
        'text-align',
        'left',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-font',
        'default',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-color',
        "rgb(0, 0, 0)", // black
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-transparency',
        1,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-style',
        'plain',
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-bold',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-italic',
        false,
        'cssTextStyle'
    );
    target.partProperties.newStyleProp(
        'text-size',
        15,
        'cssTextStyle'
    );
};

/**
 * Basic layout styles are those pertaining
 * to the positioning and resizing of subparts.
 * Examples include Cards and Area
 */
const addLayoutStyleProps = (target) => {
    // The 'layout' property is
    // one of two strings:
    // strict - Equivalent to the absolute
    // layout based strictly on coordinates
    // list - Will force items into either a row
    // or column list, based on the pairing with
    // the 'listDirection' property
    target.partProperties.newBasicProp(
        'layout',
        'strict'
    );

    // list-direction specifies row or column
    // and will only have an effect whent the
    // layout property is set to 'list'
    target.partProperties.newBasicProp(
        'list-direction',
        'row'
    );

    // Wrapping specifies whether a list should
    // wrap along its dominant dimension (row or column)
    target.partProperties.newBasicProp(
        'list-wrapping',
        false
    );

    // Padding specifies some space from the
    // border of the target Part to the beginning
    // of the layout of any subparts.
    target.partProperties.newStyleProp(
        'top-padding',
        null
    );
    target.partProperties.newStyleProp(
        'right-padding',
        null
    );
    target.partProperties.newStyleProp(
        'bottom-padding',
        null
    );
    target.partProperties.newStyleProp(
        'left-padding',
        null
    );

    // List alignment describes how elements in
    // a list layout should align themselves along
    // the dominant dimension (row or column)
    // They are essentially proxies for align-items
    target.partProperties.newBasicProp(
        'list-alignment',
        null
    );

    // List distribution describes how elements
    // in a list layout should distribute themselves
    // across or along the dominant dimension
    // (row or column)
    // This is essentially a wrapper for justify-content
    target.partProperties.newBasicProp(
        'list-distribution',
        null
    );
};

/**
  * HELPERS
 **/

const pinningSetter = (propOwner, propObject, value) => {
    let side = propObject.name.split("-")[1];
    let topLeft;
    switch (side){
    case "right":
        topLeft = "left";
        break;
    case "bottom":
        topLeft = "top";
        break;
    default:
        topLeft = side;
    }
    // we'll need to fix and un-fix the corresponding top or left property depending
    // on whether value is true of false, respectively
    let prop = propOwner.partProperties.findPropertyNamed(
        topLeft 
    );
    let oppositeSide;
    switch (side){
    case "left":
        oppositeSide = "right";
        break;
    case "right":
        oppositeSide = "left";
        break;
    case "top":
        oppositeSide = "bottom";
        break;
    case "bottom":
        oppositeSide = "top";
        break;
    }
    if(value){
        // first make sure that pinning-bottom is false
        propOwner.partProperties.setPropertyNamed(
            propOwner,
            `pinning-${oppositeSide}`,
            false
        );
        prop.readOnly = true;
    } else {
        // reset the value back to trigger a notification
        prop.setValue(propOwner, prop._value);
        prop.readOnly = false;
    }
    propObject._value = value;
};

const pinningAdjust = (owner, value) => {
    let sides = ['top', 'left', 'right', 'bottom'];
    sides.forEach(side => {
        if(value.startsWith(side)){
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                true
            );
        } else {
            owner.partProperties.setPropertyNamed(
                owner,
                `pinning-${side}`,
                false
            );
        }
    });

    if(value.includes("-")){
        if(value.endsWith('left')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                true
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                false
            );
        } else if(value.endsWith('right')){
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-left',
                false
            );
            owner.partProperties.setPropertyNamed(
                owner,
                'pinning-right',
                true
            );
        }
    }
};




/***/ }),

/***/ "./js/objects/utils/styler.js":
/*!************************************!*\
  !*** ./js/objects/utils/styler.js ***!
  \************************************/
/*! exports provided: cssStyler, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssStyler", function() { return cssStyler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cssStyler; });
/**
 * Styler
 * ------------------------------------
 * I am responsible for converting
 * SimpleTalk visual styling to a dict
 * Object of CSS JavaScript type key-value pairs
 */

/** I style the styleObj
 * styleObj: css JavaScript key:value pairs
 * propertyName: (SimpleTalk) styling property name
 * propertyValue: (SimpleTalk) styling property value
 */

const cssStyler = (styleObj, propertyName, propertyValue) => {
    switch(propertyName){

    case "background-color":
        _setOrNot(styleObj, "backgroundColor",  _colorToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "background-transparency":
        // here we set the Alpha value of the current styleObj["backgroundColor"] rgba
        _setOrNot(styleObj, "backgroundColor",  _colorTransparencyToRGBA(styleObj["backgroundColor"], propertyValue));
        break;

    case "border-top-style":
    case "border-bottom-style":
    case "border-left-style":
    case "border-right-style": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-style`,  propertyValue);
        break;
    }

    case "border-top-width":
    case "border-bottom-width":
    case "border-left-width":
    case "border-right-width": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-width`,  _intToPx(propertyValue));
        break;
    }

    case "border-top-color":
    case "border-bottom-color":
    case "border-top-color":
    case "border-right-color": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "border-top-transparency":
    case "border-bottom-transparency":
    case "border-left-transparency":
    case "border-right-transparency": {
        let s = propertyName.split("-")[1];
        _setOrNot(styleObj, `border-${s}-color`,  _colorTransparencyToRGBA(styleObj[`border-${s}-color`], propertyValue));
        break;
    }

    case "corner-top-left-round":
    case "corner-top-right-round":
    case "corner-bottom-left-round":
    case "corner-bottom-right-round":{
        let c1 = propertyName.split("-")[1];
        let c2 = propertyName.split("-")[2];
        _setOrNot(styleObj, `border-${c1}-${c2}-radius`,  _intToPx(propertyValue));
        break;
    }

    case "shadow-left":
    case "shadow-top":
    case "shadow-blur":
    case "shadow-spread":
    case "shadow-color":
    case "shadow-transparency":
        let shadowProp = propertyName.split("-")[1];
        let [left, top, blur, spread, color] = _cssBoxShadow(styleObj["box-shadow"]);
        switch(shadowProp){
        case "color":
            color = _colorToRGBA(color, propertyValue);
            break;
        case "transparency":
            color = _colorTransparencyToRGBA(color, propertyValue);
            break;
        case "left":
            left = _intToPx(propertyValue);
            break;
        case "top":
            top = _intToPx(propertyValue);
            break;
        case "blur":
            blur = _intToPx(propertyValue);
            break;
        case "spread":
            spread = _intToPx(propertyValue);
            break;
        }
        _setOrNot(styleObj, "box-shadow", `${left} ${top} ${blur} ${spread} ${color}`);
        break;

    case "text-color":
        _setOrNot(styleObj, "color",  _colorToRGBA(styleObj["color"], propertyValue));
        break;

    case "text-font":
        _setOrNot(styleObj, "fontFamily",  propertyValue);
        break;

    case "text-size":
        _setOrNot(styleObj, "fontSize", propertyValue);
        break;

    case "text-align":
        _setOrNot(styleObj, "textAlign",  propertyValue);
        break;

    case "text-bold":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-weight",  "bold");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-weight",  "normal");
        }
        break;

    case "text-italic":
        if(propertyValue === true){
            _setOrNot(styleObj, "font-style",  "italic");
        } else if(propertyValue === false){
            _setOrNot(styleObj, "font-style",  "normal");
        }
        break;

    case "text-underline":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "underline");
        }
        break;

    case "text-strikethrough":
        if(propertyValue === true){
            _setOrNot(styleObj, "textDecoration",  "line-through");
        }
        break;

    case "text-transparency":
        // here we set the Alpha value of the current styleObj["color"] rgba
        _setOrNot(styleObj, "color",  _colorTransparencyToRGBA(styleObj["color"], propertyValue));
        break;

    case "top":
        _setOrNot(styleObj, "top",  _intToPx(propertyValue));
        break;

    case "left":
        _setOrNot(styleObj, "left",  _intToPx(propertyValue));
        break;

    case "width":
        _setOrNot(styleObj, "width",  _intToPx(propertyValue));
        break;

    case "height":
        _setOrNot(styleObj, "height",  _intToPx(propertyValue));
        break;

    case "left-margin":
    case "right-margin":
    case "bottom-margin":
    case "top-margin":
        let marginSide = propertyName.split("-")[0];
        marginSide = `${marginSide[0].toUpperCase()}${marginSide.slice(1)}`;
        _setOrNot(styleObj, `margin${marginSide}`, _intToPx(propertyValue));
        break;

    case "left-padding":
    case "right-padding":
    case "bottom-padding":
    case "top-padding":
        let paddingSide = propertyName.split("-")[0];
        paddingSide = `${paddingSide[0].toUpperCase()}${paddingSide.slice(1)}`;
        _setOrNot(styleObj, `padding${paddingSide}`, _intToPx(propertyValue));
        break;

    case "text-style":
        _setOrNot(styleObj, "textStyle",  propertyValue);
        break;

    case "rotate":
        _setOrNot(styleObj, "transform",  _intToRotateDeg(propertyValue));
        break;

    case "transparency":
        _setOrNot(styleObj, "opacity",  propertyValue);
        break;

    case "hide":
        if(propertyValue === true){
            styleObj["display"] = "none";
        } else if(propertyValue === false){
            styleObj["display"] = null;
        }
        break;


    default:
        // for the default we simply allow ST style names to map 1-1
        // to CSS/JS style names. This is only somewhat safe, since the DOM
        // will simply ignore nonsense names without throwing an error. But it
        // does allow us to avoid writing a rule for every term (example: width,
        // height, top, left etc)
        _setOrNot(styleObj, propertyName,  propertyValue);
    }
    return styleObj;

};

// In order to avoid clashing with views interacting
// the style attribute directly we ignore everything that
// is either null or undefined
// TODO review this decision!
const _setOrNot = (styleObj, name, value) => {
    if(value !== null && value !== undefined){
        styleObj[name] = value;
    }
};

const _intToRotateDeg = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            n = n.split("deg")[0];
        }
        return `rotate(${n}deg)`;
    }
};


const _intToPx = (n) => {
    if(n !== null && n !== undefined){
        if(typeof(n) === "string"){
            if(n == "fill"){
                return "100%";
            } else if(["thin", "medium", "thick"].indexOf(n) > -1){
                return n;
            }
            n = n.split("px")[0];
        }
        return `${n}px`;
    }
};

// Convert colors to rgba
// change a css color RGB values, preserving the A(lpha) value
const _colorToRGBA = (cssColor, STColor) => {
    if(!STColor){
        return;
    }
    let r, g, b, a, _;
    // ST colors are RGB
    if(STColor.startsWith("rgb")){
        [r, g, b] = STColor.match(/\d+/g);
    } else {
        let colorInfo = basicCSSColors[STColor];
        if(colorInfo){
            r = colorInfo["r"];
            g = colorInfo["g"];
            b = colorInfo["b"];
        } else {
            return;
        }
    }
    if(cssColor){
        [_, _, _, a] = cssColor.match(/[\d\.]+/g);
        // if Alpha is not defined then we set it to 1
        // default for browsers
    }
    if(!a){
        a = 1;
    }
    return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// change the A(alpha) value, preserving the RGB values
const _colorTransparencyToRGBA = (cssColor, tValue) => {
    if(!cssColor){
        return;
    }

    let r, g, b;
    let mappedColor = basicCSSColors[cssColor];
    if(mappedColor){
        r = mappedColor.r;
        g = mappedColor.g;
        b = mappedColor.b;
    } else {
        [r, g, b] = cssColor.match(/\d+/g);
    }
    
    return `rgba(${r}, ${g}, ${b}, ${tValue})`;
}

// Add more colors as needed
const basicCSSColors = {
    black: {hex: "#000000", r: 0, g: 0, b: 0},
		silver: {hex: "#C0C0C0", r: 192, g: 192, b: 192},
		gray: {hex: "#808080", r: 128, g: 128, b: 128},
		white: {hex: "#FFFFFF", r: 255, g: 255, b: 255},
		maroon: {hex: "#800000", r: 128, g: 0, b: 0},
		red: {hex: "#FF0000", r: 255, g: 0, b: 0},
		purple: {hex: "#800080", r: 128, g: 0, b: 128},
		fuchsia: {hex: "#FF00FF", r: 255, g: 0, b: 255},
		green: {hex: "#008000", r: 0, g: 128, b: 0},
		lime: {hex: "#00FF00", r: 0, g: 255, b: 0},
		olive: {hex: "#808000", r: 128, g: 128, b: 0},
		yellow: {hex: "#FFFF00", r: 255, g: 255, b: 0},
		navy: {hex: "#000080", r: 0, g: 0, b: 128},
		blue: {hex: "#0000FF", r: 0, g: 0, b: 255},
		teal: {hex: "#008080", r: 0, g: 128, b: 128},
		aqua: {hex: "#00FFFF", r: 0, g: 255, b: 255},
};

// take the css box-shadow property and return its
// components (offset-y, offset-x, blur, spread and color)
// if the value is not defined return a default
const _cssBoxShadow = (cssPropValue) =>{
    if(!cssPropValue){
        return ["0px", "0px", "0px", "0px", "rgba(0, 0, 0, 1)"];
    }
    let [intValues, rgba] = cssPropValue.split(" rgba");
    let [left, top, blur, spread] = intValues.split(" ");
    return [left, top, blur, spread, `rgba${rgba}`];
}




/***/ }),

/***/ "./js/objects/views/AreaView.js":
/*!**************************************!*\
  !*** ./js/objects/views/AreaView.js ***!
  \**************************************/
/*! exports provided: AreaView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaView", function() { return AreaView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AreaView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * AreaView
 * -------------------------------
 * I am a webcomponent representation
 * of an Area, which is a grouping of
 * Parts that have some kind of layout
 * specified
 */


const templateString = `
                <style>
                #area-wrapper {
                    display: inherit;
                    flex-direction: inherit;
                    flex-wrap: inherit;
                    align-items: inherit;
                    align-content: inherit;
                    justify-content: inherit;
                    position: relative; 
                    width: 100%;
                    height: 100%;
                    border-radius: inherit;
                }
                .clip {
                    overflow: hidden;  
                }
                .allow-scroll {
                    overflow: auto;
                }
                </style>
                <div id="area-wrapper">
                <slot></slot>
                </div>
`;

class AreaView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.clippingChanged = this.clippingChanged.bind(this);
        this.allowScrollingChanged = this.allowScrollingChanged.bind(this);

        // Prop change handlers
        this.onPropChange('clipping', this.clippingChanged);
        this.onPropChange('allow-scrolling', this.allowScrollingChanged);
    }

    afterModelSet(){
        let clipping = this.model.partProperties.getPropertyNamed(
            this.model,
            "clipping"
        );
        this.clippingChanged(clipping, this.model.id);
    }

    clippingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('allow-scroll');
            wrapper.classList.add('clip');
        } else {
            wrapper.classList.remove('clip');
        }
    }

    allowScrollingChanged(newVal, id){
        let wrapper = this._shadowRoot.getElementById('area-wrapper');
        if(newVal == true){
            wrapper.classList.remove('clip');
            wrapper.classList.add('allow-scroll');
        } else {
            wrapper.classList.remove('allow-scroll');
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        let layout = this.model.partProperties.getPropertyNamed(
            this.model,
            'layout'
        );
        let direction = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-direction'
        );
        if(layout != 'list'){
            contextMenu.addListItem(
                "Set Layout to List",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'list'
                    );
                }
            );
        } else {
            contextMenu.addListItem(
                "Set Layout to Strict",
                (event) => {
                    this.model.partProperties.setPropertyNamed(
                        this.model,
                        'layout',
                        'strict'
                    );
                }
            );
            if(direction == 'row'){
                contextMenu.addListItem(
                    "Set List Direction to Column",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'column'
                        );
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Set List Direction to Column",
                    (event) => {
                        this.model.partProperties.setPropertyNamed(
                            this.model,
                            'list-direction',
                            'row'
                        );
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/AudioView.js":
/*!***************************************!*\
  !*** ./js/objects/views/AudioView.js ***!
  \***************************************/
/*! exports provided: AudioView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioView", function() { return AudioView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AudioView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <audio></audio>
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-music" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="6" cy="17" r="3"></circle>
    <circle cx="16" cy="17" r="3"></circle>
    <polyline points="9 17 9 4 19 4 19 17"></polyline>
    <line x1="9" y1="8" x2="19" y2="8"></line>
    </svg>
</div>
`;

// HTMLMediaElementStates copied from
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
const mediaStates = {
    0: "HAVE_NOTHING",
    1: "HAVE_METADATA",
    2: "HAVE_CURRENT_DATA",
    3: "HAVE_FUTURE_DATA",
    4: "HAVE_ENOUGH_DATA"
};

class AudioView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateAudioLink = this.updateAudioLink.bind(this);
        this.play = this.play.bind(this);
        this.pause = this.pause.bind(this);
    }

    afterConnected(){
        let audio = this._shadowRoot.querySelector("audio");
        audio.addEventListener('loadeddata', () => {
            let stateCode = audio.readyState;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "readyState",
                mediaStates[stateCode]
            );
        });

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        this.model.partProperties.setPropertyNamed(
            this.model,
            "readyState",
           "HAVE_NOTHING"
        );
        let audio = this._shadowRoot.querySelector("audio");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            audio.src = src;
        }
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", (value) => {
            let borderColor = "red";
            if(value == "HAVE_FUTURE_DATA" || value == "HAVE_ENOUGH_DATA"){
                borderColor = "green";
            };
            ["right", "left", "top", "bottom"].forEach((side) => {
                this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
            });
        });
        this.onPropChange("play", (value) => {
            if(value === true){
                this.play();
            } else if (value === false){
                this.pause();
            }
        });
        this.onPropChange("stop", (value) => {
            if(value === true){
                audio.currentTime = 0;
            }
        });
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <audio> element
                audio.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "audio",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    play(){
        // first make sure that the resource is ready
        let audio = this._shadowRoot.querySelector("audio");
        let readyState = this.model.partProperties.getPropertyNamed(this.model, "readyState");
        if(readyState == "HAVE_FUTURE_DATA" || readyState == "HAVE_ENOUGH_DATA"){
            audio.play();
        } else {
            alert(`audio is not ready; current state: ${readyState}`);
        }
    }

    pause(){
        this._shadowRoot.querySelector("audio").pause();
    }

    // re-loads the media, setting it back to the beggning
    stop(){
        this._shadowRoot.querySelector("audio").load();
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-audio-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for audio source');
        this.haloButton.addEventListener('click', this.updateAudioLink);
    }

    updateAudioLink(event){
        // Tells the model to update its
        // src link for the audio
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for audio:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadAudioFromSource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/BrowserView.js":
/*!*****************************************!*\
  !*** ./js/objects/views/BrowserView.js ***!
  \*****************************************/
/*! exports provided: BrowserView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserView", function() { return BrowserView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BrowserView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
    cursor: pointer;
}
iframe {
    width: 100%;
    height: 100%;
}
</style>
<iframe frameborder="0" allowfullscreen></iframe>
`;

class BrowserView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateBrowserLink = this.updateBrowserLink.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let iframe = this._shadowRoot.querySelector("iframe");
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            iframe.src = src;
        }
        this.onPropChange("src", (url) => {
            try{
                // resource load is auto-loaded by the <browser> element
                iframe.src = url;
            } catch(error){
                let errorMsg = {
                    type: "error",
                    name: "ResourceNotFound",
                    resourceType: "browser",
                    partId: this.model.id,
                    details: {source: url, type: "url"}

                };
                this.model.sendMessage({errorMsg}, this.model);
            }
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-browser-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for browser source');
        this.haloButton.addEventListener('click', this.updateBrowserLink);
    }

    updateBrowserLink(event){
        // Tells the model to update its
        // src link for the browser
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for browser:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'setURLTo',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/ButtonView.js":
/*!****************************************!*\
  !*** ./js/objects/views/ButtonView.js ***!
  \****************************************/
/*! exports provided: ButtonView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonView", function() { return ButtonView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ButtonView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * ButtonView
 * ---------------------------------------------------
 * I am a webcomponent representing a Button.
 */


const templateString = `
                <style>
                 .st-button-label {
                     user-select: none;
                     pointer-events: none;
                     text-overflow: ellipsis;
                     overflow: hidden;
                     max-width: 95%;
                     white-space: nowrap;
                 }
                </style>
                <span class="st-button-label">
                    <slot></slot><!-- Text of the Name -->
                </span>
`;

class ButtonView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bound methods
        this.setupPropHandlers = this.setupPropHandlers.bind(this);

        // Setup prop change handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('name', (value, partId) => {
            this.innerText = value;
        });
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    afterModelSet(){
        let buttonName = this.model.partProperties.getPropertyNamed(this, "name");
        if(buttonName){
            this.innerText = buttonName;
        };
    }

    // override the base class implementation
    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }
};




/***/ }),

/***/ "./js/objects/views/CardView.js":
/*!**************************************!*\
  !*** ./js/objects/views/CardView.js ***!
  \**************************************/
/*! exports provided: CardView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardView", function() { return CardView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * CardView
 * --------------------------------------------------
 * I am a webcomponent representation of a Card.
 */



const templateString = `
                <style>
                </style>
                <slot></slot>
`;

class CardView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Bind component methods
    }

    afterConnected(){
    }

    afterDisconnected(){
    }

    // override the default class method
    onClick(event){
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            event.stopPropagation();
        }
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        // Toolbox toggle hide/unhide
        let currentStack = window.System.getCurrentStackModel();
        let toolbox = currentStack.subparts.filter((part) => {
            let name = part.partProperties.getPropertyNamed(part, "name");
            return name == "Toolbox";
        })[0];
        // if there is no toolbox at all, that's weird but don't do anything
        if(toolbox){
            let hidden = toolbox.partProperties.getPropertyNamed(toolbox, "hide");
            if(hidden){
                contextMenu.addListItem(
                    "Unhide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", false);
                    }
                );
            } else {
                contextMenu.addListItem(
                    "Hide Toolbox",
                    (event) => {
                        toolbox.partProperties.setPropertyNamed(toolbox, "hide", true);
                    }
                );
            }
        }
    }
};




/***/ }),

/***/ "./js/objects/views/FieldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/FieldView.js ***!
  \***************************************/
/*! exports provided: FieldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldView", function() { return FieldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FieldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils//styler.js */ "./js/objects/utils/styler.js");
/* harmony import */ var _drawing_ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing/ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/AltSyntaxHighlighter.js */ "./js/objects/utils/AltSyntaxHighlighter.js");
/**
 * FieldView
 * ---------------------------------
 * I am the view of an Field part.
 * I am an "interim" view intended to display
 * and edit plain text on a Card.
 * I should be replaced with a more comprehensive
 * implementation of Field/FieldView in the future.
 */






const haloEditButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tools" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M3 21h4l13 -13a1.5 1.5 0 0 0 -4 -4l-13 13v4" />
  <line x1="14.5" y1="5.5" x2="18.5" y2="9.5" />
  <polyline points="12 8 7 3 3 7 8 12" />
  <line x1="7" y1="8" x2="5.5" y2="9.5" />
  <polyline points="16 12 21 17 17 21 12 16" />
  <line x1="16" y1="17" x2="14.5" y2="18.5" />
</svg>
`;

const haloLockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-4a4 4 0 0 1 8 0v4"></path>
</svg>
`;

const haloUnlockButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-lock-open" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="5" y="11" width="14" height="10" rx="2"></rect>
   <circle cx="12" cy="16" r="1"></circle>
   <path d="M8 11v-5a4 4 0 0 1 8 0"></path>
</svg>
`;

const fieldTemplateString = `
      <style>
        .field {
            display: flex;
            align-items: center;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: auto;
        }

        .field color-wheel {
            position: absolute;
        }

        .field-textarea {
            width: calc(100% - 5px);
            height: 100%;
            width: 100%;
            white-space: pre-wrap;
            overflow-wrap: anywhere;
        }

        /* Syntax Highlighting
 *---------------------------------------------------*/
span[data-st-rule="messageName"]{
    text-decoration: underline;
}

span[data-st-rule="keyword"]{
    font-weight: bold;
}

span[data-st-rule="ParameterList-item"]{
    font-style: italic;
    color: grey;
}


    </style>
    <div class="field">
        <div class="field-textarea" spellcheck="false"></div>
    </div>`;


function formatDoc(sCmd, sValue) {
  document.execCommand(sCmd, false, sValue); oDoc.focus();
}

class FieldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // this.editorCompleter = this.simpleTalkCompleter;
        this.textStyler = _utils_styler_js__WEBPACK_IMPORTED_MODULE_1__["default"];  // we might want to consider a more programmatic way to set this
        this.editorCompleter = null;
        this.contextMenuOpen = false;
        this.haloLockUnlockButton = null;
        this.selectionRanges = {};
        this.wantsContextMenu = false;

        // Presets for syntax highlighting.
        // When highlighting is enabled, we will check
        // each line of the text for the following
        // grammatical rules:
        this._syntaxRules = [
            "MessageHandlerOpen",
            "MessageHandlerClose"
        ];

        this.template = document.createElement('template');
        this.template.innerHTML = fieldTemplateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onInput = this.onInput.bind(this);
        this.onBeforeInput = this.onBeforeInput.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onKeydown = this.onKeydown.bind(this);
        this.onMousedown = this.onMousedown.bind(this);
        this.openContextMenu = this.openContextMenu.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);
        this.doIt = this.doIt.bind(this);
        this.handleSelection = this.handleSelection.bind(this);
        this.openField = this.openField.bind(this);
        this.textToHtml = this.textToHtml.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.simpleTalkCompleter = this.simpleTalkCompleter.bind(this);
        this.initCustomHaloButtons = this.initCustomHaloButtons.bind(this);
        this.insertRange = this.insertRange.bind(this);
        this.setRangeInTarget = this.setRangeInTarget.bind(this);
        this.setSelection = this.setSelection.bind(this);
        this.highlightSyntax = this.highlightSyntax.bind(this);
        this.unhighlightSyntax = this.unhighlightSyntax.bind(this);

        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('editable', (value, id) => {
            this.textarea.setAttribute('contenteditable', value);
            if(value === true){
                this.haloLockUnlockButton = this.haloLockButton;
                this.classList.add("editable");
            } else if (value === false){
                this.haloLockUnlockButton = this.haloUnlockButton;
                this.classList.remove("editable");
            }
        });
        // 'text' is a DynamicProp whose setter will set the corresponding
        // value for `innerHTML`. This way we can have programmatic content
        // setting and still allow to not loose markup.
        // 'innerHTML' is a BasicProp. See how these are set, without
        // notification in this.onInput()
        this.onPropChange('innerHTML', (value, id) => {
            this.textarea.innerHTML = value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                "text",
                this.textarea.innerText,
                false // do not notify, to avoid an infinite loop
            );
        });
    }

    afterConnected(){
        // The events here are added via the .addEventListener() API which is
        // distinct from the this.eventRespond() which uses the DOM element
        // element.onEvent API. This allows us to distnguish between "core"
        // system-web events that we don't want meddled with at the moment, like
        // entering text in a field, and ones exposed in the environemnt for scripting
        this.textarea = this._shadowRoot.querySelector('.field-textarea');

        this.textarea.addEventListener('input', this.onInput);
        //this.textarea.addEventListener('beforeinput', this.onBeforeInput);
        this.textarea.addEventListener('keydown', this.onKeydown);
        this.textarea.addEventListener('mousedown', this.onMousedown);
        // No need to add a click listener as the base PartView class does that

        // in order to deal with range insertions (for styling text fragments within
        // the textarea), we need to have the default paragraph tag = </br>. Otherwise
        // the insert new line is of the form <div></br><div> which causes the appearance
        // of newlines when nodes are inserted into a range
        //document.execCommand("defaultParagraphSeparator", false, "st-line");
    }

    afterDisconnected(){
        this.textarea.removeEventListener('input', this.onInput);
        //this.textarea.removeEventListener('beforeinput', this.onBeforeInput);
        this.textarea.removeEventListener('keydown', this.onKeydown);
        this.textarea.removeEventListener('mousedown', this.onMousedown);
    }

    afterModelSet(){
        this.textarea = this._shadowRoot.querySelector('.field-textarea');
        // If we have a model, set the value of the textarea
        // to the current html of the field model
        let innerHTML = this.model.partProperties.getPropertyNamed(
            this.model,
            'innerHTML'
        );
        this.textarea.innerHTML = innerHTML;

        let isEditable = this.model.partProperties.getPropertyNamed(this.model, "editable");
        this.textarea.setAttribute('contenteditable', isEditable);

        // setup the lock/unlock halo button
        this.initCustomHaloButtons();
        let editable = this.model.partProperties.getPropertyNamed(
            this.model,
            'editable'
        );
        if(editable === true){
            this.haloLockUnlockButton = this.haloLockButton;
            this.classList.add("editable");
        } else if (editable === false){
            this.haloLockUnlockButton = this.haloUnlockButton;
            this.classList.remove("editable");
        }
    }

    simpleTalkCompleter(element){
        let textContent = this.htmlToText(element);
        let startOfHandlerRegex = /^on\s(\w+)(\s|\n)+$/;
        let match = textContent.match(startOfHandlerRegex);
        if(match){
            let messageName = match[1];
            // if input break is a new line then an extra
            // <div></br></div> has beed added into the elemen already
            let tabLine = "\t\n";
            if(match[2] === "\n"){
                tabLine= "";
            }
            textContent = `${tabLine}end ${messageName}`;
            let innerHTML = this.textToHtml(textContent);
            element.insertAdjacentHTML("beforeend", innerHTML);
        }
        return element.innerHTML;
    }

    /*
     * I override my base-class's implementation to handle target related functionality
     */
    styleTextCSS(){
        let textarea = this._shadowRoot.querySelector('.field-textarea');
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            textarea.style[key] = value;
        });
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, this.textarea.innerHTML, cssStyle);
        }
    }

    /*
     * set a text-* property on selection to style the selected text
     * Note: this is done for every current selection, i.e. everthing
     * in this.selectionRanges
     */
    setSelection(propName, value){
        Object.values(this.selectionRanges).forEach((range) => {
            let currentStyle = {};
            // // if the document fragment has one child node and it's a span
            // // we should style that directly. This avoids unncessary DOM elements
            // // being created to wrap the contents, such as when styling is continually
            // // applied ot the same selection
            // let span;
            // if(docFragment.childNodes.length == 1 && docFragment.childNodes[0].nodeName == "SPAN"){
            //     span = docFragment.childNodes[0];
            //     // Note the use of Obejct.values here for the DOM style attribute object
            //     // that's weird
            //     Object.values(span.style).forEach((key) => {
            //         currentStyle[key] = span.style[key];
            //     });
            // } else {
            //     // we need to create a span element to wrap the contents in style
            //     span = document.createElement('span');
            //     // While tempting to use range.surroundContents() avoid this
            //     // since it will fail with a non-informative error if the range
            //     // includes partial nodes (ex text across various nodes)
            //     while (docFragment.childNodes.length){
            //         span.appendChild(docFragment.childNodes[0]);
            //     }
            // }
            let span = document.createElement('span');
            let cssObject = this.textStyler(currentStyle, propName, value);
            Object.keys(cssObject).forEach((key) => {
                span.style[key] = cssObject[key];
            });

            span.append(range.extractContents());
            range.insertNode(span);
            
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
            // if there is a target and range set then send the target an update message
            let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
            if(target){
                this.setRangeInTarget(target, this.textarea.innerHTML);
            }
        });
    }

    onBeforeInput(event){
        let selection = document.getSelection();
        let selectedRange = selection.getRangeAt(0);
        let range = selectedRange.cloneRange();

        let innerHTML = event.target.innerHTML;
        if(!innerHTML.endsWith("<div><br></div>")){
            innerHTML += "<div><br></div>";
            event.target.innerHTML = innerHTML;
        }
        
        if(event.inputType == "insertParagraph"){
            //event.stopPropagation();
            event.preventDefault();

            let br = document.createElement('br');
            let br2 = document.createElement('br');
            range.insertNode(br);
            range.collapse(false);
            range.insertNode(br2);
            range.setStartAfter(br2);
            range.setEndAfter(br2);
        }
    }

    onInput(event){
        let innerHTML = event.target.innerHTML;
        /*
        if(!innerHTML.endsWith("<br>")){
            innerHTML += "<br>";
            event.target.innerHTML = innerHTML;
        }
        */

        if(this.editorCompleter){
            // TODO sort out how this would work
            let innerHTML = event.target.innerHTML;
            innerHTML = this.editorCompleter(event.target);
        }

        this.model.partProperties.setPropertyNamed(
            this.model,
            'text',
            event.target.innerText,
            false // do not notify, to preserve contenteditable context
        );
        this.model.partProperties.setPropertyNamed(
            this.model,
            'innerHTML',
            event.target.innerHTML,
            false // do not notify
        );
        // Since we update the 'text' property without notification, the part/model
        // is not sent the "propertyChanged" message so we do so manually
        this.model.propertyChanged("text", event.target.innerText);
        // if there is a target and range set then send the target an update message
        let target = this.model.partProperties.getPropertyNamed(this.model, 'target');
        if(target){
            this.setRangeInTarget(target, event.target.innerHTML);
        }
    }

    onKeydown(event){
        // prevent the default tab key to leave focus on the field
        if(event.key==="Tab"){
            event.preventDefault();
            //document.execCommand('insertHTML', false, '&#x9');
            let sel = document.getSelection();
            let range = sel.getRangeAt(0);

            let tabNodeValue = '\t';
            let tabNode = document.createTextNode(tabNodeValue);

            range.insertNode(tabNode);

            range.setStartAfter(tabNode);
            range.setEndAfter(tabNode);
        };
    }

    onMousedown(event){
        // clear all selections
        this.selectionRanges = {};
    }
    onClick(event){
        event.preventDefault();
        event.stopPropagation();
        if(event.button == 0){
            // if the shift key is pressed we toggle the halo
            if(event.shiftKey){
                this.onHaloActivationClick(event);
            } else{
                let text = window.getSelection().toString();
                // if no text is selected we do nothing
                if(text){
                    // if the altKey is pressed we open the context ("do it") menu
                    if(event.altKey){
                        if(!this.contextMenuOpen){
                            this.openContextMenu();
                        }
                    } else {
                        this.handleSelection(event.metaKey);
                    }
                } else {
                    // make sure no context menu is open
                    if(this.contextMenuOpen){
                        this.closeContextMenu();
                    }
                    // clear all the selections
                    this.selectionRanges = {};
                }
            }
        }
    }

    /* I handle selected text, creating a new field model/view
     * for every range in the selection, keeping track of every range
     * in this.selection Object/dict so that modification can be inserted
     * back into the corresponding ranges.
     */
    handleSelection(openNewField){
        let selection = window.getSelection();
        for(let i=0; i < selection.rangeCount; i++){
            // make sure this is not a continuing selection
            // and that the range is not already registered
            let range = selection.getRangeAt(i);
            let currentRanges = Object.values(this.selectionRanges);
            if(currentRanges.indexOf(range) >= 0){
                continue;
            }
            // we generate our own range ids, since we want this to correspond to
            // selection order which is not respected by the browser selection object
            // to ensure we don't hit on other views' ranges by accident we need unique id's
            let rangeId = Date.now(); //TODO we need a better random id
            this.selectionRanges[rangeId] = range;
            if(openNewField){
                // open a field for each new selection and populate it with the range html
                this.openField(range, rangeId);
            }
        }
    }

    openField(range, rangeId){
        // create an HTML document fragment from the range to avoid dealing wiht start/end
        // and offset calculations
        // fragments don't have the full html DOM element API so we need to create one
        let span = document.createElement('span');
        span.appendChild(range.cloneContents());

        // TODO these should all be messages and correspnding command handler definitions
        // should be part of the field's own script
        let fieldModel = window.System.newModel("field", this.model._owner.id, `selection ${rangeId}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "innerHTML", span.innerHTML);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "target", `field id ${this.model.id}`);
        fieldModel.partProperties.setPropertyNamed(fieldModel, "targetRangeId", rangeId);
    }

    /**
      * Given a tagrget specifier and html
      * I first look up to make sure that the target has the corresponding
      * range (coming from the targetRangeId property), and then set it with my
      * innerHTML. Note, since the target property value is an object specifier I
      * create a semantics objects and interpret the value resulting in a valid
      * part id.
      */
    setRangeInTarget(targetSpecifier, html, css){
        let targetRangeId = this.model.partProperties.getPropertyNamed(this.model, 'targetRangeId');
        let match = window.System.grammar.match(targetSpecifier, "ObjectSpecifier");
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation('interpret', Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this.model, window.System));
        let targetId = semantics(match).interpret();

        this.model.sendMessage({
            type: "command",
            commandName: "insertRange",
            args: [targetRangeId, html, css]
        }, window.System.partsById[targetId]);
    }

    /*
     * I insert the html (string) into the specified range (by id)
     */
    insertRange(rangeId, html, cssObj){
        let range = this.selectionRanges[rangeId];
        if(range){
            let span = document.createElement('span');
            span.innerHTML = html;
            if(cssObj){
                Object.keys(cssObj).forEach((key) => {
                    let value = cssObj[key];
                    span.style[key] = value;
                });
            }
            range.deleteContents();
            range.insertNode(span);
            // update the text and innerHTML properties without notification
            // to prevent unnecessary setting of the text/html
            this.model.partProperties.setPropertyNamed(
                this.model,
                'text',
                this.textarea.innerText,
                false // do not notify, to preserve contenteditable context
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'innerHTML',
                this.textarea.innerHTML,
                false // do not notify
            );
        }
    }

    openContextMenu(){
        let text = document.getSelection().toString();
        let focusNode = document.getSelection().focusNode;
        let button = document.createElement("button");
        button.id = "doIt";
        button.style.marginLeft = "10px";
        button.style.backgroundColor = "var(--palette-green)";
        button.textContent = "Do it!";
        button.addEventListener("click", this.doIt);
        focusNode.after(button);
        this.contextMenuOpen = true;
    };

    closeContextMenu(){
        let button = this._shadowRoot.querySelector('#doIt');
        if(button){
            button.remove();
        }
        // clear the selection and set the context menu to closed
        document.getSelection().removeAllRanges();
        this.contextMenuOpen = false;
    }

    doIt(event){
        event.stopPropagation();
        let text = document.getSelection().toString();
        // clean up the text to make sure no newlines or spaces made it in
        text = text.replace(/^[\t\n ]+/, "");
        text = text.replace(/[\t\n ]+$/, "");
        this.closeContextMenu();
        // send message to compile the prepped script
        let script = `on doIt\n   ${text}\nend doIt`;
        // send these messages from the model (not the view)
        // since if there is an error the original sender will
        // have an id
        this.model.sendMessage(
            {
                type: "compile",
                codeString: script,
                targetId: this.model.id
            },
            this.model
        );
        this.model.sendMessage(
            {
                type: "command",
                commandName: "doIt",
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            },
            this.model
        );
    }

    initCustomHaloButtons(){
        this.haloLockButton = document.createElement('div');
        this.haloLockButton.id = "halo-field-lock-editor";
        this.haloLockButton.classList.add('halo-button');
        this.haloLockButton.innerHTML = haloLockButtonSVG;
        this.haloLockButton.style.marginRight = "6px";
        this.haloLockButton.setAttribute('slot', 'bottom-row');
        this.haloLockButton.setAttribute('title', 'Lock Editing');
        this.haloLockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", false],
            }, this.model);
            this.closeHalo();
            this.openHalo();
            // close/open the halo to update the editing state toggle button
        });
        this.haloUnlockButton = document.createElement('div');
        this.haloUnlockButton.id = "halo-field-unlock-editor";
        this.haloUnlockButton.classList.add('halo-button');
        this.haloUnlockButton.innerHTML = haloUnlockButtonSVG;
        this.haloUnlockButton.style.marginRight = "6px";
        this.haloUnlockButton.setAttribute('slot', 'bottom-row');
        this.haloUnlockButton.setAttribute('title', 'Unlock Editing');
        this.haloUnlockButton.addEventListener('click', () => {
            this.model.sendMessage({
                type: 'command',
                commandName: 'setProperty',
                args: ["editable", true],
            }, this.model);
            // close/open the halo to update the editing state toogle button
            this.closeHalo();
            this.openHalo();
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloLockUnlockButton);
    }

    // Overwriting the base class open/close editor methods
    openEditor(){
        window.System.openEditorForPart(this.model.id);
    }

    closeEditor(){
        window.System.closeEditorForPart(this.model.id);
    }


    /*
     * I convert raw text to html respecting the Firefox
     * contenteditable attribute guidelnes.
     * This means that single lins of text are left as is;
     * multiline text, i.e. text which includes "\n", is
     * wrapped in <div></div> for every line; and the last
     * line gets a <br> tag inserted before the </div> to reflect
     * the "on-enter-key" behavior.
     */
    textToHtml(text){
        if(text){
            let textLines = text.split("\n");
            if(textLines.length > 1){
                let html = "";
                textLines.forEach((line) => {
                    if(line){
                        html += `<div>${line}</div>`;
                    } else {
                        html += "<div><br></div>";
                    }
                });
                return  `<div>${html}<br></div>`;
            } else {
                return text;
            }
        } else {
            return "";
        }
    }

    htmlToText(element){
        // TODO this is very naive and ignores most possible structure
        if(element.innerHTML){
            // first replace all the "</div><div>" with line breaks
            let cleanHTML =  element.innerHTML.replace(/<\/div><div>/g, "\n");
            // then remove all html
            let tempElement = document.createElement("div");
            tempElement.innerHTML = cleanHTML;
            let cleanText = tempElement.textContent;
            tempElement.remove();
            return cleanText;
        } else {
            return "";
        }
    }

    highlightSyntax(){
        let current = this.getAttribute("syntax");
        if(current && current !== "false"){
            this.unhighlightSyntax();
        }
        let semantics = window.System.grammar.createSemantics();
        semantics.addOperation(
            "highlightSyntax",
            Object(_utils_AltSyntaxHighlighter_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
        );
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let newHTML = text.split("\n").map(line => {
            // Loop through each rule and try to match
            for(let i = 0; i < this._syntaxRules.length; i++){
                let rule = this._syntaxRules[i];
                let match = window.System.grammar.match(line, rule);
                if(match.succeeded()){
                    return semantics(match).highlightSyntax().outerHTML;
                }
            }
            return line;
        }).join("\n");

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", true);
    }

    unhighlightSyntax(){
        let text = this.model.partProperties.getPropertyNamed(
            this.model,
            "text"
        );
        if(!text){
            return;
        }
        let plainElements = text.split("\n").map(line => {
            let div = document.createElement("div");
            div.innerText = line;
            return div;
        });
        let finalLine = document.createElement("div");
        finalLine.append(document.createElement("br"));
        plainElements.push(finalLine);

        let newHTML = "";
        plainElements.forEach(element => {
            newHTML += element.outerHTML;
        });

        this.model.partProperties.setPropertyNamed(
            this.model,
            "innerHTML",
            newHTML
        );

        this.toggleAttribute("syntax", false);
    }
};




/***/ }),

/***/ "./js/objects/views/Halo.js":
/*!**********************************!*\
  !*** ./js/objects/views/Halo.js ***!
  \**********************************/
/*! exports provided: Halo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Halo", function() { return Halo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Halo; });
/**
 * New Halo
 */

/** Note: Icons are from 
*** https://tablericons.com/
**/
const deleteIcon =`
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-trash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="4" y1="7" x2="20" y2="7" />
  <line x1="10" y1="11" x2="10" y2="17" />
  <line x1="14" y1="11" x2="14" y2="17" />
  <path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" />
  <path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" />
</svg>
`;
const editIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-edit" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 7h-3a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-3" />
  <path d="M9 15h3l8.5 -8.5a1.5 1.5 0 0 0 -3 -3l-8.5 8.5v3" />
  <line x1="16" y1="5" x2="19" y2="8" />
</svg>
`;
const growIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrows-diagonal-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <polyline points="16 20 20 20 20 16" />
  <line x1="14" y1="14" x2="20" y2="20" />
  <polyline points="8 4 4 4 4 8" />
  <line x1="4" y1="4" x2="10" y2="10" />
</svg>
`;

const copyIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <rect x="8" y="8" width="12" height="12" rx="2"></rect>
   <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path>
</svg>
`;

const pasteIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2"></path>
   <rect x="9" y="3" width="6" height="4" rx="2"></rect>
   <path d="M9 14l2 2l4 -4"></path>
</svg>
`;

const targetIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-focus" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <circle cx="12" cy="12" r=".5" fill="currentColor"></circle>
   <circle cx="12" cy="12" r="9"></circle>
</svg>
`;

const settingsIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-settings" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z" />
  <circle cx="12" cy="12" r="3" />
</svg>
`;

const rotateIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rotate-clockwise" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M4.05 11a8 8 0 1 1 .5 4m-.5 5v-5h5"></path>
</svg>
`;

const templateString = `
<style>
 :host {
     --halo-button-height: 25px;
     --halo-button-width: 25px;
     --halo-rim-margin: 10px;
     --halo-button-width-padded: calc(var(--halo-button-width) + var(--halo-rim-margin));
     --halo-button-height-padded: calc(var(--halo-button-height) + var(--halo-rim-margin));
     position: absolute;
     box-sizing: border-box;
     top: calc(-1 * var(--halo-button-height-padded));
     left: calc(-1 * var(--halo-button-width-padded));
     width: calc(100% + (2 * var(--halo-button-width-padded)));
     height: calc(100% + (2 * var(--halo-button-height-padded)));
     color: initial;
     z-index: 10;
 }


 .halo-row,
 .halo-column {
     display: flex;
     position: absolute;
 }

 .halo-column {
     flex-direction: column;
 }

 #halo-top-row,
 #halo-bottom-row {
     width: calc(100% - var(--halo-button-width-padded));
     height: var(--halo-button-height-padded);
 }

 #halo-top-row {
     left: 0;
     top: 0;
 }

 #halo-bottom-row {
     right: 0;
     bottom: 0;
     flex-direction: row-reverse;
     align-items: flex-end;
 }

 #halo-right-column,
 #halo-left-column {
     height: calc(100% - var(--halo-button-height-padded));
     width: var(--halo-button-width-padded);
 }

 #halo-right-column {
     right: 0;
     top: 0;
     align-items: flex-end;
 }

 #halo-left-column {
     left: 0;
     top: var(--halo-button-height-padded);
 }

 .halo-button,
 ::slotted(*) {
     display: block;
     border: 1px solid rgba(100, 100, 100, 0.8);
     width: var(--halo-button-width);
     height: var(--halo-button-height);
     background-color: rgb(220, 220, 220);
 }

 .halo-button:hover
 ::slotted(*).halo-button:hover {
     cursor: pointer;
 }

 .halo-button:active
 ::slotted(*).halo-button:active {
     border: 1px solid black;
 }

 .halo-button.hidden
 ::slotted(*).halo-button.hidden {
     display: none;
 }

</style>

<div id="halo-top-row" class="halo-row">
    <div id="halo-delete" class="halo-button" title="Delete this part">
        ${deleteIcon}
    </div>
    <slot name="top-row"></slot>
</div>

<div id="halo-bottom-row" class="halo-row">
    <div id="halo-resize" class="halo-button" title="Resize this part">
        ${growIcon}
    </div>
    <div id="halo-script-edit" class="halo-button" title="Edit this part's script">
        ${editIcon}
    </div>
    <div id="halo-edit" class="halo-button" title="Edit this part">
        ${settingsIcon}
    </div>
    <slot name="bottom-row"></slot>
</div>

<div id="halo-left-column" class="halo-column">
    <div id="halo-copy" class="halo-button" title="Copy this Part">
        ${copyIcon}
    </div>
    <div id="halo-paste" class="halo-button" title="Paste the contents of clipboard into this Part">
        ${pasteIcon}
    </div>
    <div id="halo-target" class="halo-button" title="Select this Part's target">
        ${targetIcon}
    </div>
    <slot name="left-column"></slot>
</div>

<div id="halo-right-column" class="halo-column">
    <div id="halo-rotate" class="halo-button" title="Rotate this part">
        ${rotateIcon}
    </div>
    <slot name="right-column"></slot>
</div>

`;

class Halo extends HTMLElement {
    constructor(){
        super();

        // Configure the Shadow DOM and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind component methods


        // Bind event listeners
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onResizeMouseDown = this.onResizeMouseDown.bind(this);
        this.onResizeMouseUp = this.onResizeMouseUp.bind(this);
        this.onResizeMouseMove = this.onResizeMouseMove.bind(this);
        this.onRotateMouseDown = this.onRotateMouseDown.bind(this);
        this.onRotateMouseUp = this.onRotateMouseUp.bind(this);
        this.onRotateMouseMove = this.onRotateMouseMove.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.targetElement = this.getRootNode().host;
            this.targetElement.classList.add('editing');
            this.targetElement.hasOpenHalo = true;

            // Add event listeners
            this.addEventListener('mousedown', this.onMouseDown);

            // Resize button
            this.resizer = this.shadowRoot.getElementById('halo-resize');
            this.resizer.addEventListener('mousedown', this.onResizeMouseDown);
            if(!this.targetElement.wantsHaloResize){
                this.resizer.style.visibility = 'hidden';
            }

            // Rotate button
            this.rotater = this.shadowRoot.getElementById('halo-rotate');
            this.rotater.addEventListener('mousedown', this.onRotateMouseDown);
            if(!this.targetElement.wantsHaloRotate){
                this.rotater.style.visibility = 'hidden';
            }
            // Delete button
            this.deleter = this.shadowRoot.getElementById('halo-delete');
            this.deleter.addEventListener('click', this.targetElement.onHaloDelete);
            if(!this.targetElement.wantsHaloDelete){
                this.deleter.style.visibility = 'hidden';
            }

            // Edit button
            this.scriptEditor = this.shadowRoot.getElementById('halo-script-edit');
            this.scriptEditor.addEventListener('click', this.targetElement.onHaloOpenScriptEditor);
            if(!this.targetElement.wantsHaloScriptEdit){
                this.scriptEditor.style.visibility = 'hidden';
            }

            // Comprehensive editor button
            this.editor = this.shadowRoot.getElementById('halo-edit');
            this.editor.addEventListener('click', this.targetElement.onHaloOpenEditor);
            if(!this.targetElement.wantsHaloEdit){
                this.editor.style.visibility = 'hidden';
            }

            // Copy button
            this.copier = this.shadowRoot.getElementById('halo-copy');
            this.copier.addEventListener('click', this.targetElement.onHaloCopy);


            // Paste button
            this.paster = this.shadowRoot.getElementById('halo-paste');
            this.paster.addEventListener('click', this.targetElement.onHaloPaste);

            // Target button
            this.targeter = this.shadowRoot.getElementById('halo-target');
            this.targeter.addEventListener('click', this.targetElement.onHaloTarget);
            this.targeter.addEventListener('mouseenter', this.targetElement.onHaloTargetButtonMouseEnter);
            this.targeter.addEventListener('mouseleave', this.targetElement.onHaloTargetButtonMouseLeave);
        }
    }

    disconnectedCallback(){
        this.targetElement.classList.remove('editing');
        this.targetElement.hasOpenHalo = false;

        // Remove event listeners
        this.removeEventListener('mousedown', this.onMouseDown);
        this.resizer.removeEventListener('mousedown', this.onResizeMouseDown);
    }


    /* Event Handling */
    onMouseDown(event){
        if(event.button == 0 && this.targetElement.wantsHaloMove){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        let currentTop = parseInt(this.targetElement.style.top);
        let currentLeft = parseInt(this.targetElement.style.left);
        let newTop = event.movementY + currentTop;
        let newLeft = event.movementX + currentLeft;

        let model = this.targetElement.model;
        model.partProperties.setPropertyNamed(model, "top", newTop);
        model.partProperties.setPropertyNamed(model, "left", newLeft);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    onResizeMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onResizeMouseMove);
        document.addEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseUp(event){
        document.removeEventListener('mousemove', this.onResizeMouseMove);
        document.removeEventListener('mouseup', this.onResizeMouseUp);
    }

    onResizeMouseMove(event){
        this.targetElement.onHaloResize(
            event.movementX,
            event.movementY
        );
    }

    onRotateMouseDown(event){
        event.stopPropagation();
        document.addEventListener('mousemove', this.onRotateMouseMove);
        document.addEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseUp(event){
        document.removeEventListener('mousemove', this.onRotateMouseMove);
        document.removeEventListener('mouseup', this.onRotateMouseUp);
    }

    onRotateMouseMove(event){
        this.targetElement.onHaloRotate(
            event.movementX,
            event.movementY
        );
    }
};




/***/ }),

/***/ "./js/objects/views/ImageView.js":
/*!***************************************!*\
  !*** ./js/objects/views/ImageView.js ***!
  \***************************************/
/*! exports provided: ImageView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageView", function() { return ImageView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const pictureIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-photo" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <line x1="15" y1="8" x2="15.01" y2="8"></line>
   <rect x="4" y="4" width="16" height="16" rx="3"></rect>
   <path d="M4 15l4 -4a3 5 0 0 1 3 0l5 5"></path>
   <path d="M14 14l1 -1a3 5 0 0 1 3 0l2 2"></path>
</svg>
`;

const templateString = `
<img id="wrapped-image" class="hidden" />
<svg class="hidden" id="wrapped-svg" xmlns="http://www.w3.org/2000/svg">
</svg>
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    user-select: none;
}

.hidden {
    display: none;
}
img {
    width: 100%;
    height: auto;
    display: block;
}

.currently-wrapped {
    width: 100%;
    height: 100%;
}
</style>
`;

class ImageView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.updateImageData = this.updateImageData.bind(this);
        this.updateSvgImage = this.updateSvgImage.bind(this);
        this.updateBinaryImage = this.updateBinaryImage.bind(this);
        this.setDefaultImage = this.setDefaultImage.bind(this);
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateImageLink = this.updateImageLink.bind(this);
        this.updateSizingForViewport = this.updateSizingForViewport.bind(this);
    }

    afterModelSet(){
        // prop changes
        this.onPropChange("imageData", (imageData) => {
            if(!imageData){
                this.setDefaultImage();
            }
            this.updateImageData(imageData);
        });

        // Make sure we have imageData. If not, try
        // to load from a src.
        let currentImageData = this.model.partProperties.getPropertyNamed(
            this.model,
            "imageData"
        );
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            "src"
        );
        if(!currentImageData){
            if(currentSrc){
                let msg = {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ currentSrc ]
                };
                this.model.sendMessage(msg, this.model);
            } else {
                this.setDefaultImage();
            }
        } else {
            this.updateImageData(currentImageData);
        }
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    setDefaultImage(){
        this.model.partProperties.setPropertyNamed(this.model, "imageData", pictureIcon);
        this.model.partProperties.setPropertyNamed(this.model, "mimeType", "image/svg");
        this.model.partProperties.setPropertyNamed(this.model, "src", "");
        this.updateImageData(pictureIcon);
    }

    updateImageData(imageData){
        if(this.model.isSvg){
            this.updateSvgImage(imageData);
        } else {
            this.updateBinaryImage(imageData);
        }
    }

    updateBinaryImage(imageData){
        // In this case, the imageData is
        // a base64 encoded data url describing
        // the bits of the image.
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let svgEl = this._shadowRoot.getElementById('wrapped-svg');
        svgEl.classList.add('hidden');
        svgEl.classList.remove('currently-wrapped');
        imgEl.classList.add('currently-wrapped');
        imgEl.src = imageData;
        imgEl.onload = () => {
            //this.updateSizingForViewport();
        };
        this.preserveAspectOnResize = true;
        imgEl.classList.remove('hidden');
    }

    updateSvgImage(imageData){
        let imgEl = this._shadowRoot.getElementById('wrapped-image');
        let currentSvgEl = this._shadowRoot.getElementById('wrapped-svg');
        let parser = new DOMParser();
        let xmlDocument = parser.parseFromString(imageData, 'application/xml');
        let newSvgEl = xmlDocument.documentElement;

        // Ensure that the SVG has some width and height attributes
        // set so we have initial dimensions to display. If not present,
        // pull from viewbox.
        if(!newSvgEl.hasAttribute('width') || !newSvgEl.hasAttribute('height')){
            let viewBox = newSvgEl.getAttribute('viewBox');
            if(viewBox){
                viewBox = viewBox.split(" ");
                let viewBoxWidth = parseInt(viewBox[2]);
                let viewBoxHeight = parseInt(viewBox[3]);
                newSvgEl.setAttribute('height', viewBoxHeight);
                newSvgEl.setAttribute('width', viewBoxWidth);
            }
        } 
        newSvgEl.id = 'wrapped-svg';
        newSvgEl.classList.add('currently-wrapped');
        imgEl.classList.add('hidden');
        imgEl.classList.remove('currently-wrapped');
        currentSvgEl.remove();
        this._shadowRoot.appendChild(newSvgEl);
        this.updateSizingForViewport();
        this.preserveAspectOnResize = false;
    }

    updateImageLink(event){
        // Tells the model to update its
        // src link for the image
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for image:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadImageFrom',
                    args: [ result ]
                },
                this.model
            );
        }
    }

    updateSizingForViewport(){
        // Ensure that this component does not display larger
        // than the current remaining subrectangle of its origin
        // and the corner of the viewport
        let padding = 40;
        // First, we need to find the absolute top corner
        // locations for the element
        let el = this._shadowRoot.querySelector('.currently-wrapped');
        let top = 0;
        let left = 0;
        while(el){
            top += el.offsetTop;
            left += el.offsetLeft;
            el = el.offsetParent;
        }

        let rect = this.getBoundingClientRect();
        let heightLimit = document.documentElement.clientHeight - padding;
        if((rect.height + top) > heightLimit){
            let ratio = (heightLimit - top) / rect.height;
            // this.style.height = `${rect.height * ratio}px`;
            // this.style.width = `${rect.width * ratio}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                (rect.width * ratio)
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                (rect.height * ratio)
            );
        }
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    onHaloResize(movementX, movementY){
        // Override default behavior.
        // We resize the wrapped svg or img instead
        // and have the outer component simply react to
        // the change.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let wrappedImage = this._shadowRoot.querySelector('.currently-wrapped');
        let rect = wrappedImage.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let maxWidth = rect.width + movementX;
            let maxHeight = rect.height + movementY;
            let ratio = Math.min(maxWidth / rect.width, maxHeight / rect.height);
            newHeight = rect.height * ratio;
            newWidth = rect.width * ratio;
        } else {
            newWidth = rect.width + movementX;
            newHeight = rect.height + movementY;
        }

        if(newWidth && newHeight){
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight
            );
        }
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-image-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for image file');
        this.haloButton.addEventListener('click', this.updateImageLink);
    }

    addContextMenuItems(contextMenu){
        contextMenu.addSpacer();
        contextMenu.addListItem(
            'Edit Image URL',
            this.updateImageLink
        );
    }
};




/***/ }),

/***/ "./js/objects/views/PartView.js":
/*!**************************************!*\
  !*** ./js/objects/views/PartView.js ***!
  \**************************************/
/*! exports provided: PartView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartView", function() { return PartView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PartView; });
/* harmony import */ var _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contextmenu/ContextMenu.js */ "./js/objects/views/contextmenu/ContextMenu.js");
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/**
 * PartView
 * ----------------------------------------
 * I am an *abstract* webcompoent CustomElement
 * that serves as the generic view for any Part
 * models.
 * I should not be instantiated directly, nor should
 * I be added to any web page's registry of CustomElements.
 * I am indended to be extended (subclassed) by the actual
 * views for each Part kind, and therefore I contain all
 * of the common behavior, including lifecycle methods,
 * for these.
 */



window.customElements.define('st-context-menu', _contextmenu_ContextMenu_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

class PartView extends HTMLElement {
    constructor(){
        super();
        this.model = null;
        this.isPartView = true;
        this.isLensed = false;
        this.name = this.constructor.name;
        this.propChangeHandlers = {};
        this.setupBasePropHandlers();
        this.viewChangeHandlers = {};
        this.setupBaseViewChangeHandlers();

        // Halo settings. All are on by default
        this.wantsHaloResize = true;
        this.wantsHaloRotate = true;
        this.wantsHaloScriptEdit = true;
        this.wantsHaloEdit = true;
        this.wantsHaloDelete = true;
        this.wantsHalo = true;
        // Note: see getter for wantsHaloMove

        // Context menu settings
        this.wantsContextMenu = true;

        // Bind component methods
        this.setModel = this.setModel.bind(this);
        this.unsetModel = this.unsetModel.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.setupBasePropHandlers = this.setupBasePropHandlers.bind(this);
        this.setupBaseViewChangeHandlers = this.setupBaseViewChangeHandlers.bind(this);
        this.initLayout = this.initLayout.bind(this);

        // Bind initial property method
        this.styleCSS = this.styleCSS.bind(this);
        this.styleTextCSS = this.styleTextCSS.bind(this);

        // Bind property change reaction methods
        this.primHandlePropChange = this.primHandlePropChange.bind(this);
        this.onPropChange = this.onPropChange.bind(this);
        this.primHandleViewChange = this.primHandleViewChange.bind(this);
        this.onViewChange = this.onViewChange.bind(this);
        this.scriptChanged = this.scriptChanged.bind(this);
        this.layoutChanged = this.layoutChanged.bind(this);
        this.listDirectionChanged = this.listDirectionChanged.bind(this);
        this.listWrappingChanged = this.listWrappingChanged.bind(this);
        this.vResizingChanged = this.vResizingChanged.bind(this);
        this.hResizingChanged = this.hResizingChanged.bind(this);
        this.pinningLeftChanged = this.pinningLeftChanged.bind(this);
        this.pinningTopChanged = this.pinningTopChanged.bind(this);
        this.pinningBottomChanged = this.pinningBottomChanged.bind(this);
        this.pinningRightChanged = this.pinningRightChanged.bind(this);
        this.listAlignmentChanged = this.listAlignmentChanged.bind(this);
        this.listDistributionChanged = this.listDistributionChanged.bind(this);

        // Bind view change reaction methods
        this.subpartOrderChanged = this.subpartOrderChanged.bind(this);
        this.newSubpartView = this.newSubpartView.bind(this);

        // Bind Halo related methods
        this.openHalo = this.openHalo.bind(this);
        this.closeHalo = this.closeHalo.bind(this);
        this.onHaloDelete = this.onHaloDelete.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onHaloOpenScriptEditor = this.onHaloOpenScriptEditor.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.onHaloRotate = this.onHaloRotate.bind(this);
        this.onHaloPaste = this.onHaloPaste.bind(this);
        this.onHaloCopy = this.onHaloCopy.bind(this);
        this.onHaloTarget = this.onHaloTarget.bind(this);
        this.endHaloTarget = this.endHaloTarget.bind(this);
        this.onHaloTargetButtonMouseEnter = this.onHaloTargetButtonMouseEnter.bind(this);
        this.onHaloTargetButtonMouseLeave = this.onHaloTargetButtonMouseLeave.bind(this);
        this.onHaloActivationClick = this.onHaloActivationClick.bind(this);
        this.onHaloOpenEditor = this.onHaloOpenEditor.bind(this);
        this.onAuxClick = this.onAuxClick.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onContextMenuClick = this.onContextMenuClick.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.handleTargetKey = this.handleTargetKey.bind(this);
        this.handleTargetMouseClick = this.handleTargetMouseClick.bind(this);
        this.handleTargetMouseOver = this.handleTargetMouseOver.bind(this);
        this.handleTargetMouseOut = this.handleTargetMouseLeave.bind(this);
        this.addContextMenuItems = this.addContextMenuItems.bind(this);
        this.getCurrentTargetViews = this.getCurrentTargetViews.bind(this);

        // Bind editor related methods
        this.openEditor = this.openEditor.bind(this);
        this.closeEditor = this.closeEditor.bind(this);

        // Context menu
        this.openContextMenuAt = this.openContextMenuAt.bind(this);
        this.closeContextMenu = this.closeContextMenu.bind(this);

        // misc
        this.highlight = this.highlight.bind(this);
        this.unhighlight = this.unhighlight.bind(this);

        // Bind lifecycle methods
        this.afterModelSet = this.afterModelSet.bind(this);
        this.afterModelUnset = this.afterModelUnset.bind(this);
        this.afterConnected = this.afterConnected.bind(this);
        this.afterDisconnected = this.afterDisconnected.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Do some universal PartView configuration
            // when attached to a parent element, like
            // registering event listeners etc

            // Register middle mouse button click
            // to toggle the halo
            this.addEventListener('auxclick', this.onAuxClick);

            // Register default event handlers manually]
            this.addEventListener('click', this.onClick);
            this.addEventListener('contextmenu', this.onContextMenuClick);

            // Call the lifecycle method when done
            // with the above
            this.afterConnected();
        }
    }

    disconnectedCallback(){
        this.removeEventListener('auxclick', this.onAuxClick);
        this.removeEventListener('click', this.onClick);
        this.removeEventListener('contextmenu', this.onContextMenuClick);
        this.afterDisconnected();
    }

    setModel(aModel){
        this.unsetModel();
        this.model = aModel;
        aModel.addPropertySubscriber(this);
        aModel.addViewSubscriber(this);
        if(this.isLensed){
            this.removeAttribute('part-id');
            this.setAttribute('lens-part-id', aModel.id);
        } else {
            this.removeAttribute('lens-part-id');
            this.setAttribute('part-id', aModel.id);
        }

        // load all the initial styling
        this.styleCSS();
        this.styleTextCSS();
        this.initLayout();
        this.afterModelSet();
    }

    unsetModel(){
        if(this.model){
            let removedModel = this.model;
            this.model.removePropertySubscriber(this);
            this.model = null;
            this.setAttribute('part-id', "");
            this.afterModelUnset(removedModel);
        }
    }

    setupBasePropHandlers(){
        // This is where we should setup any
        // prop change handlers that are universal
        // to all PartViews. We would do this via
        // the #onPropChange method, which registers
        // a handler function.
        // Do not override this method
        // TODO: Implement the universals
        this.onPropChange('script', this.scriptChanged);
        this.onPropChange('number', this.numberChanged);
        this.onPropChange('cssStyle', this.styleCSS);
        this.onPropChange('cssTextStyle', this.styleTextCSS);
        this.onPropChange('layout', this.layoutChanged);
        this.onPropChange('list-direction', this.listDirectionChanged);
        this.onPropChange('list-wrapping', this.listWrappingChanged);
        this.onPropChange('list-alignment', this.listAlignmentChanged);
        this.onPropChange('list-distribution', this.listDistributionChanged);
        this.onPropChange('horizontal-resizing', this.hResizingChanged);
        this.onPropChange('vertical-resizing', this.vResizingChanged);
        this.onPropChange('pinning-top', this.pinningTopChanged);
        this.onPropChange('pinning-right', this.pinningRightChanged);
        this.onPropChange('pinning-left', this.pinningLeftChanged);
        this.onPropChange('pinning-bottom', this.pinningBottomChanged);
        this.onPropChange('wants-move', (value) => {
            if(value){
                this.addEventListener('mousedown', this.onMouseDown);
            } else {
                this.removeEventListener('mousedown', this.onMouseDown);
            }
        });
    }

    setupBaseViewChangeHandlers(){
        // This is where we should setup any
        // view change handlers that are universal
        // to all PartViews. We would do this via
        // the #onViewChange method, which registers
        // a handler function.
        // Do not override this method
        this.onViewChange('subpart-order', this.subpartOrderChanged);
        this.onViewChange('subpart-new', this.newSubpartView);
    }

    initLayout(){
        // Not all Part/PartView pairs have the layout
        // properties. Ensure they exist first
        let hasLayout = this.model.partProperties.findPropertyNamed('layout');
        let hasBoxResizing = this.model.partProperties.findPropertyNamed('vertical-resizing');
        let hasPinning = this.model.partProperties.findPropertyNamed('pinning');
        if(hasLayout){
            let initialLayout = this.model.partProperties.getPropertyNamed(
                this.model,
                'layout'
            );
            let initialListDirection = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-direction'
            );
            let initialListWrapping = this.model.partProperties.getPropertyNamed(
                this.model,
                'list-wrapping'
            );
            this.layoutChanged(initialLayout);
            this.listDirectionChanged(initialListDirection);
            this.listWrappingChanged(initialListWrapping);
            this.listAlignmentChanged();
            this.listDistributionChanged();
        }

        if(hasBoxResizing){
            let initialVResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'vertical-resizing'
            );
            let initialHResizing = this.model.partProperties.getPropertyNamed(
                this.model,
                'horizontal-resizing'
            );
            this.vResizingChanged(initialVResizing);
            this.hResizingChanged(initialHResizing);
        }

        if(hasPinning){
            this.pinningTopChanged();
            this.pinningBottomChanged();
            this.pinningLeftChanged();
            this.pinningRightChanged();
        }
    }

    styleCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    styleTextCSS(){
        let cssStyle = this.model.partProperties.getPropertyNamed(this, "cssTextStyle");
        Object.keys(cssStyle).forEach((key) => {
            let value = cssStyle[key];
            this.style[key] = value;
        });
    }

    sendMessage(aMessage, target){
        if(!this.isLensed){
            // Lensed views should not send messages
            window.System.sendMessage(aMessage, this, target);
        }
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            this.primHandlePropChange(
                aMessage.propertyName,
                aMessage.value,
                aMessage.partId
            );
            break;
        case 'viewChanged':
            this.primHandleViewChange(
                aMessage.changeName,
                ...aMessage.args
            );
            break;
        }
    }

    primHandlePropChange(name, value, partId){
        // We notify the model that the property change so that
        // on propertyChanged command handlers could be invoked
        // but we make sure that this stops at the said model and
        // does not go up the delegation chain
        let commandMessage = {
            type: 'command',
            commandName: 'propertyChanged',
            args: [name, value],
            shouldNotDelegate:true, // do not send this up the delegation chain
            shouldIgnore: true
        };
        this.sendMessage(commandMessage, this.model);
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.propChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(value, partId);
    }


    onPropChange(name, func){
        this.propChangeHandlers[name] = func;
    }

    primHandleViewChange(name, ...args){
        // Find the handler for the given named
        // property. If it does not exist, do nothing
        let handler = this.viewChangeHandlers[name];
        if(!handler){
            return null;
        }
        handler = handler.bind(this);
        return handler(...args);
    }

    onViewChange(name, func){
        this.viewChangeHandlers[name] = func;
    }

    scriptChanged(value, partId){
        this.model.sendMessage({
            type: 'compile',
            codeString: value,
            targetId: partId
        }, window.System);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        // there is no need to do anything for the wrapped views
        // CardRow and StackRow will handle the updates
        if(this.name == "WrappedView"){
            return;
        }
        let subpartNode = this.childNodes[currentIndex];
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
    }

    newSubpartView(newView){
        this.appendChild(newView);
    }

    layoutChanged(value, partId){
        if(value == 'list'){
            this.classList.add('list-layout');
        } else {
            this.classList.remove('list-layout');
        }
    }

    listDirectionChanged(value, partId){
        // Row is the default configuration
        // for a list layout, so only one extra
        // CSS class needs to be toggled
        if(value == 'row'){
            this.classList.remove('list-column');
        } else if(value == 'column'){
            this.classList.add('list-column');
        }
    }

    listWrappingChanged(value, partId){
        if(value == true){
            this.classList.add('wrap-list');
        } else {
            this.classList.remove('wrap-list');
        }
    }

    hResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('h-space-fill');
            this.classList.remove(
                'h-rigid',
                'h-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('h-shrink-wrap');
            this.classList.remove(
                'h-rigid',
                'h-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('h-rigid');
            this.classList.remove(
                'h-space-fill',
                'h-shrink-wrap'
            );
        }
    }

    vResizingChanged(value){
        if(value == 'space-fill'){
            this.classList.add('v-space-fill');
            this.classList.remove(
                'v-rigid',
                'v-shrink-wrap'
            );
        } else if(value == 'shrink-wrap'){
            this.classList.add('v-shrink-wrap');
            this.classList.remove(
                'v-rigid',
                'v-space-fill'
            );
        } else if(value == 'rigid'){
            this.classList.add('v-rigid');
            this.classList.remove(
                'v-space-fill',
                'v-shrink-wrap'
            );
        }
    }

    pinningTopChanged(){
        let top = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-top'
        );
        if(top){
            this.classList.add('pin-top');
        } else {
            this.classList.remove('pin-top');
        }
    }

    pinningLeftChanged(){
        let left = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-left'
        );
        if(left){
            this.classList.add('pin-left');
        } else {
            this.classList.remove('pin-left');
        }
    }

    pinningRightChanged(){
        let right = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-right'
        );
        if(right){
            this.classList.add('pin-right');
        } else {
            this.classList.remove('pin-right');
        }
    }

    pinningBottomChanged(){
        let bottom = this.model.partProperties.getPropertyNamed(
            this.model,
            'pinning-bottom'
        );
        if(bottom){
            this.classList.add('pin-bottom');
        } else {
            this.classList.remove('pin-bottom');
        }
    }

    listAlignmentChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-alignment'
        );
        let valid = [
            'top',
            'bottom',
            'left',
            'right',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-align-${side}`);
            });
            this.classList.add(`list-align-${value}`);
        }
    }

    listDistributionChanged(){
        let value = this.model.partProperties.getPropertyNamed(
            this.model,
            'list-distribution'
        );
        let valid = [
            'start',
            'end',
            'space-between',
            'space-around',
            'center'
        ];
        if(valid.includes(value)){
            valid.forEach(side => {
                this.classList.remove(`list-distribution-${side}`);
            });
            this.classList.add(`list-distribution-${value}`);
        }
    }

    /* Lifecycle Method Defaults */
    afterModelSet(){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterModelUnset(removedModel){
        // Does nothing.
        // Should be implemented in subclasses
    }

    afterConnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    afterDisconnected(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    /* Halo Related Methods */

    openHalo(){
        // Check to see if there's a halo in
        // the component's shadow root already
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            let newHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(newHalo);
        }
    }

    closeHalo(){
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(foundHalo){
            foundHalo.remove();
        }
    }

    toggleAntsBorder(){
        if(this.classList.contains('marching-ants')){
            this.classList.remove('marching-ants');
        } else {
            this.classList.add('marching-ants');
        }
    }

    onHaloDelete(){
        // What to do when the user clicks the
        // delete button on a halo for this partview.
        // The default implementation is to send a message
        // to the System to delete the corresponding
        // model and *all* views referencing that
        // model.
        this.sendMessage({
            type: 'command',
            commandName: 'deleteModel',
            args: [this.model.id]
        }, window.System);
    }

    onHaloOpenScriptEditor(){
        // Send the message to open a script editor
        // with this view's model as the target
        this.model.sendMessage({
            type: 'command',
            commandName: 'openScriptEditor',
            args: [this.model.id]
        }, this.model);
    }

    onHaloOpenEditor(){
        window.System.editor.render(this.model);
        window.System.editor.open();
    }

    onHaloResize(movementX, movementY){
        // Default implementation on what to do during
        // halo button resize opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // width and height style properties directly.
        // If the part is rotated this will throw off the bounding rectangle
        // browser calcualtion. So the hack here is to rotate the part to 0
        // (if necessary) do the calculations and then rotate it back
        let angle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", 0);
        }
        let rect = this.getBoundingClientRect();
        let newWidth, newHeight;
        if(this.preserveAspectOnResize){
            let ratio = rect.width / rect.height;
            let hyp = Math.sqrt((movementX**2) + (movementY**2));
            if(movementX < 0 || movementY < 0){
                hyp = hyp * -1;
            }
            newHeight = rect.height + hyp;
            newWidth = rect.width + hyp;
        } else {
            newWidth = movementX + rect.width;
            newHeight = movementY + rect.height;
        }
        this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
        this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
        // reset the rotate angle to the original (if necessary)
        if(angle){
            this.model.partProperties.setPropertyNamed(this.model, "rotate", angle);
        }
    }

    onHaloRotate(movementX, movementY){
        // Default implementation on what to do during
        // halo button rotate opertations. Subclasses
        // can override for custom behavior.
        // Default is to update the View component's
        // rotate style property directly.
        if(movementX || movementY){
            let currentAngle = this.model.partProperties.getPropertyNamed(this.model, "rotate");
            let rect = this.getBoundingClientRect();
            if(!currentAngle){
                currentAngle = 0;
            }
            let theta1 = Math.atan((rect.height/2)/(rect.width/2));
            let theta2 = Math.atan((rect.height/2 + movementY)/(rect.width/2 + movementX));
            let changeAngle = Math.abs((theta2 - theta1)*180/Math.PI);
            let newAngle = (currentAngle + changeAngle) % 360;
            if(newAngle < 0){
                newAngle = 360 + newAngle;
            }
            if(newAngle){
                this.model.partProperties.setPropertyNamed(this.model, "rotate", newAngle);
            }
        }
    }

    onHaloCopy(){
        window.System.clipboard.copyPart(this.model);
    }

    onHaloPaste(){
        window.System.clipboard.pasteContentsInto(this.model);
        this.closeHalo();
    }

    onHaloTarget(event){
        // Add targeting receive listeners to all PartViews
        // on the current card.
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.addEventListener('keydown', this.handleTargetKey);
            partView.addEventListener('mouseover', this.handleTargetMouseOver);
            partView.addEventListener('mouseout', this.handleTargetMouseOut);
            partView.addEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.add('targeting-mode');
        event.stopPropagation();
    }

    onHaloTargetButtonMouseEnter(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); //green
        });
    }

    onHaloTargetButtonMouseLeave(){
        // light up the current target
        this.getCurrentTargetViews().forEach((view) => {
            view.unhighlight();
        });
    }

    highlight(color){
        if(this.name != "StackView" && this.name != "WorldView"){
            this._tempBackgroundColor = this.model.partProperties.getPropertyNamed(this.model, "background-color");
            this.model.partProperties.setPropertyNamed(this.model, "background-color", color);
            this._tempBackgroundTransparency = this.model.partProperties.getPropertyNamed(this.model, "background-transparency");
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", 1);
        }

    }

    unhighlight(){
        if(this.name != "StackView" && this.name != "WorldView"){
            this.model.partProperties.setPropertyNamed(this.model, "background-color", this._tempBackgroundColor);
            this.model.partProperties.setPropertyNamed(this.model, "background-transparency", this._tempBackgroundTransparency);
        }
    }

    endHaloTarget(){
        // Remove all targeting related event listeners
        // that were added during the onHaloTarget
        // handler
        let currentStackView = document.querySelector(`[part-id="${window.System.world.currentStack.id}"]`);
        let currentCardView = document.querySelector(`[part-id="${window.System.world.currentStack.currentCard.id}"]`);
        let targetCardParts = Array.from(currentCardView.querySelectorAll('[part-id]'));
        let targetStackParts = Array.from(currentStackView.querySelectorAll('[part-id]:not(st-card):not(st-stack)'));
        let allTargets = targetCardParts.concat(targetStackParts);
        allTargets.forEach(partView => {
            document.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('keydown', this.handleTargetKey);
            partView.removeEventListener('mouseover', this.handleTargetMouseOver);
            partView.removeEventListener('mouseout', this.handleTargetMouseOut);
            partView.removeEventListener('click', this.handleTargetMouseClick);
        });
        document.body.classList.remove('targeting-mode');
    }

    handleTargetKey(event){
        if(event.key == 'Escape'){
            this.endHaloTarget();
        }
    }

    handleTargetMouseOver(event){
        if(!event.target.classList.contains('targeting')){
            event.target.classList.add('targeting');
            event.target.highlight("rgb(234, 55, 55)");
            event.target.removeEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseLeave(event){
        if(event.target.classList.contains('targeting')){
            event.target.classList.remove('targeting');
            event.target.unhighlight();
            event.target.addEventListener('click', event.target.onClick);
        }
    }

    handleTargetMouseClick(event){
        event.preventDefault();
        if(event.button == 0 && event.shiftKey){
            this.onHaloActivationClick(event);
            return;
        }
        event.target.classList.remove('targeting');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'target',
            event.target.model.id
        );
        this.endHaloTarget();
        event.stopImmediatePropagation();
        event.target.unhighlight();
        event.target.addEventListener('click', event.target.onClick);
    }

    getCurrentTargetViews(){
        // clean up the current target
        let currentTarget = this.model.partProperties.getPropertyNamed(this.model, "target");
        if(currentTarget){
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this.model, window.System)
            );
            let m = window.System.grammar.match(currentTarget, "ObjectSpecifier");
            let targetId = semantics(m).interpret();
            return window.System.findViewsById(targetId);
        }
        return [];
    }

    onContextMenuClick(event){
        if(this.wantsContextMenu){
            event.preventDefault();
            event.stopPropagation();
            if(this.contextMenuIsOpen){
                this.closeContextMenu();
            } else {
                this.openContextMenuAt(
                    event.clientX,
                    event.clientY
                );
            }
        } else {
            event.stopPropagation();
        }
    }

    onAuxClick(event){
        // Should only open halo when middle
        // mouse button is clicked
        if(event.button == 1){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onClick(event){
        if(this.contextMenuIsOpen){
            this.closeContextMenu();
        }
        if(event.button == 0 && event.shiftKey){
            event.preventDefault();
            this.onHaloActivationClick(event);
        }
    }

    onHaloActivationClick(event){
        if(this.wantsHalo){
            if(this.hasOpenHalo){
                this.closeHalo();
            } else {
                event.stopPropagation();
                // Find any other open Halos
                // and automatically close them
                let exSelector = `.editing:not([part-id="${this.model.id}"])`;
                Array.from(document.querySelectorAll(exSelector)).forEach(openHaloEl => {
                    openHaloEl.closeHalo();
                });

                // Finally, open on this view
                this.openHalo();
            }
        }
    }

    onMouseDown(event){
        if(event.button == 0 && !event.shiftKey){
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }

    onMouseMove(event){
        this.sendMessage({
            type: 'command',
            commandName: 'move',
            args: [event.movementX, event.movementY]
        }, this.model);
    }

    onMouseUp(event){
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }

    openContextMenuAt(x, y){
        let menuEl = document.createElement('st-context-menu');
        let worldView = document.querySelector('[part-id="world"]');
        menuEl.render(this.model);
        menuEl.style.left = `${x}px`;
        menuEl.style.top = `${y}px`;
        worldView.append(menuEl);
    }

    closeContextMenu(){
        let found = document.querySelector('st-context-menu');
        if(found){
            found.remove();
        }
    }

    addContextMenuItems(contextMenu){
        // The default implementation is to
        // do nothins.
        // Subclasses should override and use the
        // passed-in contextMenu object to construct
        // list items that are specific to their needs
        return;
    }

    get wantsHaloMove(){
        if(!this.parentElement || !this.isConnected){
            return false;
        }
        let parentModel = this.parentElement.model;
        if(!parentModel){
            return true;
        }

        let hasLayout = parentModel.partProperties.findPropertyNamed(
            parentModel,
            'layout'
        );

        if(!hasLayout){
            return true;
        }

        let parentLayout = parentModel.partProperties.getPropertyNamed(
            parentModel,
            'layout'
        );
        if(parentLayout === 'strict' | !parentLayout || parentLayout == ""){
            return true;
        }

        return false;
    }

    get contextMenuIsOpen(){
        let found = document.querySelector('st-context-menu');
        if(found){
            return true;
        }
        return false;
    }

    /* Editor related methods */
    openEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }

    closeEditor(){
        // Does nothing by default.
        // Should be implemented in subclass
    }
};




/***/ }),

/***/ "./js/objects/views/ResourceView.js":
/*!******************************************!*\
  !*** ./js/objects/views/ResourceView.js ***!
  \******************************************/
/*! exports provided: ResourceView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceView", function() { return ResourceView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResourceView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");


const linkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>
`;

const templateString = `
<style>
:host {
    box-sizing: border-box;
    display: block;
    position: absolute;
    padding: 1px;
    user-select: none;
}

.wrapper{
    width: 100%;
    height: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
}
</style>
<div class="wrapper">
    <span class="name"></span>
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-building-bridge-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <path d="M6 7h12a2 2 0 0 1 2 2v9a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-2a4 4 0 0 0 -8 0v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1v-9a2 2 0 0 1 2 -2"></path>
    </svg>
</div>
`;

class ResourceView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup template and shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(this.template.content.cloneNode(true));

        // Bind component methods
        this.onClick = this.onClick.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.updateResourceLink = this.updateResourceLink.bind(this);
        this.indicateReadyState = this.indicateReadyState.bind(this);
    }

    afterConnected(){
        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
    }

    afterModelSet(){
        // if the resourceName property is set then make sure it is loaded
        // TODO: i don't like this view asking the model to load!
        let resourceName = this.model.partProperties.getPropertyNamed(this.model, "resourceName");
        if(resourceName){
            this.model.loadResource([this], resourceName);
        }
        let src = this.model.partProperties.getPropertyNamed(this.model, "src");
        if(src){
            this.model.setSourceTo([this], src);
        }
        let nameSpan = this._shadowRoot.querySelector(".name");
        nameSpan.innerText = this.model.partProperties.getPropertyNamed(this.model, "name");
        let state = this.model.partProperties.getPropertyNamed(
            this.model,
            "readyState",
        );
        this.indicateReadyState(state);
        // prop changes
        this.onPropChange("name", (value) => {
            nameSpan.innerText = value;
        });
        this.onPropChange("readyState", this.indicateReadyState);
        this.onPropChange("src", (url) => {
        });
    }

    onClick(event){
        if(event.button == 0){
            if(event.shiftKey){
                // prevent triggering the on click message
                event.preventDefault();
                if(this.hasOpenHalo){
                    this.closeHalo();
                } else {
                    this.openHalo();
                }
            } else if(!this.hasOpenHalo){
                // Send the click command message to self
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'click',
                    args: [],
                    shouldIgnore: true // Should ignore if System DNU
                }, this.model);
            }
        }
    }

    indicateReadyState(value){
        let borderColor = "red";
        if(value == "fetching"){
            borderColor = "yellow";
        } else if(value == "ready"){
            borderColor = "green";
        };
        ["right", "left", "top", "bottom"].forEach((side) => {
            this.model.partProperties.setPropertyNamed(this.model, `border-${side}-color`, borderColor);
        });
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = 'halo-resource-link';
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = linkIcon;
        this.haloButton.style.marginTop = "6px";
        this.haloButton.setAttribute('slot', 'right-column');
        this.haloButton.setAttribute('title', 'Edit link for resource');
        this.haloButton.addEventListener('click', this.updateResourceLink);
    }

    updateResourceLink(event){
        // Tells the model to update its
        // src link for the resource
        let currentSrc = this.model.partProperties.getPropertyNamed(
            this.model,
            'src'
        );
        let result = window.prompt("Edit URL for resource:", currentSrc);
        if(result && result !== '' && result !== currentSrc){
            this.sendMessage(
                {
                    type: 'command',
                    commandName: 'loadResource',
                    args: [ result ]
                },
                this.model
            );
        }
    }


};




/***/ }),

/***/ "./js/objects/views/StackView.js":
/*!***************************************!*\
  !*** ./js/objects/views/StackView.js ***!
  \***************************************/
/*! exports provided: StackView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackView", function() { return StackView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _parts_Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Stack.js */ "./js/objects/parts/Stack.js");
/**
 * StackView
 * ----------------------------------------------
 * I am a Webcomponent (custom element) representing
 * the view of a Stack.
 * I take up the full width of the current viewport
 * when I am being displayed.
 * My child elements are BackgroundView and CardView
 */




// by default, stacks are hidden unless they're
// the current stack, or else they have the class
// window-stack (suggesting there's window part
// who wishes to display it)
const templateString = `<slot></slot>`;

class StackView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Setup templating and shadow dom
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Halo settings. Cards don't want
        //a halo to open
        this.wantsHalo = false;

        // Handle current-ness prop change
        this.onPropChange('current', this.handleCurrentChange);

        // Bind methods
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
    }

    afterModelSet(){
        // Do an initial setting of the
        // current card
        this.handleCurrentChange();
    }

    handleCurrentChange(){
        // The value of the current prop is the card ID
        // of the child Card that should be the
        // current one. We remove the current-card class from
        // the previous current card and add it to the new one.
        let currentCard = this.querySelector('.current-card');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let shouldNotify = false;
        let selector = `:scope > st-card[part-id="${nextCurrentId}"]`;
        if(this.isLensed){
            selector = `:scope > st-card[lens-part-id="${nextCurrentId}"]`;
            shouldNotify = true;
        }
        let nextCurrentCard = this.querySelector(selector);
        // if there is no currentCard and no next currentCard we set it to be the first
        // card child (this can happen when new ids are created on deserialization and so
        // the current property stored id is no longer relevant)
        if(!nextCurrentCard && !currentCard){
            nextCurrentCard = this.querySelector(`:scope > st-card`);
            // if there are no cards at all, this must be a brand new stack
            if(!nextCurrentCard){
                return;
            }
            this.model.partProperties.setPropertyNamed(
                this.model,
                "current",
                nextCurrentCard.id,
                shouldNotify
            );
        }
        if(nextCurrentCard){
            nextCurrentCard.classList.add('current-card');
        } else {
            return;
        }
        if(currentCard && currentCard != nextCurrentCard){
            currentCard.classList.remove('current-card');
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "CardView"){
            let lastCardNode;
            this.childNodes.forEach((child) => {
                if(child.name == "CardView"){
                    lastCardNode = child;
                }
            });
            if(lastCardNode){
                // insert after the last card
                lastCardNode.after(newView);
            } else {
                // since there are no cards
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/WindowView.js":
/*!****************************************!*\
  !*** ./js/objects/views/WindowView.js ***!
  \****************************************/
/*! exports provided: WindowView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindowView", function() { return WindowView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WindowView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WindowView
 * -------------------------------
 * I am the view of a Window Part.
 * Windows are wrappers for Stacks/StackViews that
 * appear as the subparts of other Stacks or Cards.
 * They are examples of how we can use stack and card
 * composition to create more complex UIs.
 */


const template = document.createElement('template');
template.innerHTML = `
<style>
 * {
     box-sizing: border-box;
 }

 .st-window-bar {
     display: flex;
     flex-direction: row;
     width: 100%;
     min-height: 25px;
     background-color: rgb(218, 218, 218);
     padding-left: 8px;
     padding-right: 8px;
     align-items: center;
 }
 .st-window-button {
     display: block;
     width: 12px;
     height: 12px;
     border-radius: 100%;
     background-color: rgba(255, 150, 150);
     margin-right: 4px;
 }
 .close-button {
     background-color: rgba(255, 50, 50, 0.4);
 }
 .shade-button {
     background-color: rgba(255, 255, 0. 0.4);
 }
 .expand-button {
     background-color: rgba(150, 255, 0, 0.8);
 }
 .st-window-pane {
     display: block;
     position: relative;
     min-height: 50px;
     flex: 1;
 }
 .st-window-pane.shaded {
     display: none;
 }
 .st-window-gripper {
     display: block;
     position: absolute;
     top: calc(100% - 15px);
     width: 30px;
     height: 30px;
 }
 .st-window-title {
     user-select: none;
     text-overflow: ellipsis;
     overflow: hidden;
     white-space: nowrap;
     max-width: 70%;
 }
 .right-gripper {
     left: calc(100% - 15px);
 }
 .right-gripper:hover {
     cursor: nwse-resize;
 }
 .left-gripper {
     right: calc(100% - 15px);
 }
 .left-gripper:hover {
     cursor: nesw-resize;
 }
</style>
<div class="st-window-bar">
    <div class="st-window-button close-button"></div>
    <div class="st-window-button shade-button"></div>
    <div class="st-window-button expand-button"></div>
    <div class="st-window-title">
        <span></span>
    </div>
</div>
<div class="st-window-pane">
    <slot></slot>
</div>
<div class="st-window-gripper right-gripper" data-grip-end="right"></div>
`;

class WindowView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        var templateContent = template.content.cloneNode(true);
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(templateContent);

        this.mouseDownInBar = false;
        this.isShaded = false;
        this.isExpanded = false;
        this.expandCache = {};

        // Whether or not we are gripping the
        // bottom right corner for a resize
        this.isGripping = false;

        // Bound methods
        this.setupClickAndDrag = this.setupClickAndDrag.bind(this);
        this.setupBarButtons = this.setupBarButtons.bind(this);
        this.setupExpanderAreas = this.setupExpanderAreas.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.onMouseMoveInBar = this.onMouseMoveInBar.bind(this);
        this.onMouseDownInBar = this.onMouseDownInBar.bind(this);
        this.onMouseUpAfterDrag = this.onMouseUpAfterDrag.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onShade = this.onShade.bind(this);
        this.onExpand = this.onExpand.bind(this);
        this.onGripDown = this.onGripDown.bind(this);
        this.onGripUp = this.onGripUp.bind(this);
        this.onGripMove = this.onGripMove.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('title', this.setTitle);
    }

    afterConnected(){
        this.setupClickAndDrag();
        this.setupBarButtons();
        this.setupExpanderAreas();
    }

    afterModelSet(){
        this.setTitle(
            this.model.partProperties.getPropertyNamed(
                this.model,
                'title'
            )
        );
    }

    setupClickAndDrag(){
        let bar = this._shadowRoot.querySelector('.st-window-bar');
        bar.addEventListener('mousedown', this.onMouseDownInBar);
    }

    setupBarButtons(){
        let closeButton = this._shadowRoot.querySelector('.close-button');
        let shadeButton = this._shadowRoot.querySelector('.shade-button');
        let expandButton = this._shadowRoot.querySelector('.expand-button');

        closeButton.addEventListener('click', this.onClose);
        shadeButton.addEventListener('click', this.onShade);
        expandButton.addEventListener('click', this.onExpand);
    }

    setupExpanderAreas(){
        let lowerRight = this._shadowRoot.querySelector('.right-gripper');
        lowerRight.addEventListener('mousedown', this.onGripDown);
    }

    onExpand(event){
        if(this.isExpanded){
            this.style.width = this.expandCache.width;
            this.style.height = this.expandCache.height;
            this.style.top = this.expandCache.top;
            this.style.left = this.expandCache.left;
            this.isExpanded = false;
        } else {
            this.expandCache = {
                width: this.style.width,
                height: this.style.height,
                top: this.style.top,
                left: this.style.left
            };
            // Set new values based on window size
            this.style.top = "0px";
            this.style.left = "0px";
            this.style.width = "100vw";
            this.style.height = "100vh";
            this.isExpanded = true;
        }
    }

    onShade(event){
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        if(this.isShaded){
            pane.classList.remove('shaded');
            this.isShaded = false;
        } else {
            pane.classList.add('shaded');
            this.isShaded = true;
        }
    }

    onClose(event){
        let msg = {
            type: 'command',
            commandName: 'windowClose',
            args: []
        };
        this.model.sendMessage(msg, this.model);
    }

    onMouseDownInBar(event){
        this.mouseDownInBar = true;
        let bar = event.target;
        document.addEventListener('mousemove', this.onMouseMoveInBar);
        document.addEventListener('mouseup', this.onMouseUpAfterDrag);
    }

    onMouseUpAfterDrag(event){
        this.mouseDownInBar = false;
        let bar = event.target;
        document.removeEventListener('mouseup', this.onMouseUpAfterDrag);
        document.removeEventListener('mousemove', this.onMouseMoveInBar);
    }

    onMouseMoveInBar(event){
        let currentTop = parseInt(this.style.top);
        let currentLeft = parseInt(this.style.left);
        // let newTop = `${currentTop + event.movementY}px`;
        // let newLeft = `${currentLeft + event.movementX}px`;
        let newTop = currentTop + event.movementY;
        let newLeft = currentLeft + event.movementX;
        this.model.partProperties.setPropertyNamed(this.model, "top", newTop);
        this.model.partProperties.setPropertyNamed(this.model, "left", newLeft);
    }

    onGripUp(event){
        this.isGripping = false;
        document.removeEventListener('mousemove', this.onGripMove);
        document.removeEventListener('mouseup', this.onGripUp);
    }

    onGripDown(event){
        this.isGripping = true;
        document.addEventListener('mousemove', this.onGripMove);
        document.addEventListener('mouseup', this.onGripUp);
    }

    onGripMove(event){
        if(this.isGripping){
            // Figure out the current width and height.
            // and set the property to the new one
            let box = this.getBoundingClientRect();
            let newWidth = Math.floor(box.width) + event.movementX;
            if(newWidth){
                this.model.partProperties.setPropertyNamed(this.model, "width", newWidth);
            }
            let newHeight = Math.floor(box.height) + event.movementY;
            if(newHeight){
                this.model.partProperties.setPropertyNamed(this.model, "height", newHeight);
            }
        }
    }

    setTitle(aString){
        let titleArea = this._shadowRoot.querySelector(
            '.st-window-title > span'
        );
        titleArea.innerText = aString;
    }

    // override subclass methods
    newSubpartView(newView){
        // slot the new view into the window pane
        let pane = this._shadowRoot.querySelector('.st-window-pane');
        pane.append(newView);
        this.appendChild(newView);
    }


};




/***/ }),

/***/ "./js/objects/views/WorldView.js":
/*!***************************************!*\
  !*** ./js/objects/views/WorldView.js ***!
  \***************************************/
/*! exports provided: WorldView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorldView", function() { return WorldView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PartView.js */ "./js/objects/views/PartView.js");
/**
 * WorldView
 * ---------------------------------------------
 * I am a Webcomponent (custom element) that represents
 * a view of a WorldStack model.
 * My element children should contain a single StackView representing
 * the current displayed stack (this comes from the model).
 * I am the root-level element for the SimpleTalk system in a web
 * page. There should only be one of me on any given HTML page.
 */


const templateString = `<slot></slot>`;

class WorldView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        // Set up templating and shadow dom
        // TODO: Put the template definition in this
        // module as formatted text
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // The world never wants a halo
        this.wantsHalo = false;

        // Bound methods
        this.updateCurrentStack = this.updateCurrentStack.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('current', this.updateCurrentStack);
    }

    afterConnected(){
        document.addEventListener('keydown', this.handleKeyDown);
    }

    afterDisconnected(){
        document.removeEventListener('keydown', this.handleKeyDown);
    }

    afterModelSet(){
        // Do an initial update to display
        // the model's current stack
        this.updateCurrentStack();
    }

    updateCurrentStack(){
        // The value of the current prop is the stack ID
        // of the child Stack that should be the
        // current one. We remove the current-stack class from
        // the previous current stack and add it to the new one.
        let currentStack = this.querySelector('.current-stack');
        let nextCurrentId = this.model.partProperties.getPropertyNamed(
            this.model,
            'current'
        );
        let nextCurrentStack = this.querySelector(`:scope > st-stack[part-id="${nextCurrentId}"]`);
        if(nextCurrentStack){
            nextCurrentStack.classList.add('current-stack');
        } else {
            return;
        }
        // To prevent the setting of the same id as the current stack make sure
        // next and current are not the same
        if(currentStack && currentStack != nextCurrentStack){
            currentStack.classList.remove('current-stack');
        }
    }

    handleKeyDown(event){
        if(event.altKey && event.ctrlKey && event.code == "Space"){
            let navigator = document.querySelector('st-navigator');
            navigator.toggle();
        }
    }

    // override subclass methods
    newSubpartView(newView){
        if(this.childNodes.length && newView.name == "StackView"){
            let lastStackNode;
            this.childNodes.forEach((child) => {
                if(child.name == "StackView"){
                    lastStackNode = child;
                }
            });
            if(lastStackNode){
                // insert after the last stack
                lastStackNode.after(newView);
            } else {
                // since there are no stacks
                // insert before all children
                this.childNodes[0].insertBefore(newView);
            }
        } else {
            this.appendChild(newView);
        }
    }

};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenu.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenu.js ***!
  \*****************************************************/
/*! exports provided: ContextMenu, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenu", function() { return ContextMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenu; });
/* harmony import */ var _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContextMenuItem.js */ "./js/objects/views/contextmenu/ContextMenuItem.js");
// PREAMBLE


window.customElements.define('st-context-menu-item', _ContextMenuItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        border: 1px solid black;
        background-color: white;
        box-shadow: 1px 2px 10px rgba(50, 50, 50, 0.7);
        z-index: 10000;
        padding-bottom: 8px;
        min-width: 200px;
        font-family: 'Helvetica', sans-serif;
    }

    :host-context(li) {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host-context(li):hover {
        display: flex;
    }

    header {
        position: relative;
        display: flex;
        border-bottom: 1px solid rgba(150, 150, 150, 0.5);
        padding-right: 16px;
        padding-left: 16px;
        padding-top: 8px;
        padding-bottom: 8px;
    }

    header > h4 {
        padding: 0;
        margin:0;
    }

    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        font-size: 0.8rem;
    }

</style>
<header>
    <h4></h4>
</header>
<ul id="list-items">
    <slot></slot>
</ul>
`;

class ContextMenu extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.addHaloToggleItem = this.addHaloToggleItem.bind(this);
        this.addCopyAndPasteItems = this.addCopyAndPasteItems.bind(this);
        this.addOpenEditorItem = this.addOpenEditorItem.bind(this);
        this.addScriptEditItem = this.addScriptEditItem.bind(this);
        this.addMovementItems = this.addMovementItems.bind(this);
        this.addPartSubmenu = this.addPartSubmenu.bind(this);
        this.addListItem = this.addListItem.bind(this);
        this.addSpacer = this.addSpacer.bind(this);
        this.hideHeader = this.hideHeader.bind(this);
    }

    render(aModel){
        this.innerHTML = "";
        this.model = aModel;
        let headerEl = this._shadowRoot.querySelector('header > h4');
        let headerText = `${this.model.type[0].toUpperCase()}${this.model.type.slice(1)}`;
        headerText = `a ${headerText}`;
        headerEl.textContent = headerText;

        // Render the default menu items
        this.addHaloToggleItem();
        this.addCopyAndPasteItems();
        this.addOpenEditorItem();
        this.addPartSubmenu();
        this.addScriptEditItem();
        this.addMovementItems();

        // Add View-specific items
        let view = document.querySelector(`[part-id="${this.model.id}"]`);
        view.addContextMenuItems(this);
    }

    addListItem(label, callback, submenu=null){
        let itemEl = document.createElement('st-context-menu-item');
        itemEl.textContent = label;
        itemEl.classList.add('context-menu-item');
        itemEl.addEventListener('click', callback);
        if(submenu){             
            submenu.classList.add('context-submenu', 'submenu-hidden');
            submenu.setAttribute('slot', 'submenu');
            itemEl.append(submenu);
            itemEl.showCaret();
        }
        this.append(itemEl);
    }

    addHaloToggleItem(){
        let target = window.System.findViewById(this.model.id);
        // don't add halo option to cards, since you can't see those
        if(target.name != "CardView"){
            if(target.classList.contains('editing')){
                this.addListItem(
                    'Close Halo',
                    (event) => {
                        target.closeHalo();
                    }
                );
            } else {
                this.addListItem(
                    'Open Halo',
                    (event) => {
                        target.openHalo();
                    }
                );
            }
        }
    }

    addCopyAndPasteItems(){
        // Add copy item
        this.addListItem(
            'Copy',
            (event) => {
                window.System.clipboard.copyPart(this.model);
            }
        );

        // Add paste but only if:
        // 1. There is clipboard contents;
        // 2. The part type in the clipboard is
        //    one that is accepted by this model's part
        if(window.System.clipboard.contents.length){
            let partType = window.System.clipboard.contents[0].partType;
            if(this.model.acceptsSubpart(partType)){
                let label = `Paste (a ${partType[0].toUpperCase()}${partType.slice(1)})`;
                this.addListItem(label, (event) => {
                    window.System.clipboard.pasteContentsInto(this.model);
                });
            }
        }
    }

    addOpenEditorItem(){
        this.addListItem(
            'Open Editor',
            (event) => {
                window.System.openEditorForPart(this.model.id);
            }
        );
    }

    addScriptEditItem(){
        this.addListItem(
            'Edit Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: [this.model.id]
                }, this.model);
            }
        );

        this.addListItem(
            'Edit World Script',
            (event) => {
                this.model.sendMessage({
                    type: 'command',
                    commandName: 'openScriptEditor',
                    args: ['world']
                }, this.model);
            }
        );

        let windowAncestor = this.model.findAncestorOfType('window');
        if(this.model.type != 'window' && windowAncestor !== null){
            this.addListItem(
                'Edit Owning Window Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [windowAncestor.id]
                    }, this.model);
                }
            );
        }
        
        let cardAncestor = this.model.findAncestorOfType('card');
        if(this.model.type != 'card' && cardAncestor){
            this.addListItem(
                'Edit Owning Card Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [cardAncestor.id]
                    }, this.model);
                }
            );
        }

        let stackAncestor = this.model.findAncestorOfType('stack');
        if(this.model.type != 'stack' && stackAncestor){
            this.addListItem(
                'Edit Owning Stack Script',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'openScriptEditor',
                        args: [stackAncestor.id]
                    }, this.model);
                }
            );
        }
    }

    addPartSubmenu(){
        // First, we need to get a list of names
        // of subparts that this model accepts
        let subpartNames;
        if(this.model.acceptedSubpartTypes[0] == "*"){
            // This model accepts all subpart types.
            // We need to get the names for these subparts,
            // which are registered at the System level.
            subpartNames = Object.keys(window.System.availableViews);
        } else {
            subpartNames = this.model.acceptedSubpartTypes;
        }

        // If there are no subpart names (meaning
        // the given part, like a button, doesn't
        // accept any subparts), then we do nothing.
        if(subpartNames.length == 0){
            return;
        }

        // Now we construct the submenu for adding parts
        // of the given type
        let submenu = document.createElement('st-context-menu');
        submenu.hideHeader();
        subpartNames.forEach(subpartName => {
            submenu.addListItem(
                subpartName[0].toUpperCase() + subpartName.slice(1),
                () => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'newModel',
                        args: [
                            subpartName,
                            this.model.id
                        ]
                    }, this.model);
                }
            );
        });

        // Now add the list item that will "reveal"
        // the submenu
        this.addListItem(
            'Add a new part',
            null,
            submenu
        );
        
    }

    addMovementItems(){
        let index = this.model._owner.subparts.indexOf(this.model);
        let ownerLength = this.model._owner.subparts.length;
        if(ownerLength && index < ownerLength - 1){
            // Create the moveDown option
            this.addListItem(
                'Move Down',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveDown',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to Last',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToLast',
                        args: []
                    }, this.model);
                }
            );
        }
        if(index > 0){
            // Create the moveUp option
            this.addListItem(
                'Move Up',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveUp',
                        args: []
                    }, this.model);
                }
            );
            this.addListItem(
                'Move to First',
                (event) => {
                    this.model.sendMessage({
                        type: 'command',
                        commandName: 'moveToFirst',
                        args: []
                    }, this.model);
                }
            );
        }
    }

    addSpacer(){
        let item = document.createElement('li');
        item.classList.add('context-menu-spacer');
        this.append(item);
    }

    hideHeader(){
        let headerEl = this._shadowRoot.querySelector('header');
        headerEl.style.display = "none";
    }
};




/***/ }),

/***/ "./js/objects/views/contextmenu/ContextMenuItem.js":
/*!*********************************************************!*\
  !*** ./js/objects/views/contextmenu/ContextMenuItem.js ***!
  \*********************************************************/
/*! exports provided: ContextMenuItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenuItem", function() { return ContextMenuItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContextMenuItem; });
const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
    }
    .submenu-area {
        display: none;
        position: absolute;
        left: 100%;
        top: 0px;
    }

    :host(:hover) .submenu-area {
        display: flex;
    }

    .label-area {
        display: flex;
        align-items: center;
    }

    .caret.hidden {
        display: none;
    }
    .caret {
        display: block;
        margin-left: auto;
        font-size: 1.1em;
    }
</style>
<div class="label-area">
    <span class="label"><slot></slot></span>
    <div class="caret hidden"></div>
</div>
<div class="submenu-area">
    <slot name="submenu"></slot>
</div>
`;

class ContextMenuItem extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.append(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.showCaret = this.showCaret.bind(this);
    }

    showCaret(){
        let caretEl = this._shadowRoot.querySelector('.caret');
        caretEl.classList.remove('hidden');
        
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/ColorPickerTool.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/drawing/ColorPickerTool.js ***!
  \*****************************************************/
/*! exports provided: ColorPickerTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPickerTool", function() { return ColorPickerTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorPickerTool; });
/* harmony import */ var _ColorWheelWidget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorWheelWidget.js */ "./js/objects/views/drawing/ColorWheelWidget.js");
/**
 * ColorPickerTool
 * I provide a color choorser capability
 * for the shadow canvas of my parent element.
 * Brushes on my parent Drawing canvas will use
 * whatever color I have currently selected.
 * I am explicitly designed for use with
 * DrawingView*/

const colorPickerSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-color-swatch" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 3h-4a2 2 0 0 0 -2 2v12a4 4 0 0 0 8 0v-12a2 2 0 0 0 -2 -2" />
  <path d="M13 7.35l-2 -2a2 2 0 0 0 -2.828 0l-2.828 2.828a2 2 0 0 0 0 2.828l9 9" />
  <path d="M7.3 13h-2.3a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h12" />
  <line x1="17" y1="17" x2="17" y2="17.01" />
</svg>
`;

const colorPickerTemplateString = `
<style>
    :host {
        display: block;
        position: relative;
        margin-bottom: 6px;
    }

    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        position: relative;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
        width: 24px;
        height: 24px;
    }

    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    color-wheel {
        display: none;
        position: absolute;
    }

    :host([active="true"]) > color-wheel {
        display: flex;
    }
</style>
<div id="tool-button">
${colorPickerSVG}
</div>
<color-wheel></color-wheel>
`;


class ColorPickerTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can be
        // toggled within its parent DrawingView.
        this.template = document.createElement('template');
        this.template.innerHTML = colorPickerTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool
        // is connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.onColorSelected = this.onColorSelected.bind(this);
        this.onTransparencyChanged = this.onTransparencyChanged.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('current-color')){
                this.setAttribute('current-color', 'rgba(0, 0, 0, 0)');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.colorWheel = this.shadowRoot.querySelector('color-wheel');
            this.colorWheel.addEventListener('color-selected', this.onColorSelected);
            this.colorWheel.addEventListener('transparency-changed', this.onTransparencyChanged);
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.colorWheel.removeEventListener('color-selected', this.onColorSelected);
        this.colorWheel.removeEventListener('transparency-changed', this.onTransparencyChanged);
    }

    start(x, y){
        // Does nothing in this tool
    }

    end(x, y){
        // Does nothing in this tool
    }

    onMove(x, y){
        // Does nothing in this tool
    }

    setContextFromAttributes(){
        // Does nothing in this tool
    }

    onColorSelected(event){
        let colorInfo = event.detail;
        let colorStr = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
        this.ctx.strokeStyle = colorStr;
        this.ctx.fillStyle = colorStr;
    }

    onTransparencyChanged(event){
        this.parentElement.model.sendMessage({
            type: "command",
            commandName: "setProperty",
            args: ["transparency", event.detail]
        }, this.parentElement.model);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};



window.customElements.define('color-picker-tool', ColorPickerTool);




/***/ }),

/***/ "./js/objects/views/drawing/ColorWheelWidget.js":
/*!******************************************************!*\
  !*** ./js/objects/views/drawing/ColorWheelWidget.js ***!
  \******************************************************/
/*! exports provided: ColorWheelWidget, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorWheelWidget", function() { return ColorWheelWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorWheelWidget; });
/**
 * ColorWheelWidget
 * I am a *generic use* webcomponent representing
 * a ColorWheel selection widget.
 * I operate as a floating modal window with a
 * circular color wheel as well as a list of
 * recently selected colors.
 * I am designed to be used by any parent element.
 * I will trigger an event called 'color-change' whenever
 * a new color has been selected from within me
 */

const colorWheelTemplate = `
<style>
  :host {
    display: initial !important;
    visibility: visible !important;
    position: relative;
    flex-direction: column;
    align-items: center;
    box-sizing: border-box;
    background-color: white;
    border: 1px solid black;
  }

  #palette-bar {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    height: 20px;
    background-color: rgba(200, 200, 200);
    width: 100%;
    box-sizing: border-box;
  }

  #palette-title {
    width: 100%;
    text-align: center;
  }

  #close-button {
    display: block;
    width: 12px;
    height: 12px;
    margin-left: 8px;
    background-color: white;
    border: 1px solid black;
    text-align: center;
    font-size: 12px;
  }

  #palette-content {
    flex: 1;
    display: block;
    position: relative;
  }
  #hover-color {
    display: block;
    width: 100%;
    height: 25px;
  }
  #options {
    display: flex;
    width: 100%;
    height: 25px;
    margin-top: 5px;
    justify-content: center;
  }

  #options > label{
    font-size: .8rem;
    display: flex;
    align-items: center;
  }

  #recent-colors {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    padding-left: 15px;
    padding-right: 15px;
    box-sizing: border-box;
    list-style: none;
  }
  .recent-color-item {
    display: block;
    width: 26px;
    height: 26px;
    box-sizing: border-box;
    border: 1px solid rgba(200, 200, 200, 0.8);
  }

  .recent-color-item.selected {
    border: 2px solid black;
  }

</style>
<div id="palette-wrapper">
  <div id="palette-bar"><div id="close-button">x</div><span id="palette-title"></span></div>
  <div id="palette-content">
    <div id="options">
      <input type="range" id="transparency" name="transparency" min="0" max="1" step="0.1" value="1">
      <!-- <label for="transparency">Transparency</label>-->
    </div>
    <ul id="recent-colors">
      <li class="recent-color-item selected"></li>
      <li class="recent-color-item"></li>
      <li class="recent-color-item"></li>
    </ul>
    <canvas id="color-wheel" width="150" height="150"></canvas>
    <div id="hover-color"></div>
  </div>
</div>
`;

class ColorWheelWidget extends HTMLElement {
    constructor(name){
        super();

        this.name = name;

        // Setup shadow dom and template
        this.template = document.createElement('template');
        this.template.innerHTML = colorWheelTemplate;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Bind local methods
        this.onWheelMouseEnter = this.onWheelMouseEnter.bind(this);
        this.onWheelMouseLeave = this.onWheelMouseLeave.bind(this);
        this.onWheelMouseMove = this.onWheelMouseMove.bind(this);
        this.onWheelClick = this.onWheelClick.bind(this);
        this.onItemClick = this.onItemClick.bind(this);
        this.onBarMouseDown = this.onBarMouseDown.bind(this);
        this.onBarMouseUp = this.onBarMouseUp.bind(this);
        this.onBarMouseMove = this.onBarMouseMove.bind(this);
        this.onClose = this.onClose.bind(this);
        this.onTransparencyChange = this.onTransparencyChange.bind(this);
        this._drawWheel = this._drawWheel.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.canvas = this.shadowRoot.querySelector('canvas');
            this.bar = this.shadowRoot.getElementById('palette-bar');
            // give the widget a title if provided
            if(this.name){
                this.shadowRoot.getElementById('palette-title').innerText = this.name;
            }

            // Set events
            this.canvas.addEventListener('click', this.onWheelClick);
            this.canvas.addEventListener('mouseenter', this.onWheelMouseEnter);
            this.bar.addEventListener('mousedown', this.onBarMouseDown);
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item')).forEach(el => {
                el.addEventListener('click', this.onItemClick);
            });
            this.transparencySlider = this.shadowRoot.getElementById('transparency');
            this.transparencySlider.addEventListener("input", this.onTransparencyChange);

            // Draw the color wheel to the canvas
            this._drawWheel();
        }
    }

    disconnectedCallback(){
        this.canvas.removeEventListener('click', this.onWheelClick);
        this.canvas.removeEventListener('mouseenter', this.onWheelMouseEnter);
        this.bar.removeEventListener('mousedown', this.onBarMouseDown);
        Array.from(this.shadowRoot.querySelector('.recent-color-item')).forEach(el => {
            el.removeEventListener('click', this.onItemClick);
        });
        this.transparencySlider.removeEventListener("change", this.onTransparencyChange);
    }


    onWheelMouseEnter(event){
        // Cache the image data for the whole canvas
        let ctx = this.canvas.getContext('2d');
        this._cachedImageData = ctx.getImageData(
            0,
            0,
            this.canvas.width,
            this.canvas.height
        );
        // Bind subsequent events
        this.canvas.addEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.addEventListener('mouseleave', this.onWheelMouseLeave);
    }

    onWheelMouseLeave(event){
        this.canvas.removeEventListener('mousemove', this.onWheelMouseMove);
        this.canvas.removeEventListener('mouseleave', this.onWheelMouseLeave);
        this._cachedImageData = null;
    }

    onWheelMouseMove(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let hoverColorArea = this.shadowRoot.getElementById('hover-color');
        let newStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;
        hoverColorArea.style.backgroundColor = newStyle;
    }

    onWheelClick(event){
        let position = getPositionFromEvent(event);
        let rgb = getRGBFromImageData(
            position.x,
            position.y,
            this.canvas.width,
            this._cachedImageData.data
        );
        let colorInfo = {
            r: rgb[0],
            g: rgb[1],
            b: rgb[2],
            alpha: rgb[3]
        };
        let newEvent = new CustomEvent('color-selected', {
            detail: colorInfo
        });
        this.selectedColor = colorInfo;
        this.dispatchEvent(newEvent);

        // Update the recent color swatches
        let currentSwatchSelection = this.shadowRoot.querySelector('.recent-color-item.selected');
        if(currentSwatchSelection){
            currentSwatchSelection.style.backgroundColor = `rgba(${colorInfo.r}, ${colorInfo.g}, ${colorInfo.b}, ${colorInfo.alpha})`;
            currentSwatchSelection.selectedColor = colorInfo;
        }
    }

    onTransparencyChange(event){
        let command = this.getAttribute("selector-command");
        // update the corresponding transparency - text or background
        // depending on what this color wheel is setup to update
        let propName = "background-transparency";
        if(command === "text-color"){
            propName = "text-transparency";
        }
        let eventDetail = {propName: propName, value: event.target.value};
        let newEvent = new CustomEvent('transparency-changed', {
            detail: eventDetail,
        });
        this.dispatchEvent(newEvent);
    }

    onItemClick(event){
        // If this element is not the currently
        // selected recent item, find the one that is
        // and toggle the selection class, then toggle
        // this item's selection class.
        if(!event.target.classList.contains('selected')){
            Array.from(this.shadowRoot.querySelectorAll('.recent-color-item.selected')).forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        if(event.target.selectedColor){
            let newEvent = new CustomEvent('color-selected', {
                detail: event.target.selectedColor
            });
            this.dispatchEvent(newEvent);
        }
    }

    onBarMouseDown(event){
        document.addEventListener('mousemove', this.onBarMouseMove);
        document.addEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseUp(event){
        document.removeEventListener('mousemove', this.onBarMouseMove);
        document.removeEventListener('mouseup', this.onBarMouseUp);
    }

    onBarMouseMove(event){
        let newTop = this.offsetTop + event.movementY;
        let newLeft = this.offsetLeft + event.movementX;
        this.style.top = `${newTop}px`;
        this.style.left = `${newLeft}px`;
    }

    onClose(event){
        this.remove();
    }

    _drawWheel(){
        let ctx = this.canvas.getContext('2d');
        drawCircle(ctx, this.canvas.width / 2);
    }
};

window.customElements.define('color-wheel', ColorWheelWidget);

/** Utility Functions **/

// This function is adapted from
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const drawCircle = (ctx, radius) => {
    let image = ctx.createImageData(2*radius, 2*radius);
    let data = image.data;

    for (let x = -radius; x < radius; x++) {
        for (let y = -radius; y < radius; y++) {

            let [r, phi] = xy2polar(x, y);

            if (r > radius) {
                // skip all (x,y) coordinates that are outside of the circle
                continue;
            }

            let deg = rad2deg(phi);

            // Figure out the starting index of this pixel in the image data array.
            let rowLength = 2*radius;
            let adjustedX = x + radius; // convert x from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let adjustedY = y + radius; // convert y from [-50, 50] to [0, 100] (the coordinates of the image data array)
            let pixelWidth = 4; // each pixel requires 4 slots in the data array
            let index = (adjustedX + (adjustedY * rowLength)) * pixelWidth;

            let hue = deg;
            let saturation = r / radius;
            let value = 1.0;

            let [red, green, blue] = hsv2rgb(hue, saturation, value);
            let alpha = 255;

            data[index] = red;
            data[index+1] = green;
            data[index+2] = blue;
            data[index+3] = alpha;
        }
    }

    ctx.putImageData(image, 0, 0);
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const xy2polar = (x, y) => {
    let r = Math.sqrt(x*x + y*y);
    let phi = Math.atan2(y, x);
    return [r, phi];
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43s
const rad2deg = (rad) => {
    return ((rad + Math.PI) / (2 * Math.PI)) * 360;
};

// This utility function is adapted from:
// https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43
const hsv2rgb = (hue, saturation, value) => {
    let chroma = value * saturation;
    let hue1 = hue / 60;
    let x = chroma * (1- Math.abs((hue1 % 2) - 1));
    let r1, g1, b1;
    if (hue1 >= 0 && hue1 <= 1) {
        ([r1, g1, b1] = [chroma, x, 0]);
    } else if (hue1 >= 1 && hue1 <= 2) {
        ([r1, g1, b1] = [x, chroma, 0]);
    } else if (hue1 >= 2 && hue1 <= 3) {
        ([r1, g1, b1] = [0, chroma, x]);
    } else if (hue1 >= 3 && hue1 <= 4) {
        ([r1, g1, b1] = [0, x, chroma]);
    } else if (hue1 >= 4 && hue1 <= 5) {
        ([r1, g1, b1] = [x, 0, chroma]);
    } else if (hue1 >= 5 && hue1 <= 6) {
        ([r1, g1, b1] = [chroma, 0, x]);
    }

    let m = value - chroma;
    let [r,g,b] = [r1+m, g1+m, b1+m];

    // Change r,g,b values from [0,1] to [0,255]
    return [255*r,255*g,255*b];
};

const getPositionFromEvent = (event) => {
    let target = event.target;
    let offsetX = target.offsetLeft;
    let offsetY = target.offsetTop;
    let check = target.offsetParent;
    while(check){
        offsetX += check.offsetLeft;
        offsetY += check.offsetTop;
        check = check.offsetParent;
    }
    let result = {
        x: event.clientX - offsetX,
        y: event.clientY - offsetY
    };
    return result;
};

const getRGBFromImageData = (x, y, width, data) => {
    let index = (y * width + x) * 4;
    return [
        data[index], // r
        data[index + 1], // g
        data[index + 2], // b
        data[index + 3] // alpha
    ];
};




/***/ }),

/***/ "./js/objects/views/drawing/DrawingView.js":
/*!*************************************************!*\
  !*** ./js/objects/views/drawing/DrawingView.js ***!
  \*************************************************/
/*! exports provided: DrawingView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawingView", function() { return DrawingView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DrawingView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _PencilTool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PencilTool.js */ "./js/objects/views/drawing/PencilTool.js");
/* harmony import */ var _EraserTool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EraserTool.js */ "./js/objects/views/drawing/EraserTool.js");
/* harmony import */ var _ColorPickerTool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ColorPickerTool.js */ "./js/objects/views/drawing/ColorPickerTool.js");
/**
 * DrawingView
 * Experimental.
 * This is still a pure webcomponent and is not
 * linked at all to SimpleTalk yet.
 *
 */





const haloButtonSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tool" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 10h3v-3l-3.5 -3.5a6 6 0 0 1 8 8l6 6a2 2 0 0 1 -3 3l-6-6a6 6 0 0 1 -8 -8l3.5 3.5" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: inline-block;
        position: relative;
        box-sizing: border-box;
    }
    #tool-buttons {
        position: absolute;
        left: calc(100% + 5px);
        top: 0px;
        display: flex;
        flex-direction: column;
    }
    :host(.show-border){
        border: 1px solid black;
    }
    :host(:not([mode="drawing"])) > #tool-buttons {
        display: none;
    }
</style>
<canvas></canvas >
<div id="tool-buttons">
<slot></slot>
</div>
`;

class DrawingView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["PartView"] {
    constructor(){
        super();

        // Setup shadow dom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        this.colorPickerTool = null;

        this.isCurrentlyDrawing = false;

        // Bind component methods
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onHaloResize = this.onHaloResize.bind(this);
        this.initCustomHaloButton = this.initCustomHaloButton.bind(this);
        this.toggleMode = this.toggleMode.bind(this);
        this.afterDrawAction = this.afterDrawAction.bind(this);
        this.restoreImageFromModel = this.restoreImageFromModel.bind(this);
        this.setupPropHandlers = this.setupPropHandlers.bind(this);
        this.modeChanged = this.modeChanged.bind(this);

        // Setup prop handlers
        this.setupPropHandlers();
    }

    setupPropHandlers(){
        this.onPropChange('mode', this.modeChanged);
        this.onPropChange('image', () => {
            let imageBits = this.model.partProperties.getPropertyNamed(
                this.model,
                'image'
            );
            this.restoreImageFromModel(imageBits);
        });
        this.onPropChange('show-border', (val) => {
            if(val){
                this.classList.add('show-border');
            } else {
                this.classList.remove('show-border');
            }
        });
        this.onPropChange('width', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("width", cssStyle.width);
        });
        this.onPropChange('height', (val) => {
            // Note: what we want is the calculated CSS, not the ST part property value
            let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
            let canvas = this.shadow.querySelector('canvas');
            canvas.setAttribute("height", cssStyle.height);
        });
    }

    modeChanged(value){
        this.setAttribute('mode', value);
    }

    afterConnected(){
        this.canvas = this.shadow.querySelector('canvas');
        this.canvas.addEventListener('mouseup', this.onMouseUp);
        this.canvas.addEventListener('mousedown', this.onMouseDown);

        // Set and store the drawing context
        this.drawingContext = this.canvas.getContext('2d');

        // If I don't have the default tools, add
        // them as real dom children now
        let pencilChild = this.querySelector('pencil-tool');
        if(!pencilChild){
            let newPencil = document.createElement('pencil-tool');
            this.append(newPencil);
        }
        let eraserChild = this.querySelector('eraser-tool');
        if(!eraserChild){
            let newEraser = document.createElement('eraser-tool');
            this.append(newEraser);
        }

        let colorPickerChild = this.querySelector('color-picker-tool');
        if(!colorPickerChild){
            let newColorPicker = document.createElement('color-picker-tool');
            // TODO this is a total hack since drawing does not work well with styles at the moment
            this.append(newColorPicker);
            newColorPicker.colorWheel.shadowRoot.querySelector('div#options').style.display = "none";
            this.colorPickerTool = newColorPicker;
        }

        if(!this.haloButton){
            this.initCustomHaloButton();
        }
    }

    afterDisconnected(){
        this.canvas.removeEventListener('mouseup', this.onMouseUp);
        this.canvas.removeEventListener('mousedown', this.onMouseDown);
    }

    afterModelSet(){
        // setup the canvas height and width
        // Note: what we want is the calculated CSS, not the ST part property value
        let cssStyle = this.model.partProperties.getPropertyNamed(this.model, "cssStyle");
        let canvas = this.shadow.querySelector('canvas');
        canvas.setAttribute("height", cssStyle.height);
        canvas.setAttribute("width", cssStyle.width);
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        if(currentImage){
            this.restoreImageFromModel(currentImage);
        }

        let initialShowBorder = this.model.partProperties.getPropertyNamed(
            this.model,
            'show-border'
        );
        if(initialShowBorder){
            this.classList.add('show-border');
        }
    }

    onMouseDown(event){
        if(event.shiftKey){
            return;
        } else if(!this.inDrawingMode) {
            // Send the mouseUp command message to self
            this.model.sendMessage({
                type: 'command',
                commandName: 'mouseUp',
                args: [],
                shouldIgnore: true // Should ignore if System DNU
            }, this.model);
        }
        this.activeTool = this.querySelector('[role="tool"][active="true"]');
        if(!this.activeTool){
            return;
        }
        this.isCurrentlyDrawing = true;
        let canvas = this.shadow.querySelector('canvas');
        canvas.addEventListener('mousemove', this.onMouseMove);
        canvas.addEventListener('mouseleave', this.onMouseLeave);
        this.activeTool.start(event.offsetX, event.offsetY);
    }

    onMouseMove(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode){
            this.activeTool.onMove(
                event.offsetX,
                event.offsetY
            );
        } else if(this.model.partProperties.getPropertyNamed(this.model, "wants-move")){
            this.sendMessage({
                type: 'command',
                commandName: 'move',
                args: [event.movementX, event.movementY]
            }, this.model);
        }
    }

    onMouseUp(event){
        if(event.shiftKey){
            return;
        }
        if(this.activeTool && this.inDrawingMode && this.isCurrentlyDrawing){
            this.activeTool.end(event.offsetX, event.offsetY);
            this.afterDrawAction();
        }
        this.isCurrentlyDrawing = false;
        let canvas = this.shadow.querySelector('canvas');
        canvas.removeEventListener('mousemove', this.onMouseMove);
        canvas.removeEventListener('mouseleave', this.onMouseLeave);
    }


    onMouseLeave(event){
        // If this is triggered, we left the area
        // while drawing. So call the activeTool's
        // end method
        this.activeTool.end(
            event.offsetX,
            event.offsetY
        );
        this.isCurrentlyDrawing = false;
        this.afterDrawAction();
        this.canvas.removeEventListener('mouseleave', this.onMouseLeave);
        this.canvas.removeEventListener('mousemove', this.onMouseMove);
    }

    onHaloResize(movementX, movementY){
        let canvas = this.shadowRoot.querySelector('canvas');
        let currentImage = this.model.partProperties.getPropertyNamed(
            this.model,
            'image'
        );
        // canvas.width = canvas.width + movementX;
        // canvas.height = canvas.height + movementY;
        let newWidth = canvas.width + movementX;
        let newHeight = canvas.height + movementY;
        if(newWidth && newHeight){
            // this.style.width = `${newWidth}px`;
            // this.style.height = `${newHeight}px`;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'width',
                newWidth,
                true
            );
            this.model.partProperties.setPropertyNamed(
                this.model,
                'height',
                newHeight,
                true
            );
        }
        this.restoreImageFromModel(currentImage);
    }

    afterDrawAction(){
        // Encode canvas contents as base64 png
        // and set to model's image property
        let canvas = this.shadowRoot.querySelector('canvas');
        this.model.partProperties.setPropertyNamed(
            this.model,
            'image',
            canvas.toDataURL()
        );
        //this.setAttribute("mode", "");
    }

    restoreImageFromModel(base64ImageData){
        // Clear and draw the image to restore to
        // the canvas
        if(base64ImageData){
            let canvas = this.shadowRoot.querySelector('canvas');
            let context = canvas.getContext('2d');
            let img = new Image();
            img.onload = function(){
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(img, 0, 0);
            };
            img.src = base64ImageData;

            // Set the border to hide
            this.model.partProperties.setPropertyNamed(
                this.model,
                'show-border',
                false
            );
        }
    }

    initCustomHaloButton(){
        this.haloButton = document.createElement('div');
        this.haloButton.id = "halo-drawing-toggle-mode";
        this.haloButton.classList.add('halo-button');
        this.haloButton.innerHTML = haloButtonSVG;
        this.haloButton.style.marginRight = "6px";
        this.haloButton.setAttribute('slot', 'bottom-row');
        this.haloButton.setAttribute('title', 'Toggle drawing tools');
        this.haloButton.addEventListener('click', this.toggleMode);
    }

    openHalo(){
        // Override default. Here we add a custom button
        // when showing.
        let foundHalo = this.shadowRoot.querySelector('st-halo');
        if(!foundHalo){
            foundHalo = document.createElement('st-halo');
            this.shadowRoot.appendChild(foundHalo);
        }
        foundHalo.append(this.haloButton);
    }

    toggleMode(){
        let currentMode = this.getAttribute('mode');
        let nextMode = 'viewing'; // By default, set to viewing
        let isEmpty = (!currentMode || currentMode == undefined || currentMode == "");
        if(currentMode == 'viewing' || isEmpty){
            nextMode = 'drawing';
        }
        this.model.partProperties.setPropertyNamed(
            this.model,
            'mode',
            nextMode
        );
    }

    get inDrawingMode(){
        if(!this.model){
            return false;
        }
        let mode = this.getAttribute('mode');
        if(mode == 'drawing'){
            return true;
        }
        return false;
    }
};




/***/ }),

/***/ "./js/objects/views/drawing/EraserTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/EraserTool.js ***!
  \************************************************/
/*! exports provided: EraserTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EraserTool", function() { return EraserTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EraserTool; });
/**
 * EraserTool
 * -----------------------------------
 * I provide eraser-like functionality on
 * my parent element's shadow canvas.
 * I am specifically designed for use as a
 * child of DrawingView
 */
const eraserSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-eraser" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M19 19h-11l-4 -4a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9 9" />
  <line x1="18" y1="12.3" x2="11.7" y2="6" />
</svg>
`;

const eraserToolTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${eraserSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class EraserTool extends HTMLElement {
    constructor(){
        super();

        // Setup shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = eraserToolTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context is null.
        // This will be set if and when this tool is
        // connected to a parent element that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
                this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.cachedStrokeStyle = this.ctx.strokeStyle;
        this.ctx.strokeStyle = 'red';
        this.ctx.globalCompositeOperation = 'destination-out';
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.strokeStyle = this.cachedStrokeStyle;
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};
window.customElements.define('eraser-tool', EraserTool);




/***/ }),

/***/ "./js/objects/views/drawing/PencilTool.js":
/*!************************************************!*\
  !*** ./js/objects/views/drawing/PencilTool.js ***!
  \************************************************/
/*! exports provided: PencilTool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PencilTool", function() { return PencilTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PencilTool; });
/**
 * PencilTool
 * --------------------------
 * I provide pencil-like drawing capability
 * on the shadow canvas of my parent element.
 * I am explicitly designed for use with
 * DrawingView
 */
const pencilSVG = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
  <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
</svg>
`;

const pencilTemplateString = `
<style>
    :host {
        display: flex;
        position: relative;
        margin-bottom: 6px;
    }
    #tool-button {
        --active-color: black;
        --inactive-color: rgb(170, 170, 170);
        --hover-color: rgb(140, 140, 140);
        display: block;
        width: 24px;
        height: 24px;
        border-width: 1px;
        border-style: solid;
        border-color: var(--inactive-color);
        color: var(--inactive-color);
    }
    :host([active="true"]) > #tool-button {
        border-color: var(--active-color);
        color: var(--active-color);
    }
    #brushes-container {
        position: relative;
        margin-left: 6px;
        display: none;
    }
    #brush-adjuster {
        position: relative;
        display: flex;
        margin-left: 6px;
        box-sizing: border-box;
        border-width: 1px;
        border-style: solid;
        border-color: var(--active-color);
    }
    #brush-slider,
    #brush-number {
        box-sizing: border-box;
    }
    #brush-number {
        max-width: 3rem;
    }
    :host([active="true"]) > #brushes-container {
        display: flex;
    }
</style>
<div id="tool-button">
  ${pencilSVG}
</div>
<div id="brushes-container">
  <div id="brush-adjuster">
    <input id="brush-slider" type="range" min="1" max="100" step="1">
    <input id="brush-number" type="number">
  </div>
</div>
`;

class PencilTool extends HTMLElement {
    constructor(){
        super();

        // Set up shadow dom. This tool will
        // display itself as a button that can
        // be toggled.
        this.template = document.createElement('template');
        this.template.innerHTML = pencilTemplateString;
        this.shadow = this.attachShadow({mode: 'open'});
        this.shadow.append(
            this.template.content.cloneNode(true)
        );

        // Default drawing context
        // is null. This will be set
        // if and when this tool is
        // connected to a parent element
        // that has a context
        this.ctx = null;

        // Bind component methods
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.onMove = this.onMove.bind(this);
        this.toggleActive = this.toggleActive.bind(this);
        this.setContextFromAttributes = this.setContextFromAttributes.bind(this);
        this.handleBrushSliderChange = this.handleBrushSliderChange.bind(this);
        this.handleBrushNumberInputChange = this.handleBrushNumberInputChange.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.setAttribute('role', 'tool');
            this.setAttribute('active', false);
            if(!this.hasAttribute('width')){
                this.setAttribute('width', '6');
            }
            if(this.parentElement.drawingContext){
                this.ctx = this.parentElement.drawingContext;

                // If I am the only tool in my parent,
                // set myself to active
                let siblingTools = this.parentElement.querySelectorAll('[role="tool"]');
                if(siblingTools.length == 1){
                    this.setAttribute('active', true);
                }
            }

            // Attach event listeners
            this.button = this.shadowRoot.getElementById('tool-button');
            this.button.addEventListener('click', this.toggleActive);
            this.brushSlider = this.shadowRoot.getElementById('brush-slider');
            this.brushSlider.addEventListener('input', this.handleBrushSliderChange);
            this.brushNumberInput = this.shadowRoot.getElementById('brush-number');
            this.brushNumberInput.addEventListener('input', this.handleBrushNumberInputChange);

            // If there are is currently a width set,
            // update the slider and number input accordingly
            let currentWidth = this.getAttribute('width');
            if(currentWidth){
            this.brushSlider.value = parseInt(currentWidth);
                this.brushNumberInput.value = parseInt(currentWidth);
            }
        }
    }

    disconnectedCallback(){
        this.ctx = null;
        this.button.removeEventListener('click', this.toggleActive);
        this.brushSlider.removeEventListener('input', this.handleBrushSliderChange);
        this.brushNumberInput.removeEventListener('input', this.handleBrushNumberInputChange);
    }

    start(x, y){
        this.setContextFromAttributes();
        this.ctx.moveTo(x, y);
        this.ctx.beginPath();
    }

    onMove(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }

    end(x, y){
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        this.ctx.closePath();
    }

    setContextFromAttributes(){
        // line cap
        let lineCap = this.getAttribute('line-cap');
        if(lineCap){
            this.ctx.lineCap = lineCap;
        } else {
            this.ctx.lineCap = "round"; // default
        }

        // line join
        let lineJoin = this.getAttribute('line-join');
        if(lineJoin){
            this.ctx.lineJoin = lineJoin;
        } else {
            this.ctx.lineJoin = "round";
        }

        // line width
        let lineWidth = this.getAttribute('width');
        if(lineWidth){
            this.ctx.lineWidth = parseInt(lineWidth);
        } else {
            this.ctx.lineWidth = 6;
        }
    }

    static get observedAttributes(){
        return [
            'width',
            'line-join',
            'line-cap'
        ];
    }

    attributeChangedCallback(name, oldVal, newVal){
        if(name == 'width'){
            if(this.brushSlider){
                this.brushSlider.value = parseInt(newVal);
            }
            if(this.brushNumberInput){
                this.brushNumberInput.value = parseInt(newVal);
            }
        }
    }

    handleBrushSliderChange(event){
        this.setAttribute('width', event.target.value);
    }

    handleBrushNumberInputChange(event){
        this.setAttribute('width', event.target.value);
    }

    toggleActive(event){
        let isActive = this.getAttribute('active');
        if(isActive == "true"){
            this.setAttribute('active', 'false');
        } else {
            // First, find any other tools in my parent
            // element and deactivate them.
            Array.from(this.parentElement.querySelectorAll('[role="tool"]'))
                .filter(el => {
                    return el.getAttribute('active') == 'true';
                })
                .forEach(el => {
                    el.setAttribute('active', 'false');
                });

            // Set this tool to be active
            this.setAttribute('active', 'true');
        }
    }
};

window.customElements.define('pencil-tool', PencilTool);




/***/ }),

/***/ "./js/objects/views/editors/Editor.js":
/*!********************************************!*\
  !*** ./js/objects/views/editors/Editor.js ***!
  \********************************************/
/*! exports provided: Editor, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Editor; });
/* harmony import */ var _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorTab.js */ "./js/objects/views/editors/EditorTab.js");
/* harmony import */ var _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditorPropList.js */ "./js/objects/views/editors/EditorPropList.js");
/* harmony import */ var _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditorMessenger.js */ "./js/objects/views/editors/EditorMessenger.js");
/* harmony import */ var _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditorCustomList.js */ "./js/objects/views/editors/EditorCustomList.js");
/* harmony import */ var _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditorSubpartsPane.js */ "./js/objects/views/editors/EditorSubpartsPane.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");






// PREAMBLE

// Add editor tab element
window.customElements.define('editor-tab', _EditorTab_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
window.customElements.define('editor-props-list', _EditorPropList_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
window.customElements.define('editor-custom-list', _EditorCustomList_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('editor-messenger', _EditorMessenger_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('editor-subparts', _EditorSubpartsPane_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

const closeButton = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#9e9e9e" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
</svg>
`;

const scriptIcon = `
<svg id='script' xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-file-code" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M14 3v4a1 1 0 0 0 1 1h4" />
    <path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" />
    <path d="M10 13l-1 2l1 2" />
    <path d="M14 13l1 2l-1 2" />
</svg>`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        position: absolute;
        transform: translateX(-105%);
        transition: transform 150ms linear;
        width: 400px;
        height: 100%;
        background-color: white;
        padding: 8px;
        border-right: 1px solid rgba(0, 0, 0, 0.5);
        box-shadow: 0px 1px 10px 2px rgba(0, 0, 0, 0.3);
    }
    
    :host(.open){
        transform: translateX(0%);
        transition: transform 150ms linear;
        z-index: 100;
    }

    :host(::after) {
        content: " ";
        height: 100%;
        width: 5px;
        background-color: black;
        display: block;
        position: absolute;
        top: 0;
        right: -10;
        box-shadow: 0px 0px 3px 10px rgba(100, 100, 100, 0.6);
    }

    ::slotted(editor-props-list:not(.show-pane)),
    ::slotted(editor-messenger:not(.show-pane)),
    ::slotted(editor-custom-list:not(.show-pane)),
    ::slotted(editor-subparts:not(.show-pane)){
        display: none;
    }

    #tab-area {
        display: inline-flex;
        align-items: center;
        justify-content: space-around;
        width: 100%;
    }
    
    #pane-area {
        display: block;
        flex: 1;
        margin-top: 20px;
        overflow: hidden;
    }

    #header-area {
        display: flex;
        font-family: 'Helvetica', sans-serif;
        margin-bottom: 20px;
    }

    .header-side {
        flex: 1;
        margin-top: 20px;
    }

    #display-area {
        display: flex;
        align-items: center;
        margin-bottom: 30px;
    }

    #header-area h3 {
        display: inline-block;
        margin: 0;
        margin-right: 8px;
        margin-left: 5px;
        font-size: 1.7rem;
    }

    #header-left > input {
        display: inline-block;
        padding: 4px;
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.8);
        font-size: 1.1rem;
    }

    #header-right > button {
        width: 100%;
        background-color: transparent;
        border: 1px solid transparent;
        outline: none;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        font-size: 0.85em;
    }

    #header-right > button:hover {
        cursor: pointer;
        border: 1px solid rgba(150, 150, 150, 0.3);
    }

    #header-right > button:active {
        border: 1px solid rgba(150, 150, 150, 0.8);
        background-color: rgba(220, 220, 220);
    }

    #header-right > button > svg {
        height: 1.3em;
        width: auto;
        margin-right: 8px;
    }

    #header-left {
        max-width: 80%;
    }

    #header-left span {
        font-family: monospace;
        font-size: 1.1rem;
        color: rgba(0, 0, 0, 0.5);
        text-overflow: ellipsis;
        overflow: hidden;
    }

    #icon-display-area {
        width: 1.7rem;
        height: 1.7rem;
        margin-bottom: 5px;
    }
    #icon-display-area > svg {
        width: 100%;
        height: 100%;
    }

    #close-button {
        display: block;
        position: absolute;
        top: 5;
        right: 5;
    }
    #close-button:hover {
        cursor: pointer;
    }
</style>
<div id="close-button">${closeButton}</div>
<div id="header-area">
    <div id="header-left" class="header-side">
        <div id="display-area">
            <div id="icon-display-area"></div>
            <h3></h3><span></span>
        </div>
        <input type="text" id="part-name-input"/>
    </div>
    <div id="header-right" class="header-side">
        <button id="edit-script-button">
            ${scriptIcon}
            <span>Edit Script</span>
        </button>
    </div>
</div>
<div id="tab-area">
    <editor-tab active="true" name="properties">Properties</editor-tab>
    <editor-tab name="custom">Custom</editor-tab>
    <editor-tab name="messenger">Messenger</editor-tab>
    <editor-tab name="subparts">Subparts</editor-tab>
</div>
<div id="pane-area">
    <slot></slot>
</div>
`;

class Editor extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.render = this.render.bind(this);
        this.centerOnElement = this.centerOnElement.bind(this);
        this.undoCenterOnElement = this.undoCenterOnElement.bind(this);
        this.updateHeader = this.updateHeader.bind(this);
        this.checkForNavigation = this.checkForNavigation.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.onTabActivated = this.onTabActivated.bind(this);
        this.onNameInputChange = this.onNameInputChange.bind(this);
        this.onEditScriptClick = this.onEditScriptClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this._shadowRoot.addEventListener('tab-activated', this.onTabActivated);
            this._shadowRoot.getElementById('close-button').addEventListener(
                'click',
                this.close
            );

            // Events
            let nameInput = this._shadowRoot.getElementById('part-name-input');
            nameInput.addEventListener('change', this.onNameInputChange);

            let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
            editScriptButton.addEventListener('click', this.onEditScriptClick);
        }
    }

    disconnectedCallback(){
        this._shadowRoot.removeEventListener('tab-activated', this.onTabActivated);
        this._shadowRoot.getElementById('close-button').removeEventListener(
            'click',
            this.close
        );
        
        // Events
        let nameInput = this._shadowRoot.getElementById('part-name-input');
        nameInput.removeEventListener('change', this.onNameInputChange);

        let editScriptButton = this._shadowRoot.getElementById('edit-script-button');
        editScriptButton.removeEventListener('click', this.onEditScriptClick);
    }

    toggle(){
        if(this.isOpen){
            this.close();
        } else {
            this.open();
        }
    }

    open(){
        this.classList.add('open');
        this.centerOnElement();
    }

    close(){
        this.classList.remove('open');
        this.undoCenterOnElement();
    }

    render(aModel){
        if(this.model){
            this.model.removePropertySubscriber(this);
        }
        this.model = aModel;
        this.model.addPropertySubscriber(this);

        // If the incoming model is a Card or
        // Stack that is not the current one,
        // we navigate to it
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.checkForNavigation();
        }

        // Close any open Halos.
        // If the new model wants a Halo,
        // open it on the View for that Model.
        Array.from(document.querySelectorAll(`.editing`)).forEach(el => {
            el.closeHalo();
        });
        let targetView = document.querySelector(`[part-id="${this.model.id}"]`);
        if(targetView && targetView.wantsHalo){
            targetView.openHalo();
        }
        
        this.updateHeader();

        // Clear slotted inner DOM
        this.innerHTML = "";

        // Add panes
        let propsPane = document.createElement('editor-props-list');
        propsPane.setAttribute('tab-name', 'properties');
        this.appendChild(propsPane);
        propsPane.render(this.model);

        let messengerPane = document.createElement('editor-messenger');
        messengerPane.setAttribute('tab-name', 'messenger');
        this.appendChild(messengerPane);
        messengerPane.render(this.model);

        let customPane = document.createElement('editor-custom-list');
        customPane.setAttribute('tab-name', 'custom');
        this.appendChild(customPane);
        customPane.render(this.model);

        let subpartsPane = document.createElement('editor-subparts');
        subpartsPane.setAttribute('tab-name', 'subparts');
        this.appendChild(subpartsPane);
        subpartsPane.render(this.model);

        // Find the active tab and show its corresponding pane
        let activeTab = this._shadowRoot.querySelector(`editor-tab[active="true"]`);
        if(activeTab){
            let activeName = activeTab.getAttribute('name');
            Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
                let name = pane.getAttribute('tab-name');
                if(name == activeName){
                    pane.classList.add('show-pane');
                } else {
                    pane.classList.remove('show-pane');
                }
            });
        }

        // If this pane is already open, then center
        // on the primary view element for the model
        if(this.isOpen){
            this.centerOnElement();
        }
    }

    centerOnElement(){
        // Use CSS transforms of the whole World to center on
        // the primary view element of the Part being edited,
        // if set. If not set, do nothing.
        if(this.model){
            // If we are editing a Card, Stack, or World, then
            // we uncenter and return
            let isCardStackOrWorld = ['card', 'stack', 'world'].includes(this.model.type);
            if(isCardStackOrWorld){
                return this.undoCenterOnElement();
            }
            
            let partView = window.System.findViewById(this.model.id);
            let worldView = window.System.findViewById('world');
            let current = worldView.getAttribute('centered-on');
            if(current == this.model.id.toString()){
                return;
            }

            let menuRect = this.getBoundingClientRect();
            let partRect = partView.getBoundingClientRect();

            // Get the actual viewable width, plus the editor menu
            let viewWidth = window.innerWidth + menuRect.width;
            let viewHeight = window.innerWidth - menuRect.height;

            // Calculate X translation
            let targetX = (viewWidth - partRect.width) / 2;
            let newX;
            if(targetX < partRect.left){
                newX = (partRect.left - targetX) * -1;
            } else {
                newX = targetX - partRect.left;
            }

            // Calculate Y translation
            let targetY = (viewHeight - partRect.height) / 2;
            let newY;
            if(targetY < partRect.top){
                newY = (partRect.top - targetY) * -1;
            } else {
                newY = targetY - partRect.top;
            }

            worldView.setAttribute('centered-on', this.model.id);
            
            // Set transform and transition
            worldView.style.transition = "transform 0.3s ease-out";
            worldView.style.transform = `translate(${newX}px, ${newY}px)`;
        }
    }

    undoCenterOnElement(){
        let worldView = window.System.findViewById('world');
        worldView.removeAttribute('centered-on');
        worldView.style.removeProperty('transform');
    }

    updateHeader(){
        let nameInput = this._shadowRoot.querySelector('#header-left > input');
        let typeDisplay = this._shadowRoot.querySelector('#display-area > h3');
        let idDisplay = this._shadowRoot.querySelector('#display-area > span');
        let iconDisplay = this._shadowRoot.getElementById('icon-display-area');

        let partName = this.model.partProperties.getPropertyNamed(
            this.model,
            'name'
        );

        if(partName && partName !== ""){
            nameInput.value = partName;
        } else {
            nameInput.value = "(Unnamed)";
        }

        typeDisplay.textContent = this.model.type.charAt(0).toUpperCase() + this.model.type.slice(1);
        idDisplay.textContent = `id=${this.model.id}`;
        idDisplay.title = this.model.id;

        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"]).includes(this.model.type)){
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"][this.model.type];
        } else {
            iconDisplay.innerHTML = _utils_icons_js__WEBPACK_IMPORTED_MODULE_5__["default"].generic;
        }
    }

    checkForNavigation(){
        // If the model is a Card or Stack that
        // is not the current (ie, not being displayed
        // in the main window), then we should navigate
        // to it
        let currentStack = window.System.world.currentStack;
        let currentCard = currentStack.currentCard;
        if(this.model.type == 'card' && this.model.id != currentCard.id){
            currentStack.goToCardById(this.model.id);
        } else if(this.model.type == 'stack' && this.model.id != currentStack.id){
            window.System.world.goToStackById(this.model.id);
        }
        
    }

    receiveMessage(aMessage){
        switch(aMessage.type){
        case 'propertyChanged':
            // Find any nested editor-prop-item elements
            // and re-render, so they display the correct
            // values in the editor
            let queryString = `editor-prop-item[name="${aMessage.propertyName}"][owner-id="${aMessage.partId}"]`;
            Array.from(this.querySelectorAll(queryString)).forEach(el => {
                if(el.property.value !== aMessage.value){
                    el.render();
                }
            });
            break;
        }
    }

    onTabActivated(event){
        Array.from(this._shadowRoot.querySelectorAll('editor-tab'))
            .filter(tabEl => {
                return tabEl !== event.target;
            }).forEach(tabEl => {
                tabEl.removeAttribute('active');
            });

        // Get the name of the activated tab
        let targetName = event.target.getAttribute('name');
        Array.from(this.querySelectorAll('[tab-name]')).forEach(pane => {
            let name = pane.getAttribute('tab-name');
            if(name == targetName){
                pane.classList.add('show-pane');
            } else {
                pane.classList.remove('show-pane');
            }
        });
    }

    onNameInputChange(event){
        if(this.model){
            let newName = event.target.value;
            this.model.partProperties.setPropertyNamed(
                this.model,
                'name',
                newName
            );
        }
    }

    onEditScriptClick(event){
        if(this.model){
            this.model.sendMessage({
                type: 'command',
                commandName: 'openScriptEditor',
                args: [
                    this.model.id
                ]
            }, this.model);
            this.close();
        }
    }

    get isOpen(){
        return this.classList.contains('open');
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorCustomList.js":
/*!******************************************************!*\
  !*** ./js/objects/views/editors/EditorCustomList.js ***!
  \******************************************************/
/*! exports provided: EditorCustomList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorCustomList", function() { return EditorCustomList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorCustomList; });


// PREAMBLE

const caretDownIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(180 12 12)" />
</svg>
`;

const caretRightIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-caret-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M18 15l-6 -6l-6 6h12" transform="rotate(90 12 12)" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
    
    #new-prop-area {
        display: flex;
        flex-direction: column;
        width: 100%;
    }

    #new-prop-area.open > #new-prop-form {
        display:flex;
    }

    #new-prop-form {
        display: none;
        flex-direction: column;
        width: 100%;
    }

    .row {
        display: flex;
        flex-direction: row;
        width: 100%;
        align-items: center;
        margin-bottom: 1em;
    }

    h3 {
        padding: 0px;
        margin-bottom: 1em;
    }

    #new-prop-form > .row > * {
        margin-right: 16px;
        padding-left: 8px;
        padding-right: 8px;
    }
    #new-prop-form input {
        outline: none;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.7);
        font-family: monospace;
        padding: 6px;
    }

    #new-prop-name:invalid {
        border-bottom: 1px solid red;
    }
    
    select {
        font-size: 1em;
    }
    #add-prop-dropdown-control {
        align-items: center;
        user-select: none;
    }

    #add-prop-dropdown-control:hover,
    #add-prop-dropdown-control label {
        cursor: pointer;
    }

    #caret-button {
        position: relative;
        width: 1.5em;
        height: 1.5em;
        transform: rotate(0deg);
        transition: transform 0.1s linear;
    }

    #caret-button > svg {
        width: 100%;
        height: 100%;
    }
    #new-prop-area.open #caret-button {
        transform: rotate(90deg);
        transition: transform 0.1s linear;
    }

</style>
<div id="new-prop-area">
    <div class="row" id="add-prop-dropdown-control">
        <h3><label for="caret-button">Add New Property</label></h3>
        <div id="caret-button">${caretRightIcon}</div>
    </div>
    <div id="new-prop-form">
        <div class="row">
            <label for="new-prop-name">Property Name </label>
            <input type="text" id="new-prop-name" placeholder="property-name" pattern="[a-z\\-]{3,64}"/>
        </div>
        <div class="row">
            <label for="default-val-select">Default value type</label>
            <select id="default-val-select">
                <option value="" selected>None</option>
                <option value="string">Text</option>
                <option value="number">Number</option>
                <option value="boolean">True or False</option>
            </select>
        </div>
        <div class="row">
            <label for="default-value">Default value </label>
            <input type="text" id="default-value" placeholder="Default value" disabled/>
        </div>
        <div class="row" id="submit-control">
            <button id="submit-prop">Create</button>
        </div>
    </div>
</div>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

class EditorCustomList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.resetForm = this.resetForm.bind(this);
        this.onDefaultNewTypeChange = this.onDefaultNewTypeChange.bind(this);
        this.onCaretClick = this.onCaretClick.bind(this);
        this.onCreateSubmit = this.onCreateSubmit.bind(this);
        this.onFilterInput = this.onFilterInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.newPropTypeSelect = this._shadowRoot.getElementById('default-val-select');
            this.newPropNameInput = this._shadowRoot.getElementById('new-prop-name');
            this.newPropDefaultValue = this._shadowRoot.getElementById('default-value');
            this.addPropControl = this._shadowRoot.getElementById('add-prop-dropdown-control');
            this.newPropForm = this._shadowRoot.getElementById('new-prop-form');
            this.createButton = this._shadowRoot.getElementById('submit-prop');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.filterInput = this._shadowRoot.getElementById('filter-input');
            
            // Add listeners
            this.addPropControl.addEventListener('click', this.onCaretClick);
            this.createButton.addEventListener('click', this.onCreateSubmit);
            this.filterInput.addEventListener('input', this.onFilterInput);
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any main dom children
        this.innerHTML = "";

        // Create a sorted copy of the property
        // objects
        let customProps = this.model.partProperties.getPropertyNamed(
            this.model,
            'custom-properties'
        );

        // Create a sorted list of the custom properties
        // available
        this.propList = Object.values(customProps)
            .sort((first, second) => {
                return first.name.localeCompare(second.name);
            });

        // Render the property items and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });

        // Set up event listeners
        this.newPropTypeSelect.removeEventListener('change', this.onDefaultNewTypeChange);
        this.newPropTypeSelect.addEventListener('change', this.onDefaultNewTypeChange);
    }

    onDefaultNewTypeChange(event){
        let option = event.target.selectedOptions[0];
        switch(option.value){
        case 'string':
            this.newPropDefaultValue.setAttribute('type', 'text');
            this.newPropDefaultValue.setAttribute('value', "");
            break;
        case 'number':
            this.newPropDefaultValue.setAttribute('type', 'number');
            this.newPropDefaultValue.setAttribute('value', 0);
            break;
        case 'boolean':
            this.newPropDefaultValue.setAttribute('type', 'checkbox');
            break;
        default:
            this.newPropDefaultValue.setAttribute('type', 'text');
        }

        if(option.value == ""){
            this.newPropDefaultValue.setAttribute('disabled', true);
        } else {
            this.newPropDefaultValue.removeAttribute('disabled');
        }
    }

    onCaretClick(event){
        let newPropArea = this._shadowRoot.getElementById('new-prop-area');
        newPropArea.classList.toggle('open');
    }

    onCreateSubmit(event){
        if(this.model){
            let propName = this.newPropNameInput.value;
            let defaultValue = this.newPropDefaultValue.value;
            if(this.newPropDefaultValue.type == 'checkbox'){
                defaultValue = this.newPropDefaultValue.checked;
            } else if(this.newPropDefaultValue.type == 'number'){
                defaultValue = parseFloat(this.newPropDefaultValue.value);
            }

            // Send the property create message
            this.model.sendMessage({
                type: 'command',
                commandName: 'newProperty',
                args: [
                    propName,
                    this.model.id
                ]
            }, this.model);

            // Set the created prop to the default
            // value
            this.model.partProperties.setPropertyNamed(
                this.model,
                propName,
                defaultValue
            );

            // Re-render this pane
            this.resetForm();
            this.render(this.model);
        }
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onFilterInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInput.value = "";
        this.filterBy("");
    }

    resetForm(){
        this.newPropNameInput.value = null;
        this.newPropDefaultValue.value = null;
        if(this.newPropDefaultValue.type == 'checked'){
            this.newPropDefaultValue.checked = false;
        }
        this.newPropDefaultValue.type = 'text';
        this.newPropDefaultValue.setAttribute('disabled', true);
        this.newPropTypeSelect.selectedIndex = 0;
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorLocationInfo.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorLocationInfo.js ***!
  \********************************************************/
/*! exports provided: EditorLocationInfo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorLocationInfo", function() { return EditorLocationInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorLocationInfo; });
/* harmony import */ var _ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ohm/interpreter-semantics.js */ "./js/ohm/interpreter-semantics.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");



// PREAMBLE
const arrowLeftIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrow-narrow-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12" />
  <line x1="5" y1="12" x2="9" y2="16" />
  <line x1="5" y1="12" x2="9" y2="8" />
</svg>
`;

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host(.hidden){
        display: none;
    }
    .button-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .button-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .button-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .button-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
</style>
<p class="part-info">
    My <button id="owner-link" class="button-link" title=""><span></span>${arrowLeftIcon}</button> is named <span class="part-name"></span> and is located at <button id="location-link" class="button-link" title="Copy location"><span></span>${clipboardIcon}</button> <button id="id-link" class="button-link" title="Copy id"><span>Copy id</span>${clipboardIcon}</button>
</p>
`;

class EditorLocationInfo extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Accepted values for the kind attribute
        this.allowedKinds = ['stack', 'card', 'owner'];

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_1__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.handleStackKind = this.handleStackKind.bind(this);
        this.handleCardKind = this.handleCardKind.bind(this);
        this.updateInfo = this.updateInfo.bind(this);
        this.getAncestorOfTypeFor = this.getAncestorOfTypeFor.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
        this.onLinkClick = this.onLinkClick.bind(this);
        this.onMouseEnter = this.onMouseEnter.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
    }

    connectedCallback(){
        // Events
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        ownerLinkButton.addEventListener('click', this.onLinkClick);
        locationLinkButton.addEventListener('click', this.onLocationClick);
        idLinkButton.addEventListener('click', this.onLocationClick);
        locationLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.addEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.addEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.addEventListener('mouseleave', this.onMouseLeave);
    }

    disconnectedCallback(){
        let ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        let locationLinkButton = this._shadowRoot.getElementById('location-link');
        let idLinkButton = this._shadowRoot.getElementById('id-link');
        locationLinkButton.removeEventListener('click', this.onLocationClick);
        idLinkButton.removeEventListener('click', this.onLocationClick);
        ownerLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        idLinkButton.removeEventListener('mouseenter', this.onMouseEnter);
        locationLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
        idLinkButton.removeEventListener('mouseleave', this.onMouseLeave);
    }

    render(aModel){
        this.model = aModel;
        let kind = this.getAttribute('kind');
        if(!kind || !this.allowedKinds.includes(kind)){
            this.classList.add('hidden');
            return;
        }
        if(this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }

        this.classList.remove('hidden');

        // Update element references
        this.ownerLinkButton = this._shadowRoot.getElementById('owner-link');
        this.ownerLinkTypeSpan = this.ownerLinkButton.querySelector('span');
        this.locationLinkButton = this._shadowRoot.getElementById('location-link');
        this.locationLinkSpan = this.locationLinkButton.querySelector('span');
        this.idLinkButton = this._shadowRoot.getElementById('id-link');
        this.idLinkSpan = this.idLinkButton.querySelector('span');
        this.nameSpan = this._shadowRoot.querySelector('p .part-name');

        if(kind == 'stack'){
            this.handleStackKind();
        } else if(kind =='card'){
            this.handleCardKind();
        } else {
            this.updateInfo();
        }
    }

    updateInfo(){
        let kind = this.getAttribute('kind');
        let ancestor = this.model._owner;
        if(kind == 'stack' || kind == 'card'){
            ancestor = this.getAncestorOfTypeFor(this.model, kind);
        }

        // If we cannot find an ancestor of the given
        // kind, then we hide this field
        if(!ancestor){
            this.classList.add('hidden');
            return;
        }

        // Update name span
        let ancestorName = ancestor.partProperties.getPropertyNamed(
            ancestor,
            'name'
        );
        if(!ancestorName){
            ancestorName = '(unnamed)';
        } else {
            ancestorName = `"${ancestorName}"`;
        }
        this.nameSpan.textContent = ancestorName;

        // Update kind span
        let kindLabel = kind[0].toUpperCase() + kind.slice(1);
        this.ownerLinkTypeSpan.textContent = kindLabel;

        // Update location link span
        this.locationLinkSpan.textContent = this.getLocationStringFor(ancestor);

        // Update button titles
        let editTitle = `Edit owning ${kindLabel}`;
        if(kind == 'owner'){
            editTitle = 'Edit Owner';
        }
        this.ownerLinkButton.setAttribute(
            'title',
            editTitle
        );

        // Add the ref-id attribute
        this.setAttribute('ref-id', ancestor.id);
    }

    handleStackKind(){
        if(this.model.type == 'stack' || this.model.type == 'world'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    handleCardKind(){
        if(this.model.type == 'card' || this.model.type == 'stack'){
            this.classList.add('hidden');
            return;
        }
        this.updateInfo();
    }

    getAncestorOfTypeFor(aPart, aType){
        let result;
        let currentOwner = aPart._owner;
        while(currentOwner){
            if(currentOwner.type == aType){
                result = currentOwner;
                break;
            }
            currentOwner = currentOwner._owner;
        }
        return result;
    }

    onLinkClick(event){
        let id = this.getAttribute('ref-id');
        if(id && this.model){
            // Re-render the editor on the Part
            // referenced by the found id
            let target = window.System.partsById[id];
            window.System.editor.render(target);
        }
    }

    onMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    getLocationViews(event){
        let targetId;
        let span = event.currentTarget.querySelector('span');
        if(span.parentElement.id == 'id-link'){
            targetId = this.getAttribute('ref-id');
        } else {
            let semantics = window.System.grammar.createSemantics();
            semantics.addOperation(
                'interpret',
                Object(_ohm_interpreter_semantics_js__WEBPACK_IMPORTED_MODULE_0__["default"])(window.System.partsById['world'], window.System)
            );
            let m = window.System.grammar.match(span.textContent, "ObjectSpecifier");
            try{
                targetId = semantics(m).interpret();
            } catch(e){
                console.log(`cannot locate ${span.textContent}`);
            }
        }
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorMessenger.js":
/*!*****************************************************!*\
  !*** ./js/objects/views/editors/EditorMessenger.js ***!
  \*****************************************************/
/*! exports provided: EditorMessenger, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorMessenger", function() { return EditorMessenger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorMessenger; });


// PREAMBLE
const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }
   
    textarea {
        resize: none;
        flex: 0.25;
    }
</style>
<h3>Send this <span></span> a Message:</h3>
<textarea placeholder="Type your Simpletalk message here..."></textarea>
<button>Send</button>
`;

class EditorMessenger extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onMessageFieldInput = this.onMessageFieldInput.bind(this);
        this.sendMessageFromText = this.sendMessageFromText.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.sendButton = this._shadowRoot.querySelector('button');
            this.sendButton.addEventListener('click', this.sendMessageFromText);
        
            this.messageField = this._shadowRoot.querySelector('textarea');
            this.messageField.addEventListener('input', this.onMessageFieldInput);
        }
    }

    disconnectedCallback(){
        this.messageField.removeEventListener('input', this.onMessageFieldInput);
        this.sendButton.removeEventListener('click', this.sendMessageFromText);
    }

    render(aModel){
        this.model = aModel;
        
        let partTypeLabel = this._shadowRoot.querySelector('h3 > span');
        partTypeLabel.textContent = this.model.type;
    }

    onMessageFieldInput(event){

    }

    sendMessageFromText(){
        let text = this.messageField.value;
        let script = `on doIt\n\t${text}\nend doIt`;
        this.model.sendMessage({
            type: 'compile',
            codeString: script,
            targetId: this.model.id
        }, this.model);
        this.model.sendMessage({
            type: 'command',
            commandName: 'doIt',
            args: [],
            shouldIgnore: true
        }, this.model);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropItem.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropItem.js ***!
  \****************************************************/
/*! exports provided: EditorPropItem, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropItem", function() { return EditorPropItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropItem; });
// PREAMBLE

const checkIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#00b341" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M9 12l2 2l4 -4" />
</svg>
`;

const cancelIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#ff2825" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M10 10l4 4m0 -4l-4 4" />
</svg>
`;

const templateString = `
<style>
    li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px;
        padding-left: 8px;
        padding-right: 8px;
        margin-top: 6px;
    }
   
    li > label {
        flex: 1;
    }

    :host {
        width: 100%;
    }

    :host(.item-hidden) {
        display:none;
    }

    button {
        outline: none;
        border: 1px solid transparent;
        background-color: transparent;
        opacity: 1.0;
        transition: opacity 0.1s linear;
    }

    button:disabled {
        opacity: 0.05;
        transition: opacity: 0.1s linear;
    }

    button:hover {
        cursor: pointer;
    }

    button.button-hidden {
        display: none;
    }

    label {
        font-family: monospace;
    }

    input {
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(100, 100, 100, 0.5);
        outline: none;
    }
    
    input:focus {
        border: 1px solid rgba(100, 100, 100, 0.8);
    }
</style>
<li>
    <label for="prop-value"></label>
    <input id="prop-value" name="prop-value"/>
    <button id="accept" disabled>${checkIcon}</button>
    <button id="cancel" disabled>${cancelIcon}</button>
</li>
`;

class EditorPropItem extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // By default, there is no property
        this.property = null;
        this.owner = null;

        // Bound methods
        this.render = this.render.bind(this);
        this.onInputChange = this.onInputChange.bind(this);
        this.onInputInput = this.onInputInput.bind(this);
        this.onAcceptClick = this.onAcceptClick.bind(this);
        this.onCancelClick = this.onCancelClick.bind(this);
        this.onEnterKey = this.onEnterKey.bind(this);
        this.setupNumericInput = this.setupNumericInput.bind(this);
        this.enableButtons = this.enableButtons.bind(this);
        this.disableButtons = this.disableButtons.bind(this);
    }

    setProperty(aProperty, anOwner){
        // Remove any existing event handlers
        // TODO
        this.property = aProperty;
        this.owner = anOwner;

        // Update the element attributes
        this.setAttribute('name', this.property.name);
        this.setAttribute('owner-id', this.owner.id);

        // Add new event handlers

        // Render
        this.render();
        
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('keypress', this.onEnterKey);
        }
    }

    disconnectedCallback(){
        this.removeEventListener('keypress', this.onEnterKey);
    }

    render(){
        this.labelElement = this._shadowRoot.querySelector('label');
        this.inputElement = this._shadowRoot.querySelector('input');
        this.acceptButton = this._shadowRoot.getElementById('accept');
        this.cancelButton = this._shadowRoot.getElementById('cancel');

        // Remove any hide classes
        this.acceptButton.classList.remove('button-hidden');
        this.cancelButton.classList.remove('button-hidden');
        
        // Remove any bound events
        this.inputElement.removeEventListener('input', this.onInputInput);
        this.inputElement.removeEventListener('change', this.onInputChange);
        this.acceptButton.removeEventListener('click', this.onAcceptClick);
        this.cancelButton.removeEventListener('click', this.onCancelClick);

        // Add new events
        this.inputElement.addEventListener('input', this.onInputInput);
        this.inputElement.addEventListener('change', this.onInputChange);
        this.acceptButton.addEventListener('click', this.onAcceptClick);
        this.cancelButton.addEventListener('click', this.onCancelClick);
        
        this.labelElement.textContent = `${this.property.name}:`;
        let currentVal = this.property.getValue(this.owner);
        if(currentVal == null || currentVal == undefined){
            // Do something different here
        } else if(typeof(currentVal) == 'number'){
            this.setupNumericInput();
        } else if(typeof(currentVal) == 'boolean'){
            this.inputElement.setAttribute('type', 'checkbox');
            this.inputElement.checked = currentVal;
            this.acceptButton.classList.add('button-hidden');
            this.cancelButton.classList.add('button-hidden');
        } else {
            this.inputElement.setAttribute('type', 'text');
        }

        this.inputElement.setAttribute('placeholder', currentVal);
        this.inputElement.value = currentVal;
    }

    setupNumericInput(){
        if(this.property.name.endsWith('-transparency')){
            this.inputElement.setAttribute('type', 'range');
            this.inputElement.setAttribute('step', '0.05');
            this.inputElement.setAttribute('min', '0.0');
            this.inputElement.setAttribute('max', '1.0');
        } else {
            this.inputElement.setAttribute('type', 'number');
        }
    }

    onInputChange(event){
        if(event.target.type == "checkbox"){
            this.owner.partProperties.setPropertyNamed(
                this.owner,
                this.property.name,
                event.target.checked
            );
        }
    }

    onInputInput(event){
        let inputType = event.target.getAttribute('type');
        if(inputType == 'range'){
            return this.onAcceptClick();
        }
        if(event.target.value !== this.property.getValue(this.owner)){
            this.enableButtons();
        } else {
            this.disableButtons();
        }
    }

    onEnterKey(event){
        if(event.key == 'Enter'){
            this.onAcceptClick();
        }
    }

    enableButtons(){
        this.acceptButton.removeAttribute('disabled');
        this.cancelButton.removeAttribute('disabled');
    }

    disableButtons(){
        this.acceptButton.setAttribute('disabled', true);
        this.cancelButton.setAttribute('disabled', true);
    }

    onAcceptClick(event){
        let value = this.inputElement.value;
        if(this.inputElement.type == 'number'){
            value = parseFloat(value);
            if(isNaN(value)){
                // if we can't parse the value just let it go through
                // as it might be a prop style keyword such as "fill"
                // TODO: we might want to limit this to a set of prop keywords
                value = this.inputElement.value;
            }
        } else if(this.inputElement.type == 'range'){
            value = parseFloat(value);
        } else if(this.inputElement.type == 'checkbox'){
            value = this.inputElement.checked;
        }
        this.owner.partProperties.setPropertyNamed(
            this.owner,
            this.property.name,
            value
        );
        this.disableButtons();
    }

    onCancelClick(event){
        this.inputElement.value = this.owner.partProperties.getPropertyNamed(
            this.owner,
            this.property.name
        );
        this.disableButtons();
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorPropList.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/EditorPropList.js ***!
  \****************************************************/
/*! exports provided: EditorPropList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorPropList", function() { return EditorPropList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorPropList; });
/* harmony import */ var _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorPropItem.js */ "./js/objects/views/editors/EditorPropItem.js");


// PREAMBLE
window.customElements.define('editor-prop-item', _EditorPropItem_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    #props-list {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
    }
    #filter-area {
        display: flex;
        width: 100%;
        align-items: center;
    }
    #filter-area > input {
        min-width: 0;
        width: auto;
        flex: 1;
        outline: none;
        font-size: 1.0rem;
        padding-left: 6px;
        padding-right: 6px;
        padding-top: 3px;
        padding-bottom: 3px;
        border: 1px solid rgba(100, 100, 100, 0.8);
        border-radius: 2px;
    }
</style>
<div id="filter-area">
    <input type="text" id="filter-input" name="filter-input" placeholder="Filter..."/>
    <button id="clear">Clear</button>
</div>
<ul id="props-list">
    <slot></slot>
</ul>
`;

const specialProps = [
    'cssStyle',
    'cssTextStyle',
    'id',
    'name',
    'target',
    'events',
    'current',
    'script',
    'custom-properties'
];

class EditorPropList extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.render = this.render.bind(this);
        this.onInput = this.onInput.bind(this);
        this.onFilterClearClick = this.onFilterClearClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.filterInputElement = this._shadowRoot.getElementById('filter-input');
            this.clearButton = this._shadowRoot.getElementById('clear');
            this.clearButton.addEventListener('click', this.onFilterClearClick);
        }
    }

    render(aModel){
        this.model = aModel;

        // Clear any existing main DOM children
        this.innerHTML = "";
        let inputEl = this._shadowRoot.getElementById('filter-input');
        inputEl.removeEventListener('input', this.onInput);
        inputEl.addEventListener('input', this.onInput);

        // Create a sorted copy of the property objects
        this.propList = this.model.partProperties.all.slice().filter(prop => {
                return !specialProps.includes(prop.name);
            });
        this.propList
            .sort((first, second) => {
            return first.name.localeCompare(second.name);
        });

        // Render the list item elements and insert them
        this.propList.forEach(propObject => {
            let el = document.createElement('editor-prop-item');
            el.setProperty(propObject, this.model);
            el.setAttribute('name', propObject.name);
            this.appendChild(el);
        });
    }

    filterBy(text){
        // Find all of the prop item elements whose
        // property name does *not* include the substring,
        // and set those to not display
        let allElements = Array.from(this.querySelectorAll('editor-prop-item'));
        allElements.forEach(propEl => {
            let name = propEl.getAttribute('name');
            if(name.toLowerCase().includes(text)){
                propEl.classList.remove('item-hidden');
            } else {
                propEl.classList.add('item-hidden');
            }
        });
    }

    onInput(event){
        this.filterBy(event.target.value.toLowerCase());
    }

    onFilterClearClick(event){
        this.filterInputElement.value = "";
        this.filterBy("");
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorSubpartsPane.js":
/*!********************************************************!*\
  !*** ./js/objects/views/editors/EditorSubpartsPane.js ***!
  \********************************************************/
/*! exports provided: EditorSubpartsPane, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorSubpartsPane", function() { return EditorSubpartsPane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorSubpartsPane; });
/* harmony import */ var _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorLocationInfo.js */ "./js/objects/views/editors/EditorLocationInfo.js");
/* harmony import */ var _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/icons.js */ "./js/objects/utils/icons.js");
/* harmony import */ var _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/subparts.js */ "./js/objects/views/editors/utils/subparts.js");
// PREAMBLE




window.customElements.define('editor-location-info', _EditorLocationInfo_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

const clipboardIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clipboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
  <rect x="9" y="3" width="6" height="4" rx="2" />
</svg>
`;

const templateString = `
<style>
    :host {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Helvetica', sans-serif;
        font-size: 0.8rem;
    }

    :host() > li {
        background-color: red;
    }

    .id-link,
    .location-link {
        display: inline-flex;
        align-items: center;
        outline: none;
        border: none;
        border-bottom: 1px solid rgba(150, 150, 150, 0.3);
        transition: border 0.2s ease-out;
        vertical-alignment: center;
        background-color: transparent;
        padding: 0px;
        font-size: 1em;
    }

    .id-link:hover,
    .location-link:hover {
        cursor: pointer;
        border-bottom: 1px solid rgba(150, 150, 150, 0.7);
        transition: border 0.2s ease-out;
    }

    .id-link > svg,
    .location-link > svg {
        margin-left: 8px;
        opacity: 0.7;
        transform: translateX(0px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    .id-link:hover > svg,
    .location-link:hover > svg {
        opacity: 1.0;
        transform: translateX(-5px);
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }

    section {
        display: flex;
        flex-direction: column;
        margin: 6px;
    }

    #button-area {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;'
    }

    #subparts-list-wrapper {
        flex: 1;
        overflow-y: hidden;
    }

    .hidden {
        display: none;
    }

    #subparts-area {
        flex: 1;
        list-style: none;
        font-family: 'Helvetica', sans-serif;
        padding: 0;
        margin: 0;
        margin-left: 32px;
        overflow-y: auto;
    }
</style>
<section id="button-area">
    <slot name="button"></slot>
</section>
<section id="location-area">
    <h3>Part Location and Owners</h3>
    <p class="part-info">
        I am located at <button class="location-link"><span></span>${clipboardIcon}</button>
        and my id is <button class="id-link"><span></span>${clipboardIcon}</button>
    </p>
    <slot name="ancestor-info"></slot>
</section>
<section id="subparts-list-wrapper">
    <h3>Subparts</h3>
    <ol id="subparts-area">
        <slot></slot>
    </ol>
</section>
`;

class EditorSubpartsPane extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // define and bind methods
        this.getLocationStringFor = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["getLocationStringFor"].bind(this);
        this.onLocationLinkClick = _utils_subparts_js__WEBPACK_IMPORTED_MODULE_2__["onLocationLinkClick"].bind(this);

        // Bound methods
        this.onAddSubpart = this.onAddSubpart.bind(this);
        this.onSubpartItemClick = this.onSubpartItemClick.bind(this);
        this.onSubpartItemMouseEnter = this.onSubpartItemMouseEnter.bind(this);
        this.onSubpartItemMouseLeave = this.onSubpartItemMouseLeave.bind(this);
        this.createAddPartButton = this.createAddPartButton.bind(this);
        this.createSubpartComponent = this.createSubpartComponent.bind(this);
        this.getLocationViews = this.getLocationViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.headerEl = this._shadowRoot.getElementById('location-area');
            this.myLocationArea = this.headerEl.querySelector('p');
            this.myLocationButton = this.myLocationArea.querySelector('.location-link');
            this.myIdButton = this.myLocationArea.querySelector('.id-link');

            // Add event listener to buttons
            this.myLocationButton.addEventListener('click', this.onLocationLinkClick);
            this.myIdButton.addEventListener('click', this.onLocationLinkClick);
        }
    }

    disconnectedCallback(){
        this.myLocationButton.removeEventListener('click', this.onLocationLinkClick);
        this.myIdButton.removeEventListener('click', this.onLocationLinkClick);
    }

    render(aModel){
        this.model = aModel;
        this.headerEl = this._shadowRoot.getElementById('location-area');

        // Clear any DOM children
        this.innerHTML = "";


        // Create location link elements
        // and also the self-location element
        let myLocationText = this.getLocationStringFor(this.model);
        this.myLocationButton.querySelector('span').textContent = myLocationText;
        this.myIdButton.querySelector('span').textContent = this.model.id.toString();
        if(this.model.type == 'world'){
            this.headerEl.classList.add('hidden');
        } else {
            this.headerEl.classList.remove('hidden');

            // Create the info elements
            ['stack', 'card', 'owner'].forEach(kind => {
                let infoEl = document.createElement('editor-location-info');
                infoEl.setAttribute('slot', 'ancestor-info');
                infoEl.setAttribute('kind', kind);
                infoEl.render(this.model);
                this.appendChild(infoEl);
            });
        }

        // Create the "add subpart" buttons for parts that are accepted by the
        // current Model part.
        this.model.acceptedSubpartTypes.forEach(partType => {
            let element = this.createAddPartButton(partType);
            this.appendChild(element);
        });

        let labelHeader = this._shadowRoot.querySelector('#subparts-list-wrapper > h3');
        if(this.model.subparts.length){
            labelHeader.textContent = "Current Subparts";
        } else {
            labelHeader.textContent = "There are no subparts";
        }

        this.model.subparts.forEach(subpart => {
            let element = this.createSubpartComponent(subpart);
            this.appendChild(element);
        });
    }

    createSubpartComponent(aPart){
        let wrapper = document.createElement('li');
        wrapper.classList.add('subpart-item');
        wrapper.setAttribute('ref-id', aPart.id);
        wrapper.addEventListener('click', this.onSubpartItemClick);
        wrapper.addEventListener('mouseenter', this.onSubpartItemMouseEnter);
        wrapper.addEventListener('mouseleave', this.onSubpartItemMouseLeave);

        // Add icon area an SVG for Part
        let iconArea = document.createElement('div');
        iconArea.classList.add('icon-display-area');
        let iconImage;
        if(Object.keys(_utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"]).includes(aPart.type)){
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPart.type];
        } else {
            iconImage = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        iconArea.innerHTML = iconImage;
        wrapper.append(iconArea);

        // Add label, name, and id info
        let labelArea = document.createElement('h3');
        labelArea.textContent = `a ${aPart.type[0].toUpperCase()}${aPart.type.slice(1)}`;
        wrapper.append(labelArea);
        let name = aPart.partProperties.getPropertyNamed(
            aPart,
            'name'
        );
        if(name && name != ""){
            let nameArea = document.createElement('span');
            nameArea.classList.add('name-span');
            nameArea.textContent = `"${name}"`;
            wrapper.append(nameArea);
        }

        let idArea = document.createElement('span');
        idArea.classList.add('id-span');
        idArea.textContent = `(${aPart.id})`;
        wrapper.append(idArea);

        return wrapper;
    }

    createAddPartButton(aPartName){
        let button = document.createElement('button');
        let icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"][aPartName];
        if(!icon){
            icon = _utils_icons_js__WEBPACK_IMPORTED_MODULE_1__["default"].generic;
        }
        button.setAttribute('slot', 'button');
        button.setAttribute('data-type', aPartName);
        button.setAttribute('title', `Add a ${aPartName} to this ${this.model.type}`);
        button.classList.add('add-part-button');
        button.addEventListener('click', this.onAddSubpart);
        button.innerHTML = icon;
        return button;
    }

    onSubpartItemClick(event){
        let id = event.currentTarget.getAttribute('ref-id');
        let targetPart = window.System.partsById[id];
        if(targetPart){
            window.System.editor.render(targetPart);
        }
    }

    onSubpartItemMouseEnter(event){
        this.getLocationViews(event).forEach((view) => {
            view.highlight("rgb(54, 172, 100)"); // green
        });
    }

    onSubpartItemMouseLeave(event){
        this.getLocationViews(event).forEach((view) => {
            view.unhighlight();
        });
    }

    onAddSubpart(event){
        let type = event.currentTarget.getAttribute('data-type');
        if(type){
            this.model.sendMessage({
                type: 'command',
                commandName: 'newModel',
                args: [
                    type,
                    this.model.id
                ]
            }, this.model);
        }
        this.render(this.model);
    }

    getLocationViews(event){
        let targetId = event.currentTarget.getAttribute('ref-id');
        let span = event.currentTarget.querySelector('span');
        return window.System.findViewsById(targetId);
    }
};




/***/ }),

/***/ "./js/objects/views/editors/EditorTab.js":
/*!***********************************************!*\
  !*** ./js/objects/views/editors/EditorTab.js ***!
  \***********************************************/
/*! exports provided: EditorTab, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorTab", function() { return EditorTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditorTab; });
// PREAMBLE

const templateString = `
<style>
    :host {
        display: flex;
        flex: 1;
        align-items: center;
        justify-content: center;
        padding: 6px;
        opacity: 0.5;
        border-bottom: 2px solid rgba(100, 100, 100, 0.7);
        transition: border 0.2s linear, opacity 0.2s linear;
        user-select: none;
    }

    :host([active="true"]){
        border-bottom: 2px solid rgba(200, 0, 0, 0.9);
        opacity: 1.0;
        transition: border 0.2s linear, opacity 0.2s linear;
    }

    :host(:hover){
        cursor: pointer;
    }
</style>
<span id="label">
    <slot></slot>
</span>
`;

class EditorTab extends HTMLElement {
    constructor(){
        super();

        // Setup template and shadow root
        const template = document.createElement('template');
        template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            template.content.cloneNode(true)
        );

        // Bound methods
        this.onClick = this.onClick.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            this.addEventListener('click', this.onClick);

            // If the tab is currently activated, emit
            // the tab-activaed message
            if(this.getAttribute('active') == "true"){
                let event = new CustomEvent("tab-activated", {
                    bubbles: true
                });
                this.dispatchEvent(event);
            }
        }
    }

    disconnectedCallback(){
        this.removeEventListener('click', this.onClick);
    }

    onClick(event){
        let isActive = (this.getAttribute('active') == "true");
        if(!isActive){
            this.setAttribute('active', 'true');
            let event = new CustomEvent("tab-activated", {
                bubbles: true
            });
            this.dispatchEvent(event);
        }
    }
};




/***/ }),

/***/ "./js/objects/views/editors/utils/subparts.js":
/*!****************************************************!*\
  !*** ./js/objects/views/editors/utils/subparts.js ***!
  \****************************************************/
/*! exports provided: getLocationStringFor, onLocationLinkClick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocationStringFor", function() { return getLocationStringFor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onLocationLinkClick", function() { return onLocationLinkClick; });
 const getLocationStringFor = (aPart) => {
        let result = "";
        let currentPart = aPart;
        let currentOwner = aPart._owner;
        while(currentOwner){
            let indexInParent = currentOwner.subparts.filter((subpart) => {
                return subpart.type == currentPart.type;
            }).indexOf(currentPart) + 1;
            result += `${currentPart.type} ${indexInParent} of `;
            currentPart = currentPart._owner;
            currentOwner = currentOwner._owner;
        }
        result += 'this world';
        return result;
}


const onLocationLinkClick = (event) => {
        let text = event.currentTarget.querySelector('span').textContent;
        let input = document.createElement('input');
        input.style.position = 'absolute';
        input.style.opacity = 0;
        document.body.append(input);
        let currentFocus = document.activeElement;
        input.focus();
        input.value = text;
        console.log(input.value);
        input.select();
        document.execCommand('copy');
        input.remove();
        currentFocus.focus();
}




/***/ }),

/***/ "./js/objects/views/navigator/CardRow.js":
/*!***********************************************!*\
  !*** ./js/objects/views/navigator/CardRow.js ***!
  \***********************************************/
/*! exports provided: CardRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardRow", function() { return CardRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CardRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Card Row
 * --------------------------------------------
 * I am a view on a given Stack that shows each
 * subpart card item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="cards"></slot>
`;

class CardRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedCard = this.addWrappedCard.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('card-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the Stack Model's main view element.
        // We add the st-view-added/removed CustomEvent listeners
        // here so we can react only to direct stack additions
        // to the Stack (and not, say, to Windows or other nested kinds)
        let stackView = window.System.findViewById(this.model.id);
        stackView.addEventListener('st-view-added', this.handlePartAdded);
        stackView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(removedModel){
        let stackView = window.System.findViewById(removedModel.id);
        stackView.removeEventListener('st-view-added', this.handlePartAdded);
        stackView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        if(!this.model.currentCard){
            return;
        }
        let wrappers = Array.from(this.querySelectorAll('wrapped-view'));
        wrappers.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentCard.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'card'){
            let cardPart = window.System.partsById[event.detail.partId];
            this.addWrappedCard(cardPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'card'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update number display of all wrapped views in the row
            Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToCardById(event.target.getAttribute('wrapped-id'));
        }
    }

    initView(){
        // First, we clear out any existing children
        this.innerHTML = "";

        // We iterate over each card of the stack and:
        // * Create a clone of the card view element;
        // * Attach the correct model;
        // * Set it to be a lensed view;
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'card';
        }).forEach(cardPart => {
            this.addWrappedCard(cardPart);
        });

        // Update setting the current
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedCard(aCard){
        // Insert the lensed CardView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute('slot', 'cards');
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aCard);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a card and hence not
            // displayed in the CardRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

};




/***/ }),

/***/ "./js/objects/views/navigator/Navigator.js":
/*!*************************************************!*\
  !*** ./js/objects/views/navigator/Navigator.js ***!
  \*************************************************/
/*! exports provided: STNavigator, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STNavigator", function() { return STNavigator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return STNavigator; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/* harmony import */ var _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WrappedView.js */ "./js/objects/views/navigator/WrappedView.js");
/* harmony import */ var _StackRow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StackRow.js */ "./js/objects/views/navigator/StackRow.js");
/* harmony import */ var _CardRow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CardRow.js */ "./js/objects/views/navigator/CardRow.js");
/**
 * SimpleTalk Navigator Webcomponent
 * ------------------------------------------
 * This is a standalone component that allows
 * authors to navigate the WorldStack and individual
 * Stacks therein using a convenient pop-out tray from
 * the bottom of the screen.
 **/





// Add any needed customElements
window.customElements.define('nav-stack-row', _StackRow_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
window.customElements.define('nav-card-row', _CardRow_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
window.customElements.define('wrapped-view', _WrappedView_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

const stackIcon = `
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-stack" width="50" height="50" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <polyline points="12 4 4 8 12 12 20 8 12 4"></polyline>
   <polyline points="4 12 12 16 20 12"></polyline>
   <polyline points="4 16 12 20 20 16"></polyline>
</svg>
`;

const cardIcon = `
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   class="icon icon-tabler icon-tabler-stack"
   width="50"
   height="20.833309"
   viewBox="0 0 24 9.9999884"
   stroke-width="2"
   stroke="currentColor"
   fill="none"
   stroke-linecap="round"
   stroke-linejoin="round"
   version="1.1"
   id="svg893">
  <metadata
     id="metadata899">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs897" />
  <path
     stroke="none"
     d="M -2.7669151,-1.2564948 H 21.233085 V 22.743505 H -2.7669151 Z"
     fill="none"
     id="path885" />
  <polyline
     points="12 4 4 8 12 12 20 8 12 4"
     id="polyline887"
     transform="translate(0,-3)" />
</svg>
`;

const templateString = `
<style>
    :host {
        box-sizing: border-box;
        position: absolute;
        width: 100%;
        bottom: 0;
        min-height: 271px;
        background-color: white;
        backdrop-filter: blur(4px);
        transition: transform 0.2s ease-out;
        padding: 20px;
        transform: translateY(100%);
        border-top: 1px solid rgba(50, 50, 50, 0.4);
        overflow-y: hidden;
        overflow-x: auto;
        z-index: 1000;
    }

    .nav-display-row {
        box-sizing: border-box;
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        margin-bottom: 15px;
    }
    .nav-icon {
        color: gray;
        margin-right: 30px;
    }
</style>
<div id="stacks-display" class="nav-display-row">
    <div id="stack-icon" class="nav-icon">${stackIcon}</div>
    <slot name="stack-row"></slot>
</div>
<div id="cards-display" class="nav-display-row">
    <div id="card-icon" class="nav-icon">${cardIcon}</div>
    <slot name="card-row"></slot>
</div>
`;

class STNavigator extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();

        this.initialized = false;
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.toggle = this.toggle.bind(this);
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.createCardRowFor = this.createCardRowFor.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }

    afterDisconnected(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelSet(){
        this.removeAttribute('part-id');

        // Respond to the System part-added CustomEvent
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);

        // Add a StackRow view.
        this.stackRowEl = this.querySelector(':scope > nav-stack-row');
        if(!this.stackRowEl){
            this.stackRowEl = document.createElement('nav-stack-row');
            this.stackRowEl.setAttribute('slot', 'stack-row');
            this.appendChild(this.stackRowEl);
        }
        this.stackRowEl.setModel(this.model);

        // Create any needed CardRow views for all stacks
        // currently in the world
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.createCardRowFor(stackPart);
        });

        // Init the StackRow
        this.stackRowEl.initView();
        
        // Update the current card/stack values
        this.handleCurrentChange();

        // Respond to eventual current-ness prop
        // changes from the WorldStack.
        this.onPropChange('current', this.handleCurrentChange);
    }

    handleCurrentChange(){
        // If we get here, this means that the current *stack* has changed.
        // So we need to find the correct CardRow for it and set it
        // to be the slotted one in the shadow DOM
        let currentStackId = this.model.currentStack.id.toString();
        Array.from(this.querySelectorAll('nav-card-row')).forEach(cardRow => {
            let rowId = cardRow.getAttribute('stack-id');
            cardRow.removeAttribute('slot');
            if(currentStackId == rowId){
                cardRow.setAttribute('slot', 'card-row');
                Array.from(cardRow.querySelectorAll('wrapped-view')).forEach(wrapper => {
                    wrapper.updateScaling();
                });
            }
        });
    }

    handlePartAdded(event){
        // If a new stack is added, we need to create
        // a new CardRow for it.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.createCardRowFor(stackPart);
        }
    }

    handlePartRemoved(event){
        // If a stack has been removed, we need to
        // remove the corresponding CardRow
        if(event.detail.partType == 'stack'){
            let cardRow = this.querySelector(`[stack-id="${event.detail.partId}"]`);
            if(cardRow){
                cardRow.remove();
            }
        }
    }

    createCardRowFor(aStack){
        let cardRow = document.createElement('nav-card-row');
        cardRow.setAttribute('stack-id', aStack.id);
        cardRow.setModel(aStack);
        this.appendChild(cardRow);
        cardRow.initView();
    }

    toggle(){
        this.classList.toggle('open');
        if(this.classList.contains('open')){
            this.open();
        } else {
            this.close();
        }
    }

    open(){
        this.style.transform = "translateY(0)";
    }

    close(){
        this.style.transform = "translateY(100%)";
    }

    
};




/***/ }),

/***/ "./js/objects/views/navigator/StackRow.js":
/*!************************************************!*\
  !*** ./js/objects/views/navigator/StackRow.js ***!
  \************************************************/
/*! exports provided: StackRow, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackRow", function() { return StackRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StackRow; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * Navigator Stack Row
 * --------------------------------------------
 * I am a view on the WorldStack that shows each
 * subpart stack item as a wrapped lens view along
 * a row.
 */


const templateString = `
<style>
    :host {
        display: flex;
        position: relative;
        align-items: center;
        justify-content: flex-start;
        flex: 1;
    }
</style>
<slot name="stacks"></slot>
`;

class StackRow extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bound methods
        this.initView = this.initView.bind(this);
        this.addWrappedStack = this.addWrappedStack.bind(this);
        this.handleCurrentChange = this.handleCurrentChange.bind(this);
        this.handlePartAdded = this.handlePartAdded.bind(this);
        this.handlePartRemoved = this.handlePartRemoved.bind(this);
        this.showInitially = this.showInitially.bind(this);
        this.onWrapperClick = this.onWrapperClick.bind(this);
    }

    afterConnected(){
        // we don't want the context menu to open in the nav since
        // it doens't make sense atm and will error
        this.removeEventListener('contextmenu', this.onContextMenuClick);
    }


    afterModelSet(){
        this.removeAttribute('part-id');
        this.setAttribute('stack-id', this.model.id);
        this.onPropChange('current', this.handleCurrentChange);

        // Find the World Model's main view element.
        // We add the st-view-added CustomEvent listener
        // here so we can react only to direct stack additions
        // to the WorldStack (and not, say, to Windows or other nested kinds)
        let worldView = document.querySelector('st-world');
        worldView.addEventListener('st-view-added', this.handlePartAdded);
        worldView.addEventListener('st-view-removed', this.handlePartRemoved);
    }

    afterModelUnset(){
        let worldView = document.querySelector('st-world');
        worldView.removeEventListener('st-view-added', this.handlePartAdded);
        worldView.removeEventListener('st-view-removed', this.handlePartRemoved);
    }

    handleCurrentChange(){
        let currentId = this.model.currentStack.id;
        let wrappedViews = Array.from(
            this.querySelectorAll('wrapped-view')
        );
        wrappedViews.forEach(wrapper => {
            let wrappedId = wrapper.getAttribute('wrapped-id');
            if(wrappedId == this.model.currentStack.id.toString()){
                wrapper.classList.add('current');
            } else {
                wrapper.classList.remove('current');
            }
        });
    }

    handlePartAdded(event){
        // This handler is for the st-view-added
        // CustomEvent that is triggered by System when
        // newModel() has completed.
        if(event.detail.partType == 'stack'){
            let stackPart = window.System.partsById[event.detail.partId];
            this.addWrappedStack(stackPart);
            this.showInitially();
        }
    }

    handlePartRemoved(event){
        if(event.detail.partType == 'stack'){
            let wrappedView = this.querySelector(`wrapped-view[wrapped-id="${event.detail.partId}"]`);
            if(wrappedView){
                wrappedView.remove();
            }

            // Update numbers of remaining wrapped views in this StackRow
            Array.from(this.querySelectorAll('wrapped-view')).forEach(wrapper => {
                wrapper.updateNumberDisplay();
            });
        }
    }

    onWrapperClick(event){
        let wrapperIsCurrent = event.target.classList.contains('current');
        if(this.model && !wrapperIsCurrent){
            this.model.goToStackById(
                event.target.getAttribute('wrapped-id')
            );
        }
    }

    initView(){
        // Remove any existing wrapped views
        this.innerHTML = "";

        // We iterate over each corresponding Stack and:
        // * Create a clone of its view node;
        // * Attach the correct model;
        // * Set it to be a lensed view
        // * Do the same for all children, recursively
        this.model.subparts.filter(subpart => {
            return subpart.type == 'stack';
        }).forEach(stackPart => {
            this.addWrappedStack(stackPart);
        });

        // Setup the initial current-ness display
        this.handleCurrentChange();
    }

    showInitially(){
        // Nothing for now
    }

    addWrappedStack(aStack){  
        // Insert the lensed StackView into the wrapper
        let wrapper = document.createElement('wrapped-view');
        wrapper.setAttribute("slot", "stacks");
        wrapper.addEventListener('click', this.onWrapperClick);
        this.appendChild(wrapper);
        wrapper.setModel(aStack);
    }

    subpartOrderChanged(id, currentIndex, newIndex){
        let subpartNode = this.childNodes[currentIndex];
        if(!subpartNode){
            // this could be a model subpart which is not a stack and hence not
            // displayed in the StackRow
            return;
        }
        if(newIndex == this.childNodes.length - 1){
            this.appendChild(subpartNode);
        } else {
            // we need to account for whether the index of this
            // is before or after the newIndex
            if(currentIndex < newIndex){
                newIndex = newIndex + 1;
            }
            let referenceNode = this.childNodes[newIndex];
            this.insertBefore(subpartNode, referenceNode);
        }
        // Update number display of all wrapped views in the row
        Array.from(this.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }
};




/***/ }),

/***/ "./js/objects/views/navigator/WrappedView.js":
/*!***************************************************!*\
  !*** ./js/objects/views/navigator/WrappedView.js ***!
  \***************************************************/
/*! exports provided: WrappedView, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrappedView", function() { return WrappedView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WrappedView; });
/* harmony import */ var _PartView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PartView.js */ "./js/objects/views/PartView.js");
/**
 * WrappedView Component
 * ---------------------------------------
 * I am a plain Webcomponent whose purpose is to
 * wrap a visual copy of an actual SimpleTalk View
 * element and display it in a scaled down format.
 * I make a cloned copy of the underlying view and
 * attach it to the same model as the original.
 **/


const templateString = `
<style>
    #number-display {
        opacity: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 100%;
        transition: opacity 0.2s ease-in;
        font-size: 2.2rem;
    }

    #number-display > span {
        transform: translateY(-10px);
        transition: transform 0.2s linear;
        pointer-events: none;
    }

    :host(:not(.current)) > #number-display {
        opacity: 0.8;
        background-color: rgba(200, 200, 200, 0.5);
        transition: opacity 0.2s ease-out;
        z-index: 1000;
    }

    :host(:not(.current)) > #number-display > span {
        transform: translateY(0px);
        transition: transform 0.2s linear;
    }
</style>
<div id="number-display">
    <span></span>
</div>
<slot name="wrapped-view"></slot>
`;


class WrappedView extends _PartView_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(){
        super();
        this.wantsHalo = false;

        // Set up template and shadowDom
        this.template = document.createElement('template');
        this.template.innerHTML = templateString;
        this._shadowRoot = this.attachShadow({mode: 'open'});
        this._shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );

        // Bind methods
        this.onChildSlotted = this.onChildSlotted.bind(this);
        this.updateScaling = this.updateScaling.bind(this);
        this.handleNumberChange = this.handleNumberChange.bind(this);
        this.addWrappedView = this.addWrappedView.bind(this);
        this._recursivelyUpdateLensViews = this._recursivelyUpdateLensViews.bind(this);
    }

    connectedCallback(){
        if(this.isConnected){
            // Bind a listener for the slot change.
            // This will be triggered whenever any
            // underlying element is slotted, so we
            // know to recompute the appropriate sizing
            // and styling
            let slotEl = this._shadowRoot.querySelector('slot');
            slotEl.addEventListener('slotchange', this.onChildSlotted);

            // we don't want the context menu to open in the nav since
            // it doens't make sense atm and will error
            this.removeEventListener('contextmenu', this.onContextMenuClick);
        }
    }

    disconnectedCallback(){
        let slotEl = this._shadowRoot.querySelector('slot');
        slotEl.removeEventListener('slotchange', this.onChildSlotted);
    }

    onChildSlotted(event){
        //this.updateScaling();
        //this.updateNumberDisplay();
    }

    afterModelSet(){
        this.onPropChange('number', this.handleNumberChange);
        this.removeAttribute('part-id');
        this.addWrappedView(this.model);
        this.updateNumberDisplay();
    }

    updateScaling(){
        let firstChild = this.children[0];
        // We need to find the element corresponding to the
        // actual view for the lens-ed part, in order to get
        // its current dimensions.
        let partId = firstChild.getAttribute('lens-part-id');
        let refElement = document.querySelector(`st-world`);
        let wrapBox = this.getBoundingClientRect();
        let innerBox = document.querySelector(`st-world`).getBoundingClientRect();
        let scalingX = (wrapBox.width / innerBox.width);
        let refElementBox = refElement.getBoundingClientRect();
        firstChild.style.width = `${refElementBox.width}px`;
        firstChild.style.height = `${refElementBox.height}px`;
        firstChild.style.transform = `scale(${scalingX})`;
        firstChild.style.transformOrigin = "0px 0px";
    }

    updateNumberDisplay(){
        let firstChild = this.children[0];
        let model = firstChild.model;
        // we only want to look at subparts of the same type (stack or card)
        let subparts = model._owner.subparts.filter((part) => {
            return model.type == part.type;
        });
        let numDisplay = this._shadowRoot.querySelector('#number-display > span');
        numDisplay.innerText = subparts.indexOf(model) + 1;
    }

    handleNumberChange(){
        // Update number display of all wrapped views in the row
        Array.from(this.parentNode.querySelectorAll(`wrapped-view`)).forEach(wrapper => {
            wrapper.updateNumberDisplay();
        });
    }

    addWrappedView(aPartModel){
        // First, clear out any existing
        // child elements
        this.innerHTML = "";

        // Create a lensed copy of the given
        // view and update key attributes on it
        let originalView = document.querySelector(`[part-id="${aPartModel.id}"]`);
        let lensedView = originalView.cloneNode(true);
        lensedView.setAttribute('lens-part-id', aPartModel.id);
        lensedView.setAttribute('slot', 'wrapped-view');
        lensedView.style.pointerEvents = "none";
        lensedView.wantsHalo = false;

        // Inline the initial scaling style properties.
        // We begin with an extremely small amount which will
        // be adjusted later during updateScaling();
        lensedView.style.transform = `scale(${0.001})`;
        lensedView.style.transformOrigin = "0px 0px";
        
        // Recursively create lens views of all subpart children
        // and append them in the correct places
        lensedView.isLensed = true;
        lensedView.setModel(aPartModel);
        lensedView.removeAttribute('part-id');
        if(lensedView.handleCurrentChange){
            lensedView.handleCurrentChange();
        }
        this._recursivelyUpdateLensViews(lensedView, aPartModel.id);

        // Insert the root lensed view into the wrapper
        this.setAttribute('wrapped-id', aPartModel.id);
        this.appendChild(lensedView);
        this.updateScaling();
    }

    _recursivelyUpdateLensViews(lensedView, anId){
        let subViews = Array.from(lensedView.children).filter(child => {
            return child.isPartView;
        });
        subViews.forEach(subView => {
            subView.isLensed = true;
            subView.wantsHalo = false;
            let subId = subView.getAttribute('part-id');
            subView.setAttribute('lens-part-id', subId);
            let model = window.System.partsById[subId];
            subView.setModel(model);
            subView.removeAttribute('part-id');
            this._recursivelyUpdateLensViews(subView, subId);
        });
    }

    /** PartView Overrides **/
    styleCSS(){
        // Do nothing
    }

    styleTextCSS(){
        // Do nothing
    }

    layoutChanged(){
        // Do nothing
    }
};




/***/ }),

/***/ "./js/ohm/interpreter-semantics.js":
/*!*****************************************!*\
  !*** ./js/ohm/interpreter-semantics.js ***!
  \*****************************************/
/*! exports provided: createInterpreterSemantics, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createInterpreterSemantics", function() { return createInterpreterSemantics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createInterpreterSemantics; });
/* harmony import */ var _objects_ExecutionStack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/ExecutionStack.js */ "./js/objects/ExecutionStack.js");


// Helpers
function findNearestParentOfKind(aPart, aPartType){
    let owner = aPart._owner;
    while(owner){
        if(owner.type == aPartType){
            return owner;
        }
        owner = owner._owner;
    }
    throw new Error(`'this' is a ${aPart.type}, not a ${aPartType} or does not have a parent of a ${aPartType}!`);
}

// check for possibleAncestor.acceptsSubpart(aPart.type)
// and if not go to owner and check again
function findFirstPossibleAncestor(aPart, aPartType){
    if(_subpartCheck(aPart, aPartType)){
        return aPart;
    } else {
        let owner = aPart._owner;
        while(owner){
            if(_subpartCheck(owner, aPartType)){
                return owner;
            }
            owner = owner._owner;
        }
    }
    throw new Error(`a ${aPart.type}, does not accept nor has any ancestors which accept part type ${aPartType}`);
}

function _subpartCheck(aPart, aPartType){
    if(aPartType == 'part'){
        return aPart.acceptedSubpartTypes.length > 0;
    }
    return aPart.acceptsSubpart(aPartType);
}

class STVariableReferenceError extends Error {
    constructor(...args){
        super(...args);
    }
};
Object.defineProperty(
    STVariableReferenceError.prototype,
    'name',
    {
        value: 'STVariableReferenceError'
    }
);

const createInterpreterSemantics = (partContext, systemContext) => {
    return {
        Script: function(scriptParts, _){
            return scriptParts.interpret();
        },
        MessageHandler: function(handlerOpen, lineTerm, optionalStatementList, handlerClose){
            let {messageName, parameters} = handlerOpen.interpret();
            let handlerFunction = function(senders, ...args){

                // In the grammar, the StatementList is
                // an optional rule, meaning the result of the rule
                // is an empty array (no statementlist) or a single
                // item array (the statementlist)
                if(optionalStatementList.children.length == 0){
                    return;
                }
                let statementList = optionalStatementList.children[0];

                // Next, we initialize a new ActivationContext
                // that will hold all variable information for
                // the execution of this handler.
                // We push it to the top of the current execution stack
                // and set the argument variables to locals
                args.forEach((argValue, index) => {
                    let argName = parameters[index];
                    systemContext.executionStack.current.setLocal(
                        argName,
                        argValue
                    );
                });

                // Because StatementList is both optional *and* made up
                // of iterable StatementLine rules (ie, 'StatementLine+' in grammar),
                // we need to "unwrap" these nodes without calling interpret() on them.
                // This ensures that expressions within the statements, like variable lookups,
                // are not called before any preceding statements have been interpreted and
                // the corresponding messages have already been sent. For example, statement 1 might
                // set a variable that statement 2 needs to lookup and use, so we want the lookup to
                // occur after statement 1 has been interpreted and the message for it has
                // been sent.
                statementList.children.forEach(statementLines => {
                    statementLines.children.forEach(statementLine => {
                        let message = statementLine.interpret();
                    });
                });
            };

            partContext._commandHandlers[messageName] = handlerFunction;
        },

        MessageHandlerOpen: function(literalOn, messageName, optionalParameterList){
            // Because the ParameterList here is optional, if
            // it is set it will be in the form of a size 1 array.
            // This single array item will itself be an array of the
            // parameter variable names.
            // Otherwise, an empty array indicates no params
            // are passed in for this handler
            let params = optionalParameterList.interpret();
            if(params.length > 0){
                params = params[0];
            }
            return {
                messageName: messageName.sourceString,
                parameters: params
            };
        },

        ParameterList: function(parameterString){
            return parameterString.asIteration().children.map(child => {
                return child.sourceString;
            });
        },


        InClause: function(inLiteral, objectSpecifier){
            return objectSpecifier.interpret();
        },

        Command_answer: function(answer, expression){
            let msg = {
                type: "command",
                commandName: "answer",
                args: [
                    expression.interpret()
                ]
            };
            return msg;
        },

        Command_goToDirection: function(goToLiteral, nextPrevious, systemObject){
            let args = [];
            args.push(nextPrevious.sourceString);
            if (systemObject.sourceString){
                args.push(systemObject.sourceString);
            }

            let msg = {
                type: "command",
                commandName: "go to direction",
                args: args
            };
            return msg;
        },

        Command_goToByObjectSpecifier: function(goToLiteral, objectSpecifier){
            let args = [
                objectSpecifier.interpret() // id of the object
            ];

            let msg = {
                type: "command",
                commandName: "go to",
                args: args
            };
            return msg;
        },

        Command_goToWebsite: function(goToLiteral, websiteLiteral, url){
            let args = [
                url.interpret()
            ];

            let msg = {
                type: "command",
                commandName: "go to website",
                args: args
            };
            return msg;
        },

        Command_addProperty: function(addLiteral, propertyLiteral, propNameAsLiteral, toLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "newProperty",
                args: args
            };
            return msg;
        },

        Command_addModel: function(addLiteral, newPartType, optionalPartName){
            // here no owner has been provided so we assume it is the first possible one
            let parent = findFirstPossibleAncestor(partContext, newPartType.sourceString);
            let args = [
                newPartType.sourceString,
                parent.id
            ];
            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_addModelTo: function(addLiteral, newPartType, optionalPartName, toLiteral, objectSpecifier){
            let args = [
                newPartType.sourceString, // The kind of part to add
                objectSpecifier.interpret() // id of the parent model part
            ];

            let optionalName = optionalPartName.interpret();
            if(optionalName && optionalName.length){
                args.push(optionalName[0]);
            }

            let msg = {
                type: "command",
                commandName: "newModel",
                args: args
            };
            return msg;
        },

        Command_putVariable: function(putLiteral, value, intoLiteral, globalLiteral, destination){
            let global = false;
            if(globalLiteral.sourceString){
                global = true;
            };
            let args = [
                value.interpret(),
                destination.sourceString,
                global
            ];
            let msg = {
                type: "command",
                commandName: 'putInto',
                args
            };
            return msg;
        },

        Command_deleteProperty: function(deleteLiteral, propertyLiteral, propNameAsLiteral, fromLiteral, systemObject){
            let specifiedObjectId = systemObject.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "deleteProperty",
                args: args
            };
            return msg;
        },

        Command_deleteModel: function(deleteLiteral, objectSpecifier){
            let args = [
                objectSpecifier.interpret() // id of the object
            ];

            let msg = {
                type: "command",
                commandName: "deleteModel",
                args: args
            };
            return msg;
        },

        Command_setProperty: function(setLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setProperty",
                args: args
            };
            return msg;
        },

        Command_setSelection: function(setLiteral, selectionLiteral, propNameAsLiteral, toLiteral, literalOrVarName, optionalInClause){
            let specifiedObjectId = optionalInClause.interpret()[0] || null;
            let args = [
                propNameAsLiteral.interpret(), // The property name
                literalOrVarName.interpret(), // The value or a var representing the value
                specifiedObjectId
            ];

            let msg = {
                type: "command",
                commandName: "setSelection",
                args: args
            };
            return msg;
        },

        Command_ask: function(askLiteral, question){
            return {
                type: "command",
                commandName: "ask",
                args: [ question.interpret() ]
            };
        },

        Command_tellCommand: function(tellLiteral, objectSpecifier, toLiteral, command){
            return {
                type: 'command',
                commandName: 'tell',
                args: [
                    objectSpecifier.interpret(),
                    command.interpret()
                ]
            };
        },

        Command_arbitraryCommand: function(commandName, optionalArgumentList){
            // Because the argument list is optional here, it will
            // be either an empty array (no arguments) or a size 1
            // array (which itself will contain an array of the arguments)
            let optionalArguments = optionalArgumentList.interpret();
            if(optionalArguments.length > 0){
                optionalArguments = optionalArguments[0];
            }

            return {
                type: "command",
                commandName: commandName.sourceString,
                args: optionalArguments
            };
        },

        CommandArgumentList: function(list){
            return list.asIteration().interpret();
        },

        StatementLine: function(statement, newline){
            let message = statement.interpret();

            // Some statements, like if-then controls
            // and repeat controls, do not result in
            // messages but return null.
            // We ignore these.
            if(message && typeof(message) !== 'string'){
                let commandResult = partContext.sendMessage(message, partContext);
                systemContext.executionStack.current.setLocal('it', commandResult);
                return null;
            } else {
                return message;
            }
        },

        Statement: function(actualStatement, optionalComment){
            return actualStatement.interpret();
        },

        Expression_addExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first + second;
        },

        Expression_minusExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first - second;
        },

        Expression_divideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first / second;
        },

        Expression_moduloDivideExpr: function(firstExpr, operation, secondExpr){
            let first = firstExpr.interpret();
            let second = secondExpr.interpret();
            return first % second;
        },

        Expression_timesExpr: function(firstExpression, operation, secondExpression){
            let first = firstExpression.interpret();
            let second = secondExpression.interpret();
            return first * second;
        },

        Expression_stringConcatExpr: function(firstExpression, operation, secondExpression){
            // When we encounter the "&" operator, we coerce both expressions into
            // a string
            let first = firstExpression.interpret().toString();
            let second = secondExpression.interpret().toString();
            return `${first}${second}`;
        },

        Factor_parenFactor: function(leftParen, expression, rightParen){
            return expression.interpret();
        },

        Factor_notFactor: function(notLiteral, expression){
            return !expression.interpret();
        },

        EqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first === second;
        },

        NonEqualityConditional: function(expr1, comparatorLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first !== second;
        },

        Conditional_gtComparison: function(expr1, gtLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first > second;
        },

        Conditional_ltComparison: function(expr1, ltLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first < second;
        },

        Conditional_gteComparison: function(expr1, gteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first >= second;
        },

        Conditional_lteComparison: function(expr1, lteLiteral, expr2){
            let first = expr1.interpret();
            let second = expr2.interpret();
            return first <= second;
        },

        ThereIsAnObjectConditional: function(thereLiteral, isLiteral, aOrAnLiteral, objectSpecifier){
            try{
                objectSpecifier.interpret();
                return true;
            } catch(e){
                return false;
            };
        },

        ThereIsNotAnObjectConditional: function(thereLiteral, isLiteral, notLiteral, aOrAnLiteral, inClause){
            try{
                objectSpecifier.interpret();
                return false;
            } catch(e){
                return true;
            };
        },

        ThereIsAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, aLiteral, propertyLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return true;
            }
            return false;
        },

        ThereIsNotAPropertyConditional_withSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propertyLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            let property = target.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        ThereIsNotAPropertyConditional_withoutSpecifier: function(thereLiteral, isLiteral, notLiteral, aLiteral, propLiteral, propName){
            let property = partContext.partProperties.findPropertyNamed(propName.interpret());
            if(property){
                return false;
            }
            return true;
        },

        IfThenInline: function(ifLiteral, conditional, thenLiteral, statement, optionalComment){
            let shouldEvaluate = conditional.interpret();
            if(shouldEvaluate){
                return statement.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withoutElse: function(ifLine, lineTerm1, thenLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return null;
            }
        },

        IfThenSingleline_withElse: function(ifLine, lineTerm1, thenLine, lineTerm2, elseLine){
            let condition = ifLine.interpret();
            if(condition){
                return thenLine.interpret();
            } else {
                return elseLine.interpret();
            }
        },

        IfThenMultiline_withElse: function(ifLine, lineTerm, multiThen, multiElse, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            } else {
                return multiElse.interpret();
            }
        },

        IfThenMultiline_withoutElse: function(ifLine, lineTerm, multiThen, endIfLine){
            let condition = ifLine.interpret();
            if(condition){
                return multiThen.interpret();
            }
            return null;
        },

        IfLine: function(ifLiteral, conditional, optionalComment){
            return conditional.interpret();
        },

        ThenLine: function(thenLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ElseLine: function(elseLiteral, statement, optionalComment){
            return statement.interpret();
        },

        ControlStatementLine: function(statementLine){
            return statementLine.interpret();
        },

        MultiThen: function(thenLiteral, optionalComment, lintTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        MultiElse: function(elseLiteral, optionalComment, lineTerm, controlStatementLines){
            return controlStatementLines.interpret();
        },

        KindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return false;
        },

        NotKindConditional: function(expr1, comparatorLiteral, expr2){
            // TODO: Flesh out this function to account for
            // various object types and their kind comparisons
            return true;
        },

        RepeatControlForm_forNumTimes: function(repeatLit, optionalForLit, intOrVar, timesLit){
            return {
                repeatType: 'forNumTimes',
                numTimes: intOrVar.interpret()
            };
        },

        RepeatControlForm_untilCondition: function(repeatLit, untilLit, conditional){
            return {
                repeatType: 'untilCondition',
                condition: conditional
            };
        },

        RepeatControlForm_whileCondition: function(repeatLit, whileLit, conditional){
            return {
                repeatType: 'whileCondition',
                condition: conditional
            };
        },

        RepeatControlForm_withStartFinish: function(repeatLit, withLit, varName, eqLit, firstVal, toLit, secondVal){
            return {
                repeatType: 'withStartFinish',
                varName: varName.sourceString,
                start: firstVal.interpret(),
                finish: secondVal.interpret()
            };
        },

        RepeatAdjust_exit: function(_){
            return 'exit repeat';
        },

        RepeatAdjust_next: function(_){
            return 'next repeat';
        },

        RepeatBlock: function(repeatControl, lineTerm, statementLineOrRepAdjustPlus, endLiteral){
            let repeatInfo = repeatControl.interpret();
            let statementLines = statementLineOrRepAdjustPlus.children;
            switch(repeatInfo.repeatType){
            case 'forNumTimes':
                for(let i = 1; i <= repeatInfo.numTimes; i++){
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == 'next repeat'){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the main for loop
                    }
                }
                break; // Break out of the switch
            case 'untilCondition':
                let untilTestCondition = repeatInfo.condition.interpret();
                while(!untilTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result){
                            if(result == 'exit repeat'){
                                shouldBreak = true;
                                break;
                            } else if(result == 'next repeat'){
                                break;
                            }
                        }
                    }
                    if(shouldBreak){
                        break; // break out of the outer while loop
                    }
                    untilTestCondition = repeatInfo.condition.interpret();
                }
                break; // Break out of the switch case
            case 'whileCondition':
                let whileTestCondition = repeatInfo.condition.interpret();
                while(whileTestCondition){
                    let shouldBreak = false;
                    for(let i = 0; i < statementLines.length; i++){
                        let currentStatement = statementLines[i];
                        let result = currentStatement.interpret();
                        if(result == 'exit repeat'){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldBreak){
                        break; // break out of outer while loop (end repeat)
                    }
                    whileTestCondition = repeatInfo.condition.interpret();
                }
                break; // break out of switch case
            case 'withStartFinish':
                // For now, we assume that start is less than
                // finish. We should probably throw an error if
                // otherwise
                if(repeatInfo.start > repeatInfo.finish){
                    throw new Error(`Repeat error: start greater than finish`);
                }

                for(let i = repeatInfo.start; i <= repeatInfo.finish; i++){
                    systemContext.executionStack.current.setLocal(repeatInfo.varName, i);
                    let shouldBreak = false;
                    let shouldPass = false;
                    for(let j = 0; j < statementLines.length; j++){
                        let currentStatement = statementLines[j];
                        let result = currentStatement.interpret();
                        if(result == "exit repeat"){
                            shouldBreak = true;
                            break; // break out of this inner loop
                        } else if(result == "next repeat"){
                            shouldPass = true;
                            break; // break out of this inner loop
                        }
                    }
                    if(shouldPass){
                        i += 1;
                    }
                    if(shouldBreak){
                        break; // break out of the outer (repeat) loop
                    }
                }
            }
            return null;
        },

        PropertyValue_withSpecifier: function(theLiteral, propName, ofLiteral, objectSpecifier){
            let targetId = objectSpecifier.interpret();
            let target = systemContext.partsById[targetId];
            if(!target){
                throw new Error(`Could not find part with id ${targetId} (${this.sourceString})`);
            }
            return target.partProperties.getPropertyNamed(
                target,
                propName.interpret()
            );
        },

        PropertyValue_withoutSpecifier: function(theLiteral, propName){
            return partContext.partProperties.getPropertyNamed(
                partContext,
                propName.interpret()
            );
        },

        /** Object Specifiers **/


        /**
         * The partByTarget Partial Specifier
         * refers to partials that specify a part
         * specified in the "target" PartProperty
         * of the context part. The value of the
         * target property is any valid ObjectSpecifier
         * string.
         */
        PartialSpecifier_partByTarget(targetLiteral){
            return (context) => {
                let targetPropValue = context.partProperties.getPropertyNamed(context, "target");
                // use the partContext since the context object might not have any semantics set on it
                // For example, a context object/part which does not have a script which has been
                // compiled will not have had context._semantics set.
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return systemContext.partsById[targetId];
            };
        },

        /**
         * The currentCard Partial Specifier
         * refers to partials that specify the current card
         * depending on the stack context.
         */
        PartialSpecifier_currentCard: function(currentLiteral, cardLiteral){
            return function(contextPart){
                return contextPart.currentCard;
            };
        },

        /**
         * The partByIndex Partial Specifier
         * refers to partials that specify a part
         * type and an integer literal, for ex:
         *     field 3
         * The above example refers to the third
         * field part in its owner/parent part.
         */
        PartialSpecifier_partByIndex: function(objectType, integerLiteral){
            let index = integerLiteral.interpret();
            if(index < 1){
                throw new Error(`Part indices must be 1 or greater`);
            }
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    return contextPart.subparts[index-1];
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    return partsOfType[index-1];
                }
            };
        },

        /**
         * The partByNumericalIndex Partial Specifier
         * refers to partial that specify a part
         * type preceded by the English word for the
         * number. For the moment we accept first - tenth
         * Example:
         *     sixth button
         */
        PartialSpecifier_partByNumericalIndex: function(numericalKeyword, objectType){
            let index = numericalKeyword.interpret();
            return function(contextPart){
                if(objectType.sourceString == 'part'){
                    if(index > contextPart.subparts.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return contextPart.subparts[contextPart.subparts.length - 1];
                    } else {
                        return contextPart.subparts[index-1];
                    }
                } else {
                    let partsOfType = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    });
                    if(index > partsOfType.length){
                        throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} numbered ${index}`);
                    }
                    if(index < 0){
                        // An index of -1 indicates the "last"
                        // item of the desired collection was
                        // specified
                        return partsOfType[partsOfType.length - 1];
                    } else {
                        return partsOfType[index-1];
                    }
                }
            };
        },

        /**
         * The partByName Partial Specifier
         * refers to a partial that specifies a part
         * by its name property. Example:
         *     card "My Custom Card"
         */
        PartialSpecifier_partByName: function(objectType, stringLiteral){
            let name = stringLiteral.interpret();
            if(objectType.sourceString == 'part'){
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return name == foundName;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a part named "${name}"`);
                };
            } else {
                return function(contextPart){
                    let found = contextPart.subparts.filter(subpart => {
                        return subpart.type == objectType.sourceString;
                    }).filter(subpart => {
                        let foundName = subpart.partProperties.getPropertyNamed(
                            subpart,
                            'name'
                        );
                        return foundName == name;
                    });
                    if(found.length){
                        return found[0];
                    }
                    throw new Error(`${contextPart.type}[${contextPart.id}] does not have a ${objectType.sourceString} named "${name}"`);
                };
            }
        },

        /**
         * The 'this' specifier is a terminal (final)
         * specifier that refers to one of three things:
         * 1. the type of the current part executing the script,
         *    example: this button
         * 2. Card, which refers to the card that owns the
         *    part that is currently executing the script, ex:
         *    this card
         * 3. Stack, which refers to the stack that owns the
         *    part that is currently executing the script, ex:
         *    this stack
         */
        TerminalSpecifier_thisSystemObject: function(thisLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == partContext.type){
                    return partContext;
                } else {
                    return findNearestParentOfKind(partContext, targetType);
                }
            };
        },

        /**
         * The 'current' specifier is a terminal (final)
         * specifier that refers to either the current card or stack
         * being displayed to the user.
         * There are only two possible valid options:
         *     `current card`
         *     `current stack`
         */
        TerminalSpecifier_currentSystemObject: function(currentLiteral, systemObject){
            let targetType = systemObject.sourceString;
            return function(contextPart){
                if(targetType == 'stack'){
                    return systemContext.getCurrentStackModel();
                } else if(targetType == 'card'){
                    return systemContext.getCurrentCardModel();
                } else {
                    throw new Error(`${targetType} cannot be a 'current' system object`);
                }
            };
        },

        /**
         * The partById specifier is a terminal (final)
         * specifier that refers to a given part type
         * by its unique system id. For any kind of part,
         * we use `part id <objectId>`
         * Examples: `card id 266` `part id 5`
         */
        TerminalSpecifier_partById: function(objectType, idLiteral, objectId){
            let id = objectId.sourceString;
            let found = systemContext.partsById[id];
            if(!found){
                throw new Error(`Cannot find ${objectType.sourceString} with id ${objectId}`);
            }
            return function(context){
                return found;
            };
        },

        /**
         * A "prefixed" queried specifier is just
         * a PartialSpecifier with "of" in front of it, indicating
         * that a different partial will precede it be queried inside of it.
         * Example `of button "My Button"`
         */
        QueriedSpecifier_prefixed: function(partialSpecifier, ofLiteral){
            return partialSpecifier.interpret();
        },

        /**
         * A nested queried specifier is one that has two
         * or more prefixed specifiers. The simplest would be
         * something like:
         *     `of card "My Card" of stack "Another named stack"`
         */
        QueriedSpecifier_nested: function(firstQuery, secondQuery){
            return function(contextPart){
                let inner = secondQuery.interpret()(contextPart);
                let outer = firstQuery.interpret()(inner);
                return outer;
            };
        },

        /**
         * An ObjectSpecifier without an annotated
         * rule means it was interpreted as just
         * a TerminalSpecifier of some sort.
         * However, we need to extract the id
         * and return that result, since that is what is
         * expected of all interpreted ObjectSpecifiers
         */
        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let found = terminalSpecifier.interpret()();
            return found.id;
        },

        /**
         * A Compound with terminal specifier is a QueriedSpecifier
         * that finishes with a Terminal specifier.
         * Example: `of button 3 of card "Some named card" of current stack`
         */
        ObjectSpecifier_compoundQueryWithTerminal: function(queriedSpecifier, terminalSpecifier){
            // The terminal here is the ultimate part context
            let finalPart = terminalSpecifier.interpret()();
            let result = queriedSpecifier.interpret()(finalPart);
            return result.id;
        },

        /**
         * A Compound without terminal specifier is a QueriedSpecifier
         * that finishes with a Partial specifier.
         * Example: `of button 3 of first card` (which can continue `..of current stack` etc)
         * `first button of first area of stack 3`
         * `first button of area two of stack 3`
         */
        ObjectSpecifier_compoundQueryWithoutTerminal: function(queriedSpecifier, partialSpecifier){
            // if the partialSpecfier refers to either area, card or stack
            // then go to its owner for the context
            // if it refers to the current card then find the owner for the context
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                systemObjectString = "card";
            } else {
                children.forEach((child) => {
                    if(child.ctorName == "systemObject"){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let finalPartial = partialSpecifier.interpret()(finalPart);
            let result = queriedSpecifier.interpret()(finalPartial);
            return result.id;
        },

        /**
         * A single non-terminal ObjectSpecifier is just a Partial
         * specifier by itself. When present outside of a QueriedSpecifier,
         * it will be interpreted in the current context and treated
         * as terminal/final. For example:
         *     button 4
         * by itself as a whole specifier will be interpreted as
         * `button 4 of this card`
         */
        ObjectSpecifier_singleNonTerminal: function(partialSpecifier){
            // A single non-terminal object specifier is one
            // whose terminal object is implicitly assumed to
            // be the card or the stack in which the current context part
            // exists.
            let children = partialSpecifier.children[0].children;
            let systemObjectString;
            if(children[0].sourceString == "current" && children[1].sourceString == "card"){
                return systemContext.getCurrentCardModel().id;
            } else {
                children.forEach((child) => {
                    if(child.sourceString == "part" || child.sourceString == "target" || child.ctorName == 'systemObject'){
                        systemObjectString = child.sourceString;
                    }
                });
            }
            // the systemObject is the target (defined in it's "target" part property), then we need to
            // first get the target property value (string) and interpret that
            if(systemObjectString == "target"){
                let targetPropValue = partContext.partProperties.getPropertyNamed(partContext, "target");
                let semantics = partContext._semantics;
                let matchObject = systemContext.grammar.match(targetPropValue, 'ObjectSpecifier');
                let targetId = semantics(matchObject).interpret();
                return targetId;
            } else if(systemObjectString == "current card"){
                systemObjectString = "card";
            }
            let finalPart = findFirstPossibleAncestor(partContext, systemObjectString);
            let result = partialSpecifier.interpret()(finalPart);
            return result.id;
        },

        ObjectSpecifier_singleTerminal: function(terminalSpecifier){
            let result = terminalSpecifier.interpret()(partContext);
            return result.id;
        },

        anyLiteral: function(theLiteral){
            return theLiteral.interpret();
        },

        stringLiteral: function(openQuote, text, closeQuote){
            return text.sourceString;
        },

        booleanLiteral: function(text){
            if(text.sourceString == 'true'){
                return true;
            }
            if(text.sourceString == 'false'){
                return false;
            }
            throw new Error(`Invalid boolean literal: ${text}`);
        },

        integerLiteral: function(negativeSign, integer){
            let int = parseInt(integer.sourceString);
            let hasNegative = (negativeSign.sourceString == "-");
            if(hasNegative){
                return -1 * int;
            }
            return int; 
        },

        floatLiteral: function(negativeSign, onesPlace, decimal, restPlace){
            let floatString = `${onesPlace.sourceString}.${restPlace.sourceString}`;
            let hasNegative = (negativeSign.sourceString == "-");
            let result = parseFloat(floatString);
            if(hasNegative){
                return -1 * result;
            }
            return result;
        },

        numericalKeyword: function(numeralName){
            switch(numeralName.sourceString){
            case 'first':
                return 1;
            case 'second':
                return 2;
            case 'third':
                return 3;
            case 'fourth':
                return 4;
            case 'fifth':
                return 5;
            case 'sixth':
                return 6;
            case 'seventh':
                return 7;
            case 'eighth':
                return 8;
            case 'ninth':
                return 9;
            case 'tenth':
                return 10;
            }

            return -1;
        },

        variableName: function(letterPlus, optionalDigits){
            // Lookup the variable in the part's
            // current execution context
            // If the variable is not a key on the object,
            // we throw an error: this means the variable has not yet
            // been defined but is being looked up.
            let value = systemContext.executionStack.current.get(this.sourceString);
            if(value == undefined){
                throw new STVariableReferenceError(
                    `Variable ${this.sourceString} has not been defined`);
            }
            return value;
        },

        comment: function(dashesLiteral, nonLineTerminatorChars){
            // Interpret doesn't do anything
            // with comments.
            return null;
        },

        _terminal(){

        }
    };
};





/***/ }),

/***/ "./node_modules/ohm-js/dist/built-in-rules.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/dist/built-in-rules.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = \"0\"..\"9\"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | \"a\"..\"f\"\n    | \"A\"..\"F\"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n}"},"BuiltInRules",null,null,{"alnum":["define",{"sourceInterval":[18,78]},"an alpha-numeric character",[],["alt",{"sourceInterval":[60,78]},["app",{"sourceInterval":[60,66]},"letter",[]],["app",{"sourceInterval":[73,78]},"digit",[]]]],"letter":["define",{"sourceInterval":[82,142]},"a letter",[],["alt",{"sourceInterval":[107,142]},["app",{"sourceInterval":[107,112]},"lower",[]],["app",{"sourceInterval":[119,124]},"upper",[]],["app",{"sourceInterval":[131,142]},"unicodeLtmo",[]]]],"digit":["define",{"sourceInterval":[146,177]},"a digit",[],["range",{"sourceInterval":[169,177]},"0","9"]],"hexDigit":["define",{"sourceInterval":[181,254]},"a hexadecimal digit",[],["alt",{"sourceInterval":[219,254]},["app",{"sourceInterval":[219,224]},"digit",[]],["range",{"sourceInterval":[231,239]},"a","f"],["range",{"sourceInterval":[246,254]},"A","F"]]],"ListOf":["define",{"sourceInterval":[258,336]},null,["elem","sep"],["alt",{"sourceInterval":[282,336]},["app",{"sourceInterval":[282,307]},"NonemptyListOf",[["param",{"sourceInterval":[297,301]},0],["param",{"sourceInterval":[303,306]},1]]],["app",{"sourceInterval":[314,336]},"EmptyListOf",[["param",{"sourceInterval":[326,330]},0],["param",{"sourceInterval":[332,335]},1]]]]],"NonemptyListOf":["define",{"sourceInterval":[340,388]},null,["elem","sep"],["seq",{"sourceInterval":[372,388]},["param",{"sourceInterval":[372,376]},0],["star",{"sourceInterval":[377,388]},["seq",{"sourceInterval":[378,386]},["param",{"sourceInterval":[378,381]},1],["param",{"sourceInterval":[382,386]},0]]]]],"EmptyListOf":["define",{"sourceInterval":[392,434]},null,["elem","sep"],["seq",{"sourceInterval":[438,438]}]],"listOf":["define",{"sourceInterval":[438,516]},null,["elem","sep"],["alt",{"sourceInterval":[462,516]},["app",{"sourceInterval":[462,487]},"nonemptyListOf",[["param",{"sourceInterval":[477,481]},0],["param",{"sourceInterval":[483,486]},1]]],["app",{"sourceInterval":[494,516]},"emptyListOf",[["param",{"sourceInterval":[506,510]},0],["param",{"sourceInterval":[512,515]},1]]]]],"nonemptyListOf":["define",{"sourceInterval":[520,568]},null,["elem","sep"],["seq",{"sourceInterval":[552,568]},["param",{"sourceInterval":[552,556]},0],["star",{"sourceInterval":[557,568]},["seq",{"sourceInterval":[558,566]},["param",{"sourceInterval":[558,561]},1],["param",{"sourceInterval":[562,566]},0]]]]],"emptyListOf":["define",{"sourceInterval":[572,614]},null,["elem","sep"],["seq",{"sourceInterval":[616,616]}]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/ohm-grammar.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/dist/ohm-grammar.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"Ohm {\n\n  Grammars\n    = Grammar*\n\n  Grammar\n    = ident SuperGrammar? \"{\" Rule* \"}\"\n\n  SuperGrammar\n    = \"<:\" ident\n\n  Rule\n    = ident Formals? ruleDescr? \"=\"  RuleBody  -- define\n    | ident Formals?            \":=\" OverrideRuleBody  -- override\n    | ident Formals?            \"+=\" RuleBody  -- extend\n\n  RuleBody\n    = \"|\"? NonemptyListOf<TopLevelTerm, \"|\">\n\n  TopLevelTerm\n    = Seq caseName  -- inline\n    | Seq\n\n  OverrideRuleBody\n    = \"|\"? NonemptyListOf<OverrideTopLevelTerm, \"|\">\n\n  OverrideTopLevelTerm\n    = \"...\"  -- superSplice\n    | TopLevelTerm\n\n  Formals\n    = \"<\" ListOf<ident, \",\"> \">\"\n\n  Params\n    = \"<\" ListOf<Seq, \",\"> \">\"\n\n  Alt\n    = NonemptyListOf<Seq, \"|\">\n\n  Seq\n    = Iter*\n\n  Iter\n    = Pred \"*\"  -- star\n    | Pred \"+\"  -- plus\n    | Pred \"?\"  -- opt\n    | Pred\n\n  Pred\n    = \"~\" Lex  -- not\n    | \"&\" Lex  -- lookahead\n    | Lex\n\n  Lex\n    = \"#\" Base  -- lex\n    | Base\n\n  Base\n    = ident Params? ~(ruleDescr? \"=\" | \":=\" | \"+=\")  -- application\n    | oneCharTerminal \"..\" oneCharTerminal           -- range\n    | terminal                                       -- terminal\n    | \"(\" Alt \")\"                                    -- paren\n\n  ruleDescr  (a rule description)\n    = \"(\" ruleDescrText \")\"\n\n  ruleDescrText\n    = (~\")\" any)*\n\n  caseName\n    = \"--\" (~\"\\n\" space)* name (~\"\\n\" space)* (\"\\n\" | &\"}\")\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n  ident  (an identifier)\n    = name\n\n  terminal\n    = \"\\\"\" terminalChar* \"\\\"\"\n\n  oneCharTerminal\n    = \"\\\"\" terminalChar \"\\\"\"\n\n  terminalChar\n    = escapeChar\n    | ~\"\\\\\" ~\"\\\"\" ~\"\\n\" any\n\n  escapeChar  (an escape sequence)\n    = \"\\\\\\\\\"                                     -- backslash\n    | \"\\\\\\\"\"                                     -- doubleQuote\n    | \"\\\\\\'\"                                     -- singleQuote\n    | \"\\\\b\"                                      -- backspace\n    | \"\\\\n\"                                      -- lineFeed\n    | \"\\\\r\"                                      -- carriageReturn\n    | \"\\\\t\"                                      -- tab\n    | \"\\\\u\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\n    | \"\\\\x\" hexDigit hexDigit                    -- hexEscape\n\n  space\n   += comment\n\n  comment\n    = \"//\" (~\"\\n\" any)* &(\"\\n\" | end)  -- singleLine\n    | \"/*\" (~\"*/\" any)* \"*/\"  -- multiLine\n\n  tokens = token*\n\n  token = caseName | comment | ident | operator | punctuation | terminal | any\n\n  operator = \"<:\" | \"=\" | \":=\" | \"+=\" | \"*\" | \"+\" | \"?\" | \"~\" | \"&\"\n\n  punctuation = \"<\" | \">\" | \",\" | \"--\"\n}"},"Ohm",null,"Grammars",{"Grammars":["define",{"sourceInterval":[9,32]},null,[],["star",{"sourceInterval":[24,32]},["app",{"sourceInterval":[24,31]},"Grammar",[]]]],"Grammar":["define",{"sourceInterval":[36,83]},null,[],["seq",{"sourceInterval":[50,83]},["app",{"sourceInterval":[50,55]},"ident",[]],["opt",{"sourceInterval":[56,69]},["app",{"sourceInterval":[56,68]},"SuperGrammar",[]]],["terminal",{"sourceInterval":[70,73]},"{"],["star",{"sourceInterval":[74,79]},["app",{"sourceInterval":[74,78]},"Rule",[]]],["terminal",{"sourceInterval":[80,83]},"}"]]],"SuperGrammar":["define",{"sourceInterval":[87,116]},null,[],["seq",{"sourceInterval":[106,116]},["terminal",{"sourceInterval":[106,110]},"<:"],["app",{"sourceInterval":[111,116]},"ident",[]]]],"Rule_define":["define",{"sourceInterval":[131,181]},null,[],["seq",{"sourceInterval":[131,170]},["app",{"sourceInterval":[131,136]},"ident",[]],["opt",{"sourceInterval":[137,145]},["app",{"sourceInterval":[137,144]},"Formals",[]]],["opt",{"sourceInterval":[146,156]},["app",{"sourceInterval":[146,155]},"ruleDescr",[]]],["terminal",{"sourceInterval":[157,160]},"="],["app",{"sourceInterval":[162,170]},"RuleBody",[]]]],"Rule_override":["define",{"sourceInterval":[188,248]},null,[],["seq",{"sourceInterval":[188,235]},["app",{"sourceInterval":[188,193]},"ident",[]],["opt",{"sourceInterval":[194,202]},["app",{"sourceInterval":[194,201]},"Formals",[]]],["terminal",{"sourceInterval":[214,218]},":="],["app",{"sourceInterval":[219,235]},"OverrideRuleBody",[]]]],"Rule_extend":["define",{"sourceInterval":[255,305]},null,[],["seq",{"sourceInterval":[255,294]},["app",{"sourceInterval":[255,260]},"ident",[]],["opt",{"sourceInterval":[261,269]},["app",{"sourceInterval":[261,268]},"Formals",[]]],["terminal",{"sourceInterval":[281,285]},"+="],["app",{"sourceInterval":[286,294]},"RuleBody",[]]]],"Rule":["define",{"sourceInterval":[120,305]},null,[],["alt",{"sourceInterval":[131,305]},["app",{"sourceInterval":[131,170]},"Rule_define",[]],["app",{"sourceInterval":[188,235]},"Rule_override",[]],["app",{"sourceInterval":[255,294]},"Rule_extend",[]]]],"RuleBody":["define",{"sourceInterval":[309,362]},null,[],["seq",{"sourceInterval":[324,362]},["opt",{"sourceInterval":[324,328]},["terminal",{"sourceInterval":[324,327]},"|"]],["app",{"sourceInterval":[329,362]},"NonemptyListOf",[["app",{"sourceInterval":[344,356]},"TopLevelTerm",[]],["terminal",{"sourceInterval":[358,361]},"|"]]]]],"TopLevelTerm_inline":["define",{"sourceInterval":[385,408]},null,[],["seq",{"sourceInterval":[385,397]},["app",{"sourceInterval":[385,388]},"Seq",[]],["app",{"sourceInterval":[389,397]},"caseName",[]]]],"TopLevelTerm":["define",{"sourceInterval":[366,418]},null,[],["alt",{"sourceInterval":[385,418]},["app",{"sourceInterval":[385,397]},"TopLevelTerm_inline",[]],["app",{"sourceInterval":[415,418]},"Seq",[]]]],"OverrideRuleBody":["define",{"sourceInterval":[422,491]},null,[],["seq",{"sourceInterval":[445,491]},["opt",{"sourceInterval":[445,449]},["terminal",{"sourceInterval":[445,448]},"|"]],["app",{"sourceInterval":[450,491]},"NonemptyListOf",[["app",{"sourceInterval":[465,485]},"OverrideTopLevelTerm",[]],["terminal",{"sourceInterval":[487,490]},"|"]]]]],"OverrideTopLevelTerm_superSplice":["define",{"sourceInterval":[522,543]},null,[],["terminal",{"sourceInterval":[522,527]},"..."]],"OverrideTopLevelTerm":["define",{"sourceInterval":[495,562]},null,[],["alt",{"sourceInterval":[522,562]},["app",{"sourceInterval":[522,527]},"OverrideTopLevelTerm_superSplice",[]],["app",{"sourceInterval":[550,562]},"TopLevelTerm",[]]]],"Formals":["define",{"sourceInterval":[566,606]},null,[],["seq",{"sourceInterval":[580,606]},["terminal",{"sourceInterval":[580,583]},"<"],["app",{"sourceInterval":[584,602]},"ListOf",[["app",{"sourceInterval":[591,596]},"ident",[]],["terminal",{"sourceInterval":[598,601]},","]]],["terminal",{"sourceInterval":[603,606]},">"]]],"Params":["define",{"sourceInterval":[610,647]},null,[],["seq",{"sourceInterval":[623,647]},["terminal",{"sourceInterval":[623,626]},"<"],["app",{"sourceInterval":[627,643]},"ListOf",[["app",{"sourceInterval":[634,637]},"Seq",[]],["terminal",{"sourceInterval":[639,642]},","]]],["terminal",{"sourceInterval":[644,647]},">"]]],"Alt":["define",{"sourceInterval":[651,685]},null,[],["app",{"sourceInterval":[661,685]},"NonemptyListOf",[["app",{"sourceInterval":[676,679]},"Seq",[]],["terminal",{"sourceInterval":[681,684]},"|"]]]],"Seq":["define",{"sourceInterval":[689,704]},null,[],["star",{"sourceInterval":[699,704]},["app",{"sourceInterval":[699,703]},"Iter",[]]]],"Iter_star":["define",{"sourceInterval":[719,736]},null,[],["seq",{"sourceInterval":[719,727]},["app",{"sourceInterval":[719,723]},"Pred",[]],["terminal",{"sourceInterval":[724,727]},"*"]]],"Iter_plus":["define",{"sourceInterval":[743,760]},null,[],["seq",{"sourceInterval":[743,751]},["app",{"sourceInterval":[743,747]},"Pred",[]],["terminal",{"sourceInterval":[748,751]},"+"]]],"Iter_opt":["define",{"sourceInterval":[767,783]},null,[],["seq",{"sourceInterval":[767,775]},["app",{"sourceInterval":[767,771]},"Pred",[]],["terminal",{"sourceInterval":[772,775]},"?"]]],"Iter":["define",{"sourceInterval":[708,794]},null,[],["alt",{"sourceInterval":[719,794]},["app",{"sourceInterval":[719,727]},"Iter_star",[]],["app",{"sourceInterval":[743,751]},"Iter_plus",[]],["app",{"sourceInterval":[767,775]},"Iter_opt",[]],["app",{"sourceInterval":[790,794]},"Pred",[]]]],"Pred_not":["define",{"sourceInterval":[809,824]},null,[],["seq",{"sourceInterval":[809,816]},["terminal",{"sourceInterval":[809,812]},"~"],["app",{"sourceInterval":[813,816]},"Lex",[]]]],"Pred_lookahead":["define",{"sourceInterval":[831,852]},null,[],["seq",{"sourceInterval":[831,838]},["terminal",{"sourceInterval":[831,834]},"&"],["app",{"sourceInterval":[835,838]},"Lex",[]]]],"Pred":["define",{"sourceInterval":[798,862]},null,[],["alt",{"sourceInterval":[809,862]},["app",{"sourceInterval":[809,816]},"Pred_not",[]],["app",{"sourceInterval":[831,838]},"Pred_lookahead",[]],["app",{"sourceInterval":[859,862]},"Lex",[]]]],"Lex_lex":["define",{"sourceInterval":[876,892]},null,[],["seq",{"sourceInterval":[876,884]},["terminal",{"sourceInterval":[876,879]},"#"],["app",{"sourceInterval":[880,884]},"Base",[]]]],"Lex":["define",{"sourceInterval":[866,903]},null,[],["alt",{"sourceInterval":[876,903]},["app",{"sourceInterval":[876,884]},"Lex_lex",[]],["app",{"sourceInterval":[899,903]},"Base",[]]]],"Base_application":["define",{"sourceInterval":[918,979]},null,[],["seq",{"sourceInterval":[918,963]},["app",{"sourceInterval":[918,923]},"ident",[]],["opt",{"sourceInterval":[924,931]},["app",{"sourceInterval":[924,930]},"Params",[]]],["not",{"sourceInterval":[932,963]},["alt",{"sourceInterval":[934,962]},["seq",{"sourceInterval":[934,948]},["opt",{"sourceInterval":[934,944]},["app",{"sourceInterval":[934,943]},"ruleDescr",[]]],["terminal",{"sourceInterval":[945,948]},"="]],["terminal",{"sourceInterval":[951,955]},":="],["terminal",{"sourceInterval":[958,962]},"+="]]]]],"Base_range":["define",{"sourceInterval":[986,1041]},null,[],["seq",{"sourceInterval":[986,1022]},["app",{"sourceInterval":[986,1001]},"oneCharTerminal",[]],["terminal",{"sourceInterval":[1002,1006]},".."],["app",{"sourceInterval":[1007,1022]},"oneCharTerminal",[]]]],"Base_terminal":["define",{"sourceInterval":[1048,1106]},null,[],["app",{"sourceInterval":[1048,1056]},"terminal",[]]],"Base_paren":["define",{"sourceInterval":[1113,1168]},null,[],["seq",{"sourceInterval":[1113,1124]},["terminal",{"sourceInterval":[1113,1116]},"("],["app",{"sourceInterval":[1117,1120]},"Alt",[]],["terminal",{"sourceInterval":[1121,1124]},")"]]],"Base":["define",{"sourceInterval":[907,1168]},null,[],["alt",{"sourceInterval":[918,1168]},["app",{"sourceInterval":[918,963]},"Base_application",[]],["app",{"sourceInterval":[986,1022]},"Base_range",[]],["app",{"sourceInterval":[1048,1056]},"Base_terminal",[]],["app",{"sourceInterval":[1113,1124]},"Base_paren",[]]]],"ruleDescr":["define",{"sourceInterval":[1172,1231]},"a rule description",[],["seq",{"sourceInterval":[1210,1231]},["terminal",{"sourceInterval":[1210,1213]},"("],["app",{"sourceInterval":[1214,1227]},"ruleDescrText",[]],["terminal",{"sourceInterval":[1228,1231]},")"]]],"ruleDescrText":["define",{"sourceInterval":[1235,1266]},null,[],["star",{"sourceInterval":[1255,1266]},["seq",{"sourceInterval":[1256,1264]},["not",{"sourceInterval":[1256,1260]},["terminal",{"sourceInterval":[1257,1260]},")"]],["app",{"sourceInterval":[1261,1264]},"any",[]]]]],"caseName":["define",{"sourceInterval":[1270,1338]},null,[],["seq",{"sourceInterval":[1285,1338]},["terminal",{"sourceInterval":[1285,1289]},"--"],["star",{"sourceInterval":[1290,1304]},["seq",{"sourceInterval":[1291,1302]},["not",{"sourceInterval":[1291,1296]},["terminal",{"sourceInterval":[1292,1296]},"\n"]],["app",{"sourceInterval":[1297,1302]},"space",[]]]],["app",{"sourceInterval":[1305,1309]},"name",[]],["star",{"sourceInterval":[1310,1324]},["seq",{"sourceInterval":[1311,1322]},["not",{"sourceInterval":[1311,1316]},["terminal",{"sourceInterval":[1312,1316]},"\n"]],["app",{"sourceInterval":[1317,1322]},"space",[]]]],["alt",{"sourceInterval":[1326,1337]},["terminal",{"sourceInterval":[1326,1330]},"\n"],["lookahead",{"sourceInterval":[1333,1337]},["terminal",{"sourceInterval":[1334,1337]},"}"]]]]],"name":["define",{"sourceInterval":[1342,1382]},"a name",[],["seq",{"sourceInterval":[1363,1382]},["app",{"sourceInterval":[1363,1372]},"nameFirst",[]],["star",{"sourceInterval":[1373,1382]},["app",{"sourceInterval":[1373,1381]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[1386,1418]},null,[],["alt",{"sourceInterval":[1402,1418]},["terminal",{"sourceInterval":[1402,1405]},"_"],["app",{"sourceInterval":[1412,1418]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[1422,1452]},null,[],["alt",{"sourceInterval":[1437,1452]},["terminal",{"sourceInterval":[1437,1440]},"_"],["app",{"sourceInterval":[1447,1452]},"alnum",[]]]],"ident":["define",{"sourceInterval":[1456,1489]},"an identifier",[],["app",{"sourceInterval":[1485,1489]},"name",[]]],"terminal":["define",{"sourceInterval":[1493,1531]},null,[],["seq",{"sourceInterval":[1508,1531]},["terminal",{"sourceInterval":[1508,1512]},"\""],["star",{"sourceInterval":[1513,1526]},["app",{"sourceInterval":[1513,1525]},"terminalChar",[]]],["terminal",{"sourceInterval":[1527,1531]},"\""]]],"oneCharTerminal":["define",{"sourceInterval":[1535,1579]},null,[],["seq",{"sourceInterval":[1557,1579]},["terminal",{"sourceInterval":[1557,1561]},"\""],["app",{"sourceInterval":[1562,1574]},"terminalChar",[]],["terminal",{"sourceInterval":[1575,1579]},"\""]]],"terminalChar":["define",{"sourceInterval":[1583,1640]},null,[],["alt",{"sourceInterval":[1602,1640]},["app",{"sourceInterval":[1602,1612]},"escapeChar",[]],["seq",{"sourceInterval":[1619,1640]},["not",{"sourceInterval":[1619,1624]},["terminal",{"sourceInterval":[1620,1624]},"\\"]],["not",{"sourceInterval":[1625,1630]},["terminal",{"sourceInterval":[1626,1630]},"\""]],["not",{"sourceInterval":[1631,1636]},["terminal",{"sourceInterval":[1632,1636]},"\n"]],["app",{"sourceInterval":[1637,1640]},"any",[]]]]],"escapeChar_backslash":["define",{"sourceInterval":[1683,1738]},null,[],["terminal",{"sourceInterval":[1683,1689]},"\\\\"]],"escapeChar_doubleQuote":["define",{"sourceInterval":[1745,1802]},null,[],["terminal",{"sourceInterval":[1745,1751]},"\\\""]],"escapeChar_singleQuote":["define",{"sourceInterval":[1809,1866]},null,[],["terminal",{"sourceInterval":[1809,1815]},"\\'"]],"escapeChar_backspace":["define",{"sourceInterval":[1873,1928]},null,[],["terminal",{"sourceInterval":[1873,1878]},"\\b"]],"escapeChar_lineFeed":["define",{"sourceInterval":[1935,1989]},null,[],["terminal",{"sourceInterval":[1935,1940]},"\\n"]],"escapeChar_carriageReturn":["define",{"sourceInterval":[1996,2056]},null,[],["terminal",{"sourceInterval":[1996,2001]},"\\r"]],"escapeChar_tab":["define",{"sourceInterval":[2063,2112]},null,[],["terminal",{"sourceInterval":[2063,2068]},"\\t"]],"escapeChar_unicodeEscape":["define",{"sourceInterval":[2119,2178]},null,[],["seq",{"sourceInterval":[2119,2160]},["terminal",{"sourceInterval":[2119,2124]},"\\u"],["app",{"sourceInterval":[2125,2133]},"hexDigit",[]],["app",{"sourceInterval":[2134,2142]},"hexDigit",[]],["app",{"sourceInterval":[2143,2151]},"hexDigit",[]],["app",{"sourceInterval":[2152,2160]},"hexDigit",[]]]],"escapeChar_hexEscape":["define",{"sourceInterval":[2185,2240]},null,[],["seq",{"sourceInterval":[2185,2208]},["terminal",{"sourceInterval":[2185,2190]},"\\x"],["app",{"sourceInterval":[2191,2199]},"hexDigit",[]],["app",{"sourceInterval":[2200,2208]},"hexDigit",[]]]],"escapeChar":["define",{"sourceInterval":[1644,2240]},"an escape sequence",[],["alt",{"sourceInterval":[1683,2240]},["app",{"sourceInterval":[1683,1689]},"escapeChar_backslash",[]],["app",{"sourceInterval":[1745,1751]},"escapeChar_doubleQuote",[]],["app",{"sourceInterval":[1809,1815]},"escapeChar_singleQuote",[]],["app",{"sourceInterval":[1873,1878]},"escapeChar_backspace",[]],["app",{"sourceInterval":[1935,1940]},"escapeChar_lineFeed",[]],["app",{"sourceInterval":[1996,2001]},"escapeChar_carriageReturn",[]],["app",{"sourceInterval":[2063,2068]},"escapeChar_tab",[]],["app",{"sourceInterval":[2119,2160]},"escapeChar_unicodeEscape",[]],["app",{"sourceInterval":[2185,2208]},"escapeChar_hexEscape",[]]]],"space":["extend",{"sourceInterval":[2244,2263]},null,[],["app",{"sourceInterval":[2256,2263]},"comment",[]]],"comment_singleLine":["define",{"sourceInterval":[2281,2327]},null,[],["seq",{"sourceInterval":[2281,2312]},["terminal",{"sourceInterval":[2281,2285]},"//"],["star",{"sourceInterval":[2286,2298]},["seq",{"sourceInterval":[2287,2296]},["not",{"sourceInterval":[2287,2292]},["terminal",{"sourceInterval":[2288,2292]},"\n"]],["app",{"sourceInterval":[2293,2296]},"any",[]]]],["lookahead",{"sourceInterval":[2299,2312]},["alt",{"sourceInterval":[2301,2311]},["terminal",{"sourceInterval":[2301,2305]},"\n"],["app",{"sourceInterval":[2308,2311]},"end",[]]]]]],"comment_multiLine":["define",{"sourceInterval":[2334,2370]},null,[],["seq",{"sourceInterval":[2334,2356]},["terminal",{"sourceInterval":[2334,2338]},"/*"],["star",{"sourceInterval":[2339,2351]},["seq",{"sourceInterval":[2340,2349]},["not",{"sourceInterval":[2340,2345]},["terminal",{"sourceInterval":[2341,2345]},"*/"]],["app",{"sourceInterval":[2346,2349]},"any",[]]]],["terminal",{"sourceInterval":[2352,2356]},"*/"]]],"comment":["define",{"sourceInterval":[2267,2370]},null,[],["alt",{"sourceInterval":[2281,2370]},["app",{"sourceInterval":[2281,2312]},"comment_singleLine",[]],["app",{"sourceInterval":[2334,2356]},"comment_multiLine",[]]]],"tokens":["define",{"sourceInterval":[2374,2389]},null,[],["star",{"sourceInterval":[2383,2389]},["app",{"sourceInterval":[2383,2388]},"token",[]]]],"token":["define",{"sourceInterval":[2393,2469]},null,[],["alt",{"sourceInterval":[2401,2469]},["app",{"sourceInterval":[2401,2409]},"caseName",[]],["app",{"sourceInterval":[2412,2419]},"comment",[]],["app",{"sourceInterval":[2422,2427]},"ident",[]],["app",{"sourceInterval":[2430,2438]},"operator",[]],["app",{"sourceInterval":[2441,2452]},"punctuation",[]],["app",{"sourceInterval":[2455,2463]},"terminal",[]],["app",{"sourceInterval":[2466,2469]},"any",[]]]],"operator":["define",{"sourceInterval":[2473,2538]},null,[],["alt",{"sourceInterval":[2484,2538]},["terminal",{"sourceInterval":[2484,2488]},"<:"],["terminal",{"sourceInterval":[2491,2494]},"="],["terminal",{"sourceInterval":[2497,2501]},":="],["terminal",{"sourceInterval":[2504,2508]},"+="],["terminal",{"sourceInterval":[2511,2514]},"*"],["terminal",{"sourceInterval":[2517,2520]},"+"],["terminal",{"sourceInterval":[2523,2526]},"?"],["terminal",{"sourceInterval":[2529,2532]},"~"],["terminal",{"sourceInterval":[2535,2538]},"&"]]],"punctuation":["define",{"sourceInterval":[2542,2578]},null,[],["alt",{"sourceInterval":[2556,2578]},["terminal",{"sourceInterval":[2556,2559]},"<"],["terminal",{"sourceInterval":[2562,2565]},">"],["terminal",{"sourceInterval":[2568,2571]},","],["terminal",{"sourceInterval":[2574,2578]},"--"]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/dist/operations-and-attributes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ohm-js/dist/operations-and-attributes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ohm = __webpack_require__(/*! .. */ "./node_modules/ohm-js/src/main.js");
module.exports = ohm.makeRecipe(["grammar",{"source":"OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = \"(\" ListOf<name, \",\"> \")\"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n}"},"OperationsAndAttributes",null,"AttributeSignature",{"AttributeSignature":["define",{"sourceInterval":[29,58]},null,[],["app",{"sourceInterval":[54,58]},"name",[]]],"OperationSignature":["define",{"sourceInterval":[62,100]},null,[],["seq",{"sourceInterval":[87,100]},["app",{"sourceInterval":[87,91]},"name",[]],["opt",{"sourceInterval":[92,100]},["app",{"sourceInterval":[92,99]},"Formals",[]]]]],"Formals":["define",{"sourceInterval":[104,143]},null,[],["seq",{"sourceInterval":[118,143]},["terminal",{"sourceInterval":[118,121]},"("],["app",{"sourceInterval":[122,139]},"ListOf",[["app",{"sourceInterval":[129,133]},"name",[]],["terminal",{"sourceInterval":[135,138]},","]]],["terminal",{"sourceInterval":[140,143]},")"]]],"name":["define",{"sourceInterval":[147,187]},"a name",[],["seq",{"sourceInterval":[168,187]},["app",{"sourceInterval":[168,177]},"nameFirst",[]],["star",{"sourceInterval":[178,187]},["app",{"sourceInterval":[178,186]},"nameRest",[]]]]],"nameFirst":["define",{"sourceInterval":[191,223]},null,[],["alt",{"sourceInterval":[207,223]},["terminal",{"sourceInterval":[207,210]},"_"],["app",{"sourceInterval":[217,223]},"letter",[]]]],"nameRest":["define",{"sourceInterval":[227,257]},null,[],["alt",{"sourceInterval":[242,257]},["terminal",{"sourceInterval":[242,245]},"_"],["app",{"sourceInterval":[252,257]},"alnum",[]]]]}]);


/***/ }),

/***/ "./node_modules/ohm-js/extras/VisitorFamily.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/extras/VisitorFamily.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ../src/common */ "./node_modules/ohm-js/src/common.js").assert;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Helpers

function getProp(name, thing, fn) {
  return fn(thing[name]);
}

function mapProp(name, thing, fn) {
  return thing[name].map(fn);
}

// Returns a function that will walk a single property of a node.
// `descriptor` is a string indicating the property name, optionally ending
// with '[]' (e.g., 'children[]').
function getPropWalkFn(descriptor) {
  const parts = descriptor.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor);
}

function getProps(walkFns, thing, fn) {
  return walkFns.map(walkFn => walkFn(thing, fn));
}

function getWalkFn(shape) {
  if (typeof shape === 'string') {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === 'function', 'Expected a string, Array, or function');
    assert(shape.length === 2, 'Expected a function of arity 2, got ' + shape.length);
    return shape;
  }
}

function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}

function trim(s) {
  return s.trim();
}

function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === '') {
    const name = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(',').map(trim);
    }
    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {
      return {name, formals: params};
    }
  }
  throw new Error('Invalid operation signature: ' + sig);
}

/*
  A VisitorFamily contains a set of recursive operations that are defined over some kind of
  tree structure. The `config` parameter specifies how to walk the tree:
  - 'getTag' is function which, given a node in the tree, returns the node's 'tag' (type)
  - 'shapes' an object that maps from a tag to a value that describes how to recursively
    evaluate the operation for nodes of that type. The value can be:
    * a string indicating the property name that holds that node's only child
    * an Array of property names (or an empty array indicating a leaf type), or
    * a function taking two arguments (node, fn), and returning an Array which is the result
      of apply `fn` to each of the node's children.
 */
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;

  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error('heeey!');
  };
  this.operations = {};

  this._arities = Object.create(null);
  this._getChildren = Object.create(null);

  const self = this;
  Object.keys(this._shapes).forEach(k => {
    const shape = self._shapes[k];
    self._getChildren[k] = getWalkFn(shape);

    // A function means the arity isn't fixed, so don't put an entry in the arity map.
    if (typeof shape !== 'function') {
      self._arities[k] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = function(thing) { return new self.Adapter(thing, self); };
}

VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};

VisitorFamily.prototype._checkActionDict = function(dict) {
  const self = this;
  Object.keys(dict).forEach(k => {
    assert(k in self._getChildren, "Unrecognized action name '" + k + "'");
    const action = dict[k];
    assert(typeof action === 'function', "Key '" + k + "': expected function, got " + action);
    if (k in self._arities) {
      const expected = self._arities[k];
      const actual = dict[k].length;
      assert(actual === expected,
          "Action '" + k + "' has the wrong arity: expected " + expected + ', got ' + actual);
    }
  });
};

VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const name = sig.name;
  this._checkActionDict(actions);
  this.operations[name] = {
    name,
    formals: sig.formals,
    actions
  };

  const family = this;
  this.Adapter.prototype[name] = function() {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name + "'");

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let i = 0; i < arguments.length; i++) {
      args[sig.formals[i]] = arguments[i];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = actions[tag].apply(this, family._getChildren[tag](this._adaptee, family._wrap));
    this.args = oldArgs;
    return ans;
  };
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = VisitorFamily;


/***/ }),

/***/ "./node_modules/ohm-js/extras/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/extras/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  VisitorFamily: __webpack_require__(/*! ./VisitorFamily */ "./node_modules/ohm-js/extras/VisitorFamily.js"),
  semanticsForToAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").semantics,
  toAST: __webpack_require__(/*! ./semantics-toAST */ "./node_modules/ohm-js/extras/semantics-toAST.js").helper
};


/***/ }),

/***/ "./node_modules/ohm-js/extras/semantics-toAST.js":
/*!*******************************************************!*\
  !*** ./node_modules/ohm-js/extras/semantics-toAST.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ../src/pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const MatchResult = __webpack_require__(/*! ../src/MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const Grammar = __webpack_require__(/*! ../src/Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

const defaultOperation = {
  _terminal() {
    return this.primitiveValue;
  },

  _nonterminal(children) {
    const ctorName = this._node.ctorName;
    const mapping = this.args.mapping;

    // without customization
    if (!mapping.hasOwnProperty(ctorName)) {
      // intermediate node
      if (this._node instanceof pexprs.Alt || this._node instanceof pexprs.Apply) {
        return children[0].toAST(mapping);
      }

      // lexical rule
      if (this.isLexical()) {
        return this.sourceString;
      }

      // singular node (e.g. only surrounded by literals or lookaheads)
      const realChildren = children.filter(child => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }

      // rest: terms with multiple children
    }

    // direct forward
    if (typeof mapping[ctorName] === 'number') {
      return children[mapping[ctorName]].toAST(mapping);
    }

    // named/mapped children or unnamed children ('0', '1', '2', ...)
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === 'number') {
        // direct forward
        node[prop] = children[mappedProp].toAST(mapping);
      } else if ((typeof mappedProp === 'string') || (typeof mappedProp === 'boolean') ||
          (mappedProp === null)) {
        // primitive value
        node[prop] = mappedProp;
      } else if ((typeof mappedProp === 'object') && (mappedProp instanceof Number)) {
        // primitive number (must be unboxed)
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === 'function') {
        // computed value
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === undefined) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          // delete predefined 'type' properties, like 'type', if explicitely removed
          delete node[prop];
        }
      }
    }
    return node;
  },

  _iter(children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }

    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },

  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },

  EmptyListOf() {
    return [];
  }
};

// Returns a plain JavaScript object that includes an abstract syntax tree (AST)
// for the given match result `res` containg a concrete syntax tree (CST) and grammar.
// The optional `mapping` parameter can be used to customize how the nodes of the CST
// are mapped to the AST (see /doc/extras.md#toastmatchresult-mapping).
function toAST(res, mapping) {
  if (!(res instanceof MatchResult) || res.failed()) {
    throw new Error('toAST() expects a succesfull MatchResult as first parameter');
  }

  mapping = extend({}, mapping);
  const operation = extend({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === 'function') {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g = res._cst.grammar;
  const s = g.createSemantics().addOperation('toAST(mapping)', operation);
  return s(res).toAST(mapping);
}

// Returns a semantics containg the toAST(mapping) operation for the given grammar g.
function semanticsForToAST(g) {
  if (!(g instanceof Grammar)) {
    throw new Error('semanticsToAST() expects a Grammar as parameter');
  }

  return g.createSemantics().addOperation('toAST(mapping)', defaultOperation);
}

module.exports = {
  helper: toAST,
  semantics: semanticsForToAST
};


/***/ }),

/***/ "./node_modules/ohm-js/node_modules/is-buffer/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ohm-js/node_modules/is-buffer/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "./node_modules/ohm-js/package.json":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/package.json ***!
  \******************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bin, bugs, contributors, dependencies, description, devDependencies, engines, homepage, keywords, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_args\":[[\"ohm-js@15.4.1\",\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\"]],\"_from\":\"ohm-js@15.4.1\",\"_id\":\"ohm-js@15.4.1\",\"_inBundle\":false,\"_integrity\":\"sha512-ob5b6hnlg6tR73Zxd8ON/MQND36SgEDbKQYrzdDVVyTNa3d3aJ/YyobB7mItJ8YXNTZGgZ/eUiLtfo2CU0uREA==\",\"_location\":\"/ohm-js\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"ohm-js@15.4.1\",\"name\":\"ohm-js\",\"escapedName\":\"ohm-js\",\"rawSpec\":\"15.4.1\",\"saveSpec\":null,\"fetchSpec\":\"15.4.1\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/ohm-js/-/ohm-js-15.4.1.tgz\",\"_spec\":\"15.4.1\",\"_where\":\"/Users/danielkrasner/REPOS/ULex/SimpleTalk\",\"author\":{\"name\":\"Alex Warth\",\"email\":\"alexwarth@gmail.com\",\"url\":\"http://tinlizzie.org/~awarth\"},\"bin\":{\"ohm-js\":\"src/ohm-cmd.js\"},\"bugs\":{\"url\":\"https://github.com/harc/ohm/issues\"},\"contributors\":[{\"name\":\"Patrick Dubroy\",\"email\":\"pdubroy@gmail.com\"},{\"name\":\"Meixian Li\",\"email\":\"lmeixian@gmail.com\"},{\"name\":\"Marko Rder\",\"email\":\"m.roeder@photon-software.de\"},{\"name\":\"Tony Garnock-Jones\",\"email\":\"tonygarnockjones@gmail.com\"},{\"name\":\"Saketh Kasibatla\",\"email\":\"sake.kasi@gmail.com\"},{\"name\":\"Lionel Landwerlin\",\"email\":\"llandwerlin@gmail.com\"},{\"name\":\"Jason Merrill\",\"email\":\"jwmerrill@gmail.com\"},{\"name\":\"Ray Toal\",\"email\":\"rtoal@lmu.edu\"},{\"name\":\"Yoshiki Ohshima\",\"email\":\"Yoshiki.Ohshima@acm.org\"},{\"name\":\"stagas\",\"email\":\"gstagas@gmail.com\"},{\"name\":\"Jonathan Edwards\",\"email\":\"JonathanMEdwards@gmail.com\"},{\"name\":\"Neil Jewers\",\"email\":\"njjewers@uwaterloo.ca\"},{\"name\":\"Mike Niebling\",\"email\":\"(none)\",\"url\":\"none\"},{\"name\":\"Arthur Carabott\",\"email\":\"arthurc@gmail.com\"},{\"name\":\"AngryPowman\",\"email\":\"angrypowman@qq.com\"},{\"name\":\"Luca Guzzon\",\"email\":\"luca.guzzon@gmail.com\"},{\"name\":\"Leslie Ying\",\"email\":\"acetophore@users.noreply.github.com\"},{\"name\":\"Stan Rozenraukh\",\"email\":\"stan@stanistan.com\"},{\"name\":\"Stephan Seidt\",\"email\":\"stephan.seidt@gmail.com\"},{\"name\":\"Thomas Nyberg\",\"email\":\"tomnyberg@gmail.com\"},{\"name\":\"Justin Chase\",\"email\":\"justin.m.chase@gmail.com\"},{\"name\":\"Vse Mozhet Byt\",\"email\":\"vsemozhetbyt@gmail.com\"},{\"name\":\"Wil Chung\",\"email\":\"10446+iamwilhelm@users.noreply.github.com\"},{\"name\":\"Daniel Tomlinson\",\"email\":\"DanielTomlinson@me.com\"},{\"name\":\"abego\",\"email\":\"ub@abego-software.de\"},{\"name\":\"acslk\",\"email\":\"d_vd415@hotmail.com\"},{\"name\":\"codeZeilen\",\"email\":\"codeZeilen@users.noreply.github.com\"},{\"name\":\"owch\",\"email\":\"bowenrainyday@gmail.com\"},{\"name\":\"sfinnie\",\"email\":\"scott.finnie@gmail.com\"},{\"name\":\"Milan Lajto\",\"email\":\"milan.lajtos@me.com\"}],\"dependencies\":{\"is-buffer\":\"^2.0.4\",\"util-extend\":\"^1.0.3\"},\"description\":\"An object-oriented language for parsing and pattern matching\",\"devDependencies\":{\"@types/tape\":\"^4.13.0\",\"eslint\":\"^7.9.0\",\"eslint-config-google\":\"^0.14.0\",\"eslint-plugin-camelcase-ohm\":\"^0.2.1\",\"eslint-plugin-no-extension-in-require\":\"^0.2.0\",\"eslint-plugin-tape\":\"^1.1.0\",\"husky\":\"^4.2.5\",\"jsdom\":\"^9.9.1\",\"json\":\"^9.0.6\",\"markscript\":\"^0.5.0\",\"node-static\":\"^0.7.11\",\"nodemon\":\"^2.0.4\",\"ohm-grammar-ecmascript\":\"^0.5.0\",\"tap-spec\":\"^5.0.0\",\"tape\":\"^5.0.1\",\"tape-catch\":\"^1.0.6\",\"ts-loader\":\"^8.0.4\",\"ts-node\":\"^9.0.0\",\"typescript\":\"^4.0.3\",\"walk-sync\":\"^2.2.0\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^3.3.12\"},\"engines\":{\"node\":\">=0.12.1\"},\"homepage\":\"https://ohmlang.github.io/\",\"keywords\":[\"parser\",\"compiler\",\"pattern matching\",\"pattern-matching\",\"ometa\",\"ometa/js\",\"ometa-js\",\"ometajs\",\"rapid\",\"prototyping\"],\"license\":\"MIT\",\"main\":\"src/main.js\",\"name\":\"ohm-js\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/harc/ohm.git\"},\"scripts\":{\"bootstrap\":\"bash bin/bootstrap --test || (echo 'Bootstrap failed.' && mv -v dist/ohm-grammar.js.old dist/ohm-grammar.js && mv -v dist/built-in-rules.js.old dist/built-in-rules.js && mv -v dist/operations-and-attributes.js.old dist/operations-and-attributes.js)\",\"build\":\"yarn build-debug && webpack --mode=production\",\"build-debug\":\"webpack --mode=development\",\"clean\":\"rm -f dist/ohm.js dist/ohm.min.js\",\"lint\":\"eslint . --ignore-path ../.eslintignore\",\"postinstall\":\"node bin/dev-setup.js\",\"postpublish\":\"rm README.md\",\"pre-commit\":\"yarn run lint && yarn run build && yarn run test\",\"prebootstrap\":\"bash bin/prebootstrap\",\"prebuild-debug\":\"bash ../bin/update-env.sh\",\"prepublishOnly\":\"cp ../README.md .\",\"pretest\":\"bash ../bin/update-env.sh\",\"test\":\"(tape 'test/**/*.js' | tap-spec) && ts-node test/test-typings.ts\",\"test-watch\":\"bash bin/test-watch\",\"unsafe-bootstrap\":\"bash bin/bootstrap\",\"version-package\":\"bash bin/version\",\"watch\":\"webpack --mode=development --watch\"},\"types\":\"index.d.ts\",\"version\":\"15.4.1\"}");

/***/ }),

/***/ "./node_modules/ohm-js/src/Builder.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Builder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const GrammarDecl = __webpack_require__(/*! ./GrammarDecl */ "./node_modules/ohm-js/src/GrammarDecl.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Builder() {}

Builder.prototype = {
  currentDecl: null,
  currentRuleName: null,

  newGrammar(name) {
    return new GrammarDecl(name);
  },

  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name);
    if (superGrammar) {
      gDecl.withSuperGrammar(this.fromRecipe(superGrammar));
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }

    this.currentDecl = gDecl;
    Object.keys(rules).forEach(ruleName => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];

      const action = ruleRecipe[0]; // define/extend/override
      const metaInfo = ruleRecipe[1];
      const description = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);

      let source;
      if (gDecl.source && metaInfo && metaInfo.sourceInterval) {
        source = gDecl.source.subInterval(
            metaInfo.sourceInterval[0],
            metaInfo.sourceInterval[1] - metaInfo.sourceInterval[0]);
      }
      gDecl[action](ruleName, formals, body, description, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },

  terminal(x) {
    return new pexprs.Terminal(x);
  },

  range(from, to) {
    return new pexprs.Range(from, to);
  },

  param(index) {
    return new pexprs.Param(index);
  },

  alt(/* term1, term2, ... */) {
    let terms = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs.Alt(terms);
  },

  seq(/* factor1, factor2, ... */) {
    let factors = [];
    for (let idx = 0; idx < arguments.length; idx++) {
      let arg = arguments[idx];
      if (!(arg instanceof pexprs.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs.Seq(factors);
  },

  star(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Star(expr);
  },

  plus(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Plus(expr);
  },

  opt(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Opt(expr);
  },

  not(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Not(expr);
  },

  la(expr) {
    // TODO: temporary to still be able to read old recipes
    return this.lookahead(expr);
  },

  lookahead(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lookahead(expr);
  },

  lex(expr) {
    if (!(expr instanceof pexprs.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs.Lex(expr);
  },

  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs.PExpr ? param :
          this.fromRecipe(param);
      }, this);
    }
    return new pexprs.Apply(ruleName, optParams);
  },

  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs.Splice(
        this.currentDecl.superGrammar,
        this.currentRuleName,
        beforeTerms.map(term => this.fromRecipe(term)),
        afterTerms.map(term => this.fromRecipe(term)));
  },

  fromRecipe(recipe) {
    // the meta-info of 'grammar' is processed in Builder.grammar
    const result = this[recipe[0]].apply(this,
      recipe[0] === 'grammar' ? recipe.slice(1) : recipe.slice(2));

    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(
            this.currentDecl.sourceInterval.apply(this.currentDecl, metaInfo.sourceInterval)
        );
      }
    }
    return result;
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Builder;


/***/ }),

/***/ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/CaseInsensitiveTerminal.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const TerminalNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").TerminalNode;
const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const {PExpr, Terminal} = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

class CaseInsensitiveTerminal extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }

  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert(terminal instanceof Terminal, 'expected a Terminal expression');
    return terminal.obj;
  }

  // Implementation of the PExpr API

  allowsSkippingPrecedingSpace() {
    return true;
  }

  eval(state) {
    const inputStream = state.inputStream;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(state.grammar, matchStr), origPos);
      return true;
    }
  }

  generateExample(grammar, examples, inSyntacticContext, actuals) {
    // Start with a example generated from the Terminal...
    const str = this.obj.generateExample(grammar, examples, inSyntacticContext, actuals).value;

    // ...and randomly switch characters to uppercase/lowercase.
    let value = '';
    for (let i = 0; i < str.length; ++i) {
      value += Math.random() < 0.5 ? str[i].toLocaleLowerCase() : str[i].toLocaleUpperCase();
    }
    return {value};
  }

  getArity() {
    return 1;
  }

  substituteParams(actuals) {
    return new CaseInsensitiveTerminal(this.obj.substituteParams(actuals));
  }

  toDisplayString() {
    return this.obj.toDisplayString() + ' (case-insensitive)';
  }

  toFailure(grammar) {
    return new Failure(this, this.obj.toFailure(grammar) + ' (case-insensitive)', 'description');
  }

  _isNullable(grammar, memo) {
    return this.obj._isNullable(grammar, memo);
  }
}

module.exports = CaseInsensitiveTerminal;


/***/ }),

/***/ "./node_modules/ohm-js/src/Failure.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Failure.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

/*
  `Failure`s represent expressions that weren't matched while parsing. They are used to generate
  error messages automatically. The interface of `Failure`s includes the collowing methods:

  - getText() : String
  - getType() : String  (one of {"description", "string", "code"})
  - isDescription() : bool
  - isStringTerminal() : bool
  - isCode() : bool
  - isFluffy() : bool
  - makeFluffy() : void
  - subsumes(Failure) : bool
*/

function isValidType(type) {
  return type === 'description' || type === 'string' || type === 'code';
}

function Failure(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error('invalid Failure type: ' + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}

Failure.prototype.getPExpr = function() {
  return this.pexpr;
};

Failure.prototype.getText = function() {
  return this.text;
};

Failure.prototype.getType = function() {
  return this.type;
};

Failure.prototype.isDescription = function() {
  return this.type === 'description';
};

Failure.prototype.isStringTerminal = function() {
  return this.type === 'string';
};

Failure.prototype.isCode = function() {
  return this.type === 'code';
};

Failure.prototype.isFluffy = function() {
  return this.fluffy;
};

Failure.prototype.makeFluffy = function() {
  this.fluffy = true;
};

Failure.prototype.clearFluffy = function() {
  this.fluffy = false;
};

Failure.prototype.subsumes = function(that) {
  return this.getText() === that.getText() &&
      this.type === that.type &&
      (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};

Failure.prototype.toString = function() {
  return this.type === 'string' ?
    JSON.stringify(this.getText()) :
    this.getText();
};

Failure.prototype.clone = function() {
  const failure = new Failure(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};

Failure.prototype.toKey = function() {
  return this.toString() + '#' + this.type;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Failure;


/***/ }),

/***/ "./node_modules/ohm-js/src/Grammar.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Grammar.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const CaseInsensitiveTerminal = __webpack_require__(/*! ./CaseInsensitiveTerminal */ "./node_modules/ohm-js/src/CaseInsensitiveTerminal.js");
const Matcher = __webpack_require__(/*! ./Matcher */ "./node_modules/ohm-js/src/Matcher.js");
const Semantics = __webpack_require__(/*! ./Semantics */ "./node_modules/ohm-js/src/Semantics.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getSortedRuleValues(grammar) {
  return Object.keys(grammar.rules).sort().map(name => grammar.rules[name]);
}

function Grammar(
    name,
    superGrammar,
    rules,
    optDefaultStartRule) {
  this.name = name;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error("Invalid start rule: '" + optDefaultStartRule +
                      "' is not a rule in grammar '" + name + "'");
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}

let ohmGrammar;
let buildGrammar;

// This method is called from main.js once Ohm has loaded.
Grammar.initApplicationParser = function(grammar, builderFn) {
  ohmGrammar = grammar;
  buildGrammar = builderFn;
};

Grammar.prototype = {
  matcher() {
    return new Matcher(this);
  },

  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;
  },

  equals(g) {
    if (this === g) {
      return true;
    }
    // Do the cheapest comparisons first.
    if (g == null ||
        this.name !== g.name ||
        this.defaultStartRule !== g.defaultStartRule ||
        !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description &&
             rule.formals.join(',') === otherRules[i].formals.join(',') &&
             rule.body.toString() === otherRules[i].body.toString();
    });
  },

  match(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.match(optStartApplication);
  },

  trace(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.trace(optStartApplication);
  },

  semantics() {
    // TODO: Remove this eventually! Deprecated in v0.12.
    throw new Error('semantics() is deprecated -- use createSemantics() instead.');
  },

  createSemantics() {
    return Semantics.createSemantics(this);
  },

  extendSemantics(superSemantics) {
    return Semantics.createSemantics(this, superSemantics._getSemantics());
  },

  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name, actionDict) {
    function isSpecialAction(a) {
      return a === '_iter' || a === '_terminal' || a === '_nonterminal' || a === '_default';
    }

    const problems = [];
    for (const k in actionDict) {
      const v = actionDict[k];
      if (!isSpecialAction(k) && !(k in this.rules)) {
        problems.push("'" + k + "' is not a valid semantic action for '" + this.name + "'");
      } else if (typeof v !== 'function') {
        problems.push(
            "'" + k + "' must be a function in an action dictionary for '" + this.name + "'");
      } else {
        const actual = v.length;
        const expected = this._topDownActionArity(k);
        if (actual !== expected) {
          problems.push(
              "Semantic action '" + k + "' has the wrong arity: " +
              'expected ' + expected + ', got ' + actual);
        }
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map(problem => '- ' + problem);
      const error = new Error(
          "Found errors in the action dictionary of the '" + name + "' " + what + ':\n' +
          prettyProblems.join('\n'));
      error.problems = problems;
      throw error;
    }
  },

  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    if (actionName === '_iter' || actionName === '_nonterminal' || actionName === '_default') {
      return 1;
    } else if (actionName === '_terminal') {
      return 0;
    }
    return this.rules[actionName].body.getArity();
  },

  _inheritsFrom(grammar) {
    let g = this.superGrammar;
    while (g) {
      if (g.equals(grammar, true)) {
        return true;
      }
      g = g.superGrammar;
    }
    return false;
  },

  toRecipe(optVarName) {
    const metaInfo = {};
    // Include the grammar source if it is available.
    if (this.source) {
      metaInfo.source = this.source.contents;
    }

    let superGrammar = null;
    if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammar = JSON.parse(this.superGrammar.toRecipe());
    }

    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }

    const rules = {};
    const self = this;
    Object.keys(this.rules).forEach(ruleName => {
      const ruleInfo = self.rules[ruleName];
      const body = ruleInfo.body;
      const isDefinition = !self.superGrammar || !self.superGrammar.rules[ruleName];

      let operation;
      if (isDefinition) {
        operation = 'define';
      } else {
        operation = body instanceof pexprs.Extend ? 'extend' : 'override';
      }

      const metaInfo = {};
      if (ruleInfo.source && self.source) {
        const adjusted = ruleInfo.source.relativeTo(self.source);
        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }

      const description = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, self.source);

      rules[ruleName] = [
        operation, // "define"/"extend"/"override"
        metaInfo,
        description,
        ruleInfo.formals,
        bodyRecipe
      ];
    });

    return JSON.stringify([
      'grammar',
      metaInfo,
      this.name,
      superGrammar,
      startRule,
      rules
    ]);
  },

  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },

  _toOperationOrAttributeActionDictionaryTemplate() {
    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus
    // should appear next to other cases of AddExpr.

    const sb = new common.StringBuffer();
    sb.append('{');

    let first = true;
    for (const ruleName in this.rules) {
      const body = this.rules[ruleName].body;
      if (first) {
        first = false;
      } else {
        sb.append(',');
      }
      sb.append('\n');
      sb.append('  ');
      this.addSemanticActionTemplate(ruleName, body, sb);
    }

    sb.append('\n}');
    return sb.contents();
  },

  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(': function(');
    const arity = this._topDownActionArity(ruleName);
    sb.append(common.repeat('_', arity).join(', '));
    sb.append(') {\n');
    sb.append('  }');
  },

  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf('<') === -1) {
      // simple application
      app = new pexprs.Apply(str);
    } else {
      // parameterized application
      const cst = ohmGrammar.match(str, 'Base_application');
      app = buildGrammar(cst, {});
    }

    // Ensure that the application is valid.
    if (!(app.ruleName in this.rules)) {
      throw errors.undeclaredRule(app.ruleName, this.name);
    }
    const formals = this.rules[app.ruleName].formals;
    if (formals.length !== app.args.length) {
      const source = this.rules[app.ruleName].source;
      throw errors.wrongNumberOfParameters(app.ruleName, formals.length, app.args.length, source);
    }
    return app;
  }
};

// The following grammar contains a few rules that couldn't be written  in "userland".
// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called
// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and
// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar
// isn't specified.
Grammar.ProtoBuiltInRules = new Grammar(
    'ProtoBuiltInRules', // name
    undefined, // supergrammar
    {
      any: {
        body: pexprs.any,
        formals: [],
        description: 'any character',
        primitive: true
      },
      end: {
        body: pexprs.end,
        formals: [],
        description: 'end of input',
        primitive: true
      },

      caseInsensitive: {
        body: new CaseInsensitiveTerminal(new pexprs.Param(0)),
        formals: ['str'],
        primitive: true
      },
      lower: {
        body: new pexprs.UnicodeChar('Ll'),
        formals: [],
        description: 'a lowercase letter',
        primitive: true
      },
      upper: {
        body: new pexprs.UnicodeChar('Lu'),
        formals: [],
        description: 'an uppercase letter',
        primitive: true
      },
      // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
      unicodeLtmo: {
        body: new pexprs.UnicodeChar('Ltmo'),
        formals: [],
        description: 'a Unicode character in Lt, Lm, or Lo',
        primitive: true
      },

      // These rules are not truly primitive (they could be written in userland) but are defined
      // here for bootstrapping purposes.
      spaces: {
        body: new pexprs.Star(new pexprs.Apply('space')),
        formals: []
      },
      space: {
        body: new pexprs.Range('\x00', ' '),
        formals: [],
        description: 'a space'
      }
    }
);

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Grammar;


/***/ }),

/***/ "./node_modules/ohm-js/src/GrammarDecl.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/GrammarDecl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Constructors

function GrammarDecl(name) {
  this.name = name;
}

// Helpers

GrammarDecl.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};

GrammarDecl.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
        // TODO: The conditional expression below is an ugly hack. It's kind of ok because
        // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
        // we should try to find a better way to do this.
        this.name === 'BuiltInRules' ?
            Grammar.ProtoBuiltInRules :
            Grammar.BuiltInRules);
  }
  return this.superGrammar;
};

GrammarDecl.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
  }
  return ruleInfo;
};

GrammarDecl.prototype.installOverriddenOrExtendedRule = function(name, formals, body, source) {
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
  }
  return this.install(name, formals, body, ruleInfo.description, source);
};

GrammarDecl.prototype.install = function(name, formals, body, description, source) {
  this.rules[name] = {
    body: body.introduceParams(formals),
    formals,
    description,
    source
  };
  return this;
};

// Stuff that you should only do once

GrammarDecl.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error('the super grammar of a GrammarDecl cannot be set more than once');
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);

  // Grammars with an explicit supergrammar inherit a default start rule.
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};

GrammarDecl.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};

GrammarDecl.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};

// Creates a Grammar instance, and if it passes the sanity checks, returns it.
GrammarDecl.prototype.build = function() {
  const grammar = new Grammar(
      this.name,
      this.ensureSuperGrammar(),
      this.rules,
      this.defaultStartRule);

  // TODO: change the pexpr.prototype.assert... methods to make them add
  // exceptions to an array that's provided as an arg. Then we'll be able to
  // show more than one error of the same type at a time.
  // TODO: include the offending pexpr in the errors, that way we can show
  // the part of the source that caused it.
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar.rules).forEach(ruleName => {
    const body = grammar.rules[ruleName].body;
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    // The following check can only be done if the grammar has no invalid applications.
    Object.keys(grammar.rules).forEach(ruleName => {
      const body = grammar.rules[ruleName].body;
      try {
        body.assertIteratedExprsAreNotNullable(grammar, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar.source = this.source;
  }

  return grammar;
};

// Rule declarations

GrammarDecl.prototype.define = function(name, formals, body, description, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
  } else if (this.rules[name]) {
    throw errors.duplicateRuleDeclaration(name, this.name, this.name, source);
  }
  const duplicateParameterNames = common.getDuplicates(formals);
  if (duplicateParameterNames.length > 0) {
    throw errors.duplicateParameterNames(name, duplicateParameterNames, source);
  }
  return this.install(name, formals, body, description, source);
};

GrammarDecl.prototype.override = function(name, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name, source);
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

GrammarDecl.prototype.extend = function(name, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
  }
  const body = new pexprs.Extend(this.superGrammar, name, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = GrammarDecl;


/***/ }),

/***/ "./node_modules/ohm-js/src/InputStream.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/InputStream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function InputStream(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}

InputStream.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },

  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },

  matchString(s, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      /*
        Case-insensitive comparison is a tricky business. Some notable gotchas include the
        "Turkish I" problem (http://www.i18nguy.com/unicode/turkish-i18n.html) and the fact
        that the German Esszet () turns into "SS" in upper case.

        This is intended to be a locale-invariant comparison, which means it may not obey
        locale-specific expectations (e.g. "i" => "").
       */
      for (idx = 0; idx < s.length; idx++) {
        const actual = this.next();
        const expected = s[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    // Default is case-sensitive comparison.
    for (idx = 0; idx < s.length; idx++) {
      if (this.next() !== s[idx]) { return false; }
    }
    return true;
  },

  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },

  interval(startIdx, optEndIdx) {
    return new Interval(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = InputStream;


/***/ }),

/***/ "./node_modules/ohm-js/src/Interval.js":
/*!*********************************************!*\
  !*** ./node_modules/ohm-js/src/Interval.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const assert = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js").assert;
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Interval(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}

Interval.coverage = function(/* interval1, interval2, ... */) {
  const sourceString = arguments[0].sourceString;
  let startIdx = arguments[0].startIdx;
  let endIdx = arguments[0].endIdx;
  for (let idx = 1; idx < arguments.length; idx++) {
    const interval = arguments[idx];
    if (interval.sourceString !== sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, arguments[idx].startIdx);
      endIdx = Math.max(endIdx, arguments[idx].endIdx);
    }
  }
  return new Interval(sourceString, startIdx, endIdx);
};

Interval.prototype = {
  coverageWith(/* interval1, interval2, ... */) {
    const intervals = Array.prototype.slice.call(arguments);
    intervals.push(this);
    return Interval.coverage.apply(undefined, intervals);
  },

  collapsedLeft() {
    return new Interval(this.sourceString, this.startIdx, this.startIdx);
  },

  collapsedRight() {
    return new Interval(this.sourceString, this.endIdx, this.endIdx);
  },

  getLineAndColumn() {
    return util.getLineAndColumn(this.sourceString, this.startIdx);
  },

  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },

  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      // `this` and `that` are the same interval!
      return [
      ];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      // `that` splits `this` into two intervals
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx),
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      // `that` contains a prefix of `this`
      return [
        new Interval(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      // `that` contains a suffix of `this`
      return [
        new Interval(this.sourceString, this.startIdx, that.startIdx)
      ];
    } else {
      // `that` and `this` do not overlap
      return [
        this
      ];
    }
  },

  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors.intervalSourcesDontMatch();
    }
    assert(this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
        'other interval does not cover this one');
    return new Interval(this.sourceString,
        this.startIdx - that.startIdx,
        this.endIdx - that.startIdx);
  },

  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends. (This only makes sense when
  // the input stream is a string.)
  trimmed() {
    const contents = this.contents;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval(this.sourceString, startIdx, endIdx);
  },

  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval(this.sourceString, newStartIdx, newStartIdx + len);
  }
};

Object.defineProperties(Interval.prototype, {
  contents: {
    get() {
      if (this._contents === undefined) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() { return this.endIdx - this.startIdx; },
    enumerable: true
  }
});

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Interval;



/***/ }),

/***/ "./node_modules/ohm-js/src/MatchResult.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/MatchResult.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function MatchResult(
    matcher,
    input,
    startExpr,
    cst,
    cstOffset,
    rightmostFailurePosition,
    optRecordedFailures) {

  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;

  if (this.failed()) {
    common.defineLazyProperty(this, 'message', function() {
      const detail = 'Expected ' + this.getExpectedText();
      return util.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common.defineLazyProperty(this, 'shortMessage', function() {
      const detail = 'expected ' + this.getExpectedText();
      const errorInfo = util.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;
    });
  }
}

MatchResult.prototype.succeeded = function() {
  return !!this._cst;
};

MatchResult.prototype.failed = function() {
  return !this.succeeded();
};

MatchResult.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};

MatchResult.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures =
        this.matcher._match(this.startExpr, false, this.getRightmostFailurePosition());
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};

MatchResult.prototype.toString = function() {
  return this.succeeded() ?
      '[match succeeded]' :
      '[match failed at position ' + this.getRightmostFailurePosition() + ']';
};

// Return a string summarizing the expected contents of the input stream when
// the match failure occurred.
MatchResult.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error('cannot get expected text of a successful MatchResult');
  }

  const sb = new common.StringBuffer();
  let failures = this.getRightmostFailures();

  // Filter out the fluffy failures to make the default error messages more useful
  failures = failures.filter(failure => !failure.isFluffy());

  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ', or ' : ' or ');
      } else {
        sb.append(', ');
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};

MatchResult.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchResult;


/***/ }),

/***/ "./node_modules/ohm-js/src/MatchState.js":
/*!***********************************************!*\
  !*** ./node_modules/ohm-js/src/MatchState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const PosInfo = __webpack_require__(/*! ./PosInfo */ "./node_modules/ohm-js/src/PosInfo.js");
const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const applySpaces = new pexprs.Apply('spaces');

function MatchState(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;

  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream(matcher.input);
  this.memoTable = matcher.memoTable;

  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];

  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];

  if (optPositionToRecordFailures !== undefined) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = Object.create(null);
  }
}

MatchState.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },

  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },

  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();

    this.rightmostFailurePosition = Math.max(
        this.rightmostFailurePosition,
        this._rightmostFailurePositionStack.pop());

    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },

  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },

  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },

  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },

  inSyntacticContext() {
    if (typeof this.inputStream.source !== 'string') {
      return false;
    }
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      // The top-level context is syntactic if the start application is.
      return this.startExpr.factors[0].isSyntactic();
    }
  },

  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },

  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },

  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ?
        this.skipSpaces() :
        this.inputStream.pos;
  },

  maybeSkipSpacesBefore(expr) {
    if (expr instanceof pexprs.Apply && expr.isSyntactic()) {
      return this.skipSpaces();
    } else if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },

  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },

  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },

  numBindings() {
    return this._bindings.length;
  },

  truncateBindings(newLength) {
    // Yes, this is this really faster than setting the `length` property (tested with
    // bin/es5bench on Node v6.1.0).
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },

  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },

  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },

  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);

    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        // Substitute parameters with the actual pexprs that were passed to
        // the current rule.
        expr = expr.substituteParams(app.args);
      } else {
        // This branch is only reached for the "end-check" that is
        // performed after the top-level application. In that case,
        // expr === pexprs.end so there is no need to substitute
        // parameters.
      }

      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },

  recordFailure(failure, shouldCloneIfNew) {
    const key = failure.toKey();
    if (!this.recordedFailures[key]) {
      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key].clearFluffy();
    }
  },

  recordFailures(failures, shouldCloneIfNew) {
    const self = this;
    Object.keys(failures).forEach(key => {
      self.recordFailure(failures[key], shouldCloneIfNew);
    });
  },

  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return undefined;
    }

    const ans = Object.create(null);
    const self = this;
    Object.keys(this.recordedFailures).forEach(key => {
      ans[key] = self.recordedFailures[key].clone();
    });
    return ans;
  },

  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },

  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ?
        this.posToOffset(this.rightmostFailurePosition) :
        -1;
  },

  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr.ruleName) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },

  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) ||
           new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },

  isTracing() {
    return !!this.trace;
  },

  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }

    if (this.recordedFailures &&
        this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }

    return true;
  },


  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }

    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition =
        Math.max(this.rightmostFailurePosition, memoRecRightmostFailurePosition);
    if (this.recordedFailures &&
        this.positionToRecordFailures === memoRecRightmostFailurePosition &&
        memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }

    this.inputStream.examinedLength =
        Math.max(this.inputStream.examinedLength, memoRec.examinedLength + origPos);

    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },

  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const inputStream = this.inputStream;
    const origNumBindings = this._bindings.length;

    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = Object.create(null);
    }

    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);

    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }

    // Do the actual evaluation.
    const ans = expr.eval(this);

    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }

    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        const self = this;
        Object.keys(this.recordedFailures).forEach(key => {
          self.recordedFailures[key].makeFluffy();
        });
      }
    } else {
      // Reset the position and the bindings.
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }

    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }

    return ans;
  },

  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      const self = this;
      rightmostFailures = Object.keys(this.recordedFailures).map(key => self.recordedFailures[key]);
    }
    return new MatchResult(
        this.matcher,
        this.input,
        this.startExpr,
        this._bindings[0],
        this._bindingOffsets[0],
        this.rightmostFailurePosition,
        rightmostFailures);
  },

  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();

    // The trace node for the start rule is always the last entry. If it is a syntactic rule,
    // the first entry is for an application of 'spaces'.
    // TODO(pdubroy): Clean this up by introducing a special `Match<startAppl>` rule, which will
    // ensure that there is always a single root trace node.
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },

  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },

  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = MatchState;


/***/ }),

/***/ "./node_modules/ohm-js/src/Matcher.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/Matcher.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const MatchState = __webpack_require__(/*! ./MatchState */ "./node_modules/ohm-js/src/MatchState.js");

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Matcher(grammar) {
  this.grammar = grammar;
  this.memoTable = [];
  this.input = '';
}

Matcher.prototype.getInput = function() {
  return this.input;
};

Matcher.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};

Matcher.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length ||
      endIdx < 0 || endIdx > currentInput.length ||
      startIdx > endIdx) {
    throw new Error('Invalid indices: ' + startIdx + ' and ' + endIdx);
  }

  // update input
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);

  // update memo table (similar to the above)
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(undefined);
  }
  restOfMemoTable.forEach(
      function(posInfo) { this.memoTable.push(posInfo); },
      this);

  // Invalidate memoRecs
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }

  return this;
};

Matcher.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};

Matcher.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};

Matcher.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};

/*
  Returns the starting expression for this Matcher's associated grammar. If `optStartApplicationStr`
  is specified, it is a string expressing a rule application in the grammar. If not specified, the
  grammar's default start rule will be used.
*/
Matcher.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error('Missing start rule argument -- the grammar has no default start rule.');
  }

  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs.Seq([startApp, pexprs.end]);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Matcher;


/***/ }),

/***/ "./node_modules/ohm-js/src/Namespace.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Namespace.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function Namespace() {
}
Namespace.prototype = Object.create(null);

Namespace.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace) {
    return objOrNamespace;
  }
  return Namespace.createNamespace(objOrNamespace);
};

// Create a new namespace. If `optProps` is specified, all of its properties
// will be copied to the new namespace.
Namespace.createNamespace = function(optProps) {
  return Namespace.extend(Namespace.prototype, optProps);
};

// Create a new namespace which extends another namespace. If `optProps` is
// specified, all of its properties will be copied to the new namespace.
Namespace.extend = function(namespace, optProps) {
  if (namespace !== Namespace.prototype && !(namespace instanceof Namespace)) {
    throw new TypeError('not a Namespace object: ' + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return extend(ns, optProps);
};

// TODO: Should this be a regular method?
Namespace.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Namespace;


/***/ }),

/***/ "./node_modules/ohm-js/src/PosInfo.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/PosInfo.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function PosInfo() {
  this.applicationMemoKeyStack = []; // active applications at this position
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = undefined;
}

PosInfo.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },

  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },

  exit() {
    this.applicationMemoKeyStack.pop();
  },

  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;

    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    const indexOfFirstInvolvedRule =
        applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(indexOfFirstInvolvedRule);

    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };

    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },

  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },

  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const applicationMemoKeyStack = this.applicationMemoKeyStack;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },

  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset =
        Math.max(this.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
    return memoRec;
  },

  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      // Optimization: none of the rule applications that were memoized here examined the
      // interval of the input that changed, so nothing has to be invalidated.
      return;
    }

    const memo = this.memo;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    const self = this;
    Object.keys(memo).forEach(k => {
      const memoRec = memo[k];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k];
      } else {
        self.maxExaminedLength = Math.max(self.maxExaminedLength, memoRec.examinedLength);
        self.maxRightmostFailureOffset =
            Math.max(self.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
      }
    });
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = PosInfo;


/***/ }),

/***/ "./node_modules/ohm-js/src/Semantics.js":
/*!**********************************************!*\
  !*** ./node_modules/ohm-js/src/Semantics.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/ohm-js/src/InputStream.js");
const IterationNode = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js").IterationNode;
const MatchResult = __webpack_require__(/*! ./MatchResult */ "./node_modules/ohm-js/src/MatchResult.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

const globalActionStack = [];
let prototypeGrammar;
let prototypeGrammarSemantics;

// JSON is not a valid subset of JavaScript because there are two possible line terminators,
// U+2028 (line separator) and U+2029 (paragraph separator) that are allowed in JSON strings
// but not in JavaScript strings.
// jsonToJS() properly encodes those two characters in JSON so that it can seamlessly be
// inserted into JavaScript code (plus the encoded version is still valid JSON)
function jsonToJS(str) {
  const output = str.replace(/[\u2028\u2029]/g, (char, pos, str) => {
    const hex = char.codePointAt(0).toString(16);
    return '\\u' + '0000'.slice(hex.length) + hex;
  });
  return output;
}

// ----------------- Wrappers -----------------

// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)
// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A
// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and
// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is
// used to cache the wrapper instances that are created for its child nodes. Setting these instance
// variables is the responsibility of the constructor of each Semantics-specific subclass of
// `Wrapper`.
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;

    // The interval that the childOffsets of `node` are relative to. It should be the source
    // of the closest Nonterminal node.
    this._baseInterval = baseInterval;

    if (node.isNonterminal()) {
      common.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }

  toString() {
    return '[semantics wrapper for ' + this._node.grammar.name + ']';
  };

  // This is used by ohm editor to display a node wrapper appropriately.
  toJSON() {
    return this.toString();
  }

  _forgetMemoizedResultFor(attributeName) {
    // Remove the memoized attribute from the cstNode and all its children.
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach(child => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }

  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      // TODO: Consider throwing an exception here.
      return undefined;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];

      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
    }
    return childWrapper;
  }

  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    // Force the creation of all child wrappers
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }

  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }

  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }

  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }

  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }

  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];

    const childNodes = childWrappers.map(c => c._node);
    const iter = new IterationNode(this._node.grammar, childNodes, [], -1, false);

    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }

  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }

  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }

  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error('The `interval` property is deprecated -- use `source` instead');
  }

  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }

  // Returns the primitive value of this CST node, if it's a terminal node. Otherwise,
  // throws an exception.
  get primitiveValue() {
    if (this.isTerminal()) {
      return this._node.primitiveValue;
    }
    throw new TypeError(
        "tried to access the 'primitiveValue' attribute of a non-terminal CST node");
  }

  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}

// ----------------- Semantics -----------------

// A Semantics is a container for a family of Operations and Attributes for a given grammar.
// Semantics enable modularity (different clients of a grammar can create their set of operations
// and attributes in isolation) and extensibility even when operations and attributes are mutually-
// recursive. This constructor should not be called directly except from
// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are
// `g.createSemantics()` and `g.extendSemantics(parentSemantics)`.
function Semantics(grammar, superSemantics) {
  const self = this;
  this.grammar = grammar;
  this.checkedActionDicts = false;

  // Constructor for wrapper instances, which are passed as the arguments to the semantic actions
  // of an operation or attribute. Operations and attributes require double dispatch: the semantic
  // action is chosen based on both the node's type and the semantics. Wrappers ensure that
  // the `execute` method is called with the correct (most specific) semantics object as an
  // argument.
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self.checkActionDictsIfHaventAlready();
      this._semantics = self;
    }
  };

  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) {
      throw new Error(
          "Cannot extend a semantics for grammar '" + this.super.grammar.name +
          "' for use with grammar '" + grammar.name + "' (not a sub-grammar)");
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = Object.create(null);

    // Assign unique symbols for each of the attributes inherited from the super-semantics so that
    // they are memoized independently.
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = Object.create(null);
    this.attributes = Object.create(null);
    this.attributeKeys = Object.create(null);
  }
}

Semantics.prototype.toString = function() {
  return '[semantics for ' + this.grammar.name + ']';
};

Semantics.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};

// Checks that the action dictionaries for all operations and attributes in this semantics,
// including the ones that were inherited from the super-semantics, agree with the grammar.
// Throws an exception if one or more of them doesn't.
Semantics.prototype.checkActionDicts = function() {
  let name;
  for (name in this.operations) {
    this.operations[name].checkActionDict(this.grammar);
  }
  for (name in this.attributes) {
    this.attributes[name].checkActionDict(this.grammar);
  }
};

Semantics.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s) {
    return s.super !== Semantics.BuiltInSemantics._getSemantics();
  }

  let str = '(function(g) {\n';
  if (hasSuperSemantics(this)) {
    str += '  var semantics = ' + this.super.toRecipe(true) + '(g';

    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += '.superGrammar';
      relatedGrammar = relatedGrammar.superGrammar;
    }

    str += ');\n';
    str += '  return g.extendSemantics(semantics)';
  } else {
    str += '  return g.createSemantics()';
  }
  ['Operation', 'Attribute'].forEach(type => {
    const semanticOperations = this[type.toLowerCase() + 's'];
    Object.keys(semanticOperations).forEach(name => {
      const {actionDict, formals, builtInDefault} = semanticOperations[name];

      let signature = name;
      if (formals.length > 0) {
        signature += '(' + formals.join(', ') + ')';
      }

      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + 's'][name]) {
        method = 'extend' + type;
      } else {
        method = 'add' + type;
      }
      str += '\n    .' + method + '(' + JSON.stringify(signature) + ', {';

      const srcArray = [];
      Object.keys(actionDict).forEach(actionName => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();

          // Convert method shorthand to plain old function syntax.
          // https://github.com/harc/ohm/issues/263
          source = source.replace(/^.*\(/, 'function(');

          srcArray.push('\n      ' + JSON.stringify(actionName) + ': ' + source);
        }
      });
      str += srcArray.join(',') + '\n    })';
    });
  });
  str += ';\n  })';

  if (!semanticsOnly) {
    str =
      '(function() {\n' +
      '  var grammar = this.fromRecipe(' + jsonToJS(this.grammar.toRecipe()) + ');\n' +
      '  var semantics = ' + str + '(grammar);\n' +
      '  return semantics;\n' +
      '});\n';
  }

  return str;
};

function parseSignature(signature, type) {
  if (!prototypeGrammar) {
    // The Operations and Attributes grammar won't be available while Ohm is loading,
    // but we can get away the following simplification b/c none of the operations
    // that are used while loading take arguments.
    common.assert(signature.indexOf('(') === -1);
    return {
      name: signature,
      formals: []
    };
  }

  const r = prototypeGrammar.match(
      signature,
      type === 'operation' ? 'OperationSignature' : 'AttributeSignature');
  if (r.failed()) {
    throw new Error(r.message);
  }

  return prototypeGrammarSemantics(r).parse();
}

function newDefaultAction(type, name, doIt) {
  return function(children) {
    const self = this;
    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
    const args = thisThing.formals.map(formal => self.args[formal]);

    if (this.isIteration()) {
      // This CST node corresponds to an iteration expression in the grammar (*, +, or ?). The
      // default behavior is to map this operation or attribute over all of its child nodes.
      return children.map(child => doIt.apply(child, args));
    }

    // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that
    // we got here means that this action dictionary doesn't have an action for this particular
    // non-terminal or a generic `_nonterminal` action.
    if (children.length === 1) {
      // As a convenience, if this node only has one child, we just return the result of
      // applying this operation / attribute to the child node.
      return doIt.apply(children[0], args);
    } else {
      // Otherwise, we throw an exception to let the programmer know that we don't know what
      // to do with this node.
      throw errors.missingSemanticAction(this.ctorName, name, type, globalActionStack);
    }
  };
}

Semantics.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + 's';

  const parsedNameAndFormalArgs = parseSignature(signature, type);
  const name = parsedNameAndFormalArgs.name;
  const formals = parsedNameAndFormalArgs.formals;

  // TODO: check that there are no duplicate formal arguments

  this.assertNewName(name, type);

  // Create the action dictionary for this operation / attribute that contains a `_default` action
  // which defines the default behavior of iteration, terminal, and non-terminal nodes...
  const builtInDefault = newDefaultAction(type, name, doIt);
  const realActionDict = {_default: builtInDefault};
  // ... and add in the actions supplied by the programmer, which may override some or all of the
  // default ones.
  Object.keys(actionDict).forEach(name => {
    realActionDict[name] = actionDict[name];
  });

  const entry = type === 'operation' ?
      new Operation(name, formals, realActionDict, builtInDefault) :
      new Attribute(name, realActionDict, builtInDefault);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  entry.checkActionDict(this.grammar);

  this[typePlural][name] = entry;

  function doIt() {
    // Dispatch to most specific version of this operation / attribute -- it may have been
    // overridden by a sub-semantics.
    const thisThing = this._semantics[typePlural][name];

    // Check that the caller passed the correct number of arguments.
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
          'Invalid number of arguments passed to ' + name + ' ' + type + ' (expected ' +
          thisThing.formals.length + ', got ' + arguments.length + ')');
    }

    // Create an "arguments object" from the arguments that were passed to this
    // operation / attribute.
    const args = Object.create(null);
    for (let idx = 0; idx < arguments.length; idx++) {
      const formal = thisThing.formals[idx];
      args[formal] = arguments[idx];
    }

    const oldArgs = this.args;
    this.args = args;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }

  if (type === 'operation') {
    this.Wrapper.prototype[name] = doIt;
    this.Wrapper.prototype[name].toString = function() {
      return '[' + name + ' operation]';
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name, {
      get: doIt,
      configurable: true // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name, {
      value: util.uniqueId(name)
    });
  }
};

Semantics.prototype.extendOperationOrAttribute = function(type, name, actionDict) {
  const typePlural = type + 's';

  // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.
  parseSignature(name, 'attribute');

  if (!(this.super && name in this.super[typePlural])) {
    throw new Error('Cannot extend ' + type + " '" + name +
        "': did not inherit an " + type + ' with that name');
  }
  if (Object.prototype.hasOwnProperty.call(this[typePlural], name)) {
    throw new Error('Cannot extend ' + type + " '" + name + "' again");
  }

  // Create a new operation / attribute whose actionDict delegates to the super operation /
  // attribute's actionDict, and which has all the keys from `inheritedActionDict`.
  const inheritedFormals = this[typePlural][name].formals;
  const inheritedActionDict = this[typePlural][name].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach(name => {
    newActionDict[name] = actionDict[name];
  });

  this[typePlural][name] = type === 'operation' ?
      new Operation(name, inheritedFormals, newActionDict) :
      new Attribute(name, newActionDict);

  // The following check is not strictly necessary (it will happen later anyway) but it's better to
  // catch errors early.
  this[typePlural][name].checkActionDict(this.grammar);
};

Semantics.prototype.assertNewName = function(name, type) {
  if (Wrapper.prototype.hasOwnProperty(name)) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': that's a reserved name");
  }
  if (name in this.operations) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an operation with that name already exists");
  }
  if (name in this.attributes) {
    throw new Error(
        'Cannot add ' + type + " '" + name + "': an attribute with that name already exists");
  }
};

// Returns a wrapper for the given CST `node` in this semantics.
// If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?
Semantics.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};

// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from
// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new
// Semantics instance. When that function is invoked with a CST node as an argument, it returns
// a wrapper for that node which gives access to the operations and attributes provided by this
// semantics.
Semantics.createSemantics = function(grammar, optSuperSemantics) {
  const s = new Semantics(
      grammar,
      optSuperSemantics !== undefined ?
          optSuperSemantics :
          Semantics.BuiltInSemantics._getSemantics());

  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy
  // for `s`, which is the real `Semantics` instance.
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
          'Semantics expected a MatchResult, but got ' + common.unexpectedObjToString(matchResult));
    }
    if (matchResult.failed()) {
      throw new TypeError('cannot apply Semantics to ' + matchResult.toString());
    }

    const cst = matchResult._cst;
    if (cst.grammar !== grammar) {
      throw new Error(
          "Cannot use a MatchResult from grammar '" + cst.grammar.name +
          "' with a semantics for '" + grammar.name + "'");
    }
    const inputStream = new InputStream(matchResult.input);
    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };

  // Forward public methods from the proxy to the semantics instance.
  proxy.addOperation = function(signature, actionDict) {
    s.addOperationOrAttribute('operation', signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name, actionDict) {
    s.extendOperationOrAttribute('operation', name, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name, actionDict) {
    s.addOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name, actionDict) {
    s.extendOperationOrAttribute('attribute', name, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error('"' + operationOrAttributeName + '" is not a valid operation or attribute ' +
        'name in this semantics for "' + grammar.name + '"');
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s.operations) {
      semantic = s.operations[operationOrAttributeName];
      delete s.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s.attributes) {
      semantic = s.attributes[operationOrAttributeName];
      delete s.attributes[operationOrAttributeName];
    }
    delete s.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s.attributes);
  };
  proxy.getGrammar = function() {
    return s.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s.toRecipe(semanticsOnly);
  };

  // Make the proxy's toString() work.
  proxy.toString = s.toString.bind(s);

  // Returns the semantics for the proxy.
  proxy._getSemantics = function() {
    return s;
  };

  return proxy;
};

// ----------------- Operation -----------------

// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very
// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by
// recursively walking the CST, and at each node, invoking the matching semantic action from
// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic
// action is found.
class Operation {
  constructor(name, formals, actionDict, builtInDefault) {
    this.name = name;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }

  checkActionDict(grammar) {
    grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }

  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      // Look for a semantic action whose name matches the node's constructor name, which is either
      // the name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an
      // iteration node). In the latter case, the action function receives a single argument, which
      // is an array containing all of the children of the CST node.
      const ctorName = nodeWrapper._node.ctorName;
      let actionFn = this.actionDict[ctorName];
      let ans;
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        ans = this.doAction(semantics, nodeWrapper, actionFn, nodeWrapper.isIteration());
        return ans;
      }

      // The action dictionary does not contain a semantic action for this specific type of node.
      // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic
      // action, we invoke it:
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, '_nonterminal', ctorName]);
          ans = this.doAction(semantics, nodeWrapper, actionFn, true);
          return ans;
        }
      }

      // Otherwise, we invoke the '_default' semantic action.
      globalActionStack.push([this, 'default action', ctorName]);
      ans = this.doAction(semantics, nodeWrapper, this.actionDict._default, true);
      return ans;
    } finally {
      globalActionStack.pop();
    }
  }

  // Invoke `actionFn` on the CST node that corresponds to `nodeWrapper`, in the context of
  // `semantics`. If `optPassChildrenAsArray` is truthy, `actionFn` will be called with a single
  // argument, which is an array of wrappers. Otherwise, the number of arguments to `actionFn` will
  // be equal to the number of children in the CST node.
  doAction(semantics, nodeWrapper, actionFn, optPassChildrenAsArray) {
    return optPassChildrenAsArray ?
        actionFn.call(nodeWrapper, nodeWrapper._children()) :
        actionFn.apply(nodeWrapper, nodeWrapper._children());
  }
}

Operation.prototype.typeName = 'operation';

// ----------------- Attribute -----------------

// Attributes are Operations whose results are memoized. This means that, for any given semantics,
// the semantic action for a CST node will be invoked no more than once.
class Attribute extends Operation {
  constructor(name, actionDict, builtInDefault) {
    super(name, [], actionDict, builtInDefault);
  }

  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key = semantics.attributeKeys[this.name];
    if (!node.hasOwnProperty(key)) {
      // The following is a super-send -- isn't JS beautiful? :/
      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key];
  }
}

Attribute.prototype.typeName = 'attribute';


// ----------------- Deferred initialization -----------------

util.awaitBuiltInRules(builtInRules => {
  const operationsAndAttributesGrammar = __webpack_require__(/*! ../dist/operations-and-attributes */ "./node_modules/ohm-js/dist/operations-and-attributes.js");
  initBuiltInSemantics(builtInRules);
  initPrototypeParser(operationsAndAttributesGrammar); // requires BuiltInSemantics
});

function initBuiltInSemantics(builtInRules) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };

  Semantics.BuiltInSemantics = Semantics
      .createSemantics(builtInRules, null)
      .addOperation('asIteration', {
        emptyListOf: actions.empty,
        nonemptyListOf: actions.nonEmpty,
        EmptyListOf: actions.empty,
        NonemptyListOf: actions.nonEmpty
      });
}

function initPrototypeParser(grammar) {
  prototypeGrammarSemantics = grammar.createSemantics().addOperation('parse', {
    AttributeSignature(name) {
      return {
        name: name.parse(),
        formals: []
      };
    },
    OperationSignature(name, optFormals) {
      return {
        name: name.parse(),
        formals: optFormals.parse()[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().parse();
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  prototypeGrammar = grammar;
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Semantics;


/***/ }),

/***/ "./node_modules/ohm-js/src/Trace.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/Trace.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Interval = __webpack_require__(/*! ./Interval */ "./node_modules/ohm-js/src/Interval.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Unicode characters that are used in the `toString` output.
const BALLOT_X = '\u2717';
const CHECK_MARK = '\u2713';
const DOT_OPERATOR = '\u22C5';
const RIGHTWARDS_DOUBLE_ARROW = '\u21D2';
const SYMBOL_FOR_HORIZONTAL_TABULATION = '\u2409';
const SYMBOL_FOR_LINE_FEED = '\u240A';
const SYMBOL_FOR_CARRIAGE_RETURN = '\u240D';

const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};

function spaces(n) {
  return common.repeat(' ', n).join('');
}

// Return a string representation of a portion of `input` at offset `pos`.
// The result will contain exactly `len` characters.
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));

  // Pad the output if necessary.
  if (excerpt.length < len) {
    return excerpt + common.repeat(' ', len - excerpt.length).join('');
  }
  return excerpt;
}

function asEscapedString(obj) {
  if (typeof obj === 'string') {
    // Replace non-printable characters with visible symbols.
    return obj
        .replace(/ /g, DOT_OPERATOR)
        .replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)
        .replace(/\n/g, SYMBOL_FOR_LINE_FEED)
        .replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}

// ----------------- Trace -----------------

function Trace(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;

  this._flags = succeeded ? Flags.succeeded : 0;
}

// A value that can be returned from visitor functions to indicate that a
// node should not be recursed into.
Trace.prototype.SKIP = {};

Object.defineProperty(Trace.prototype, 'displayString', {
  get() { return this.expr.toDisplayString(); }
});

// For convenience, create a getter and setter for the boolean flags in `Flags`.
Object.keys(Flags).forEach(name => {
  const mask = Flags[name];
  Object.defineProperty(Trace.prototype, name, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});

Trace.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};

Trace.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace(
      this.input, this.pos, this.pos2, expr, this.succeeded, this.bindings, this.children);

  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};

// Record the trace information for the terminating condition of the LR loop.
Trace.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry =
      new Trace(this.input, this.pos, this.pos2, this.expr, false, [value], [ruleBodyTrace]);
  this.terminatingLREntry.terminatesLR = true;
};

// Recursively traverse this trace node and all its descendents, calling a visitor function
// for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property
// is a function to call before visiting the children of a node, and its 'exit' property is
// a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'
// function.
//
// The functions are called with three arguments: the Trace node, its parent Trace, and a number
// representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if
// specified, is the value to use for `this` when executing the visitor functions.
Trace.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === 'function') {
    visitor = {enter: visitor};
  }

  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach(child => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    // Don't visit the root node itself, only its children.
    this.children.forEach(c => { _walk(c, null, 0); });
  } else {
    _walk(this, null, 0);
  }
};

// Return a string representation of the trace.
// Sample:
//     12+2*3  exp   "12"
//     12+2*3    addExp (LR)   "12"
//     12+2*3        addExp_plus
Trace.prototype.toString = function() {
  const sb = new common.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    // Don't print anything for Alt nodes.
    if (ctorName === 'Alt') {
      return; // eslint-disable-line consistent-return
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(' (LR)');
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');
      sb.append(typeof contents === 'string' ? '"' + contents + '"' : contents);
    }
    sb.append('\n');
  });
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = Trace;


/***/ }),

/***/ "./node_modules/ohm-js/src/common.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/common.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const extend = __webpack_require__(/*! util-extend */ "./node_modules/util-extend/extend.js");

// --------------------------------------------------------------------
// Private Stuff
// --------------------------------------------------------------------

// Helpers

const escapeStringFor = {};
for (let c = 0; c < 128; c++) {
  escapeStringFor[c] = String.fromCharCode(c);
}
escapeStringFor["'".charCodeAt(0)] = "\\'";
escapeStringFor['"'.charCodeAt(0)] = '\\"';
escapeStringFor['\\'.charCodeAt(0)] = '\\\\';
escapeStringFor['\b'.charCodeAt(0)] = '\\b';
escapeStringFor['\f'.charCodeAt(0)] = '\\f';
escapeStringFor['\n'.charCodeAt(0)] = '\\n';
escapeStringFor['\r'.charCodeAt(0)] = '\\r';
escapeStringFor['\t'.charCodeAt(0)] = '\\t';
escapeStringFor['\u000b'.charCodeAt(0)] = '\\v';

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.abstract = function(optMethodName) {
  const methodName = optMethodName || '';
  return function() {
    throw new Error(
        'this method ' + methodName + ' is abstract! ' +
      '(it has no implementation in class ' + this.constructor.name + ')');
  };
};

exports.assert = function(cond, message) {
  if (!cond) {
    throw new Error(message);
  }
};

// Define a lazily-computed, non-enumerable property named `propName`
// on the object `obj`. `getterFn` will be called to compute the value the
// first time the property is accessed.
exports.defineLazyProperty = function(obj, propName, getterFn) {
  let memo;
  Object.defineProperty(obj, propName, {
    get() {
      if (!memo) {
        memo = getterFn.call(this);
      }
      return memo;
    }
  });
};

exports.clone = function(obj) {
  if (obj) {
    return extend({}, obj);
  }
  return obj;
};

exports.extend = extend;

exports.repeatFn = function(fn, n) {
  const arr = [];
  while (n-- > 0) {
    arr.push(fn());
  }
  return arr;
};

exports.repeatStr = function(str, n) {
  return new Array(n + 1).join(str);
};

exports.repeat = function(x, n) {
  return exports.repeatFn(() => x, n);
};

exports.getDuplicates = function(array) {
  const duplicates = [];
  for (let idx = 0; idx < array.length; idx++) {
    const x = array[idx];
    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {
      duplicates.push(x);
    }
  }
  return duplicates;
};

exports.copyWithoutDuplicates = function(array) {
  const noDuplicates = [];
  array.forEach(entry => {
    if (noDuplicates.indexOf(entry) < 0) {
      noDuplicates.push(entry);
    }
  });
  return noDuplicates;
};

exports.isSyntactic = function(ruleName) {
  const firstChar = ruleName[0];
  return firstChar === firstChar.toUpperCase();
};

exports.isLexical = function(ruleName) {
  return !exports.isSyntactic(ruleName);
};

exports.padLeft = function(str, len, optChar) {
  const ch = optChar || ' ';
  if (str.length < len) {
    return exports.repeatStr(ch, len - str.length) + str;
  }
  return str;
};

// StringBuffer

exports.StringBuffer = function() {
  this.strings = [];
};

exports.StringBuffer.prototype.append = function(str) {
  this.strings.push(str);
};

exports.StringBuffer.prototype.contents = function() {
  return this.strings.join('');
};

// Character escaping and unescaping

exports.escapeChar = function(c, optDelim) {
  const charCode = c.charCodeAt(0);
  if ((c === '"' || c === "'") && optDelim && c !== optDelim) {
    return c;
  } else if (charCode < 128) {
    return escapeStringFor[charCode];
  } else if (128 <= charCode && charCode < 256) {
    return '\\x' + exports.padLeft(charCode.toString(16), 2, '0');
  } else {
    return '\\u' + exports.padLeft(charCode.toString(16), 4, '0');
  }
};

exports.unescapeChar = function(s) {
  if (s.charAt(0) === '\\') {
    switch (s.charAt(1)) {
      case 'b': return '\b';
      case 'f': return '\f';
      case 'n': return '\n';
      case 'r': return '\r';
      case 't': return '\t';
      case 'v': return '\v';
      case 'x': return String.fromCharCode(parseInt(s.substring(2, 4), 16));
      case 'u': return String.fromCharCode(parseInt(s.substring(2, 6), 16));
      default: return s.charAt(1);
    }
  } else {
    return s;
  }
};

// Helper for producing a description of an unknown object in a safe way.
// Especially useful for error messages where an unexpected type of object was encountered.
exports.unexpectedObjToString = function(obj) {
  if (obj == null) {
    return String(obj);
  }
  const baseToString = Object.prototype.toString.call(obj);
  try {
    let typeName;
    if (obj.constructor && obj.constructor.name) {
      typeName = obj.constructor.name;
    } else if (baseToString.indexOf('[object ') === 0) {
      typeName = baseToString.slice(8, -1); // Extract e.g. "Array" from "[object Array]".
    } else {
      typeName = typeof obj;
    }
    return typeName + ': ' + JSON.stringify(String(obj));
  } catch (e) {
    return baseToString;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/errors.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/errors.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}

// ----------------- errors about intervals -----------------

function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}

// ----------------- errors about grammars -----------------

// Grammar syntax error

function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, 'message', {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, 'shortMessage', {
    enumerable: true,
    get() {
      return 'Expected ' + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}

// Undeclared grammar

function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ?
      'Grammar ' + grammarName + ' is not declared in namespace ' + Namespace.toString(namespace) :
      'Undeclared grammar ' + grammarName;
  return createError(message, interval);
}

// Duplicate grammar declaration

function duplicateGrammarDeclaration(grammar, namespace) {
  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');
}

// ----------------- rules -----------------

// Undeclared rule

function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,
      optInterval);
}

// Cannot override undeclared rule

function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Cannot extend undeclared rule

function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,
      optSource);
}

// Duplicate rule declaration

function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName +
      "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}

// Wrong number of parameters

function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
      'Wrong number of parameters for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      source);
}

// Wrong number of arguments

function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
      'Wrong number of arguments for rule ' + ruleName +
          ' (expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// Duplicate parameter names

function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(', '),
      source);
}

// Invalid parameter expression

function invalidParameter(ruleName, expr) {
  return createError(
      'Invalid parameter to rule ' + ruleName + ': ' + expr + ' has arity ' + expr.getArity() +
         ', but parameter expressions must have arity 1',
      expr.source);
}

// Application of syntactic rule from lexical rule

function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',
      applyExpr.source);
}

// Incorrect argument type

function incorrectArgumentType(expectedType, expr) {
  return createError('Incorrect argument type: expected ' + expectedType, expr.source);
}

// Multiple instances of the super-splice operator (`...`) in the rule body.

function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}

// ----------------- Kleene operators -----------------

function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ?
    applicationStack[applicationStack.length - 1].args :
    [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message =
    'Nullable expression ' + expr + " is not allowed inside '" +
    kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack
        .map(app => new pexprs.Apply(app.ruleName, app.args))
        .join('\n');
    message += '\nApplication stack (most recent application last):\n' + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}

// ----------------- arity -----------------

function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
      'Rule ' + ruleName + ' involves an alternation which has inconsistent arity ' +
          '(expected ' + expected + ', got ' + actual + ')',
      expr.source);
}

// ----------------- properties -----------------

function duplicatePropertyNames(duplicates) {
  return createError('Object pattern has duplicate property names: ' + duplicates.join(', '));
}

// ----------------- constructors -----------------

function invalidConstructorCall(grammar, ctorName, children) {
  return createError(
      'Attempt to invoke constructor ' + ctorName + ' with invalid or unexpected arguments');
}

// ----------------- convenience -----------------

function multipleErrors(errors) {
  const messages = errors.map(e => e.message);
  return createError(
      ['Errors:'].concat(messages).join('\n- '),
      errors[0].interval);
}

// ----------------- semantic -----------------

function missingSemanticAction(ctorName, name, type, stack) {
  let stackTrace = stack.slice(0, -1).map(info => {
    const ans = '  ' + info[0].name + ' > ' + info[1];
    return info.length === 3
        ? ans + " for '" + info[2] + "'"
        : ans;
  }).join('\n');
  stackTrace += '\n  ' + name + ' > ' + ctorName;

  const where = type + " '" + name + "'";
  const message = "Missing semantic action for '" + ctorName + "' in " + where + '\n' +
                'Action stack (most recent call last):\n' + stackTrace;

  const e = createError(message);
  e.name = 'missingSemanticAction';
  return e;
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  applicationOfSyntacticRuleFromLexicalContext,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  wrongNumberOfArguments,
  wrongNumberOfParameters,

  throwErrors(errors) {
    if (errors.length === 1) {
      throw errors[0];
    }
    if (errors.length > 1) {
      throw multipleErrors(errors);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/main.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/main.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global document, XMLHttpRequest */



// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Builder = __webpack_require__(/*! ./Builder */ "./node_modules/ohm-js/src/Builder.js");
const Grammar = __webpack_require__(/*! ./Grammar */ "./node_modules/ohm-js/src/Grammar.js");
const Namespace = __webpack_require__(/*! ./Namespace */ "./node_modules/ohm-js/src/Namespace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");
const version = __webpack_require__(/*! ./version */ "./node_modules/ohm-js/src/version.js");

const isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/ohm-js/node_modules/is-buffer/index.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// The metagrammar, i.e. the grammar for Ohm grammars. Initialized at the
// bottom of this file because loading the grammar requires Ohm itself.
let ohmGrammar;

// An object which makes it possible to stub out the document API for testing.
let documentInterface = {
  querySelector(sel) { return document.querySelector(sel); },
  querySelectorAll(sel) { return document.querySelectorAll(sel); }
};

const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);

// Check if `obj` is a DOM element.
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

function isUndefined(obj) {
  return obj === void 0; // eslint-disable-line no-void
}

const MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

function isArrayLike(obj) {
  if (obj == null) {
    return false;
  }
  const length = obj.length;
  return typeof length === 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
}

// TODO: just use the jQuery thing
function load(url) {
  const req = new XMLHttpRequest();
  req.open('GET', url, false);
  try {
    req.send();
    if (req.status === 0 || req.status === 200) {
      return req.responseText;
    }
  } catch (e) {}
  throw new Error('unable to load url ' + url);
}

// Returns a Grammar instance (i.e., an object with a `match` method) for
// `tree`, which is the concrete syntax tree of a user-written grammar.
// The grammar will be assigned into `namespace` under the name of the grammar
// as specified in the source.
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;

  // A visitor that produces a Grammar instance from the CST.
  const helpers = metaGrammar.createSemantics().addOperation('visit', {
    Grammar(n, s, open, rs, close) {
      const grammarName = n.visit();
      decl = builder.newGrammar(grammarName, namespace);
      s.visit();
      rs.visit();
      const g = decl.build();
      g.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors.duplicateGrammarDeclaration(g, namespace);
      }
      namespace[grammarName] = g;
      return g;
    },

    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === 'null') {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },

    Rule_define(n, fs, d, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      // If there is no default start rule yet, set it now. This must be done before visiting
      // the body, because it might contain an inline rule definition.
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b.visit();
      const description = d.visit()[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description, source);
    },
    Rule_override(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];

      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);

      overriding = true;
      const body = b.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.visit()[0] || [];
      const body = b.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      const args = terms.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();

      // Check if the super-splice operator (`...`) appears in the terms.
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);

        // Ensure it appears no more than once.
        afterTerms.forEach(t => {
          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);
        });

        return new pexprs.Splice(
            decl.superGrammar, currentRuleName, beforeTerms, afterTerms).withSource(this.source);
      } else {
        return builder.alt.apply(builder, args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },

    Params(opointy, ps, cpointy) {
      return ps.visit();
    },

    Alt(seqs) {
      const args = seqs.visit();
      return builder.alt.apply(builder, args).withSource(this.source);
    },

    TopLevelTerm_inline(b, n) {
      const inlineRuleName = currentRuleName + '_' + n.visit();
      const body = b.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration =
          !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map(formal => builder.app(formal));
      return builder.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },

    Seq(expr) {
      return builder.seq.apply(builder, expr.visit()).withSource(this.source);
    },

    Iter_star(x, _) {
      return builder.star(x.visit()).withSource(this.source);
    },
    Iter_plus(x, _) {
      return builder.plus(x.visit()).withSource(this.source);
    },
    Iter_opt(x, _) {
      return builder.opt(x.visit()).withSource(this.source);
    },

    Pred_not(_, x) {
      return builder.not(x.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x) {
      return builder.lookahead(x.visit()).withSource(this.source);
    },

    Lex_lex(_, x) {
      return builder.lex(x.visit()).withSource(this.source);
    },

    Base_application(rule, ps) {
      return builder.app(rule.visit(), ps.visit()[0] || []).withSource(this.source);
    },
    Base_range(from, _, to) {
      return builder.range(from.visit(), to.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x, close) {
      return x.visit();
    },

    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },

    caseName(_, space1, n, space2, end) {
      return n.visit();
    },

    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {},
    nameRest(expr) {},

    terminal(open, cs, close) {
      return cs.visit().join('');
    },

    oneCharTerminal(open, c, close) {
      return c.visit();
    },

    terminalChar(_) {
      return common.unescapeChar(this.sourceString);
    },

    escapeChar(_) {
      return this.sourceString;
    },

    NonemptyListOf(x, _, xs) {
      return [x.visit()].concat(xs.visit());
    },
    EmptyListOf() {
      return [];
    },

    _terminal() {
      return this.primitiveValue;
    }
  });
  return helpers(match).visit();
}

function compileAndLoad(source, namespace) {
  const m = ohmGrammar.match(source, 'Grammars');
  if (m.failed()) {
    throw errors.grammarSyntaxError(m);
  }
  return buildGrammar(m, namespace);
}

// Return the contents of a script element, fetching it via XHR if necessary.
function getScriptElementContents(el) {
  if (!isElement(el)) {
    throw new TypeError('Expected a DOM Node, got ' + common.unexpectedObjToString(el));
  }
  if (el.type !== 'text/ohm-js') {
    throw new Error('Expected a script tag with type="text/ohm-js", got ' + el);
  }
  return el.getAttribute('src') ? load(el.getAttribute('src')) : el.innerHTML;
}

function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);

  // Ensure that the source contained no more than one grammar definition.
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error('Missing grammar definition');
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
        util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) +
        'Found more than one grammar definition -- use ohm.grammars() instead.');
  }
  return ns[grammarNames[0]]; // Return the one and only grammar.
}

function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== 'string') {
    // For convenience, detect Node.js Buffer objects and automatically call toString().
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
          'Expected string as first argument, got ' + common.unexpectedObjToString(source));
    }
  }
  compileAndLoad(source, ns);
  return ns;
}

function grammarFromScriptElement(optNode) {
  let node = optNode;
  if (isUndefined(node)) {
    const nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
    if (nodeList.length !== 1) {
      throw new Error(
          'Expected exactly one script tag with type="text/ohm-js", found ' + nodeList.length);
    }
    node = nodeList[0];
  }
  return grammar(getScriptElementContents(node));
}

function grammarsFromScriptElements(optNodeOrNodeList) {
  // Simple case: the argument is a DOM node.
  if (isElement(optNodeOrNodeList)) {
    return grammars(optNodeOrNodeList);
  }
  // Otherwise, it must be either undefined or a NodeList.
  let nodeList = optNodeOrNodeList;
  if (isUndefined(nodeList)) {
    // Find all script elements with type="text/ohm-js".
    nodeList = documentInterface.querySelectorAll('script[type="text/ohm-js"]');
  } else if (typeof nodeList === 'string' || (!isElement(nodeList) && !isArrayLike(nodeList))) {
    throw new TypeError('Expected a Node, NodeList, or Array, but got ' + nodeList);
  }
  const ns = Namespace.createNamespace();
  for (let i = 0; i < nodeList.length; ++i) {
    // Copy the new grammars into `ns` to keep the namespace flat.
    common.extend(ns, grammars(getScriptElementContents(nodeList[i]), ns));
  }
  return ns;
}

function makeRecipe(recipe) {
  if (typeof recipe === 'function') {
    return recipe.call(new Builder());
  } else {
    if (typeof recipe === 'string') {
      // stringified JSON recipe
      recipe = JSON.parse(recipe);
    }
    return (new Builder()).fromRecipe(recipe);
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

// Stuff that users should know about
module.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null, // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util,
  extras: __webpack_require__(/*! ../extras */ "./node_modules/ohm-js/extras/index.js"),
  version
};

// Stuff for testing, etc.
module.exports._buildGrammar = buildGrammar;
module.exports._setDocumentInterfaceForTesting = function(doc) { documentInterface = doc; };

// Late initialization for stuff that is bootstrapped.

Grammar.BuiltInRules = __webpack_require__(/*! ../dist/built-in-rules */ "./node_modules/ohm-js/dist/built-in-rules.js");
util.announceBuiltInRules(Grammar.BuiltInRules);

module.exports.ohmGrammar = ohmGrammar = __webpack_require__(/*! ../dist/ohm-grammar */ "./node_modules/ohm-js/dist/ohm-grammar.js");
Grammar.initApplicationParser(ohmGrammar, buildGrammar);


/***/ }),

/***/ "./node_modules/ohm-js/src/nodes.js":
/*!******************************************!*\
  !*** ./node_modules/ohm-js/src/nodes.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

class Node {
  constructor(grammar, ctorName, matchLength) {
    this.grammar = grammar;
    this.ctorName = ctorName;
    this.matchLength = matchLength;
  }

  numChildren() {
    return this.children ? this.children.length : 0;
  }

  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }

  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }

  hasChildren() {
    return this.numChildren() > 1;
  }

  hasNoChildren() {
    return !this.hasChildren();
  }

  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
          'cannot get only child of a node of type ' + this.ctorName +
          ' (it has ' + this.numChildren() + ' children)');
    } else {
      return this.firstChild();
    }
  }

  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get first child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(0);
    }
  }

  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
          'cannot get last child of a ' + this.ctorName + ' node, which has no children');
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }

  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childBefore() called w/ an argument that is not a child');
    } else if (childIdx === 0) {
      throw new Error('cannot get child before first child');
    } else {
      return this.childAt(childIdx - 1);
    }
  }

  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error('Node.childAfter() called w/ an argument that is not a child');
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error('cannot get child after last child');
    } else {
      return this.childAt(childIdx + 1);
    }
  }

  isTerminal() {
    return false;
  }

  isNonterminal() {
    return false;
  }

  isIteration() {
    return false;
  }

  isOptional() {
    return false;
  }

  toJSON() {
    return {[this.ctorName]: this.children};
  }
}

// Terminals

class TerminalNode extends Node {
  constructor(grammar, value) {
    const matchLength = value ? value.length : 0;
    super(grammar, '_terminal', matchLength);
    this.primitiveValue = value;
  }

  isTerminal() {
    return true;
  }

  toJSON() {
    return {[this.ctorName]: this.primitiveValue};
  }
}

// Nonterminals

class NonterminalNode extends Node {
  constructor(grammar, ruleName, children, childOffsets, matchLength) {
    super(grammar, ruleName, matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
  }

  isNonterminal() {
    return true;
  }

  isLexical() {
    return common.isLexical(this.ctorName);
  }

  isSyntactic() {
    return common.isSyntactic(this.ctorName);
  }
}

// Iterations

class IterationNode extends Node {
  constructor(grammar, children, childOffsets, matchLength, isOptional) {
    super(grammar, '_iter', matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }

  isIteration() {
    return true;
  }

  isOptional() {
    return this.optional;
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = {
  Node,
  TerminalNode,
  NonterminalNode,
  IterationNode
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js":
/*!************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Return true if we should skip spaces preceding this expression in a syntactic context.
*/
pexprs.PExpr.prototype.allowsSkippingPrecedingSpace = common.abstract(
    'allowsSkippingPrecedingSpace'
);

/*
  Generally, these are all first-order expressions and (with the exception of Apply)
  directly read from the input stream.
*/
pexprs.any.allowsSkippingPrecedingSpace =
pexprs.end.allowsSkippingPrecedingSpace =
pexprs.Apply.prototype.allowsSkippingPrecedingSpace =
pexprs.Terminal.prototype.allowsSkippingPrecedingSpace =
pexprs.Range.prototype.allowsSkippingPrecedingSpace =
pexprs.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};

/*
  Higher-order expressions that don't directly consume input.
*/
pexprs.Alt.prototype.allowsSkippingPrecedingSpace =
pexprs.Iter.prototype.allowsSkippingPrecedingSpace =
pexprs.Lex.prototype.allowsSkippingPrecedingSpace =
pexprs.Lookahead.prototype.allowsSkippingPrecedingSpace =
pexprs.Not.prototype.allowsSkippingPrecedingSpace =
pexprs.Param.prototype.allowsSkippingPrecedingSpace =
pexprs.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");
const util = __webpack_require__(/*! ./util */ "./node_modules/ohm-js/src/util.js");

let BuiltInRules;

util.awaitBuiltInRules(g => { BuiltInRules = g; });

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

let lexifyCount;

pexprs.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.PExpr.prototype._assertAllApplicationsAreValid = common.abstract(
    '_assertAllApplicationsAreValid'
);

pexprs.any._assertAllApplicationsAreValid =
pexprs.end._assertAllApplicationsAreValid =
pexprs.Terminal.prototype._assertAllApplicationsAreValid =
pexprs.Range.prototype._assertAllApplicationsAreValid =
pexprs.Param.prototype._assertAllApplicationsAreValid =
pexprs.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  // no-op
};

pexprs.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
  lexifyCount--;
};

pexprs.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);
  }
};

pexprs.Iter.prototype._assertAllApplicationsAreValid =
pexprs.Not.prototype._assertAllApplicationsAreValid =
pexprs.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar);
};

pexprs.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
  const ruleInfo = grammar.rules[this.ruleName];

  // Make sure that the rule exists...
  if (!ruleInfo) {
    throw errors.undeclaredRule(this.ruleName, grammar.name, this.source);
  }

  // ...and that this application is allowed
  if (common.isSyntactic(this.ruleName) && (!common.isSyntactic(ruleName) || lexifyCount > 0)) {
    throw errors.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }

  // ...and that this application has the correct number of arguments
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }

  // ...and that all of the argument expressions only have valid applications and have arity 1.
  const self = this;
  this.args.forEach(arg => {
    arg._assertAllApplicationsAreValid(ruleName, grammar);
    if (arg.getArity() !== 1) {
      throw errors.invalidParameter(self.ruleName, arg);
    }
  });

  // Extra checks for "special" applications

  // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.
  if (BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive) {
    if (!(this.args[0] instanceof pexprs.Terminal)) {
      throw errors.incorrectArgumentType('a Terminal (e.g. \"abc\")', this.args[0]);
    }
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertChoicesHaveUniformArity = common.abstract(
    'assertChoicesHaveUniformArity'
);

pexprs.any.assertChoicesHaveUniformArity =
pexprs.end.assertChoicesHaveUniformArity =
pexprs.Terminal.prototype.assertChoicesHaveUniformArity =
pexprs.Range.prototype.assertChoicesHaveUniformArity =
pexprs.Param.prototype.assertChoicesHaveUniformArity =
pexprs.Lex.prototype.assertChoicesHaveUniformArity =
pexprs.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op
};

pexprs.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};

pexprs.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // Extend is a special case of Alt that's guaranteed to have exactly two
  // cases: [extensions, origBody].
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};

pexprs.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};

pexprs.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // no-op (not required b/c the nested expr doesn't show up in the CST)
};

pexprs.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};

pexprs.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  // The arities of the parameter expressions is required to be 1 by
  // `assertAllApplicationsAreValid()`.
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.assertIteratedExprsAreNotNullable = common.abstract(
    'assertIteratedExprsAreNotNullable'
);

pexprs.any.assertIteratedExprsAreNotNullable =
pexprs.end.assertIteratedExprsAreNotNullable =
pexprs.Terminal.prototype.assertIteratedExprsAreNotNullable =
pexprs.Range.prototype.assertIteratedExprsAreNotNullable =
pexprs.Param.prototype.assertIteratedExprsAreNotNullable =
pexprs.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // no-op
};

pexprs.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar);
  }
};

pexprs.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  // Note: this is the implementation of this method for `Star` and `Plus` expressions.
  // It is overridden for `Opt` below.
  this.expr.assertIteratedExprsAreNotNullable(grammar);
  if (this.expr.isNullable(grammar)) {
    throw errors.kleeneExprHasNullableOperand(this, []);
  }
};

pexprs.Opt.prototype.assertIteratedExprsAreNotNullable =
pexprs.Not.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lookahead.prototype.assertIteratedExprsAreNotNullable =
pexprs.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.expr.assertIteratedExprsAreNotNullable(grammar);
};

pexprs.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
  this.args.forEach(arg => {
    arg.assertIteratedExprsAreNotNullable(grammar);
  });
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-check.js":
/*!*************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-check.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.check = common.abstract('check');

pexprs.any.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.end.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === undefined;
};

pexprs.Terminal.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         vals[0].primitiveValue === this.obj;
};

pexprs.Range.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === typeof this.from;
};

pexprs.Param.prototype.check = function(grammar, vals) {
  return vals.length >= 1;
};

pexprs.Alt.prototype.check = function(grammar, vals) {
  for (let i = 0; i < this.terms.length; i++) {
    const term = this.terms[i];
    if (term.check(grammar, vals)) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.check = function(grammar, vals) {
  let pos = 0;
  for (let i = 0; i < this.factors.length; i++) {
    const factor = this.factors[i];
    if (factor.check(grammar, vals.slice(pos))) {
      pos += factor.getArity();
    } else {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.check = function(grammar, vals) {
  const arity = this.getArity();
  const columns = vals.slice(0, arity);
  if (columns.length !== arity) {
    return false;
  }
  const rowCount = columns[0].length;
  let i;
  for (i = 1; i < arity; i++) {
    if (columns[i].length !== rowCount) {
      return false;
    }
  }

  for (i = 0; i < rowCount; i++) {
    const row = [];
    for (let j = 0; j < arity; j++) {
      row.push(columns[j][i]);
    }
    if (!this.expr.check(grammar, row)) {
      return false;
    }
  }

  return true;
};

pexprs.Not.prototype.check = function(grammar, vals) {
  return true;
};

pexprs.Lookahead.prototype.check =
pexprs.Lex.prototype.check = function(grammar, vals) {
  return this.expr.check(grammar, vals);
};

pexprs.Apply.prototype.check = function(grammar, vals) {
  if (!(vals[0] instanceof nodes.Node &&
        vals[0].grammar === grammar &&
        vals[0].ctorName === this.ruleName)) {
    return false;
  }

  // TODO: think about *not* doing the following checks, i.e., trusting that the rule
  // was correctly constructed.
  const ruleNode = vals[0];
  const body = grammar.rules[this.ruleName].body;
  return body.check(grammar, ruleNode.children) && ruleNode.numChildren() === body.getArity();
};

pexprs.UnicodeChar.prototype.check = function(grammar, vals) {
  return vals[0] instanceof nodes.Node &&
         vals[0].isTerminal() &&
         typeof vals[0].primitiveValue === 'string';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-eval.js":
/*!************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-eval.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Trace = __webpack_require__(/*! ./Trace */ "./node_modules/ohm-js/src/Trace.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/ohm-js/src/errors.js");
const nodes = __webpack_require__(/*! ./nodes */ "./node_modules/ohm-js/src/nodes.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const TerminalNode = nodes.TerminalNode;
const NonterminalNode = nodes.NonterminalNode;
const IterationNode = nodes.IterationNode;

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should
  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures
  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific
  data structures to be "secrets" of that class, which is good for modularity.)

  The contract of this method is as follows:
  * When the return value is `true`,
    - the state object will have `expr.getArity()` more bindings than it did before the call.
  * When the return value is `false`,
    - the state object may have more bindings than it did before the call, and
    - its input stream's position may be anywhere.

  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state
  object's bindings nor its input stream's position will change if the expression fails to match.
*/
pexprs.PExpr.prototype.eval = common.abstract('eval'); // function(state) { ... }

pexprs.any.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.end.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode(state.grammar, undefined), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Terminal.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode(state.grammar, this.obj), origPos);
    return true;
  }
};

pexprs.Range.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.from <= ch && ch <= this.to) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};

pexprs.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};

pexprs.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};

pexprs.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};

pexprs.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};

pexprs.Iter.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }

  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];

    const endOffset =
        lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
        new IterationNode(state.grammar, cols[idx], colOffsets[idx], matchLength, isOptional));
    state._bindingOffsets.push(offset);
  }
  return true;
};

pexprs.Not.prototype.eval = function(state) {
  /*
    TODO:
    - Right now we're just throwing away all of the failures that happen inside a `not`, and
      recording `this` as a failed expression.
    - Double negation should be equivalent to lookahead, but that's not the case right now wrt
      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce
      a failure for 'foo' instead.
  */

  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();

  const ans = state.eval(this.expr);

  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }

  inputStream.pos = origPos;
  return true;
};

pexprs.Lookahead.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};

pexprs.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);

  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    // This rule is already active at this position, i.e., it is left-recursive.
    return app.handleCycle(state);
  }

  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];

  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};

pexprs.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const currentLeftRecursion = posInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];

  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    // We already know about this left recursion, but it's possible there are "involved
    // applications" that we don't already know about, so...
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    // New left recursion detected! Memoize a failure to try to get a seed parse.
    memoRec = posInfo.memoize(
        memoKey,
        {matchLength: 0, examinedLength: 0, value: false, rightmostFailureOffset: -1});
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};

pexprs.Apply.prototype.reallyEval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const body = ruleInfo.body;
  const description = ruleInfo.description;

  state.enterApplication(origPosInfo, this);

  if (description) {
    state.pushFailuresInfo();
  }

  // Reset the input stream's examinedLength property so that we can track
  // the examined length of this particular application.
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;

  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;

  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec); // updates origPosInfo's maxExaminedLength
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    // This application is not involved in left recursion, so it's ok to memoize it.
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;

  if (description) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }

  // Record trace information in the memo table, so that it is available if the memoized result
  // is used later.
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }

  // Fix the input stream's examinedLength -- it should be the maximum examined length
  // across all applications, not just this one.
  inputStream.examinedLength = Math.max(inputStream.examinedLength, origInputStreamExaminedLength);

  state.exitApplication(origPosInfo, value);

  return succeeded;
};

pexprs.Apply.prototype.evalOnce = function(expr, state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;

  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    return new NonterminalNode(
        state.grammar, this.ruleName, bindings, offsets, inputStream.pos - origPos);
  } else {
    return false;
  }
};

pexprs.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }

  const inputStream = state.inputStream;

  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();

    if (state.isTracing()) {
      // Before evaluating the body again, add a trace node for this application to the memo entry.
      // Its only child is a copy of the trace node from `newValue`, which will always be the last
      // element in `state.trace`.
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace(
          state.input, origPos, inputStream.pos, this, true, [newValue], [seedTrace.clone()]);
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1); // Drop the trace for the old seed.
    }
  }
  if (state.isTracing()) {
    // The last entry is for an unused result -- pop it and save it in the "real" entry.
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};

pexprs.UnicodeChar.prototype.eval = function(state) {
  const inputStream = state.inputStream;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode(state.grammar, ch), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-generateExample.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-generateExample.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Helpers
// --------------------------------------------------------------------

function flatten(listOfLists) {
  return Array.prototype.concat.apply([], listOfLists);
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.generateExample = common.abstract('generateExample');

function categorizeExamples(examples) {
  // A list of rules that the system needs examples of, in order to generate an example
  //   for the current rule
  let examplesNeeded = examples.filter(example => example.hasOwnProperty('examplesNeeded'))
      .map(example => example.examplesNeeded);

  examplesNeeded = flatten(examplesNeeded);

  const uniqueExamplesNeeded = {};
  for (let i = 0; i < examplesNeeded.length; i++) {
    const currentExampleNeeded = examplesNeeded[i];
    uniqueExamplesNeeded[currentExampleNeeded] = true;
  }
  examplesNeeded = Object.keys(uniqueExamplesNeeded);

  // A list of successfully generated examples
  const successfulExamples = examples.filter(example => example.hasOwnProperty('value'))
      .map(item => item.value);

  // This flag returns true if the system cannot generate the rule it is currently
  //   attempting to generate, regardless of whether or not it has the examples it needs.
  //   Currently, this is only used in overriding generators to prevent the system from
  //   generating examples for certain rules (e.g. 'ident').
  const needHelp = examples.some(item => item.needHelp);

  return {
    examplesNeeded,
    successfulExamples,
    needHelp
  };
}

pexprs.any.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return {value: String.fromCharCode(Math.floor(Math.random() * 255))};
};

// Assumes that terminal's object is always a string
pexprs.Terminal.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: this.obj};
};

pexprs.Range.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  const rangeSize = this.to.charCodeAt(0) - this.from.charCodeAt(0);
  return {value: String.fromCharCode(
      this.from.charCodeAt(0) + Math.floor(rangeSize * Math.random())
  )};
};

pexprs.Param.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return actuals[this.index].generateExample(grammar, examples, inSyntacticContext, actuals);
};

pexprs.Alt.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  // items -> termExamples
  const termExamples = this.terms.map(term => {
    return term.generateExample(grammar, examples, inSyntacticContext, actuals);
  });

  const categorizedExamples = categorizeExamples(termExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // Alt can contain both an example and a request for examples
  if (successfulExamples.length > 0) {
    const i = Math.floor(Math.random() * successfulExamples.length);
    ans.value = successfulExamples[i];
  }
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }
  ans.needHelp = needHelp;

  return ans;
};

pexprs.Seq.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const factorExamples = this.factors.map(factor => {
    return factor.generateExample(grammar, examples, inSyntacticContext, actuals);
  });
  const categorizedExamples = categorizeExamples(factorExamples);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;
  const needHelp = categorizedExamples.needHelp;

  const ans = {};

  // In a Seq, all pieces must succeed in order to have a successful example.
  if (examplesNeeded.length > 0 || needHelp) {
    ans.examplesNeeded = examplesNeeded;
    ans.needHelp = needHelp;
  } else {
    ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  }

  return ans;
};

pexprs.Iter.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const rangeTimes = Math.min(this.maxNumMatches - this.minNumMatches, 3);
  const numTimes = Math.floor(Math.random() * (rangeTimes + 1) + this.minNumMatches);
  const items = [];

  for (let i = 0; i < numTimes; i++) {
    items.push(this.expr.generateExample(grammar, examples, inSyntacticContext, actuals));
  }

  const categorizedExamples = categorizeExamples(items);

  const examplesNeeded = categorizedExamples.examplesNeeded;
  const successfulExamples = categorizedExamples.successfulExamples;

  const ans = {};

  // It's always either one or the other.
  // TODO: instead of ' ', call 'spaces.generateExample()'
  ans.value = successfulExamples.join(inSyntacticContext ? ' ' : '');
  if (examplesNeeded.length > 0) {
    ans.examplesNeeded = examplesNeeded;
  }

  return ans;
};

// Right now, 'Not' and 'Lookahead' generate nothing and assume that whatever follows will
//   work according to the encoded constraints.
pexprs.Not.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lookahead.prototype.generateExample = function(grammar, examples, inSyntacticContext) {
  return {value: ''};
};

pexprs.Lex.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  return this.expr.generateExample(grammar, examples, false, actuals);
};

pexprs.Apply.prototype.generateExample = function(grammar, examples, inSyntacticContext, actuals) {
  const ans = {};

  const ruleName = this.substituteParams(actuals).toString();

  if (!examples.hasOwnProperty(ruleName)) {
    ans.examplesNeeded = [ruleName];
  } else {
    const relevantExamples = examples[ruleName];
    const i = Math.floor(Math.random() * relevantExamples.length);
    ans.value = relevantExamples[i];
  }

  return ans;
};

pexprs.UnicodeChar.prototype.generateExample = function(
    grammar, examples, inSyntacticContext, actuals) {
  let char;
  switch (this.category) {
    case 'Lu': char = ''; break;
    case 'Ll': char = ''; break;
    case 'Lt': char = ''; break;
    case 'Lm': char = ''; break;
    case 'Lo': char = ''; break;

    case 'Nl': char = ''; break;
    case 'Nd': char = ''; break;

    case 'Mn': char = '\u0487'; break;
    case 'Mc': char = ''; break;

    case 'Pc': char = ''; break;

    case 'Zs': char = '\u2001'; break;

    case 'L': char = ''; break;
    case 'Ltmo': char = ''; break;
  }
  return {value: char}; // 
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-getArity.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-getArity.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.getArity = common.abstract('getArity');

pexprs.any.getArity =
pexprs.end.getArity =
pexprs.Terminal.prototype.getArity =
pexprs.Range.prototype.getArity =
pexprs.Param.prototype.getArity =
pexprs.Apply.prototype.getArity =
pexprs.UnicodeChar.prototype.getArity = function() {
  return 1;
};

pexprs.Alt.prototype.getArity = function() {
  // This is ok b/c all terms must have the same arity -- this property is
  // checked by the Grammar constructor.
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};

pexprs.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};

pexprs.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};

pexprs.Not.prototype.getArity = function() {
  return 0;
};

pexprs.Lookahead.prototype.getArity =
pexprs.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-introduceParams.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-introduceParams.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Called at grammar creation time to rewrite a rule body, replacing each reference to a formal
  parameter with a `Param` node. Returns a PExpr -- either a new one, or the original one if
  it was modified in place.
*/
pexprs.PExpr.prototype.introduceParams = common.abstract('introduceParams');

pexprs.any.introduceParams =
pexprs.end.introduceParams =
pexprs.Terminal.prototype.introduceParams =
pexprs.Range.prototype.introduceParams =
pexprs.Param.prototype.introduceParams =
pexprs.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};

pexprs.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};

pexprs.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};

pexprs.Iter.prototype.introduceParams =
pexprs.Not.prototype.introduceParams =
pexprs.Lookahead.prototype.introduceParams =
pexprs.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};

pexprs.Apply.prototype.introduceParams = function(formals) {
  const index = formals.indexOf(this.ruleName);
  if (index >= 0) {
    if (this.args.length > 0) {
      // TODO: Should this be supported? See issue #64.
      throw new Error('Parameterized rules cannot be passed as arguments to another rule.');
    }
    return new pexprs.Param(index).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-isNullable.js":
/*!******************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-isNullable.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns `true` if this parsing expression may accept without consuming any input.
pexprs.PExpr.prototype.isNullable = function(grammar) {
  return this._isNullable(grammar, Object.create(null));
};

pexprs.PExpr.prototype._isNullable = common.abstract('_isNullable');

pexprs.any._isNullable =
pexprs.Range.prototype._isNullable =
pexprs.Param.prototype._isNullable =
pexprs.Plus.prototype._isNullable =
pexprs.UnicodeChar.prototype._isNullable = function(grammar, memo) {
  return false;
};

pexprs.end._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Terminal.prototype._isNullable = function(grammar, memo) {
  if (typeof this.obj === 'string') {
    // This is an over-simplification: it's only correct if the input is a string. If it's an array
    // or an object, then the empty string parsing expression is not nullable.
    return this.obj === '';
  } else {
    return false;
  }
};

pexprs.Alt.prototype._isNullable = function(grammar, memo) {
  return this.terms.length === 0 ||
      this.terms.some(term => term._isNullable(grammar, memo));
};

pexprs.Seq.prototype._isNullable = function(grammar, memo) {
  return this.factors.every(factor => factor._isNullable(grammar, memo));
};

pexprs.Star.prototype._isNullable =
pexprs.Opt.prototype._isNullable =
pexprs.Not.prototype._isNullable =
pexprs.Lookahead.prototype._isNullable = function(grammar, memo) {
  return true;
};

pexprs.Lex.prototype._isNullable = function(grammar, memo) {
  return this.expr._isNullable(grammar, memo);
};

pexprs.Apply.prototype._isNullable = function(grammar, memo) {
  const key = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key)) {
    const body = grammar.rules[this.ruleName].body;
    const inlined = body.substituteParams(this.args);
    memo[key] = false; // Prevent infinite recursion for recursive rules.
    memo[key] = inlined._isNullable(grammar, memo);
  }
  return memo[key];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-outputRecipe.js":
/*!********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-outputRecipe.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.outputRecipe = common.abstract('outputRecipe');

pexprs.any.outputRecipe = function(formals, grammarInterval) {
  return ['any', getMetaInfo(this, grammarInterval)];
};

pexprs.end.outputRecipe = function(formals, grammarInterval) {
  return ['end', getMetaInfo(this, grammarInterval)];
};

pexprs.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'terminal',
    getMetaInfo(this, grammarInterval),
    this.obj
  ];
};

pexprs.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'range',
    getMetaInfo(this, grammarInterval),
    this.from,
    this.to
  ];
};

pexprs.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'param',
    getMetaInfo(this, grammarInterval),
    this.index
  ];
};

pexprs.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'alt',
    getMetaInfo(this, grammarInterval)
  ].concat(this.terms.map(term => term.outputRecipe(formals, grammarInterval)));
};

pexprs.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0]; // [extension, original]
  return extension.outputRecipe(formals, grammarInterval);
};

pexprs.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    'splice',
    getMetaInfo(this, grammarInterval),
    beforeTerms.map(term => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map(term => term.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'seq',
    getMetaInfo(this, grammarInterval)
  ].concat(this.factors.map(factor => factor.outputRecipe(formals, grammarInterval)));
};

pexprs.Star.prototype.outputRecipe =
pexprs.Plus.prototype.outputRecipe =
pexprs.Opt.prototype.outputRecipe =
pexprs.Not.prototype.outputRecipe =
pexprs.Lookahead.prototype.outputRecipe =
pexprs.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};

pexprs.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'app',
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map(arg => arg.outputRecipe(formals, grammarInterval))
  ];
};

pexprs.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    'unicodeChar',
    getMetaInfo(this, grammarInterval),
    this.category
  ];
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-substituteParams.js":
/*!************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-substituteParams.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a PExpr that results from recursively replacing every formal parameter (i.e., instance
  of `Param`) inside this PExpr with its actual value from `actuals` (an Array).

  The receiver must not be modified; a new PExpr must be returned if any replacement is necessary.
*/
// function(actuals) { ... }
pexprs.PExpr.prototype.substituteParams = common.abstract('substituteParams');

pexprs.any.substituteParams =
pexprs.end.substituteParams =
pexprs.Terminal.prototype.substituteParams =
pexprs.Range.prototype.substituteParams =
pexprs.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};

pexprs.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};

pexprs.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs.Alt(
      this.terms.map(term => term.substituteParams(actuals)));
};

pexprs.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs.Seq(
      this.factors.map(factor => factor.substituteParams(actuals)));
};

pexprs.Iter.prototype.substituteParams =
pexprs.Not.prototype.substituteParams =
pexprs.Lookahead.prototype.substituteParams =
pexprs.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};

pexprs.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    // Avoid making a copy of this application, as an optimization
    return this;
  } else {
    const args = this.args.map(arg => arg.substituteParams(actuals));
    return new pexprs.Apply(this.ruleName, args);
  }
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toArgumentNameList.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

const {copyWithoutDuplicates} = common;

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}

function resolveDuplicatedNames(argumentNameList) {
  // `count` is used to record the number of times each argument name occurs in the list,
  // this is useful for checking duplicated argument name. It maps argument names to ints.
  const count = Object.create(null);
  argumentNameList.forEach(argName => {
    count[argName] = (count[argName] || 0) + 1;
  });

  // Append subscripts ('_1', '_2', ...) to duplicate argument names.
  Object.keys(count).forEach(dupArgName => {
    if (count[dupArgName] <= 1) {
      return;
    }

    // This name shows up more than once, so add subscripts.
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + '_' + subscript++;
      }
    });
  });
}

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  Returns a list of strings that will be used as the default argument names for its receiver
  (a pexpr) in a semantic action. This is used exclusively by the Semantics Editor.

  `firstArgIndex` is the 1-based index of the first argument name that will be generated for this
  pexpr. It enables us to name arguments positionally, e.g., if the second argument is a
  non-alphanumeric terminal like "+", it will be named '$2'.

  `noDupCheck` is true if the caller of `toArgumentNameList` is not a top level caller. It enables
  us to avoid nested duplication subscripts appending, e.g., '_1_1', '_1_2', by only checking
  duplicates at the top level.

  Here is a more elaborate example that illustrates how this method works:
  `(a "+" b).toArgumentNameList(1)` evaluates to `['a', '$2', 'b']` with the following recursive
  calls:

    (a).toArgumentNameList(1) -> ['a'],
    ("+").toArgumentNameList(2) -> ['$2'],
    (b).toArgumentNameList(3) -> ['b']

  Notes:
  * This method must only be called on well-formed expressions, e.g., the receiver must
    not have any Alt sub-expressions with inconsistent arities.
  * e.getArity() === e.toArgumentNameList(1).length
*/
// function(firstArgIndex, noDupCheck) { ... }
pexprs.PExpr.prototype.toArgumentNameList = common.abstract('toArgumentNameList');

pexprs.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['any'];
};

pexprs.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['end'];
};

pexprs.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === 'string' && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    // If this terminal is a valid suffix for a JS identifier, just prepend it with '_'
    return ['_' + this.obj];
  } else {
    // Otherwise, name it positionally.
    return ['$' + firstArgIndex];
  }
};

pexprs.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + '_to_' + this.to;
  // If the `argName` is not valid then try to prepend a `_`.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '_' + argName;
  }
  // If the `argName` still not valid after prepending a `_`, then name it positionally.
  if (!isRestrictedJSIdentifier(argName)) {
    argName = '$' + firstArgIndex;
  }
  return [argName];
};

pexprs.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // `termArgNameLists` is an array of arrays where each row is the
  // argument name list that corresponds to a term in this alternation.
  const termArgNameLists = this.terms.map(term => term.toArgumentNameList(firstArgIndex, true));

  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join('_or_'));
  }

  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  // Generate the argument name list, without worrying about duplicates.
  let argumentNameList = [];
  this.factors.forEach(factor => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);

    // Shift the firstArgIndex to take this factor's argument names into account.
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck)
      .map(exprArgumentString => exprArgumentString[exprArgumentString.length - 1] === 's' ?
          exprArgumentString + 'es' :
          exprArgumentString + 's');
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};

pexprs.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(argName => {
    return 'opt' + argName[0].toUpperCase() + argName.slice(1);
  });
};

pexprs.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};

pexprs.Lookahead.prototype.toArgumentNameList =
pexprs.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};

pexprs.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};

pexprs.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['$' + firstArgIndex];
};

pexprs.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ['param' + this.index];
};

// "Value pexprs" (Value, Str, Arr, Obj) are going away soon, so we don't worry about them here.


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toDisplayString.js":
/*!***********************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toDisplayString.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

// Returns a string representing the PExpr, for use as a UI label, etc.
pexprs.PExpr.prototype.toDisplayString = common.abstract('toDisplayString');

pexprs.Alt.prototype.toDisplayString =
pexprs.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return '[' + this.constructor.name + ']';
};

pexprs.any.toDisplayString =
pexprs.end.toDisplayString =
pexprs.Iter.prototype.toDisplayString =
pexprs.Not.prototype.toDisplayString =
pexprs.Lookahead.prototype.toDisplayString =
pexprs.Lex.prototype.toDisplayString =
pexprs.Terminal.prototype.toDisplayString =
pexprs.Range.prototype.toDisplayString =
pexprs.Param.prototype.toDisplayString = function() {
  return this.toString();
};

pexprs.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toDisplayString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toDisplayString = function() {
  return 'Unicode [' + this.category + '] character';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toFailure.js":
/*!*****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toFailure.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const Failure = __webpack_require__(/*! ./Failure */ "./node_modules/ohm-js/src/Failure.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

pexprs.PExpr.prototype.toFailure = common.abstract('toFailure');

pexprs.any.toFailure = function(grammar) {
  return new Failure(this, 'any object', 'description');
};

pexprs.end.toFailure = function(grammar) {
  return new Failure(this, 'end of input', 'description');
};

pexprs.Terminal.prototype.toFailure = function(grammar) {
  return new Failure(this, this.obj, 'string');
};

pexprs.Range.prototype.toFailure = function(grammar) {
  // TODO: come up with something better
  return new Failure(this, JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');
};

pexprs.Not.prototype.toFailure = function(grammar) {
  const description = this.expr === pexprs.any ?
      'nothing' :
      'not ' + this.expr.toFailure(grammar);
  return new Failure(this, description, 'description');
};

pexprs.Lookahead.prototype.toFailure = function(grammar) {
  return this.expr.toFailure(grammar);
};

pexprs.Apply.prototype.toFailure = function(grammar) {
  let description = grammar.rules[this.ruleName].description;
  if (!description) {
    const article = (/^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a');
    description = article + ' ' + this.ruleName;
  }
  return new Failure(this, description, 'description');
};

pexprs.UnicodeChar.prototype.toFailure = function(grammar) {
  return new Failure(this, 'a Unicode [' + this.category + '] character', 'description');
};

pexprs.Alt.prototype.toFailure = function(grammar) {
  const fs = this.terms.map(t => t.toFailure(grammar));
  const description = '(' + fs.join(' or ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Seq.prototype.toFailure = function(grammar) {
  const fs = this.factors.map(f => f.toFailure(grammar));
  const description = '(' + fs.join(' ') + ')';
  return new Failure(this, description, 'description');
};

pexprs.Iter.prototype.toFailure = function(grammar) {
  const description = '(' + this.expr.toFailure(grammar) + this.operator + ')';
  return new Failure(this, description, 'description');
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs-toString.js":
/*!****************************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs-toString.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");
const pexprs = __webpack_require__(/*! ./pexprs */ "./node_modules/ohm-js/src/pexprs.js");

// --------------------------------------------------------------------
// Operations
// --------------------------------------------------------------------

/*
  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.
  Note that this is not an iff (<==>): e.g.,
  (~"b" "a").toString() !== ("a").toString(), even though
  ~"b" "a" and "a" are interchangeable in any grammar,
  both in terms of the languages they accept and their arities.
*/
pexprs.PExpr.prototype.toString = common.abstract('toString');

pexprs.any.toString = function() {
  return 'any';
};

pexprs.end.toString = function() {
  return 'end';
};

pexprs.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};

pexprs.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);
};

pexprs.Param.prototype.toString = function() {
  return '$' + this.index;
};

pexprs.Lex.prototype.toString = function() {
  return '#(' + this.expr.toString() + ')';
};

pexprs.Alt.prototype.toString = function() {
  return this.terms.length === 1 ?
    this.terms[0].toString() :
    '(' + this.terms.map(term => term.toString()).join(' | ') + ')';
};

pexprs.Seq.prototype.toString = function() {
  return this.factors.length === 1 ?
    this.factors[0].toString() :
    '(' + this.factors.map(factor => factor.toString()).join(' ') + ')';
};

pexprs.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};

pexprs.Not.prototype.toString = function() {
  return '~' + this.expr;
};

pexprs.Lookahead.prototype.toString = function() {
  return '&' + this.expr;
};

pexprs.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map(arg => arg.toString());
    return this.ruleName + '<' + ps.join(',') + '>';
  } else {
    return this.ruleName;
  }
};

pexprs.UnicodeChar.prototype.toString = function() {
  return '\\p{' + this.category + '}';
};


/***/ }),

/***/ "./node_modules/ohm-js/src/pexprs.js":
/*!*******************************************!*\
  !*** ./node_modules/ohm-js/src/pexprs.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const UnicodeCategories = __webpack_require__(/*! ../third_party/UnicodeCategories */ "./node_modules/ohm-js/third_party/UnicodeCategories.js");
const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// General stuff

class PExpr {
  constructor() {
    if (this.constructor === PExpr) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }

  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}

// Any

const any = Object.create(PExpr.prototype);

// End

const end = Object.create(PExpr.prototype);

// Terminals

class Terminal extends PExpr {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}

// Ranges

class Range extends PExpr {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
  }
}

// Parameters

class Param extends PExpr {
  constructor(index) {
    super();
    this.index = index;
  }
}

// Alternation

class Alt extends PExpr {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}

// Extend is an implementation detail of rule extension

class Extend extends Alt {
  constructor(superGrammar, name, body) {
    const origBody = superGrammar.rules[name].body;
    super([body, origBody]);

    this.superGrammar = superGrammar;
    this.name = name;
    this.body = body;
  }
}

// Splice is an implementation detail of rule overriding with the `...` operator.
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);

    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}

// Sequences

class Seq extends PExpr {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}

// Iterators and optionals

class Iter extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Star extends Iter {}
class Plus extends Iter {}
class Opt extends Iter {}

Star.prototype.operator = '*';
Plus.prototype.operator = '+';
Opt.prototype.operator = '?';

Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;

Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;

// Predicates

class Not extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

class Lookahead extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// "Lexification"

class Lex extends PExpr {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}

// Rule application

class Apply extends PExpr {
  constructor(ruleName, args=[]) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }

  isSyntactic() {
    return common.isSyntactic(this.ruleName);
  }

  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, '_memoKey', {value: this.toString()});
    }
    return this._memoKey;
  }
}

// Unicode character

class UnicodeChar extends PExpr {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

exports.PExpr = PExpr;
exports.any = any;
exports.end = end;
exports.Terminal = Terminal;
exports.Range = Range;
exports.Param = Param;
exports.Alt = Alt;
exports.Extend = Extend;
exports.Splice = Splice;
exports.Seq = Seq;
exports.Iter = Iter;
exports.Star = Star;
exports.Plus = Plus;
exports.Opt = Opt;
exports.Not = Not;
exports.Lookahead = Lookahead;
exports.Lex = Lex;
exports.Apply = Apply;
exports.UnicodeChar = UnicodeChar;

// --------------------------------------------------------------------
// Extensions
// --------------------------------------------------------------------

__webpack_require__(/*! ./pexprs-allowsSkippingPrecedingSpace */ "./node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js");
__webpack_require__(/*! ./pexprs-assertAllApplicationsAreValid */ "./node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js");
__webpack_require__(/*! ./pexprs-assertChoicesHaveUniformArity */ "./node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js");
__webpack_require__(/*! ./pexprs-assertIteratedExprsAreNotNullable */ "./node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js");
__webpack_require__(/*! ./pexprs-check */ "./node_modules/ohm-js/src/pexprs-check.js");
__webpack_require__(/*! ./pexprs-eval */ "./node_modules/ohm-js/src/pexprs-eval.js");
__webpack_require__(/*! ./pexprs-getArity */ "./node_modules/ohm-js/src/pexprs-getArity.js");
__webpack_require__(/*! ./pexprs-generateExample */ "./node_modules/ohm-js/src/pexprs-generateExample.js");
__webpack_require__(/*! ./pexprs-outputRecipe */ "./node_modules/ohm-js/src/pexprs-outputRecipe.js");
__webpack_require__(/*! ./pexprs-introduceParams */ "./node_modules/ohm-js/src/pexprs-introduceParams.js");
__webpack_require__(/*! ./pexprs-isNullable */ "./node_modules/ohm-js/src/pexprs-isNullable.js");
__webpack_require__(/*! ./pexprs-substituteParams */ "./node_modules/ohm-js/src/pexprs-substituteParams.js");
__webpack_require__(/*! ./pexprs-toDisplayString */ "./node_modules/ohm-js/src/pexprs-toDisplayString.js");
__webpack_require__(/*! ./pexprs-toArgumentNameList */ "./node_modules/ohm-js/src/pexprs-toArgumentNameList.js");
__webpack_require__(/*! ./pexprs-toFailure */ "./node_modules/ohm-js/src/pexprs-toFailure.js");
__webpack_require__(/*! ./pexprs-toString */ "./node_modules/ohm-js/src/pexprs-toString.js");


/***/ }),

/***/ "./node_modules/ohm-js/src/util.js":
/*!*****************************************!*\
  !*** ./node_modules/ohm-js/src/util.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

const common = __webpack_require__(/*! ./common */ "./node_modules/ohm-js/src/common.js");

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

// Given an array of numbers `arr`, return an array of the numbers as strings,
// right-justified and padded to the same length.
function padNumbersToEqualLength(arr) {
  let maxLen = 0;
  const strings = arr.map(n => {
    const str = n.toString();
    maxLen = Math.max(maxLen, str.length);
    return str;
  });
  return strings.map(s => common.padLeft(s, maxLen));
}

// Produce a new string that would be the result of copying the contents
// of the string `src` onto `dest` at offset `offest`.
function strcpy(dest, src, offset) {
  const origDestLen = dest.length;
  const start = dest.slice(0, offset);
  const end = dest.slice(offset + src.length);
  return (start + src + end).substr(0, origDestLen);
}

// Casts the underlying lineAndCol object to a formatted message string,
// highlighting `ranges`.
function lineAndColumnToMessage(...ranges) {
  const lineAndCol = this;
  const offset = lineAndCol.offset;
  const repeatStr = common.repeatStr;

  const sb = new common.StringBuffer();
  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\n');

  // An array of the previous, current, and next line numbers as strings of equal length.
  const lineNumbers = padNumbersToEqualLength([
    lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
    lineAndCol.lineNum,
    lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
  ]);

  // Helper for appending formatting input lines to the buffer.
  const appendLine = (num, content, prefix) => {
    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\n');
  };

  // Include the previous line for context if possible.
  if (lineAndCol.prevLine != null) {
    appendLine(0, lineAndCol.prevLine, '  ');
  }
  // Line that the error occurred on.
  appendLine(1, lineAndCol.line, '> ');

  // Build up the line that points to the offset and possible indicates one or more ranges.
  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.
  const lineLen = lineAndCol.line.length;
  let indicationLine = repeatStr(' ', lineLen + 1);
  for (let i = 0; i < ranges.length; ++i) {
    let startIdx = ranges[i][0];
    let endIdx = ranges[i][1];
    common.assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');

    const lineStartOffset = offset - lineAndCol.colNum + 1;
    startIdx = Math.max(0, startIdx - lineStartOffset);
    endIdx = Math.min(endIdx - lineStartOffset, lineLen);

    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);
  }
  const gutterWidth = 2 + lineNumbers[1].length + 3;
  sb.append(repeatStr(' ', gutterWidth));
  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);
  sb.append(indicationLine.replace(/ +$/, '') + '\n');

  // Include the next line for context if possible.
  if (lineAndCol.nextLine != null) {
    appendLine(2, lineAndCol.nextLine, '  ');
  }
  return sb.contents();
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

let builtInRulesCallbacks = [];

// Since Grammar.BuiltInRules is bootstrapped, most of Ohm can't directly depend it.
// This function allows modules that do depend on the built-in rules to register a callback
// that will be called later in the initialization process.
exports.awaitBuiltInRules = cb => {
  builtInRulesCallbacks.push(cb);
};

exports.announceBuiltInRules = grammar => {
  builtInRulesCallbacks.forEach(cb => {
    cb(grammar);
  });
  builtInRulesCallbacks = null;
};

// Return an object with the line and column information for the given
// offset in `str`.
exports.getLineAndColumn = (str, offset) => {
  let lineNum = 1;
  let colNum = 1;

  let currOffset = 0;
  let lineStartOffset = 0;

  let nextLine = null;
  let prevLine = null;
  let prevLineStartOffset = -1;

  while (currOffset < offset) {
    const c = str.charAt(currOffset++);
    if (c === '\n') {
      lineNum++;
      colNum = 1;
      prevLineStartOffset = lineStartOffset;
      lineStartOffset = currOffset;
    } else if (c !== '\r') {
      colNum++;
    }
  }

  // Find the end of the target line.
  let lineEndOffset = str.indexOf('\n', lineStartOffset);
  if (lineEndOffset === -1) {
    lineEndOffset = str.length;
  } else {
    // Get the next line.
    const nextLineEndOffset = str.indexOf('\n', lineEndOffset + 1);
    nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset)
                                        : str.slice(lineEndOffset, nextLineEndOffset);
    // Strip leading and trailing EOL char(s).
    nextLine = nextLine.replace(/^\r?\n/, '').replace(/\r$/, '');
  }

  // Get the previous line.
  if (prevLineStartOffset >= 0) {
    prevLine = str.slice(prevLineStartOffset, lineStartOffset)
        .replace(/\r?\n$/, ''); // Strip trailing EOL char(s).
  }

  // Get the target line, stripping a trailing carriage return if necessary.
  const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, '');

  return {
    offset,
    lineNum,
    colNum,
    line,
    prevLine,
    nextLine,
    toString: lineAndColumnToMessage
  };
};

// Return a nicely-formatted string describing the line and column for the
// given offset in `str` highlighting `ranges`.
exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
  return exports.getLineAndColumn(str, offset).toString(...ranges);
};

exports.uniqueId = (() => {
  let idCounter = 0;
  return prefix => '' + prefix + idCounter++;
})();


/***/ }),

/***/ "./node_modules/ohm-js/src/version.js":
/*!********************************************!*\
  !*** ./node_modules/ohm-js/src/version.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global __GLOBAL_OHM_VERSION__ */



// When running under Node, read the version from package.json. For the browser,
// use a special global variable defined in the build process (see webpack.config.js).
module.exports = typeof __GLOBAL_OHM_VERSION__ === 'string'
    ? __GLOBAL_OHM_VERSION__
    : __webpack_require__(/*! ../package.json */ "./node_modules/ohm-js/package.json").version;


/***/ }),

/***/ "./node_modules/ohm-js/third_party/UnicodeCategories.js":
/*!**************************************************************!*\
  !*** ./node_modules/ohm-js/third_party/UnicodeCategories.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Based on https://github.com/mathiasbynens/unicode-9.0.0.
// These are just categories that are used in ES5/ES2015.
// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.
module.exports = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,

  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,

  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,

  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,

  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,

  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};


/***/ }),

/***/ "./node_modules/util-extend/extend.js":
/*!********************************************!*\
  !*** ./node_modules/util-extend/extend.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = extend;
function extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || typeof add !== 'object') return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}


/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./plugins/merriam.js":
/*!****************************!*\
  !*** ./plugins/merriam.js ***!
  \****************************/
/*! exports provided: merriam, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merriam", function() { return merriam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return merriam; });
const merriam = {
    name: "MerriamAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    cache: null,
    cacheNextItem: null,
    currentResponseItemIndex: -1,
    src: null,
    get: async function(prerequisite, arg){
        if(arg){
            if(!this.cache){
                throw Error("No result has been fetched");
            }
            if(arg == "next"){
                let results = this.cache.results;
                this.currentResponseItemIndex += 1;
                if(this.currentResponseItemIndex >= results.length){
                    this.currentResponseItemIndex = 0;
                }
                this.response = this.cache.results[this.currentResponseItemIndex];
                // put the result in the next item cache
                this.cacheNextItem = this.cache.results[this.currentResponseItemIndex];
                return JSON.stringify(this.response, null, '\t');
            }
            // here we assume that the arg is a key in the next item cache
            this.response = this.cacheNextItem[arg];
            return this.response;
        }
        const payload = parsePrerequisite(prerequisite);
        const params = {
            "method": "POST",
            "headers": {
                "content-type": "application/json"
            },
            "body": JSON.stringify(payload)
        };
        let response = await fetch(this.src, params);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            this.cache = json;
            return JSON.stringify(this.response, null, '\t');
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    }
}


let parsePrerequisite = (p) => {
    let pList = p.split(";");
    let payload = {};
    pList.forEach((item) => {
        let key = item.split(":")[0];
        let value = item.replace(`${key}:`, "");
        switch(key){
        case "fields":
            payload["fields"] = value.split(',');
            break;
        case "weights":
            let weights = {};
            value.split(",").forEach((w) => {
                let [w_name, w_value] = w.split(":");
                weights[w_name] = Number(w_value);
            });
            payload["weights"] = weights;
            break;
        case "doc_ids":
            payload["doc_ids"] = value.split(",");
            break;
        case "limit":
            payload["limit"] = Number(value);
            break;
        }
    });
    return payload;
}





/***/ }),

/***/ "./plugins/plugins.js":
/*!****************************!*\
  !*** ./plugins/plugins.js ***!
  \****************************/
/*! exports provided: plugins, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugins", function() { return plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return plugins; });
/* harmony import */ var _testAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./testAPI.js */ "./plugins/testAPI.js");
/* harmony import */ var _merriam_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./merriam.js */ "./plugins/merriam.js");



const plugins = {
    "MerriamAPI": _merriam_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    "TestAPI": _testAPI_js__WEBPACK_IMPORTED_MODULE_0__["default"]
}




/***/ }),

/***/ "./plugins/testAPI.js":
/*!****************************!*\
  !*** ./plugins/testAPI.js ***!
  \****************************/
/*! exports provided: test, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test", function() { return test; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return test; });
const test = {
    name: "TestAPI",
    load: function(url){
        this.src = url;
        return true;
    },
    response: null,
    src: null,
    get: async function(prerequisite, key){
        if(key){
            if(!this.response){
                throw Error("No result has been fetched");
            }
            return this.response[key];
        }
        let src = this.src;
        if(prerequisite){
            src = src + "/" + prerequisite;
        }
        let response = await fetch(src);
        if (response.ok) { // if HTTP-status is 200-299
            // get the response body (the method explained below)
            let json = await response.json();
            this.response = json;
            return JSON.stringify(json);
        } else {
            console.error("HTTP-Error: " + response.status);
            return false;
        };
    },
};




/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9FeGVjdXRpb25TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9BdWRpby5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9DYXJkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvRHJhd2luZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL0ZpZWxkLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9QYXJ0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvcGFydHMvUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wYXJ0cy9TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3BhcnRzL1dvcmxkU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9jbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9lcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9oYW5kSW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3V0aWxzL21lcnJpYW1JbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy91dGlscy9zZXJpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdXRpbHMvc3R5bGVyLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvQXJlYVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9BdWRpb1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Ccm93c2VyVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0J1dHRvblZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9DYXJkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0ZpZWxkVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL0hhbG8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9JbWFnZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9QYXJ0Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1Jlc291cmNlVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1N0YWNrVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL1dpbmRvd1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9Xb3JsZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9jb250ZXh0bWVudS9Db250ZXh0TWVudS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2NvbnRleHRtZW51L0NvbnRleHRNZW51SXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvQ29sb3JQaWNrZXJUb29sLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9Db2xvcldoZWVsV2lkZ2V0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZHJhd2luZy9EcmF3aW5nVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvRXJhc2VyVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2RyYXdpbmcvUGVuY2lsVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yLmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JDdXN0b21MaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JMb2NhdGlvbkluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvck1lc3Nlbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvRWRpdG9yUHJvcEl0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclByb3BMaXN0LmpzIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvdmlld3MvZWRpdG9ycy9FZGl0b3JTdWJwYXJ0c1BhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9lZGl0b3JzL0VkaXRvclRhYi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL2VkaXRvcnMvdXRpbHMvc3VicGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvQ2FyZFJvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL3ZpZXdzL25hdmlnYXRvci9OYXZpZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvU3RhY2tSb3cuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy92aWV3cy9uYXZpZ2F0b3IvV3JhcHBlZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vanMvb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL2Rpc3QvYnVpbHQtaW4tcnVsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9kaXN0L29obS1ncmFtbWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZGlzdC9vcGVyYXRpb25zLWFuZC1hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvZXh0cmFzL1Zpc2l0b3JGYW1pbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9leHRyYXMvc2VtYW50aWNzLXRvQVNULmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0Nhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL0ZhaWx1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9HcmFtbWFyRGVjbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnB1dFN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9JbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9NYXRjaFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL01hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvTmFtZXNwYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1Bvc0luZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvU2VtYW50aWNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL1RyYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9ub2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWNoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1ldmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1nZW5lcmF0ZUV4YW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWdldEFyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy1pbnRyb2R1Y2VQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLWlzTnVsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLW91dHB1dFJlY2lwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtc3Vic3RpdHV0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9Bcmd1bWVudE5hbWVMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3BleHBycy10b0Rpc3BsYXlTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLXRvRmFpbHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3NyYy9wZXhwcnMtdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvcGV4cHJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vaG0tanMvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29obS1qcy9zcmMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2htLWpzL3RoaXJkX3BhcnR5L1VuaWNvZGVDYXRlZ29yaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsLWV4dGVuZC9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIndlYnBhY2s6Ly8vLi9wbHVnaW5zL21lcnJpYW0uanMiLCJ3ZWJwYWNrOi8vLy4vcGx1Z2lucy9wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL3BsdWdpbnMvdGVzdEFQSS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUVBQWM7QUFDL0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELFdBQVc7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxXQUFXOztBQUV4RDtBQUNBOztBQUVB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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVMscUNBQXFDLFVBQVUsT0FBTyxRQUFRO0FBQzlILGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyRUFBYTtBQUNuRCxtRUFBbUU7QUFDbkU7QUFDQSxpQkFBaUI7QUFDakIscUVBQXFFO0FBQ3JFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN4dUJGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7QUFLTTs7QUFFckMsdUJBQXVCLDZDQUFJO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9GQUFrQjtBQUMxQixRQUFRLDBGQUF3QjtBQUNoQyxRQUFRLG1GQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFFBQVE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JJRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QjtBQUNBO0FBR1k7O0FBRXpDLG9CQUFvQixnREFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixVQUFVLG9DQUFvQyxXQUFXO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN0UkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QjtBQUNFO0FBS007O0FBRXJDLHFCQUFxQixnREFBSTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRkFBa0I7QUFDMUIsUUFBUSwwRkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQzs7Ozs7Ozs7Ozs7OztBQzVJRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZCOzs7QUFHN0IseUJBQXlCLGdEQUFJO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsb0NBQW9DLFdBQVc7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JVRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx3REFBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2hKRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWMsY0FBYyxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBLHFGQUFxRixpQkFBaUIsWUFBWTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDbE1GO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdEQUF3RCxjQUFjO0FBQ3RFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQU1FOzs7Ozs7Ozs7Ozs7O0FDcFJGO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN4R0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFNO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1FOzs7Ozs7Ozs7Ozs7O0FDN0NGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNwZUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9FOzs7Ozs7Ozs7Ozs7O0FDOWZGO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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QVkscUNBQXFDO0FBQ2pELFVBQVUsbUNBQW1DO0FBQzdDLFNBQVMsbUNBQW1DO0FBQzVDLFVBQVUscUNBQXFDO0FBQy9DLFdBQVcscUNBQXFDO0FBQ2hELFNBQVMsbUNBQW1DO0FBQzVDLFNBQVMsbUNBQW1DO0FBQzVDLFNBQVMscUNBQXFDO0FBQzlDLFNBQVMscUNBQXFDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDbFZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9EQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRLE1BQU0sWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ2hYRjtBQUFBO0FBQUE7QUFBQTtBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9EQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFELHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDcFRGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RDtBQUNlOztBQUV0RSxnREFBZ0QsbUVBQVc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RCxhQUFhO0FBQ2IsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEUsYUFBYTtBQUNiLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3RIRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixvREFBUTtBQUNqQztBQUNBOztBQUVBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hELDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUMvUkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7O0FBRUEsd0JBQXdCLG9EQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsY0FBYztBQUM5RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3BIRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ21EOztBQUVuRCxxREFBcUQsMkRBQWU7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQyxFQUFFLHlCQUF5QjtBQUN4RiwwQkFBMEIsV0FBVztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwQkFBMEIsRUFBRSxrQkFBa0I7QUFDdEY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3RXRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNsRUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsWUFBWTtBQUNyQyw2QkFBNkIsWUFBWTs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDcGFGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7QUFDRztBQUNBO0FBQ1U7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixxREFBUTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QyxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN6V0Y7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3ZQRjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFLRTs7Ozs7Ozs7Ozs7OztBQ3JQRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7QUFDVTtBQUNFO0FBQ0U7QUFDSTtBQUNaO0FBQzdDOztBQUVBO0FBQ0EsMkNBQTJDLHFEQUFTO0FBQ3BELGtEQUFrRCwwREFBYztBQUNoRSxtREFBbUQsNERBQWdCO0FBQ25FLGlEQUFpRCwyREFBZTtBQUNoRSxnREFBZ0QsOERBQWtCOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSyxNQUFNLEtBQUs7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7O0FBRUEsdUJBQXVCLHVEQUFTO0FBQ2hDLG9DQUFvQyx1REFBUztBQUM3QyxTQUFTO0FBQ1Qsb0NBQW9DLHVEQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHNCQUFzQixlQUFlLGdCQUFnQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzZ0JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLEtBQUs7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUN4RkY7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDelFGO0FBQUE7QUFBQTtBQUFBO0FBQWlEOztBQUVqRDtBQUNBLGlEQUFpRCwwREFBYzs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFOzs7Ozs7Ozs7Ozs7O0FDakpGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ3lEO0FBQ1o7QUFDaUM7O0FBRTlFLHFEQUFxRCw4REFBa0I7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkUsb0JBQW9CO0FBQ2pHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBS0U7Ozs7Ozs7Ozs7Ozs7QUNyTEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMEJB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QTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU0sRUFBRSxPQUFPO0FBQ3JDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUyxJQUFJLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUyxJQUFJLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQSx5Q0FBeUMsbUJBQU8sQ0FBQyxrR0FBbUM7QUFDcEY7QUFDQSxzREFBc0Q7QUFDdEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pRQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVc7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsMkRBQWE7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHFEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMscURBQVU7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGlEQUFRO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXOztBQUVuQyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQyxFQUFFO0FBQzVELHlCQUF5Qix1Q0FBdUM7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0I7QUFDdEIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEVBQTRFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Z0dBQWtDO0FBQ3BFLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTs7QUFFakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLEtBQUs7QUFDTDs7QUFLRSIsImZpbGUiOiJkZXZTeXN0ZW0uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9qcy9vYmplY3RzL1N5c3RlbS5qc1wiKTtcbiIsIi8qKlxuICogRXhlY3V0aW9uU3RhY2tcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhbiBvYmplY3QgdGhhdCBtYW5hZ2VzIGEgc3RhY2sgb2ZcbiAqIEFjdGl2YXRpb25Db250ZXh0IG9iamVjdHMuXG4gKiBJIGFtIGRlc2lnbmVkIHRvIGJlIHVzZWQgYnkgU3lzdGVtIGFzIHRoZVxuICogZ2xvYmFsIGV4ZWN1dGlvbiBzdGFjay5cbiAqXG4gKi9cblxuY2xhc3MgRXhlY3V0aW9uU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX3N0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2dsb2JhbHMgPSB7fTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMucG9wID0gdGhpcy5wb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wdXNoID0gdGhpcy5wdXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0R2xvYmFsID0gdGhpcy5zZXRHbG9iYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRHbG9iYWwgPSB0aGlzLmdldEdsb2JhbC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHBvcCgpe1xuICAgICAgICBpZighdGhpcy5fc3RhY2subGVuZ3RoKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFjay5wb3AoKTtcbiAgICB9XG5cbiAgICBwdXNoKGFuQWN0aXZhdGlvbil7XG4gICAgICAgIHRoaXMuX3N0YWNrLnB1c2goYW5BY3RpdmF0aW9uKTtcbiAgICB9XG5cbiAgICBzZXRHbG9iYWwodmFyTmFtZSwgdmFsdWUpe1xuICAgICAgICB0aGlzLl9nbG9iYWxzW3Zhck5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0R2xvYmFsKHZhck5hbWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2xvYmFsc1t2YXJOYW1lXTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudCgpe1xuICAgICAgICBpZighdGhpcy5fc3RhY2subGVuZ3RoKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBnZXQgcHJldmlvdXMoKXtcbiAgICAgICAgaWYoIXRoaXMuX3N0YWNrLmxlbmd0aCA+PSAyKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAyXTtcbiAgICB9XG59O1xuXG5jbGFzcyBBY3RpdmF0aW9uQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZU5hbWUsIHBhcnQsIGluY29taW5nTWVzc2FnZSwgaGFuZGxlckZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICAgICAgdGhpcy5tZXNzYWdlTmFtZSA9IG1lc3NhZ2VOYW1lO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBpbmNvbWluZ01lc3NhZ2U7XG4gICAgICAgIHRoaXMuaGFuZGxlckZ1bmN0aW9uID0gaGFuZGxlckZ1bmN0aW9uO1xuICAgICAgICB0aGlzLl9sb2NhbHMgPSB7fTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuZ2V0ID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRMb2NhbCA9IHRoaXMuZ2V0TG9jYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRMb2NhbCA9IHRoaXMuc2V0TG9jYWwuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQodmFyTmFtZSl7XG4gICAgICAgIGxldCBsb2NhbFZhbHVlID0gdGhpcy5nZXRMb2NhbCh2YXJOYW1lKTtcbiAgICAgICAgaWYobG9jYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBvdGhlcndpc2UgdHJ5IHRvIHJldHVybiBhIGdsb2JhbFxuICAgICAgICAvLyB2YXJpYWJsZVxuICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5nZXRHbG9iYWwodmFyTmFtZSk7XG4gICAgfVxuXG4gICAgZ2V0TG9jYWwodmFyTmFtZSl7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbHNbdmFyTmFtZV07XG4gICAgfVxuXG4gICAgc2V0TG9jYWwodmFyTmFtZSwgdmFsdWUpe1xuICAgICAgICB0aGlzLl9sb2NhbHNbdmFyTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7XG4gICAgRXhlY3V0aW9uU3RhY2ssXG4gICAgQWN0aXZhdGlvbkNvbnRleHRcbn07XG4iLCIvKipcbiAqIFN5c3RlbSBPYmplY3RcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgXCJ0b3BcIiBvZiB0aGVcbiAqIHN5dGVtLiBJIGFtIHRoZSBwb2ludCBvZiBjb21tdW5pY2F0aW9uIGJldHdlZW5cbiAqIE1vZGVscyBhbmQgVmlld3MuXG4gKi9cbmltcG9ydCBDYXJkIGZyb20gJy4vcGFydHMvQ2FyZC5qcyc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi9wYXJ0cy9TdGFjay5qcyc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vcGFydHMvQnV0dG9uLmpzJztcbmltcG9ydCBGaWVsZCBmcm9tICcuL3BhcnRzL0ZpZWxkLmpzJztcbmltcG9ydCBXb3JsZFN0YWNrIGZyb20gJy4vcGFydHMvV29ybGRTdGFjay5qcyc7XG5pbXBvcnQgV2luZG93IGZyb20gJy4vcGFydHMvV2luZG93LmpzJztcbmltcG9ydCBEcmF3aW5nIGZyb20gJy4vcGFydHMvRHJhd2luZy5qcyc7XG5pbXBvcnQgQXVkaW8gZnJvbSAnLi9wYXJ0cy9BdWRpby5qcyc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuL3BhcnRzL0Jyb3dzZXIuanMnO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vcGFydHMvUmVzb3VyY2UuanMnO1xuaW1wb3J0IEltYWdlIGZyb20gJy4vcGFydHMvSW1hZ2UuanMnO1xuaW1wb3J0IEFyZWEgZnJvbSAnLi9wYXJ0cy9BcmVhLmpzJztcblxuaW1wb3J0IFdvcmxkVmlldyBmcm9tICcuL3ZpZXdzL1dvcmxkVmlldy5qcyc7XG5pbXBvcnQgU3RhY2tWaWV3IGZyb20gJy4vdmlld3MvU3RhY2tWaWV3LmpzJztcbmltcG9ydCBCdXR0b25WaWV3IGZyb20gJy4vdmlld3MvQnV0dG9uVmlldy5qcyc7XG5cbmltcG9ydCBDYXJkVmlldyBmcm9tICcuL3ZpZXdzL0NhcmRWaWV3LmpzJztcbmltcG9ydCBXaW5kb3dWaWV3IGZyb20gJy4vdmlld3MvV2luZG93Vmlldyc7XG5pbXBvcnQgRmllbGRWaWV3IGZyb20gJy4vdmlld3MvRmllbGRWaWV3LmpzJztcbmltcG9ydCBEcmF3aW5nVmlldyBmcm9tICcuL3ZpZXdzL2RyYXdpbmcvRHJhd2luZ1ZpZXcuanMnO1xuaW1wb3J0IEltYWdlVmlldyBmcm9tICcuL3ZpZXdzL0ltYWdlVmlldy5qcyc7XG5pbXBvcnQgQXJlYVZpZXcgZnJvbSAnLi92aWV3cy9BcmVhVmlldy5qcyc7XG5pbXBvcnQgQXVkaW9WaWV3IGZyb20gJy4vdmlld3MvQXVkaW9WaWV3LmpzJztcbmltcG9ydCBCcm93c2VyVmlldyBmcm9tICcuL3ZpZXdzL0Jyb3dzZXJWaWV3LmpzJztcbmltcG9ydCBSZXNvdXJjZVZpZXcgZnJvbSAnLi92aWV3cy9SZXNvdXJjZVZpZXcuanMnO1xuXG5cbmltcG9ydCBIYWxvIGZyb20gJy4vdmlld3MvSGFsby5qcyc7XG5pbXBvcnQgU1ROYXZpZ2F0b3IgZnJvbSAnLi92aWV3cy9uYXZpZ2F0b3IvTmF2aWdhdG9yLmpzJztcbmltcG9ydCBFZGl0b3IgZnJvbSAnLi92aWV3cy9lZGl0b3JzL0VkaXRvci5qcyc7XG5cbmltcG9ydCBvaG0gZnJvbSAnb2htLWpzJztcbmltcG9ydCBpbnRlcnByZXRlclNlbWFudGljcyBmcm9tICcuLi9vaG0vaW50ZXJwcmV0ZXItc2VtYW50aWNzLmpzJztcbmltcG9ydCB7RXhlY3V0aW9uU3RhY2ssIEFjdGl2YXRpb25Db250ZXh0fSBmcm9tICcuL0V4ZWN1dGlvblN0YWNrLmpzJztcblxuaW1wb3J0IGlkTWFrZXIgZnJvbSAnLi91dGlscy9pZC5qcyc7XG5pbXBvcnQgU1RDbGlwYm9hcmQgZnJvbSAnLi91dGlscy9jbGlwYm9hcmQuanMnO1xuXG5pbXBvcnQge0Jhc2ljUHJvcGVydHl9IGZyb20gJy4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmltcG9ydCBoYW5kSW50ZXJmYWNlIGZyb20gJy4vdXRpbHMvaGFuZEludGVyZmFjZS5qcyc7XG5pbXBvcnQgbWVycmlhbVNpbVNjb3JlIGZyb20gJy4vdXRpbHMvbWVycmlhbUludGVyZmFjZS5qcyc7XG5cbmltcG9ydCB7U1REZXNlcmlhbGl6ZXIsIFNUU2VyaWFsaXplcn0gZnJvbSAnLi91dGlscy9zZXJpYWxpemF0aW9uLmpzJztcblxuaW1wb3J0IHBsdWdpbnMgZnJvbSAnLi4vLi4vcGx1Z2lucy9wbHVnaW5zLmpzJztcblxuY29uc3QgRE9NcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXG5pbXBvcnQgY3JlYXRlSGlnaGxpZ2h0ZXIgZnJvbSAnLi91dGlscy9BbHRTeW50YXhIaWdobGlnaHRlci5qcyc7XG5cblxuY29uc3QgU3lzdGVtID0ge1xuICAgIG5hbWU6IFwiU3lzdGVtXCIsXG4gICAgaWQ6IC0xLFxuICAgIGlzTG9hZGVkOiBmYWxzZSxcbiAgICBwYXJ0c0J5SWQ6IHt9LFxuICAgIF9jb21tYW5kSGFuZGxlcnM6IHt9LFxuICAgIF9mdW5jdGlvbkhhbmRsZXJzOiB7fSxcbiAgICBfZGVzZXJpYWxpemVyOiBudWxsLFxuXG4gICAgLy8gQSBkaWN0aW9uYXJ5IG1hcHBpbmcgYXZhaWxhYmxlIFNUIHJlc291cmNlIChzdWNoIGFzIHBsdWdpbikgbmFtZXNcbiAgICBhdmFpbGFibGVSZXNvdXJjZXM6IHt9LFxuXG4gICAgLy8gQSBkaWN0aW9uYXJ5IG1hcHBpbmcgcGFydCB0eXBlcyBsaWtlXG4gICAgLy8gJ2J1dHRvbicgdG8gdGhlaXIgY2xhc3NlcyAoQnV0dG9uKVxuICAgIGF2YWlsYWJsZVBhcnRzOiB7fSxcblxuICAgIC8vIEEgZGljdGlvbmFyeSBtYXBwaW5nIHBhcnQgdHlwZXMgbGlrZVxuICAgIC8vICdidXR0b24nIHRvIHRoZWlyIHZpZXcgY2xhc3NlcyAoQnV0dG9uVmlldylcbiAgICBhdmFpbGFibGVWaWV3czoge30sXG5cbiAgICAvLyBBIHJlZ2lzdHJ5IHRoYXQga2VlcHMgYWxsIHN5c3RlbSBtZXNzYWdlcyBmcm9tXG4gICAgLy8gYmVnaW5uaWduIG9mIHRpbWU7IFRPRE8gaW4gdGhlIGZ1dHVyZSB3ZSBtaWdodCB3YW50XG4gICAgLy8gdG8gbm90ZSBrZWVwIGFsbCB0aGlzIGluIG1lbW9yeVxuICAgIC8vIGVhY2ggbG9nIGNvbnNpc3RzIG9mOlxuICAgIC8vIFthTWVzc2FnZSwgKHNvdXJjZU5hbWUsIHNvdXJjZUlkKSwgKHRhcmdldE5hbWUsIHRhcmdldElkKV1cbiAgICBtZXNzYWdlTG9nOiBbXSxcblxuICAgIC8vIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBwYWdlIGxvYWRzLlxuICAgIC8vIENoZWNrcyBmb3IgYW55IHZpZXcgZWxlbWVudHMgaW4gdGhlXG4gICAgLy8gcGFnZSBhbmQgYXR0ZW1wdHMgdG8gZmluZCBzZXJpYWxpemVkXG4gICAgLy8gbW9kZWwgc3RhdGUgZm9yIGVhY2ggb2YgdGhlbS4gSWYgcHJlc2VudCxcbiAgICAvLyBkZXNlcmlhbGl6ZXMgdGhlIG1vZGVsIGFuZCBhdHRhY2hlcyBpdFxuICAgIC8vIHRvIHRoZSB2aWV3LlxuICAgIGluaXRpYWxMb2FkOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBsb2FkIHRoZSBhdmFpbGFibGUgcmVzb3VyY2VzXG4gICAgICAgIC8vIHRoZXNlIG1pZ2h0IGJlIG5lZWRlZCBkb3duIHRoZSBsaW5lXG4gICAgICAgIHRoaXMubG9hZFJlc291cmNlcygpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBzZXJpYWxpemF0aW9uIHNjcmlwdCB0YWdcbiAgICAgICAgLy8gY29udGFpbmluZyBKU09OIG9mIHNlcmlhbGl6ZWQgaW5mb3JtYXRpb24sXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gbG9hZCBmcm9tIGl0XG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VyaWFsaXphdGlvbicpO1xuICAgICAgICBpZihzZXJpYWxpemF0aW9uRWwgJiYgc2VyaWFsaXphdGlvbkVsLnRleHQgIT0gXCJcIil7XG4gICAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplKClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEluaXRpYWxPcGVuTWVzc2FnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtLm5hdmlnYXRvci5zZXRNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5c3RlbS5wYXJ0c0J5SWRbJ3dvcmxkJ11cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB3ZSByZW5kZXIgdGhlIFdvcmxkIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wcmVoZW5zaXZlIEVkaXRvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5yZW5kZXIodGhpcy53b3JsZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRGcm9tRW1wdHkoKTtcbiBcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHJlbmRlciB0aGUgV29ybGQgaW4gdGhlXG4gICAgICAgICAgICAvLyBDb21wcmVoZW5zaXZlIEVkaXRvclxuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyKHRoaXMud29ybGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0YWNoIGEgbmV3IGNsaXBib2FyZCBpbnN0YW5jZVxuICAgICAgICB0aGlzLmNsaXBib2FyZCA9IG5ldyBTVENsaXBib2FyZCh0aGlzKTtcblxuICAgICAgICAvLyBCeSB0aGlzIHBvaW50IHdlIHNob3VsZCBoYXZlIGEgV29ybGRWaWV3IHdpdGhcbiAgICAgICAgLy8gYSBtb2RlbCBhdHRhY2hlZC5cbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIGxvYWRSZXNvdXJjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW5zKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF2YWlsYWJsZVJlc291cmNlc1trXSA9IHBsdWdpbnNba107XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBsb2FkRnJvbUVtcHR5OiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgd29ybGRNb2RlbCA9IG5ldyB0aGlzLmF2YWlsYWJsZVBhcnRzWyd3b3JsZCddKCk7XG4gICAgICAgIHRoaXMucGFydHNCeUlkW3dvcmxkTW9kZWwuaWRdID0gd29ybGRNb2RlbDtcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICB0aGlzLnRhZ05hbWVGb3JWaWV3TmFtZWQoJ3dvcmxkJylcbiAgICAgICAgKTtcbiAgICAgICAgd29ybGRWaWV3LnNldE1vZGVsKHdvcmxkTW9kZWwpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdvcmxkVmlldyk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgc3RhY2sgbW9kZWxcbiAgICAgICAgbGV0IGluaXRTdGFjayA9IHRoaXMubmV3TW9kZWwoJ3N0YWNrJywgd29ybGRNb2RlbC5pZCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgY2FyZCBtb2RlbCBmb3IgdGhhdCBzdGFja1xuICAgICAgICBsZXQgaW5pdENhcmQgPSB0aGlzLm5ld01vZGVsKCdjYXJkJywgaW5pdFN0YWNrLmlkKTtcblxuICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBzdGFjayBhbmQgY2FyZCBpZHMgXG4gICAgICAgIHdvcmxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHdvcmxkTW9kZWwsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBpbml0U3RhY2suaWRcbiAgICAgICAgKTtcbiAgICAgICAgaW5pdFN0YWNrLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBpbml0U3RhY2ssXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBpbml0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICAvLyBVcGRhdGUgc2VyaWFsaXphdGlvblxuICAgICAgICB0aGlzLnNlcmlhbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMuc2VuZEluaXRpYWxPcGVuTWVzc2FnZXMoKTtcbiAgICAgICAgU3lzdGVtLm5hdmlnYXRvci5zZXRNb2RlbChcbiAgICAgICAgICAgIFN5c3RlbS5wYXJ0c0J5SWRbJ3dvcmxkJ11cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2VuZEluaXRpYWxPcGVuTWVzc2FnZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFNlbmQgdGhlIG9wZW5Xb3JsZCBtZXNzYWdlIHRvIHRoZSBXb3JsZFN0YWNrXG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgICAgICB3b3JsZC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5Xb3JsZCcsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICB9LCB3b3JsZCk7XG4gICAgICAgIHdvcmxkLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIHdvcmxkLmN1cnJlbnRTdGFjayk7XG4gICAgICAgIHdvcmxkLmN1cnJlbnRTdGFjay5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5DYXJkJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIHdvcmxkLmN1cnJlbnRTdGFjay5jdXJyZW50Q2FyZCk7XG4gICAgfSxcblxuICAgIHNlbmRNZXNzYWdlOiBmdW5jdGlvbihhTWVzc2FnZSwgc291cmNlLCB0YXJnZXQpe1xuICAgICAgICBpZighdGFyZ2V0IHx8IHRhcmdldCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlcyBtdXN0IGJlIHNlbnQgd2l0aCB0YXJnZXQgcmVjZWl2ZXJzIHNwZWNpZmllZCEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgYWxsIHNvdXJjZXMgd2hpY2ggcGFzcyB0aGlzIG1lc3NhZ2VcbiAgICAgICAgaWYgKCEoXCJzZW5kZXJzXCIgaW4gYU1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBhTWVzc2FnZVtcInNlbmRlcnNcIl0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhTWVzc2FnZS5zZW5kZXJzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc291cmNlLm5hbWUsXG4gICAgICAgICAgICBpZDogc291cmNlLmlkLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0LnJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKTtcbiAgICB9LFxuXG4gICAgcmVjZWl2ZU1lc3NhZ2U6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAnbmV3Vmlldyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3VmlldyhcbiAgICAgICAgICAgICAgICAgICAgYU1lc3NhZ2Uudmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGFNZXNzYWdlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSAnY29tcGlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZShhTWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlQ29tbWFuZChhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvZXNOb3RVbmRlcnN0YW5kKGFNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkb2VzTm90VW5kZXJzdGFuZDogZnVuY3Rpb24oYU1lc3NhZ2Upe1xuICAgICAgICAvLyBJZiB0aGUgbWVzc2FnZSBoYXMgdGhlIHNob3VsZElnbm9yZSBwcm9wZXJ0eVxuICAgICAgICAvLyBzZXQgdG8gdHJ1ZSwgaXQgbWVhbnMgd2Ugc2hvdWxkIGp1c3Qgc3dhbGxvd1xuICAgICAgICAvLyB0aGlzIG1lc3NhZ2UgaWYgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpdC4gVGhpcyBpc1xuICAgICAgICAvLyB1c2VmdWwgZm9yIG1lc3NhZ2VzIGxpa2UgbW91c2UgZXZlbnRzIG9uIGJ1dHRvbnNcbiAgICAgICAgLy8gd2hpY2ggYXJlIG5vdCBjYXB0dXJlZCBieSBkZWZhdWx0IGFuZCB3b3VsZCBvdGhlcndpc2VcbiAgICAgICAgLy8gZW5kIHVwIGFycml2aW5nIHRvIHRoaXMgU3lzdGVtIG9iamVjdCB2aWEgdGhlXG4gICAgICAgIC8vIG1lc3NhZ2UgZGVsZWdhdGlvbiBjaGFpbi5cbiAgICAgICAgaWYoYU1lc3NhZ2Uuc2hvdWxkSWdub3JlKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JpZ2luYWxTZW5kZXIgPSB0aGlzLnBhcnRzQnlJZFthTWVzc2FnZS5zZW5kZXJzWzBdLmlkXTtcbiAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG5hbWU6IFwiTWVzc2FnZU5vdFVuZGVyc3Rvb2RcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGFNZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIG9yaWdpbmFsU2VuZGVyLnNlbmRNZXNzYWdlKG1zZywgb3JpZ2luYWxTZW5kZXIpO1xuICAgIH0sXG5cbiAgICBjb21waWxlOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIGxldCB0YXJnZXRPYmplY3QgPSB0aGlzLnBhcnRzQnlJZFthTWVzc2FnZS50YXJnZXRJZF07XG4gICAgICAgIGlmKCF0YXJnZXRPYmplY3QgfHwgdGFyZ2V0T2JqZWN0ID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5c3RlbSBjb3VsZCBub3QgY29tcGlsZSB0YXJnZXQgb2JqZWN0ICR7YU1lc3NhZ2UudGFyZ2V0SWR9YCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGluY29taW5nIFNpbXBsZVRhbGsgc2NyaXB0IHN0cmluZy5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGdyYW1tYXRpY2FsIGVycm9ycywgcmVwb3J0IHRoZW0gYW5kIGJhaWwuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IHNlbWFudGljcyBvbiB0aGUgdGFyZ2V0UGFydCwgYWRkXG4gICAgICAgIC8vIHRoZSByZXF1aXJlZCBzZW1hbnRpYyBvcGVyYXRpb25zLCBhbmQgaW50ZXJwcmV0IHRoZSB0b3BcbiAgICAgICAgLy8gbGV2ZWwgb2YgdGhlIHNjcmlwdCwgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIEpTIGhhbmRsZXIgZnVuY3Rpb25zXG4gICAgICAgIGxldCBwYXJzZWRTY3JpcHQgPSBsYW5ndWFnZUdyYW1tYXIubWF0Y2goYU1lc3NhZ2UuY29kZVN0cmluZyk7XG4gICAgICAgIGlmKHBhcnNlZFNjcmlwdC5mYWlsZWQoKSl7XG4gICAgICAgICAgICAvLyBjb25zaWRlciB1c2luZyB0aGUgcGFyc2UgZGF0YSBmcm9tIHRyYWNlXG4gICAgICAgICAgICAvLyBleGFtcGxlOiBsZXQgdHJhY2VkU2NyaXB0ID0gbGFuZ3VhZ2VHcmFtbWFyLnRyYWNlKGFNZXNzYWdlLmNvZGVTdHJpbmcpO1xuICAgICAgICAgICAgLy8gbGV0IHRyZWUgPSB0cmFjZWRTY3JpcHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiR3JhbW1hck1hdGNoRXJyb3JcIixcbiAgICAgICAgICAgICAgICBwYXJzZWRTY3JpcHQ6IHBhcnNlZFNjcmlwdCxcbiAgICAgICAgICAgICAgICBwYXJ0SWQ6IGFNZXNzYWdlLnRhcmdldElkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0LnNlbmRNZXNzYWdlKG1zZywgdGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBjbGVhciBvdXQgYW55IGN1cnJlbnRseSBjb21waWxlZCBoYW5kbGVyc1xuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGluY29taW5nIHNjcmlwdCBtaWdodCBnZXQgcmlkIG9mIHRoZW1cbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5fY29tbWFuZEhhbmRsZXJzID0ge307XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNlbWFudGljcyBvYmplY3Qgd2hvc2UgcGFydENvbnRleHRcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYmUgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAgICB0YXJnZXRPYmplY3QuX3NlbWFudGljcyA9IGxhbmd1YWdlR3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgICAgIHRhcmdldE9iamVjdC5fc2VtYW50aWNzLmFkZE9wZXJhdGlvbihcbiAgICAgICAgICAgICAgICAnaW50ZXJwcmV0JyxcbiAgICAgICAgICAgICAgICBpbnRlcnByZXRlclNlbWFudGljcyh0YXJnZXRPYmplY3QsIHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0Ll9zZW1hbnRpY3MocGFyc2VkU2NyaXB0KS5pbnRlcnByZXQoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gQmUgc3VyZSB0byB0aGVuIHVwZGF0ZSB0aGVcbiAgICAgICAgLy8gc2VyaWFsaXphdGlvbiBmb3IgdGhlIHRhcmdldFxuICAgICAgICAvLyBwYXJ0LCB0aHVzIGFkZGluZyB0aGUgc2NyaXB0IHRvXG4gICAgICAgIC8vIGl0cyBzZXJpYWxpemF0aW9uXG4gICAgICAgIGlmKGFNZXNzYWdlLnNlcmlhbGl6ZSl7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlY2VpdmVDb21tYW5kOiBmdW5jdGlvbihhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fY29tbWFuZEhhbmRsZXJzW2FNZXNzYWdlLmNvbW1hbmROYW1lXTtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgICBsZXQgYm91bmRIYW5kbGVyID0gaGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgbGV0IGFjdGl2YXRpb24gPSBuZXcgQWN0aXZhdGlvbkNvbnRleHQoXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UuY29tbWFuZE5hbWUsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBib3VuZEhhbmRsZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGlvblN0YWNrLnB1c2goYWN0aXZhdGlvbik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYm91bmRIYW5kbGVyKGFNZXNzYWdlLnNlbmRlcnMsIC4uLmFNZXNzYWdlLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2VzTm90VW5kZXJzdGFuZChhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV3TW9kZWw6IGZ1bmN0aW9uKGtpbmQsIG93bmVySWQsIG5hbWUsIGJ1aWxkVmlldz10cnVlKXtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBpbnN0YW5jZSBvZiB0aGUgbW9kZWwgdGhhdFxuICAgICAgICAvLyBtYXRjaGVzIHRoZSBvd25lcidzIGlkXG4gICAgICAgIGxldCBvd25lclBhcnQgPSB0aGlzLnBhcnRzQnlJZFtvd25lcklkXTtcbiAgICAgICAgaWYoIW93bmVyUGFydCB8fCBvd25lclBhcnQgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3lzdGVtIGNvdWxkIG5vdCBsb2NhdGUgb3duZXIgcGFydCB3aXRoIGlkICR7b3duZXJJZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGNsYXNzIGNvbnN0cnVjdG9yIGZvciB0aGUga2luZCBvZlxuICAgICAgICAvLyBwYXJ0IHJlcXVlc3RlZCBhcyBhIG5ldyBtb2RlbC4gSWYgbm90IGtub3duLFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICBsZXQgbW9kZWxDbGFzcyA9IHRoaXMuYXZhaWxhYmxlUGFydHNba2luZF07XG4gICAgICAgIGlmKCFtb2RlbENsYXNzKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSB1bmtub3duIHBhcnQgdHlwZTogJHtraW5kfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb2RlbCA9IG5ldyBtb2RlbENsYXNzKG93bmVyUGFydCk7XG4gICAgICAgIGlmKG5hbWUpe1xuICAgICAgICAgICAgbW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChtb2RlbCwgJ25hbWUnLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRzQnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcblxuICAgICAgICAvLyBBbnkgY3JlYXRlZCBwYXJ0IG1pZ2h0IGluaXRpYWxpemUgaXRzXG4gICAgICAgIC8vIG93biBzdWJwYXJ0cy4gV2UgbmVlZCB0byBsZXQgdGhlIFN5c3RlbSBrbm93XG4gICAgICAgIC8vIGFib3V0IHRob3NlIHRvb1xuICAgICAgICBtb2RlbC5zdWJwYXJ0cy5mb3JFYWNoKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0c0J5SWRbc3VicGFydC5pZF0gPSBzdWJwYXJ0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHZhbGlkIG93bmVyIHBhcnQgZm9yXG4gICAgICAgIC8vIHRoZSBuZXdseSBjcmVhdGVkIHBhcnQgbW9kZWwsXG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IG1vZGVsIHRvIHRoZSBvd25lcidzXG4gICAgICAgIC8vIHN1YnBhcnRzIGxpc3RcbiAgICAgICAgaWYob3duZXJQYXJ0KXtcbiAgICAgICAgICAgIG93bmVyUGFydC5hZGRQYXJ0KG1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgU3lzdGVtIGFzIGEgcHJvcGVydHkgc3Vic2NyaWJlciB0b1xuICAgICAgICAvLyB0aGUgbmV3IG1vZGVsLiBUaGlzIHdpbGwgc2VuZCBhIG1lc3NhZ2UgdG9cbiAgICAgICAgLy8gdGhpcyBTeXN0ZW0gb2JqZWN0IHdoZW5ldmVyIGFueSBvZiB0aGlzIG1vZGVsJ3NcbiAgICAgICAgLy8gcHJvcGVydGllcyBoYXZlIGNoYW5nZWRcbiAgICAgICAgbW9kZWwuYWRkUHJvcGVydHlTdWJzY3JpYmVyKHRoaXMpO1xuXG4gICAgICAgIGlmKGJ1aWxkVmlldyl7XG4gICAgICAgICAgICAvLyBTZWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHZpZXcgZm9yIHRoZSBtb2RlbC5cbiAgICAgICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIGFuZCBhdHRhY2ggaXQuXG4gICAgICAgICAgICBsZXQgdmlld0Zvck1vZGVsID0gdGhpcy5maW5kVmlld0J5SWQobW9kZWwuaWQpO1xuICAgICAgICAgICAgaWYoIXZpZXdGb3JNb2RlbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWaWV3KG1vZGVsLnR5cGUsIG1vZGVsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHkgaWYgdGhlIG93bmVyIHBhcnQgaXMgZWl0aGVyIGEgd29ybGQgb3IgYSBzdGFja1xuICAgICAgICAvLyBhbmQgaGFzIG9ubHkgb25lIHN0YWNrIG9yIGNhcmQgY2hpbGQsIHJlc3BlY3RpdmVseSwgc2V0XG4gICAgICAgIC8vIHRoYXQgY2hpbGQgdG8gYmUgdGhlIGN1cnJlbnRcbiAgICAgICAgaWYob3duZXJQYXJ0LnR5cGUgPT0gXCJ3b3JsZFwiIHx8IG93bmVyUGFydC50eXBlID09IFwic3RhY2tcIil7XG4gICAgICAgICAgICBsZXQgY3VycmVudElkID0gb3duZXJQYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQob3duZXJQYXJ0LCBcImN1cnJlbnRcIik7XG4gICAgICAgICAgICBpZighY3VycmVudElkKXtcbiAgICAgICAgICAgICAgICBvd25lclBhcnQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChvd25lclBhcnQsIFwiY3VycmVudFwiLCBtb2RlbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIG5ld1Byb3BlcnR5KHNlbmRlcnMsIHByb3BOYW1lLCBvYmplY3RJZCl7XG4gICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgIGxldCBvcmlnaW5hbFNlbmRlciA9IHNlbmRlcnNbMF0uaWQ7XG5cbiAgICAgICAgaWYob2JqZWN0SWQpe1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhbiBvYmplY3RJZCwgd2UgYXJlXG4gICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvZiBhIHNwZWNpZmljIHBhcnQgYnlcbiAgICAgICAgICAgIC8vIGlkXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvYmplY3RJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHNldHRpbmcgdGhlIHByb3BlcnR5IG9uIHRoZSBwYXJ0XG4gICAgICAgICAgICAvLyB0aGF0IG9yaWdpbmFsbHkgc2VudCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb3JpZ2luYWxTZW5kZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG5ld1Byb3BlcnR5IHRhcmdldCFgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZSkpe1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnQgJHt0YXJnZXQuaWR9IGFscmVhZHkgaGFzIHByb3BlcnR5IFwiJHtwcm9wTmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG9ubHkgYWRkIGJhc2ljIHByb3BlcnR5IGFuZCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsXG4gICAgICAgIGxldCBjdXN0b21Qcm9wID0gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKFwiY3VzdG9tLXByb3BlcnRpZXNcIik7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IEJhc2ljUHJvcGVydHkocHJvcE5hbWUsIG51bGwpO1xuICAgICAgICBjdXN0b21Qcm9wLmFkZChuZXdQcm9wKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlUHJvcGVydHkoc2VuZGVycywgcHJvcE5hbWUsIG9iamVjdElkKXtcbiAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gc2VuZGVyc1swXS5pZDtcblxuICAgICAgICBpZihvYmplY3RJZCl7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIGFuIG9iamVjdElkLCB3ZSBhcmVcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHByb3BlcnR5IG9mIGEgc3BlY2lmaWMgcGFydCBieVxuICAgICAgICAgICAgLy8gaWRcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29iamVjdElkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBhcmUgc2V0dGluZyB0aGUgcHJvcGVydHkgb24gdGhlIHBhcnRcbiAgICAgICAgICAgIC8vIHRoYXQgb3JpZ2luYWxseSBzZW50IHRoZSBtZXNzYWdlXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFtvcmlnaW5hbFNlbmRlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgZGVsZXRlUHJvcGVydHkgdGFyZ2V0IWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsIG9ubHkgZGVsZXRlIGN1c3RvbSBwcm9wZXJ0aWVzIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxuICAgICAgICBsZXQgcHJvcCA9IHRhcmdldC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZSk7XG5cbiAgICAgICAgbGV0IGN1c3RvbVByb3AgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoXCJjdXN0b20tcHJvcGVydGllc1wiKTtcbiAgICAgICAgY3VzdG9tUHJvcC5kZWxldGUocHJvcCk7XG4gICAgfSxcblxuICAgIHNldFByb3BlcnR5KHNlbmRlcnMsIHByb3BOYW1lLCB2YWx1ZSwgb2JqZWN0SWQpe1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBsZXQgb3JpZ2luYWxTZW5kZXIgPSBzZW5kZXJzWzBdLmlkO1xuXG4gICAgICAgIGlmKG9iamVjdElkKXtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgYW4gb2JqZWN0SWQsIHdlIGFyZVxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgcHJvcGVydHkgb2YgYSBzcGVjaWZpYyBwYXJ0IGJ5XG4gICAgICAgICAgICAvLyBpZFxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wYXJ0c0J5SWRbb2JqZWN0SWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvbiB0aGUgcGFydFxuICAgICAgICAgICAgLy8gdGhhdCBvcmlnaW5hbGx5IHNlbnQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMucGFydHNCeUlkW29yaWdpbmFsU2VuZGVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBzZXRQcm9wZXJ0eSB0YXJnZXQhYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IHBhcnQgaXMgYSBTdGFjaywgd2UgYWxzb1xuICAgICAgICAvLyBzZXQgdGhpcyBwcm9wZXJ0eSBvbiBhbGwgb2YgaXRzIENhcmRcbiAgICAgICAgLy8gc3VicGFydHNcbiAgICAgICAgaWYodGFyZ2V0LnR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICB0YXJnZXQuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICAgICAgfSkuZm9yRWFjaChjYXJkID0+IHtcbiAgICAgICAgICAgICAgICBjYXJkLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgIGNhcmQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGhlIG1vZGVsIHdpdGggdGhlIGdpdmVuIElEIGZyb21cbiAgICAvLyB0aGUgU3lzdGVtJ3MgcmVnaXN0cnksIGFzIHdlbGwgYXMgZnJvbSB0aGUgc3VicGFydHNcbiAgICAvLyBhcnJheSBvZiBhbnkgb3duZXJzXG4gICAgZGVsZXRlTW9kZWw6IGZ1bmN0aW9uKG1vZGVsSWQpe1xuICAgICAgICBsZXQgZm91bmRNb2RlbCA9IHRoaXMucGFydHNCeUlkW21vZGVsSWRdO1xuICAgICAgICBpZighZm91bmRNb2RlbCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiByZW1vdmluZyBhIGNhcmQgb3IgYSBzdGFjayBiZSBzdXJlIGl0IGlzIG5vdCB0aGUgb25seSBvbmVcbiAgICAgICAgLy8gYW5kIGlmIGl0IGlzIHRoZSBjdXJyZW50IGNhcmQgb3Igc3RhY2sgd2Ugc2hvdWxkIGdvIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAvLyBiZWZvcmUgcmVtb3ZpbmcgaXRcbiAgICAgICAgaWYoZm91bmRNb2RlbC50eXBlID09IFwiY2FyZFwiIHx8IGZvdW5kTW9kZWwudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IHNhbWVUeXBlU3VicGFydHMgPSBmb3VuZE1vZGVsLl9vd25lci5zdWJwYXJ0cy5maWx0ZXIoKHApID0+IHtyZXR1cm4gcC50eXBlID09IGZvdW5kTW9kZWwudHlwZTt9KTtcbiAgICAgICAgICAgIGlmKHNhbWVUeXBlU3VicGFydHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgYSBTVCBlcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSB0aGUgb25seSAke2ZvdW5kTW9kZWwudHlwZX1gKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihtb2RlbElkID09IHRoaXMuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKS5pZCAgfHwgbW9kZWxJZCA9PSB0aGlzLmdldEN1cnJlbnRDYXJkTW9kZWwoKS5pZCl7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHRoZSBjdXJyZW50ICR7Zm91bmRNb2RlbC50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIHN0b3AgYWxsIHN0ZXBwaW5nXG4gICAgICAgIC8vIG9uIHRoZSBQYXJ0LCBvdGhlcndpc2Ugc3RlcHBpbmdcbiAgICAgICAgLy8gaW50ZXJ2YWxzIHdpbGwgZXJyb3IgaW5maW5pdGVseVxuICAgICAgICBmb3VuZE1vZGVsLnN0b3BTdGVwcGluZygpO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZWRpdG9yIGlzIGNsb3NlZFxuICAgICAgICBmb3VuZE1vZGVsLmNsb3NlRWRpdG9yQ21kSGFuZGxlcigpO1xuXG4gICAgICAgIGxldCBvd25lck1vZGVsID0gZm91bmRNb2RlbC5fb3duZXI7XG4gICAgICAgIGlmKG93bmVyTW9kZWwpe1xuICAgICAgICAgICAgb3duZXJNb2RlbC5yZW1vdmVQYXJ0KGZvdW5kTW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMucGFydHNCeUlkW21vZGVsSWRdO1xuICAgICAgICB0aGlzLnJlbW92ZVZpZXdzKG1vZGVsSWQpO1xuXG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgc3RhdGVcbiAgICAgICAgdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhbGwgdmlld3Mgd2l0aCB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIG1vZGVsIGlkIGZyb20gdGhlIERPTVxuICAgIHJlbW92ZVZpZXdzOiBmdW5jdGlvbihtb2RlbElkKXtcbiAgICAgICAgbGV0IHZpZXdzID0gQXJyYXkuZnJvbSh0aGlzLmZpbmRWaWV3c0J5SWQobW9kZWxJZCkpO1xuICAgICAgICB2aWV3cy5mb3JFYWNoKHZpZXcgPT4ge1xuICAgICAgICAgICAgbGV0IHBhcmVudEVsID0gdmlldy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgdmlldy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHZpZXcpO1xuICAgICAgICAgICAgLy8gRGlzcGF0Y2ggYSBDdXN0b21FdmVudCBvbiB0aGUgcGFyZW50RWxlbWVudFxuICAgICAgICAgICAgLy8gaW5kaWNhdGluZyB0aGF0IHRoaXMgcGFydCBoYXMgYmVlbiByZW1vdmVkLCBhbmRcbiAgICAgICAgICAgIC8vIGFueSB2aWV3IHV0aWxpdGllcyB0aGF0IGNhcmUgY2FuIGJlIG5vdGlmaWVkLlxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzdC12aWV3LXJlbW92ZWQnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRUeXBlOiB2aWV3Lm1vZGVsLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRJZDogbW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXJJZDogbnVsbFxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmVudEVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxlbnNlcyA9IHRoaXMuZmluZExlbnNWaWV3c0J5SWQobW9kZWxJZCk7XG4gICAgICAgIGxlbnNlcy5mb3JFYWNoKGxlbnNWaWV3ID0+IHtcbiAgICAgICAgICAgIGxlbnNWaWV3LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQobGVuc1ZpZXcpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbmV3VmlldzogZnVuY3Rpb24ocGFydE5hbWUsIG1vZGVsSWQsIHBhcmVudElkKXtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5wYXJ0c0J5SWRbbW9kZWxJZF07XG4gICAgICAgIGlmKCFtb2RlbCB8fCBtb2RlbCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTeXN0ZW0gZG9lcyBub3Qga25vdyBwYXJ0ICR7cGFydE5hbWV9WyR7bW9kZWxJZH1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXBhcnROYW1lKXtcbiAgICAgICAgICAgIHBhcnROYW1lID0gbW9kZWwudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcmVudCBtb2RlbCBpZC4gVGhpcyB3aWxsXG4gICAgICAgIC8vIGhlbHAgdXMgZmluZCB0aGUgcGFyZW50IHZpZXcgZWxlbWVudCBmb3JcbiAgICAgICAgLy8gYXBwZW5kaW5nIHRoZSBuZXcgZWxlbWVudC5cbiAgICAgICAgaWYgKCFwYXJlbnRJZCl7XG4gICAgICAgICAgICBwYXJlbnRJZCA9IG1vZGVsLl9vd25lci5pZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50RWxlbWVudCA9IHRoaXMuZmluZFZpZXdCeUlkKHBhcmVudElkKTtcbiAgICAgICAgaWYoIXBhcmVudEVsZW1lbnQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXJlbnQgZWxlbWVudCBmb3IgJHtwYXJ0TmFtZX1bJHttb2RlbElkfV0gKG1vZGVsIG93bmVyIGlkOiAke21vZGVsLl9vd25lci5pZH0pYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyB2aWV3IGluc3RhbmNlLFxuICAgICAgICAvLyBhcHBlbmQgdG8gcGFyZW50LCBhbmQgc2V0IHRoZSBtb2RlbFxuICAgICAgICBsZXQgbmV3VmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICB0aGlzLnRhZ05hbWVGb3JWaWV3TmFtZWQocGFydE5hbWUpXG4gICAgICAgICk7XG4gICAgICAgIG5ld1ZpZXcuc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwidmlld0NoYW5nZWRcIixcbiAgICAgICAgICAgIGNoYW5nZU5hbWU6IFwic3VicGFydC1uZXdcIixcbiAgICAgICAgICAgIGFyZ3M6IFtuZXdWaWV3XVxuICAgICAgICB9LCBtb2RlbC5fb3duZXIsIHBhcmVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIERpc3BhdGNoIGEgQ3VzdG9tRXZlbnQgb24gdGhlIHBhcmVudEVsZW1lbnRcbiAgICAgICAgLy8gaW5kaWNhdGluZyB0aGF0IHRoaXMgcGFydCBoYXMgYmVlbiBjcmVhdGVkLCBhbmRcbiAgICAgICAgLy8gYW55IHZpZXcgdXRpbGl0aWVzIHRoYXQgY2FyZSBjYW4gYmUgbm90aWZpZWQuXG4gICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc3Qtdmlldy1hZGRlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHBhcnRUeXBlOiBtb2RlbC50eXBlLFxuICAgICAgICAgICAgICAgIHBhcnRJZDogbW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgb3duZXJJZDogbW9kZWwuX293bmVyLmlkIHx8IG51bGxcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgIC8vIFNlZSBpZiB0aGVyZSBhcmUgbGVucyB2aWV3cyBhbmQgdXBkYXRlXG4gICAgICAgIC8vIHRob3NlIGFzIHdlbGxcbiAgICAgICAgbGV0IGxlbnNWaWV3cyA9IHRoaXMuZmluZExlbnNWaWV3c0J5SWQocGFyZW50SWQpO1xuICAgICAgICBsZW5zVmlld3MuZm9yRWFjaChsZW5zVmlldyA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3TGVuc1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZUZvclZpZXdOYW1lZChwYXJ0TmFtZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRNb2RlbChtb2RlbCk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldEF0dHJpYnV0ZSgnbGVucy1wYXJ0LWlkJywgbW9kZWxJZCk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbGVucycpO1xuICAgICAgICAgICAgbGVuc1ZpZXcuYXBwZW5kQ2hpbGQobmV3TGVuc1ZpZXcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUT0RPIGRvIHdlIHdhbnQgdG8gYWxsb3cgdGhlIHBvc3NpYmlsaXkgb2YgYSB2aWV3IG9uIGFuXG4gICAgICAgIC8vIGVsZW1lbnQgYnV0IG5vIHN1YnBhcnQgb2YgdGhhdCB2aWV3IG9uIHRoZSBlbGVtZW50P1xuXG4gICAgICAgIC8vIEZvciBhbGwgc3VicGFydHMgb2YgdGhpcyBtb2RlbCwgY2FsbFxuICAgICAgICAvLyB0aGUgbmV3VmlldyBtZXRob2QgcmVjdXJzaXZlbHlcbiAgICAgICAgbW9kZWwuc3VicGFydHMuZm9yRWFjaChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV3VmlldyhzdWJwYXJ0LnR5cGUsIHN1YnBhcnQuaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3VmlldztcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJQYXJ0OiBmdW5jdGlvbihuYW1lLCBjbHMpe1xuICAgICAgICB0aGlzLmF2YWlsYWJsZVBhcnRzW25hbWVdID0gY2xzO1xuICAgIH0sXG5cbiAgICByZWdpc3RlclZpZXc6IGZ1bmN0aW9uKG5hbWUsIGNscyl7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlVmlld3NbbmFtZV0gPSBjbHM7XG4gICAgfSxcblxuICAgIHRhZ05hbWVGb3JWaWV3TmFtZWQ6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgICByZXR1cm4gYHN0LSR7bmFtZX1gO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyB2aWV3IGVsZW1lbnRcbiAgICAvLyB3aXRoIHRoZSBnaXZlbiBpZFxuICAgIGZpbmRWaWV3QnlJZDogZnVuY3Rpb24oaWQpe1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke2lkfVwiXWApO1xuICAgIH0sXG5cbiAgICBmaW5kTGVuc1ZpZXdzQnlJZDogZnVuY3Rpb24oaWQpe1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbbGVucy1wYXJ0LWlkPVwiJHtpZH1cIl1gKSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIG1hdGNoaW5nIHZpZXcgZWxlbWVudHMgd2l0aFxuICAgIC8vIHRoZSBnaXZlbiBwYXJ0IGlkXG4gICAgZmluZFZpZXdzQnlJZDogZnVuY3Rpb24oaWQpe1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW3BhcnQtaWQ9XCIke2lkfVwiXWApO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdGhlIG1vZGVsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhY2tcbiAgICBnZXRDdXJyZW50U3RhY2tNb2RlbDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5nZXRXb3JsZFN0YWNrTW9kZWwoKTtcbiAgICAgICAgcmV0dXJuIHdvcmxkLmN1cnJlbnRTdGFjaztcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRoZSBtb2RlbCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IGNhcmRcbiAgICBnZXRDdXJyZW50Q2FyZE1vZGVsOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5nZXRDdXJyZW50U3RhY2tNb2RlbCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFN0YWNrLmN1cnJlbnRDYXJkO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdGhlIG1vZGVsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHdvcmxkIHN0YWNrXG4gICAgZ2V0V29ybGRTdGFja01vZGVsOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgbW9kZWwgY29ycmVzcG9uZGluZyBzY3JpcHQgZWRpdG9yIHN0LWZpZWxkXG4gICAgLy8gTm90ZTogd2UgdXNlIHRoZSB3aW5kb3cubW9kZWwudGFyZ2V0IHRvIGxvY2F0ZSB0aGUgY29ycmVzcG9uZGluZyB3aW5kb3dcbiAgICAvLyBidXQgcmV0dXJuIGl0cyBzdC1maWVsZCBzdWJwYXJ0XG4gICAgZmluZFNjcmlwdEVkaXRvckJ5VGFyZ2V0SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgbGV0IHNjcmlwdEVkaXRvckZpZWxkO1xuICAgICAgICBsZXQgd2luZG93cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdC13aW5kb3dcIik7XG4gICAgICAgIHdpbmRvd3MuZm9yRWFjaCgodykgPT4ge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHcubW9kZWwudGFyZ2V0O1xuICAgICAgICAgICAgaWYodGFyZ2V0ICYmIHRhcmdldC5pZCA9PT0gaWQpe1xuICAgICAgICAgICAgICAgIHNjcmlwdEVkaXRvckZpZWxkID0gdy5xdWVyeVNlbGVjdG9yKFwic3QtZmllbGRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2NyaXB0RWRpdG9yRmllbGQ7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgICAgIGlmKCF3b3JsZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHdvcmxkIGZvdW5kIWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXJpYWxpemVyID0gbmV3IFNUU2VyaWFsaXplcih0aGlzKTtcbiAgICAgICAgbGV0IHNlcmlhbFN0cmluZyA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMucGFydHNCeUlkWyd3b3JsZCddLCB0cnVlKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3QgYSBzY3JpcHQgdGFnIGluIHRoZVxuICAgICAgICAvLyBib2R5IGZvciB0aGUgc2VyaWFsaXphdGlvbiwgY3JlYXRlIGl0XG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uU2NyaXB0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VyaWFsaXphdGlvbicpO1xuICAgICAgICBpZighc2VyaWFsaXphdGlvblNjcmlwdEVsKXtcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25TY3JpcHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2VyaWFsaXphdGlvblNjcmlwdEVsLmlkID0gJ3NlcmlhbGl6YXRpb24nO1xuICAgICAgICAgICAgc2VyaWFsaXphdGlvblNjcmlwdEVsLnR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChzZXJpYWxpemF0aW9uU2NyaXB0RWwpO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6YXRpb25TY3JpcHRFbC50ZXh0Q29udGVudCA9IHNlcmlhbFN0cmluZztcbiAgICB9LFxuXG4gICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VyaWFsaXphdGlvbicpO1xuICAgICAgICBpZighc2VyaWFsaXphdGlvbkVsKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc2VyaWFsaXphdGlvbiBmb3VuZCBmb3IgdGhpcyBwYWdlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVzZXJpYWxpemVyID0gbmV3IFNURGVzZXJpYWxpemVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb25FbC50ZXh0Q29udGVudCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhICpjb21wbGV0ZSogSFRNTFxuICAgIC8vIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uXG4gICAgLy8gdGhhdCBjYW4gbGF0ZXIgYmUgc2F2ZWQgdG8gYSBmaWxlXG4gICAgZ2V0RnVsbEhUTUxTdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBjbG9uZWREb2N1bWVudCA9IGRvY3VtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgbGV0IHdvcmxkID0gY2xvbmVkRG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3Qtd29ybGQnKTtcbiAgICAgICAgbGV0IG5hdiA9IGNsb25lZERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LW5hdmlnYXRvcicpO1xuICAgICAgICBpZih3b3JsZCl7XG4gICAgICAgICAgICB3b3JsZC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihuYXYpe1xuICAgICAgICAgICAgbmF2LnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lZERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgfSxcblxuXG4gICAgLyoqIE5hdmlnYXRpb24gb2YgQ3VycmVudCBXb3JsZCAqKi9cbiAgICBnb1RvTmV4dFN0YWNrOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICAgICAgcmV0dXJuIHdvcmxkLmdvVG9OZXh0U3RhY2soKTtcbiAgICB9LFxuXG4gICAgZ29Ub1ByZXZTdGFjazogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5wYXJ0c0J5SWRbJ3dvcmxkJ107XG4gICAgICAgIHJldHVybiB3b3JsZC5nb1RvUHJldlN0YWNrKCk7XG4gICAgfSxcblxuICAgIGdvVG9TdGFja0J5SWQ6IGZ1bmN0aW9uKHN0YWNrSWQpe1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLnBhcnRzQnlJZFsnd29ybGQnXTtcbiAgICAgICAgcmV0dXJuIHdvcmxkLmdvVG9TdGFja0J5SWQoc3RhY2tJZCk7XG4gICAgfSxcblxuICAgIC8qKiBOYXZpZ2F0aW9uIG9mIEN1cnJlbnQgU3RhY2sgKiovXG4gICAgZ29Ub05leHRDYXJkOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5nZXRDdXJyZW50U3RhY2tNb2RlbCgpOyBcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGFjay5nb1RvTmV4dENhcmQoKTtcbiAgICB9LFxuXG4gICAgZ29Ub1ByZXZDYXJkOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gdGhpcy5nZXRDdXJyZW50U3RhY2tNb2RlbCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFN0YWNrLmdvVG9QcmV2Q2FyZCgpO1xuICAgIH0sXG5cbiAgICBnb1RvQ2FyZEJ5SWQ6IGZ1bmN0aW9uKGNhcmRJZCl7XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmdldEN1cnJlbnRTdGFja01vZGVsKCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50U3RhY2suZ29Ub0NhcmRCeUlkKGNhcmRJZCk7XG4gICAgfSxcblxuICAgIG9wZW5FZGl0b3JGb3JQYXJ0OiBmdW5jdGlvbihwYXJ0SWQpe1xuICAgICAgICB0aGlzLmVkaXRvci5yZW5kZXIoXG4gICAgICAgICAgICB0aGlzLnBhcnRzQnlJZFtwYXJ0SWRdXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9wZW4oKTtcbiAgICB9LFxuXG4gICAgY2xvc2VFZGl0b3JGb3JQYXJ0OiBmdW5jdGlvbihwYXJ0SWQpe1xuICAgICAgICB0aGlzLmVkaXRvci5jbG9zZSgpO1xuICAgIH1cbn07XG5cbi8qKiBBZGQgRGVmYXVsdCBTeXN0ZW0gQ29tbWFuZCBIYW5kbGVycyAqKi9cbi8vU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2RlbGV0ZU1vZGVsJ10gPSBTeXN0ZW0uZGVsZXRlTW9kZWw7XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZGVsZXRlTW9kZWwnXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIC4uLnJlc3Qpe1xuICAgIFN5c3RlbS5kZWxldGVNb2RlbCguLi5yZXN0KTtcbn07XG4vL1N5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyduZXdNb2RlbCddID0gU3lzdGVtLm5ld01vZGVsO1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ25ld01vZGVsJ10gPSBmdW5jdGlvbihzZW5kZXJzLCAuLi5yZXN0KXtcbiAgICBTeXN0ZW0ubmV3TW9kZWwoLi4ucmVzdCk7XG4gICAgdGhpcy5zZXJpYWxpemUoKTtcbn07XG4vL1N5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyduZXdWaWV3J10gPSBTeXN0ZW0ubmV3VmlldztcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyduZXdWaWV3J10gPSBmdW5jdGlvbihzZW5kZXJzLCAuLi5yZXN0KXtcbiAgICBTeXN0ZW0ubmV3VmlldyguLi5yZXN0KTtcbn07XG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbmV3UHJvcGVydHknXSA9IFN5c3RlbS5uZXdQcm9wZXJ0eTtcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydzZXRQcm9wZXJ0eSddID0gU3lzdGVtLnNldFByb3BlcnR5O1xuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ2RlbGV0ZVByb3BlcnR5J10gPSBTeXN0ZW0uZGVsZXRlUHJvcGVydHk7XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydhc2snXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHF1ZXN0aW9uKXtcbiAgICAvLyBVc2UgdGhlIG5hdGl2ZSBKUyBwcm9tcHQgZnVuY3Rpb24gdG8gYXNrIHRoZSBxdWVzdGlvblxuICAgIC8vIGFuZCByZXR1cm4gaXRzIHZhbHVlLlxuICAgIC8vIEJ5IHJldHVybmluZyBoZXJlLCB3ZSBleHBlY3QgdGhlIGltcGxpY2l0IHZhcmlhYmxlXG4gICAgLy8gXCJpdFwiIHRvIGJlIHNldCBpbnNpZGUgYW55IGNhbGxpbmcgc2NyaXB0XG4gICAgcmV0dXJuIHByb21wdChxdWVzdGlvbik7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1sncHV0SW50byddID0gZnVuY3Rpb24oc2VuZGVycywgdmFsdWUsIHZhcmlhYmxlTmFtZSwgZ2xvYmFsKXtcbiAgICBpZihnbG9iYWwpe1xuICAgICAgICBTeXN0ZW0uZXhlY3V0aW9uU3RhY2suc2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEJlY2F1c2Ugd2UgcHVzaCBhbGwgaGFuZGxlcnMgb250byB0aGUgZXhlY3V0aW9uIHN0YWNrLFxuICAgIC8vIHRoZSBwdXRJbnRvIGhhbmRsZXIgaXMgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICAgIC8vIEluIG9yZGVyIHRvIG1vZGlmeSB0aGUgY2FsbGVyJ3MgdmFyaWFibGVzLCB3ZSBuZWVkIHRvXG4gICAgLy8gZmluZCB0aGUgY29udGV4dCB0aGF0IGlzIG9uZSBwcmV2aW91cyBvbiB0aGUgc3RhY2tcbiAgICBpZihTeXN0ZW0uZXhlY3V0aW9uU3RhY2sucHJldmlvdXMpe1xuICAgICAgICBTeXN0ZW0uZXhlY3V0aW9uU3RhY2sucHJldmlvdXMuc2V0TG9jYWwodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeGVjdXRpb25TdGFjayBFcnJvcjogI3B1dEludG8gb24gdG9wIG9mIGVtcHR5IHN0YWNrIWApO1xuICAgIH1cbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydhbnN3ZXInXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHZhbHVlKXtcbiAgICBhbGVydCh2YWx1ZS50b1N0cmluZygpKTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydnbyB0byBkaXJlY3Rpb24nXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIGRpcmVjdGl2ZSwgb2JqZWN0TmFtZSl7XG4gICAgc3dpdGNoKG9iamVjdE5hbWUpIHtcbiAgICAgICAgY2FzZSAnY2FyZCc6XG4gICAgICAgICAgICBzd2l0Y2goZGlyZWN0aXZlKXtcbiAgICAgICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvTmV4dENhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub1ByZXZDYXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3RhY2snOlxuICAgICAgICAgICAgc3dpdGNoKGRpcmVjdGl2ZSl7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub05leHRTdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXZpb3VzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvUHJldlN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFsZXJ0KGBcImdvIHRvXCIgbm90IGltcGxlbWVudGVkIGZvciAke29iamVjdE5hbWV9YCk7XG5cbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZ28gdG8nXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIGlkKXtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLnBhcnRzQnlJZFtpZF07XG4gICAgaWYoIW1vZGVsKXtcbiAgICAgICAgYWxlcnQoYFwiZ28gdG9cIiB0YXJnZXQgbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHN3aXRjaChtb2RlbC50eXBlKSB7XG4gICAgY2FzZSAnY2FyZCc6XG4gICAgICAgIHRoaXMuZ29Ub0NhcmRCeUlkKGlkKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzdGFjayc6XG4gICAgICAgIHRoaXMuZ29Ub1N0YWNrQnlJZChpZCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgICAgYWxlcnQoYFwiZ28gdG9cIiBub3QgaW1wbGVtZW50ZWQgZm9yICR7bW9kZWwudHlwZX1gKTtcblxuICAgIH1cbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydnbyB0byB3ZWJzaXRlJ10gPSBmdW5jdGlvbihzZW5kZXJzLCB1cmwpe1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xufTtcblxuLy9JbXBvcnQgYSB3b3JsZCwgaS5lLiBpdHMgc3RhY2tzIGZyb20gYW5vdGhlciBzb3VyY2VcblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydpbXBvcnRXb3JsZCddID0gZnVuY3Rpb24oc2VuZGVyLCBzb3VyY2VVcmwpe1xuICAgIGlmKCFzb3VyY2VVcmwpe1xuICAgICAgICBzb3VyY2VVcmwgPSB3aW5kb3cucHJvbXB0KFwiQ2hvb3NlIFdvcmxkIGxvY2F0aW9uXCIpO1xuICAgIH1cbiAgICBmZXRjaChzb3VyY2VVcmwpXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgIGlmKCFjb250ZW50VHlwZS5zdGFydHNXaXRoKCd0ZXh0L2h0bWwnKSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbnRlbnQgdHlwZTogJHtjb250ZW50VHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCkudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkRG9jdW1lbnQgPSBET01wYXJzZXIucGFyc2VGcm9tU3RyaW5nKHJlYWRlci5yZXN1bHQsIFwidGV4dC9odG1sXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyAuZ2V0RWxlbWVudEJ5SWQoKSBmb3IgYSBub2RlIEhUTUwgcGFyc2VkIGRvY3VtZW50IVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbkVsID0gcGFyc2VkRG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIXNlcmlhbGl6YXRpb25FbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gc2VyaWFsaXphdGlvbiBmb3VuZCBmb3IgJHtzb3VyY2VVcmx9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChgV29ybGQgXCIke3NvdXJjZVVybH1cIiBub3QgZm91bmRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZXIgPSBuZXcgU1REZXNlcmlhbGl6ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2VyaWFsaXplci50YXJnZXRJZCA9ICd3b3JsZCc7IC8vIFdlIHdpbGwgaW5zZXJ0IHRoZSBzdGFja3MgaW50byB0aGUgd29ybGRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplci5pbXBvcnRGcm9tU2VyaWFsaXphdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25FbC50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIG9ubHkgU3RhY2tzIHRoYXQgYXJlIGRpcmVjdCBzdWJwYXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB3b3JsZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNTdGFjayA9IHBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1dvcmxkU3VicGFydCA9IHBhcnQuX293bmVyICYmIHBhcnQuX293bmVyLnR5cGUgPT0gJ3dvcmxkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTdGFjayAmJiBpc1dvcmxkU3VicGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgX3NyYy5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGluZmluaXRlbHlcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGxvYWQgb3BlcmF0aW9uXG4gICAgICAgICAgICB0aGlzLl9zcmMgPSBzb3VyY2VVcmw7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy8gU3RvcCBhbmQgcmVzdGFydCBoYW5kIGludGVyZmFjZSBpZiBpdCdzIHJ1bm5pbmcuXG4gICAgICAgICAgICBpZiAoaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uUnVubmluZykge1xuICAgICAgICAgICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgYWxlcnQoXCJDb3VsZCBub3QgbG9hZCB3b3JsZFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snb3BlblNjcmlwdEVkaXRvciddID0gZnVuY3Rpb24oc2VuZGVycywgdGFyZ2V0SWQpe1xuICAgIGxldCB0YXJnZXQgPSB0aGlzLnBhcnRzQnlJZFt0YXJnZXRJZF07XG4gICAgbGV0IHRhcmdldE5hbWUgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwibmFtZVwiKTtcbiAgICBpZih0YXJnZXROYW1lKXtcbiAgICAgICAgdGFyZ2V0TmFtZSA9IGBcIiR7dGFyZ2V0TmFtZX1cImA7XG4gICAgfVxuICAgIGxldCBuYW1lID0gYFNjcmlwdCBGb3IgJHt0YXJnZXQubmFtZX0gJHt0YXJnZXROYW1lfWA7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgZGlud28gb3BlbmVkIHdpdGggdGhpcyBuYW1lLCB0aGVuXG4gICAgLy8gd2UgcmV0dXJuIHdpdGhvdXQgY3JlYXRpbmcgYW55dGhpbmcgbmV3LlxuICAgIGxldCBmb3VuZCA9IE9iamVjdC52YWx1ZXMoU3lzdGVtLnBhcnRzQnlJZCkuZmlsdGVyKHBhcnQgPT4ge1xuICAgICAgICBsZXQgcGFydE5hbWU7XG4gICAgICAgIGlmKHBhcnQudHlwZSA9PSAnd2luZG93Jyl7XG4gICAgICAgICAgICBwYXJ0TmFtZSA9IHBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICd0aXRsZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChwYXJ0LnR5cGUgPT0gJ3dpbmRvdycgJiYgbmFtZSA9PSBwYXJ0TmFtZSk7XG4gICAgfSk7XG4gICAgaWYoZm91bmQubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuZ2V0Q3VycmVudENhcmRNb2RlbCgpO1xuICAgIGxldCB3aW5kb3cgPSB0aGlzLm5ld01vZGVsKCd3aW5kb3cnLCBjdXJyZW50Q2FyZC5pZCk7XG4gICAgbGV0IGFyZWEgPSB0aGlzLm5ld01vZGVsKCdhcmVhJywgd2luZG93LmlkKTtcbiAgICBsZXQgc2NyaXB0RmllbGQgPSB0aGlzLm5ld01vZGVsKCdmaWVsZCcsIGFyZWEuaWQpO1xuICAgIGxldCBzYXZlQnV0dG9uID0gdGhpcy5uZXdNb2RlbCgnYnV0dG9uJywgYXJlYS5pZCk7XG5cblxuICAgIC8vIHNldHVwIHRoZSB3aW5kb3cgYW5kIHN0YWNrIHByb3BlcnRpZXNcbiAgICB3aW5kb3cuc2V0VGFyZ2V0KHRhcmdldCk7XG4gICAgd2luZG93LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQod2luZG93LCBcInRpdGxlXCIsIG5hbWUpO1xuICAgIHdpbmRvdy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHdpbmRvdywgXCJoZWlnaHRcIiwgMjAwKTtcbiAgICB3aW5kb3cucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh3aW5kb3csIFwid2lkdGhcIiwgNTAwKTtcbiAgICB3aW5kb3cucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh3aW5kb3csICd0b3AnLCAxMDApO1xuICAgIHdpbmRvdy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHdpbmRvdywgJ2xlZnQnLCAxMDApO1xuXG4gICAgYXJlYS5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGFyZWEsIFwibGF5b3V0XCIsIFwibGlzdFwiKTtcbiAgICBhcmVhLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoYXJlYSwgXCJsaXN0LWRpcmVjdGlvblwiLCBcImNvbHVtblwiKTtcbiAgICBhcmVhLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoYXJlYSwgXCJ3aWR0aFwiLCBcImZpbGxcIik7XG4gICAgYXJlYS5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGFyZWEsIFwiaGVpZ2h0XCIsIFwiZmlsbFwiKTtcblxuICAgIC8vIHNjcmlwdCBmaWVsZFxuICAgIGxldCB0YXJnZXRTY3JpcHQgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwic2NyaXB0XCIpOyBcbiAgICBzY3JpcHRGaWVsZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNjcmlwdEZpZWxkLCBcInRleHRcIiwgdGFyZ2V0U2NyaXB0KTtcbiAgICBzY3JpcHRGaWVsZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNjcmlwdEZpZWxkLCBcImhlaWdodFwiLCBcImZpbGxcIik7XG4gICAgc2NyaXB0RmllbGQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzY3JpcHRGaWVsZCwgXCJ3aWR0aFwiLCBcImZpbGxcIik7XG5cbiAgICAvLyBTZXR1cCBzeW50YXggaGlnaGxpZ2h0XG4gICAgc2NyaXB0RmllbGQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgY29tbWFuZE5hbWU6IFwiaGlnaGxpZ2h0U3ludGF4XCIsXG4gICAgICAgIGFyZ3M6IFtdXG4gICAgfSwgc2NyaXB0RmllbGQpO1xuXG5cbiAgICAvLyBzZXR1cCB1cCB0aGUgc2F2ZSBidXR0b24gcHJvcGVydGllc1xuICAgIHNhdmVCdXR0b24ucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChzYXZlQnV0dG9uLCBcIm5hbWVcIiwgXCJTYXZlIFNjcmlwdFwiKTtcbiAgICBzYXZlQnV0dG9uLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2F2ZUJ1dHRvbiwgXCJ3aWR0aFwiLCBcImZpbGxcIik7XG4gICAgc2F2ZUJ1dHRvbi5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHNhdmVCdXR0b24sIFwidGV4dC1zaXplXCIsIDIwKTtcbiAgICBzYXZlQnV0dG9uLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2F2ZUJ1dHRvbiwgXCJ0YXJnZXRcIiwgYHBhcnQgaWQgJHt0YXJnZXQuaWR9YCk7XG5cbiAgICBzYXZlQnV0dG9uLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2F2ZUJ1dHRvbiwgXCJ0YXJnZXRcIiwgYHBhcnQgaWQgJHt0YXJnZXQuaWR9YCk7XG4gICAgbGV0IHNhdmVTY3JpcHQgPSBgb24gY2xpY2tcXG5cXHR0ZWxsIHRhcmdldCB0byBzZXQgXCJzY3JpcHRcIiB0byB0aGUgXCJ0ZXh0XCIgb2YgZmlyc3QgZmllbGRcXG5lbmQgY2xpY2tgOyBcbiAgICBzYXZlQnV0dG9uLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2F2ZUJ1dHRvbiwgXCJzY3JpcHRcIiwgc2F2ZVNjcmlwdCk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snU2ltcGxlVGFsayddID0gZnVuY3Rpb24oc2VuZGVycyl7XG4gICAgcmV0dXJuIFN5c3RlbS5ncmFtbWFyLnNvdXJjZS5zb3VyY2VTdHJpbmc7XG59XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWydvcGVuRGVidWdnZXInXSA9IGZ1bmN0aW9uKHNlbmRlcnMsIHBhcnRJZCl7XG4gICAgbGV0IHRhcmdldCA9IHRoaXMucGFydHNCeUlkW3BhcnRJZF07XG4gICAgLy8gQ3JlYXRlIHRoZSBGaWVsZCBtb2RlbCBhbmQgYXR0YWNoIHRvIGN1cnJlbnQgY2FyZFxuICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuZ2V0Q3VycmVudENhcmRNb2RlbCgpO1xuICAgIGxldCBmaWVsZE1vZGVsID0gdGhpcy5uZXdNb2RlbCgnZmllbGQnLCBjdXJyZW50Q2FyZC5pZCk7XG4gICAgbGV0IHRleHQgPSBgQXZhaWxhYmxlIENvbW1hbmRzIGZvciAke3RhcmdldC5uYW1lfSAoaWQgJHt0YXJnZXQuaWR9KVxcblxcbmA7XG4gICAgT2JqZWN0LmtleXModGFyZ2V0LmNvbW1hbmRIYW5kbGVyUmVnaXN0cnkpLmZvckVhY2goKG5hbWUpID0+e1xuICAgICAgICBsZXQgaW5mbyA9IHRhcmdldC5jb21tYW5kSGFuZGxlclJlZ2lzdHJ5W25hbWVdO1xuICAgICAgICB0ZXh0ICs9IGAke25hbWV9OiAke0pTT04uc3RyaW5naWZ5KGluZm8pfVxcbmA7XG4gICAgfSk7XG4gICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICBmaWVsZE1vZGVsLFxuICAgICAgICAndGV4dCcsXG4gICAgICAgIHRleHRcbiAgICApO1xuICAgIGZpZWxkTW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgZmllbGRNb2RlbCxcbiAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgZmFsc2VcbiAgICApO1xufTtcblxuU3lzdGVtLl9jb21tYW5kSGFuZGxlcnNbJ3NhdmVIVE1MJ10gPSBmdW5jdGlvbihzZW5kZXJzKXtcbiAgICAvLyBTdG9wIGhhbmQgcmVjb2duaXRpb24gaWYgaXQncyBydW5uaW5nLlxuICAgIGxldCBoYW5kUmVjb2duaXRpb25PcmlnaW5hbGx5UnVubmluZyA9IGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmc7XG4gICAgaWYgKGhhbmRSZWNvZ25pdGlvbk9yaWdpbmFsbHlSdW5uaW5nKSB7XG4gICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RvcCgpO1xuICAgIH1cbiAgICB0aGlzLnNlcmlhbGl6ZSgpO1xuXG4gICAgbGV0IHN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xuICAgIGxldCBzZXJpYWxpemVkUGFnZSA9IHRoaXMuZ2V0RnVsbEhUTUxTdHJpbmcoKTtcbiAgICBsZXQgdHlwZUluZm8gPSBcImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04XCI7XG4gICAgbGV0IHVybCA9IGAke3R5cGVJbmZvfSwke2VuY29kZVVSSUNvbXBvbmVudChzZXJpYWxpemVkUGFnZSl9YDtcblxuICAgIGxldCBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYW5jaG9yLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChhbmNob3IpO1xuICAgIGFuY2hvci5ocmVmID0gdXJsO1xuICAgIGFuY2hvci5kb3dubG9hZCA9IGBTaW1wbGVUYWxrU25hcHNob3RfJHtzdGFtcH0uaHRtbGA7XG4gICAgYW5jaG9yLmNsaWNrKCk7XG4gICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICBhbmNob3IucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChhbmNob3IpO1xuICAgIC8vIFN0YXJ0IGhhbmQgcmVjb2duaXRpb24gaWYgaXQgd2FzIHJ1bm5pbmcuXG4gICAgaWYgKGhhbmRSZWNvZ25pdGlvbk9yaWdpbmFsbHlSdW5uaW5nKSB7XG4gICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RhcnQoKTtcbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1sndGVsbCddID0gKHNlbmRlcnMsIHRhcmdldElkLCBkZWZlcnJlZE1lc3NhZ2UpID0+IHtcbiAgICBsZXQgdGFyZ2V0UGFydCA9IFN5c3RlbS5wYXJ0c0J5SWRbdGFyZ2V0SWRdO1xuICAgIGlmKCF0YXJnZXRQYXJ0KXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gdGVsbCBwYXJ0IGlkICR7dGFyZ2V0SWR9OiBubyBzdWNoIHBhcnQhYCk7XG4gICAgfVxuICAgIHRhcmdldFBhcnQuc2VuZE1lc3NhZ2UoZGVmZXJyZWRNZXNzYWdlLCB0YXJnZXRQYXJ0KTtcbn07XG5cblN5c3RlbS5fY29tbWFuZEhhbmRsZXJzWyd0b2dnbGVIYW5kRGV0ZWN0aW9uJ10gPSAoKSA9PiB7XG4gICAgaWYgKGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbk1vZGVsID09PSBudWxsKSB7XG4gICAgICAgIGhhbmRJbnRlcmZhY2Uuc3RhcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kSW50ZXJmYWNlLnN0b3AoKTtcbiAgICB9XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snbWVycmlhbSddID0gKHNlbmRlcnMsIGRvY0lkKSA9PiB7XG4gICAgY29uc3Qgc2VuZGVyID0gU3lzdGVtLnBhcnRzQnlJZFtzZW5kZXJzWzBdLmlkXTtcbiAgICBtZXJyaWFtU2ltU2NvcmUoc2VuZGVyLCBkb2NJZCk7XG59O1xuXG5TeXN0ZW0uX2NvbW1hbmRIYW5kbGVyc1snZ2xvYmFsSW50ZXJydXB0J10gPSAoKSA9PiB7XG4gICAgLy8gY3ljbGUgdGhyb3VnaCBhbGwgdGhlIHBhcnRzIGFuZCBzZXQgdGhlIFwic3RlcHBpbmdcIiBwcm9wZXJ0eSB0byBmYWxzZVxuICAgIE9iamVjdC52YWx1ZXMoU3lzdGVtLnBhcnRzQnlJZCkuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICBpZihwYXJ0LmlzU3RlcHBpbmcpe1xuICAgICAgICAgICAgcGFydC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHBhcnQsIFwic3RlcHBpbmdcIiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKiBSZWdpc3RlciB0aGUgaW5pdGlhbCBzZXQgb2YgcGFydHMgaW4gdGhlIHN5c3RlbSAqKi9cblN5c3RlbS5yZWdpc3RlclBhcnQoJ2NhcmQnLCBDYXJkKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ3N0YWNrJywgU3RhY2spO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnZmllbGQnLCBGaWVsZCk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdidXR0b24nLCBCdXR0b24pO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnd29ybGQnLCBXb3JsZFN0YWNrKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ3dpbmRvdycsIFdpbmRvdyk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdmaWVsZCcsIEZpZWxkKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2RyYXdpbmcnLCBEcmF3aW5nKTtcblN5c3RlbS5yZWdpc3RlclBhcnQoJ2ltYWdlJywgSW1hZ2UpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnYXJlYScsIEFyZWEpO1xuU3lzdGVtLnJlZ2lzdGVyUGFydCgnYXVkaW8nLCBBdWRpbyk7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdicm93c2VyJywgQnJvd3Nlcik7XG5TeXN0ZW0ucmVnaXN0ZXJQYXJ0KCdyZXNvdXJjZScsIFJlc291cmNlKTtcblxuLyoqIFJlZ2lzdGVyIHRoZSBpbml0aWFsIHNldCBvZiB2aWV3cyBpbiB0aGUgc3lzdGVtICoqL1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnYnV0dG9uJywgQnV0dG9uVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdzdGFjaycsIFN0YWNrVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCd3b3JsZCcsIFdvcmxkVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdjYXJkJywgQ2FyZFZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnd2luZG93JywgV2luZG93Vmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdmaWVsZCcsIEZpZWxkVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdkcmF3aW5nJywgRHJhd2luZ1ZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnaW1hZ2UnLCBJbWFnZVZpZXcpO1xuU3lzdGVtLnJlZ2lzdGVyVmlldygnYXJlYScsIEFyZWFWaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2F1ZGlvJywgQXVkaW9WaWV3KTtcblN5c3RlbS5yZWdpc3RlclZpZXcoJ2Jyb3dzZXInLCBCcm93c2VyVmlldyk7XG5TeXN0ZW0ucmVnaXN0ZXJWaWV3KCdyZXNvdXJjZScsIFJlc291cmNlVmlldyk7XG5cblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBhZGRpbmcgYWxsIG9mIHRoZVxuLy8gYXZhaWxhYmxlIGN1c3RvbSBlbGVtZW50cyB0byB0aGUgd2luZG93IG9iamVjdCdzXG4vLyBjdXN0b21FbGVtZW50cyByZWdpc3RyeVxuU3lzdGVtLnJlZ2lzdGVyQ3VzdG9tRWxlbWVudHMgPSBmdW5jdGlvbigpe1xuICAgIE9iamVjdC5rZXlzKFN5c3RlbS5hdmFpbGFibGVWaWV3cykuZm9yRWFjaChwYXJ0TmFtZSA9PiB7XG4gICAgICAgIGxldCB2aWV3Q2xhc3MgPSBTeXN0ZW0uYXZhaWxhYmxlVmlld3NbcGFydE5hbWVdO1xuICAgICAgICBsZXQgZWxlbWVudE5hbWUgPSBTeXN0ZW0udGFnTmFtZUZvclZpZXdOYW1lZChwYXJ0TmFtZSk7XG4gICAgICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoZWxlbWVudE5hbWUsIHZpZXdDbGFzcyk7XG4gICAgfSk7XG59O1xuXG4vLyBpbmlpdGFsaXplIHRoZSBjb21waWxlciBhbmQgYWRkIGl0IHRvIHRoZSBzeXN0ZW1cbi8vIEluc3RhbnRpYXRlIHRoZSBncmFtbWFyLlxubGV0IGxhbmd1YWdlR3JhbW1hcjtcbmlmICh3aW5kb3cuZ3JhbW1hcil7XG4gICAgLy8gZm9yIHRlc3RpbmcgaXQgaXMgc29tZXRpbWVzIGNvbnZlbmllbnQgdG8gbG9hZCB0aGUgZ3JhbW1hciBhbmQgYWRkIHRvIHdpbmRvd1xuICAgIC8vIHNlZSAuL3Rlc3RzL3ByZWxvYWQuanMgZm9yIGV4YW1wbGVcbiAgICBsYW5ndWFnZUdyYW1tYXIgPSBvaG0uZ3JhbW1hcih3aW5kb3cuZ3JhbW1hcik7XG59IGVsc2Uge1xuICAgIGxhbmd1YWdlR3JhbW1hciA9IG9obS5ncmFtbWFyRnJvbVNjcmlwdEVsZW1lbnQoKTtcbn1cblxuU3lzdGVtLmdyYW1tYXIgPSBsYW5ndWFnZUdyYW1tYXI7XG5cbi8vIFNldCB0aGUgZXhlY3Rpb24gc3RhY2sgb24gdGhlXG4vLyBTeXN0ZW1cblN5c3RlbS5leGVjdXRpb25TdGFjayA9IG5ldyBFeGVjdXRpb25TdGFjaygpO1xuXG4vLyBBZGQgYSBkeW5hbWljIGdldHRlciBmb3IgdGhlIFdvcmxkIGZvciBjb252ZW5pZW5jZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5c3RlbSwgJ3dvcmxkJywge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydHNCeUlkWyd3b3JsZCddO1xuICAgIH1cbn0pO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIC8vIEFkZCB0aGUgU3lzdGVtIG9iamVjdCB0byB3aW5kb3cgc29cbiAgICAvLyB0aGF0IGl0IGlzIGdsb2JhbCBvbiB0aGUgcGFnZS4gV2UgZG8gdGhpc1xuICAgIC8vIGZvciBib3RoIGRlYnVnZ2luZyBhbmQgdGVzdGluZy5cbiAgICB3aW5kb3cuU3lzdGVtID0gU3lzdGVtO1xuICAgIC8vIEFkZCB0aGUgcG9zc2libGUgdmlld3MgYXMgd2ViY29tcG9uZW50c1xuICAgIC8vIGluIHRoZSBjdXN0b20gZWxlbWVudCByZWdpc3RyeVxuICAgIFN5c3RlbS5yZWdpc3RlckN1c3RvbUVsZW1lbnRzKCk7XG5cbiAgICAvLyBBZGQgYW55IG90aGVyIG5vbi1wYXJ0IHZpZXcgQ3VzdG9tRWxlbWVudHMsXG4gICAgLy8gbGlrZSB0aGUgaGFsb1xuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0LWhhbG8nLCBIYWxvKTtcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdC1uYXZpZ2F0b3InLCBTVE5hdmlnYXRvcik7XG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3QtZWRpdG9yJywgRWRpdG9yKTtcblxuICAgIC8vIEFkZCBuYXZcbiAgICBTeXN0ZW0ubmF2aWdhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtbmF2aWdhdG9yJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChTeXN0ZW0ubmF2aWdhdG9yKTtcblxuICAgIC8vIEFkZCBjb21wcmVoZW5zaXZlIGVkaXRvciBwYW5lXG4gICAgLy8gaWYgb25lIGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIG1hcmt1cFxuICAgIGxldCBleGlzdGluZ0VkaXRvcnMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0LWVkaXRvcicpKTtcbiAgICBleGlzdGluZ0VkaXRvcnMuZm9yRWFjaChlZGl0b3JFbCA9PiB7XG4gICAgICAgIGVkaXRvckVsLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIFN5c3RlbS5lZGl0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1lZGl0b3InKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFN5c3RlbS5lZGl0b3IpO1xuXG4gICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBzZXR1cCBvZlxuICAgIC8vIHRoZSBzeXN0ZW1cbiAgICBTeXN0ZW0uaW5pdGlhbExvYWQoKTtcbn0pO1xuXG4vLyBhZGQgYSBtZXNzYWdlIGxpc3RlbmVyIG9uIHdpbmRvd1xuLy8gdGhlc2UgY2FuIGluY2x1ZGUgbWVzc2FnZSBmcm9tIGEgYnJvd3NlciBwYXJ0XG4vLyBmb3Igbm93IGZpbHRlciB0aG9zZSBub3QgY29taW5nIGZyb20gdGhlIG9yaWdpblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5vcmlnaW4gIT09IHdpbmRvdy5vcmlnaW4pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zb2xlLmxvZyhgTWVzc2FnZSB0byBicm93c2VyYCk7XG4gICAgLy8gVE9ETzogbWF5YmUgd2UgbmVlZCB0byBkZWFsIHdpdGggcXVvdGUgZXNjYXBlcyBkaXJlY3RseVxuICAgIC8vIGluIHRoZSBncmFtbWFyXG4gICAgbGV0IHNjcmlwdCA9IGV2ZW50LmRhdGEucmVwbGFjZUFsbChcIidcIiwgJ1wiJyk7XG4gICAgLy8gb25seSBzdGF0ZW1lbnRzIGFyZSBhY2NlcHRlZCBmb3Igbm93XG4gICAgbGV0IHBhcnNlZFNjcmlwdCA9IGxhbmd1YWdlR3JhbW1hci5tYXRjaChzY3JpcHQsIFwiU3RhdGVtZW50XCIpO1xuICAgIGlmKHBhcnNlZFNjcmlwdC5mYWlsZWQoKSl7XG4gICAgICAgIC8vIGZvciBub3cganVzdCBsb2cgdGhhdCBpdCBmYWlsZWRcbiAgICAgICAgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gcGFyc2Ugc2NyaXB0IGZvciBicm93c2VyXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzZW1hbnRpY3MgPSBsYW5ndWFnZUdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgIGxldCB3b3JsZCA9IFN5c3RlbS5wYXJ0c0J5SWRbXCJ3b3JsZFwiXTtcbiAgICAgICAgc2VtYW50aWNzLmFkZE9wZXJhdGlvbihcbiAgICAgICAgICAgICdpbnRlcnByZXQnLFxuICAgICAgICAgICAgaW50ZXJwcmV0ZXJTZW1hbnRpY3Mod29ybGQsIFN5c3RlbSlcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IG1zZyA9IHNlbWFudGljcyhwYXJzZWRTY3JpcHQpLmludGVycHJldCgpO1xuICAgICAgICBTeXN0ZW0uc2VuZE1lc3NhZ2UobXNnLCB3b3JsZCwgU3lzdGVtKTtcbiAgICB9XG59KTtcblxuLy8gZ2xvYmFsIGludGVycnVwdFxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgIGlmKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5ID09ICdjJyl7XG4gICAgICAgIFN5c3RlbS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImdsb2JhbEludGVycnVwdFwiLFxuICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgfSwgU3lzdGVtLCBTeXN0ZW0pO1xuICAgIH1cbn0pO1xuXG5cbmV4cG9ydCB7XG4gICAgU3lzdGVtLFxuICAgIFN5c3RlbSBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBBcmVhXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgQXJlYSBQYXJ0LlxuICogSSByZXByZXNlbnQgYSAnZ3JvdXBpbmcnIG9mIHN1YnBhcnRzIHdpdGhpblxuICogbXkgb3duZXIgcGFydC5cbiAqIEkgY29udGFpbiB0aGUgTGF5b3V0IHByb3BlcnRpZXMgc2V0LCBhbmQgdGhlcmVmb3JlXG4gKiBjYW4gZGlzcGxheSBteSBjb250YWluZWQgc3VicGFydHMgYWNjb3JkaW5nIHRvIFxuICogZGlmZmVyZW50IGxheW91dCBwcm9wZXJ0aWVzIHRoYW4gbXkgYW5jZXN0b3JcbiAqIENhcmQuXG4gKlxuICovXG5pbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkTGF5b3V0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jb25zdCBzaWRlcyA9IFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXTtcblxuY2xhc3MgQXJlYSBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgICB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzID0gW1xuICAgICAgICAgICAgXCJhcmVhXCIsXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgXCJmaWVsZFwiLFxuICAgICAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICAgICAgXCJhdWRpb1wiLFxuICAgICAgICAgICAgXCJyZXNvdXJjZVwiLFxuICAgICAgICAgICAgXCJkcmF3aW5nXCIsXG4gICAgICAgICAgICBcImJyb3dzZXJcIixcbiAgICAgICAgICAgIFwid2luZG93XCJcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBZGQgc3R5bGUgcHJvcHNcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZExheW91dFN0eWxlUHJvcHModGhpcyk7XG5cbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAvLyBmb3IgYW4gZW1wdHkgYXJlYVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgIDUwXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgIDUwXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2NsaXBwaW5nJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2FsbG93LXNjcm9sbGluZycsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC10cmFuc3BhcmVuY3knLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYGJvcmRlci0ke3N9LWNvbG9yYCxcbiAgICAgICAgICAgICAgICBcInJnYigyMzgsIDIzOCwgMjM4KVwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS10cmFuc3BhcmVuY3lgLFxuICAgICAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdhcmVhJztcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEFyZWEsXG4gICAgQXJlYSBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIEF1ZGlvIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIHNyYykge1xuICAgICAgICBzdXBlcihvd25lcik7XG5cbiAgICAgICAgLy8gUHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zcmMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3JlYWR5U3RhdGUnLFxuICAgICAgICAgICAgXCJIQVZFX05PVEhJTkdcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJwbGF5XCIsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJzdG9wXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZEF1ZGlvRnJvbVNvdXJjZVwiLCB0aGlzLmxvYWRBdWRpb0Zyb21Tb3VyY2UpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInBsYXlcIiwgKCkgPT4ge3RoaXMucGxheSh0cnVlKTt9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJwYXVzZVwiLCAoKSA9PiB7dGhpcy5wbGF5KGZhbHNlKTt9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzdG9wXCIsIHRoaXMuc3RvcCk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLmxvYWRBdWRpb0Zyb21Tb3VyY2UgPSB0aGlzLmxvYWRBdWRpb0Zyb21Tb3VyY2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wbGF5ID0gdGhpcy5wbGF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3RvcCA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpO1xuXG5cbiAgICAgICAgLy8gbG9hZCB0aGUgc3JjIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRUZXh0U3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzaWRlfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdhdWRpbyc7XG4gICAgfVxuXG4gICAgbG9hZEF1ZGlvRnJvbVNvdXJjZShzZW5kZXJzLCBzb3VyY2VVcmwpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgc291cmNlVXJsKTtcbiAgICB9XG5cbiAgICBwbGF5KHZhbHVlKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicGxheVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInN0b3BcIiwgZmFsc2UpO1xuICAgIH1cblxuICAgIHN0b3AoKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicGxheVwiLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInN0b3BcIiwgdHJ1ZSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBBdWRpbyxcbiAgICBBdWRpbyBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIEJyb3dzZXIgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgc3JjKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNyYyA9IG51bGw7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3JlYWR5U3RhdGUnLFxuICAgICAgICAgICAgXCJIQVZFX05PVEhJTkdcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJwbGF5XCIsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJzdG9wXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwic2V0VVJMVG9cIiwgdGhpcy5zZXRVUkwpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImZvcndhcmRcIiwgdGhpcy5zZW5kTWVzc2FnZVRvQnJvd3Nlcik7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNldFVSTCA9IHRoaXMuc2V0VVJMLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VUb0Jyb3dzZXIgPSB0aGlzLnNlbmRNZXNzYWdlVG9Ccm93c2VyLmJpbmQodGhpcyk7XG5cblxuICAgICAgICAvLyBsb2FkIHRoZSBzcmMgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYoc3JjKXtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInNyY1wiLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIFtcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiXS5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c2lkZX0td2lkdGhgLFxuICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICAgICAgNDAwLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnYnJvd3Nlcic7XG4gICAgfVxuXG4gICAgc2V0VVJMKHNlbmRlcnMsIHNvdXJjZVVybCl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInNyY1wiLCBzb3VyY2VVcmwpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlVG9Ccm93c2VyKHNlbmRlcnMsIG1lc3NhZ2Upe1xuICAgICAgICBsZXQgdmlld3MgPSB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGhpcy5pZCk7XG4gICAgICAgIHZpZXdzLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGxldCBpZnJhbWUgPSB2Ll9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJpZnJhbWVcIik7XG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCB3aW5kb3cub3JpZ2luKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBCcm93c2VyLFxuICAgIEJyb3dzZXIgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQnV0dG9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgQnV0dG9uIFBhcnQuXG4gKiBNeSBvd25lciBpcyBhbHdheXMgYSBDYXJkLlxuICogSSBhbSBhIGNsaWNrYWJsZSBwb2ludCBvZiBpbnRlcmFjdGlvbiBvbiBhIENhcmQsXG4gKiB3aG9zZSBmdW5jdGlvbmFsaXR5IGNhbiBiZSBjdXN0b21pemVkIGJ5IHRoZSBhdXRob3IuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIEJhc2ljUHJvcGVydHksXG4gICAgRHluYW1pY1Byb3BlcnR5XG59IGZyb20gJy4uL3Byb3BlcnRpZXMvUGFydFByb3BlcnRpZXMuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIEJ1dHRvbiBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyKXtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuXG4gICAgICAgIHRoaXMuaXNCdXR0b24gPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCBCdXR0b24tc3BlY2lmaWMgcGFydCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAnc2VsZWN0ZWRUZXh0JyxcbiAgICAgICAgICAgIG51bGwsIC8vIHJlYWRPbmx5IChmb3Igbm93KVxuICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3RlZFRleHQsXG4gICAgICAgICAgICB0cnVlLCAvLyByZWFkT25seSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdHlsaW5nXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRUZXh0U3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICAvLyBwYXJ0IHNwZWNpZmljIGRlZmF1bHQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InLFxuICAgICAgICAgICAgXCJyZ2IoMjU1LCAyMzQsIDE0OSlcIiwgLy8gdmFyKC0tcGFsZXR0ZS15ZWxsb3cpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY29ybmVyLXRvcC1sZWZ0LXJvdW5kJyxcbiAgICAgICAgICAgIDNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjb3JuZXItdG9wLXJpZ2h0LXJvdW5kJyxcbiAgICAgICAgICAgIDNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjb3JuZXItYm90dG9tLWxlZnQtcm91bmQnLFxuICAgICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2Nvcm5lci1ib3R0b20tcmlnaHQtcm91bmQnLFxuICAgICAgICAgICAgM1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JvcmRlci10b3Atd2lkdGgnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JvcmRlci1ib3R0b20td2lkdGgnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JvcmRlci1sZWZ0LXdpZHRoJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdib3JkZXItcmlnaHQtd2lkdGgnLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3NoYWRvdy1sZWZ0JyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdzaGFkb3ctdG9wJyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdzaGFkb3ctYmx1cicsXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnc2hhZG93LWJsdXInLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuXG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdidXR0b24nO1xuICAgIH1cblxuICAgIC8vVE9ETzogaW1wbGVtZW50IHRoaXMgcHJvcGVydHlcbiAgICAvLyBnZXR0ZXIgZm9yIHJlYWxcbiAgICBnZXRTZWxlY3RlZFRleHQocHJvcE5hbWUsIHByb3BWYWwpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEJ1dHRvbixcbiAgICBCdXR0b24gYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQ2FyZFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBDYXJkIFBhcnQuXG4gKiBJIHJlcHJlc2VudCBhIGNvbGxlY3Rpb24gb2YgUGFydHMgdGhhdCBpc1xuICogZGlzcGxheWVkIG9uIHRoZSBzY3JlZW4uIE15IG93bmVyIGlzIGFsd2F5c1xuICogYSBTdGFjayBQYXJ0LlxuICogSSBjYW4gY29udGFpbiBhbnkga2luZCBvZiBQYXJ0LCBpbmNsdWRpbmdcbiAqIGJ1dHRvbnMgYW5kIGZpZWxkcy5cbiAqL1xuaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBCYXNpY1Byb3BlcnR5XG59IGZyb20gJy4uL3Byb3BlcnRpZXMvUGFydFByb3BlcnRpZXMuanMnO1xuXG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRMYXlvdXRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIENhcmQgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgbmFtZSl7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuX293bmVyO1xuICAgICAgICB0aGlzLmFjY2VwdGVkU3VicGFydFR5cGVzID0gW1xuICAgICAgICAgICAgXCJ3aW5kb3dcIiwgXCJidXR0b25cIixcbiAgICAgICAgICAgIFwiZmllbGRcIiwgXCJmaWVsZFwiLCBcImFyZWFcIiwgXCJkcmF3aW5nXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsIFwiYXVkaW9cIiwgXCJicm93c2VyXCIsIFwicmVzb3VyY2VcIlxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmlzQ2FyZCA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIENhcmQtc3BlY2lmaWMgcGFydFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ21hcmtlZCcsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdjYW50RGVsZXRlJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2RvbnRTZWFyY2gnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnc2hvd1BpY3QnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgaW5pdGlhbGl6aW5nIHdpdGggYSBuYW1lXG4gICAgICAgIC8vIHNldCB0aGUgbmFtZSBwcm9wZXJ0eVxuICAgICAgICBpZihuYW1lKXtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZExheW91dFN0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgIFwicmdiKDAsIDc1LCAxMDMpXCIgLy8gcGFsZXR0ZS1ibHVlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdjYXJkJztcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIENhcmQsXG4gICAgQ2FyZCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBCYXNpYyBVc2VyIERyYXdpbmcgUGFydFxuICovXG5pbXBvcnQge1BhcnR9IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY29uc3Qgc2lkZXMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5cbmNsYXNzIERyYXdpbmcgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcil7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBTZXQgbmV3IHByb3BlcnRpZXMgZm9yIHRoaXNcbiAgICAgICAgLy8gcGFydCB0eXBlXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICAnZHJhd2luZydcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU3R5bGVcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwicmdiKDIzOCwgMjM4LCAyMzgpXCIsIC8vZ3JleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS10cmFuc3BhcmVuY3lgLFxuICAgICAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgIDMwMFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAyMDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBXZSBhcmUgdXNpbmcgYSBkaXN0aW5jdCBzaG93LWJvcmRlclxuICAgICAgICAvLyBwcm9wZXJ0eSB0byBkZWFsIHdpdGggYmVpbmcgYWJsZSB0byBzZWVcbiAgICAgICAgLy8gYSBkcmF3aW5nIHRoYXQgaXMgZW1wdHlcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnc2hvdy1ib3JkZXInLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFdoZW4gZHJhd2luZyBmcm9tIGEgc2NyaXB0L2NvbW1hbmRzLFxuICAgICAgICAvLyB3ZSB3aWxsIHVzZSB0aGlzIGFzIHRoZSBvcGVuIGNhbnZhc1xuICAgICAgICAvLyB3aG9zZSBpbWFnZSBieXRlcyB3aWxsIGJlIHNldCB0byB0aGVcbiAgICAgICAgLy8gaW1hZ2UgcHJvcGVydHlcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBudWxsO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgZHJhd2luZyBjb21tYW5kc1xuICAgICAgICB0aGlzLnNldHVwRHJhd2luZ0NvbW1hbmRzKCk7XG5cblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2V0dXBEcmF3aW5nQ29tbWFuZHMgPSB0aGlzLnNldHVwRHJhd2luZ0NvbW1hbmRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gdGhpcy5zdHJva2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlVG8gPSB0aGlzLm1vdmVUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmxpbmVUbyA9IHRoaXMubGluZVRvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVnaW5EcmF3ID0gdGhpcy5iZWdpbkRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmREcmF3ID0gdGhpcy5lbmREcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXIgPSB0aGlzLmNsZWFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29vcmRzRnJvbVN0cmluZyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnZHJhd2luZyc7XG4gICAgfVxuXG4gICAgc2V0dXBEcmF3aW5nQ29tbWFuZHMoKXtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ2xpbmVUbycsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdtb3ZlVG8nLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignYmVnaW5EcmF3JywgKHNlbmRlcnMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5EcmF3KC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ2ZpbmlzaERyYXcnLCAoc2VuZGVycywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmREcmF3KC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoJ3N0cm9rZScsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKCdjbGVhcicsIChzZW5kZXJzLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBTY3JpcHRhYmxlIERyYXdpbmcgQ29tbWFuZHMgKi9cbiAgICBzdHJva2UoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgLy8gSGFyZC1jb2RlZC4gR2V0IGZyb20gcHJvcHNcbiAgICAgICAgICAgIC8vIGFuZCBsaW5rIHRvIHZpZXdzXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQuc3Ryb2tlV2lkdGggPSAxMDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlVG8oeCwgeSl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIC8vbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZyhjb29yZFBhaXIpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0Lm1vdmVUbyhcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5lVG8oeCwgeSl7XG4gICAgICAgIGlmKHRoaXMuaXNEcmF3aW5nKXtcbiAgICAgICAgICAgIC8vbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzRnJvbVN0cmluZyhjb29yZFBhaXIpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWdpbkRyYXcoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEcmF3aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMud2lkdGggPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3dpZHRoJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcy5oZWlnaHQgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2hlaWdodCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0ID0gdGhpcy5hY3RpdmVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBjdXJyZW50bHkgaW1hZ2UgZGF0YSBzZXQgdG8gdGhlXG4gICAgICAgIC8vIGltYWdlIHBhcnQgcHJvcGVydHksIHdlIG5lZWQgdG8gZHJhdyB0aGF0IGltYWdlXG4gICAgICAgIC8vIG9udG8gdGhlIGNhbnZhcyBmaXJzdC5cbiAgICAgICAgbGV0IGN1cnJlbnRJbWFnZSA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaW1hZ2UnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRJbWFnZSl7XG4gICAgICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gY3VycmVudEltYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVnaW4gYSBkcmF3aW5nIHBhdGhcbiAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGVuZERyYXcoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGltYWdlIHByb3BlcnR5IHRvIGJlIHRoZVxuICAgICAgICAgICAgLy8gc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHVwZGF0ZSBhbnkgc3Vic2NyaWJlZCB2aWV3c1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNhbnZhcy50b0RhdGFVUkwoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzRHJhd2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKXtcbiAgICAgICAgaWYodGhpcy5pc0RyYXdpbmcpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FudmFzLndpZHRoID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICd3aWR0aCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMuaGVpZ2h0ID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29udGV4dCA9IHRoaXMuYWN0aXZlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMudG9EYXRhVVJMKClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qIFV0aWxpdHkgTWV0aG9kcyBmb3IgU2NyaXB0YWJsZSBEcmF3aW5nICovXG4gICAgY29vcmRzRnJvbVN0cmluZyhjb29yZFN0cmluZyl7XG4gICAgICAgIGxldCBwYWlyID0gY29vcmRTdHJpbmcuc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgeCA9IHBhcnNlSW50KHBhaXJbMF0pO1xuICAgICAgICBsZXQgeSA9IHBhcnNlSW50KHBhaXJbMV0pO1xuICAgICAgICByZXR1cm4ge3gsIHl9O1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRHJhd2luZyxcbiAgICBEcmF3aW5nIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEZpZWxkXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIEZpZWxkIFBhcnQuXG4gKiBJIGFtIGEgY29udGFpbmVyIHRoYXQgaG9sZHMgdGV4dC4gSSBhbHNvIGFsbG93XG4gKiBhIHVzZXIgdG8gZWRpdCBteSB0ZXh0LlxuICovXG5pbXBvcnQgUGFydCBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcblxuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jbGFzcyBGaWVsZCBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBuYW1lKXtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXCJmaWVsZFwiXTtcblxuICAgICAgICB0aGlzLmlzRmllbGQgPSB0cnVlO1xuXG4gICAgICAgIGlmKG5hbWUpe1xuICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIEZpZWxkLXNwZWNpZmljXG4gICAgICAgIC8vIFBhcnQgUHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdtb2RlJyxcbiAgICAgICAgICAgICdlZGl0aW5nJyAvL1RPRE8gdGhpcyBzaG91bGQgYmUgZWl0aGVyIFwiYnJhdm9cIiBvciBcInNpbXBsZXRhbGtcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAgICAgICAnJ1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3RhcmdldFJhbmdlSWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vICd0ZXh0JyBpcyBhIER5bmFtaWNQcm9wZXJ0eSBjb25maWd1cmVkIHRvIGFsc28gc2V0IHRoZSBpbm5lckhUTUxcbiAgICAgICAgLy8gQmFzaWNQcm9wZXJ0eSB3aGVuIGNoYW5nZWQuIFRoZSBiYXNpYyBpZGVhIGlzIHRoYXQgJ3RleHQnIHdpbGwgYmVcbiAgICAgICAgLy8gdGhlIHByb3BlcnR5IHRoYXQgU1Qgd2lsbCBpbnRlcmZhY2Ugd2l0aCBhbmQgZXZlcnl0aW1lIGl0XG4gICAgICAgIC8vIGlzIGNoYW5nZWQgdGhlICdpbm5lckhUTUwnIHByb3BlcnR5IHNob3VsZCBmb2xsb3cuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAob3duZXIsIHByb3AsIHZhbHVlLCBub3RpZnkpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9wLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmKG5vdGlmeSl7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgYWxsIG5ld2xpbmUgY2hhcmFjdGVycyB3aXRoIDxicj5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpO1xuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG93bmVyLCAnaW5uZXJIVE1MJywgdmFsdWUsIG5vdGlmeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChvd25lciwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wLl92YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICAgICAgJycgICAgIC8vIGRlZmF1bHQgaXMgZW1wdHkgc3RyaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnZWRpdGFibGUnLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG5cbiAgICAgICAgLy8gQSBudW1iZXIgb2YgdGhlIHByb3BzIGRlYWwgd2l0aCBkaXJlY3QgdGV4dCBlZGl0aW5nLFxuICAgICAgICAvLyBhbmQgc28gdGhleSBhcmUgbGlrZSBjb21tYW5kcy4gRXhhbXBsZXMgaW5jbHVkZSBcInVuZG9cIlxuICAgICAgICAvLyBcInJlZG9cIiBcImNsZWFyXCIgZXRjLiBIZXJlIHdlIHVzZSBkeW5hbWkgcHJvcHMgd2hpY2ggdGhlXG4gICAgICAgIC8vIHZpZXcgY2FuIHJlc3BvbmQgdG8gYWNjb3JkaW5nbHksIGJ1dCBoYXZpbmcgdGhlc2UgcHJvcHMgaGF2ZVxuICAgICAgICAvLyBubyBhY3R1YWwgJ3N0YXRlJ1xuICAgICAgICAvKiogVE9ETzogdGhlc2Ugc2hvdWxkIGJlIHByaXZhdGUgY29tbWFuZHNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgIFwidW5kb1wiLFxuICAgICAgICAgICAgKCkgPT4ge30sIC8vIGFsbCB3ZSBpcyBhIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgKCkgPT4ge30gLy8gbm8gZ2V0dGVyXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICBcInJlZG9cIixcbiAgICAgICAgICAgICgpID0+IHt9LCAvLyBhbGwgd2UgaXMgYSBub3RpZmljYXRpb25cbiAgICAgICAgICAgICgpID0+IHt9IC8vIG5vIGdldHRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAgICAgXCJyZW1vdmUtZm9ybWF0XCIsXG4gICAgICAgICAgICAoKSA9PiB7fSwgLy8gYWxsIHdlIGlzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAoKSA9PiB7fSAvLyBubyBnZXR0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgKiovXG5cbiAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICAvLyBzZXR0aW5nIHdpZHRoIGFuZCBoZWlnaHQgdG8gbnVsbFxuICAgICAgICAvLyBlZmZlY3RpdmVseSBmb3JjZXMgdG8gdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAgICAvLyBvZiB0aGUgYnV0dG9uIHRvIGZpdCB0aGUgYnV0dG9uIG5hbWVcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFRleHRTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIHBhcnQgc3BlY2lmaWMgZGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcInJnYigyNTUsIDI0OCwgMjIwKVwiLCAvLyB2YXIoLS1wYWxldHRlLWNvcm5zaWspXG4gICAgICAgICk7XG4gICAgICAgIHNpZGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgXCJtZWRpdW1cIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tc3R5bGVgLFxuICAgICAgICAgICAgICAgIFwic29saWRcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgICAgIFwiYmxhY2tcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgICAgIFwiMVwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICAgICA0MDAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG5cbiAgICAgICAgdGhpcy5pbnNlcnRSYW5nZSA9IHRoaXMuaW5zZXJ0UmFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24gPSB0aGlzLnNldFNlbGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcImluc2VydFJhbmdlXCIsIHRoaXMuaW5zZXJ0UmFuZ2UpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInNldFNlbGVjdGlvblwiLCB0aGlzLnNldFNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiaGlnaGxpZ2h0U3ludGF4XCIsIHRoaXMuaGlnaGxpZ2h0U3ludGF4KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJ1bmhpZ2hsaWdodFN5bnRheFwiLCB0aGlzLnVuaGlnaGxpZ2h0U3ludGF4KTtcbiAgICB9XG5cbiAgICBpbnNlcnRSYW5nZShzZW5kZXJzLCByYW5nZUlkLCBodG1sLCBjc3Mpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGhpcy5pZCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy5pbnNlcnRSYW5nZShyYW5nZUlkLCBodG1sLCBjc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb24oc2VuZGVycywgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKXtcbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IGFsbG93IHByb3BlcnRpZXMgb2YgdHlwZSBcInRleHQtKlwiIHRvIGJlIHNldFxuICAgICAgICBpZihwcm9wZXJ0eU5hbWUuc3RhcnRzV2l0aChcInRleHQtXCIpKXtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0aGlzLmlkKS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRTZWxlY3Rpb24ocHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCB2aWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5pZCk7XG4gICAgICAgIGlmKHZpZXcpe1xuICAgICAgICAgICAgdmlldy5oaWdobGlnaHRTeW50YXgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuaGlnaGxpZ2h0U3ludGF4KCl7XG4gICAgICAgIGxldCB2aWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5pZCk7XG4gICAgICAgIGlmKHZpZXcpe1xuICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodFN5bnRheCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdmaWVsZCc7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBGaWVsZCxcbiAgICBGaWVsZCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuXG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHNcbn0gZnJvbSAnLi4vdXRpbHMvc3R5bGVQcm9wZXJ0aWVzLmpzJztcblxuY2xhc3MgSW1hZ2UgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgc3JjKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgdGhpcy5zZXRTb3VyY2UsXG4gICAgICAgICAgICB0aGlzLmdldFNvdXJjZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3NyYyA9IHNyYztcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwibWltZVR5cGVcIixcbiAgICAgICAgICAgIFwidW5rbm93blwiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcImltYWdlRGF0YVwiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2RyYWdnYWJsZScsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgYWRkQmFzaWNTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gcGFydCBzcGVjaWZpYyBkZWZhdWx0IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICAgICAgICBcImJsYWNrXCJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcml2YXRlIGNvbW1hbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJsb2FkSW1hZ2VGcm9tXCIsIHRoaXMubG9hZEltYWdlRnJvbVNvdXJjZSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZEltYWdlRnJvbUZpbGVcIiwgdGhpcy5sb2FkSW1hZ2VGcm9tRmlsZSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLmxvYWRJbWFnZUZyb21Tb3VyY2UgPSB0aGlzLmxvYWRJbWFnZUZyb21Tb3VyY2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2VGcm9tRmlsZSA9IHRoaXMubG9hZEltYWdlRnJvbUZpbGUuYmluZCh0aGlzKTtcbiAgICB9XG5cblxuICAgIGxvYWRJbWFnZUZyb21Tb3VyY2Uoc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgZmV0Y2goc291cmNlVXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICBpZighY29udGVudFR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UnKSl7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbWFnZSBtaW1lVHlwZTogJHtjb250ZW50VHlwZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbWVUeXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZihjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiaW1hZ2Uvc3ZnXCIpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKHRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKS50aGVuKGJsb2IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXN1bHQgLy8gd2lsbCBiZSB0aGUgYmFzZTY0IGVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBfc3JjLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGluZmluaXRlbHlcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBsb2FkIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuX3NyYyA9IHNvdXJjZVVybDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAnaW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2FkSW1hZ2VGcm9tRmlsZSgpe1xuICAgICAgICBsZXQgZmlsZVBpY2tlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGZpbGVQaWNrZXIudHlwZSA9ICdmaWxlJztcbiAgICAgICAgZmlsZVBpY2tlci5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsICdpbWFnZS8qJyk7XG4gICAgICAgIGZpbGVQaWNrZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZmlsZVBpY2tlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZmlsZSBoZXJlXG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAnbWltZVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICBmaWxlUGlja2VyLmZpbGVzWzBdLnR5cGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXN1bHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBpbWFnZUZpbGUgPSBmaWxlUGlja2VyLmZpbGVzWzBdO1xuICAgICAgICAgICAgaWYoaW1hZ2VGaWxlLnR5cGUuaW5jbHVkZXMoJ3N2ZycpKXtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChpbWFnZUZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZUZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVBpY2tlci5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGZpbGVQaWNrZXIpO1xuICAgICAgICBmaWxlUGlja2VyLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlKG93bmVyLCBwcm9wZXJ0eSwgdmFsdWUpe1xuICAgICAgICBvd25lci5fc3JjID0gdmFsdWU7XG4gICAgICAgIGlmKHZhbHVlKXtcbiAgICAgICAgICAgIG93bmVyLmxvYWRJbWFnZUZyb21Tb3VyY2UoW3RoaXNdLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTb3VyY2Uob3duZXIsIHByb3BlcnR5KXtcbiAgICAgICAgcmV0dXJuIG93bmVyLl9zcmM7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgfVxuXG4gICAgZ2V0IGlzU3ZnKCl7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcIm1pbWVUeXBlXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYoIW1pbWVUeXBlKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW1lVHlwZS5zdGFydHNXaXRoKCdpbWFnZS9zdmcnKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEltYWdlLFxuICAgIEltYWdlIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFBhcnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgcmVwcmVzZW50IHRoZSBwcm90b3R5cGUgb2JqZWN0IGZvciBhbGxcbiAqIFNpbXBsZVRhbGsgcGFydHMuXG4gKi9cbmltcG9ydCB7XG4gICAgaWRNYWtlcixcbiAgICBpc1ZhbGlkSWRcbn0gZnJvbSAnLi4vdXRpbHMvaWQuanMnO1xuaW1wb3J0IGVycm9ySGFuZGxlciBmcm9tICcuLi91dGlscy9lcnJvckhhbmRsZXIuanMnO1xuaW1wb3J0IHtcbiAgICBQYXJ0UHJvcGVydGllcyxcbiAgICBCYXNpY1Byb3BlcnR5LFxuICAgIER5bmFtaWNQcm9wZXJ0eVxufSBmcm9tICcuLi9wcm9wZXJ0aWVzL1BhcnRQcm9wZXJ0aWVzLmpzJztcblxuaW1wb3J0IHtBY3RpdmF0aW9uQ29udGV4dH0gZnJvbSAnLi4vRXhlY3V0aW9uU3RhY2suanMnO1xuXG5cbmNsYXNzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGFuT3duZXJQYXJ0LCBuYW1lLCBkZXNlcmlhbGl6aW5nPWZhbHNlKXtcblxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgLy8gQW4gYXJyYXkgb2YgY2hpbGQgcGFydHNcbiAgICAgICAgdGhpcy5zdWJwYXJ0cyA9IFtdO1xuICAgICAgICAvLyBhIGxpc3Qgb2YgYWxsIGFjY2VwdGVkIHN1YnBhcnRzIGJ5IHR5cGVcbiAgICAgICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIG51bGwgYW5kIGVhY2ggUGFydCBzdWJjbGNhc3Mgc2hvdWxkXG4gICAgICAgIC8vIHNwZWNpZnkgaWYgb3RoZXJ3aXNlXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzID0gbmV3IFBhcnRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuX293bmVyID0gYW5Pd25lclBhcnQ7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9wcml2YXRlQ29tbWFuZEhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0U2VtYW50aWNzID0ge307XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5U3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3ZpZXdTdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaXNQYXJ0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BlcnRpZXMgPSB0aGlzLnNldHVwUHJvcGVydGllcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVQcm9wZXJ0aWVzID0gdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuYWRkUGFydCA9IHRoaXMuYWRkUGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVBhcnQgPSB0aGlzLnJlbW92ZVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hY2NlcHRzU3VicGFydCA9IHRoaXMuYWNjZXB0c1N1YnBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIgPSB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlciA9IHRoaXMucmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0RnVuY0hhbmRsZXIgPSB0aGlzLnNldEZ1bmNIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUNtZCA9IHRoaXMucmVjZWl2ZUNtZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVGdW5jID0gdGhpcy5yZWNlaXZlRnVuYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVFcnJvciA9IHRoaXMucmVjZWl2ZUVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZU1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVNZXNzYWdlID0gdGhpcy5kZWxlZ2F0ZU1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IHRoaXMuc2VuZE1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eVN1YnNjcmliZXIgPSB0aGlzLmFkZFByb3BlcnR5U3Vic2NyaWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5U3Vic2NyaWJlciA9IHRoaXMucmVtb3ZlUHJvcGVydHlTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkVmlld1N1YnNjcmliZXIgPSB0aGlzLmFkZFZpZXdTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlVmlld1N1YnNjcmliZXIgPSB0aGlzLnJlbW92ZVZpZXdTdWJzY3JpYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gdGhpcy5zZXJpYWxpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b0pTT04gPSB0aGlzLnRvSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFByb3BzRnJvbURlc2VyaWFsaXplciA9IHRoaXMuc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmluZEFuY2VzdG9yT2ZUeXBlID0gdGhpcy5maW5kQW5jZXN0b3JPZlR5cGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuRWRpdG9yQ21kSGFuZGxlciA9IHRoaXMub3BlbkVkaXRvckNtZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvckNtZEhhbmRsZXIgPSB0aGlzLmNsb3NlRWRpdG9yQ21kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvcHlDbWRIYW5kbGVyID0gdGhpcy5jb3B5Q21kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhc3RlQ21kSGFuZGxlciA9IHRoaXMucGFzdGVDbWRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNTdWJwYXJ0T2ZDdXJyZW50Q2FyZCA9IHRoaXMuaXNTdWJwYXJ0T2ZDdXJyZW50Q2FyZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzU3VicGFydE9mQ3VycmVudFN0YWNrID0gdGhpcy5pc1N1YnBhcnRPZkN1cnJlbnRTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE93bmVyQnJhbmNoID0gdGhpcy5nZXRPd25lckJyYW5jaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0U3RlcHBpbmcgPSB0aGlzLnN0YXJ0U3RlcHBpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdG9wU3RlcHBpbmcgPSB0aGlzLnN0b3BTdGVwcGluZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRhcmdldFByb3AgPSB0aGlzLnNldFRhcmdldFByb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVN1YnBhcnRVcCA9IHRoaXMubW92ZVN1YnBhcnRVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vdmVTdWJwYXJ0RG93biA9IHRoaXMubW92ZVN1YnBhcnREb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubW92ZVN1YnBhcnRUb0ZpcnN0ID0gdGhpcy5tb3ZlU3VicGFydFRvRmlyc3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlU3VicGFydFRvTGFzdCA9IHRoaXMubW92ZVN1YnBhcnRUb0xhc3QuYmluZCh0aGlzKTtcblxuXG5cbiAgICAgICAgLy8gRmluYWxseSwgd2UgZmluaXNoIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgLy8gY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm9wZW5FZGl0b3JcIiwgdGhpcy5vcGVuRWRpdG9yQ21kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiY2xvc2VFZGl0b3JcIiwgdGhpcy5jbG9zZUVkaXRvckNtZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcInNldFRhcmdldFRvXCIsIHRoaXMuc2V0VGFyZ2V0UHJvcCk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwiY29weVwiLCB0aGlzLmNvcHlDbWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlQ21kSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVVcFwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnRVcCh0aGlzKTt9KTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJtb3ZlRG93blwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnREb3duKHRoaXMpO30pO1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0ZpcnN0XCIsICgpID0+IHt0aGlzLl9vd25lci5tb3ZlU3VicGFydFRvRmlyc3QodGhpcyk7fSk7XG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVRvTGFzdFwiLCAoKSA9PiB7dGhpcy5fb3duZXIubW92ZVN1YnBhcnRUb0xhc3QodGhpcyk7fSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZ2V0dGVyIHRvIGdldCB0aGUgaWRcbiAgICAvLyBmcm9tIHRoZSBwYXJ0UHJvcGVydGllc1xuICAgIGdldCBpZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsICdpZCcpO1xuICAgIH1cblxuICAgIHNldCBpZCh2YWwpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsICdpZCcsIHZhbCk7XG4gICAgfVxuXG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgbmFtZXMgb2YgYWxsIG9mIG15IGFuZCBteSBhbmNlc3RvcnMnIGhhbmRsZXJzXG4gICAgLy8gZm9yIHRoZSBtb21lbnQgdGhpcyBpcyBqdXN0IG5hbWVzLCB0eXBlLCBpZCBhbmQgd2hldGhlciB0aGUgaGFuZGxlciBvdmVycmlkZXNcbiAgICAvLyBhbiBvd25lcidzLCBidXQgY291bGQgYmUgcmljaGVyIGluZm8sIHN1Y2ggYXMgYXJndW1lbnRzLCBkb2N1bWVudGF0aW9uIGV0Y1xuICAgIGdldCBjb21tYW5kSGFuZGxlclJlZ2lzdHJ5KCl7XG4gICAgICAgIGxldCBoYW5kbGVyc0luZm8gPSB7fTtcbiAgICAgICAgbGV0IG93bmVyQnJhbmNoID0gdGhpcy5nZXRPd25lckJyYW5jaCgpO1xuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDw9IG93bmVyQnJhbmNoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gb3duZXJCcmFuY2hbb3duZXJCcmFuY2gubGVuZ3RoIC0gaV07XG4gICAgICAgICAgICBsZXQgcGFydFR5cGUgPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgICBpZihwYXJ0LmlkID09PSAtMSl7XG4gICAgICAgICAgICAgICAgcGFydFR5cGUgPSBcIlN5c3RlbVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTeXN0ZW0gZG9lc24ndCBoYXZlIHByaXZhdGUgY29tbWFuZCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcnQuX3ByaXZhdGVDb21tYW5kSGFuZGxlcnMpLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhhbmRsZXJzSW5mb1toXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNJbmZvW2hdID0ge3BhcnRJZDogcGFydC5pZCwgcGFydFR5cGU6IHBhcnRUeXBlLCBvdmVycmlkZTogb3ZlcnJpZGUsIHByaXZhdGU6IHRydWV9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFydC5fY29tbWFuZEhhbmRsZXJzKS5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoaGFuZGxlcnNJbmZvW2hdKXtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVyc0luZm9baF0gPSB7cGFydElkOiBwYXJ0LmlkLCBwYXJ0VHlwZTogcGFydFR5cGUsIG92ZXJyaWRlOiBvdmVycmlkZSwgcHJpdmF0ZTogZmFsc2V9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzSW5mbztcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIHRoZSB0aGlzLnBhcnQgLT4gU3lzdGVtIGJyYW5jaCBieSBwYXJ0IGlkXG4gICAgZ2V0T3duZXJCcmFuY2goYnJhbmNoKXtcbiAgICAgICAgaWYoIWJyYW5jaCl7XG4gICAgICAgICAgICBicmFuY2ggPSBbdGhpc107XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy50eXBlID09PSBcIndvcmxkXCIpe1xuICAgICAgICAgICAgYnJhbmNoLnB1c2god2luZG93LlN5c3RlbSk7XG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJhbmNoLnB1c2godGhpcy5fb3duZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fb3duZXIuZ2V0T3duZXJCcmFuY2goYnJhbmNoKTtcbiAgICB9XG5cbiAgICAvLyBDb25maWd1cmVzIHRoZSBzcGVjaWZpYyBwcm9wZXJ0aWVzIHRoYXQgdGhlXG4gICAgLy8gZ2l2ZW4gcGFydCBjYW4gZXhwZWN0LCBhbG9uZyB3aXRoIGFueSBkZWZhdWx0XG4gICAgLy8gdmFsdWVzLlxuICAgIC8vIERlc2NlbmRhbnQgUGFydHMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kXG4gICAgLy8gaW4gdGhlaXIgb3duIGNvbnN0cnVjdG9yIGFmdGVyIGNhbGxpbmcgc3VwZXIsXG4gICAgLy8gc28gdGhhdCB0aGV5IGdldCB0aGUgcGFyZW50J3MgZ2VuZXJhbCBwcm9wZXJ0aWVzXG4gICAgLy8gdG9vLlxuICAgIHNldHVwUHJvcGVydGllcygpe1xuICAgICAgICAvLyBIZXJlLCB3ZSBzZXQgdXAgcHJvcGVydGllcyBjb21tb25cbiAgICAgICAgLy8gdG8gQUxMIFBhcnRzIGluIHRoZSBzeXN0ZW0uXG4gICAgICAgIGxldCBiYXNpY1Byb3BzID0gW1xuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ3RhcmdldCcsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnY29udGVudHMnLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnd2FudHMtbW92ZScsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgICAgIGlkTWFrZXIubmV3KClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXcgQmFzaWNQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgYE5ldyAke3RoaXMudHlwZX1gXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV3IEJhc2ljUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgJ3JlY3RhbmdsZScsXG4gICAgICAgICAgICAgICAgXCIwLCAwLCAwLCAwXCIsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBbJ3JlY3QnXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIG51bGwgLy8gRm9yIG5vd1xuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICAgICAgLy8gY3NzIChyZWFsbHkgSlMgc3R5bGUpIGtleS12YWx1ZXNcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdjc3NTdHlsZScsXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gY3NzIChyZWFsbHkgSlMgc3R5bGUpIGtleS12YWx1ZXNcbiAgICAgICAgICAgIG5ldyBCYXNpY1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICdjc3NUZXh0U3R5bGUnLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgICBiYXNpY1Byb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLmFkZFByb3BlcnR5KHByb3ApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGUgaW5kZXggbnVtYmVyIG9mIHRoZSBwYXJ0IGluIHBhcnQuX293bmVyLnN1YnBhcnRcbiAgICAgICAgLy8gYXJyYXkuIE5vdGU6IHRoaXMgaXMgMS1pbmRleGVkXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgIG51bGwsIC8vIG5vIHNldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICBpZihwcm9wT3duZXIudHlwZSA9PSBcIndvcmxkXCIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BPd25lci5fb3duZXIuc3VicGFydHMuaW5kZXhPZihwcm9wT3duZXIpICsgMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlIC8vIHJlYWRvbmx5XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICd0YXJnZXQnLFxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWwpe1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgdGFyZ2V0IGlzIGEgbm9uLUlEXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gaXNWYWxpZElkKHZhbCk7XG4gICAgICAgICAgICAgICAgaWYoaWQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhbiBJRCBpbnNlcnQgXCJwYXJ0XCIgc2luY2Ugb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdyYW1tYXIgZG9lc24ndCBoYW5kbGUgSUQgd2l0aG91dCBzeXN0ZW0gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZWZpeGVzXG4gICAgICAgICAgICAgICAgICAgIHByb3BPYmplY3QuX3ZhbHVlID0gYHBhcnQgaWQgJHt2YWx9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wT2JqZWN0Ll92YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICApLFxuXG4gICAgICAgIC8vIEN1c3RvbSBQcm9wZXJ0aWVzIHN0b3JlIHByb3BzIGRlZmluZWQgd2l0aGluIHRoZVxuICAgICAgICAvLyBTVCBlbnZpcm9ubWVudFxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0N1c3RvbVByb3AoXG4gICAgICAgICksXG5cbiAgICAgICAgLy8gU3RlcHBpbmcgcmVsYXRlZCBwcm9wc1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICAgICAvLyBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlblxuICAgICAgICAgICAgLy8gc2VuZHMgb2YgdGhlIHN0ZXAgY29tbWFuZCBpZiB0aGVcbiAgICAgICAgICAgIC8vIHN0ZXBwaW5nIHByb3BlcnR5IGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAnc3RlcFRpbWUnLFxuICAgICAgICAgICAgLy8gRHluYW1pYyBzZXR0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsdWUpe1xuICAgICAgICAgICAgICAgIGlmKHByb3BPd25lci5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJydXB0IHRoZSBjdXJyZW50IGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXN0YXJ0IHdpdGggbmV3IHN0ZXBUaW1lXG4gICAgICAgICAgICAgICAgICAgIHByb3BPd25lci5zdG9wU3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnN0YXJ0U3RlcHBpbmcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIER5bmFtaWMgZ2V0dGVyXG4gICAgICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZSwgLy8gY2FuIHJlYWQgYW5kIHdyaXRlXG4gICAgICAgICAgICA1MDAgLy8gRGVmYXVsdCB0byBoYWxmIGEgc2Vjb25kXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgICAgICdzdGVwcGluZycsXG4gICAgICAgICAgICAvLyBEeW5hbWljIHNldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWx1ZSl7XG4gICAgICAgICAgICAgICAgaWYodmFsdWUgPT09IGZhbHNlICYmIHByb3BPd25lci5pc1N0ZXBwaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnN0b3BTdGVwcGluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PT0gdHJ1ZSAmJiAhcHJvcE93bmVyLmlzU3RlcHBpbmcpe1xuICAgICAgICAgICAgICAgICAgICBwcm9wT3duZXIuc3RhcnRTdGVwcGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBEeW5hbWljIGdldHRlclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW50ZXJ2YWxJZCBpcyBzZXQsIHRoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgUGFydCBpcyBjdXJyZW50bHkgc3RlcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE93bmVyLmlzU3RlcHBpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgfVxuXG4gICAgLy8gVG8gYmUgY2FsbGVkIGluIGVhY2ggc3ViLWNsYXNzIHRoYXQgaGFzIFN0eWxlUHJvcGVydGllc1xuICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgc3R5bGUgcHJvcHMgYXJlIGNvbmZpZ3VyZWRcbiAgICBzZXR1cFN0eWxlUHJvcGVydGllcygpe1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLl9wcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmKHByb3AuY29uc3RydWN0b3IubmFtZSA9PT0gXCJTdHlsZVByb3BlcnR5XCIpe1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHZhbHVlIG9uIGl0c2VsZiBlbnN1cmVzIHRoYXQgdGhlIGNzc1N0eWxlXG4gICAgICAgICAgICAgICAgLy8gQmFzaWNQcm9wZXJ0eSBpcyB1cGRhdGVkIHdpdGggdGhlIGFwcHJvcHJpYXRlIHN0eWxlclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnNpb24gY3NzIGtleS12YWxcbiAgICAgICAgICAgICAgICBwcm9wLnNldFZhbHVlKHRoaXMsIHByb3AuX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFN1YnBhcnQgQWNjZXNzICoqL1xuICAgIC8qKlxuICAgICAqIEVhY2ggc3ViY2xhc3Mgd2lsbCBpbXBsZW1lbnQgaXRzIG93biBzZXQgb2YgY2hlY2tzLFxuICAgICAqIGFuZCB0aHJvdyBhbiBhcHByb3ByaXRlIGVycm9yIGlmIHRoZSBzdWJwYXJ0IHR5cGUgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBhY2NlcHRzU3VicGFydChhUGFydFR5cGUpe1xuICAgICAgICBpZiAodGhpcy5hY2NlcHRlZFN1YnBhcnRUeXBlc1swXSA9PT0gXCIqXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMuaW5jbHVkZXMoYVBhcnRUeXBlLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwYXJ0IHRvIHRoaXMgcGFydCdzIHN1YnBhcnRzXG4gICAgICogY29sbGVjdGlvbiwgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICAgKiBJdCB3aWxsIGFsc28gc2V0IHRoZSBvd25lciBvZiB0aGVcbiAgICAgKiBhZGRlZCBwYXJ0IHRvIGJlIHRoaXMgcGFydC5cbiAgICAgKi9cbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgaWYoIXRoaXMuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gZG9lcyBub3QgYWNjZXB0IHN1YnBhcnRzIG9mIHR5cGUgJHthUGFydC50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYoZm91bmQgPCAwKXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydHMucHVzaChhUGFydCk7XG4gICAgICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcGFydCBmcm9tIHRoaXNcbiAgICAgKiBwYXJ0J3MgbGlzdCBvZiBzdWJwYXJ0cyAoaWYgcHJlc2VudCkuXG4gICAgICogSXQgd2lsbCBhbHNvIHVuc2V0IHRoZSBvd25lciBvZiB0aGVcbiAgICAgKiBnaXZlbiBwYXJ0LlxuICAgICAqL1xuICAgIHJlbW92ZVBhcnQoYVBhcnQpe1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYocGFydEluZGV4ID49IDApe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UocGFydEluZGV4LCAxKTtcbiAgICAgICAgICAgIGFQYXJ0Ll9vd25lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgdGhlIFBhcnQgaW5zdGFuY2UgaXMgYSBzdWJwYXJ0IG9mIHRoZSBjdXJyZW50XG4gICAgICogQ2FyZC5cbiAgICAgKi9cbiAgICBpc1N1YnBhcnRPZkN1cnJlbnRDYXJkKCl7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBQYXJ0IGluc3RhbmNlIGlzIGEgc3VicGFydCBvZiB0aGUgY3VycmVudFxuICAgICAqIFN0YWNrLlxuICAgICAqL1xuICAgIGlzU3VicGFydE9mQ3VycmVudFN0YWNrKCl7XG4gICAgfVxuXG4gICAgLyoqIExvZ2dpbmcgYW5kIFJlcG9ydGluZyAqKi9cbiAgICBzaG91bGRCZUltcGxlbWVudGVkKGZ1bmN0aW9uTmFtZSl7XG4gICAgICAgIGxldCBtc2cgPSBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHNob3VsZCBpbXBsZW1lbnQgJHtmdW5jdGlvbk5hbWV9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgLyoqIE1lc3NhZ2UgSGFuZGxpbmcgYW5kIERlbGVnYXRpb24gKiovXG4gICAgZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICBhTWVzc2FnZSxcbiAgICAgICAgICAgIHRoaXMuX293bmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHRhcmdldCl7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLnNlbmRNZXNzYWdlKGFNZXNzYWdlLCB0aGlzLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIHJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgUGFydHMgd2lsbCBvbmx5IGhhbmRsZVxuICAgICAgICAvLyBtZXNzYWdlcyBvZiB0eXBlICdjb21tYW5kJyBhbmQgJ2Z1bmN0aW9uJ1xuICAgICAgICBzd2l0Y2goYU1lc3NhZ2UudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlQ21kKGFNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVGdW5jKGFNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVFcnJvcihhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNlaXZlRXJyb3IoYU1lc3NhZ2Upe1xuICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyLmhhbmRsZShhTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmVjZWl2ZUNtZChhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fY29tbWFuZEhhbmRsZXJzW2FNZXNzYWdlLmNvbW1hbmROYW1lXTtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIFBhcnQgaGFzIGEgaGFuZGxlciBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBnaXZlbiBjb21tYW5kLCB3ZSBydW4gaXQuXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGxhdGUtYmluZCB0aGUgY3VycmVudCBwYXJ0XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSBhcyB0aGUgJ3RoaXMnIGNvbnRleHQgZm9yXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlclxuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByaXZhdGVIYW5kbGVyID0gdGhpcy5fcHJpdmF0ZUNvbW1hbmRIYW5kbGVyc1thTWVzc2FnZS5jb21tYW5kTmFtZV07XG4gICAgICAgIGlmKHByaXZhdGVIYW5kbGVyKXtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgUGFydCBoYXMgYSBoYW5kbGVyIGZvclxuICAgICAgICAgICAgLy8gdGhlIGdpdmVuIGNvbW1hbmQsIHdlIHJ1biBpdC5cbiAgICAgICAgICAgIC8vIFdlIGFsc28gbGF0ZS1iaW5kIHRoZSBjdXJyZW50IHBhcnRcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIGFzIHRoZSAndGhpcycgY29udGV4dCBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICBsZXQgYm91bmRIYW5kbGVyID0gcHJpdmF0ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9uID0gbmV3IEFjdGl2YXRpb25Db250ZXh0KFxuICAgICAgICAgICAgICAgIGFNZXNzYWdlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgYm91bmRIYW5kbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5leGVjdXRpb25TdGFjay5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJvdW5kSGFuZGxlcihhTWVzc2FnZS5zZW5kZXJzLCAuLi5hTWVzc2FnZS5hcmdzKTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZXhlY3V0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBoYXZlIG5vIGhhbmRsZXIgZm9yXG4gICAgICAgIC8vIGl0LiBVbmxlc3MgdGhlIG1lc3NhZ2UgaW5kaWNhdGVzIHNob3VsZE5vdERlbGVnYXRlXG4gICAgICAgIC8vIHdlIGRlbGVnYXRlIGFsb25nIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGRlbGVnYXRpb24gY2hhaW4uIEl0IGlzIHVwXG4gICAgICAgIC8vIHRvIFBhcnRzIHRvIHByb3Blcmx5IGltcGxlbWVudCBkZWxlZ2F0aW9uXG4gICAgICAgIC8vIGZvciB0aGVtc2VsdmVzIVxuICAgICAgICBpZihhTWVzc2FnZS5zaG91bGROb3REZWxlZ2F0ZSl7XG4gICAgICAgICAgICByZXR1cm4gYU1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZWNlaXZlRnVuYyhhTWVzc2FnZSl7XG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5fZnVuY3Rpb25IYW5kbGVyc1thTWVzc2FnZS5mdW5jdGlvbk5hbWVdO1xuXG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgICAgbGV0IGJvdW5kSGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZEhhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoY29tbWFuZE5hbWUsIGhhbmRsZXIpe1xuICAgICAgICB0aGlzLl9wcml2YXRlQ29tbWFuZEhhbmRsZXJzW2NvbW1hbmROYW1lXSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgcmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyKGNvbW1hbmROYW1lKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ByaXZhdGVDb21tYW5kSGFuZGxlcnNbY29tbWFuZE5hbWVdO1xuICAgIH1cblxuICAgIHNldEZ1bmNIYW5kbGVyKGZ1bmNOYW1lLCBoYW5kbGVyKXtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25IYW5kbGVyc1tmdW5jTmFtZV0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIC8qKiBDb21tYW5kIEhhbmRsZXJzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgQ29tbWFuZCBoYW5kbGVycyB3aGljaCBhcmUgaW52b2tlZCBhdCB0aGUgUGFydCBsZXZlbFxuICAgICAgICB3aGljaCBhcmUgbm90IGltbWVkaWF0ZWx5IGRlbGVnYWVkIHRvIHRoZSBQYXJ0Ll9vd25lclxuICAgICoqL1xuXG4gICAgb3BlbkVkaXRvckNtZEhhbmRsZXIoKXtcbiAgICAgICAgbGV0IGVkaXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LWVkaXRvcicpO1xuICAgICAgICBlZGl0b3IucmVuZGVyKHRoaXMpO1xuICAgICAgICBpZighZWRpdG9yLmlzT3Blbil7XG4gICAgICAgICAgICBlZGl0b3Iub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VFZGl0b3JDbWRIYW5kbGVyKCl7XG4gICAgICAgIGxldCBlZGl0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC1lZGl0b3Iub3BlbicpO1xuICAgICAgICBpZihlZGl0b3Ipe1xuICAgICAgICAgICAgZWRpdG9yLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUYXJnZXRQcm9wKHNlbmRlcnMsIC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYXJncy5qb2luKFwiIFwiKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgY29weUNtZEhhbmRsZXIoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29weVBhcnQodGhpcyk7XG4gICAgfVxuXG4gICAgcGFzdGVDbWRIYW5kbGVyKCl7XG4gICAgICAgIGlmKCF3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5pc0VtcHR5KXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29udGVudHNbMF07XG4gICAgICAgICAgICBpZihpdGVtLnR5cGUgPT0gJ3NpbXBsZXRhbGsvanNvbicgJiYgdGhpcy5hY2NlcHRzU3VicGFydChpdGVtLnBhcnRUeXBlKSl7XG4gICAgICAgICAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQucGFzdGVDb250ZW50c0ludG8odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlKHNlbmRlcnMsIG1vdmVtZW50WCwgbW92ZW1lbnRZKXtcbiAgICAgICAgaWYoIXRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcIndhbnRzLW1vdmVcIikpe1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBhcnQgJHt0aGlzLmlkfSB0cnlpbmcgdG8gbW92ZSB3aXRoICd3YW50cy1tb3ZlJyBwcm9wZXJ0eSBmYWxzZWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJ0b3BcIik7XG4gICAgICAgIHRvcCArPSBtb3ZlbWVudFk7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInRvcFwiLCB0b3ApO1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcImxlZnRcIik7XG4gICAgICAgIGxlZnQgKz0gbW92ZW1lbnRYO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJsZWZ0XCIsIGxlZnQpO1xuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgdGhpcy5zdWJwYXJ0cy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRVcChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gMCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdGU6IG1vdmVTdWJwYXJ0VG9GaXJzdCBtZWFucyBtb3ZlIHRvIGZpcnN0IGluIHRoZSB2aWV3XG4gICAgLy8gaS5lLiBsYXN0IGFzIGEgc3ViYXBydFxuICAgIG1vdmVTdWJwYXJ0VG9GaXJzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0xhc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgLyoqIFByb3BlcnR5IFN1YnNjcmliZXJzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBPYmplY3RzIGFkZGVkIGFzIHByb3BlcnR5IHN1YnNjcmliZXJzXG4gICAgICAgIHdpbGwgYmUgJ25vdGlmaWVkJyB3aGVuZXZlciBvbmUgb2YgdGhpc1xuICAgICAgICBQYXJ0J3MgcHJvcGVydGllcyBjaGFuZ2VzXG4gICAgKiovXG4gICAgYWRkUHJvcGVydHlTdWJzY3JpYmVyKGFuT2JqZWN0KXtcbiAgICAgICAgdGhpcy5fcHJvcGVydHlTdWJzY3JpYmVycy5hZGQoYW5PYmplY3QpO1xuICAgIH1cblxuICAgIHJlbW92ZVByb3BlcnR5U3Vic2NyaWJlcihhbk9iamVjdCl7XG4gICAgICAgIHRoaXMuX3Byb3BlcnR5U3Vic2NyaWJlcnMuZGVsZXRlKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eUNoYW5nZWQocHJvcGVydHlOYW1lLCBuZXdWYWx1ZSl7XG4gICAgICAgIGxldCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3Byb3BlcnR5Q2hhbmdlZCcsXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIHBhcnRJZDogdGhpcy5pZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eVN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2UsIHN1YnNjcmliZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogVmlldyBTdWJzY3JpYmVyc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgT2JqZWN0cyBhZGRlZCBhcyB2aWV3IHN1YnNjcmliZXJzXG4gICAgICAgIHdpbGwgYmUgJ25vdGlmaWVkJyB3aGVuZXZlciB0aGlzIFBhcnRcbiAgICAgICAgaW5jdXJycyBhIHZpZXcgY2hhbmdlIChhZGQsIGRlbGV0ZSBzdWJwYXJ0cywgcmVvcmRlciBldGMpXG4gICAgKiovXG4gICAgYWRkVmlld1N1YnNjcmliZXIoYW5PYmplY3Qpe1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMuYWRkKGFuT2JqZWN0KTtcbiAgICB9XG5cbiAgICByZW1vdmVWaWV3U3Vic2NyaWJlcihhbk9iamVjdCl7XG4gICAgICAgIHRoaXMuX3ZpZXdTdWJzY3JpYmVycy5kZWxldGUoYW5PYmplY3QpO1xuICAgIH1cblxuICAgIHZpZXdDaGFuZ2VkKGNoYW5nZU5hbWUsIC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWV3Q2hhbmdlZCcsXG4gICAgICAgICAgICBjaGFuZ2VOYW1lOiBjaGFuZ2VOYW1lLFxuICAgICAgICAgICAgcGFydElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl92aWV3U3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobWVzc2FnZSwgc3Vic2NyaWJlcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN1YnBhcnRPcmRlckNoYW5nZWQoaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpe1xuICAgICAgICBsZXQgc3VicGFydCA9IHRoaXMuc3VicGFydHMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSlbMF07XG4gICAgICAgIHRoaXMuc3VicGFydHMuc3BsaWNlKG5ld0luZGV4LCAwLCBzdWJwYXJ0KTtcbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlZChcInN1YnBhcnQtb3JkZXJcIiwgaWQsIGN1cnJlbnRJbmRleCwgbmV3SW5kZXgpO1xuICAgIH1cblxuICAgIHN0YXJ0U3RlcHBpbmcoKXtcbiAgICAgICAgaWYodGhpcy5fc3RlcEludGVydmFsSWQpe1xuICAgICAgICAgICAgdGhpcy5zdG9wU3RlcHBpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RlcFRpbWUgPSB0aGlzLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ3N0ZXBUaW1lJ1xuICAgICAgICApO1xuICAgICAgICBpZihzdGVwVGltZSA+IDApe1xuICAgICAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdzdGVwJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHN0ZXBUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BTdGVwcGluZygpe1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3N0ZXBJbnRlcnZhbElkKTtcbiAgICAgICAgdGhpcy5fc3RlcEludGVydmFsSWQgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBpc1N0ZXBwaW5nKCl7XG4gICAgICAgIC8vIFdlIGtub3cgdGhlIFBhcnQgaXMgY3VycmVudGx5IHN0ZXBwaW5nXG4gICAgICAgIC8vIG9mIHRoZSBzdG9yZWQgaW50ZXJ2YWxJZCBpcyBzZXQgdG9cbiAgICAgICAgLy8gc29tZXRoaW5nIGJlc2lkZXMgbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcEludGVydmFsSWQgIT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgUGFydCdzIHN0YXRlIGFzIEpTT04uXG4gICAgICogQnkgZGVmYXVsdCwgd2UgZG8gbm90IHNlcmlhbGl6ZSBzcGVjaWZpY1xuICAgICAqIFBhcnRDb2xsZWN0aW9uIGluZm9ybWF0aW9uIChyZWN1cnNpdmVseSksXG4gICAgICogYW5kIG9ubHkgaW5jbHVkZSBiYXNpY3MgaW5jbHVkaW5nIHRoZSBjdXJyZW50XG4gICAgICogc3RhdGUgb2YgYWxsIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCl7XG4gICAgICAgIGxldCBvd25lcklkID0gbnVsbDtcbiAgICAgICAgaWYodGhpcy5fb3duZXIpe1xuICAgICAgICAgICAgb3duZXJJZCA9IHRoaXMuX293bmVyLmlkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgc3VicGFydHM6IHRoaXMuc3VicGFydHMubWFwKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LmlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvd25lcklkOiBvd25lcklkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuX3Byb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcC5nZXRWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcHJvcGVydGllcyBhbmQgb3RoZXJcbiAgICAgKiBhdHRyaWJ1dGVzIG9mIHRoaXMgUGFydCBtb2RlbFxuICAgICAqIGZyb20gYSBkZXNlcmlhbGl6ZWQgSlNPTiBvYmplY3QuXG4gICAgICovXG4gICAgc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyKGluY29taW5nUHJvcHMsIGRlc2VyaWFsaXplcil7XG4gICAgICAgIE9iamVjdC5rZXlzKGluY29taW5nUHJvcHMpLmZvckVhY2gocHJvcE5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gdGhpcy5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZighcHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWUgb2xkIG9yIGludmFsaWQgcHJvcGVydHkgaXNcbiAgICAgICAgICAgICAgICAvLyBwcmVzZW50IGluIHRoZSBkZXNlcmlhbGl6YXRpb24sIHNpbXBseSBwcm92aWRlXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nIGFuZCB0aGVuIHNraXAgdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXNlcmlhbGl6ZWQgcHJvcGVydHkgXCIke3Byb3BOYW1lfVwiIGlzIG5vdCBhIHZhbGlkIHByb3BlcnR5IG5hbWUgZm9yICR7dGhpcy50eXBlfSAoaWQgJHt0aGlzLmlkfSkgYW5kIHdpbGwgYmUgaWdub3JlZGApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHByb3BOYW1lID09IFwiY3VzdG9tLXByb3BlcnRpZXNcIil7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIHByb3BlcnRpZXMgYXJlIHNlcmlhbGl6ZWQgYXMgYW4gb2JqZWN0IGxpa2Ugb3RoZXIgcHJvcHNcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byBjcmVhdGUgcHJvcGVydGllcyBmcm9tIHRoZXNlIGFuZCBzZXQgdGhlaXIgcmVzcGVjdGl2ZVxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcy4gVGhlbiB3ZSBuZWVkIHRvIHNldCB0aGUgdmFsdWUgb2YgXCJjdXN0b20tcHJvcGVydGllc1wiIHByb3BcbiAgICAgICAgICAgICAgICAvLyBpdHNlbGYgdG8gYmUgdGhlIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGVzZVxuICAgICAgICAgICAgICAgIGxldCBjdXN0b21Qcm9wc0RhdGEgPSBpbmNvbWluZ1Byb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q3VzdG9tUHJvcHNPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKGN1c3RvbVByb3BzRGF0YSkuZm9yRWFjaCgocHJvcERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgQmFzaWNQcm9wZXJ0eShwcm9wRGF0YS5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcC5zZXRWYWx1ZSh0aGlzLCBwcm9wRGF0YS5fdmFsdWUsIGZhbHNlKTsgLy8gbm8gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3VzdG9tUHJvcHNPYmplY3RbcHJvcERhdGEubmFtZV0gPSBuZXdQcm9wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFZhbHVlKHRoaXMsIG5ld0N1c3RvbVByb3BzT2JqZWN0LCBmYWxzZSk7IC8vIG5vIG5lZWQgdG8gbm90aWZ5XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXByb3BlcnR5LnJlYWRPbmx5KXtcbiAgICAgICAgICAgICAgICAvLyBMYXN0IGFyZyBpcyBmYWxzZSwgd2hpY2ggdGVsbHMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbm90IHRvIG5vdGlmeSBpdHMgb3duZXIncyBzdWJzY3JpYmVycyBvZlxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IGNoYW5nZXMuIFdlIGRvbid0IG5lZWQgdGhhdCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gZGVzZXJpYWxpemluZ1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFZhbHVlKHRoaXMsIGluY29taW5nUHJvcHNbcHJvcE5hbWVdLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvSlNPTigpe1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9XG5cbiAgICBmaW5kQW5jZXN0b3JPZlR5cGUoYVBhcnRUeXBlKXtcbiAgICAgICAgbGV0IG93bmVyID0gdGhpcy5fb3duZXI7XG4gICAgICAgIHdoaWxlKG93bmVyKXtcbiAgICAgICAgICAgIGlmKG93bmVyLnR5cGUgPT0gYVBhcnRUeXBlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvd25lciA9IG93bmVyLl9vd25lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnQsXG4gICAgUGFydCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL1BhcnQuanMnO1xuaW1wb3J0IHtcbiAgICBhZGRCYXNpY1N0eWxlUHJvcHMsXG4gICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzLFxuICAgIGFkZFRleHRTdHlsZVByb3BzXG59IGZyb20gJy4uL3V0aWxzL3N0eWxlUHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIFJlc291cmNlIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIHNyYykge1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3JjID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgICdyZWFkeVN0YXRlJyxcbiAgICAgICAgICAgIFwibm90UmVhZHlcIlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgXCJwcmVyZXF1aXNpdGVcIixcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgICAgIFwicmVzb3VyY2VOYW1lXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBjb21tYW5kIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibG9hZFJlc291cmNlXCIsIHRoaXMubG9hZFJlc291cmNlKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJzZXRTb3VyY2VUb1wiLCB0aGlzLnNldFNvdXJjZVRvKTtcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlQ29tbWFuZEhhbmRsZXIoXCJnZXRcIiwgdGhpcy5nZXQpO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5sb2FkUmVzb3VyY2UgPSB0aGlzLmxvYWRSZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgc3JjIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGFkZEJhc2ljU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzKHRoaXMpO1xuICAgICAgICBhZGRUZXh0U3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGBib3JkZXItJHtzaWRlfS13aWR0aGAsXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdyZXNvdXJjZSc7XG4gICAgfVxuXG4gICAgbG9hZFJlc291cmNlKHNlbmRlcnMsIHJlc291cmNlTmFtZSl7XG4gICAgICAgIGlmKCF3aW5kb3cuU3lzdGVtLmF2YWlsYWJsZVJlc291cmNlcyB8fCAhd2luZG93LlN5c3RlbS5hdmFpbGFibGVSZXNvdXJjZXNbcmVzb3VyY2VOYW1lXSl7XG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGJlIGEgU1QgZXJyb3JcbiAgICAgICAgICAgIHRocm93IEVycm9yKGByZXNvdXJjZSAke3Jlc291cmNlTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHdpbmRvdy5TeXN0ZW0uYXZhaWxhYmxlUmVzb3VyY2VzW3Jlc291cmNlTmFtZV07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlc291cmNlTmFtZVwiLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICAvLyB3ZSBjYW4ndCBndWFyYW50ZWUgdGhlIHN0YXRlIG9mIGEgcmVzb3VyY2UgYW5kIHNvIGl0IHNob3VsZCBiZSByZS1zZXQgZXZlcnkgdGltZVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlVG8oc2VuZGVycywgc291cmNlVXJsKXtcbiAgICAgICAgaWYoIXRoaXMucmVzb3VyY2Upe1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBiZSBhIFNUIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgbm8gcmVzb3VyY2UgbG9hZGVkIGZvciByZXNvdXJjZSBwYXJ0IGlkICR7dGhpcy5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJzcmNcIiwgc291cmNlVXJsKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZS5sb2FkKHNvdXJjZVVybCk7XG4gICAgICAgIC8vIHdlIGNhbid0IGd1YXJhbnRlZSB0aGUgc3RhdGUgb2YgYSByZXNvdXJjZSBhbmQgc28gaXQgc2hvdWxkIGJlIHJlLXNldCBldmVyeSB0aW1lXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgIH1cblxuICAgIGdldChzZW5kZXJzLCAuLi5hcmdzKXtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVhZHlTdGF0ZVwiLCBcImZldGNoaW5nXCIpO1xuICAgICAgICBsZXQgcHJlcmVxdWlzaXRlID0gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicHJlcmVxdWlzaXRlXCIpO1xuICAgICAgICB0aGlzLnJlc291cmNlLmdldChwcmVyZXF1aXNpdGUsIC4uLmFyZ3MpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcywgXCJyZWFkeVN0YXRlXCIsIFwicmVhZHlcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJyZXNwb25kZWRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5pZCwgdGhpcy5yZXNvdXJjZS5uYW1lXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlYWR5U3RhdGVcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlc3BvbnNlXCIsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZXJyb3JlZFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmlkLCB0aGlzLnJlc291cmNlLm5hbWUsIGVycm9yLm1lc3NhZ2VdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0KCl7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcInJlYWR5U3RhdGVcIiwgXCJub3RSZWFkeVwiKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwicmVzcG9uc2VcIiwgbnVsbCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBSZXNvdXJjZSxcbiAgICBSZXNvdXJjZSBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTdGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSB0aGUgU3RhY2sgUGFydC5cbiAqIEkgcmVwcmVzZW50IGEgY29sbGVjdGlvbiBvZiBDYXJkIHBhcnRzLFxuICogYWxvbmcgd2l0aCBzb21lIGV4dHJhIGNvbmZpZ3VyYWJpbGl0eS5cbiAqL1xuaW1wb3J0IFBhcnQgZnJvbSAnLi9QYXJ0LmpzJztcbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZC5qcyc7XG5pbXBvcnQge1xuICAgIEJhc2ljUHJvcGVydHlcbn0gZnJvbSAnLi4vcHJvcGVydGllcy9QYXJ0UHJvcGVydGllcy5qcyc7XG5cbmNsYXNzIFN0YWNrIGV4dGVuZHMgUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIG5hbWUsIGRlc2VyaWFsaXppbmc9ZmFsc2Upe1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImNhcmRcIiwgXCJ3aW5kb3dcIiwgXCJidXR0b25cIiwgXCJhcmVhXCIsIFwiZmllbGRcIixcbiAgICAgICAgICAgIFwiZHJhd2luZ1wiLCBcImltYWdlXCIsIFwiYXVkaW9cIiwgXCJicm93c2VyXCJcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBTZXQgdXAgU3RhY2sgc3BlY2lmaWNcbiAgICAgICAgLy8gUGFydFByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnY2FudFBlZWsnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAncmVzaXphYmxlJyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cblxuICAgICAgICAvLyBXaWxsIGhvbGQgdGhlIGNhcmQtYmFzZWQgaW5kZXgsXG4gICAgICAgIC8vIHdoaWNoIGhlcmUgaXMgemVyby1pbmRleGVkLCBvZiB0aGVcbiAgICAgICAgLy8gY2FyZCB0aGF0IGlzIHRoZSBjdXJyZW50IGNhcmQgZm9yIHRoaXNcbiAgICAgICAgLy8gU3RhY2suXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgZ2VuZXJhbCBtZXRob2RzXG4gICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8gPSB0aGlzLnNlbmRPcGVuQ2FyZFRvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvID0gdGhpcy5zZW5kQ2xvc2VDYXJkVG8uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIHN0YWNrIG5hdmlnYXRpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLmdvVG9OZXh0Q2FyZCA9IHRoaXMuZ29Ub05leHRDYXJkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub1ByZXZDYXJkID0gdGhpcy5nb1RvUHJldkNhcmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvQ2FyZEJ5SWQgPSB0aGlzLmdvVG9DYXJkQnlJZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdvVG9OdGhDYXJkID0gdGhpcy5nb1RvTnRoQ2FyZC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdvVG9OZXh0Q2FyZCgpe1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoY2FyZHMubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBjdXJyZW50SWR4ID0gY2FyZHMuaW5kZXhPZihjdXJyZW50Q2FyZCk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCArIDE7XG4gICAgICAgIGlmKG5leHRJZHggPj0gY2FyZHMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHRJZHggPSAobmV4dElkeCAlIGNhcmRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHNbbmV4dElkeF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBuZXh0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50Q2FyZElkICE9IG5leHRDYXJkLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvKGN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8obmV4dENhcmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub0NhcmRCeUlkKGFuSWQpe1xuICAgICAgICBsZXQgY3VycmVudENhcmRJZCA9IHRoaXMuY3VycmVudENhcmRJZDtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkID0gdGhpcy5jdXJyZW50Q2FyZDtcbiAgICAgICAgbGV0IGNhcmRzID0gT2JqZWN0LnZhbHVlcyh3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZCkuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwiY2FyZFwiO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHMuZmluZChjYXJkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXJkLmlkID09IGFuSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZighbmV4dENhcmQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FyZCBpZDogJHthbklkfSBjYW50IGJlIGZvdW5kIHN0YWNrYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGNhcmQgaXMgbm90IG9uIHRoaXMgc3RhY2sgd2Ugc2hvdWxkIGdvIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0YWNrXG4gICAgICAgIGlmKG5leHRDYXJkLl9vd25lciAhPSB0aGlzKXtcbiAgICAgICAgICAgIHRoaXMuX293bmVyLmdvVG9TdGFja0J5SWQobmV4dENhcmQuX293bmVyLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dENhcmQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYoY3VycmVudENhcmRJZCAhPSBuZXh0Q2FyZC5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZUNhcmRUbyhjdXJyZW50Q2FyZCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuQ2FyZFRvKG5leHRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9QcmV2Q2FyZCgpe1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoY2FyZHMubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBjdXJyZW50SWR4ID0gY2FyZHMuaW5kZXhPZihjdXJyZW50Q2FyZCk7XG5cbiAgICAgICAgbGV0IG5leHRJZHggPSBjdXJyZW50SWR4IC0gMTtcbiAgICAgICAgaWYobmV4dElkeCA8IDApe1xuICAgICAgICAgICAgbmV4dElkeCA9IGNhcmRzLmxlbmd0aCArIG5leHRJZHg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDYXJkID0gY2FyZHNbbmV4dElkeF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgICBuZXh0Q2FyZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50Q2FyZElkICE9IG5leHRDYXJkLmlkKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlQ2FyZFRvKGN1cnJlbnRDYXJkKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5DYXJkVG8obmV4dENhcmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub050aENhcmQoYW5JbmRleCl7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSB1c2luZyAxLWluZGV4ZWQgdmFsdWVzXG4gICAgICAgIC8vIHBlciB0aGUgU2ltcGxlVGFsayBzeXN0ZW1cbiAgICAgICAgbGV0IHRydWVJbmRleCA9IGFuSW5kZXggLSAxO1xuICAgICAgICBsZXQgY2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ2NhcmQnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYodHJ1ZUluZGV4IDwgMCB8fCB0cnVlSW5kZXggPiBjYXJkcy5sZW5ndGggLTEpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgbmF2aWdhdGUgdG8gY2FyZCBudW1iZXIgJHthbkluZGV4fSAtLSBvdXQgb2YgYm91bmRzYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkSWQgPSB0aGlzLmN1cnJlbnRDYXJkSWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMuY3VycmVudENhcmQ7XG4gICAgICAgIGxldCBuZXh0Q2FyZCA9IGNhcmRzW3RydWVJbmRleF07XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCcsXG4gICAgICAgICAgIG5leHRDYXJkLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRDYXJkSWQgIT0gbmV4dENhcmQuaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VDYXJkVG8oY3VycmVudENhcmQpO1xuICAgICAgICAgICAgdGhpcy5zZW5kT3BlbkNhcmRUbyhuZXh0Q2FyZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kQ2xvc2VDYXJkVG8oYUNhcmQpe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2Nsb3NlQ2FyZCcsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYUNhcmRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZW5kT3BlbkNhcmRUbyhhQ2FyZCl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlbkNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFDYXJkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICdzdGFjayc7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRDYXJkSWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudENhcmQoKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RoaXMuY3VycmVudENhcmRJZF07XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGJhc2UgY2xhc3MgbWV0aG9kc1xuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsQ2FyZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPCBsYXN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlU3VicGFydFRvTGFzdChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsQ2FyZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPCBsYXN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgbGFzdFZhbGlkUGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0VXAocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBmaXJzdFZhbGlkUGFydEluZGV4ID0gMDtcbiAgICAgICAgaWYocGFydC50eXBlICE9IFwiY2FyZFwiKXtcbiAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlyc3RWYWxpZFBhcnRJbmRleCA9IGFsbENhcmRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPiBmaXJzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0ZpcnN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgZmlyc3RWYWxpZFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmKHBhcnQudHlwZSAhPSBcImNhcmRcIil7XG4gICAgICAgICAgICBsZXQgYWxsQ2FyZHMgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0VmFsaWRQYXJ0SW5kZXggPSBhbGxDYXJkcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4ID4gZmlyc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBmaXJzdFZhbGlkUGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFBhcnQoYVBhcnQpe1xuICAgICAgICBpZighdGhpcy5hY2NlcHRzU3VicGFydChhUGFydC50eXBlKSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy50eXBlfSBkb2VzIG5vdCBhY2NlcHQgc3VicGFydHMgb2YgdHlwZSAke2FQYXJ0LnR5cGV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YoYVBhcnQpO1xuICAgICAgICBpZihmb3VuZCA8IDApe1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcnQgaXMgYSBjYXJkIHRoZW4gYXBwZW5kIGFmdGVyIHRoZSBsYXN0IGNhcmRcbiAgICAgICAgICAgIGlmKGFQYXJ0LnR5cGUgPT0gXCJjYXJkXCIpe1xuICAgICAgICAgICAgICAgIGxldCBhbGxDYXJkcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJjYXJkXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UoYWxsQ2FyZHMubGVuZ3RoLCAwLCBhUGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VicGFydHMucHVzaChhUGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTdGFjayxcbiAgICBTdGFjayBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBXaW5kb3cgUGFydFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBIFdpbmRvdyBpcyBhIFBhcnQgdGhhdCB3cmFwcyBhbm90aGVyXG4gKiBQYXJ0IG9mIHR5cGUgQ2FyZCwgU3RhY2ssIG9yIFdvcmxkU3RhY2tcbiAqIGluIGEgbW92ZWFibGUgd2luZG93LlxuICogSSBjYW4gYWxzbyBvcHRpb25hbGx5IGhvbGQgYSByZWZlcmVuY2VcbiAqIHRvIGEgdGFyZ2V0IFBhcnQgdGhhdCBJIGRvIG5vdCBvd24uIEkgY2FsbFxuICogdGhpcyBKUyBwcm9wZXJ0eSB0YXJnZXQgYW5kIEkgc3RvcmUgdGhlXG4gKiB0YXJnZXQgcGFydCdzIGlkIGFzIGEgSHlwZXJUYWxrIHByb3BlcnR5XG4gKiBjYWxsZWQgdGFyZ2V0SWQuXG4gKiBXaGVuIG15IG93bmVyIHBhcnQgaXMgdGhlIGN1cnJlbnQgdmlldywgSVxuICogd2lsbCBiZSB2aXNpYmxlIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2UuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi9TdGFjay5qcyc7XG5pbXBvcnQge1xuICAgIGFkZEJhc2ljU3R5bGVQcm9wcyxcbiAgICBhZGRQb3NpdGlvbmluZ1N0eWxlUHJvcHMsXG4gICAgYWRkTGF5b3V0U3R5bGVQcm9wc1xufSBmcm9tICcuLi91dGlscy9zdHlsZVByb3BlcnRpZXMuanMnO1xuXG5jbGFzcyBXaW5kb3cgZXh0ZW5kcyBQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgbmFtZSwgdGFyZ2V0LCBkZXNlcmlhbGl6aW5nPWZhbHNlKXtcbiAgICAgICAgc3VwZXIob3duZXIsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXG4gICAgICAgICAgICBcImFyZWFcIixcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBcImZpZWxkXCIsXG4gICAgICAgICAgICBcImltYWdlXCIsXG4gICAgICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgICAgICBcInJlc291cmNlXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdcIixcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBJZiB3ZSBwYXNzIGluIGEgdGFyZ2V0LFxuICAgICAgICAvLyBzZXQgaXQuXG4gICAgICAgIGlmKHRhcmdldCl7XG4gICAgICAgICAgICB0aGlzLnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHVwIFdpbmRvdyBzcGVjaWZpY1xuICAgICAgICAvLyBwYXJ0IHB0b3BlcnRpZXNcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgICAgIFwiTmV3IFdpbmRvdyBUaXRsZVwiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICAgICAnaXNSZXNpemFibGUnLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICAvLyBTdHlsZVxuICAgICAgICBhZGRCYXNpY1N0eWxlUHJvcHModGhpcyk7XG4gICAgICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlUHJvcGVydGllcygpO1xuICAgICAgICAvLyBwYXJ0IHNwZWNpZmljIGRlZmF1bHQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXRUYXJnZXQgPSB0aGlzLnNldFRhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV2luZG93Q2xvc2UgPSB0aGlzLm9uV2luZG93Q2xvc2UuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBBZGQgcHJpdmF0ZSBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldFByaXZhdGVDb21tYW5kSGFuZGxlcignd2luZG93Q2xvc2UnLCB0aGlzLm9uV2luZG93Q2xvc2UpO1xuICAgIH1cblxuICAgIHNldFRhcmdldChhUGFydCl7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYVBhcnQ7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgdGhpcy50YXJnZXQuaWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1bnNldFRhcmdldCgpe1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlXG4gICAgICogVW5saWtlIG90aGVyIGtpbmRzIG9mIFBhcnRzLCBhIHdpbmRvd1xuICAgICAqIGhhcyBvbmx5IG9uZSBzdWJwYXJ0LCB3aGljaCBzaG91bGQgYmVcbiAgICAgKiBDYXJkLCBTdGFjaywgb3IgV29ybGRTdGFjay5cbiAgICAgKi9cbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0aGlzLmFjY2VwdHNTdWJwYXJ0KGFQYXJ0LnR5cGUpO1xuICAgICAgICBpZighaXNWYWxpZCl7XG4gICAgICAgICAgICAvLyBDb25zaWRlciByZXBsYWNpbmcgdGhpcyBnZW5lcmljIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCBhIG1lc3NhZ2UgYmFzZWQgYXBwcm9hY2ggdGhhdCBzZW5kc1xuICAgICAgICAgICAgLy8gdGhlc2Ugc29ydHMgb2Ygbm9uLWZhdGFsIGVycm9ycyB0byBTeXN0ZW1cbiAgICAgICAgICAgIC8vIGFzIGEga2luZCBvZiBtZXNzYWdlLiBUaGlzIHdheSB3ZSBjYW4gZGlzcGxheVxuICAgICAgICAgICAgLy8gZXJyb3JzIGluIFNpbXBsdFRhbGsgb2JqZWN0cy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2luZG93cyBjYW5ub3Qgd3JhcCBwYXJ0cyBvZiB0eXBlICR7YVBhcnQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhcnQoc3VicGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICBhUGFydC5fb3duZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIG9uV2luZG93Q2xvc2Uoc2VuZGVycywgLi4uYXJncyl7XG4gICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gZGVsZXRlXG4gICAgICAgIC8vIHRoZSB3aW5kb3cgbW9kZWwgZnJvbSB0aGUgU3lzdGVtLlxuICAgICAgICAvLyBTY3JpcHRzIGNhbiBvdmVycmlkZSB0aGlzIGhhbmRsZXJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdkZWxldGVNb2RlbCcsXG4gICAgICAgICAgICAgICAgYXJnczogWyB0aGlzLmlkIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKXtcbiAgICAgICAgcmV0dXJuICd3aW5kb3cnO1xuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBXaW5kb3csXG4gICAgV2luZG93IGFzIGRlZmF1bHRcbn1cbiIsIi8qKlxuICogV29ybGRTdGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgU3RhY2sgcGFydCB0aGF0IHJlcHJlc2VudHMgdGhlIHJvb3Qgb2YgYVxuICogaGllcmFyY2h5IG9mIHBhcnRzLiBJIGFtIHRoZSBlbmQgb2YgdGhlIG93bmVyc2hpcFxuICogY2hhaW4gZm9yIGFueSBnaXZlbiBjb25maWd1cmF0aW9uIG9mIFBhcnRzLlxuICogSSBhbSBhbHNvIHRoZSBmaW5hbCByZXNvbHZlciBvZiBhbGwgdW5oYW5kbGVkXG4gKiBtZXNzYWdlcyBzZW50IGFsb25nIHRoZSBkZWxlZ2F0aW9uIGNoYWluIGZvciBwYXJ0cy5cbiAqIEFsbCBwYXJ0cyBjYW4gZXZlbnR1YWxseSByZXNvbHZlIHRvIG1lIHZpYSB0aGUgZGVsZWdhdGlvblxuICogY2hhaW4gb3Igb3duZXJzaGlwIGhpZXJhcmNoeS5cbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBpbnN0YW5jZSBvZiBtZSBpbiBhbnkgZ2l2ZW5cbiAqIFNpbXBsZVRhbGsgZW52aXJvbm1lbnQuXG4gKi9cbmltcG9ydCBQYXJ0IGZyb20gJy4vUGFydC5qcyc7XG5cblxuY2xhc3MgV29ybGRTdGFjayBleHRlbmRzIFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKG51bGwpO1xuXG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMgPSBbXCJzdGFja1wiLCBcImltYWdlXCJdO1xuXG4gICAgICAgIHRoaXMuaXNXb3JsZCA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIHN0YWNrXG4gICAgICAgIC8vIGlkIG9mIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgICAgIHRoaXMucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFNldCB0aGUgaWQgcHJvcGVydHkgdG8gYWx3YXlzXG4gICAgICAgIC8vIGJlICd3b3JsZCdcbiAgICAgICAgdGhpcy5pZCA9ICd3b3JsZCc7XG5cbiAgICAgICAgLy8gQmluZCBnZW5lcmFsIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZW5kT3BlblN0YWNrVG8gPSB0aGlzLnNlbmRPcGVuU3RhY2tUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8gPSB0aGlzLnNlbmRDbG9zZVN0YWNrVG8uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIG5hdmlnYXRpb24gbWV0aG9kc1xuICAgICAgICB0aGlzLmdvVG9OZXh0U3RhY2sgPSB0aGlzLmdvVG9OZXh0U3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvUHJldlN0YWNrID0gdGhpcy5nb1RvUHJldlN0YWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ29Ub050aFN0YWNrID0gdGhpcy5nb1RvTnRoU3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nb1RvU3RhY2tCeUlkID0gdGhpcy5nb1RvU3RhY2tCeUlkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvbW1hbmQgaGFuZGxlcnMgd2hpY2ggYXJlIG5vdCBuZWVkZWQgZm9yIHdvcmxkXG4gICAgICAgIHRoaXMucmVtb3ZlUHJpdmF0ZUNvbW1hbmRIYW5kbGVyKFwibW92ZVVwXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVEb3duXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0ZpcnN0XCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVByaXZhdGVDb21tYW5kSGFuZGxlcihcIm1vdmVUb0xhc3RcIik7XG4gICAgfVxuXG4gICAgZ29Ub05leHRTdGFjaygpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihzdGFja3MubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrSWQgPSB0aGlzLmN1cnJlbnRTdGFja0lkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IHN0YWNrcy5pbmRleE9mKGN1cnJlbnRTdGFjayk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCArIDE7XG4gICAgICAgIGlmKG5leHRJZHggPj0gc3RhY2tzLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0SWR4ID0gKG5leHRJZHggJSBzdGFja3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvU3RhY2tCeUlkKGFuSWQpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzLmZpbmQoc3RhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmlkID09IGFuSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZighbmV4dFN0YWNrKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIGlkOiAke2FuSWR9IGNhbnQgYmUgZm91bmQgb24gdGhpcyBzdGFja2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgdGhpcy5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAgIG5leHRTdGFjay5pZFxuICAgICAgICApO1xuICAgICAgICBpZihjdXJyZW50U3RhY2tJZCAhPSBuZXh0U3RhY2suaWQpe1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VTdGFja1RvKGN1cnJlbnRTdGFjayk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPcGVuU3RhY2tUbyhuZXh0U3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZTdGFjaygpe1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihzdGFja3MubGVuZ3RoIDwgMil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMuY3VycmVudFN0YWNrO1xuICAgICAgICBsZXQgY3VycmVudFN0YWNrSWQgPSB0aGlzLmN1cnJlbnRTdGFja0lkO1xuICAgICAgICBsZXQgY3VycmVudElkeCA9IHN0YWNrcy5pbmRleE9mKGN1cnJlbnRTdGFjayk7XG4gICAgICAgIGxldCBuZXh0SWR4ID0gY3VycmVudElkeCAtIDE7XG4gICAgICAgIGlmKG5leHRJZHggPCAwKXtcbiAgICAgICAgICAgIG5leHRJZHggPSBzdGFja3MubGVuZ3RoICsgbmV4dElkeDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YWNrID0gc3RhY2tzW25leHRJZHhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvTnRoU3RhY2soYW5JbmRleCl7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSB1c2luZyAxLWluZGV4ZWQgdmFsdWVzXG4gICAgICAgIC8vIHBlciB0aGUgU2ltcGxlVGFsayBzeXN0ZW1cbiAgICAgICAgbGV0IHRydWVJbmRleCA9IGFuSW5kZXggLSAxO1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdzdGFjayc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZih0cnVlSW5kZXggPCAwIHx8IHRydWVJbmRleCA+IHN0YWNrcy5sZW5ndGggLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbmF2aWdhdGUgdG8gc3RhY2sgbnVtYmVyICR7YW5JbmRleH0gLS0gb3V0IG9mIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB0aGlzLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRTdGFja0lkID0gdGhpcy5jdXJyZW50U3RhY2tJZDtcbiAgICAgICAgbGV0IG5leHRTdGFjayA9IHN0YWNrc1t0cnVlSW5kZXhdO1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICAgbmV4dFN0YWNrLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnRTdGFja0lkICE9IG5leHRTdGFjay5pZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZVN0YWNrVG8oY3VycmVudFN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9wZW5TdGFja1RvKG5leHRTdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kQ2xvc2VTdGFja1RvKGFTdGFjayl7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbG9zZVN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIGFTdGFjayk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IGFTdGFjay5jdXJyZW50Q2FyZDtcbiAgICAgICAgaWYoY3VycmVudENhcmQpe1xuICAgICAgICAgICAgYVN0YWNrLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbG9zZUNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgYVN0YWNrLmN1cnJlbnRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbmRPcGVuU3RhY2tUbyhhU3RhY2spe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblN0YWNrJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH0sIGFTdGFjayk7XG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IGFTdGFjay5jdXJyZW50Q2FyZDtcbiAgICAgICAgaWYoY3VycmVudENhcmQpe1xuICAgICAgICAgICAgYVN0YWNrLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsIFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlbkNhcmQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZVxuICAgICAgICAgICAgfSwgYVN0YWNrLmN1cnJlbnRDYXJkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0eXBlKCl7XG4gICAgICAgIHJldHVybiAnd29ybGQnO1xuICAgIH1cblxuICAgIGdldCBsb2FkZWRTdGFja3MoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBub3JtYWwgUGFydCBzZXJpYWxpemF0aW9uLlxuICAgIC8vIEhlcmUgd2UgbmVlZCB0byBhbHNvIGluY2x1ZGUgYW4gYXJyYXkgb2YgaWRzIG9mXG4gICAgLy8gbG9hZGVkIHN0YWNrcyBhbmQgdGhlIGlkIG9mIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgc2VyaWFsaXplKCl7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgc3VicGFydHM6IHRoaXMuc3VicGFydHMubWFwKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LmlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvd25lcklkOiBudWxsLFxuICAgICAgICAgICAgbG9hZGVkU3RhY2tzOiAodGhpcy5sb2FkZWRTdGFja3MubWFwKHN0YWNrID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2suaWQ7XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGN1cnJlbnQgcGFydCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHZhbHVlc1xuICAgICAgICB0aGlzLnBhcnRQcm9wZXJ0aWVzLl9wcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AuZ2V0VmFsdWUodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBmb3IgZGVsZWdhdGlvbi5cbiAgICAvLyBXZSBzZW5kIGFueSBtZXNzYWdlcyB0aGF0IHNob3VsZCBiZSBkZWxlZ2F0ZWRcbiAgICAvLyB0byB0aGUgZ2xvYmFsIFN5c3RlbSBvYmplY3QsIHdoaWNoIGhhcyBhbnlcbiAgICAvLyAnaGFuZGxlcnMgb2YgbGFzdCByZXNvcnQnXG4gICAgZGVsZWdhdGVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoYU1lc3NhZ2UsIHdpbmRvdy5TeXN0ZW0pO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50U3RhY2tJZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdjdXJyZW50J1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50U3RhY2soKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RoaXMuY3VycmVudFN0YWNrSWRdO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHRoZSBiYXNlIGNsYXNzIG1ldGhvZHNcbiAgICBhZGRQYXJ0KGFQYXJ0KXtcbiAgICAgICAgaWYoIXRoaXMuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gZG9lcyBub3QgYWNjZXB0IHN1YnBhcnRzIG9mIHR5cGUgJHthUGFydC50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKGFQYXJ0KTtcbiAgICAgICAgaWYoZm91bmQgPCAwKXtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJ0IGlzIGEgc3RhY2sgdGhlbiBhcHBlbmQgYWZ0ZXIgdGhlIGxhc3Qgc3RhY2tcbiAgICAgICAgICAgIGlmKGFQYXJ0LnR5cGUgPT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgICAgICBsZXQgYWxsU3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJwYXJ0cy5zcGxpY2UoYWxsU3RhY2tzLmxlbmd0aCwgMCwgYVBhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnBhcnRzLnB1c2goYVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVBhcnQuX293bmVyID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVTdWJwYXJ0RG93bihwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGxhc3RWYWxpZFBhcnRJbmRleCA9IHRoaXMuc3VicGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYocGFydC50eXBlID09IFwic3RhY2tcIil7XG4gICAgICAgICAgICBsZXQgYWxsU3RhY2tzID0gdGhpcy5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09IFwic3RhY2tcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdFZhbGlkUGFydEluZGV4ID0gYWxsU3RhY2tzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbGFzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0xhc3QocGFydCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN1YnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICAgIGxldCBsYXN0VmFsaWRQYXJ0SW5kZXggPSB0aGlzLnN1YnBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKHBhcnQudHlwZSA9PSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RWYWxpZFBhcnRJbmRleCA9IGFsbFN0YWNrcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA8IGxhc3RWYWxpZFBhcnRJbmRleCl7XG4gICAgICAgICAgICB0aGlzLnN1YnBhcnRPcmRlckNoYW5nZWQocGFydC5pZCwgY3VycmVudEluZGV4LCBsYXN0VmFsaWRQYXJ0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRVcChwYXJ0KXtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3VicGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgbGV0IGZpcnN0VmFsaWRQYXJ0SW5kZXggPSAwO1xuICAgICAgICBpZihwYXJ0LnR5cGUgIT0gXCJzdGFja1wiKXtcbiAgICAgICAgICAgIGxldCBhbGxTdGFja3MgPSB0aGlzLnN1YnBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT0gXCJzdGFja1wiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaXJzdFZhbGlkUGFydEluZGV4ID0gYWxsU3RhY2tzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZihjdXJyZW50SW5kZXggPiBmaXJzdFZhbGlkUGFydEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZChwYXJ0LmlkLCBjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZVN1YnBhcnRUb0ZpcnN0KHBhcnQpe1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdWJwYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICBsZXQgZmlyc3RWYWxpZFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmKHBhcnQudHlwZSAhPSBcInN0YWNrXCIpe1xuICAgICAgICAgICAgbGV0IGFsbFN0YWNrcyA9IHRoaXMuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PSBcInN0YWNrXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0VmFsaWRQYXJ0SW5kZXggPSBhbGxTdGFja3MubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmKGN1cnJlbnRJbmRleCA+IGZpcnN0VmFsaWRQYXJ0SW5kZXgpe1xuICAgICAgICAgICAgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKHBhcnQuaWQsIGN1cnJlbnRJbmRleCwgZmlyc3RWYWxpZFBhcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmV4cG9ydCB7XG4gICAgV29ybGRTdGFjayxcbiAgICBXb3JsZFN0YWNrIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgY3NzU3R5bGVyIGZyb20gJy4uL3V0aWxzLy9zdHlsZXIuanMnO1xuXG4vKipcbiAqIFBhcnRQcm9wZXJ0aWVzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmFzZVxuICogUGFydCBQcm9wZXJ0aWVzIGZvciBhbGwgUGFydHMuXG4gKiBJIGFsc28gaW5jbHVkZSBzb21lIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIG9uIG15IHByb3RvdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5XG4gKiBvdGhlciBQYXJ0cyB3aGVuIHRoZXkgaW5oZXJpdCBmcm9tIG1lLlxuICogRm9yIG5vdywgd2UgdXNlIE9iamVjdC5jcmVhdGUoKSBmb3IgaW5oZXJpdGFuY2UuXG4gKi9cblxuY2xhc3MgQmFzaWNQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seT1mYWxzZSwgYWxpYXNlcz1bXSl7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgIHRoaXMuYWxpYXNlcyA9IGFsaWFzZXM7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5nZXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhc0FsaWFzID0gdGhpcy5oYXNBbGlhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSB0aGlzLm1hdGNoZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzTmFtZU9yQWxpYXMgPSB0aGlzLm1hdGNoZXNOYW1lT3JBbGlhcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBiYXNpYyBwcm9wZXJ0aWVzLCB3ZSByZXR1cm5cbiAgICAvLyB0aGUgc2V0L3N0b3JlZCB2YWx1ZVxuICAgIGdldFZhbHVlKG93bmVyKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8vIEZvciB0aGUgYmFzaWMgcHJvcGVydGllcywgd2Ugc2V0XG4gICAgLy8gYmFzZWQgb24gdGhlIGluY29taW5nIGRlc2lyZWQgdmFsdWVcbiAgICAvLyBhbG9uZSAobm90aGluZyBpcyBjb21wdXRlZClcbiAgICBzZXRWYWx1ZShvd25lciwgdmFsLCBub3RpZnk9dHJ1ZSl7XG4gICAgICAgIGlmKCF0aGlzLnJlYWRPbmx5KXtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICAgICAgaWYobm90aWZ5KXtcbiAgICAgICAgICAgICAgICBvd25lci5wcm9wZXJ0eUNoYW5nZWQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHByb3BlcnR5XG4gICAgLy8gZ29lcyBieSB0aGUgZ2l2ZW4gYWxpYXNcbiAgICBoYXNBbGlhcyhhbkFsaWFzKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpYXNlcy5pbmNsdWRlcyhhbkFsaWFzKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG5hbWUgaXNcbiAgICAvLyBlaXRoZXIgYW4gYWxpYXMgb3IgdGhlIGV4YWN0IG5hbWVcbiAgICAvLyBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgIG1hdGNoZXNOYW1lT3JBbGlhcyhhTmFtZU9yQWxpYXMpe1xuICAgICAgICBpZih0aGlzLmhhc0FsaWFzKGFOYW1lT3JBbGlhcykpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZihhTmFtZU9yQWxpYXMgPT0gdGhpcy5uYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGluY29taW5nIFByb3BlcnR5XG4gICAgLy8gaGFzIHRoZSBzYW1lIG5hbWUgYW5kL29yIG9uZSBvZiB0aGUgc2FtZVxuICAgIC8vIGFsaWFzZXMgYXMgdGhpcyBQcm9wZXJ0eVxuICAgIG1hdGNoZXMoYVByb3BlcnR5KXtcbiAgICAgICAgaWYoYVByb3BlcnR5Lm5hbWUgPT0gdGhpcy5uYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYWxpYXNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgbGV0IG15QWxpYXMgPSB0aGlzLmFsaWFzZXNbaV07XG4gICAgICAgICAgICAgICAgaWYoYVByb3BlcnR5Lmhhc0FsaWFzKG15QWxpYXMpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5cbi8qKiBDdXN0b20gUHJvcGVydGllcyBhcmUgc2ltaWxhciB0byBkeW5hbWljIHByb3BzLCBleGNlcHQgdGhhdFxuICAqIHVuZGVyIHRoZSBob29kIHRoZXkgc3RvcmUgYW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgKiBzdG9yaW5nIHByb3BzIGRlZmluZWQgd2l0aGluIHRoZSBTVCBlbnZpcm9ubWVudC4gVGhlIGZpbmQoKVxuICAqIGFkZCgpIGRlbGV0ZSgpIG1ldGhvZHMgZmluZCwgYWRkLCBvciByZW1vdmUgcHJvcGVydGllcyBmcm9tIHRoZVxuICAqIHRoaXMuY3VzdG9tUHJvcGVydGllcyBvYmplY3QuXG4gKiovXG5jbGFzcyBDdXN0b21Qcm9wZXJ0eSBleHRlbmRzIEJhc2ljUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWU9XCJjdXN0b20tcHJvcGVydGllc1wiLCBkZWZhdWx0VmFsdWU9e30sIHJlYWRPbmx5PWZhbHNlLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seT1mYWxzZSwgYWxpYXNlcyk7XG4gICAgfVxuXG4gICAgZmluZChuYW1lKXtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl92YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYocHJvcCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhZGQoYVByb3BlcnR5KXtcbiAgICAgICAgLy8gTk9URTogYWxpYXNlcyBhcmUgY29tcGxldGVkIGlnbm9yZWQgZm9yIG5vd1xuICAgICAgICBpZighdGhpcy5maW5kKGFQcm9wZXJ0eS5uYW1lKSl7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZVthUHJvcGVydHkubmFtZV0gPSBhUHJvcGVydHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUoYVByb3BlcnR5KXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ZhbHVlW2FQcm9wZXJ0eS5uYW1lXTtcbiAgICB9XG5cblxuXG59O1xuXG5jbGFzcyBEeW5hbWljUHJvcGVydHkgZXh0ZW5kcyBCYXNpY1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzZXR0ZXIsIGdldHRlciwgcmVhZE9ubHk9ZmFsc2UsIGRlZmF1bHRWYWx1ZT1udWxsLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seSwgYWxpYXNlcyk7XG4gICAgICAgIHRoaXMudmFsdWVTZXR0ZXIgPSBzZXR0ZXI7XG4gICAgICAgIHRoaXMudmFsdWVHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhpcyBvdmVycmlkZSwgd2UgdXNlIHRoZSBnZXR0ZXJcbiAgICAvLyBpZiBhdmFpbGFibGUsIHRvIGR5bmFtaWNhbGx5IGdldCB0aGVcbiAgICAvLyBpbmNvbWluZyB2YWx1ZS5cbiAgICBnZXRWYWx1ZShvd25lcil7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlR2V0dGVyKG93bmVyLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBJbiB0aGlzIG92ZXJyaWRlLCB3ZSB1c2UgdGhlIHNldHRlclxuICAgIC8vIGlmIGF2YWlsYWJsZSwgdG8gZHluYW1pY2FsbHkgc2V0IHRoZVxuICAgIC8vIGluY29taW5nIHZhbHVlXG4gICAgc2V0VmFsdWUob3duZXIsIHZhbCwgbm90aWZ5PXRydWUpe1xuICAgICAgICBpZighdGhpcy5yZWFkT25seSl7XG4gICAgICAgICAgICB0aGlzLnZhbHVlU2V0dGVyKG93bmVyLCB0aGlzLCB2YWwsIG5vdGlmeSk7XG4gICAgICAgICAgICBpZihub3RpZnkpe1xuICAgICAgICAgICAgICAgIG93bmVyLnByb3BlcnR5Q2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKiogSSBhbSBhIHNwZWNpYWwgcHJvcGVydHkgd2hpY2ggaGFuZGxlcyBpbnRlcmZhY2luZyB3aXRoIHRoZVxuICAqIHRoZSBjc3NTdHlsZSBiYXNpYyBwcm9wZXJ0eS4gV2hlbmV2ZXIgSSBhbSB1cGRhdGVkIEkgbWFrZVxuICAqIHN1cmUgdG8gdXBkYXRlIHRoZSBjc3NTdHlsZSBwcm9wZXJ0eSB2aWEgdGhlIHN0eWxlciB1dGlsaXR5XG4gICogZnVuY3Rpb24uIEkgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGRpZmZlcmVudCBhbmQgaW5kZXBlbnRcbiAgKiBzdHlsaW5nIG9wdGlvbnMuXG4gICoqL1xuY2xhc3MgU3R5bGVQcm9wZXJ0eSBleHRlbmRzIEJhc2ljUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlZmF1bHRWYWx1ZSwgIHByb3BOYW1lPSdjc3NTdHlsZScsIHN0eWxlcj1jc3NTdHlsZXIsIHJlYWRPbmx5PWZhbHNlLCBhbGlhc2VzPVtdKXtcbiAgICAgICAgc3VwZXIobmFtZSwgZGVmYXVsdFZhbHVlLCByZWFkT25seSwgYWxpYXNlcyk7XG4gICAgICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICAgICAgdGhpcy5zdHlsZXIgPSBzdHlsZXI7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhpcyBvdmVycmlkZSwgd2UgdXBkYXRlIHRoZSBjc3NTdHlsZSBwcm9wZXJ0eVxuICAgIHNldFZhbHVlKG93bmVyLCB2YWwsIG5vdGlmeT10cnVlKXtcbiAgICAgICAgaWYoIXRoaXMucmVhZE9ubHkpe1xuICAgICAgICAgICAgbGV0IHN0eWxlUHJvcGVydHkgPSBvd25lci5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCh0aGlzLnByb3BOYW1lKTtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHN0eWxlUHJvcGVydHkuZ2V0VmFsdWUob3duZXIpO1xuICAgICAgICAgICAgbGV0IG5ld1N0eWxlID0gdGhpcy5zdHlsZXIoc3R5bGUsIHRoaXMubmFtZSwgdmFsKTtcbiAgICAgICAgICAgIHN0eWxlUHJvcGVydHkuc2V0VmFsdWUob3duZXIsIG5ld1N0eWxlLCBub3RpZnkpO1xuXG4gICAgICAgICAgICAvLyBzZXQgbXkgdmFsdWUgYXMgd2VsbFxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICBpZihub3RpZnkpe1xuICAgICAgICAgICAgICAgIG93bmVyLnByb3BlcnR5Q2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY2xhc3MgUGFydFByb3BlcnRpZXMge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuaGFzUHJvcGVydHkgPSB0aGlzLmhhc1Byb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkgPSB0aGlzLmFkZFByb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlUHJvcGVydHkgPSB0aGlzLnJlbW92ZVByb3BlcnR5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmluZFByb3BlcnR5TmFtZWQgPSB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHlOYW1lZCA9IHRoaXMuc2V0UHJvcGVydHlOYW1lZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFByb3BlcnR5TmFtZWQgPSB0aGlzLmdldFByb3BlcnR5TmFtZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXdCYXNpY1Byb3AgPSB0aGlzLm5ld0Jhc2ljUHJvcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5ld1N0eWxlUHJvcCA9IHRoaXMubmV3U3R5bGVQcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubmV3RHluYW1pY1Byb3AgPSB0aGlzLm5ld0R5bmFtaWNQcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2luZGV4T2ZQcm9wZXJ0eSA9IHRoaXMuX2luZGV4T2ZQcm9wZXJ0eS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCBhbGwoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjb2xsZWN0aW9uICdoYXMnIGEgcHJvcGVydHkgaWYgaXQgY29udGFpbnNcbiAgICAvLyBhIFByb3BlcnR5IG9iamVjdCB3aXRoIG1hdGNoaW5nIG5hbWUgb3IgYWxpYXNcbiAgICAvLyBvZiB0aGUgaW5jb21pbmcgcHJvcGVydHkuXG4gICAgaGFzUHJvcGVydHkoYVByb3BlcnR5KXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYoYVByb3BlcnR5Lm1hdGNoZXMocHJvcCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIG9uZSBvZiBteSBQcm9wZXJ0aWVzIGJ5XG4gICAgLy8gYSBuYW1lIG9yIGFsaWFzLiBSZXR1cm5zIG51bGxcbiAgICAvLyBpZiBubyBtYXRjaCBmb3VuZC4gUGVyaGFwcyB3ZSBzaG91bGRcbiAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgIGZpbmRQcm9wZXJ0eU5hbWVkKGFOYW1lKXtcbiAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgbGV0IGN1c3RvbVByb3BlcnRpZXNQcm9wO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fcHJvcGVydGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuX3Byb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBpZihwcm9wLm1hdGNoZXNOYW1lT3JBbGlhcyhhTmFtZSkpe1xuICAgICAgICAgICAgICAgIGZvdW5kID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIGN1c3RvbSBwcm9wZXJ0aWVzIHByb3AsIGFzIHdlIG1pZ2h0IG5lZWQgaXRcbiAgICAgICAgICAgIC8vIGZvciBsYXRlclxuICAgICAgICAgICAgaWYocHJvcC5tYXRjaGVzTmFtZU9yQWxpYXMoXCJjdXN0b20tcHJvcGVydGllc1wiKSl7XG4gICAgICAgICAgICAgICAgY3VzdG9tUHJvcGVydGllc1Byb3AgPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiB0aGUgcHJvcGVydHkgaXMgY3VzdG9tXG4gICAgICAgIGlmKCFmb3VuZCAmJiBjdXN0b21Qcm9wZXJ0aWVzUHJvcCl7XG4gICAgICAgICAgICBmb3VuZCA9IGN1c3RvbVByb3BlcnRpZXNQcm9wLmZpbmQoYU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0cyB0byBnZXQgdGhlICp2YWx1ZSogb2YgdGhlIHByb3BlcnR5XG4gICAgLy8gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciBhbGlhcy5cbiAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB3ZSB0aHJvdyBhblxuICAgIC8vIGVycm9yXG4gICAgZ2V0UHJvcGVydHlOYW1lZChvd25lciwgYU5hbWUpe1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbmRQcm9wZXJ0eU5hbWVkKGFOYW1lKTtcbiAgICAgICAgaWYoIWZvdW5kKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvd25lcn0gZG9lcyBub3QgaGF2ZSBwcm9wZXJ0eSBcIiR7YU5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQuZ2V0VmFsdWUob3duZXIpO1xuICAgIH1cblxuICAgIC8vIEF0dGVtcHRzIHRvIHNldCB0aGUgKnZhbHVlKiBvZiB0aGUgcHJvcGVydHlcbiAgICAvLyB3aXRoIHRoZSBnaXZlbiBuYW1lIG9yIGFsaWFzLlxuICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHdlIHRocm93IGFuXG4gICAgLy8gZXJyb3JcbiAgICBzZXRQcm9wZXJ0eU5hbWVkKG93bmVyLCBhTmFtZSwgYVZhbHVlLCBub3RpZnk9dHJ1ZSl7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZmluZFByb3BlcnR5TmFtZWQoYU5hbWUpO1xuICAgICAgICBpZighZm91bmQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke293bmVyfSBkb2VzIG5vdCBoYXZlIHByb3BlcnR5IFwiJHthTmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZC5zZXRWYWx1ZShvd25lciwgYVZhbHVlLCBub3RpZnkpO1xuICAgIH1cblxuICAgIC8vIElmIHlvdSBhZGQgYSBwcm9wZXJ0eSB3aXRoIGEgbmFtZSBvciBhbGlhc1xuICAgIC8vIHRoYXQgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBjb2xsZWN0aW9uLFxuICAgIC8vIHRoZW4gd2UgJ292ZXJ3cml0ZScgaXQgYnkgcmVtb3ZpbmcgdGhlIGV4aXNpbmdcbiAgICAvLyBwcm9wZXJ0eSBhbmQgcmVwbGFjaW5nIGl0IHdpdGggdGhlIGluY29taW5nIG9uZS5cbiAgICAvLyBPdGhlcndpc2UsIHdlIGp1c3QgYWRkIHRoZSBwcm9wZXJ0eVxuICAgIGFkZFByb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGlmKHRoaXMuaGFzUHJvcGVydHkoYVByb3BlcnR5KSl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5KGFQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvcGVydGllcy5wdXNoKGFQcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZpbmcgYSBwcm9wZXJ0eSBoZXJlIG1lYW5zIHJlbW92aW5nXG4gICAgLy8gaXQgZnJvbSB0aGUgc3RvcmVkIGFycmF5LiBJZiB0aGUgcHJvcGVydHlcbiAgICAvLyBpcyBub3QgaW4gdGhlIGFycmF5LCB3ZSBkbyBOT1QgdGhyb3cgYW4gZXJyb3IuXG4gICAgLy8gV2UganVzdCBnbyBvbiB3aXRoIG91ciBsaXZlcywgYmVjYXVzZSB3aG8gY2FyZXM/XG4gICAgcmVtb3ZlUHJvcGVydHkoYVByb3BlcnR5KXtcbiAgICAgICAgbGV0IHByb3BJbmRleCA9IHRoaXMuX2luZGV4T2ZQcm9wZXJ0eShhUHJvcGVydHkpO1xuICAgICAgICBpZihwcm9wSW5kZXggPj0gMCl7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnNwbGljZShwcm9wSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBiYXNpY1xuICAgIC8vIHByb3BlcnR5LlxuICAgIG5ld0Jhc2ljUHJvcCguLi5hcmdzKXtcbiAgICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgQmFzaWNQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShuZXdQcm9wKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IGN1c3RvbVxuICAgIC8vIHByb3BlcnR5LlxuICAgIG5ld0N1c3RvbVByb3AoLi4uYXJncyl7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IEN1c3RvbVByb3BlcnR5KC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KG5ld1Byb3ApO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXcgc3R5bGVcbiAgICAvLyBwcm9wZXJ0eS5cbiAgICBuZXdTdHlsZVByb3AoLi4uYXJncyl7XG4gICAgICAgIGxldCBuZXdQcm9wID0gbmV3IFN0eWxlUHJvcGVydHkoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ld1xuICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgIG5ld0R5bmFtaWNQcm9wKC4uLmFyZ3Mpe1xuICAgICAgICBsZXQgbmV3UHJvcCA9IG5ldyBEeW5hbWljUHJvcGVydHkoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QuIEZpbmRzIHRoZSBmaXJzdCBvY2N1cnJpbmdcbiAgICAvLyBpbmRleCBvZiB0aGUgZ2l2ZW4gUHJvcGVydHkgaW4gdGhlIGFycmF5XG4gICAgLy8gb2YgcHJvcGVydGllcyBpbiB0aGlzIGNvbGxlY3Rpb24uIFJldHVybnNcbiAgICAvLyAtMSBpZiBub3QgZm91bmQsIHBlciBKUyBpbXBsZW1lbnRhdGlvbi5cbiAgICBfaW5kZXhPZlByb3BlcnR5KGFQcm9wZXJ0eSl7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYoYVByb3BlcnR5Lm1hdGNoZXMocHJvcCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnRQcm9wZXJ0aWVzLFxuICAgIEJhc2ljUHJvcGVydHksXG4gICAgQ3VzdG9tUHJvcGVydHksXG4gICAgRHluYW1pY1Byb3BlcnR5LFxuICAgIFBhcnRQcm9wZXJ0aWVzIGFzIGRlZmF1bHRcbn07XG4iLCIvKiogU2Vjb25kIHBhc3MgYXQgc3ludGF4IGhpZ2hsaWdodGVyIHNlbWFudGljcyAqKi9cbmNvbnN0IHN5bnRheFNwYW4gPSAocnVsZU5hbWUpID0+IHtcbiAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3N0LXN5bnRheCcpO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKCdkYXRhLXN0LXJ1bGUnLCBydWxlTmFtZSk7XG4gICAgcmV0dXJuIHNwYW47XG59XG5cbmNvbnN0IGNyZWF0ZUhpZ2hsaWdodGVyID0gKGZpZWxkRWxlbWVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIE1lc3NhZ2VIYW5kbGVyT3BlbjogZnVuY3Rpb24obGl0ZXJhbE9uLCBtZXNzYWdlTmFtZSwgb3B0aW9uYWxQYXJhbUxpc3Qpe1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBzeW50YXhTcGFuKFwiTWVzc2FnZUhhbmRsZXJPcGVuXCIpO1xuICAgICAgICAgICAgbGV0IG9uU3BhbiA9IHN5bnRheFNwYW4oXCJrZXl3b3JkXCIpO1xuICAgICAgICAgICAgb25TcGFuLmFwcGVuZChcIm9uIFwiKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKG9uU3Bhbik7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCBzdWItcnVsZXNcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKG1lc3NhZ2VOYW1lLmhpZ2hsaWdodFN5bnRheCgpKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKC4uLm9wdGlvbmFsUGFyYW1MaXN0LmhpZ2hsaWdodFN5bnRheCgpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWVzc2FnZUhhbmRsZXJDbG9zZShsaXRlcmFsRW5kLCBtZXNzYWdlTmFtZSl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IHN5bnRheFNwYW4oXCJNZXNzYWdlSGFuZGxlckNsb3NlXCIpO1xuICAgICAgICAgICAgbGV0IGVuZFNwYW4gPSBzeW50YXhTcGFuKFwia2V5d29yZFwiKTtcbiAgICAgICAgICAgIGVuZFNwYW4uYXBwZW5kKFwiZW5kIFwiKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kKGVuZFNwYW4pO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBhcnRzXG4gICAgICAgICAgICBzcGFuLmFwcGVuZChtZXNzYWdlTmFtZS5oaWdobGlnaHRTeW50YXgoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9LFxuXG4gICAgICAgIFBhcmFtZXRlckxpc3Q6IGZ1bmN0aW9uKHBhcmFtU3RyaW5nKXtcbiAgICAgICAgICAgIGxldCBvdXRlciA9IHN5bnRheFNwYW4oXCJQYXJhbWV0ZXJMaXN0XCIpO1xuICAgICAgICAgICAgbGV0IGlubmVySXRlbXMgPSBwYXJhbVN0cmluZy5hc0l0ZXJhdGlvbigpLmNoaWxkcmVuLm1hcChwYXJhbU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzcGFuID0gc3ludGF4U3BhbihcIlBhcmFtZXRlckxpc3QtaXRlbVwiKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZChwYXJhbU5hbWUuc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Bhbi5vdXRlckhUTUw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dGVyLmlubmVySFRNTCA9IGlubmVySXRlbXMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG91dGVyO1xuICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZU5hbWU6IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZCgnc3Qtc3ludGF4Jyk7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnZGF0YS1zdC1ydWxlJywgJ21lc3NhZ2VOYW1lJyk7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZChzdHJpbmcuc291cmNlU3RyaW5nICsgXCIgXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5d29yZDogZnVuY3Rpb24oc3RyaW5nKXtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdzdC1zeW50YXgnKTtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKCdkYXRhLXN0LXJ1bGUnLCAna2V5d29yZCcpO1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmQoc3RyaW5nLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnQge1xuICAgIGNyZWF0ZUhpZ2hsaWdodGVyLFxuICAgIGNyZWF0ZUhpZ2hsaWdodGVyIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFV0aWxpdGllcyBmb3IgQ2xpcGJvYXJkIEZ1bmN0aW9uYWxpdHlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRm9yIHRoZSBtb21lbnQgd2UgdXNlIGEgdmVyeSBwcmltaXRpdmUgc3RhbmQtaW5cbiAqIHNpbmNlIHRoZSBDbGlwYm9hcmQgQVBJIGlzIG5vdCBzdGFuZGFyZGl6ZWQgYWNyb3NzXG4gKiBicm93c2VyIGltcGxlbWVudGF0aW9ucy5cbiAqKi9cbmltcG9ydCBpZE1ha2VyIGZyb20gJy4vaWQuanMnO1xuaW1wb3J0IHtTVERlc2VyaWFsaXplciwgU1RTZXJpYWxpemVyfSBmcm9tICcuL3NlcmlhbGl6YXRpb24uanMnO1xuXG5jbGFzcyBTVENsaXBib2FyZCB7XG4gICAgY29uc3RydWN0b3IoYVN5c3RlbSl7XG4gICAgICAgIHRoaXMuc3lzdGVtID0gYVN5c3RlbTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IFtdO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5jb3B5UGFydCA9IHRoaXMuY29weVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXN0ZUNvbnRlbnRzSW50byA9IHRoaXMucGFzdGVDb250ZW50c0ludG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlTGVuc2VkQ2hpbGRyZW4gPSB0aGlzLl9jcmVhdGVMZW5zZWRDaGlsZHJlbi5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvcHlQYXJ0KGFQYXJ0KXtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZXIgPSBuZXcgU1RTZXJpYWxpemVyKHRoaXMuc3lzdGVtKTtcbiAgICAgICAgbGV0IHJvb3RTZXJpYWxpemF0aW9uID0gc2VyaWFsaXplci5zZXJpYWxpemUoYVBhcnQsIGZhbHNlKTtcbiAgICAgICAgbGV0IGl0ZW0gPSBuZXcgU1RDbGlwYm9hcmRJdGVtKFxuICAgICAgICAgICAgJ3NpbXBsZXRhbGsvanNvbicsXG4gICAgICAgICAgICByb290U2VyaWFsaXphdGlvbixcbiAgICAgICAgICAgIGFQYXJ0LnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IFtpdGVtXTtcbiAgICB9XG5cbiAgICBwYXN0ZUNvbnRlbnRzSW50byhhVGFyZ2V0UGFydCl7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IHRoaXMuY29udGVudHMubWFwKGNsaXBib2FyZENvbnRlbnQgPT4ge1xuICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudC5kYXRhO1xuICAgICAgICAgICAgbGV0IGRlc2VyaWFsaXplciA9IG5ldyBTVERlc2VyaWFsaXplcih0aGlzLnN5c3RlbSk7XG4gICAgICAgICAgICBkZXNlcmlhbGl6ZXIudGFyZ2V0SWQgPSBhVGFyZ2V0UGFydC5pZDtcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENvbnRlbnQpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdG9wIGFuZCBsZWZ0IHZhbHVlcyB0byB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXN0ZWQgcGFydCBkb2Vzbid0IHJ1biBvdXRzaWRlIG9mIHRoZSBuZXdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRpdmUgYm91bmRzIGluIHdoaWNoIGl0IGhhcyBiZWVuIHBhc3RlZFxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGFydCA9IGRlc2VyaWFsaXplci5yb290UGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNUb3AgPSBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCd0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0xlZnQgPSBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1RvcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihoYXNMZWZ0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcnQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiBIYWxvIG9uIHRoZSBuZXcgdmlld1xuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZXIucm9vdFZpZXdzWzBdLm9wZW5IYWxvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIEN1c3RvbUV2ZW50IHRoYXQgbm90aWZpZXMgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYSBuZXcgdmlldyB3YXMgYWRkZWQgKHVzZWQgYnkgTmF2IGV0YylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzdC12aWV3LWFkZGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydFR5cGU6IG5ld1BhcnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IG5ld1BhcnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJZDogbmV3UGFydC5fb3duZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplci5yb290Vmlld3NbMF0uZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFueSBsZW5zZWQgdmlld3MgdGhhdCBtaWdodCBiZSBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvb3RMZW5zVmlld3MgPSB0aGlzLnN5c3RlbS5maW5kTGVuc1ZpZXdzQnlJZChuZXdQYXJ0Ll9vd25lci5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RMZW5zVmlld3MuZm9yRWFjaChsZW5zVmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TGVuc1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQobmV3UGFydC50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldE1vZGVsKG5ld1BhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIG5ld1BhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbnNWaWV3LmFwcGVuZENoaWxkKG5ld0xlbnNWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxlbnNlZENoaWxkcmVuKG5ld0xlbnNWaWV3LCBuZXdQYXJ0LnN1YnBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlTGVuc2VkQ2hpbGRyZW4oYUxlbnNWaWV3LCBzdWJwYXJ0cyl7XG4gICAgICAgIHN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3TGVuc1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIHRoaXMuc3lzdGVtLnRhZ05hbWVGb3JWaWV3TmFtZWQoc3VicGFydC50eXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld0xlbnNWaWV3LnNldE1vZGVsKHN1YnBhcnQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICBuZXdMZW5zVmlldy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIHN1YnBhcnQuaWQpO1xuICAgICAgICAgICAgbmV3TGVuc1ZpZXcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xlbnMnKTtcbiAgICAgICAgICAgIGFMZW5zVmlldy5hcHBlbmRDaGlsZChuZXdMZW5zVmlldyk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVMZW5zZWRDaGlsZHJlbihuZXdMZW5zVmlldywgc3VicGFydC5zdWJwYXJ0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBnZXQgaXNFbXB0eSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGggPD0gMDtcbiAgICB9XG59XG5cbmNsYXNzIFNUQ2xpcGJvYXJkSXRlbSB7XG4gICAgY29uc3RydWN0b3IobWltZVR5cGUsIGRhdGEsIHBhcnRUeXBlKXtcbiAgICAgICAgaWYobWltZVR5cGUpe1xuICAgICAgICAgICAgdGhpcy50eXBlID0gbWltZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFydFR5cGUpe1xuICAgICAgICAgICAgdGhpcy5fcGFydFR5cGUgPSBwYXJ0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGFydFR5cGUoKXtcbiAgICAgICAgaWYodGhpcy50eXBlID09ICdzaW1wbGV0YWxrL2pzb24nKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXQgcGFydFR5cGUodmFsKXtcbiAgICAgICAgdGhpcy5fcGFydFR5cGUgPSB2YWw7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBTVENsaXBib2FyZCxcbiAgICBTVENsaXBib2FyZCBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBFcnJvciBIYW5kbGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gcmVzcG9uc2libGUgZm9yIGhhbmRsZXIgYWxsXG4gKiBTeXN0ZW0td2lkZSBlcnJvcnNcbiAqL1xuXG5jb25zdCBlcnJvckhhbmRsZXIgPSB7XG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLm5hbWUpe1xuICAgICAgICAgICAgY2FzZSAnR3JhbW1hck1hdGNoRXJyb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUdyYW1tYXJNYXRjaEVycm9yKGFNZXNzYWdlKTtcbiAgICAgICAgICAgIGNhc2UgJ01lc3NhZ2VOb3RVbmRlcnN0b29kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNZXNzYWdlTm90VW5kZXJzdG9vZChhTWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlmIEkgZG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggdGhpcyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgLy8gSSBzZW5kIGl0IGFsb25nIHRvIHRoZSBTeXN0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5yZWNlaXZlTWVzc2FnZShhTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlR3JhbW1hck1hdGNoRXJyb3I6IGZ1bmN0aW9uKGFNZXNzYWdlKXtcbiAgICAgICAgLy8gVE9ETyBpcyB0aGVyZSBhIG1vcmUgc3RydWN0dXJlZCB3YXkgdG8gZ2V0IHRoaXMgb3V0IG9mIG9obT9cbiAgICAgICAgbGV0IHJlZ2V4ID0gL0xpbmUgKD88bGluZT5cXGQpLCBjb2wgKD88Y29sdW1uPlxcZCkvO1xuICAgICAgICBsZXQgbWF0Y2ggPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQubWVzc2FnZS5tYXRjaChyZWdleCk7XG4gICAgICAgIGxldCBlcnJvckxpbmVOdW0gPSBwYXJzZUludChtYXRjaC5ncm91cHNbXCJsaW5lXCJdKSAtIDE7IC8vIG9obSBsaW5lcyBzdGFydCB3aXRoIDEgXG4gICAgICAgIC8vIHNlZSBpZiB0aGUgZ3JhbW1hciBydWxlIGhhcyBiZWVuIGlkZW50aWZpZWRcbiAgICAgICAgbGV0IHJ1bGVOYW1lO1xuICAgICAgICBsZXQgcmlnaHRNb3N0RmFpbHVyZXMgPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQuZ2V0UmlnaHRtb3N0RmFpbHVyZXMoKTtcbiAgICAgICAgaWYocmlnaHRNb3N0RmFpbHVyZXNbMV0pe1xuICAgICAgICAgICAgcnVsZU5hbWUgPSByaWdodE1vc3RGYWlsdXJlc1sxXS5wZXhwci5ydWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgc29tZSBtb3JlIGluZm8gYWJvdXQgd2hhdCB0aGUgcGFyc2VyIGV4cGVjdGVkXG4gICAgICAgIGxldCBleHBlY3RlZFRleHQgPSBhTWVzc2FnZS5wYXJzZWRTY3JpcHQuZ2V0RXhwZWN0ZWRUZXh0KCk7XG4gICAgICAgIC8vIGdldCB0aGUgb3JpZ2luYWwgc2NyaXB0XG4gICAgICAgIGxldCB0ZXh0ID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmlucHV0O1xuICAgICAgICBsZXQgdGV4dExpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgLy8gcmVwbGFjZSBzYWlkIHRleHQgbGluZSB3aXRoIGFuIGVycm9yIG1hcmtlclxuICAgICAgICB0ZXh0TGluZXNbZXJyb3JMaW5lTnVtXSArPSBgIC0tPDw8W0V4cGVjdGVkOiR7ZXhwZWN0ZWRUZXh0fTsgcnVsZU5hbWU6IFwiJHtydWxlTmFtZX1cIl1gO1xuICAgICAgICB0ZXh0ID0gdGV4dExpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBwYXJzZWQgc2NyaXB0IGlzIFwiZG9JdFwiIHRoZW4gdGhlIHN0YXRlbWVudExpbmVzIGFyZVxuICAgICAgICAvLyBsb2NhdGVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHRleHQsIG5vdCB0aGUgc2NyaXB0LCBwcm9wZXJ0eSBhbmRcbiAgICAgICAgLy8gd2Ugd2FudCB0aGUgZXJyb3IgdG8gYmUgbWFya2VkIHVwIGluIHRoZSBmaWVsZCB0ZXh0YXJlYVxuICAgICAgICBpZihhTWVzc2FnZS5wYXJzZWRTY3JpcHQuaW5wdXQuc3RhcnRzV2l0aChcIm9uIGRvSXRcIikpe1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyTW9kZWwgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFthTWVzc2FnZS5wYXJ0SWRdO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBnZXQgdGhlIG9yaWdpbmFsIHRleHQgc28gYXMgbm90IHRvIGNvbXBsZXRlbHkgcmVwbGFjZSBpdFxuICAgICAgICAgICAgLy8gdGhlbiBpbnNlcnQgdGhlIG1hcmt1cCBpbiB0aGUgYXBwcm9wcmlhdGUgbGluZVxuICAgICAgICAgICAgbGV0IGZpZWxkVGV4dCA9IG9yaWdpbmFsU2VuZGVyTW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvcmlnaW5hbFNlbmRlck1vZGVsLCBcInRleHRcIik7XG4gICAgICAgICAgICBsZXQgc2NyaXB0ID0gYU1lc3NhZ2UucGFyc2VkU2NyaXB0LmlucHV0O1xuICAgICAgICAgICAgc2NyaXB0ID0gdGhpcy5fY2xlYW5Eb0l0U0NyaXB0KHNjcmlwdCk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBcImRvSXRcIiBoYW5kbGVyIGluc2VydGVkIGJhY2sgaW4sIHNpbmNlIGl0J3MganVzdCBhIGhpZGRlbiB3cmFwcGVyIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHN0YXRlbWVudCBsaW5lc1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuX2NsZWFuRG9JdFNDcmlwdCh0ZXh0KTtcbiAgICAgICAgICAgIGZpZWxkVGV4dCA9IGZpZWxkVGV4dC5yZXBsYWNlKHNjcmlwdCwgdGV4dCk7XG4gICAgICAgICAgICBvcmlnaW5hbFNlbmRlck1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQob3JpZ2luYWxTZW5kZXJNb2RlbCwgXCJ0ZXh0XCIsIGZpZWxkVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBsb2NhdGUgdGhlIHNjcmlwdCBlZGl0b3IgaW4gcXVlc3Rpb25cbiAgICAgICAgICAgIGxldCBzY3JpcHRFZGl0b3IgPSB3aW5kb3cuU3lzdGVtLmZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkKGFNZXNzYWdlLnBhcnRJZCk7XG4gICAgICAgICAgICBpZighc2NyaXB0RWRpdG9yKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGVuU2NyaXB0RWRpdG9yKGFNZXNzYWdlLnBhcnRJZCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChhTWVzc2FnZS5wYXJ0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyaXB0RWRpdG9yLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoc2NyaXB0RWRpdG9yLm1vZGVsLCBcInRleHRcIiwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3BlbiB0aGUgZ3JhbW1hciBpZiB0aGVyZSBpcyBub3Qgb25lIG9wZW4gYWxyZWFkeVxuICAgICAgICBsZXQgY3VycmVudENhcmQgPSB3aW5kb3cuU3lzdGVtLmdldEN1cnJlbnRDYXJkTW9kZWwoKTtcbiAgICAgICAgbGV0IGdyYW1tYXIgPSBjdXJyZW50Q2FyZC5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocGFydC50eXBlID09IFwiZmllbGRcIikgJiYgKHBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChwYXJ0LCBcIm5hbWVcIikgPT0gXCJTaW1wbGVUYWxrXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoZ3JhbW1hci5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICB0aGlzLl9vcGVuR3JhbW1hcihhTWVzc2FnZS5wYXJ0SWQsIHJ1bGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVNZXNzYWdlTm90VW5kZXJzdG9vZChhTWVzc2FnZSl7XG4gICAgICAgIGxldCBvZmZlbmRpbmdNZXNzYWdlID0gYU1lc3NhZ2UubWVzc2FnZTtcbiAgICAgICAgbGV0IG9yaWdpbmFsU2VuZGVyID0gb2ZmZW5kaW5nTWVzc2FnZS5zZW5kZXJzWzBdO1xuICAgICAgICAvLyBBcmUgd2UgZXZlciBnb2luZyB0byBoYXZlIE1OVSBlcnJvcnMgb24gbWVzc2FnZXMgdGhhdFxuICAgICAgICAvLyBhcmUgbm90IHR5cGU6IGNvbW1hbmQ/XG4gICAgICAgIGlmKG9mZmVuZGluZ01lc3NhZ2UudHlwZSA9PT0gXCJjb21tYW5kXCIpe1xuICAgICAgICAgICAgbGV0IGNvbW1hbmROYW1lID0gb2ZmZW5kaW5nTWVzc2FnZS5jb21tYW5kTmFtZTtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFNlbmRlck1vZGVsID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbb3JpZ2luYWxTZW5kZXIuaWRdO1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXHMqJHtjb21tYW5kTmFtZX0oXFxzfFxcbnwkKWAsICdnJyk7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgICAgICBsZXQgZXhlY3V0aW9uU3RhY2sgPSB3aW5kb3cuU3lzdGVtLmV4ZWN1dGlvblN0YWNrLl9zdGFjaztcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBleGVjdXRpb24gc3RhY2sgaXMgXCJkb0l0XCIgdGhlbiB0aGUgc3RhdGVtZW50TGluZXMgYXJlXG4gICAgICAgICAgICAvLyBsb2NhdGVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHRleHQsIG5vdCB0aGUgc2NyaXB0LCBwcm9wZXJ0eSBhbmRcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdGhlIGVycm9yIHRvIGJlIG1hcmtlZCB1cCBpbiB0aGUgZmllbGQgdGV4dGFyZWFcbiAgICAgICAgICAgIGlmKGV4ZWN1dGlvblN0YWNrWzBdICYmIGV4ZWN1dGlvblN0YWNrWzBdLm1lc3NhZ2VOYW1lID09IFwiZG9JdFwiKXtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBleGVjdXRpb25TdGFja1swXS5wYXJ0O1xuICAgICAgICAgICAgICAgIHRleHQgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChvcmlnaW5hbFNlbmRlck1vZGVsLCAndGV4dCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb3JpZ2luYWxTZW5kZXJNb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKG9yaWdpbmFsU2VuZGVyTW9kZWwsICdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICBsZXQgc2NyaXB0RWRpdG9yID0gd2luZG93LlN5c3RlbS5maW5kU2NyaXB0RWRpdG9yQnlUYXJnZXRJZChvcmlnaW5hbFNlbmRlci5pZCk7XG4gICAgICAgICAgICAgICAgaWYoIXNjcmlwdEVkaXRvcil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5TY3JpcHRFZGl0b3Iob3JpZ2luYWxTZW5kZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRFZGl0b3IgPSB3aW5kb3cuU3lzdGVtLmZpbmRTY3JpcHRFZGl0b3JCeVRhcmdldElkKG9yaWdpbmFsU2VuZGVyLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoc2NyaXB0RWRpdG9yKXtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2NyaXB0RWRpdG9yLm1vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gU29ydCB0aGlzIG91dFxuICAgICAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dExpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBvZmZlbmRpbmcgY29tbWFuZCB0ZXh0IGxpbmUgd2l0aCBhbiBlcnJvciBtYXJrZXJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0TGluZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmKGxpbmUubWF0Y2gocmVnZXgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IGxpbmUgKz0gYCAtLTw8PFtNZXNzYWdlTm90VW5kZXJzdG9vZDogY29tbWFuZDsgY29tbWFuZE5hbWU6IFwiJHtjb21tYW5kTmFtZX1cIl1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0TGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwidGV4dFwiLCB0ZXh0KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmluYWxseSBvcGVuIHRoZSBkZWJ1Z2dlciAob3IgY3VycmVudCB2ZXJzaW9uIHRoZXJlb2YpXG4gICAgICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIGEgYml0IGRhbmdlcm91cywgYi9jIGlmIHRoZSBTeXN0ZW0gZG9lc24ndFxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBgb3BlbkRlYnVnZ2VyYCBjb21tYW5kIGFueXdoZXJlIGl0IHdpbGwgdGhyb3dcbiAgICAgICAgICAgIC8vIGEgTU5VIGVycm9yLCB3aGljaCB3aWxsIHRoZW4gaW52b2tlIHRoaXMgaGFuZGxlciBjdWFzaW5nXG4gICAgICAgICAgICAvLyBhbiBpbmZpbml0ZSBsb29wIVxuICAgICAgICAgICAgdGhpcy5fb3BlbkRlYnVnZ2VyKG9yaWdpbmFsU2VuZGVyLmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYW5Eb0l0U0NyaXB0KHNjcmlwdCl7XG4gICAgICAgIC8vIGNsZWFuIHVwIHRoZSBEb0l0IHNjcmlwdCBieSByZW1vdmluZyB0aGUgaGFuZGxlclxuICAgICAgICAvLyBuZXdsaW5lcywgdGFicyBhbmQgc3BhY2VzXG4gICAgICAgIHNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlKFwib24gZG9JdFwiLCBcIlwiKTtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoXCJlbmQgZG9JdFwiLCBcIlwiKTtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoL15bXFxuXFx0IF0rLywgXCJcIik7XG4gICAgICAgIHNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlKC9bXFxuXFx0IF0rJC8sIFwiXCIpO1xuICAgICAgICByZXR1cm4gc2NyaXB0O1xuICAgIH0sXG5cbiAgICBfb3BlblNjcmlwdEVkaXRvcjogZnVuY3Rpb24ocGFydElkKXtcbiAgICAgICAgbGV0IHRhcmdldCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3BhcnRJZF07XG4gICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgIFwiY29tbWFuZE5hbWVcIjogXCJvcGVuU2NyaXB0RWRpdG9yXCIsXG4gICAgICAgICAgICBhcmdzOiBbcGFydElkXVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UobXNnLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICBfb3BlbkdyYW1tYXI6IGZ1bmN0aW9uKHBhcnRJZCwgcnVsZU5hbWUpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbcGFydElkXTtcbiAgICAgICAgbGV0IHN0YXRlbWVudExpbmVzID0gW1xuICAgICAgICAgICAgJ2lmIHRoZXJlIGlzIG5vdCBhIGZpZWxkIFwiU2ltcGxlVGFsa1wiIG9mIGN1cnJlbnQgY2FyZCcsXG4gICAgICAgICAgICAndGhlbicsXG4gICAgICAgICAgICAnYWRkIGZpZWxkIFwiU2ltcGxlVGFsa1wiIHRvIGN1cnJlbnQgY2FyZCcsXG4gICAgICAgICAgICAndGVsbCBmaWVsZCBcIlNpbXBsZVRhbGtcIiBvZiBjdXJyZW50IGNhcmQgdG8gc2V0IFwiZWRpdGFibGVcIiB0byBmYWxzZScsXG4gICAgICAgICAgICAnU2ltcGxlVGFsaycsXG4gICAgICAgICAgICAndGVsbCBmaWVsZCBcIlNpbXBsZVRhbGtcIm9mIGN1cnJlbnQgY2FyZCB0byBzZXQgXCJ0ZXh0XCIgdG8gaXQnLFxuICAgICAgICAgICAgJ2VuZCBpZidcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IHNjcmlwdCA9IGBvbiBkb0l0XFxuICAgJHtzdGF0ZW1lbnRMaW5lcy5qb2luKCdcXG4nKX1cXG5lbmQgZG9JdGA7XG4gICAgICAgIHRhcmdldC5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbXBpbGVcIixcbiAgICAgICAgICAgICAgICBjb2RlU3RyaW5nOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHRhcmdldC5pZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICApO1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiZG9JdFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gQXQgdGhlIG1vbWVudCB0aGlzIHNpbXBseSBvcGVucyBhIHN0LXdpbmRvdyBzdC1maWVsZCB3aXRoXG4gICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIGF2YWlsYWJsZSBjb21tYW5kcyBmb3Igc2FpZCBwYXJ0c1xuICAgIF9vcGVuRGVidWdnZXI6IGZ1bmN0aW9uKHBhcnRJZCl7XG4gICAgICAgIGxldCB0YXJnZXQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtwYXJ0SWRdO1xuICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBcImNvbW1hbmROYW1lXCI6IFwib3BlbkRlYnVnZ2VyXCIsXG4gICAgICAgICAgICBhcmdzOiBbcGFydElkXVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuc2VuZE1lc3NhZ2UobXNnLCB0YXJnZXQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgZXJyb3JIYW5kbGVyLFxuICAgIGVycm9ySGFuZGxlciBhcyBkZWZhdWx0XG59O1xuIiwiY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5jb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuY29uc3Qgc2NhbGVEaW0gPSAoZGltKSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSAwLjc7XG4gICAgY29uc3Qgc3RyaWRlID0gMTY7XG4gICAgY29uc3QgZXZlblJlcyA9IGRpbSAqIHNjYWxlIC0gMTtcbiAgICByZXR1cm4gZXZlblJlcyAtIChldmVuUmVzICUgc3RyaWRlKSArIDE7XG59O1xuXG5jb25zdCBkZXRlY3RIYW5kcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IHNjYWxlRGltKGNhbnZhcy53aWR0aCk7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gc2NhbGVEaW0oY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjb25zdCBpbWFnZSA9IHRmLnRpZHkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGYuZnJvbVBpeGVscyhjYW52YXMpLnJlc2l6ZUJpbGluZWFyKFtzY2FsZWRIZWlnaHQsIHNjYWxlZFdpZHRoXSkuZXhwYW5kRGltcygwKTtcbiAgICB9KTtcbiAgICBjb25zdCBbc2NvcmVzLCB0Ym94ZXNdID0gYXdhaXQgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uTW9kZWwuZXhlY3V0ZUFzeW5jKGltYWdlKTtcbiAgICBpbWFnZS5kaXNwb3NlKCk7XG4gICAgY29uc3QgaGFuZHNEZXRlY3RlZCA9IHRmLnRpZHkoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gdGYuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb24oXG4gICAgICAgICAgICB0Ym94ZXMucmVzaGFwZShbdGJveGVzLnNoYXBlWzFdLCB0Ym94ZXMuc2hhcGVbM11dKSxcbiAgICAgICAgICAgIHNjb3Jlcy5yZXNoYXBlKFtzY29yZXMuc2hhcGVbMV1dKSxcbiAgICAgICAgICAgIDIwLFxuICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgMC44NSkuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGJveGVzID0gW107XG4gICAgICAgIHZhciBpZHg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWR4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgICAgIHZhciBzY29yZSA9IHNjb3Jlcy5nZXQoMCwgaWR4LCAwKTtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG9yZGVyIGlzIFttaW5ZLCBtaW5YLCBtYXhZLCBtYXhYXSBzbyB3ZSByZW9yZGVyLlxuICAgICAgICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IFt0Ym94ZXMuZ2V0KDAsIGlkeCwgMCwgMSksIHRib3hlcy5nZXQoMCwgaWR4LCAwLCAwKV0sXG4gICAgICAgICAgICAgICAgbG93ZXJSaWdodDogW3Rib3hlcy5nZXQoMCwgaWR4LCAwLCAzKSwgdGJveGVzLmdldCgwLCBpZHgsIDAsIDIpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJveGVzLnB1c2goe3Njb3JlOiBzY29yZSwgYm94OiBib3h9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2JveGVzOiBib3hlcywgdGltZXN0YW1wOiBEYXRlLm5vdygpfTtcbiAgICB9KTtcbiAgICBzY29yZXMuZGlzcG9zZSgpO1xuICAgIHRib3hlcy5kaXNwb3NlKCk7XG4gICAgaWYgKGhhbmRzRGV0ZWN0ZWQuYm94ZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGlmIChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRldGVjdEhhbmRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJveCA9IGhhbmRzRGV0ZWN0ZWQuYm94ZXNbMF0uYm94O1xuICAgIGNvbnN0IFt4MSwgeTFdID0gYm94LnVwcGVyTGVmdDtcbiAgICBjb25zdCBbeDIsIHkyXSA9IGJveC5sb3dlclJpZ2h0O1xuICAgIGNvbnN0IGFyZWEgPSB7YXJlYTogKHgyIC0geDEpICogKHkyIC0geTEpLCB0aW1lc3RhbXA6IERhdGUubm93KCl9O1xuICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzID0gW10uY29uY2F0KGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzLnNsaWNlKC0yKSwgW2FyZWFdKTtcbiAgICAvLyBVcGRhdGUgaGFuZCBsb2NhdGlvblxuICAgIGNvbnN0IHZ3ID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDAsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApXG4gICAgY29uc3QgdmggPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IDAsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKVxuICAgIGNvbnN0IHAgPSBbMC41ICogKHgxICsgeDIpICogdncsIDAuNSAqICh5MSArIHkyKSAqIHZoXTtcbiAgICBoYW5kSW50ZXJmYWNlLnBvc2l0aW9ucyA9IFtdLmNvbmNhdChoYW5kSW50ZXJmYWNlLnBvc2l0aW9ucy5zbGljZSgtMiksIFtwXSk7XG4gICAgdmFyIHRhcmdldCA9IGhhbmRJbnRlcmZhY2UudGFyZ2V0RWxlbWVudDtcbiAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHRhcmdldCA9IGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIGF2ZXJhZ2UgcG9zaXRpb25cbiAgICBjb25zdCBbcDEsIHAyLCBwM10gPSBoYW5kSW50ZXJmYWNlLnBvc2l0aW9ucztcbiAgICBjb25zdCBbYXAxLCBhcDJdID0gWygxLzMpKihwMVswXSArIHAyWzBdICsgcDNbMF0pLCAoMS8zKSoocDFbMV0gKyBwMlsxXSArIHAzWzFdKV07XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGFyZ2V0LCBcImxlZnRcIiwgYXAxKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0YXJnZXQsIFwidG9wXCIsIGFwMik7XG4gICAgLy8gRXh0cmFjdCBhcmVhIGluZm9ybWF0aW9uIHdpdGhvdXQgYW55IHRpbWVzdGFtcHNcbiAgICB2YXIganVzdEFyZWFzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25BcmVhcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBqdXN0QXJlYXMucHVzaChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25BcmVhc1tpXS5hcmVhKTtcbiAgICB9XG4gICAgdmFyIGp1c3RBcmVhcyA9IFtdLmNvbmNhdChBcnJheSgzIC0ganVzdEFyZWFzLmxlbmd0aCkuZmlsbCgwKSwganVzdEFyZWFzKTtcbiAgICAvLyBDaGVjayBpZiBoYW5kIGlzIHB1c2hpbmcgaW5cbiAgICBjb25zdCBbYTEsIGEyLCBhM10gPSBqdXN0QXJlYXM7XG4gICAgY29uc3QgYXZlQXJlYSA9ICgxLzMpICogKGExICsgYTIgKyBhMyk7XG4gICAgaWYgKGF2ZUFyZWEgPiAwLjI1KSB7XG4gICAgICAgIGlmICghaGFuZEludGVyZmFjZS5oYW5kTWFza2VkKSB7XG4gICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmhhbmRNYXNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGhhbmRJbnRlcmZhY2UuaGFuZE1hc2tlZCA9IGZhbHNlOyB9LCAzMDAwKTtcbiAgICAgICAgICAgIGlmIChoYW5kSW50ZXJmYWNlLnRhcmdldEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VzdFZpZXcgPSBmaW5kQ2xvc2VzdFZpZXcoW3AxLCBwMl0pO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0VmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmxlbmluSGFuZC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGhhbmRJbnRlcmZhY2UubGVuaW5IYW5kLCBcImhpZGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UudGFyZ2V0RWxlbWVudCA9IGNsb3Nlc3RWaWV3Lm1vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZEludGVyZmFjZS5sZW5pbkhhbmQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChoYW5kSW50ZXJmYWNlLmxlbmluSGFuZCwgXCJoaWRlXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBoYW5kSW50ZXJmYWNlLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGV0ZWN0SGFuZHMpO1xuICAgIH1cbn07XG5cbmNvbnN0IGZpbmRDbG9zZXN0VmlldyA9IChwb2ludCkgPT4ge1xuICAgIGxldCB2aWV3cyA9IFtdO1xuICAgIHdpbmRvdy5TeXN0ZW0uZ2V0Q3VycmVudENhcmRNb2RlbCgpLnN1YnBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgbGV0IHBhcnRWaWV3cyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZChwYXJ0LmlkKTtcbiAgICAgICAgcGFydFZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXdzLnB1c2godmlldyk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgdmFyIFtjbG9zZXN0RGlzdCwgY2xvc2VzdFZpZXddID0gW0luZmluaXR5LCBudWxsXTtcbiAgICB2aWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgIGxldCB2aWV3RGlzdCA9IGRpc3QocG9pbnQsIGdldFZlcnRpY2VzKHZpZXcpKTtcbiAgICAgICAgaWYgKHZpZXdEaXN0IDwgY2xvc2VzdERpc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gdmlld0Rpc3Q7XG4gICAgICAgICAgICBjbG9zZXN0VmlldyA9IHZpZXc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvc2VzdFZpZXc7XG59XG5cbi8vIGh0dHBzOi8vYWFyb25zbWl0aC5vbmxpbmUvZWFzaWx5LWxvYWQtYW4tZXh0ZXJuYWwtc2NyaXB0LXVzaW5nLWphdmFzY3JpcHQvXG5jb25zdCBsb2FkU2NyaXB0ID0gc3JjID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy50ZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVuc29yZmxvd2pzIGFscmVhZHkgbG9hZGVkXCIpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwibG9hZGluZyB0ZW5zb3JmbG93anNcIik7XG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kKHNjcmlwdCk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBsb2FkSGFuZERldGVjdGlvbk1vZGVsID0gKCkgPT4ge1xuICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvbkFyZWFzID0gW107XG4gICAgbG9hZFNjcmlwdChcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHRlbnNvcmZsb3cvdGZqc0AwLjEzLjUvZGlzdC90Zi5qc1wiKS50aGVuKCgpID0+IHtcbiAgICAgICAgd2luZG93LnRmLmxvYWRGcm96ZW5Nb2RlbChcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9oYW5kdHJhY2tqcy9tb2RlbHMvd2ViL3NzZGxpdGVtb2JpbGVuZXR2Mi90ZW5zb3JmbG93anNfbW9kZWwucGJcIixcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9oYW5kdHJhY2tqcy9tb2RlbHMvd2ViL3NzZGxpdGVtb2JpbGVuZXR2Mi93ZWlnaHRzX21hbmlmZXN0Lmpzb25cIlxuICAgICAgICApLnRoZW4obW9kZWwgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJoYW5kIGRldGVjdGlvbiBtb2RlbCBsb2FkZWRcIik7XG4gICAgICAgICAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25Nb2RlbCA9IG1vZGVsO1xuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiB0cnVlIH0pO1xuICAgICAgICB9KS50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gdmlkZW8ucGxheSgpO1xuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmlkZW8gc3RhcnRlZFwiKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC0xLCAwLCAwLCAxLCBjYW52YXMud2lkdGgsIDApOyAvLyBNaXJyb3IgaW5jb21pbmcgdmlkZW9cbiAgICAgICAgICAgIGhhbmRJbnRlcmZhY2UuaGFuZERldGVjdGlvblJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgaGFuZEludGVyZmFjZS5sZW5pbkhhbmQgPSB3aW5kb3cuU3lzdGVtLm5ld01vZGVsKCdpbWFnZScsIHdpbmRvdy5TeXN0ZW0uZ2V0V29ybGRTdGFja01vZGVsKCkuaWQsIFwiL2ltYWdlcy9sZW5pbkhhbmQucG5nXCIpO1xuICAgICAgICAgICAgaGFuZEludGVyZmFjZS50YXJnZXRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGV0ZWN0SGFuZHMpO1xuICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciBsb2FkaW5nIGhhbmQgZGV0ZWN0aW9uIG1vZGVsXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmNvbnN0IHVubG9hZEhhbmREZXRlY3Rpb25Nb2RlbCA9ICgpID0+IHtcbiAgICBoYW5kSW50ZXJmYWNlLmhhbmREZXRlY3Rpb25SdW5uaW5nID0gZmFsc2U7XG4gICAgd2luZG93LlN5c3RlbS5kZWxldGVNb2RlbChoYW5kSW50ZXJmYWNlLmxlbmluSGFuZC5pZClcbiAgICBoYW5kSW50ZXJmYWNlLmxlbmluSGFuZCA9IG51bGw7XG4gICAgdmlkZW8ucGF1c2UoKTtcbiAgICBjb25zdCB0cmFja3MgPSB2aWRlby5zcmNPYmplY3QuZ2V0VHJhY2tzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhY2tzW2ldLnN0b3AoKTtcbiAgICB9XG4gICAgdmlkZW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICBjb25zb2xlLmxvZyhcInZpZGVvIHN0b3BwZWRcIik7XG4gICAgaGFuZEludGVyZmFjZS5oYW5kRGV0ZWN0aW9uTW9kZWwgPSBudWxsO1xuICAgIGNvbnNvbGUubG9nKFwidW5sb2FkaW5nIGhhbmQgZGV0ZWN0aW9uIG1vZGVsXCIpO1xufVxuXG5jb25zdCBnZXRWZXJ0aWNlcyA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdXBwZXJMZWZ0ID0gW3JlY3QueCwgcmVjdC55XTtcbiAgICBjb25zdCB1cHBlclJpZ2h0ID0gW3JlY3QueCArIHJlY3Qud2lkdGgsIHJlY3QueV07XG4gICAgY29uc3QgbG93ZXJMZWZ0ID0gW3JlY3QueCwgcmVjdC55ICsgcmVjdC5oZWlnaHRdO1xuICAgIGNvbnN0IGxvd2VyUmlnaHQgPSBbcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55ICsgcmVjdC5oZWlnaHRdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwcGVyTGVmdDogdXBwZXJMZWZ0LFxuICAgICAgICB1cHBlclJpZ2h0OiB1cHBlclJpZ2h0LFxuICAgICAgICBsb3dlckxlZnQ6IGxvd2VyTGVmdCxcbiAgICAgICAgbG93ZXJSaWdodDogbG93ZXJSaWdodFxuICAgIH07XG59XG5cbmNvbnN0IGRpc3QgPSAocG9pbnQsIHZlcnRpY2VzKSA9PiB7XG4gICAgY29uc3QgW3AxLCBwMl0gPSBwb2ludDtcbiAgICBjb25zdCBbdWwxLCB1bDJdID0gdmVydGljZXMudXBwZXJMZWZ0O1xuICAgIGNvbnN0IFtsbDEsIGxsMl0gPSB2ZXJ0aWNlcy5sb3dlckxlZnQ7XG4gICAgY29uc3QgW3VyMSwgdXIyXSA9IHZlcnRpY2VzLnVwcGVyUmlnaHQ7XG4gICAgY29uc3QgW2xyMSwgbHIyXSA9IHZlcnRpY2VzLmxvd2VyUmlnaHQ7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gICAgLy8gTmV4dCB3ZSBjb21wdXRlIHRoZSB2ZWN0b3IgcG9pbnRpbmcgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGNsb3Nlc3QgcG9pbnRcbiAgICAvLyBvbiB0aGUgcmVjdGFuZ2xlLiBUaGVyZSBhcmUgOSBjYXNlcy4gVGhlIGZpcnN0IGlzIHdoZW4gdGhlIHBvaW5zdCBpc1xuICAgIC8vIGluc2lkZSB0aGUgcmVjdGFuZ2xlLiBUaGUgbmV4dCBmb3VyIGNhc2VzIGFyZSBpZiB0aGUgcG9pbnQgaW4gb25lIG9mXG4gICAgLy8gdGhlIGZvdXIgY29ybmVycyBhbmQgdGhlIGZpbmFsIGZvdXIgY2FzZXMgYXJlIHdoZW4gdGhlIHBvaW50IGlzIG9uIG9uZVxuICAgIC8vIG9mIHRoZSBmb3VyIHNpZGVzLlxuICAgIHZhciBbdjEsIHYyXSA9IFtudWxsLCBudWxsXTtcbiAgICBpZiAoKHVsMSA8PSBwMSkgJiYgKHAxIDw9IGxyMSkgJiYgKHVsMiA8PSBwMikgJiYgKHAyIDw9IGxyMikpIHtcbiAgICAgICAgLy8gQ2FzZSAwOiBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICAgICAgICBbdjEsIHYyXSA9IFswLCAwXTtcbiAgICB9IGVsc2UgaWYgKChwMSA8PSB1bDEpICYmIChwMiA8PSB1bDIpKSB7XG4gICAgICAgIC8vIENhc2UgMTogdXBwZXIgbGVmdFxuICAgICAgICBbdjEsIHYyXSA9IFt1bDEgLSBwMSwgdWwyIC0gcDJdO1xuICAgIH0gZWxzZSBpZiAoKHAxID49IHVyMSkgJiYgKHAyIDw9IHVyMikpIHtcbiAgICAgICAgLy8gQ2FzZSAyOiB1cHBlciByaWdodFxuICAgICAgICBbdjEsIHYyXSA9IFt1cjEgLSBwMSwgdXIyIC0gcDJdO1xuICAgIH0gZWxzZSBpZiAoKHAxIDw9IGxsMSkgJiYgKHAyID49IGxsMikpIHtcbiAgICAgICAgLy8gQ2FzZSAzOiBsb3dlciBsZWZ0XG4gICAgICAgIFt2MSwgdjJdID0gW2xsMSAtIHAxLCBsbDIgLSBwMl07XG4gICAgfSBlbHNlIGlmICgocDEgPj0gbHIxKSAmJiAocDIgPj0gbHIyKSkge1xuICAgICAgICAvLyBDYXNlIDQ6IGxvd2VyIHJpZ2h0XG4gICAgICAgIFt2MSwgdjJdID0gW2xyMSAtIHAxLCBscjIgLSBwMl07XG4gICAgfSBlbHNlIGlmIChwMSA8PSB1bDEpIHtcbiAgICAgICAgLy8gQ2FzZSA1OiBzaWRlIGxlZnRcbiAgICAgICAgW3YxLCB2Ml0gPSBbdWwxIC0gcDEsIDBdO1xuICAgIH0gZWxzZSBpZiAocDEgPj0gbHIxKSB7XG4gICAgICAgIC8vIENhc2UgNjogc2lkZSByaWdodFxuICAgICAgICBbdjEsIHYyXSA9IFtscjEgLSBwMSwgMF07XG4gICAgfSBlbHNlIGlmIChwMiA8PSB1bDIpIHtcbiAgICAgICAgLy8gQ2FzZSA3OiBzaWRlIHRvcFxuICAgICAgICBbdjEsIHYyXSA9IFswLCB1bDIgLSBwMl07XG4gICAgfSBlbHNlIGlmIChwMiA+PSBscjIpIHtcbiAgICAgICAgLy8gQ2FzZSA4OiBzaWRlIGJvdHRvbVxuICAgICAgICBbdjEsIHYyXSA9IFswLCBscjIgLSBwMl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSA5OiBpbnNpZGVcbiAgICAgICAgW3YxLCB2Ml0gPSBbMCwgMF07XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnNxcnQodjEqdjEgKyB2Mip2Mik7XG59XG5cbmNsYXNzIEhhbmRJbnRlcmZhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhbmREZXRlY3Rpb25Nb2RlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZERldGVjdGlvblJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5pbkhhbmQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRNYXNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kRGV0ZWN0aW9uQXJlYXMgPSBbXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbWzAsIDBdLCBbMCwgMF0sIFswLCAwXV07XG4gICAgICAgIC8vIFhYWCAtIE9ubHkgaGVyZSB0byBpZ25vcmUgdGhlIHRlbnNvcmZsb3cgd2FybmluZ3NcbiAgICAgICAgY29uc29sZS53YXJuID0gKCkgPT4ge307XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGxvYWRIYW5kRGV0ZWN0aW9uTW9kZWwoKTtcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB1bmxvYWRIYW5kRGV0ZWN0aW9uTW9kZWwoKTtcbiAgICB9XG59XG5cbmNvbnN0IFRlc3RhYmxlcyA9IHtcbiAgICBkaXN0OiBkaXN0XG59XG5cbmNvbnN0IGhhbmRJbnRlcmZhY2UgPSBuZXcgSGFuZEludGVyZmFjZSgpO1xuXG5leHBvcnQge1xuICAgIFRlc3RhYmxlcyxcbiAgICBoYW5kSW50ZXJmYWNlLFxuICAgIGhhbmRJbnRlcmZhY2UgYXMgZGVmYXVsdFxufTtcbiIsImxldCBwYXJ0SWNvbnMgPSB7fTtcblxucGFydEljb25zLndvcmxkID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXdvcmxkXCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjQ0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI5XCIgLz5cbiAgPGxpbmUgeDE9XCIzLjZcIiB5MT1cIjlcIiB4Mj1cIjIwLjRcIiB5Mj1cIjlcIiAvPlxuICA8bGluZSB4MT1cIjMuNlwiIHkxPVwiMTVcIiB4Mj1cIjIwLjRcIiB5Mj1cIjE1XCIgLz5cbiAgPHBhdGggZD1cIk0xMS41IDNhMTcgMTcgMCAwIDAgMCAxOFwiIC8+XG4gIDxwYXRoIGQ9XCJNMTIuNSAzYTE3IDE3IDAgMCAxIDAgMThcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuc3RhY2sgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc3RhY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzJjM2U1MFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiMTIgNCA0IDggMTIgMTIgMjAgOCAxMiA0XCIgLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjQgMTIgMTIgMTYgMjAgMTJcIiAvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiNCAxNiAxMiAyMCAyMCAxNlwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5jYXJkID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXNxdWFyZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMmMzZTUwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxyZWN0IHg9XCI0XCIgeT1cIjRcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuYnV0dG9uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWhhbmQtZmluZ2VyXCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjQ0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk04IDEzdi04LjVhMS41IDEuNSAwIDAgMSAzIDB2Ny41XCIgLz5cbiAgPHBhdGggZD1cIk0xMSAxMS41di0yYTEuNSAxLjUgMCAxIDEgMyAwdjIuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTAuNWExLjUgMS41IDAgMCAxIDMgMHYxLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE3IDExLjVhMS41IDEuNSAwIDAgMSAzIDB2NC41YTYgNiAwIDAgMSAtNiA2aC0yaC4yMDhhNiA2IDAgMCAxIC01LjAxMiAtMi43YTY5Ljc0IDY5Ljc0IDAgMCAxIC0uMTk2IC0uM2MtLjMxMiAtLjQ3OSAtMS40MDcgLTIuMzg4IC0zLjI4NiAtNS43MjhhMS41IDEuNSAwIDAgMSAuNTM2IC0yLjAyMmExLjg2NyAxLjg2NyAwIDAgMSAyLjI4IC4yOGwxLjQ3IDEuNDdcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMud2luZG93ID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXdpbmRvd1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTIgM2MtMy44NjYgMCAtNyAzLjI3MiAtNyA3djEwYTEgMSAwIDAgMCAxIDFoMTJhMSAxIDAgMCAwIDEgLTF2LTEwYzAgLTMuNzI4IC0zLjEzNCAtNyAtNyAtN3pcIiAvPlxuICA8bGluZSB4MT1cIjVcIiB5MT1cIjEzXCIgeDI9XCIxOVwiIHkyPVwiMTNcIiAvPlxuICA8bGluZSB4MT1cIjEyXCIgeTE9XCIzXCIgeDI9XCIxMlwiIHkyPVwiMjFcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuYXJlYSA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zaGFwZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxjaXJjbGUgY3g9XCI1XCIgY3k9XCI1XCIgcj1cIjJcIiAvPlxuICA8Y2lyY2xlIGN4PVwiMTlcIiBjeT1cIjVcIiByPVwiMlwiIC8+XG4gIDxjaXJjbGUgY3g9XCI1XCIgY3k9XCIxOVwiIHI9XCIyXCIgLz5cbiAgPGNpcmNsZSBjeD1cIjE5XCIgY3k9XCIxOVwiIHI9XCIyXCIgLz5cbiAgPGxpbmUgeDE9XCI1XCIgeTE9XCI3XCIgeDI9XCI1XCIgeTI9XCIxN1wiIC8+XG4gIDxsaW5lIHgxPVwiN1wiIHkxPVwiNVwiIHgyPVwiMTdcIiB5Mj1cIjVcIiAvPlxuICA8bGluZSB4MT1cIjdcIiB5MT1cIjE5XCIgeDI9XCIxN1wiIHkyPVwiMTlcIiAvPlxuICA8bGluZSB4MT1cIjE5XCIgeTE9XCI3XCIgeDI9XCIxOVwiIHkyPVwiMTdcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuZmllbGQgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItZm9ybXNcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEyIDNhMyAzIDAgMCAwIC0zIDN2MTJhMyAzIDAgMCAwIDMgM1wiIC8+XG4gIDxwYXRoIGQ9XCJNNiAzYTMgMyAwIDAgMSAzIDN2MTJhMyAzIDAgMCAxIC0zIDNcIiAvPlxuICA8cGF0aCBkPVwiTTEzIDdoN2ExIDEgMCAwIDEgMSAxdjhhMSAxIDAgMCAxIC0xIDFoLTdcIiAvPlxuICA8cGF0aCBkPVwiTTUgN2gtMWExIDEgMCAwIDAgLTEgMXY4YTEgMSAwIDAgMCAxIDFoMVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTcgMTJoLjAxXCIgLz5cbiAgPHBhdGggZD1cIk0xMyAxMmguMDFcIiAvPlxuPC9zdmc+XG5gO1xuXG5wYXJ0SWNvbnMuZHJhd2luZyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1wYWxldHRlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xMiAyMWE5IDkgMCAxIDEgMCAtMThhOSA4IDAgMCAxIDkgOGE0LjUgNCAwIDAgMSAtNC41IDRoLTIuNWEyIDIgMCAwIDAgLTEgMy43NWExLjMgMS4zIDAgMCAxIC0xIDIuMjVcIiAvPlxuICA8Y2lyY2xlIGN4PVwiNy41XCIgY3k9XCIxMC41XCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIC8+XG4gIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiNy41XCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIC8+XG4gIDxjaXJjbGUgY3g9XCIxNi41XCIgY3k9XCIxMC41XCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIC8+XG48L3N2Zz5cbmA7XG5cbnBhcnRJY29ucy5pbWFnZSA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1waG90b1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxsaW5lIHgxPVwiMTVcIiB5MT1cIjhcIiB4Mj1cIjE1LjAxXCIgeTI9XCI4XCIgLz5cbiAgPHJlY3QgeD1cIjRcIiB5PVwiNFwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiM1wiIC8+XG4gIDxwYXRoIGQ9XCJNNCAxNWw0IC00YTMgNSAwIDAgMSAzIDBsNSA1XCIgLz5cbiAgPHBhdGggZD1cIk0xNCAxNGwxIC0xYTMgNSAwIDAgMSAzIDBsMiAyXCIgLz5cbjwvc3ZnPlxuYDtcblxucGFydEljb25zLmdlbmVyaWMgPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcHV6emxlXCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjQ0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMyYzNlNTBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk00IDdoM2ExIDEgMCAwIDAgMSAtMXYtMWEyIDIgMCAwIDEgNCAwdjFhMSAxIDAgMCAwIDEgMWgzYTEgMSAwIDAgMSAxIDF2M2ExIDEgMCAwIDAgMSAxaDFhMiAyIDAgMCAxIDAgNGgtMWExIDEgMCAwIDAgLTEgMXYzYTEgMSAwIDAgMSAtMSAxaC0zYTEgMSAwIDAgMSAtMSAtMXYtMWEyIDIgMCAwIDAgLTQgMHYxYTEgMSAwIDAgMSAtMSAxaC0zYTEgMSAwIDAgMSAtMSAtMXYtM2ExIDEgMCAwIDEgMSAtMWgxYTIgMiAwIDAgMCAwIC00aC0xYTEgMSAwIDAgMSAtMSAtMXYtM2ExIDEgMCAwIDEgMSAtMVwiIC8+XG48L3N2Zz5cbmA7XG5cbmV4cG9ydCB7XG4gICAgcGFydEljb25zLFxuICAgIHBhcnRJY29ucyBhcyBkZWZhdWx0XG59O1xuIiwiLy8gSUQgcmVsYXRlZCB1dGlsaXRpZXNcblxuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5cbi8qKlxuICogSUQgTWFrZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgZ2xvYmFsbHlcbiAqIHVuaXF1ZSBJRCB2YWx1ZXMgZm9yIFBhcnRzIGluIHRoZSBTaW1wbGVUYWxrXG4gKiB3b3JsZC5cbiAqIEhDIHJlcXVpcmVzIHRoYXQgYWxsIFBhcnRzIGhhdmUgdW5pcXVlIGlkcyBhbmRcbiAqIHRoYXQgdGhlc2Ugc2hvdWxkIG5vdCBiZSByZXBlYXRlZCBpbiBhbnkgZ2l2ZW5cbiAqIFwiYXBwbGljYXRpb25cIiBpbnN0YW5jZS5cbiAqIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoYXQgYW4gXCJhcHBsaWNhdGlvblwiIGlzXG4gKiBpbiBvdXIgY29udGV4dCwgYnV0IHJlZ2FyZGxlc3Mgd2UgY2FuIHVzZSB0aGlzXG4gKiBtb2R1bGUgYXMgYSBkcm9wIGluIHJlcGxhY2VtZW50LCBpbXBsZW1lbnRpbmdcbiAqIFVVSURzIG9yIFVSTHMgb3Igd2hhdGV2ZXIgd2Ugd2FudC5cbiAqIEZvciBub3cgd2UganVzdCBpbmNyZW1lbnQgYW4gaW50ZWdlci5cbiAqL1xuY29uc3QgaWRNYWtlciA9IHtcbiAgICBuZXc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBpZCA9IHV1aWR2NCgpO1xuICAgICAgICByZXR1cm4gaWQucmVwbGFjZSgvLS9nLCAnJyk7XG4gICAgfVxufTtcblxuLyogSUQgY2hlY2tlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gaWQgaXNcbiAqIGlzIHZhbGlkIGFuZCByZXR1cm5pbmcgaXQgaWYgc29cbiAqL1xuY29uc3QgaXNWYWxpZElkID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZihpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkIHx8IGlkID09PSBcIlwiKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZihpZC5sZW5ndGggIT0gMzIgfHwgaWQubWF0Y2goJ1thLXowLTldKicpWzBdLmxlbmd0aCAhPSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydCB7XG4gICAgaWRNYWtlcixcbiAgICBpc1ZhbGlkSWQsXG4gICAgaWRNYWtlciBhcyBkZWZhdWx0XG59O1xuIiwiY29uc3QgbWVycmlhbVNpbVNjb3JlID0gYXN5bmMgKHNlbmRlciwgZG9jSWQpID0+IHtcbiAgICBjb25zdCB1cmwgPSBcImh0dHBzOi8vcGF0ZW50cy5tZXJyaWFtdGVjaC5jb20vX2FwaS9tZXJyaWFtL1wiXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgXCJmaWVsZHNcIjogW1xuICAgICAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICAgICAgXCJkYXRlX3B1YmxcIlxuICAgICAgICBdLFxuICAgICAgICBcIndlaWdodHNcIjoge1xuICAgICAgICAgICAgXCJtZXJyaWFtXCI6MC43LFxuICAgICAgICAgICAgXCJkYXRlXCI6MC4zLFxuICAgICAgICAgICAgXCJoaWVyYXJjaHlcIjowLjFcbiAgICAgICAgfSxcbiAgICAgICAgXCJkb2NfaWRzXCI6IFtcbiAgICAgICAgICAgIGRvY0lkXG4gICAgICAgIF0sXG4gICAgICAgIFwibGltaXRcIjogNX1cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImhlYWRlcnNcIjoge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJib2R5XCI6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gICAgfVxuICAgIGZldGNoKHVybCwgcGFyYW1zKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICByZXR1cm4gZGF0YS5qc29uKCk7XG4gICAgfSkudGhlbihqc29uID0+IHtcbiAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtZXJyaWFtcmVzdWx0JyxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICBzZW5kZXIuc2VuZE1lc3NhZ2UobXNnLCBzZW5kZXIpO1xuICAgIH0pO1xufVxuXG5leHBvcnQge1xuICAgIG1lcnJpYW1TaW1TY29yZSxcbiAgICBtZXJyaWFtU2ltU2NvcmUgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogU2VyaWFsaXphdGlvbiBhbmQgRGVzZXJpYWxpemF0aW9uIFV0aWxpdHkgQ2xhc3Nlc1xuICovXG5pbXBvcnQgaWRNYWtlciBmcm9tICcuL2lkLmpzJztcblxuY29uc3QgdmVyc2lvbiA9IFwiMC4wLjJcIjtcblxuY2xhc3MgU1REZXNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGFTeXN0ZW0pe1xuICAgICAgICB0aGlzLnN5c3RlbSA9IGFTeXN0ZW07XG5cbiAgICAgICAgLy8gVGhlc2UgY2FjaGVzIGFyZSB1c2VkIGR1cmluZyB0aGUgcHJvY2Vzc1xuICAgICAgICAvLyBhcyBvcHRpbWl6YXRpb25zXG4gICAgICAgIHRoaXMuX21vZGVsQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc3VicGFydE1hcENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2lkQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLl9wcm9wc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3ZpZXdzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0Q2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fcm9vdHNDYWNoZSA9IFtdO1xuXG4gICAgICAgIC8vIFRoZSB0YXJnZXRJZCBpcyB0aGUgaWQgb2ZcbiAgICAgICAgLy8gdGhlIFBhcnQgdGhhdCB3ZSB3aXNoIHRvIGFwcGVuZCBhbnlcbiAgICAgICAgLy8gZGVzZXJpYWxpemVkIHN1YnBhcnQgdHJlZSBpbnRvLlxuICAgICAgICAvLyBCeSBkZWZhdWx0IHdlIGFzc3VtZSB0aGUgd2hvbGUgc3lzdGVtLFxuICAgICAgICAvLyBpZSBmdWxsIGRlc2VyaWFsaXphdGlvbi5cbiAgICAgICAgdGhpcy50YXJnZXRJZCA9ICdzeXN0ZW0nO1xuICAgICAgICAvLyB0aGUgcm9vdCBpZCBpcyB0aGUgaWQgb2YgdGhlIHJvb3QgcGFydCBpbnN0YW5jZVxuICAgICAgICAvLyBiZWluZyBhdHRhY2hlZFxuICAgICAgICB0aGlzLnJvb3RJZCA9IG51bGw7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gdGhpcy5kZXNlcmlhbGl6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplRGF0YSA9IHRoaXMuZGVzZXJpYWxpemVEYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemVQYXJ0ID0gdGhpcy5kZXNlcmlhbGl6ZVBhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hdHRhY2hTdWJwYXJ0cyA9IHRoaXMuYXR0YWNoU3VicGFydHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzID0gdGhpcy5zZXRQcm9wZXJ0aWVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlVmlldyA9IHRoaXMuY3JlYXRlVmlldy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmF0dGFjaFZpZXcgPSB0aGlzLmF0dGFjaFZpZXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRWaWV3TW9kZWwgPSB0aGlzLnNldFZpZXdNb2RlbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVQYXJ0U2NyaXB0ID0gdGhpcy5jb21waWxlUGFydFNjcmlwdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2hXb3JsZCA9IHRoaXMucmVmcmVzaFdvcmxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXBwZW5kV29ybGQgPSB0aGlzLmFwcGVuZFdvcmxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUGFydHNUb1N5c3RlbSA9IHRoaXMuYWRkUGFydHNUb1N5c3RlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVTY3JpcHRzID0gdGhpcy5jb21waWxlU2NyaXB0cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEZsYXR0ZW5lZFBhcnRUcmVlID0gdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE1vZGVsQ2xhc3MgPSB0aGlzLmdldE1vZGVsQ2xhc3MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVJZCA9IHRoaXMuaGFuZGxlSWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yID0gdGhpcy50aHJvd0Vycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmx1c2hDYWNoZXMgPSB0aGlzLmZsdXNoQ2FjaGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hWaWV3QWRkZWQgPSB0aGlzLmRpc3BhdGNoVmlld0FkZGVkLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgZGVzZXJpYWxpemUoYUpTT05TdHJpbmcpe1xuICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKGFKU09OU3RyaW5nKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3lzdGVtLnBhcnRzQnlJZFt0aGlzLnRhcmdldElkXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVEYXRhKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIGRlc2VyaWFsaXplZCBQYXJ0cyB0byB0aGUgU3lzdGVtIGRpY3QsXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkaW5nIHRoZSBuZXcgV29ybGQuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQYXJ0c1RvU3lzdGVtKHRoaXMuX2luc3RhbmNlQ2FjaGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDb21waWxlIHRoZSBzY3JpcHRzIG9uICphbGwqIGRlc2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIC8vIHBhcnRzXG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlU2NyaXB0cyh0aGlzLl9pbnN0YW5jZUNhY2hlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSByb290IFBhcnQgaW50byB3aGF0ZXZlclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBpdCBzaG91bGQgZ28gaW50by5cbiAgICAgICAgICAgICAgICBsZXQgcm9vdFBhcnQgPSB0aGlzLnJvb3RQYXJ0c1swXTtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdFZpZXcgPSB0aGlzLnJvb3RWaWV3c1swXTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRhcmdldElkID09ICdzeXN0ZW0nKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoV29ybGQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYWRkUGFydChyb290UGFydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgYXBwZW5kIHRoZSBQYXJ0VmlldyByb290IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBpdCBzaG91bGQgZ28gaW4gdGhlIHZpZXcgdHJlZS5cbiAgICAgICAgICAgICAgICBpZih0aGlzLnRhcmdldElkID09ICdzeXN0ZW0nKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRXb3JsZCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3RoaXMudGFyZ2V0SWR9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZpZXcuYXBwZW5kQ2hpbGQocm9vdFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVmlld0FkZGVkKHJvb3RWaWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXNlcmlhbGl6ZURhdGEoKXtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDYWNoZXMoKTtcbiAgICAgICAgICAgIC8vIEZpcnN0LCB3ZSBlbnN1cmUgdGhhdCB0aGUgdGFyZ2V0IHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgZGVzZXJpYWxpemluZyBpbnRvIGFjdHVhbGx5IGV4aXN0c1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3lzdGVtLnBhcnRzQnlJZFt0aGlzLnRhcmdldElkXTtcbiAgICAgICAgICAgIGlmKCF0YXJnZXQgJiYgdGhpcy50YXJnZXRJZCAhPSAnc3lzdGVtJyl7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBUYXJnZXQgaWQgJHt0aGlzLnRhcmdldElkfSBkb2VzIG5vdCBleGlzdCBpbiBTeXN0ZW1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2Vjb25kLCB3ZSBjcmVhdGUgaW5zdGFuY2VzIG9mIGFsbCBtb2RlbHMgaW4gdGhlIHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBkbyBub3QgeWV0IGF0dGFjaCB0aGVpciBzdWJwYXJ0cy5cbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5kYXRhLnBhcnRzKS5mb3JFYWNoKHBhcnREYXRhID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplUGFydChPYmplY3QuYXNzaWduKHt9LCBwYXJ0RGF0YSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0YXJnZXRzXG4gICAgICAgICAgICBmb3IgKGxldCBtb2RlbElkIGluIHRoaXMuX3Byb3BzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHMgPSB0aGlzLl9wcm9wc0NhY2hlW21vZGVsSWRdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy50YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgb2xkSWQgaW4gdGhpcy5faWRDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0lkID0gdGhpcy5faWRDYWNoZVtvbGRJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMudGFyZ2V0ID09PSAncGFydCBpZCAnICsgb2xkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy50YXJnZXQgPSAncGFydCBpZCAnICsgbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgc2NyaXB0c1xuICAgICAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLl9zY3JpcHRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGxldCBzY3JpcHQgPSB0aGlzLl9zY3JpcHRDYWNoZVttb2RlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0ICE9PSBudWxsICYmIHNjcmlwdC5tYXRjaCgncGFydCBpZCcpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG9sZElkIGluIHRoaXMuX2lkQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJZCA9IHRoaXMuX2lkQ2FjaGVbb2xkSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9sZFJlID0gJ3BhcnQgaWQgJyArIG9sZElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1JlID0gJ3BhcnQgaWQgJyArIG5ld0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NjcmlwdENhY2hlW21vZGVsSWRdLm1hdGNoKG9sZFJlKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1vZGVsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAob2xkUmUsIFwiZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JpcHRDYWNoZVttb2RlbElkXSA9IHNjcmlwdC5yZXBsYWNlKHJlLCBuZXdSZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoaXJkLCB3ZSBnbyB0aHJvdWdoIGVhY2ggY3JlYXRlZCBQYXJ0IGluc3RhbmNlXG4gICAgICAgICAgICAvLyBhbmQgYWRkIGFueSBzdWJwYXJ0cyB0byBpdC4gTm90ZSB0aGF0IHRoaXMgaXMgbm90XG4gICAgICAgICAgICAvLyByZWN1cnNpdmVcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlQ2FjaGUuZm9yRWFjaChwYXJ0SW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoU3VicGFydHMocGFydEluc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGb3J0aCBhbmQgZmlmdGguIENyZWF0ZSBhbmQgYXR0YWNoIHZpZXdzXG4gICAgICAgICAgICAvLyBOb3RlIHRoaXMgaXMgcmVjdXJzaXZlIHRvIHByZXNlcnZlIHRoZSBzdWJwYXJ0ICsgdmlldyBjaGlsZHJlbiBvcmRlclxuICAgICAgICAgICAgbGV0IHJvb3QgPSB0aGlzLl9pbnN0YW5jZUNhY2hlLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQocGFydCwgXCJpZFwiKSA9PSB0aGlzLnJvb3RJZDtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVBbmRBdHRhY2hWaWV3cyhyb290KTtcblxuICAgICAgICAgICAgLy8gU2l4dGgsIHdlIHNldCBhbGwgcHJvcGVydGllcyBvbiBlYWNoIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIFBhcnQgbW9kZWwgZnJvbSB0aGUgZGVzZXJpYWxpemVkIGRhdGEuXG4gICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHVzaW5nIGEgdmlzaXRvciBtZXRob2Qgb24gdGhlIGluc3RhbmNlc1xuICAgICAgICAgICAgLy8gdGhlbXNlbHZlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdGhlIGluLW1lbW9yeSB2aWV3cyB0aGUgYWJpbGl0eSB0b1xuICAgICAgICAgICAgLy8gcmVhY3QgdG8gYW55IGluaXRpYWwgY2hhbmdlcyB0byB0aGVpciBtb2RlbHMuXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZUNhY2hlLmZvckVhY2gocGFydEluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMocGFydEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYW5zbGF0ZSBuZXcgaWRzIHRvIG9sZCBvbmVzXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRJbnN0YW5jZS5uYW1lID09IFwiV29ybGRTdGFja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3b3JsZCA9IHBhcnRJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pZENhY2hlW3dvcmxkLmN1cnJlbnRTdGFja0lkXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydEluc3RhbmNlLm5hbWUgPT0gXCJTdGFja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHBhcnRJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pZENhY2hlW3N0YWNrLmN1cnJlbnRDYXJkSWRdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld01vZGVsKHBhcnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gV2UgZGV0ZXJtaW5lIHdoaWNoIG9mIHRoZSBpbnN0YW5jZXMgaXMgYSBcInJvb3RcIixcbiAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhhdCBpdCBoYXMsIGF0IHRoaXMgcG9pbnQsIG5vIG93bmVyIGluXG4gICAgICAgICAgICAvLyB0aGUgZGVzZXJpYWxpemVkIGRhdGEuIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSByb290c1xuICAgICAgICAgICAgLy8gKGFuZCB0aGVyZWZvcmUgbXVsdGlwbGUgdHJlZXMpIGluIGEgc2luZ2xlIGRlc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgdGhpcy5fcm9vdHNDYWNoZSA9IHRoaXMuX2luc3RhbmNlQ2FjaGUuZmlsdGVyKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuX293bmVyID09IG51bGwgfHwgaW5zdGFuY2UuX293bmVyID09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJbnNlcnRpb24gc2hvdWxkIGJlIGhhbmRsZWQgYnkgY29tcG9zZWRcbiAgICAgICAgICAgIC8vIHByb21pc2VzIGVsc2V3aGVyZSAoc2VlIGltcG9ydHMgYW5kIGRlc2VyaWFsaXplKClcbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlcylcblxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNyZWF0ZUFuZEF0dGFjaFZpZXdzKHBhcnRJbnN0YW5jZSl7XG4gICAgICAgIHRoaXMuY3JlYXRlVmlldyhwYXJ0SW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmF0dGFjaFZpZXcocGFydEluc3RhbmNlKTtcbiAgICAgICAgaWYocGFydEluc3RhbmNlLnN1YnBhcnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBwYXJ0SW5zdGFuY2Uuc3VicGFydHMuZm9yRWFjaCgoc3VicGFydEluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVBbmRBdHRhY2hWaWV3cyhzdWJwYXJ0SW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbXBvcnRGcm9tU2VyaWFsaXphdGlvbihhSlNPTlN0cmluZywgZmlsdGVyRnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKGFKU09OU3RyaW5nKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3lzdGVtLnBhcnRzQnlJZFt0aGlzLnRhcmdldElkXTtcbiAgICAgICAgbGV0IHRhcmdldFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7dGhpcy50YXJnZXRJZH1cIl1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVEYXRhKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgcHJvdmlkZSBhIGZpbHRlciBmdW5jdGlvbiBvdmVyXG4gICAgICAgICAgICAgICAgLy8gYWxsIGRlc2VyaWFsaXplZCBwYXJ0IGluc3RhbmNlcywgcmV0dXJuaW5nIG9ubHlcbiAgICAgICAgICAgICAgICAvLyB0aG9zZSB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGFsbCBTdGFja3MgaW4gdGhlIFdvcmxkU3RhY2suXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlQ2FjaGUuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocm9vdFBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdFBhcnRzLmZvckVhY2gocm9vdFBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxsVHJlZVBhcnRzID0gdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZShyb290UGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFydHNUb1N5c3RlbShhbGxUcmVlUGFydHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByb290UGFydHM7XG5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocm9vdFBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdFBhcnRzLmZvckVhY2gocm9vdFBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxsVHJlZVBhcnRzID0gdGhpcy5nZXRGbGF0dGVuZWRQYXJ0VHJlZShyb290UGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZVNjcmlwdHMoYWxsVHJlZVBhcnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFBhcnRzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyb290UGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICByb290UGFydHMuZm9yRWFjaChyb290UGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlld3NDYWNoZVtyb290UGFydC5pZF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5hZGRQYXJ0KHJvb3RQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Vmlldy5hcHBlbmRDaGlsZCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFZpZXdBZGRlZCh2aWV3KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlc2VyaWFsaXplUGFydChwYXJ0RGF0YSl7XG4gICAgICAgIGxldCBwYXJ0Q2xhc3MgPSB0aGlzLmdldE1vZGVsQ2xhc3MocGFydERhdGEudHlwZSk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBwYXJ0Q2xhc3MoKTtcblxuICAgICAgICAvLyBXZSBjcmVhdGUgYSBuZXcgSUQgZm9yIHRoaXMgcGFydCwgc2luY2Ugd2UgY2Fubm90XG4gICAgICAgIC8vIGd1YXJhbnRlZSBJRCBjbGFzaGVzIHdpdGggdGhlIGV4aXN0aW5nIFN5c3RlbS5cbiAgICAgICAgLy8gRXhjZXB0aW9uIGlzIGlmIHRoZSB1c2VPcmlnaW5hbGlkcyBmbGFnIGlzIHNldCxcbiAgICAgICAgLy8gc3VjaCBhcyBhdCBsb2FkIHRpbWVcbiAgICAgICAgbGV0IHtuZXdJZCwgb2xkSWR9ID0gdGhpcy5oYW5kbGVJZChpbnN0YW5jZSwgcGFydERhdGEpO1xuICAgICAgICBpbnN0YW5jZS5pZCA9IG5ld0lkO1xuICAgICAgICAvLyBjYWNoZSB0aGUgbmV3IHJvb3QgSUQgaWYgdGhpcyBpcyBhIHJvb3QgaW5zdGFuY2VcbiAgICAgICAgaWYodGhpcy5kYXRhLnJvb3RJZCA9PSBvbGRJZCl7XG4gICAgICAgICAgICB0aGlzLnJvb3RJZCA9IG5ld0lkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRvIG91ciBjYWNoZXMgYW5kIGFsc28gdG8gdGhlIFN5c3RlbVxuICAgICAgICB0aGlzLl9pZENhY2hlW29sZElkXSA9IG5ld0lkO1xuICAgICAgICB0aGlzLl9zY3JpcHRDYWNoZVtuZXdJZF0gPSBwYXJ0RGF0YS5wcm9wZXJ0aWVzLnNjcmlwdDtcbiAgICAgICAgdGhpcy5fcHJvcHNDYWNoZVtuZXdJZF0gPSBwYXJ0RGF0YS5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLl9tb2RlbENhY2hlW25ld0lkXSA9IGluc3RhbmNlO1xuICAgICAgICB0aGlzLl9zdWJwYXJ0TWFwQ2FjaGVbbmV3SWRdID0gcGFydERhdGEuc3VicGFydHM7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlQ2FjaGUucHVzaChpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlSWQoYVBhcnQsIHBhcnREYXRhKXtcbiAgICAgICAgbGV0IG5ld0lkLCBvbGRJZDtcbiAgICAgICAgb2xkSWQgPSBwYXJ0RGF0YS5pZDtcbiAgICAgICAgbmV3SWQgPSBhUGFydC5pZDtcbiAgICAgICAgaWYoYVBhcnQudHlwZSAhPT0gJ3dvcmxkJyl7XG4gICAgICAgICAgICBuZXdJZCA9IGlkTWFrZXIubmV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5ld0lkLFxuICAgICAgICAgICAgb2xkSWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhZGRQYXJ0c1RvU3lzdGVtKGFMaXN0T2ZQYXJ0cyl7XG4gICAgICAgIGFMaXN0T2ZQYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0ucGFydHNCeUlkW3BhcnQuaWRdID0gcGFydDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tcGlsZVNjcmlwdHMoYUxpc3RPZlBhcnRzKXtcbiAgICAgICAgYUxpc3RPZlBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVQYXJ0U2NyaXB0KHBhcnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhdHRhY2hTdWJwYXJ0cyhhUGFydCl7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBfc3VicGFydE1hcENhY2hlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGFuIGVudHJ5IG1hcHBpbmcgZnJvbSB0aGlzIGFQYXJ0J3MgKG5ldylcbiAgICAgICAgLy8gaWQgdG8gYW4gYXJyYXkgb2YgaWRzIG9mIGFsc28taW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gc3VicGFydCBtb2RlbHNcbiAgICAgICAgbGV0IHN1YnBhcnRJZHMgPSB0aGlzLl9zdWJwYXJ0TWFwQ2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICBzdWJwYXJ0SWRzLmZvckVhY2goc3VicGFydElkID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdJZCA9IHRoaXMuX2lkQ2FjaGVbc3VicGFydElkXTtcbiAgICAgICAgICAgIGxldCBzdWJwYXJ0TW9kZWwgPSB0aGlzLl9tb2RlbENhY2hlW25ld0lkXTtcbiAgICAgICAgICAgIGlmKCFzdWJwYXJ0TW9kZWwpe1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVBhcnQuYWRkUGFydChzdWJwYXJ0TW9kZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRQcm9wZXJ0aWVzKGFQYXJ0KXtcbiAgICAgICAgbGV0IHByb3BzID0gdGhpcy5fcHJvcHNDYWNoZVthUGFydC5pZF07XG4gICAgICAgIGRlbGV0ZSBwcm9wc1snaWQnXTtcbiAgICAgICAgYVBhcnQuc2V0UHJvcHNGcm9tRGVzZXJpYWxpemVyKHByb3BzLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjcmVhdGVWaWV3KGFQYXJ0KXtcbiAgICAgICAgbGV0IG5ld1ZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgdGhpcy5zeXN0ZW0udGFnTmFtZUZvclZpZXdOYW1lZChhUGFydC50eXBlKVxuICAgICAgICApO1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgcGFydC1pZCBhdHRyaWJ1dGUgc2luY2UgdGhlc2VcbiAgICAgICAgLy8gYXJlIHVzZWQgZm9yIHF1ZXJpZXMgbmVlZGVkIGZvciB0aGluZ3MgbGlrZVxuICAgICAgICAvLyBjdXJyZW50IHN0YWNrIGFuZCBjYXJkXG4gICAgICAgIG5ld1ZpZXcuc2V0QXR0cmlidXRlKFwicGFydC1pZFwiLCBhUGFydC5pZCk7XG4gICAgICAgIHRoaXMuX3ZpZXdzQ2FjaGVbYVBhcnQuaWRdID0gbmV3VmlldztcbiAgICB9XG5cbiAgICBzZXRWaWV3TW9kZWwoYVBhcnQpe1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3ZpZXdzQ2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICB2aWV3LnNldE1vZGVsKGFQYXJ0KTtcbiAgICB9XG4gICAgXG4gICAgYXR0YWNoVmlldyhhUGFydCl7XG4gICAgICAgIGxldCBvd25lciA9IGFQYXJ0Ll9vd25lcjtcbiAgICAgICAgaWYob3duZXIpe1xuICAgICAgICAgICAgbGV0IG93bmVyVmlldyA9IHRoaXMuX3ZpZXdzQ2FjaGVbb3duZXIuaWRdO1xuICAgICAgICAgICAgbGV0IHBhcnRWaWV3ID0gdGhpcy5fdmlld3NDYWNoZVthUGFydC5pZF07XG4gICAgICAgICAgICBvd25lci5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2aWV3Q2hhbmdlZFwiLFxuICAgICAgICAgICAgICAgIGNoYW5nZU5hbWU6IFwic3VicGFydC1uZXdcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbcGFydFZpZXddXG4gICAgICAgICAgICB9LCBvd25lclZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcGlsZVBhcnRTY3JpcHQoYVBhcnQpe1xuICAgICAgICBsZXQgc2NyaXB0U3RyaW5nID0gdGhpcy5fc2NyaXB0Q2FjaGVbYVBhcnQuaWRdO1xuICAgICAgICBpZihzY3JpcHRTdHJpbmcgJiYgc2NyaXB0U3RyaW5nICE9IFwiXCIpe1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0uY29tcGlsZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBpbGUnLFxuICAgICAgICAgICAgICAgIHRhcmdldElkOiBhUGFydC5pZCxcbiAgICAgICAgICAgICAgICBjb2RlU3RyaW5nOiBzY3JpcHRTdHJpbmcsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWZyZXNoV29ybGQoKXtcbiAgICAgICAgLy8gV2UgYXNzdW1lIGEgc2luZ2xlIHJvb3QgcGFydCB3YXMgZGVzZXJpYWxpemVkIGFuZFxuICAgICAgICAvLyBhdHRhY2ggaXQgYXMgdGhlIFdvcmxkIGFjY29yZGluZ2x5XG4gICAgICAgIGxldCBuZXdXb3JsZCA9IHRoaXMucm9vdFBhcnRzWzBdO1xuICAgICAgICBpZihuZXdXb3JsZC50eXBlICE9PSAnd29ybGQnKXtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihgRm91bmQgJHt0aGlzLnJvb3RQYXJ0cy5sZW5ndGh9IHJvb3RzLCBidXQgbm8gd29ybGQhYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddID0gdGhpcy5yb290UGFydHNbMF07XG4gICAgfVxuXG4gICAgYXBwZW5kV29ybGQoKXtcbiAgICAgICAgLy8gV2UgYXNzdW1lIGEgc2luZ2xlIHJvb3QgdmlldyB0aGF0IGlzIGFuIHN0LXdvcmxkLlxuICAgICAgICBsZXQgZm91bmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpO1xuICAgICAgICBpZihmb3VuZCl7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlcGxhY2VDaGlsZCh0aGlzLnJvb3RWaWV3c1swXSwgZm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5wcmVwZW5kKHRoaXMucm9vdFZpZXdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoVmlld0FkZGVkKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJykpO1xuICAgIH1cblxuICAgIGdldEZsYXR0ZW5lZFBhcnRUcmVlKGFQYXJ0LCBsaXN0PVtdKXtcbiAgICAgICAgbGlzdC5wdXNoKGFQYXJ0KTtcbiAgICAgICAgYVBhcnQuc3VicGFydHMuZm9yRWFjaChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RmxhdHRlbmVkUGFydFRyZWUoc3VicGFydCwgbGlzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICB0aHJvd0Vycm9yKG1lc3NhZ2Upe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlc2VyaWFsaXphdGlvbiBFcnJvcjogJHttZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGdldE1vZGVsQ2xhc3MoYVBhcnRUeXBlU3RyKXtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuc3lzdGVtLmF2YWlsYWJsZVBhcnRzW2FQYXJ0VHlwZVN0cl07XG4gICAgICAgIGlmKCFjbHMpe1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBQYXJ0IHR5cGUgXCIke2FQYXJ0VHlwZVN0cn1cIiBkb2VzIG5vdCBleGlzdCBpbiBzeXN0ZW1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xzO1xuICAgIH1cblxuICAgIGZsdXNoQ2FjaGVzKCl7XG4gICAgICAgIHRoaXMuX21vZGVsQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc3VicGFydE1hcENhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2lkQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLl9wcm9wc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX3ZpZXdzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0Q2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fcm9vdHNDYWNoZSA9IFtdO1xuICAgIH1cblxuICAgIGRpc3BhdGNoVmlld0FkZGVkKGFWaWV3KXtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzdC12aWV3LWFkZGVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcGFydFR5cGU6IGFWaWV3Lm1vZGVsLnR5cGUsXG4gICAgICAgICAgICAgICAgcGFydElkOiBhVmlldy5tb2RlbC5pZCxcbiAgICAgICAgICAgICAgICAvL293bmVySWQ6IGFWaWV3Lm1vZGVsLl9vd25lci5pZCB8fCBudWxsXG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgYVZpZXcucGFyZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBnZXQgcm9vdFBhcnRzKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290c0NhY2hlO1xuICAgIH1cblxuICAgIGdldCByb290Vmlld3MoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdFBhcnRzLm1hcChwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3c0NhY2hlW3BhcnQuaWRdO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuY2xhc3MgU1RTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihhU3lzdGVtKXtcbiAgICAgICAgdGhpcy5zeXN0ZW0gPSBhU3lzdGVtO1xuICAgICAgICB0aGlzLl9vYmplY3RDYWNoZSA9IHt9O1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXJpYWxpemVQYXJ0ID0gdGhpcy5zZXJpYWxpemVQYXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmx1c2hDYWNoZXMgPSB0aGlzLmZsdXNoQ2FjaGVzLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgc2VyaWFsaXplKGFSb290UGFydCwgcHJldHR5PXRydWUpe1xuICAgICAgICB0aGlzLmZsdXNoQ2FjaGVzKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgcm9vdElkOiBhUm9vdFBhcnQuaWQsXG4gICAgICAgICAgICB0eXBlOiBhUm9vdFBhcnQudHlwZSxcbiAgICAgICAgICAgIGlkOiBhUm9vdFBhcnQuaWRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgUGFydHMgYW5kXG4gICAgICAgIC8vIHN0b3JlIGluIGZsYXQgbGlzdFxuICAgICAgICB0aGlzLnNlcmlhbGl6ZVBhcnQoYVJvb3RQYXJ0KTtcblxuICAgICAgICAvLyBXZSBzZXQgdGhlIHJlc3VsdCBvYmplY3RzIHBhcnRzXG4gICAgICAgIC8vIGRpY3QgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGNhY2hlXG4gICAgICAgIHJlc3VsdC5wYXJ0cyA9IHRoaXMuX29iamVjdENhY2hlO1xuXG4gICAgICAgIC8vIEZpbmFsbHksIHdlIGNvbnZlcnQgdG8gYSBzdHJpbmcgYW5kXG4gICAgICAgIC8vIHJldHVyblxuICAgICAgICBpZihwcmV0dHkpe1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlcmlhbGl6ZVBhcnQoYVBhcnQpe1xuICAgICAgICAvLyBXZSB1c2UgdGhlIHNlcmlhbGl6ZSBtZXRob2QgYXZhaWxhYmxlIG9uXG4gICAgICAgIC8vIGJhc2UgUGFydHMsIHBhc3NpbmcgaW4gdGhpcyBzZXJpYWxpemVyIGluc3RhbmNlXG4gICAgICAgIC8vIGFzIHRoZSBzb2xlIGFyZ1xuICAgICAgICB0aGlzLl9vYmplY3RDYWNoZVthUGFydC5pZF0gPSBhUGFydC5zZXJpYWxpemUodGhpcyk7XG4gICAgICAgIGFQYXJ0LnN1YnBhcnRzLmZvckVhY2goc3VicGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZVBhcnQoc3VicGFydCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZsdXNoQ2FjaGVzKCl7XG4gICAgICAgIHRoaXMuX29iamVjdENhY2hlID0ge307XG4gICAgfVxufVxuXG5leHBvcnQge1xuICAgIFNUU2VyaWFsaXplcixcbiAgICBTVERlc2VyaWFsaXplclxufTtcbiIsIi8qKlxuICogSGVscGVycyBmb3Igc2V0dGluZyB1cCB2YXJpb3VzXG4gKiBzdHlsZSBwcm9wZXJ0aWVzXG4gKi9cblxuXG4vKipcbiAqIEJhc2ljIHN0eWxlIHByb3BlcnRpZXMgYXJlIHRob3NlXG4gKiBjb21tb24gdG8gYWxsICh2aXN1YWwpIFBhcnRzXG4gKi9cbmNvbnN0IHNpZGVzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuXG5jb25zdCBhZGRCYXNpY1N0eWxlUHJvcHMgPSAodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2JhY2tncm91bmQtdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgMSxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIiwgLy8gd2hpdGUgXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndHJhbnNwYXJlbmN5JyxcbiAgICAgICAgMS4wLFxuICAgICk7XG4gICAgc2lkZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAgICAgYGJvcmRlci0ke3N9LXN0eWxlYCxcbiAgICAgICAgICAgICdzb2xpZCdcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICAgICBgYm9yZGVyLSR7c30td2lkdGhgLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICAgICBgYm9yZGVyLSR7c30tY29sb3JgLFxuICAgICAgICAgICAgXCJyZ2IoMCwgMCwgMClcIiwgLy8gYmxhY2tcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBzaWRlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICAgICBgYm9yZGVyLSR7c30tdHJhbnNwYXJlbmN5YCxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LWxlZnQnLFxuICAgICAgICAwXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnc2hhZG93LXRvcCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctYmx1cicsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctc3ByZWFkJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3NoYWRvdy1jb2xvcicsXG4gICAgICAgIFwicmdiKDIzOCwgMjM4LCAyMzgpXCIsIC8vIGdyZXlcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdzaGFkb3ctdHJhbnNwYXJlbmN5JyxcbiAgICAgICAgMVxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2Nvcm5lci10b3AtbGVmdC1yb3VuZCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdjb3JuZXItdG9wLXJpZ2h0LXJvdW5kJyxcbiAgICAgICAgMFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2Nvcm5lci1ib3R0b20tbGVmdC1yb3VuZCcsXG4gICAgICAgIDBcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdjb3JuZXItYm90dG9tLXJpZ2h0LXJvdW5kJyxcbiAgICAgICAgMFxuICAgICk7XG59O1xuXG4vKipcbiAqIFN0eWxlIHByb3BlcnRpZXMgZm9yIFBhcnRzIHRoYXQgY2FuXG4gKiBiZSBtb3ZlZCBhbmQgdGhhdCBjYW4gaGF2ZSBleHBsaWNpdFxuICogZGltZW5zaW9ucy4gRXhhbXBsZXM6IGJ1dHRvbnMsIGZpZWxkcy5cbiAqIEV4YW1wbGVzIG9mIHRob3NlIHRoYXQgY2FuJ3Q6IENhcmRzLCBTdGFja3NcbiAqL1xuY29uc3QgYWRkUG9zaXRpb25pbmdTdHlsZVByb3BzID0gKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdoaWRlJyxcbiAgICAgICAgZmFsc2UsXG4gICAgKTtcbiAgICAvLyBzZXR0aW5nIHdpZHRoIGFuZCBoZWlnaHQgdG8gbnVsbFxuICAgIC8vIGVmZmVjdGl2ZWx5IGZvcmNlcyB0byB0aGUgZGVmYXVsdCBzaXplXG4gICAgLy8gb2YgdGhlIGJ1dHRvbiB0byBmaXQgdGhlIGJ1dHRvbiBuYW1lXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgMTAwLFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIG51bGwsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndG9wJyxcbiAgICAgICAgMCxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgMCxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdyb3RhdGUnLFxuICAgICAgICBudWxsLFxuICAgICk7XG5cbiAgICAvLyBob3Jpem9udGFsLXJlc2l6aW5nIHNwZWNpZmllcyBhIHN0cmF0ZWd5XG4gICAgLy8gZm9yIGhvdyB0aGlzIFBhcnQgc2hvdWxkIGFkanVzdCBpdHNcbiAgICAvLyBob3Jpem9udGFsIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBhcmVudC5cbiAgICAvLyBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgIC8vICogcmlnaWQgLSBTdGljayB0byB0aGUgdG9wLCBsZWZ0LCB3aWR0aFxuICAgIC8vIGFuZCBoZWlnaHQgcHJvcGVydGllcyBhcyB0aGV5IGFyZSBleHBsaWNpdGx5XG4gICAgLy8gc2V0O1xuICAgIC8vICogc2hyaW5rLXdyYXAgLSBCZWNvbWUgbGFyZ2UgZW5vdWdoIG9uIHRoZSBob3JpLVxuICAgIC8vIHpvbnRhbCBheGlzIG9ubHkgdG8gZml0IGFueSBjaGlsZCBjb250ZW50cztcbiAgICAvLyAqIHNwYWNlLWZpbGwgLSBGaWxsIGFzIG11Y2ggYXMgd2UgY2FuIGluIHRoZVxuICAgIC8vIGhvcml6b250YWwgYXhpcyBpbiB0aGUgcGFyZW50IFBhcnQuXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2hvcml6b250YWwtcmVzaXppbmcnLFxuICAgICAgICAncmlnaWQnXG4gICAgKTtcblxuICAgIC8vIHZlcnRpY2FsLXJlc2l6aW5nIHNwZWNpZmllcyBhIHN0cmF0ZWd5XG4gICAgLy8gZm9yIGhvdyB0aGlzIFBhcnQgc2hvdWxkIGFkanVzdCBpdHNcbiAgICAvLyB2ZXJ0aWNhbCBheGlzIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gICAgLy8gUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAvLyAqIHJpZ2lkIC0gU3RpY2sgdG8gdGhlIHRvcCwgbGVmdCwgd2lkdGhcbiAgICAvLyBhbmQgaGVpZ2h0IHByb3BlcnRpZXMgYXMgdGhleSBhcmUgZXhwbGljaXRseVxuICAgIC8vIHNldDtcbiAgICAvLyAqIHNocmluay13cmFwIC0gQmVjb21lIGxhcmdlIGVub3VnaCBvbiB0aGUgaG9yaS1cbiAgICAvLyB6b250YWwgYXhpcyBvbmx5IHRvIGZpdCBhbnkgY2hpbGQgY29udGVudHM7XG4gICAgLy8gKiBzcGFjZS1maWxsIC0gRmlsbCBhcyBtdWNoIGFzIHdlIGNhbiBpbiB0aGVcbiAgICAvLyB2ZXJ0aWNhbCBheGlzIGluIHRoZSBwYXJlbnQgUGFydC5cbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndmVydGljYWwtcmVzaXppbmcnLFxuICAgICAgICAncmlnaWQnXG4gICAgKTtcblxuICAgIC8vIE1hcmdpbiBzcGVjaWZpZXMgc29tZSBzcGFjZSBiZXR3ZWVuIHRoZVxuICAgIC8vIHRhcmdldCBQYXJ0IGFuZCBhbnkgb3RoZXIgUGFydHMgdGhhdCBtaWdodFxuICAgIC8vIGJlIGFkamFjZW50IHRvIGl0IGluIGEgY29tbW9uIE93bmVyLiBJdCB3aWxsXG4gICAgLy8gbm90IGJlIGluIGVmZmVjdCB3aGVuIHRoZSBvd25lciBpcyB1c2luZyBhXG4gICAgLy8gc3RyaWN0IGxheW91dC5cbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndG9wLW1hcmdpbicsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdyaWdodC1tYXJnaW4nLFxuICAgICAgICBudWxsXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAnYm90dG9tLW1hcmdpbicsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdsZWZ0LW1hcmdpbicsXG4gICAgICAgIG51bGxcbiAgICApO1xuXG4gICAgLy8gUGlubmluZyBzcGVjaWZpZXMgd2hldGhlciBvciBub3RcbiAgICAvLyBhIGdpdmVuIHBhcnQgc2hvdWxkIFwic3RpY2tcIiB0byBhXG4gICAgLy8gcGFydGljdWxhciBzaWRlIG9mIGl0cyBvd25lciBQYXJ0LlxuICAgIC8vIFBpbm5pbmcgcHJvcGVydGllcyBvbmx5IGhhdmUgZWZmZWN0XG4gICAgLy8gaW5zaWRlIG9mIFBhcnRzIHdpdGggYSBzdHJpY3QgbGF5b3V0XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAncGlubmluZy10b3AnLFxuICAgICAgICBwaW5uaW5nU2V0dGVyLFxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHByb3BPYmplY3QuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICBmYWxzZSAvLyBkZWZhdWx0IHZhbHVlXG5cbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdEeW5hbWljUHJvcChcbiAgICAgICAgJ3Bpbm5pbmctbGVmdCcsXG4gICAgICAgIHBpbm5pbmdTZXR0ZXIsXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICByZXR1cm4gcHJvcE9iamVjdC5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlLCAvLyBub3QgcmVhZCBvbmx5XG4gICAgICAgIGZhbHNlIC8vIGRlZmF1bHQgdmFsdWVcblxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAncGlubmluZy1ib3R0b20nLFxuICAgICAgICBwaW5uaW5nU2V0dGVyLFxuICAgICAgICBmdW5jdGlvbihwcm9wT3duZXIsIHByb3BPYmplY3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHByb3BPYmplY3QuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmYWxzZSwgLy8gbm90IHJlYWQgb25seVxuICAgICAgICBmYWxzZSAvLyBkZWZhdWx0IHZhbHVlXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3RHluYW1pY1Byb3AoXG4gICAgICAgICdwaW5uaW5nLXJpZ2h0JyxcbiAgICAgICAgcGlubmluZ1NldHRlcixcbiAgICAgICAgZnVuY3Rpb24ocHJvcE93bmVyLCBwcm9wT2JqZWN0KXtcbiAgICAgICAgICAgIHJldHVybiBwcm9wT2JqZWN0Ll92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2UsIC8vIG5vdCByZWFkIG9ubHlcbiAgICAgICAgZmFsc2UgLy8gZGVmYXVsdCB2YWx1ZVxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0R5bmFtaWNQcm9wKFxuICAgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXMgZm9yIHRoZSBjb21wb3VuZFxuICAgICAgICAvLyAncGlubmluZycgcHJvcGVydHkgYXJlOlxuICAgICAgICAvLyAqXCJub25lXCIgb3IgbnVsbFxuICAgICAgICAvLyAqdG9wXG4gICAgICAgIC8vICp0b3AtcmlnaHRcbiAgICAgICAgLy8gKnRvcC1sZWZ0XG4gICAgICAgIC8vICpib3R0b21cbiAgICAgICAgLy8gKmJvdHRvbS1yaWdodFxuICAgICAgICAvLyAqYm90dG9tLWxlZnRcbiAgICAgICAgLy8gKmxlZnRcbiAgICAgICAgLy8gKnJpZ2h0XG4gICAgICAgICdwaW5uaW5nJyxcbiAgICAgICAgLy8gU2V0dGVyXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCwgdmFsdWUpe1xuICAgICAgICAgICAgaWYoIXZhbHVlIHx8IHZhbHVlID09IFwibm9uZVwiKXtcbiAgICAgICAgICAgICAgICBbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaW4gPSBgcGlubmluZy0ke3NpZGV9YDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wT3duZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpbm5pbmdBZGp1c3QocHJvcE93bmVyLCB2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgIGZ1bmN0aW9uKHByb3BPd25lciwgcHJvcE9iamVjdCl7XG4gICAgICAgICAgICBsZXQgdG9wID0gcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLXRvcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gcHJvcE93bmVyLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcHJvcE93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLWJvdHRvbSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1sZWZ0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHByb3BPd25lci5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1yaWdodCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZih0b3Ape1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd0b3AnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihib3R0b20pe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdib3R0b20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGxlZnQpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYocmlnaHQpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdyaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJy0nKTtcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG4vKipcbiAqIFN0eWxlIHByb3BlcnRpZXMgZm9yIFBhcnRzIHRoYXQgZGlzcGxheVxuICogdGV4dFxuICovXG5jb25zdCBhZGRUZXh0U3R5bGVQcm9wcyA9ICh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1hbGlnbicsXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgJ2Nzc1RleHRTdHlsZSdcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0ZXh0LWZvbnQnLFxuICAgICAgICAnZGVmYXVsdCcsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1jb2xvcicsXG4gICAgICAgIFwicmdiKDAsIDAsIDApXCIsIC8vIGJsYWNrXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC10cmFuc3BhcmVuY3knLFxuICAgICAgICAxLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtc3R5bGUnLFxuICAgICAgICAncGxhaW4nLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtYm9sZCcsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnY3NzVGV4dFN0eWxlJ1xuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ3RleHQtaXRhbGljJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3U3R5bGVQcm9wKFxuICAgICAgICAndGV4dC1zaXplJyxcbiAgICAgICAgMTUsXG4gICAgICAgICdjc3NUZXh0U3R5bGUnXG4gICAgKTtcbn07XG5cbi8qKlxuICogQmFzaWMgbGF5b3V0IHN0eWxlcyBhcmUgdGhvc2UgcGVydGFpbmluZ1xuICogdG8gdGhlIHBvc2l0aW9uaW5nIGFuZCByZXNpemluZyBvZiBzdWJwYXJ0cy5cbiAqIEV4YW1wbGVzIGluY2x1ZGUgQ2FyZHMgYW5kIEFyZWFcbiAqL1xuY29uc3QgYWRkTGF5b3V0U3R5bGVQcm9wcyA9ICh0YXJnZXQpID0+IHtcbiAgICAvLyBUaGUgJ2xheW91dCcgcHJvcGVydHkgaXNcbiAgICAvLyBvbmUgb2YgdHdvIHN0cmluZ3M6XG4gICAgLy8gc3RyaWN0IC0gRXF1aXZhbGVudCB0byB0aGUgYWJzb2x1dGVcbiAgICAvLyBsYXlvdXQgYmFzZWQgc3RyaWN0bHkgb24gY29vcmRpbmF0ZXNcbiAgICAvLyBsaXN0IC0gV2lsbCBmb3JjZSBpdGVtcyBpbnRvIGVpdGhlciBhIHJvd1xuICAgIC8vIG9yIGNvbHVtbiBsaXN0LCBiYXNlZCBvbiB0aGUgcGFpcmluZyB3aXRoXG4gICAgLy8gdGhlICdsaXN0RGlyZWN0aW9uJyBwcm9wZXJ0eVxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICdsYXlvdXQnLFxuICAgICAgICAnc3RyaWN0J1xuICAgICk7XG5cbiAgICAvLyBsaXN0LWRpcmVjdGlvbiBzcGVjaWZpZXMgcm93IG9yIGNvbHVtblxuICAgIC8vIGFuZCB3aWxsIG9ubHkgaGF2ZSBhbiBlZmZlY3Qgd2hlbnQgdGhlXG4gICAgLy8gbGF5b3V0IHByb3BlcnR5IGlzIHNldCB0byAnbGlzdCdcbiAgICB0YXJnZXQucGFydFByb3BlcnRpZXMubmV3QmFzaWNQcm9wKFxuICAgICAgICAnbGlzdC1kaXJlY3Rpb24nLFxuICAgICAgICAncm93J1xuICAgICk7XG5cbiAgICAvLyBXcmFwcGluZyBzcGVjaWZpZXMgd2hldGhlciBhIGxpc3Qgc2hvdWxkXG4gICAgLy8gd3JhcCBhbG9uZyBpdHMgZG9taW5hbnQgZGltZW5zaW9uIChyb3cgb3IgY29sdW1uKVxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdCYXNpY1Byb3AoXG4gICAgICAgICdsaXN0LXdyYXBwaW5nJyxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgLy8gUGFkZGluZyBzcGVjaWZpZXMgc29tZSBzcGFjZSBmcm9tIHRoZVxuICAgIC8vIGJvcmRlciBvZiB0aGUgdGFyZ2V0IFBhcnQgdG8gdGhlIGJlZ2lubmluZ1xuICAgIC8vIG9mIHRoZSBsYXlvdXQgb2YgYW55IHN1YnBhcnRzLlxuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICd0b3AtcGFkZGluZycsXG4gICAgICAgIG51bGxcbiAgICApO1xuICAgIHRhcmdldC5wYXJ0UHJvcGVydGllcy5uZXdTdHlsZVByb3AoXG4gICAgICAgICdyaWdodC1wYWRkaW5nJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2JvdHRvbS1wYWRkaW5nJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld1N0eWxlUHJvcChcbiAgICAgICAgJ2xlZnQtcGFkZGluZycsXG4gICAgICAgIG51bGxcbiAgICApO1xuXG4gICAgLy8gTGlzdCBhbGlnbm1lbnQgZGVzY3JpYmVzIGhvdyBlbGVtZW50cyBpblxuICAgIC8vIGEgbGlzdCBsYXlvdXQgc2hvdWxkIGFsaWduIHRoZW1zZWx2ZXMgYWxvbmdcbiAgICAvLyB0aGUgZG9taW5hbnQgZGltZW5zaW9uIChyb3cgb3IgY29sdW1uKVxuICAgIC8vIFRoZXkgYXJlIGVzc2VudGlhbGx5IHByb3hpZXMgZm9yIGFsaWduLWl0ZW1zXG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgJ2xpc3QtYWxpZ25tZW50JyxcbiAgICAgICAgbnVsbFxuICAgICk7XG5cbiAgICAvLyBMaXN0IGRpc3RyaWJ1dGlvbiBkZXNjcmliZXMgaG93IGVsZW1lbnRzXG4gICAgLy8gaW4gYSBsaXN0IGxheW91dCBzaG91bGQgZGlzdHJpYnV0ZSB0aGVtc2VsdmVzXG4gICAgLy8gYWNyb3NzIG9yIGFsb25nIHRoZSBkb21pbmFudCBkaW1lbnNpb25cbiAgICAvLyAocm93IG9yIGNvbHVtbilcbiAgICAvLyBUaGlzIGlzIGVzc2VudGlhbGx5IGEgd3JhcHBlciBmb3IganVzdGlmeS1jb250ZW50XG4gICAgdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLm5ld0Jhc2ljUHJvcChcbiAgICAgICAgJ2xpc3QtZGlzdHJpYnV0aW9uJyxcbiAgICAgICAgbnVsbFxuICAgICk7XG59O1xuXG4vKipcbiAgKiBIRUxQRVJTXG4gKiovXG5cbmNvbnN0IHBpbm5pbmdTZXR0ZXIgPSAocHJvcE93bmVyLCBwcm9wT2JqZWN0LCB2YWx1ZSkgPT4ge1xuICAgIGxldCBzaWRlID0gcHJvcE9iamVjdC5uYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICBsZXQgdG9wTGVmdDtcbiAgICBzd2l0Y2ggKHNpZGUpe1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICB0b3BMZWZ0ID0gXCJsZWZ0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgdG9wTGVmdCA9IFwidG9wXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRvcExlZnQgPSBzaWRlO1xuICAgIH1cbiAgICAvLyB3ZSdsbCBuZWVkIHRvIGZpeCBhbmQgdW4tZml4IHRoZSBjb3JyZXNwb25kaW5nIHRvcCBvciBsZWZ0IHByb3BlcnR5IGRlcGVuZGluZ1xuICAgIC8vIG9uIHdoZXRoZXIgdmFsdWUgaXMgdHJ1ZSBvZiBmYWxzZSwgcmVzcGVjdGl2ZWx5XG4gICAgbGV0IHByb3AgPSBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQoXG4gICAgICAgIHRvcExlZnQgXG4gICAgKTtcbiAgICBsZXQgb3Bwb3NpdGVTaWRlO1xuICAgIHN3aXRjaCAoc2lkZSl7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgb3Bwb3NpdGVTaWRlID0gXCJyaWdodFwiO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgb3Bwb3NpdGVTaWRlID0gXCJsZWZ0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgb3Bwb3NpdGVTaWRlID0gXCJib3R0b21cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICBvcHBvc2l0ZVNpZGUgPSBcInRvcFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYodmFsdWUpe1xuICAgICAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCBwaW5uaW5nLWJvdHRvbSBpcyBmYWxzZVxuICAgICAgICBwcm9wT3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHByb3BPd25lcixcbiAgICAgICAgICAgIGBwaW5uaW5nLSR7b3Bwb3NpdGVTaWRlfWAsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICBwcm9wLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNldCB0aGUgdmFsdWUgYmFjayB0byB0cmlnZ2VyIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIHByb3Auc2V0VmFsdWUocHJvcE93bmVyLCBwcm9wLl92YWx1ZSk7XG4gICAgICAgIHByb3AucmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcHJvcE9iamVjdC5fdmFsdWUgPSB2YWx1ZTtcbn07XG5cbmNvbnN0IHBpbm5pbmdBZGp1c3QgPSAob3duZXIsIHZhbHVlKSA9PiB7XG4gICAgbGV0IHNpZGVzID0gWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXTtcbiAgICBzaWRlcy5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgICBpZih2YWx1ZS5zdGFydHNXaXRoKHNpZGUpKXtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgYHBpbm5pbmctJHtzaWRlfWAsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgYHBpbm5pbmctJHtzaWRlfWAsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKHZhbHVlLmluY2x1ZGVzKFwiLVwiKSl7XG4gICAgICAgIGlmKHZhbHVlLmVuZHNXaXRoKCdsZWZ0Jykpe1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1sZWZ0JyxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1yaWdodCcsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZS5lbmRzV2l0aCgncmlnaHQnKSl7XG4gICAgICAgICAgICBvd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgICdwaW5uaW5nLWxlZnQnLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAncGlubmluZy1yaWdodCcsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgYWRkQmFzaWNTdHlsZVByb3BzLFxuICAgIGFkZFBvc2l0aW9uaW5nU3R5bGVQcm9wcyxcbiAgICBhZGRUZXh0U3R5bGVQcm9wcyxcbiAgICBhZGRMYXlvdXRTdHlsZVByb3BzXG59O1xuIiwiLyoqXG4gKiBTdHlsZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSByZXNwb25zaWJsZSBmb3IgY29udmVydGluZ1xuICogU2ltcGxlVGFsayB2aXN1YWwgc3R5bGluZyB0byBhIGRpY3RcbiAqIE9iamVjdCBvZiBDU1MgSmF2YVNjcmlwdCB0eXBlIGtleS12YWx1ZSBwYWlyc1xuICovXG5cbi8qKiBJIHN0eWxlIHRoZSBzdHlsZU9ialxuICogc3R5bGVPYmo6IGNzcyBKYXZhU2NyaXB0IGtleTp2YWx1ZSBwYWlyc1xuICogcHJvcGVydHlOYW1lOiAoU2ltcGxlVGFsaykgc3R5bGluZyBwcm9wZXJ0eSBuYW1lXG4gKiBwcm9wZXJ0eVZhbHVlOiAoU2ltcGxlVGFsaykgc3R5bGluZyBwcm9wZXJ0eSB2YWx1ZVxuICovXG5cbmNvbnN0IGNzc1N0eWxlciA9IChzdHlsZU9iaiwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSA9PiB7XG4gICAgc3dpdGNoKHByb3BlcnR5TmFtZSl7XG5cbiAgICBjYXNlIFwiYmFja2dyb3VuZC1jb2xvclwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiYmFja2dyb3VuZENvbG9yXCIsICBfY29sb3JUb1JHQkEoc3R5bGVPYmpbXCJiYWNrZ3JvdW5kQ29sb3JcIl0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgLy8gaGVyZSB3ZSBzZXQgdGhlIEFscGhhIHZhbHVlIG9mIHRoZSBjdXJyZW50IHN0eWxlT2JqW1wiYmFja2dyb3VuZENvbG9yXCJdIHJnYmFcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImJhY2tncm91bmRDb2xvclwiLCAgX2NvbG9yVHJhbnNwYXJlbmN5VG9SR0JBKHN0eWxlT2JqW1wiYmFja2dyb3VuZENvbG9yXCJdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImJvcmRlci10b3Atc3R5bGVcIjpcbiAgICBjYXNlIFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiOlxuICAgIGNhc2UgXCJib3JkZXItbGVmdC1zdHlsZVwiOlxuICAgIGNhc2UgXCJib3JkZXItcmlnaHQtc3R5bGVcIjoge1xuICAgICAgICBsZXQgcyA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgYGJvcmRlci0ke3N9LXN0eWxlYCwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFwiYm9yZGVyLXRvcC13aWR0aFwiOlxuICAgIGNhc2UgXCJib3JkZXItYm90dG9tLXdpZHRoXCI6XG4gICAgY2FzZSBcImJvcmRlci1sZWZ0LXdpZHRoXCI6XG4gICAgY2FzZSBcImJvcmRlci1yaWdodC13aWR0aFwiOiB7XG4gICAgICAgIGxldCBzID0gcHJvcGVydHlOYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBgYm9yZGVyLSR7c30td2lkdGhgLCAgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFwiYm9yZGVyLXRvcC1jb2xvclwiOlxuICAgIGNhc2UgXCJib3JkZXItYm90dG9tLWNvbG9yXCI6XG4gICAgY2FzZSBcImJvcmRlci10b3AtY29sb3JcIjpcbiAgICBjYXNlIFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCI6IHtcbiAgICAgICAgbGV0IHMgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtzfS1jb2xvcmAsICBfY29sb3JUb1JHQkEoc3R5bGVPYmpbYGJvcmRlci0ke3N9LWNvbG9yYF0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImJvcmRlci10b3AtdHJhbnNwYXJlbmN5XCI6XG4gICAgY2FzZSBcImJvcmRlci1ib3R0b20tdHJhbnNwYXJlbmN5XCI6XG4gICAgY2FzZSBcImJvcmRlci1sZWZ0LXRyYW5zcGFyZW5jeVwiOlxuICAgIGNhc2UgXCJib3JkZXItcmlnaHQtdHJhbnNwYXJlbmN5XCI6IHtcbiAgICAgICAgbGV0IHMgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtzfS1jb2xvcmAsICBfY29sb3JUcmFuc3BhcmVuY3lUb1JHQkEoc3R5bGVPYmpbYGJvcmRlci0ke3N9LWNvbG9yYF0sIHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcImNvcm5lci10b3AtbGVmdC1yb3VuZFwiOlxuICAgIGNhc2UgXCJjb3JuZXItdG9wLXJpZ2h0LXJvdW5kXCI6XG4gICAgY2FzZSBcImNvcm5lci1ib3R0b20tbGVmdC1yb3VuZFwiOlxuICAgIGNhc2UgXCJjb3JuZXItYm90dG9tLXJpZ2h0LXJvdW5kXCI6e1xuICAgICAgICBsZXQgYzEgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzFdO1xuICAgICAgICBsZXQgYzIgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzJdO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBib3JkZXItJHtjMX0tJHtjMn0tcmFkaXVzYCwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBcInNoYWRvdy1sZWZ0XCI6XG4gICAgY2FzZSBcInNoYWRvdy10b3BcIjpcbiAgICBjYXNlIFwic2hhZG93LWJsdXJcIjpcbiAgICBjYXNlIFwic2hhZG93LXNwcmVhZFwiOlxuICAgIGNhc2UgXCJzaGFkb3ctY29sb3JcIjpcbiAgICBjYXNlIFwic2hhZG93LXRyYW5zcGFyZW5jeVwiOlxuICAgICAgICBsZXQgc2hhZG93UHJvcCA9IHByb3BlcnR5TmFtZS5zcGxpdChcIi1cIilbMV07XG4gICAgICAgIGxldCBbbGVmdCwgdG9wLCBibHVyLCBzcHJlYWQsIGNvbG9yXSA9IF9jc3NCb3hTaGFkb3coc3R5bGVPYmpbXCJib3gtc2hhZG93XCJdKTtcbiAgICAgICAgc3dpdGNoKHNoYWRvd1Byb3Ape1xuICAgICAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgICAgIGNvbG9yID0gX2NvbG9yVG9SR0JBKGNvbG9yLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHJhbnNwYXJlbmN5XCI6XG4gICAgICAgICAgICBjb2xvciA9IF9jb2xvclRyYW5zcGFyZW5jeVRvUkdCQShjb2xvciwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgIGxlZnQgPSBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICB0b3AgPSBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICAgICAgYmx1ciA9IF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcHJlYWRcIjpcbiAgICAgICAgICAgIHNwcmVhZCA9IF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImJveC1zaGFkb3dcIiwgYCR7bGVmdH0gJHt0b3B9ICR7Ymx1cn0gJHtzcHJlYWR9ICR7Y29sb3J9YCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtY29sb3JcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImNvbG9yXCIsICBfY29sb3JUb1JHQkEoc3R5bGVPYmpbXCJjb2xvclwiXSwgcHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWZvbnRcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnRGYW1pbHlcIiwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LXNpemVcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImZvbnRTaXplXCIsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWFsaWduXCI6XG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0ZXh0QWxpZ25cIiwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0LWJvbGRcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udC13ZWlnaHRcIiwgIFwiYm9sZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmKHByb3BlcnR5VmFsdWUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJmb250LXdlaWdodFwiLCAgXCJub3JtYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC1pdGFsaWNcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udC1zdHlsZVwiLCAgXCJpdGFsaWNcIik7XG4gICAgICAgIH0gZWxzZSBpZihwcm9wZXJ0eVZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiZm9udC1zdHlsZVwiLCAgXCJub3JtYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC11bmRlcmxpbmVcIjpcbiAgICAgICAgaWYocHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidGV4dERlY29yYXRpb25cIiwgIFwidW5kZXJsaW5lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtc3RyaWtldGhyb3VnaFwiOlxuICAgICAgICBpZihwcm9wZXJ0eVZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgXCJ0ZXh0RGVjb3JhdGlvblwiLCAgXCJsaW5lLXRocm91Z2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dC10cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgLy8gaGVyZSB3ZSBzZXQgdGhlIEFscGhhIHZhbHVlIG9mIHRoZSBjdXJyZW50IHN0eWxlT2JqW1wiY29sb3JcIl0gcmdiYVxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiY29sb3JcIiwgIF9jb2xvclRyYW5zcGFyZW5jeVRvUkdCQShzdHlsZU9ialtcImNvbG9yXCJdLCBwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidG9wXCIsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcImxlZnRcIiwgIF9pbnRUb1B4KHByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcIndpZHRoXCIsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwiaGVpZ2h0XCIsICBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImxlZnQtbWFyZ2luXCI6XG4gICAgY2FzZSBcInJpZ2h0LW1hcmdpblwiOlxuICAgIGNhc2UgXCJib3R0b20tbWFyZ2luXCI6XG4gICAgY2FzZSBcInRvcC1tYXJnaW5cIjpcbiAgICAgICAgbGV0IG1hcmdpblNpZGUgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgICBtYXJnaW5TaWRlID0gYCR7bWFyZ2luU2lkZVswXS50b1VwcGVyQ2FzZSgpfSR7bWFyZ2luU2lkZS5zbGljZSgxKX1gO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBtYXJnaW4ke21hcmdpblNpZGV9YCwgX2ludFRvUHgocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJsZWZ0LXBhZGRpbmdcIjpcbiAgICBjYXNlIFwicmlnaHQtcGFkZGluZ1wiOlxuICAgIGNhc2UgXCJib3R0b20tcGFkZGluZ1wiOlxuICAgIGNhc2UgXCJ0b3AtcGFkZGluZ1wiOlxuICAgICAgICBsZXQgcGFkZGluZ1NpZGUgPSBwcm9wZXJ0eU5hbWUuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgICBwYWRkaW5nU2lkZSA9IGAke3BhZGRpbmdTaWRlWzBdLnRvVXBwZXJDYXNlKCl9JHtwYWRkaW5nU2lkZS5zbGljZSgxKX1gO1xuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIGBwYWRkaW5nJHtwYWRkaW5nU2lkZX1gLCBfaW50VG9QeChwcm9wZXJ0eVZhbHVlKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHQtc3R5bGVcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcInRleHRTdHlsZVwiLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICBfc2V0T3JOb3Qoc3R5bGVPYmosIFwidHJhbnNmb3JtXCIsICBfaW50VG9Sb3RhdGVEZWcocHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmFuc3BhcmVuY3lcIjpcbiAgICAgICAgX3NldE9yTm90KHN0eWxlT2JqLCBcIm9wYWNpdHlcIiwgIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgXCJoaWRlXCI6XG4gICAgICAgIGlmKHByb3BlcnR5VmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgc3R5bGVPYmpbXCJkaXNwbGF5XCJdID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSBpZihwcm9wZXJ0eVZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICBzdHlsZU9ialtcImRpc3BsYXlcIl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICBkZWZhdWx0OlxuICAgICAgICAvLyBmb3IgdGhlIGRlZmF1bHQgd2Ugc2ltcGx5IGFsbG93IFNUIHN0eWxlIG5hbWVzIHRvIG1hcCAxLTFcbiAgICAgICAgLy8gdG8gQ1NTL0pTIHN0eWxlIG5hbWVzLiBUaGlzIGlzIG9ubHkgc29tZXdoYXQgc2FmZSwgc2luY2UgdGhlIERPTVxuICAgICAgICAvLyB3aWxsIHNpbXBseSBpZ25vcmUgbm9uc2Vuc2UgbmFtZXMgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci4gQnV0IGl0XG4gICAgICAgIC8vIGRvZXMgYWxsb3cgdXMgdG8gYXZvaWQgd3JpdGluZyBhIHJ1bGUgZm9yIGV2ZXJ5IHRlcm0gKGV4YW1wbGU6IHdpZHRoLFxuICAgICAgICAvLyBoZWlnaHQsIHRvcCwgbGVmdCBldGMpXG4gICAgICAgIF9zZXRPck5vdChzdHlsZU9iaiwgcHJvcGVydHlOYW1lLCAgcHJvcGVydHlWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZU9iajtcblxufTtcblxuLy8gSW4gb3JkZXIgdG8gYXZvaWQgY2xhc2hpbmcgd2l0aCB2aWV3cyBpbnRlcmFjdGluZ1xuLy8gdGhlIHN0eWxlIGF0dHJpYnV0ZSBkaXJlY3RseSB3ZSBpZ25vcmUgZXZlcnl0aGluZyB0aGF0XG4vLyBpcyBlaXRoZXIgbnVsbCBvciB1bmRlZmluZWRcbi8vIFRPRE8gcmV2aWV3IHRoaXMgZGVjaXNpb24hXG5jb25zdCBfc2V0T3JOb3QgPSAoc3R5bGVPYmosIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgaWYodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgIHN0eWxlT2JqW25hbWVdID0gdmFsdWU7XG4gICAgfVxufTtcblxuY29uc3QgX2ludFRvUm90YXRlRGVnID0gKG4pID0+IHtcbiAgICBpZihuICE9PSBudWxsICYmIG4gIT09IHVuZGVmaW5lZCl7XG4gICAgICAgIGlmKHR5cGVvZihuKSA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICBuID0gbi5zcGxpdChcImRlZ1wiKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHJvdGF0ZSgke259ZGVnKWA7XG4gICAgfVxufTtcblxuXG5jb25zdCBfaW50VG9QeCA9IChuKSA9PiB7XG4gICAgaWYobiAhPT0gbnVsbCAmJiBuICE9PSB1bmRlZmluZWQpe1xuICAgICAgICBpZih0eXBlb2YobikgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgaWYobiA9PSBcImZpbGxcIil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMTAwJVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmKFtcInRoaW5cIiwgXCJtZWRpdW1cIiwgXCJ0aGlja1wiXS5pbmRleE9mKG4pID4gLTEpe1xuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4uc3BsaXQoXCJweFwiKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bn1weGA7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCBjb2xvcnMgdG8gcmdiYVxuLy8gY2hhbmdlIGEgY3NzIGNvbG9yIFJHQiB2YWx1ZXMsIHByZXNlcnZpbmcgdGhlIEEobHBoYSkgdmFsdWVcbmNvbnN0IF9jb2xvclRvUkdCQSA9IChjc3NDb2xvciwgU1RDb2xvcikgPT4ge1xuICAgIGlmKCFTVENvbG9yKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgciwgZywgYiwgYSwgXztcbiAgICAvLyBTVCBjb2xvcnMgYXJlIFJHQlxuICAgIGlmKFNUQ29sb3Iuc3RhcnRzV2l0aChcInJnYlwiKSl7XG4gICAgICAgIFtyLCBnLCBiXSA9IFNUQ29sb3IubWF0Y2goL1xcZCsvZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbG9ySW5mbyA9IGJhc2ljQ1NTQ29sb3JzW1NUQ29sb3JdO1xuICAgICAgICBpZihjb2xvckluZm8pe1xuICAgICAgICAgICAgciA9IGNvbG9ySW5mb1tcInJcIl07XG4gICAgICAgICAgICBnID0gY29sb3JJbmZvW1wiZ1wiXTtcbiAgICAgICAgICAgIGIgPSBjb2xvckluZm9bXCJiXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKGNzc0NvbG9yKXtcbiAgICAgICAgW18sIF8sIF8sIGFdID0gY3NzQ29sb3IubWF0Y2goL1tcXGRcXC5dKy9nKTtcbiAgICAgICAgLy8gaWYgQWxwaGEgaXMgbm90IGRlZmluZWQgdGhlbiB3ZSBzZXQgaXQgdG8gMVxuICAgICAgICAvLyBkZWZhdWx0IGZvciBicm93c2Vyc1xuICAgIH1cbiAgICBpZighYSl7XG4gICAgICAgIGEgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xufVxuXG4vLyBjaGFuZ2UgdGhlIEEoYWxwaGEpIHZhbHVlLCBwcmVzZXJ2aW5nIHRoZSBSR0IgdmFsdWVzXG5jb25zdCBfY29sb3JUcmFuc3BhcmVuY3lUb1JHQkEgPSAoY3NzQ29sb3IsIHRWYWx1ZSkgPT4ge1xuICAgIGlmKCFjc3NDb2xvcil7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgciwgZywgYjtcbiAgICBsZXQgbWFwcGVkQ29sb3IgPSBiYXNpY0NTU0NvbG9yc1tjc3NDb2xvcl07XG4gICAgaWYobWFwcGVkQ29sb3Ipe1xuICAgICAgICByID0gbWFwcGVkQ29sb3IucjtcbiAgICAgICAgZyA9IG1hcHBlZENvbG9yLmc7XG4gICAgICAgIGIgPSBtYXBwZWRDb2xvci5iO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFtyLCBnLCBiXSA9IGNzc0NvbG9yLm1hdGNoKC9cXGQrL2cpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHt0VmFsdWV9KWA7XG59XG5cbi8vIEFkZCBtb3JlIGNvbG9ycyBhcyBuZWVkZWRcbmNvbnN0IGJhc2ljQ1NTQ29sb3JzID0ge1xuICAgIGJsYWNrOiB7aGV4OiBcIiMwMDAwMDBcIiwgcjogMCwgZzogMCwgYjogMH0sXG5cdFx0c2lsdmVyOiB7aGV4OiBcIiNDMEMwQzBcIiwgcjogMTkyLCBnOiAxOTIsIGI6IDE5Mn0sXG5cdFx0Z3JheToge2hleDogXCIjODA4MDgwXCIsIHI6IDEyOCwgZzogMTI4LCBiOiAxMjh9LFxuXHRcdHdoaXRlOiB7aGV4OiBcIiNGRkZGRkZcIiwgcjogMjU1LCBnOiAyNTUsIGI6IDI1NX0sXG5cdFx0bWFyb29uOiB7aGV4OiBcIiM4MDAwMDBcIiwgcjogMTI4LCBnOiAwLCBiOiAwfSxcblx0XHRyZWQ6IHtoZXg6IFwiI0ZGMDAwMFwiLCByOiAyNTUsIGc6IDAsIGI6IDB9LFxuXHRcdHB1cnBsZToge2hleDogXCIjODAwMDgwXCIsIHI6IDEyOCwgZzogMCwgYjogMTI4fSxcblx0XHRmdWNoc2lhOiB7aGV4OiBcIiNGRjAwRkZcIiwgcjogMjU1LCBnOiAwLCBiOiAyNTV9LFxuXHRcdGdyZWVuOiB7aGV4OiBcIiMwMDgwMDBcIiwgcjogMCwgZzogMTI4LCBiOiAwfSxcblx0XHRsaW1lOiB7aGV4OiBcIiMwMEZGMDBcIiwgcjogMCwgZzogMjU1LCBiOiAwfSxcblx0XHRvbGl2ZToge2hleDogXCIjODA4MDAwXCIsIHI6IDEyOCwgZzogMTI4LCBiOiAwfSxcblx0XHR5ZWxsb3c6IHtoZXg6IFwiI0ZGRkYwMFwiLCByOiAyNTUsIGc6IDI1NSwgYjogMH0sXG5cdFx0bmF2eToge2hleDogXCIjMDAwMDgwXCIsIHI6IDAsIGc6IDAsIGI6IDEyOH0sXG5cdFx0Ymx1ZToge2hleDogXCIjMDAwMEZGXCIsIHI6IDAsIGc6IDAsIGI6IDI1NX0sXG5cdFx0dGVhbDoge2hleDogXCIjMDA4MDgwXCIsIHI6IDAsIGc6IDEyOCwgYjogMTI4fSxcblx0XHRhcXVhOiB7aGV4OiBcIiMwMEZGRkZcIiwgcjogMCwgZzogMjU1LCBiOiAyNTV9LFxufTtcblxuLy8gdGFrZSB0aGUgY3NzIGJveC1zaGFkb3cgcHJvcGVydHkgYW5kIHJldHVybiBpdHNcbi8vIGNvbXBvbmVudHMgKG9mZnNldC15LCBvZmZzZXQteCwgYmx1ciwgc3ByZWFkIGFuZCBjb2xvcilcbi8vIGlmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZCByZXR1cm4gYSBkZWZhdWx0XG5jb25zdCBfY3NzQm94U2hhZG93ID0gKGNzc1Byb3BWYWx1ZSkgPT57XG4gICAgaWYoIWNzc1Byb3BWYWx1ZSl7XG4gICAgICAgIHJldHVybiBbXCIwcHhcIiwgXCIwcHhcIiwgXCIwcHhcIiwgXCIwcHhcIiwgXCJyZ2JhKDAsIDAsIDAsIDEpXCJdO1xuICAgIH1cbiAgICBsZXQgW2ludFZhbHVlcywgcmdiYV0gPSBjc3NQcm9wVmFsdWUuc3BsaXQoXCIgcmdiYVwiKTtcbiAgICBsZXQgW2xlZnQsIHRvcCwgYmx1ciwgc3ByZWFkXSA9IGludFZhbHVlcy5zcGxpdChcIiBcIik7XG4gICAgcmV0dXJuIFtsZWZ0LCB0b3AsIGJsdXIsIHNwcmVhZCwgYHJnYmEke3JnYmF9YF07XG59XG5cbmV4cG9ydCB7XG4gICAgY3NzU3R5bGVyLFxuICAgIGNzc1N0eWxlciBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBBcmVhVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHdlYmNvbXBvbmVudCByZXByZXNlbnRhdGlvblxuICogb2YgYW4gQXJlYSwgd2hpY2ggaXMgYSBncm91cGluZyBvZlxuICogUGFydHMgdGhhdCBoYXZlIHNvbWUga2luZCBvZiBsYXlvdXRcbiAqIHNwZWNpZmllZFxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuICAgICAgICAgICAgICAgIDxzdHlsZT5cbiAgICAgICAgICAgICAgICAjYXJlYS13cmFwcGVyIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduLWNvbnRlbnQ6IGluaGVyaXQ7XG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyBcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLmNsaXAge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuOyAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC5hbGxvdy1zY3JvbGwge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiYXJlYS13cmFwcGVyXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuYDtcblxuY2xhc3MgQXJlYVZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmNsaXBwaW5nQ2hhbmdlZCA9IHRoaXMuY2xpcHBpbmdDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWxsb3dTY3JvbGxpbmdDaGFuZ2VkID0gdGhpcy5hbGxvd1Njcm9sbGluZ0NoYW5nZWQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBQcm9wIGNoYW5nZSBoYW5kbGVyc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY2xpcHBpbmcnLCB0aGlzLmNsaXBwaW5nQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdhbGxvdy1zY3JvbGxpbmcnLCB0aGlzLmFsbG93U2Nyb2xsaW5nQ2hhbmdlZCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICBsZXQgY2xpcHBpbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJjbGlwcGluZ1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2xpcHBpbmdDaGFuZ2VkKGNsaXBwaW5nLCB0aGlzLm1vZGVsLmlkKTtcbiAgICB9XG5cbiAgICBjbGlwcGluZ0NoYW5nZWQobmV3VmFsLCBpZCl7XG4gICAgICAgIGxldCB3cmFwcGVyID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYXJlYS13cmFwcGVyJyk7XG4gICAgICAgIGlmKG5ld1ZhbCA9PSB0cnVlKXtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnYWxsb3ctc2Nyb2xsJyk7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2NsaXAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnY2xpcCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWxsb3dTY3JvbGxpbmdDaGFuZ2VkKG5ld1ZhbCwgaWQpe1xuICAgICAgICBsZXQgd3JhcHBlciA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2FyZWEtd3JhcHBlcicpO1xuICAgICAgICBpZihuZXdWYWwgPT0gdHJ1ZSl7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2NsaXAnKTtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnYWxsb3ctc2Nyb2xsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2FsbG93LXNjcm9sbCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ29udGV4dE1lbnVJdGVtcyhjb250ZXh0TWVudSl7XG4gICAgICAgIGNvbnRleHRNZW51LmFkZFNwYWNlcigpO1xuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdsYXlvdXQnXG4gICAgICAgICk7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2xpc3QtZGlyZWN0aW9uJ1xuICAgICAgICApO1xuICAgICAgICBpZihsYXlvdXQgIT0gJ2xpc3QnKXtcbiAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgIFwiU2V0IExheW91dCB0byBMaXN0XCIsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF5b3V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICBcIlNldCBMYXlvdXQgdG8gU3RyaWN0XCIsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF5b3V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpY3QnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSAncm93Jyl7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiU2V0IExpc3QgRGlyZWN0aW9uIHRvIENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0LWRpcmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbidcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgXCJTZXQgTGlzdCBEaXJlY3Rpb24gdG8gQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3QtZGlyZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncm93J1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEFyZWFWaWV3LFxuICAgIEFyZWFWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IGxpbmtJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxpbmtcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEwIDE0YTMuNSAzLjUgMCAwIDAgNSAwbDQgLTRhMy41IDMuNSAwIDAgMCAtNSAtNWwtLjUgLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDEwYTMuNSAzLjUgMCAwIDAgLTUgMGwtNCA0YTMuNSAzLjUgMCAwIDAgNSA1bC41IC0uNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuOmhvc3Qge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHBhZGRpbmc6IDFweDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbi53cmFwcGVye1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG59XG48L3N0eWxlPlxuPGRpdiBjbGFzcz1cIndyYXBwZXJcIj5cbiAgICA8YXVkaW8+PC9hdWRpbz5cbiAgICA8c3BhbiBjbGFzcz1cIm5hbWVcIj48L3NwYW4+XG4gICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLW11c2ljXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgIDxjaXJjbGUgY3g9XCI2XCIgY3k9XCIxN1wiIHI9XCIzXCI+PC9jaXJjbGU+XG4gICAgPGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxN1wiIHI9XCIzXCI+PC9jaXJjbGU+XG4gICAgPHBvbHlsaW5lIHBvaW50cz1cIjkgMTcgOSA0IDE5IDQgMTkgMTdcIj48L3BvbHlsaW5lPlxuICAgIDxsaW5lIHgxPVwiOVwiIHkxPVwiOFwiIHgyPVwiMTlcIiB5Mj1cIjhcIj48L2xpbmU+XG4gICAgPC9zdmc+XG48L2Rpdj5cbmA7XG5cbi8vIEhUTUxNZWRpYUVsZW1lbnRTdGF0ZXMgY29waWVkIGZyb21cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3JlYWR5U3RhdGVcbmNvbnN0IG1lZGlhU3RhdGVzID0ge1xuICAgIDA6IFwiSEFWRV9OT1RISU5HXCIsXG4gICAgMTogXCJIQVZFX01FVEFEQVRBXCIsXG4gICAgMjogXCJIQVZFX0NVUlJFTlRfREFUQVwiLFxuICAgIDM6IFwiSEFWRV9GVVRVUkVfREFUQVwiLFxuICAgIDQ6IFwiSEFWRV9FTk9VR0hfREFUQVwiXG59O1xuXG5jbGFzcyBBdWRpb1ZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF1ZGlvTGluayA9IHRoaXMudXBkYXRlQXVkaW9MaW5rLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGxheSA9IHRoaXMucGxheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhdXNlID0gdGhpcy5wYXVzZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIGxldCBhdWRpbyA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpO1xuICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0YXRlQ29kZSA9IGF1ZGlvLnJlYWR5U3RhdGU7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBcInJlYWR5U3RhdGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVN0YXRlc1tzdGF0ZUNvZGVdXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZighdGhpcy5oYWxvQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyRGlzY29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICBsZXQgbmFtZVNwYW4gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKTtcbiAgICAgICAgbmFtZVNwYW4uaW5uZXJUZXh0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwibmFtZVwiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwicmVhZHlTdGF0ZVwiLFxuICAgICAgICAgICBcIkhBVkVfTk9USElOR1wiXG4gICAgICAgICk7XG4gICAgICAgIGxldCBhdWRpbyA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpO1xuICAgICAgICBsZXQgc3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwic3JjXCIpO1xuICAgICAgICBpZihzcmMpe1xuICAgICAgICAgICAgYXVkaW8uc3JjID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3AgY2hhbmdlc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcIm5hbWVcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuYW1lU3Bhbi5pbm5lclRleHQgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwicmVhZHlTdGF0ZVwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGxldCBib3JkZXJDb2xvciA9IFwicmVkXCI7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PSBcIkhBVkVfRlVUVVJFX0RBVEFcIiB8fCB2YWx1ZSA9PSBcIkhBVkVfRU5PVUdIX0RBVEFcIil7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBcImdyZWVuXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgYGJvcmRlci0ke3NpZGV9LWNvbG9yYCwgYm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcInBsYXlcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoXCJzdG9wXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYodmFsdWUgPT09IHRydWUpe1xuICAgICAgICAgICAgICAgIGF1ZGlvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwic3JjXCIsICh1cmwpID0+IHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZSBsb2FkIGlzIGF1dG8tbG9hZGVkIGJ5IHRoZSA8YXVkaW8+IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBhdWRpby5zcmMgPSB1cmw7XG4gICAgICAgICAgICB9IGNhdGNoKGVycm9yKXtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJSZXNvdXJjZU5vdEZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlVHlwZTogXCJhdWRpb1wiLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IHRoaXMubW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtzb3VyY2U6IHVybCwgdHlwZTogXCJ1cmxcIn1cblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7ZXJyb3JNc2d9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGxheSgpe1xuICAgICAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgcmVzb3VyY2UgaXMgcmVhZHlcbiAgICAgICAgbGV0IGF1ZGlvID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiYXVkaW9cIik7XG4gICAgICAgIGxldCByZWFkeVN0YXRlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicmVhZHlTdGF0ZVwiKTtcbiAgICAgICAgaWYocmVhZHlTdGF0ZSA9PSBcIkhBVkVfRlVUVVJFX0RBVEFcIiB8fCByZWFkeVN0YXRlID09IFwiSEFWRV9FTk9VR0hfREFUQVwiKXtcbiAgICAgICAgICAgIGF1ZGlvLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KGBhdWRpbyBpcyBub3QgcmVhZHk7IGN1cnJlbnQgc3RhdGU6ICR7cmVhZHlTdGF0ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhdXNlKCl7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgLy8gcmUtbG9hZHMgdGhlIG1lZGlhLCBzZXR0aW5nIGl0IGJhY2sgdG8gdGhlIGJlZ2duaW5nXG4gICAgc3RvcCgpe1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKS5sb2FkKCk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgdGhlIG9uIGNsaWNrIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNsaWNrIGNvbW1hbmQgbWVzc2FnZSB0byBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0LiBIZXJlIHdlIGFkZCBhIGN1c3RvbSBidXR0b25cbiAgICAgICAgLy8gd2hlbiBzaG93aW5nLlxuICAgICAgICBsZXQgZm91bmRIYWxvID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3N0LWhhbG8nKTtcbiAgICAgICAgaWYoIWZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZm91bmRIYWxvKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEhhbG8uYXBwZW5kKHRoaXMuaGFsb0J1dHRvbik7XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b24oKXtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pZCA9ICdoYWxvLWF1ZGlvLWxpbmsnO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uY2xhc3NMaXN0LmFkZCgnaGFsby1idXR0b24nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlubmVySFRNTCA9IGxpbmtJY29uO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc3R5bGUubWFyZ2luVG9wID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdyaWdodC1jb2x1bW4nKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnRWRpdCBsaW5rIGZvciBhdWRpbyBzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVBdWRpb0xpbmspO1xuICAgIH1cblxuICAgIHVwZGF0ZUF1ZGlvTGluayhldmVudCl7XG4gICAgICAgIC8vIFRlbGxzIHRoZSBtb2RlbCB0byB1cGRhdGUgaXRzXG4gICAgICAgIC8vIHNyYyBsaW5rIGZvciB0aGUgYXVkaW9cbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3NyYydcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoXCJFZGl0IFVSTCBmb3IgYXVkaW86XCIsIGN1cnJlbnRTcmMpO1xuICAgICAgICBpZihyZXN1bHQgJiYgcmVzdWx0ICE9PSAnJyAmJiByZXN1bHQgIT09IGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdsb2FkQXVkaW9Gcm9tU291cmNlJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyByZXN1bHQgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuXG5leHBvcnQge1xuICAgIEF1ZGlvVmlldyxcbiAgICBBdWRpb1ZpZXcgYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgbGlua0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbGlua1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAgMTRhMy41IDMuNSAwIDAgMCA1IDBsNCAtNGEzLjUgMy41IDAgMCAwIC01IC01bC0uNSAuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTBhMy41IDMuNSAwIDAgMCAtNSAwbC00IDRhMy41IDMuNSAwIDAgMCA1IDVsLjUgLS41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG46aG9zdCB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcGFkZGluZzogMXB4O1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cbmlmcmFtZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuPC9zdHlsZT5cbjxpZnJhbWUgZnJhbWVib3JkZXI9XCIwXCIgYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPlxuYDtcblxuY2xhc3MgQnJvd3NlclZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uID0gdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJyb3dzZXJMaW5rID0gdGhpcy51cGRhdGVCcm93c2VyTGluay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIGlmKCF0aGlzLmhhbG9CdXR0b24pe1xuICAgICAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIGxldCBpZnJhbWUgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJpZnJhbWVcIik7XG4gICAgICAgIGxldCBzcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJzcmNcIik7XG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwic3JjXCIsICh1cmwpID0+IHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAvLyByZXNvdXJjZSBsb2FkIGlzIGF1dG8tbG9hZGVkIGJ5IHRoZSA8YnJvd3Nlcj4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmcmFtZS5zcmMgPSB1cmw7XG4gICAgICAgICAgICB9IGNhdGNoKGVycm9yKXtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJSZXNvdXJjZU5vdEZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlVHlwZTogXCJicm93c2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRJZDogdGhpcy5tb2RlbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczoge3NvdXJjZTogdXJsLCB0eXBlOiBcInVybFwifVxuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtlcnJvck1zZ30sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDApe1xuICAgICAgICAgICAgaWYoZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyB0aGUgb24gY2xpY2sgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZighdGhpcy5oYXNPcGVuSGFsbyl7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgY2xpY2sgY29tbWFuZCBtZXNzYWdlIHRvIHNlbGZcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5IYWxvKCl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQuIEhlcmUgd2UgYWRkIGEgY3VzdG9tIGJ1dHRvblxuICAgICAgICAvLyB3aGVuIHNob3dpbmcuXG4gICAgICAgIGxldCBmb3VuZEhhbG8gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc3QtaGFsbycpO1xuICAgICAgICBpZighZm91bmRIYWxvKXtcbiAgICAgICAgICAgIGZvdW5kSGFsbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0LWhhbG8nKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChmb3VuZEhhbG8pO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kSGFsby5hcHBlbmQodGhpcy5oYWxvQnV0dG9uKTtcbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbigpe1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlkID0gJ2hhbG8tYnJvd3Nlci1saW5rJztcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBsaW5rSWNvbjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnN0eWxlLm1hcmdpblRvcCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAncmlnaHQtY29sdW1uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0VkaXQgbGluayBmb3IgYnJvd3NlciBzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVCcm93c2VyTGluayk7XG4gICAgfVxuXG4gICAgdXBkYXRlQnJvd3NlckxpbmsoZXZlbnQpe1xuICAgICAgICAvLyBUZWxscyB0aGUgbW9kZWwgdG8gdXBkYXRlIGl0c1xuICAgICAgICAvLyBzcmMgbGluayBmb3IgdGhlIGJyb3dzZXJcbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3NyYydcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoXCJFZGl0IFVSTCBmb3IgYnJvd3NlcjpcIiwgY3VycmVudFNyYyk7XG4gICAgICAgIGlmKHJlc3VsdCAmJiByZXN1bHQgIT09ICcnICYmIHJlc3VsdCAhPT0gY3VycmVudFNyYyl7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ3NldFVSTFRvJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyByZXN1bHQgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuXG5leHBvcnQge1xuICAgIEJyb3dzZXJWaWV3LFxuICAgIEJyb3dzZXJWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIEJ1dHRvblZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHdlYmNvbXBvbmVudCByZXByZXNlbnRpbmcgYSBCdXR0b24uXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG4gICAgICAgICAgICAgICAgPHN0eWxlPlxuICAgICAgICAgICAgICAgICAuc3QtYnV0dG9uLWxhYmVsIHtcbiAgICAgICAgICAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgICAgICAgICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICAgICAgICAgICBtYXgtd2lkdGg6IDk1JTtcbiAgICAgICAgICAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L3N0eWxlPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3QtYnV0dG9uLWxhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90Pjwvc2xvdD48IS0tIFRleHQgb2YgdGhlIE5hbWUgLS0+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuYDtcblxuY2xhc3MgQnV0dG9uVmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycyA9IHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBTZXR1cCBwcm9wIGNoYW5nZSBoYW5kbGVyc1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ25hbWUnLCAodmFsdWUsIHBhcnRJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbm5lclRleHQgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgbGV0IGJ1dHRvbk5hbWUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcywgXCJuYW1lXCIpO1xuICAgICAgICBpZihidXR0b25OYW1lKXtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJUZXh0ID0gYnV0dG9uTmFtZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgYmFzZSBjbGFzcyBpbXBsZW1lbnRhdGlvblxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCl7XG4gICAgICAgICAgICBpZihldmVudC5zaGlmdEtleSl7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCF0aGlzLmhhc09wZW5IYWxvKXtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBjbGljayBjb21tYW5kIG1lc3NhZ2UgdG8gc2VsZlxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlIC8vIFNob3VsZCBpZ25vcmUgaWYgU3lzdGVtIEROVVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlcndyaXRpbmcgdGhlIGJhc2UgY2xhc3Mgb3Blbi9jbG9zZSBlZGl0b3IgbWV0aG9kc1xuICAgIG9wZW5FZGl0b3IoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5vcGVuRWRpdG9yRm9yUGFydCh0aGlzLm1vZGVsLmlkKTtcbiAgICB9XG5cbiAgICBjbG9zZUVkaXRvcigpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmNsb3NlRWRpdG9yRm9yUGFydCh0aGlzLm1vZGVsLmlkKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEJ1dHRvblZpZXcsXG4gICAgQnV0dG9uVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBDYXJkVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSB3ZWJjb21wb25lbnQgcmVwcmVzZW50YXRpb24gb2YgYSBDYXJkLlxuICovXG5cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG4gICAgICAgICAgICAgICAgPHN0eWxlPlxuICAgICAgICAgICAgICAgIDwvc3R5bGU+XG4gICAgICAgICAgICAgICAgPHNsb3Q+PC9zbG90PlxuYDtcblxuY2xhc3MgQ2FyZFZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSGFsbyBzZXR0aW5ncy4gQ2FyZHMgZG9uJ3Qgd2FudFxuICAgICAgICAvL2EgaGFsbyB0byBvcGVuXG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgZGVmYXVsdCBjbGFzcyBtZXRob2RcbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDAgJiYgZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ29udGV4dE1lbnVJdGVtcyhjb250ZXh0TWVudSl7XG4gICAgICAgIGNvbnRleHRNZW51LmFkZFNwYWNlcigpO1xuICAgICAgICAvLyBUb29sYm94IHRvZ2dsZSBoaWRlL3VuaGlkZVxuICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gd2luZG93LlN5c3RlbS5nZXRDdXJyZW50U3RhY2tNb2RlbCgpO1xuICAgICAgICBsZXQgdG9vbGJveCA9IGN1cnJlbnRTdGFjay5zdWJwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcGFydC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHBhcnQsIFwibmFtZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09IFwiVG9vbGJveFwiO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gdG9vbGJveCBhdCBhbGwsIHRoYXQncyB3ZWlyZCBidXQgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYodG9vbGJveCl7XG4gICAgICAgICAgICBsZXQgaGlkZGVuID0gdG9vbGJveC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRvb2xib3gsIFwiaGlkZVwiKTtcbiAgICAgICAgICAgIGlmKGhpZGRlbil7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiVW5oaWRlIFRvb2xib3hcIixcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sYm94LnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodG9vbGJveCwgXCJoaWRlXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICBcIkhpZGUgVG9vbGJveFwiLFxuICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xib3gucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0b29sYm94LCBcImhpZGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBDYXJkVmlldyxcbiAgICBDYXJkVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBGaWVsZFZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSB0aGUgdmlldyBvZiBhbiBGaWVsZCBwYXJ0LlxuICogSSBhbSBhbiBcImludGVyaW1cIiB2aWV3IGludGVuZGVkIHRvIGRpc3BsYXlcbiAqIGFuZCBlZGl0IHBsYWluIHRleHQgb24gYSBDYXJkLlxuICogSSBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBhIG1vcmUgY29tcHJlaGVuc2l2ZVxuICogaW1wbGVtZW50YXRpb24gb2YgRmllbGQvRmllbGRWaWV3IGluIHRoZSBmdXR1cmUuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcbmltcG9ydCBjc3NTdHlsZXIgZnJvbSAnLi4vdXRpbHMvL3N0eWxlci5qcyc7XG5pbXBvcnQgQ29sb3JXaGVlbFdpZGdldCBmcm9tICcuL2RyYXdpbmcvQ29sb3JXaGVlbFdpZGdldC5qcyc7XG5pbXBvcnQgaW50ZXJwcmV0ZXJTZW1hbnRpY3MgZnJvbSAnLi4vLi4vb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyc7XG5pbXBvcnQgY3JlYXRlSGlnaGxpZ2h0ZXIgZnJvbSAnLi4vdXRpbHMvQWx0U3ludGF4SGlnaGxpZ2h0ZXIuanMnO1xuXG5jb25zdCBoYWxvRWRpdEJ1dHRvblNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci10b29sc1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMyAyMWg0bDEzIC0xM2ExLjUgMS41IDAgMCAwIC00IC00bC0xMyAxM3Y0XCIgLz5cbiAgPGxpbmUgeDE9XCIxNC41XCIgeTE9XCI1LjVcIiB4Mj1cIjE4LjVcIiB5Mj1cIjkuNVwiIC8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCIxMiA4IDcgMyAzIDcgOCAxMlwiIC8+XG4gIDxsaW5lIHgxPVwiN1wiIHkxPVwiOFwiIHgyPVwiNS41XCIgeTI9XCI5LjVcIiAvPlxuICA8cG9seWxpbmUgcG9pbnRzPVwiMTYgMTIgMjEgMTcgMTcgMjEgMTIgMTZcIiAvPlxuICA8bGluZSB4MT1cIjE2XCIgeTE9XCIxN1wiIHgyPVwiMTQuNVwiIHkyPVwiMTguNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGhhbG9Mb2NrQnV0dG9uU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxvY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxyZWN0IHg9XCI1XCIgeT1cIjExXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjEwXCIgcng9XCIyXCI+PC9yZWN0PlxuICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxNlwiIHI9XCIxXCI+PC9jaXJjbGU+XG4gICA8cGF0aCBkPVwiTTggMTF2LTRhNCA0IDAgMCAxIDggMHY0XCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBoYWxvVW5sb2NrQnV0dG9uU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxvY2stb3BlblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHJlY3QgeD1cIjVcIiB5PVwiMTFcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTBcIiByeD1cIjJcIj48L3JlY3Q+XG4gICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjE2XCIgcj1cIjFcIj48L2NpcmNsZT5cbiAgIDxwYXRoIGQ9XCJNOCAxMXYtNWE0IDQgMCAwIDEgOCAwXCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBmaWVsZFRlbXBsYXRlU3RyaW5nID0gYFxuICAgICAgPHN0eWxlPlxuICAgICAgICAuZmllbGQge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgfVxuXG4gICAgICAgIC5maWVsZCBjb2xvci13aGVlbCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIH1cblxuICAgICAgICAuZmllbGQtdGV4dGFyZWEge1xuICAgICAgICAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIDVweCk7XG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICAgICAgICAgIG92ZXJmbG93LXdyYXA6IGFueXdoZXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogU3ludGF4IEhpZ2hsaWdodGluZ1xuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuc3BhbltkYXRhLXN0LXJ1bGU9XCJtZXNzYWdlTmFtZVwiXXtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cblxuc3BhbltkYXRhLXN0LXJ1bGU9XCJrZXl3b3JkXCJde1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xufVxuXG5zcGFuW2RhdGEtc3QtcnVsZT1cIlBhcmFtZXRlckxpc3QtaXRlbVwiXXtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgY29sb3I6IGdyZXk7XG59XG5cblxuICAgIDwvc3R5bGU+XG4gICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZC10ZXh0YXJlYVwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiPjwvZGl2PlxuICAgIDwvZGl2PmA7XG5cblxuZnVuY3Rpb24gZm9ybWF0RG9jKHNDbWQsIHNWYWx1ZSkge1xuICBkb2N1bWVudC5leGVjQ29tbWFuZChzQ21kLCBmYWxzZSwgc1ZhbHVlKTsgb0RvYy5mb2N1cygpO1xufVxuXG5jbGFzcyBGaWVsZFZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyB0aGlzLmVkaXRvckNvbXBsZXRlciA9IHRoaXMuc2ltcGxlVGFsa0NvbXBsZXRlcjtcbiAgICAgICAgdGhpcy50ZXh0U3R5bGVyID0gY3NzU3R5bGVyOyAgLy8gd2UgbWlnaHQgd2FudCB0byBjb25zaWRlciBhIG1vcmUgcHJvZ3JhbW1hdGljIHdheSB0byBzZXQgdGhpc1xuICAgICAgICB0aGlzLmVkaXRvckNvbXBsZXRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlcyA9IHt9O1xuICAgICAgICB0aGlzLndhbnRzQ29udGV4dE1lbnUgPSBmYWxzZTtcblxuICAgICAgICAvLyBQcmVzZXRzIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nLlxuICAgICAgICAvLyBXaGVuIGhpZ2hsaWdodGluZyBpcyBlbmFibGVkLCB3ZSB3aWxsIGNoZWNrXG4gICAgICAgIC8vIGVhY2ggbGluZSBvZiB0aGUgdGV4dCBmb3IgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBncmFtbWF0aWNhbCBydWxlczpcbiAgICAgICAgdGhpcy5fc3ludGF4UnVsZXMgPSBbXG4gICAgICAgICAgICBcIk1lc3NhZ2VIYW5kbGVyT3BlblwiLFxuICAgICAgICAgICAgXCJNZXNzYWdlSGFuZGxlckNsb3NlXCJcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBmaWVsZFRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uSW5wdXQgPSB0aGlzLm9uSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZUlucHV0ID0gdGhpcy5vbkJlZm9yZUlucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uS2V5ZG93biA9IHRoaXMub25LZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZWRvd24gPSB0aGlzLm9uTW91c2Vkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51ID0gdGhpcy5vcGVuQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51ID0gdGhpcy5jbG9zZUNvbnRleHRNZW51LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9JdCA9IHRoaXMuZG9JdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdGlvbiA9IHRoaXMuaGFuZGxlU2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbkZpZWxkID0gdGhpcy5vcGVuRmllbGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0VG9IdG1sID0gdGhpcy50ZXh0VG9IdG1sLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMgPSB0aGlzLnNldHVwUHJvcEhhbmRsZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2ltcGxlVGFsa0NvbXBsZXRlciA9IHRoaXMuc2ltcGxlVGFsa0NvbXBsZXRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9ucyA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0UmFuZ2UgPSB0aGlzLmluc2VydFJhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCA9IHRoaXMuc2V0UmFuZ2VJblRhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbiA9IHRoaXMuc2V0U2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U3ludGF4ID0gdGhpcy5oaWdobGlnaHRTeW50YXguYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodFN5bnRheCA9IHRoaXMudW5oaWdobGlnaHRTeW50YXguYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9wSGFuZGxlcnMoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2VkaXRhYmxlJywgKHZhbHVlLCBpZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uID0gdGhpcy5oYWxvTG9ja0J1dHRvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uID0gdGhpcy5oYWxvVW5sb2NrQnV0dG9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcImVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gJ3RleHQnIGlzIGEgRHluYW1pY1Byb3Agd2hvc2Ugc2V0dGVyIHdpbGwgc2V0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgIC8vIHZhbHVlIGZvciBgaW5uZXJIVE1MYC4gVGhpcyB3YXkgd2UgY2FuIGhhdmUgcHJvZ3JhbW1hdGljIGNvbnRlbnRcbiAgICAgICAgLy8gc2V0dGluZyBhbmQgc3RpbGwgYWxsb3cgdG8gbm90IGxvb3NlIG1hcmt1cC5cbiAgICAgICAgLy8gJ2lubmVySFRNTCcgaXMgYSBCYXNpY1Byb3AuIFNlZSBob3cgdGhlc2UgYXJlIHNldCwgd2l0aG91dFxuICAgICAgICAvLyBub3RpZmljYXRpb24gaW4gdGhpcy5vbklucHV0KClcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2lubmVySFRNTCcsICh2YWx1ZSwgaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVyVGV4dCxcbiAgICAgICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5LCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyBUaGUgZXZlbnRzIGhlcmUgYXJlIGFkZGVkIHZpYSB0aGUgLmFkZEV2ZW50TGlzdGVuZXIoKSBBUEkgd2hpY2ggaXNcbiAgICAgICAgLy8gZGlzdGluY3QgZnJvbSB0aGUgdGhpcy5ldmVudFJlc3BvbmQoKSB3aGljaCB1c2VzIHRoZSBET00gZWxlbWVudFxuICAgICAgICAvLyBlbGVtZW50Lm9uRXZlbnQgQVBJLiBUaGlzIGFsbG93cyB1cyB0byBkaXN0bmd1aXNoIGJldHdlZW4gXCJjb3JlXCJcbiAgICAgICAgLy8gc3lzdGVtLXdlYiBldmVudHMgdGhhdCB3ZSBkb24ndCB3YW50IG1lZGRsZWQgd2l0aCBhdCB0aGUgbW9tZW50LCBsaWtlXG4gICAgICAgIC8vIGVudGVyaW5nIHRleHQgaW4gYSBmaWVsZCwgYW5kIG9uZXMgZXhwb3NlZCBpbiB0aGUgZW52aXJvbmVtbnQgZm9yIHNjcmlwdGluZ1xuICAgICAgICB0aGlzLnRleHRhcmVhID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZmllbGQtdGV4dGFyZWEnKTtcblxuICAgICAgICB0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0KTtcbiAgICAgICAgLy90aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0JywgdGhpcy5vbkJlZm9yZUlucHV0KTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleWRvd24pO1xuICAgICAgICB0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZWRvd24pO1xuICAgICAgICAvLyBObyBuZWVkIHRvIGFkZCBhIGNsaWNrIGxpc3RlbmVyIGFzIHRoZSBiYXNlIFBhcnRWaWV3IGNsYXNzIGRvZXMgdGhhdFxuXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGRlYWwgd2l0aCByYW5nZSBpbnNlcnRpb25zIChmb3Igc3R5bGluZyB0ZXh0IGZyYWdtZW50cyB3aXRoaW5cbiAgICAgICAgLy8gdGhlIHRleHRhcmVhKSwgd2UgbmVlZCB0byBoYXZlIHRoZSBkZWZhdWx0IHBhcmFncmFwaCB0YWcgPSA8L2JyPi4gT3RoZXJ3aXNlXG4gICAgICAgIC8vIHRoZSBpbnNlcnQgbmV3IGxpbmUgaXMgb2YgdGhlIGZvcm0gPGRpdj48L2JyPjxkaXY+IHdoaWNoIGNhdXNlcyB0aGUgYXBwZWFyYW5jZVxuICAgICAgICAvLyBvZiBuZXdsaW5lcyB3aGVuIG5vZGVzIGFyZSBpbnNlcnRlZCBpbnRvIGEgcmFuZ2VcbiAgICAgICAgLy9kb2N1bWVudC5leGVjQ29tbWFuZChcImRlZmF1bHRQYXJhZ3JhcGhTZXBhcmF0b3JcIiwgZmFsc2UsIFwic3QtbGluZVwiKTtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICB0aGlzLnRleHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0KTtcbiAgICAgICAgLy90aGlzLnRleHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0JywgdGhpcy5vbkJlZm9yZUlucHV0KTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleWRvd24pO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZWRvd24pO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmZpZWxkLXRleHRhcmVhJyk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtb2RlbCwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdGV4dGFyZWFcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgaHRtbCBvZiB0aGUgZmllbGQgbW9kZWxcbiAgICAgICAgbGV0IGlubmVySFRNTCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnaW5uZXJIVE1MJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVySFRNTCA9IGlubmVySFRNTDtcblxuICAgICAgICBsZXQgaXNFZGl0YWJsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImVkaXRhYmxlXCIpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgaXNFZGl0YWJsZSk7XG5cbiAgICAgICAgLy8gc2V0dXAgdGhlIGxvY2svdW5sb2NrIGhhbG8gYnV0dG9uXG4gICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b25zKCk7XG4gICAgICAgIGxldCBlZGl0YWJsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnZWRpdGFibGUnXG4gICAgICAgICk7XG4gICAgICAgIGlmKGVkaXRhYmxlID09PSB0cnVlKXtcbiAgICAgICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSB0aGlzLmhhbG9Mb2NrQnV0dG9uO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKFwiZWRpdGFibGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdGFibGUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIHRoaXMuaGFsb0xvY2tVbmxvY2tCdXR0b24gPSB0aGlzLmhhbG9VbmxvY2tCdXR0b247XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNpbXBsZVRhbGtDb21wbGV0ZXIoZWxlbWVudCl7XG4gICAgICAgIGxldCB0ZXh0Q29udGVudCA9IHRoaXMuaHRtbFRvVGV4dChlbGVtZW50KTtcbiAgICAgICAgbGV0IHN0YXJ0T2ZIYW5kbGVyUmVnZXggPSAvXm9uXFxzKFxcdyspKFxcc3xcXG4pKyQvO1xuICAgICAgICBsZXQgbWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaChzdGFydE9mSGFuZGxlclJlZ2V4KTtcbiAgICAgICAgaWYobWF0Y2gpe1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VOYW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBicmVhayBpcyBhIG5ldyBsaW5lIHRoZW4gYW4gZXh0cmFcbiAgICAgICAgICAgIC8vIDxkaXY+PC9icj48L2Rpdj4gaGFzIGJlZWQgYWRkZWQgaW50byB0aGUgZWxlbWVuIGFscmVhZHlcbiAgICAgICAgICAgIGxldCB0YWJMaW5lID0gXCJcXHRcXG5cIjtcbiAgICAgICAgICAgIGlmKG1hdGNoWzJdID09PSBcIlxcblwiKXtcbiAgICAgICAgICAgICAgICB0YWJMaW5lPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBgJHt0YWJMaW5lfWVuZCAke21lc3NhZ2VOYW1lfWA7XG4gICAgICAgICAgICBsZXQgaW5uZXJIVE1MID0gdGhpcy50ZXh0VG9IdG1sKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGlubmVySFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSSBvdmVycmlkZSBteSBiYXNlLWNsYXNzJ3MgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRhcmdldCByZWxhdGVkIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICBzdHlsZVRleHRDU1MoKXtcbiAgICAgICAgbGV0IHRleHRhcmVhID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZmllbGQtdGV4dGFyZWEnKTtcbiAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwiY3NzVGV4dFN0eWxlXCIpO1xuICAgICAgICBPYmplY3Qua2V5cyhjc3NTdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjc3NTdHlsZVtrZXldO1xuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YXJnZXQgYW5kIHJhbmdlIHNldCB0aGVuIHNlbmQgdGhlIHRhcmdldCBhbiB1cGRhdGUgbWVzc2FnZVxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsICd0YXJnZXQnKTtcbiAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCh0YXJnZXQsIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLCBjc3NTdHlsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIHNldCBhIHRleHQtKiBwcm9wZXJ0eSBvbiBzZWxlY3Rpb24gdG8gc3R5bGUgdGhlIHNlbGVjdGVkIHRleHRcbiAgICAgKiBOb3RlOiB0aGlzIGlzIGRvbmUgZm9yIGV2ZXJ5IGN1cnJlbnQgc2VsZWN0aW9uLCBpLmUuIGV2ZXJ0aGluZ1xuICAgICAqIGluIHRoaXMuc2VsZWN0aW9uUmFuZ2VzXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHByb3BOYW1lLCB2YWx1ZSl7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5zZWxlY3Rpb25SYW5nZXMpLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0eWxlID0ge307XG4gICAgICAgICAgICAvLyAvLyBpZiB0aGUgZG9jdW1lbnQgZnJhZ21lbnQgaGFzIG9uZSBjaGlsZCBub2RlIGFuZCBpdCdzIGEgc3BhblxuICAgICAgICAgICAgLy8gLy8gd2Ugc2hvdWxkIHN0eWxlIHRoYXQgZGlyZWN0bHkuIFRoaXMgYXZvaWRzIHVubmNlc3NhcnkgRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyAvLyBiZWluZyBjcmVhdGVkIHRvIHdyYXAgdGhlIGNvbnRlbnRzLCBzdWNoIGFzIHdoZW4gc3R5bGluZyBpcyBjb250aW51YWxseVxuICAgICAgICAgICAgLy8gLy8gYXBwbGllZCBvdCB0aGUgc2FtZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIGxldCBzcGFuO1xuICAgICAgICAgICAgLy8gaWYoZG9jRnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBkb2NGcmFnbWVudC5jaGlsZE5vZGVzWzBdLm5vZGVOYW1lID09IFwiU1BBTlwiKXtcbiAgICAgICAgICAgIC8vICAgICBzcGFuID0gZG9jRnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIC8vICAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgT2JlamN0LnZhbHVlcyBoZXJlIGZvciB0aGUgRE9NIHN0eWxlIGF0dHJpYnV0ZSBvYmplY3RcbiAgICAgICAgICAgIC8vICAgICAvLyB0aGF0J3Mgd2VpcmRcbiAgICAgICAgICAgIC8vICAgICBPYmplY3QudmFsdWVzKHNwYW4uc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgICAgICBjdXJyZW50U3R5bGVba2V5XSA9IHNwYW4uc3R5bGVba2V5XTtcbiAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgYSBzcGFuIGVsZW1lbnQgdG8gd3JhcCB0aGUgY29udGVudHMgaW4gc3R5bGVcbiAgICAgICAgICAgIC8vICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgLy8gICAgIC8vIFdoaWxlIHRlbXB0aW5nIHRvIHVzZSByYW5nZS5zdXJyb3VuZENvbnRlbnRzKCkgYXZvaWQgdGhpc1xuICAgICAgICAgICAgLy8gICAgIC8vIHNpbmNlIGl0IHdpbGwgZmFpbCB3aXRoIGEgbm9uLWluZm9ybWF0aXZlIGVycm9yIGlmIHRoZSByYW5nZVxuICAgICAgICAgICAgLy8gICAgIC8vIGluY2x1ZGVzIHBhcnRpYWwgbm9kZXMgKGV4IHRleHQgYWNyb3NzIHZhcmlvdXMgbm9kZXMpXG4gICAgICAgICAgICAvLyAgICAgd2hpbGUgKGRvY0ZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIC8vICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkb2NGcmFnbWVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGxldCBjc3NPYmplY3QgPSB0aGlzLnRleHRTdHlsZXIoY3VycmVudFN0eWxlLCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzT2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzcGFuLnN0eWxlW2tleV0gPSBjc3NPYmplY3Rba2V5XTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzcGFuLmFwcGVuZChyYW5nZS5leHRyYWN0Q29udGVudHMoKSk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHNwYW4pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaW5uZXJIVE1MJyxcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRhcmVhLmlubmVySFRNTCxcbiAgICAgICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YXJnZXQgYW5kIHJhbmdlIHNldCB0aGVuIHNlbmQgdGhlIHRhcmdldCBhbiB1cGRhdGUgbWVzc2FnZVxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCAndGFyZ2V0Jyk7XG4gICAgICAgICAgICBpZih0YXJnZXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCh0YXJnZXQsIHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25CZWZvcmVJbnB1dChldmVudCl7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsZWN0ZWRSYW5nZS5jbG9uZVJhbmdlKCk7XG5cbiAgICAgICAgbGV0IGlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgIGlmKCFpbm5lckhUTUwuZW5kc1dpdGgoXCI8ZGl2Pjxicj48L2Rpdj5cIikpe1xuICAgICAgICAgICAgaW5uZXJIVE1MICs9IFwiPGRpdj48YnI+PC9kaXY+XCI7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRQYXJhZ3JhcGhcIil7XG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgbGV0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcbiAgICAgICAgICAgIGxldCBicjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpO1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShicik7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGJyMik7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKGJyMik7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihicjIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25JbnB1dChldmVudCl7XG4gICAgICAgIGxldCBpbm5lckhUTUwgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MO1xuICAgICAgICAvKlxuICAgICAgICBpZighaW5uZXJIVE1MLmVuZHNXaXRoKFwiPGJyPlwiKSl7XG4gICAgICAgICAgICBpbm5lckhUTUwgKz0gXCI8YnI+XCI7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAgICAgaWYodGhpcy5lZGl0b3JDb21wbGV0ZXIpe1xuICAgICAgICAgICAgLy8gVE9ETyBzb3J0IG91dCBob3cgdGhpcyB3b3VsZCB3b3JrXG4gICAgICAgICAgICBsZXQgaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTDtcbiAgICAgICAgICAgIGlubmVySFRNTCA9IHRoaXMuZWRpdG9yQ29tcGxldGVyKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVyVGV4dCxcbiAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnksIHRvIHByZXNlcnZlIGNvbnRlbnRlZGl0YWJsZSBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnaW5uZXJIVE1MJyxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwsXG4gICAgICAgICAgICBmYWxzZSAvLyBkbyBub3Qgbm90aWZ5XG4gICAgICAgICk7XG4gICAgICAgIC8vIFNpbmNlIHdlIHVwZGF0ZSB0aGUgJ3RleHQnIHByb3BlcnR5IHdpdGhvdXQgbm90aWZpY2F0aW9uLCB0aGUgcGFydC9tb2RlbFxuICAgICAgICAvLyBpcyBub3Qgc2VudCB0aGUgXCJwcm9wZXJ0eUNoYW5nZWRcIiBtZXNzYWdlIHNvIHdlIGRvIHNvIG1hbnVhbGx5XG4gICAgICAgIHRoaXMubW9kZWwucHJvcGVydHlDaGFuZ2VkKFwidGV4dFwiLCBldmVudC50YXJnZXQuaW5uZXJUZXh0KTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YXJnZXQgYW5kIHJhbmdlIHNldCB0aGVuIHNlbmQgdGhlIHRhcmdldCBhbiB1cGRhdGUgbWVzc2FnZVxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsICd0YXJnZXQnKTtcbiAgICAgICAgaWYodGFyZ2V0KXtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJblRhcmdldCh0YXJnZXQsIGV2ZW50LnRhcmdldC5pbm5lckhUTUwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlkb3duKGV2ZW50KXtcbiAgICAgICAgLy8gcHJldmVudCB0aGUgZGVmYXVsdCB0YWIga2V5IHRvIGxlYXZlIGZvY3VzIG9uIHRoZSBmaWVsZFxuICAgICAgICBpZihldmVudC5rZXk9PT1cIlRhYlwiKXtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvL2RvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgZmFsc2UsICcmI3g5Jyk7XG4gICAgICAgICAgICBsZXQgc2VsID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcblxuICAgICAgICAgICAgbGV0IHRhYk5vZGVWYWx1ZSA9ICdcXHQnO1xuICAgICAgICAgICAgbGV0IHRhYk5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0YWJOb2RlVmFsdWUpO1xuXG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHRhYk5vZGUpO1xuXG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKHRhYk5vZGUpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIodGFiTm9kZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgb25Nb3VzZWRvd24oZXZlbnQpe1xuICAgICAgICAvLyBjbGVhciBhbGwgc2VsZWN0aW9uc1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlcyA9IHt9O1xuICAgIH1cbiAgICBvbkNsaWNrKGV2ZW50KXtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB3ZSB0b2dnbGUgdGhlIGhhbG9cbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCk7XG4gICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyB0ZXh0IGlzIHNlbGVjdGVkIHdlIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBpZih0ZXh0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFsdEtleSBpcyBwcmVzc2VkIHdlIG9wZW4gdGhlIGNvbnRleHQgKFwiZG8gaXRcIikgbWVudVxuICAgICAgICAgICAgICAgICAgICBpZihldmVudC5hbHRLZXkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuY29udGV4dE1lbnVPcGVuKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5Db250ZXh0TWVudSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb24oZXZlbnQubWV0YUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgbm8gY29udGV4dCBtZW51IGlzIG9wZW5cbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb250ZXh0TWVudU9wZW4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgYWxsIHRoZSBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2VzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogSSBoYW5kbGUgc2VsZWN0ZWQgdGV4dCwgY3JlYXRpbmcgYSBuZXcgZmllbGQgbW9kZWwvdmlld1xuICAgICAqIGZvciBldmVyeSByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLCBrZWVwaW5nIHRyYWNrIG9mIGV2ZXJ5IHJhbmdlXG4gICAgICogaW4gdGhpcy5zZWxlY3Rpb24gT2JqZWN0L2RpY3Qgc28gdGhhdCBtb2RpZmljYXRpb24gY2FuIGJlIGluc2VydGVkXG4gICAgICogYmFjayBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVTZWxlY3Rpb24ob3Blbk5ld0ZpZWxkKXtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSsrKXtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGlzIGlzIG5vdCBhIGNvbnRpbnVpbmcgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyBhbmQgdGhhdCB0aGUgcmFuZ2UgaXMgbm90IGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XG4gICAgICAgICAgICBsZXQgY3VycmVudFJhbmdlcyA9IE9iamVjdC52YWx1ZXModGhpcy5zZWxlY3Rpb25SYW5nZXMpO1xuICAgICAgICAgICAgaWYoY3VycmVudFJhbmdlcy5pbmRleE9mKHJhbmdlKSA+PSAwKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGdlbmVyYXRlIG91ciBvd24gcmFuZ2UgaWRzLCBzaW5jZSB3ZSB3YW50IHRoaXMgdG8gY29ycmVzcG9uZCB0b1xuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIG9yZGVyIHdoaWNoIGlzIG5vdCByZXNwZWN0ZWQgYnkgdGhlIGJyb3dzZXIgc2VsZWN0aW9uIG9iamVjdFxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHdlIGRvbid0IGhpdCBvbiBvdGhlciB2aWV3cycgcmFuZ2VzIGJ5IGFjY2lkZW50IHdlIG5lZWQgdW5pcXVlIGlkJ3NcbiAgICAgICAgICAgIGxldCByYW5nZUlkID0gRGF0ZS5ub3coKTsgLy9UT0RPIHdlIG5lZWQgYSBiZXR0ZXIgcmFuZG9tIGlkXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlc1tyYW5nZUlkXSA9IHJhbmdlO1xuICAgICAgICAgICAgaWYob3Blbk5ld0ZpZWxkKXtcbiAgICAgICAgICAgICAgICAvLyBvcGVuIGEgZmllbGQgZm9yIGVhY2ggbmV3IHNlbGVjdGlvbiBhbmQgcG9wdWxhdGUgaXQgd2l0aCB0aGUgcmFuZ2UgaHRtbFxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkZpZWxkKHJhbmdlLCByYW5nZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5GaWVsZChyYW5nZSwgcmFuZ2VJZCl7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBIVE1MIGRvY3VtZW50IGZyYWdtZW50IGZyb20gdGhlIHJhbmdlIHRvIGF2b2lkIGRlYWxpbmcgd2lodCBzdGFydC9lbmRcbiAgICAgICAgLy8gYW5kIG9mZnNldCBjYWxjdWxhdGlvbnNcbiAgICAgICAgLy8gZnJhZ21lbnRzIGRvbid0IGhhdmUgdGhlIGZ1bGwgaHRtbCBET00gZWxlbWVudCBBUEkgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKHJhbmdlLmNsb25lQ29udGVudHMoKSk7XG5cbiAgICAgICAgLy8gVE9ETyB0aGVzZSBzaG91bGQgYWxsIGJlIG1lc3NhZ2VzIGFuZCBjb3JyZXNwbmRpbmcgY29tbWFuZCBoYW5kbGVyIGRlZmluaXRpb25zXG4gICAgICAgIC8vIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBmaWVsZCdzIG93biBzY3JpcHRcbiAgICAgICAgbGV0IGZpZWxkTW9kZWwgPSB3aW5kb3cuU3lzdGVtLm5ld01vZGVsKFwiZmllbGRcIiwgdGhpcy5tb2RlbC5fb3duZXIuaWQsIGBzZWxlY3Rpb24gJHtyYW5nZUlkfWApO1xuICAgICAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoZmllbGRNb2RlbCwgXCJpbm5lckhUTUxcIiwgc3Bhbi5pbm5lckhUTUwpO1xuICAgICAgICBmaWVsZE1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoZmllbGRNb2RlbCwgXCJ0YXJnZXRcIiwgYGZpZWxkIGlkICR7dGhpcy5tb2RlbC5pZH1gKTtcbiAgICAgICAgZmllbGRNb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKGZpZWxkTW9kZWwsIFwidGFyZ2V0UmFuZ2VJZFwiLCByYW5nZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogR2l2ZW4gYSB0YWdyZ2V0IHNwZWNpZmllciBhbmQgaHRtbFxuICAgICAgKiBJIGZpcnN0IGxvb2sgdXAgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHRhcmdldCBoYXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICogcmFuZ2UgKGNvbWluZyBmcm9tIHRoZSB0YXJnZXRSYW5nZUlkIHByb3BlcnR5KSwgYW5kIHRoZW4gc2V0IGl0IHdpdGggbXlcbiAgICAgICogaW5uZXJIVE1MLiBOb3RlLCBzaW5jZSB0aGUgdGFyZ2V0IHByb3BlcnR5IHZhbHVlIGlzIGFuIG9iamVjdCBzcGVjaWZpZXIgSVxuICAgICAgKiBjcmVhdGUgYSBzZW1hbnRpY3Mgb2JqZWN0cyBhbmQgaW50ZXJwcmV0IHRoZSB2YWx1ZSByZXN1bHRpbmcgaW4gYSB2YWxpZFxuICAgICAgKiBwYXJ0IGlkLlxuICAgICAgKi9cbiAgICBzZXRSYW5nZUluVGFyZ2V0KHRhcmdldFNwZWNpZmllciwgaHRtbCwgY3NzKXtcbiAgICAgICAgbGV0IHRhcmdldFJhbmdlSWQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgJ3RhcmdldFJhbmdlSWQnKTtcbiAgICAgICAgbGV0IG1hdGNoID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLm1hdGNoKHRhcmdldFNwZWNpZmllciwgXCJPYmplY3RTcGVjaWZpZXJcIik7XG4gICAgICAgIGxldCBzZW1hbnRpY3MgPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgIHNlbWFudGljcy5hZGRPcGVyYXRpb24oJ2ludGVycHJldCcsIGludGVycHJldGVyU2VtYW50aWNzKHRoaXMubW9kZWwsIHdpbmRvdy5TeXN0ZW0pKTtcbiAgICAgICAgbGV0IHRhcmdldElkID0gc2VtYW50aWNzKG1hdGNoKS5pbnRlcnByZXQoKTtcblxuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiaW5zZXJ0UmFuZ2VcIixcbiAgICAgICAgICAgIGFyZ3M6IFt0YXJnZXRSYW5nZUlkLCBodG1sLCBjc3NdXG4gICAgICAgIH0sIHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW3RhcmdldElkXSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJIGluc2VydCB0aGUgaHRtbCAoc3RyaW5nKSBpbnRvIHRoZSBzcGVjaWZpZWQgcmFuZ2UgKGJ5IGlkKVxuICAgICAqL1xuICAgIGluc2VydFJhbmdlKHJhbmdlSWQsIGh0bWwsIGNzc09iail7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMuc2VsZWN0aW9uUmFuZ2VzW3JhbmdlSWRdO1xuICAgICAgICBpZihyYW5nZSl7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIGlmKGNzc09iail7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzT2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gY3NzT2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoc3Bhbik7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHRleHQgYW5kIGlubmVySFRNTCBwcm9wZXJ0aWVzIHdpdGhvdXQgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHNldHRpbmcgb2YgdGhlIHRleHQvaHRtbFxuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuaW5uZXJUZXh0LFxuICAgICAgICAgICAgICAgIGZhbHNlIC8vIGRvIG5vdCBub3RpZnksIHRvIHByZXNlcnZlIGNvbnRlbnRlZGl0YWJsZSBjb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgZmFsc2UgLy8gZG8gbm90IG5vdGlmeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5Db250ZXh0TWVudSgpe1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBmb2N1c05vZGUgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS5mb2N1c05vZGU7XG4gICAgICAgIGxldCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICBidXR0b24uaWQgPSBcImRvSXRcIjtcbiAgICAgICAgYnV0dG9uLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjEwcHhcIjtcbiAgICAgICAgYnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidmFyKC0tcGFsZXR0ZS1ncmVlbilcIjtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gXCJEbyBpdCFcIjtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmRvSXQpO1xuICAgICAgICBmb2N1c05vZGUuYWZ0ZXIoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudU9wZW4gPSB0cnVlO1xuICAgIH07XG5cbiAgICBjbG9zZUNvbnRleHRNZW51KCl7XG4gICAgICAgIGxldCBidXR0b24gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNkb0l0Jyk7XG4gICAgICAgIGlmKGJ1dHRvbil7XG4gICAgICAgICAgICBidXR0b24ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgdGhlIHNlbGVjdGlvbiBhbmQgc2V0IHRoZSBjb250ZXh0IG1lbnUgdG8gY2xvc2VkXG4gICAgICAgIGRvY3VtZW50LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51T3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvSXQoZXZlbnQpe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgbGV0IHRleHQgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpO1xuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgdGV4dCB0byBtYWtlIHN1cmUgbm8gbmV3bGluZXMgb3Igc3BhY2VzIG1hZGUgaXQgaW5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXltcXHRcXG4gXSsvLCBcIlwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvW1xcdFxcbiBdKyQvLCBcIlwiKTtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgIC8vIHNlbmQgbWVzc2FnZSB0byBjb21waWxlIHRoZSBwcmVwcGVkIHNjcmlwdFxuICAgICAgICBsZXQgc2NyaXB0ID0gYG9uIGRvSXRcXG4gICAke3RleHR9XFxuZW5kIGRvSXRgO1xuICAgICAgICAvLyBzZW5kIHRoZXNlIG1lc3NhZ2VzIGZyb20gdGhlIG1vZGVsIChub3QgdGhlIHZpZXcpXG4gICAgICAgIC8vIHNpbmNlIGlmIHRoZXJlIGlzIGFuIGVycm9yIHRoZSBvcmlnaW5hbCBzZW5kZXIgd2lsbFxuICAgICAgICAvLyBoYXZlIGFuIGlkXG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21waWxlXCIsXG4gICAgICAgICAgICAgICAgY29kZVN0cmluZzogc2NyaXB0LFxuICAgICAgICAgICAgICAgIHRhcmdldElkOiB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcImRvSXRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9ucygpe1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uaWQgPSBcImhhbG8tZmllbGQtbG9jay1lZGl0b3JcIjtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLmlubmVySFRNTCA9IGhhbG9Mb2NrQnV0dG9uU1ZHO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvTG9ja0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnYm90dG9tLXJvdycpO1xuICAgICAgICB0aGlzLmhhbG9Mb2NrQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnTG9jayBFZGl0aW5nJyk7XG4gICAgICAgIHRoaXMuaGFsb0xvY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdzZXRQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgYXJnczogW1wiZWRpdGFibGVcIiwgZmFsc2VdLFxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgLy8gY2xvc2Uvb3BlbiB0aGUgaGFsbyB0byB1cGRhdGUgdGhlIGVkaXRpbmcgc3RhdGUgdG9nZ2xlIGJ1dHRvblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5pZCA9IFwiaGFsby1maWVsZC11bmxvY2stZWRpdG9yXCI7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9VbmxvY2tCdXR0b24uaW5uZXJIVE1MID0gaGFsb1VubG9ja0J1dHRvblNWRztcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvVW5sb2NrQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdib3R0b20tcm93Jyk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ1VubG9jayBFZGl0aW5nJyk7XG4gICAgICAgIHRoaXMuaGFsb1VubG9ja0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ3NldFByb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJlZGl0YWJsZVwiLCB0cnVlXSxcbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgLy8gY2xvc2Uvb3BlbiB0aGUgaGFsbyB0byB1cGRhdGUgdGhlIGVkaXRpbmcgc3RhdGUgdG9vZ2xlIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9Mb2NrVW5sb2NrQnV0dG9uKTtcbiAgICB9XG5cbiAgICAvLyBPdmVyd3JpdGluZyB0aGUgYmFzZSBjbGFzcyBvcGVuL2Nsb3NlIGVkaXRvciBtZXRob2RzXG4gICAgb3BlbkVkaXRvcigpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLm9wZW5FZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgIH1cblxuICAgIGNsb3NlRWRpdG9yKCl7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uY2xvc2VFZGl0b3JGb3JQYXJ0KHRoaXMubW9kZWwuaWQpO1xuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBJIGNvbnZlcnQgcmF3IHRleHQgdG8gaHRtbCByZXNwZWN0aW5nIHRoZSBGaXJlZm94XG4gICAgICogY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZSBndWlkZWxuZXMuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHNpbmdsZSBsaW5zIG9mIHRleHQgYXJlIGxlZnQgYXMgaXM7XG4gICAgICogbXVsdGlsaW5lIHRleHQsIGkuZS4gdGV4dCB3aGljaCBpbmNsdWRlcyBcIlxcblwiLCBpc1xuICAgICAqIHdyYXBwZWQgaW4gPGRpdj48L2Rpdj4gZm9yIGV2ZXJ5IGxpbmU7IGFuZCB0aGUgbGFzdFxuICAgICAqIGxpbmUgZ2V0cyBhIDxicj4gdGFnIGluc2VydGVkIGJlZm9yZSB0aGUgPC9kaXY+IHRvIHJlZmxlY3RcbiAgICAgKiB0aGUgXCJvbi1lbnRlci1rZXlcIiBiZWhhdmlvci5cbiAgICAgKi9cbiAgICB0ZXh0VG9IdG1sKHRleHQpe1xuICAgICAgICBpZih0ZXh0KXtcbiAgICAgICAgICAgIGxldCB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgaWYodGV4dExpbmVzLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgIGxldCBodG1sID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0ZXh0TGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihsaW5lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gYDxkaXY+JHtsaW5lfTwvZGl2PmA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IFwiPGRpdj48YnI+PC9kaXY+XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIGA8ZGl2PiR7aHRtbH08YnI+PC9kaXY+YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGh0bWxUb1RleHQoZWxlbWVudCl7XG4gICAgICAgIC8vIFRPRE8gdGhpcyBpcyB2ZXJ5IG5haXZlIGFuZCBpZ25vcmVzIG1vc3QgcG9zc2libGUgc3RydWN0dXJlXG4gICAgICAgIGlmKGVsZW1lbnQuaW5uZXJIVE1MKXtcbiAgICAgICAgICAgIC8vIGZpcnN0IHJlcGxhY2UgYWxsIHRoZSBcIjwvZGl2PjxkaXY+XCIgd2l0aCBsaW5lIGJyZWFrc1xuICAgICAgICAgICAgbGV0IGNsZWFuSFRNTCA9ICBlbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKC88XFwvZGl2PjxkaXY+L2csIFwiXFxuXCIpO1xuICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgYWxsIGh0bWxcbiAgICAgICAgICAgIGxldCB0ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBjbGVhbkhUTUw7XG4gICAgICAgICAgICBsZXQgY2xlYW5UZXh0ID0gdGVtcEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB0ZW1wRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhblRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZ2hsaWdodFN5bnRheCgpe1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwic3ludGF4XCIpO1xuICAgICAgICBpZihjdXJyZW50ICYmIGN1cnJlbnQgIT09IFwiZmFsc2VcIil7XG4gICAgICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0U3ludGF4KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbWFudGljcyA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5jcmVhdGVTZW1hbnRpY3MoKTtcbiAgICAgICAgc2VtYW50aWNzLmFkZE9wZXJhdGlvbihcbiAgICAgICAgICAgIFwiaGlnaGxpZ2h0U3ludGF4XCIsXG4gICAgICAgICAgICBjcmVhdGVIaWdobGlnaHRlcih0aGlzKVxuICAgICAgICApO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcInRleHRcIlxuICAgICAgICApO1xuICAgICAgICBpZighdGV4dCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0hUTUwgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLm1hcChsaW5lID0+IHtcbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHJ1bGUgYW5kIHRyeSB0byBtYXRjaFxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX3N5bnRheFJ1bGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMuX3N5bnRheFJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHdpbmRvdy5TeXN0ZW0uZ3JhbW1hci5tYXRjaChsaW5lLCBydWxlKTtcbiAgICAgICAgICAgICAgICBpZihtYXRjaC5zdWNjZWVkZWQoKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY3MobWF0Y2gpLmhpZ2hsaWdodFN5bnRheCgpLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcblxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJpbm5lckhUTUxcIixcbiAgICAgICAgICAgIG5ld0hUTUxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZShcInN5bnRheFwiLCB0cnVlKTtcbiAgICB9XG5cbiAgICB1bmhpZ2hsaWdodFN5bnRheCgpe1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcInRleHRcIlxuICAgICAgICApO1xuICAgICAgICBpZighdGV4dCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBsYWluRWxlbWVudHMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLm1hcChsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZGl2LmlubmVyVGV4dCA9IGxpbmU7XG4gICAgICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpbmFsTGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGZpbmFsTGluZS5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgICAgcGxhaW5FbGVtZW50cy5wdXNoKGZpbmFsTGluZSk7XG5cbiAgICAgICAgbGV0IG5ld0hUTUwgPSBcIlwiO1xuICAgICAgICBwbGFpbkVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBuZXdIVE1MICs9IGVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJpbm5lckhUTUxcIixcbiAgICAgICAgICAgIG5ld0hUTUxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZShcInN5bnRheFwiLCBmYWxzZSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBGaWVsZFZpZXcsXG4gICAgRmllbGRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIE5ldyBIYWxvXG4gKi9cblxuLyoqIE5vdGU6IEljb25zIGFyZSBmcm9tIFxuKioqIGh0dHBzOi8vdGFibGVyaWNvbnMuY29tL1xuKiovXG5jb25zdCBkZWxldGVJY29uID1gXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItdHJhc2hcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8bGluZSB4MT1cIjRcIiB5MT1cIjdcIiB4Mj1cIjIwXCIgeTI9XCI3XCIgLz5cbiAgPGxpbmUgeDE9XCIxMFwiIHkxPVwiMTFcIiB4Mj1cIjEwXCIgeTI9XCIxN1wiIC8+XG4gIDxsaW5lIHgxPVwiMTRcIiB5MT1cIjExXCIgeDI9XCIxNFwiIHkyPVwiMTdcIiAvPlxuICA8cGF0aCBkPVwiTTUgN2wxIDEyYTIgMiAwIDAgMCAyIDJoOGEyIDIgMCAwIDAgMiAtMmwxIC0xMlwiIC8+XG4gIDxwYXRoIGQ9XCJNOSA3di0zYTEgMSAwIDAgMSAxIC0xaDRhMSAxIDAgMCAxIDEgMXYzXCIgLz5cbjwvc3ZnPlxuYDtcbmNvbnN0IGVkaXRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWVkaXRcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTkgN2gtM2EyIDIgMCAwIDAgLTIgMnY5YTIgMiAwIDAgMCAyIDJoOWEyIDIgMCAwIDAgMiAtMnYtM1wiIC8+XG4gIDxwYXRoIGQ9XCJNOSAxNWgzbDguNSAtOC41YTEuNSAxLjUgMCAwIDAgLTMgLTNsLTguNSA4LjV2M1wiIC8+XG4gIDxsaW5lIHgxPVwiMTZcIiB5MT1cIjVcIiB4Mj1cIjE5XCIgeTI9XCI4XCIgLz5cbjwvc3ZnPlxuYDtcbmNvbnN0IGdyb3dJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWFycm93cy1kaWFnb25hbC0yXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBvbHlsaW5lIHBvaW50cz1cIjE2IDIwIDIwIDIwIDIwIDE2XCIgLz5cbiAgPGxpbmUgeDE9XCIxNFwiIHkxPVwiMTRcIiB4Mj1cIjIwXCIgeTI9XCIyMFwiIC8+XG4gIDxwb2x5bGluZSBwb2ludHM9XCI4IDQgNCA0IDQgOFwiIC8+XG4gIDxsaW5lIHgxPVwiNFwiIHkxPVwiNFwiIHgyPVwiMTBcIiB5Mj1cIjEwXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY29weUljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY29weVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCI+PC9wYXRoPlxuICAgPHJlY3QgeD1cIjhcIiB5PVwiOFwiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHJ4PVwiMlwiPjwvcmVjdD5cbiAgIDxwYXRoIGQ9XCJNMTYgOHYtMmEyIDIgMCAwIDAgLTIgLTJoLThhMiAyIDAgMCAwIC0yIDJ2OGEyIDIgMCAwIDAgMiAyaDJcIj48L3BhdGg+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHBhc3RlSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jbGlwYm9hcmQtY2hlY2tcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxwYXRoIGQ9XCJNOSA1aC0yYTIgMiAwIDAgMCAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTBhMiAyIDAgMCAwIDIgLTJ2LTEyYTIgMiAwIDAgMCAtMiAtMmgtMlwiPjwvcGF0aD5cbiAgIDxyZWN0IHg9XCI5XCIgeT1cIjNcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCI0XCIgcng9XCIyXCI+PC9yZWN0PlxuICAgPHBhdGggZD1cIk05IDE0bDIgMmw0IC00XCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0YXJnZXRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWZvY3VzXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIi41XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPjwvY2lyY2xlPlxuICAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI5XCI+PC9jaXJjbGU+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHNldHRpbmdzSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1zZXR0aW5nc1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAuMzI1IDQuMzE3Yy40MjYgLTEuNzU2IDIuOTI0IC0xLjc1NiAzLjM1IDBhMS43MjQgMS43MjQgMCAwIDAgMi41NzMgMS4wNjZjMS41NDMgLS45NCAzLjMxIC44MjYgMi4zNyAyLjM3YTEuNzI0IDEuNzI0IDAgMCAwIDEuMDY1IDIuNTcyYzEuNzU2IC40MjYgMS43NTYgMi45MjQgMCAzLjM1YTEuNzI0IDEuNzI0IDAgMCAwIC0xLjA2NiAyLjU3M2MuOTQgMS41NDMgLS44MjYgMy4zMSAtMi4zNyAyLjM3YTEuNzI0IDEuNzI0IDAgMCAwIC0yLjU3MiAxLjA2NWMtLjQyNiAxLjc1NiAtMi45MjQgMS43NTYgLTMuMzUgMGExLjcyNCAxLjcyNCAwIDAgMCAtMi41NzMgLTEuMDY2Yy0xLjU0MyAuOTQgLTMuMzEgLS44MjYgLTIuMzcgLTIuMzdhMS43MjQgMS43MjQgMCAwIDAgLTEuMDY1IC0yLjU3MmMtMS43NTYgLS40MjYgLTEuNzU2IC0yLjkyNCAwIC0zLjM1YTEuNzI0IDEuNzI0IDAgMCAwIDEuMDY2IC0yLjU3M2MtLjk0IC0xLjU0MyAuODI2IC0zLjMxIDIuMzcgLTIuMzdjMSAuNjA4IDIuMjk2IC4wNyAyLjU3MiAtMS4wNjV6XCIgLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIzXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3Qgcm90YXRlSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1yb3RhdGUtY2xvY2t3aXNlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8cGF0aCBkPVwiTTQuMDUgMTFhOCA4IDAgMSAxIC41IDRtLS41IDV2LTVoNVwiPjwvcGF0aD5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gOmhvc3Qge1xuICAgICAtLWhhbG8tYnV0dG9uLWhlaWdodDogMjVweDtcbiAgICAgLS1oYWxvLWJ1dHRvbi13aWR0aDogMjVweDtcbiAgICAgLS1oYWxvLXJpbS1tYXJnaW46IDEwcHg7XG4gICAgIC0taGFsby1idXR0b24td2lkdGgtcGFkZGVkOiBjYWxjKHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoKSArIHZhcigtLWhhbG8tcmltLW1hcmdpbikpO1xuICAgICAtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQ6IGNhbGModmFyKC0taGFsby1idXR0b24taGVpZ2h0KSArIHZhcigtLWhhbG8tcmltLW1hcmdpbikpO1xuICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgIHRvcDogY2FsYygtMSAqIHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpKTtcbiAgICAgbGVmdDogY2FsYygtMSAqIHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoLXBhZGRlZCkpO1xuICAgICB3aWR0aDogY2FsYygxMDAlICsgKDIgKiB2YXIoLS1oYWxvLWJ1dHRvbi13aWR0aC1wYWRkZWQpKSk7XG4gICAgIGhlaWdodDogY2FsYygxMDAlICsgKDIgKiB2YXIoLS1oYWxvLWJ1dHRvbi1oZWlnaHQtcGFkZGVkKSkpO1xuICAgICBjb2xvcjogaW5pdGlhbDtcbiAgICAgei1pbmRleDogMTA7XG4gfVxuXG5cbiAuaGFsby1yb3csXG4gLmhhbG8tY29sdW1uIHtcbiAgICAgZGlzcGxheTogZmxleDtcbiAgICAgcG9zaXRpb246IGFic29sdXRlO1xuIH1cblxuIC5oYWxvLWNvbHVtbiB7XG4gICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gfVxuXG4gI2hhbG8tdG9wLXJvdyxcbiAjaGFsby1ib3R0b20tcm93IHtcbiAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLWhhbG8tYnV0dG9uLXdpZHRoLXBhZGRlZCkpO1xuICAgICBoZWlnaHQ6IHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpO1xuIH1cblxuICNoYWxvLXRvcC1yb3cge1xuICAgICBsZWZ0OiAwO1xuICAgICB0b3A6IDA7XG4gfVxuXG4gI2hhbG8tYm90dG9tLXJvdyB7XG4gICAgIHJpZ2h0OiAwO1xuICAgICBib3R0b206IDA7XG4gICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuIH1cblxuICNoYWxvLXJpZ2h0LWNvbHVtbixcbiAjaGFsby1sZWZ0LWNvbHVtbiB7XG4gICAgIGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0taGFsby1idXR0b24taGVpZ2h0LXBhZGRlZCkpO1xuICAgICB3aWR0aDogdmFyKC0taGFsby1idXR0b24td2lkdGgtcGFkZGVkKTtcbiB9XG5cbiAjaGFsby1yaWdodC1jb2x1bW4ge1xuICAgICByaWdodDogMDtcbiAgICAgdG9wOiAwO1xuICAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gfVxuXG4gI2hhbG8tbGVmdC1jb2x1bW4ge1xuICAgICBsZWZ0OiAwO1xuICAgICB0b3A6IHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodC1wYWRkZWQpO1xuIH1cblxuIC5oYWxvLWJ1dHRvbixcbiA6OnNsb3R0ZWQoKikge1xuICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjgpO1xuICAgICB3aWR0aDogdmFyKC0taGFsby1idXR0b24td2lkdGgpO1xuICAgICBoZWlnaHQ6IHZhcigtLWhhbG8tYnV0dG9uLWhlaWdodCk7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyMjAsIDIyMCwgMjIwKTtcbiB9XG5cbiAuaGFsby1idXR0b246aG92ZXJcbiA6OnNsb3R0ZWQoKikuaGFsby1idXR0b246aG92ZXIge1xuICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gfVxuXG4gLmhhbG8tYnV0dG9uOmFjdGl2ZVxuIDo6c2xvdHRlZCgqKS5oYWxvLWJ1dHRvbjphY3RpdmUge1xuICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiB9XG5cbiAuaGFsby1idXR0b24uaGlkZGVuXG4gOjpzbG90dGVkKCopLmhhbG8tYnV0dG9uLmhpZGRlbiB7XG4gICAgIGRpc3BsYXk6IG5vbmU7XG4gfVxuXG48L3N0eWxlPlxuXG48ZGl2IGlkPVwiaGFsby10b3Atcm93XCIgY2xhc3M9XCJoYWxvLXJvd1wiPlxuICAgIDxkaXYgaWQ9XCJoYWxvLWRlbGV0ZVwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIkRlbGV0ZSB0aGlzIHBhcnRcIj5cbiAgICAgICAgJHtkZWxldGVJY29ufVxuICAgIDwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJ0b3Atcm93XCI+PC9zbG90PlxuPC9kaXY+XG5cbjxkaXYgaWQ9XCJoYWxvLWJvdHRvbS1yb3dcIiBjbGFzcz1cImhhbG8tcm93XCI+XG4gICAgPGRpdiBpZD1cImhhbG8tcmVzaXplXCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiUmVzaXplIHRoaXMgcGFydFwiPlxuICAgICAgICAke2dyb3dJY29ufVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoYWxvLXNjcmlwdC1lZGl0XCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiRWRpdCB0aGlzIHBhcnQncyBzY3JpcHRcIj5cbiAgICAgICAgJHtlZGl0SWNvbn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwiaGFsby1lZGl0XCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiRWRpdCB0aGlzIHBhcnRcIj5cbiAgICAgICAgJHtzZXR0aW5nc0ljb259XG4gICAgPC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cImJvdHRvbS1yb3dcIj48L3Nsb3Q+XG48L2Rpdj5cblxuPGRpdiBpZD1cImhhbG8tbGVmdC1jb2x1bW5cIiBjbGFzcz1cImhhbG8tY29sdW1uXCI+XG4gICAgPGRpdiBpZD1cImhhbG8tY29weVwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIkNvcHkgdGhpcyBQYXJ0XCI+XG4gICAgICAgICR7Y29weUljb259XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImhhbG8tcGFzdGVcIiBjbGFzcz1cImhhbG8tYnV0dG9uXCIgdGl0bGU9XCJQYXN0ZSB0aGUgY29udGVudHMgb2YgY2xpcGJvYXJkIGludG8gdGhpcyBQYXJ0XCI+XG4gICAgICAgICR7cGFzdGVJY29ufVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJoYWxvLXRhcmdldFwiIGNsYXNzPVwiaGFsby1idXR0b25cIiB0aXRsZT1cIlNlbGVjdCB0aGlzIFBhcnQncyB0YXJnZXRcIj5cbiAgICAgICAgJHt0YXJnZXRJY29ufVxuICAgIDwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJsZWZ0LWNvbHVtblwiPjwvc2xvdD5cbjwvZGl2PlxuXG48ZGl2IGlkPVwiaGFsby1yaWdodC1jb2x1bW5cIiBjbGFzcz1cImhhbG8tY29sdW1uXCI+XG4gICAgPGRpdiBpZD1cImhhbG8tcm90YXRlXCIgY2xhc3M9XCJoYWxvLWJ1dHRvblwiIHRpdGxlPVwiUm90YXRlIHRoaXMgcGFydFwiPlxuICAgICAgICAke3JvdGF0ZUljb259XG4gICAgPC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cInJpZ2h0LWNvbHVtblwiPjwvc2xvdD5cbjwvZGl2PlxuXG5gO1xuXG5jbGFzcyBIYWxvIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHRoZSBTaGFkb3cgRE9NIGFuZCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG5cblxuICAgICAgICAvLyBCaW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemVNb3VzZURvd24gPSB0aGlzLm9uUmVzaXplTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemVNb3VzZVVwID0gdGhpcy5vblJlc2l6ZU1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZU1vdXNlTW92ZSA9IHRoaXMub25SZXNpemVNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJvdGF0ZU1vdXNlRG93biA9IHRoaXMub25Sb3RhdGVNb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJvdGF0ZU1vdXNlVXAgPSB0aGlzLm9uUm90YXRlTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUm90YXRlTW91c2VNb3ZlID0gdGhpcy5vblJvdGF0ZU1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRSb290Tm9kZSgpLmhvc3Q7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZWRpdGluZycpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50Lmhhc09wZW5IYWxvID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcblxuICAgICAgICAgICAgLy8gUmVzaXplIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5yZXNpemVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXJlc2l6ZScpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25SZXNpemVNb3VzZURvd24pO1xuICAgICAgICAgICAgaWYoIXRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9SZXNpemUpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJvdGF0ZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMucm90YXRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1yb3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMucm90YXRlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUm90YXRlTW91c2VEb3duKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvUm90YXRlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVsZXRlIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5kZWxldGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLWRlbGV0ZScpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb0RlbGV0ZSk7XG4gICAgICAgICAgICBpZighdGhpcy50YXJnZXRFbGVtZW50LndhbnRzSGFsb0RlbGV0ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWRpdCBidXR0b25cbiAgICAgICAgICAgIHRoaXMuc2NyaXB0RWRpdG9yID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXNjcmlwdC1lZGl0Jyk7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdEVkaXRvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9PcGVuU2NyaXB0RWRpdG9yKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvU2NyaXB0RWRpdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JpcHRFZGl0b3Iuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wcmVoZW5zaXZlIGVkaXRvciBidXR0b25cbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLWVkaXQnKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb09wZW5FZGl0b3IpO1xuICAgICAgICAgICAgaWYoIXRoaXMudGFyZ2V0RWxlbWVudC53YW50c0hhbG9FZGl0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLmNvcGllciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaGFsby1jb3B5Jyk7XG4gICAgICAgICAgICB0aGlzLmNvcGllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9Db3B5KTtcblxuXG4gICAgICAgICAgICAvLyBQYXN0ZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMucGFzdGVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdoYWxvLXBhc3RlJyk7XG4gICAgICAgICAgICB0aGlzLnBhc3Rlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudGFyZ2V0RWxlbWVudC5vbkhhbG9QYXN0ZSk7XG5cbiAgICAgICAgICAgIC8vIFRhcmdldCBidXR0b25cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2hhbG8tdGFyZ2V0Jyk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50YXJnZXRFbGVtZW50Lm9uSGFsb1RhcmdldCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VFbnRlcik7XG4gICAgICAgICAgICB0aGlzLnRhcmdldGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvVGFyZ2V0QnV0dG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZWRpdGluZycpO1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQuaGFzT3BlbkhhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgIHRoaXMucmVzaXplci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUmVzaXplTW91c2VEb3duKTtcbiAgICB9XG5cblxuICAgIC8qIEV2ZW50IEhhbmRsaW5nICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiB0aGlzLnRhcmdldEVsZW1lbnQud2FudHNIYWxvTW92ZSl7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIGxldCBjdXJyZW50VG9wID0gcGFyc2VJbnQodGhpcy50YXJnZXRFbGVtZW50LnN0eWxlLnRvcCk7XG4gICAgICAgIGxldCBjdXJyZW50TGVmdCA9IHBhcnNlSW50KHRoaXMudGFyZ2V0RWxlbWVudC5zdHlsZS5sZWZ0KTtcbiAgICAgICAgbGV0IG5ld1RvcCA9IGV2ZW50Lm1vdmVtZW50WSArIGN1cnJlbnRUb3A7XG4gICAgICAgIGxldCBuZXdMZWZ0ID0gZXZlbnQubW92ZW1lbnRYICsgY3VycmVudExlZnQ7XG5cbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy50YXJnZXRFbGVtZW50Lm1vZGVsO1xuICAgICAgICBtb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG1vZGVsLCBcInRvcFwiLCBuZXdUb3ApO1xuICAgICAgICBtb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKG1vZGVsLCBcImxlZnRcIiwgbmV3TGVmdCk7XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVNb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJlc2l6ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUmVzaXplTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVNb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJlc2l6ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUmVzaXplTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVNb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvUmVzaXplKFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRYLFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRZXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb25Sb3RhdGVNb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJvdGF0ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUm90YXRlTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25Sb3RhdGVNb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblJvdGF0ZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUm90YXRlTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25Sb3RhdGVNb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQub25IYWxvUm90YXRlKFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRYLFxuICAgICAgICAgICAgZXZlbnQubW92ZW1lbnRZXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBIYWxvLFxuICAgIEhhbG8gYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBQYXJ0VmlldyBmcm9tICcuL1BhcnRWaWV3LmpzJztcblxuY29uc3QgbGlua0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItbGlua1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTAgMTRhMy41IDMuNSAwIDAgMCA1IDBsNCAtNGEzLjUgMy41IDAgMCAwIC01IC01bC0uNSAuNVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTQgMTBhMy41IDMuNSAwIDAgMCAtNSAwbC00IDRhMy41IDMuNSAwIDAgMCA1IDVsLjUgLS41XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgcGljdHVyZUljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItcGhvdG9cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiPjwvcGF0aD5cbiAgIDxsaW5lIHgxPVwiMTVcIiB5MT1cIjhcIiB4Mj1cIjE1LjAxXCIgeTI9XCI4XCI+PC9saW5lPlxuICAgPHJlY3QgeD1cIjRcIiB5PVwiNFwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiM1wiPjwvcmVjdD5cbiAgIDxwYXRoIGQ9XCJNNCAxNWw0IC00YTMgNSAwIDAgMSAzIDBsNSA1XCI+PC9wYXRoPlxuICAgPHBhdGggZD1cIk0xNCAxNGwxIC0xYTMgNSAwIDAgMSAzIDBsMiAyXCI+PC9wYXRoPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxpbWcgaWQ9XCJ3cmFwcGVkLWltYWdlXCIgY2xhc3M9XCJoaWRkZW5cIiAvPlxuPHN2ZyBjbGFzcz1cImhpZGRlblwiIGlkPVwid3JhcHBlZC1zdmdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG48L3N2Zz5cbjxzdHlsZT5cbjpob3N0IHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLmhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbmltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4uY3VycmVudGx5LXdyYXBwZWQge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cbjwvc3R5bGU+XG5gO1xuXG5jbGFzcyBJbWFnZVZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMudXBkYXRlSW1hZ2VEYXRhID0gdGhpcy51cGRhdGVJbWFnZURhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdmdJbWFnZSA9IHRoaXMudXBkYXRlU3ZnSW1hZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVCaW5hcnlJbWFnZSA9IHRoaXMudXBkYXRlQmluYXJ5SW1hZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXREZWZhdWx0SW1hZ2UgPSB0aGlzLnNldERlZmF1bHRJbWFnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbWFnZUxpbmsgPSB0aGlzLnVwZGF0ZUltYWdlTGluay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZ0ZvclZpZXdwb3J0ID0gdGhpcy51cGRhdGVTaXppbmdGb3JWaWV3cG9ydC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gcHJvcCBjaGFuZ2VzXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwiaW1hZ2VEYXRhXCIsIChpbWFnZURhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKCFpbWFnZURhdGEpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEltYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlRGF0YShpbWFnZURhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBpbWFnZURhdGEuIElmIG5vdCwgdHJ5XG4gICAgICAgIC8vIHRvIGxvYWQgZnJvbSBhIHNyYy5cbiAgICAgICAgbGV0IGN1cnJlbnRJbWFnZURhdGEgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgXCJpbWFnZURhdGFcIlxuICAgICAgICApO1xuICAgICAgICBsZXQgY3VycmVudFNyYyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICBcInNyY1wiXG4gICAgICAgICk7XG4gICAgICAgIGlmKCFjdXJyZW50SW1hZ2VEYXRhKXtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdsb2FkSW1hZ2VGcm9tJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyBjdXJyZW50U3JjIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2UobXNnLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0SW1hZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2VEYXRhKGN1cnJlbnRJbWFnZURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgaWYoIXRoaXMuaGFsb0J1dHRvbil7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIHNldERlZmF1bHRJbWFnZSgpe1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJpbWFnZURhdGFcIiwgcGljdHVyZUljb24pO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJtaW1lVHlwZVwiLCBcImltYWdlL3N2Z1wiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwic3JjXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUltYWdlRGF0YShwaWN0dXJlSWNvbik7XG4gICAgfVxuXG4gICAgdXBkYXRlSW1hZ2VEYXRhKGltYWdlRGF0YSl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwuaXNTdmcpe1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdmdJbWFnZShpbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCaW5hcnlJbWFnZShpbWFnZURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlQmluYXJ5SW1hZ2UoaW1hZ2VEYXRhKXtcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgaW1hZ2VEYXRhIGlzXG4gICAgICAgIC8vIGEgYmFzZTY0IGVuY29kZWQgZGF0YSB1cmwgZGVzY3JpYmluZ1xuICAgICAgICAvLyB0aGUgYml0cyBvZiB0aGUgaW1hZ2UuXG4gICAgICAgIGxldCBpbWdFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZWQtaW1hZ2UnKTtcbiAgICAgICAgbGV0IHN2Z0VsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnd3JhcHBlZC1zdmcnKTtcbiAgICAgICAgc3ZnRWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIHN2Z0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGltZ0VsLmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGltZ0VsLnNyYyA9IGltYWdlRGF0YTtcbiAgICAgICAgaW1nRWwub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgLy90aGlzLnVwZGF0ZVNpemluZ0ZvclZpZXdwb3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJlc2VydmVBc3BlY3RPblJlc2l6ZSA9IHRydWU7XG4gICAgICAgIGltZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIH1cblxuICAgIHVwZGF0ZVN2Z0ltYWdlKGltYWdlRGF0YSl7XG4gICAgICAgIGxldCBpbWdFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZWQtaW1hZ2UnKTtcbiAgICAgICAgbGV0IGN1cnJlbnRTdmdFbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZWQtc3ZnJyk7XG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGxldCB4bWxEb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaW1hZ2VEYXRhLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgIGxldCBuZXdTdmdFbCA9IHhtbERvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgU1ZHIGhhcyBzb21lIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlc1xuICAgICAgICAvLyBzZXQgc28gd2UgaGF2ZSBpbml0aWFsIGRpbWVuc2lvbnMgdG8gZGlzcGxheS4gSWYgbm90IHByZXNlbnQsXG4gICAgICAgIC8vIHB1bGwgZnJvbSB2aWV3Ym94LlxuICAgICAgICBpZighbmV3U3ZnRWwuaGFzQXR0cmlidXRlKCd3aWR0aCcpIHx8ICFuZXdTdmdFbC5oYXNBdHRyaWJ1dGUoJ2hlaWdodCcpKXtcbiAgICAgICAgICAgIGxldCB2aWV3Qm94ID0gbmV3U3ZnRWwuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgICAgICAgICBpZih2aWV3Qm94KXtcbiAgICAgICAgICAgICAgICB2aWV3Qm94ID0gdmlld0JveC5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdCb3hXaWR0aCA9IHBhcnNlSW50KHZpZXdCb3hbMl0pO1xuICAgICAgICAgICAgICAgIGxldCB2aWV3Qm94SGVpZ2h0ID0gcGFyc2VJbnQodmlld0JveFszXSk7XG4gICAgICAgICAgICAgICAgbmV3U3ZnRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB2aWV3Qm94SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBuZXdTdmdFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdmlld0JveFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgbmV3U3ZnRWwuaWQgPSAnd3JhcHBlZC1zdmcnO1xuICAgICAgICBuZXdTdmdFbC5jbGFzc0xpc3QuYWRkKCdjdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBpbWdFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgaW1nRWwuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudGx5LXdyYXBwZWQnKTtcbiAgICAgICAgY3VycmVudFN2Z0VsLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKG5ld1N2Z0VsKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmdGb3JWaWV3cG9ydCgpO1xuICAgICAgICB0aGlzLnByZXNlcnZlQXNwZWN0T25SZXNpemUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbWFnZUxpbmsoZXZlbnQpe1xuICAgICAgICAvLyBUZWxscyB0aGUgbW9kZWwgdG8gdXBkYXRlIGl0c1xuICAgICAgICAvLyBzcmMgbGluayBmb3IgdGhlIGltYWdlXG4gICAgICAgIGxldCBjdXJyZW50U3JjID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdzcmMnXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZXN1bHQgPSB3aW5kb3cucHJvbXB0KFwiRWRpdCBVUkwgZm9yIGltYWdlOlwiLCBjdXJyZW50U3JjKTtcbiAgICAgICAgaWYocmVzdWx0ICYmIHJlc3VsdCAhPT0gJycgJiYgcmVzdWx0ICE9PSBjdXJyZW50U3JjKXtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbG9hZEltYWdlRnJvbScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsgcmVzdWx0IF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVTaXppbmdGb3JWaWV3cG9ydCgpe1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdCBkaXNwbGF5IGxhcmdlclxuICAgICAgICAvLyB0aGFuIHRoZSBjdXJyZW50IHJlbWFpbmluZyBzdWJyZWN0YW5nbGUgb2YgaXRzIG9yaWdpblxuICAgICAgICAvLyBhbmQgdGhlIGNvcm5lciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgbGV0IHBhZGRpbmcgPSA0MDtcbiAgICAgICAgLy8gRmlyc3QsIHdlIG5lZWQgdG8gZmluZCB0aGUgYWJzb2x1dGUgdG9wIGNvcm5lclxuICAgICAgICAvLyBsb2NhdGlvbnMgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgIGxldCBlbCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmN1cnJlbnRseS13cmFwcGVkJyk7XG4gICAgICAgIGxldCB0b3AgPSAwO1xuICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgIHdoaWxlKGVsKXtcbiAgICAgICAgICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgICAgICAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG4gICAgICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGhlaWdodExpbWl0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIHBhZGRpbmc7XG4gICAgICAgIGlmKChyZWN0LmhlaWdodCArIHRvcCkgPiBoZWlnaHRMaW1pdCl7XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSAoaGVpZ2h0TGltaXQgLSB0b3ApIC8gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAvLyB0aGlzLnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0ICogcmF0aW99cHhgO1xuICAgICAgICAgICAgLy8gdGhpcy5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGggKiByYXRpb31weGA7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAgIChyZWN0LndpZHRoICogcmF0aW8pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgICAgKHJlY3QuaGVpZ2h0ICogcmF0aW8pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9CdXR0b24pO1xuICAgIH1cblxuICAgIG9uSGFsb1Jlc2l6ZShtb3ZlbWVudFgsIG1vdmVtZW50WSl7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICAgIC8vIFdlIHJlc2l6ZSB0aGUgd3JhcHBlZCBzdmcgb3IgaW1nIGluc3RlYWRcbiAgICAgICAgLy8gYW5kIGhhdmUgdGhlIG91dGVyIGNvbXBvbmVudCBzaW1wbHkgcmVhY3QgdG9cbiAgICAgICAgLy8gdGhlIGNoYW5nZS5cbiAgICAgICAgLy8gSWYgdGhlIHBhcnQgaXMgcm90YXRlZCB0aGlzIHdpbGwgdGhyb3cgb2ZmIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgICAgLy8gYnJvd3NlciBjYWxjdWFsdGlvbi4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byByb3RhdGUgdGhlIHBhcnQgdG8gMFxuICAgICAgICAvLyAoaWYgbmVjZXNzYXJ5KSBkbyB0aGUgY2FsY3VsYXRpb25zIGFuZCB0aGVuIHJvdGF0ZSBpdCBiYWNrXG4gICAgICAgIGxldCBhbmdsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiKTtcbiAgICAgICAgaWYoYW5nbGUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwcGVkSW1hZ2UgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5jdXJyZW50bHktd3JhcHBlZCcpO1xuICAgICAgICBsZXQgcmVjdCA9IHdyYXBwZWRJbWFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG5ld1dpZHRoLCBuZXdIZWlnaHQ7XG4gICAgICAgIGlmKHRoaXMucHJlc2VydmVBc3BlY3RPblJlc2l6ZSl7XG4gICAgICAgICAgICBsZXQgbWF4V2lkdGggPSByZWN0LndpZHRoICsgbW92ZW1lbnRYO1xuICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgbW92ZW1lbnRZO1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gTWF0aC5taW4obWF4V2lkdGggLyByZWN0LndpZHRoLCBtYXhIZWlnaHQgLyByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSByZWN0LmhlaWdodCAqIHJhdGlvO1xuICAgICAgICAgICAgbmV3V2lkdGggPSByZWN0LndpZHRoICogcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHJlY3Qud2lkdGggKyBtb3ZlbWVudFg7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSByZWN0LmhlaWdodCArIG1vdmVtZW50WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5ld1dpZHRoICYmIG5ld0hlaWdodCl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRoZSByb3RhdGUgYW5nbGUgdG8gdGhlIG9yaWdpbmFsIChpZiBuZWNlc3NhcnkpXG4gICAgICAgIGlmKGFuZ2xlKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInJvdGF0ZVwiLCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Q3VzdG9tSGFsb0J1dHRvbigpe1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmlkID0gJ2hhbG8taW1hZ2UtbGluayc7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaW5uZXJIVE1MID0gbGlua0ljb247XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zdHlsZS5tYXJnaW5Ub3AgPSBcIjZweFwiO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCdzbG90JywgJ3JpZ2h0LWNvbHVtbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsICdFZGl0IGxpbmsgZm9yIGltYWdlIGZpbGUnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVJbWFnZUxpbmspO1xuICAgIH1cblxuICAgIGFkZENvbnRleHRNZW51SXRlbXMoY29udGV4dE1lbnUpe1xuICAgICAgICBjb250ZXh0TWVudS5hZGRTcGFjZXIoKTtcbiAgICAgICAgY29udGV4dE1lbnUuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnRWRpdCBJbWFnZSBVUkwnLFxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbWFnZUxpbmtcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEltYWdlVmlldyxcbiAgICBJbWFnZVZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogUGFydFZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYW4gKmFic3RyYWN0KiB3ZWJjb21wb2VudCBDdXN0b21FbGVtZW50XG4gKiB0aGF0IHNlcnZlcyBhcyB0aGUgZ2VuZXJpYyB2aWV3IGZvciBhbnkgUGFydFxuICogbW9kZWxzLlxuICogSSBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseSwgbm9yIHNob3VsZFxuICogSSBiZSBhZGRlZCB0byBhbnkgd2ViIHBhZ2UncyByZWdpc3RyeSBvZiBDdXN0b21FbGVtZW50cy5cbiAqIEkgYW0gaW5kZW5kZWQgdG8gYmUgZXh0ZW5kZWQgKHN1YmNsYXNzZWQpIGJ5IHRoZSBhY3R1YWxcbiAqIHZpZXdzIGZvciBlYWNoIFBhcnQga2luZCwgYW5kIHRoZXJlZm9yZSBJIGNvbnRhaW4gYWxsXG4gKiBvZiB0aGUgY29tbW9uIGJlaGF2aW9yLCBpbmNsdWRpbmcgbGlmZWN5Y2xlIG1ldGhvZHMsXG4gKiBmb3IgdGhlc2UuXG4gKi9cbmltcG9ydCBDb250ZXh0TWVudSBmcm9tICcuL2NvbnRleHRtZW51L0NvbnRleHRNZW51LmpzJztcbmltcG9ydCBpbnRlcnByZXRlclNlbWFudGljcyBmcm9tICcuLi8uLi9vaG0vaW50ZXJwcmV0ZXItc2VtYW50aWNzLmpzJztcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3QtY29udGV4dC1tZW51JywgQ29udGV4dE1lbnUpO1xuXG5jbGFzcyBQYXJ0VmlldyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1BhcnRWaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xlbnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMucHJvcENoYW5nZUhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2V0dXBCYXNlUHJvcEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMudmlld0NoYW5nZUhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2V0dXBCYXNlVmlld0NoYW5nZUhhbmRsZXJzKCk7XG5cbiAgICAgICAgLy8gSGFsbyBzZXR0aW5ncy4gQWxsIGFyZSBvbiBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMud2FudHNIYWxvUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YW50c0hhbG9Sb3RhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsb1NjcmlwdEVkaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsb0VkaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLndhbnRzSGFsb0RlbGV0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gdHJ1ZTtcbiAgICAgICAgLy8gTm90ZTogc2VlIGdldHRlciBmb3Igd2FudHNIYWxvTW92ZVxuXG4gICAgICAgIC8vIENvbnRleHQgbWVudSBzZXR0aW5nc1xuICAgICAgICB0aGlzLndhbnRzQ29udGV4dE1lbnUgPSB0cnVlO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5zZXRNb2RlbCA9IHRoaXMuc2V0TW9kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bnNldE1vZGVsID0gdGhpcy51bnNldE1vZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSB0aGlzLnNlbmRNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBCYXNlUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cEJhc2VQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cEJhc2VWaWV3Q2hhbmdlSGFuZGxlcnMgPSB0aGlzLnNldHVwQmFzZVZpZXdDaGFuZ2VIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRMYXlvdXQgPSB0aGlzLmluaXRMYXlvdXQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIGluaXRpYWwgcHJvcGVydHkgbWV0aG9kXG4gICAgICAgIHRoaXMuc3R5bGVDU1MgPSB0aGlzLnN0eWxlQ1NTLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3R5bGVUZXh0Q1NTID0gdGhpcy5zdHlsZVRleHRDU1MuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCaW5kIHByb3BlcnR5IGNoYW5nZSByZWFjdGlvbiBtZXRob2RzXG4gICAgICAgIHRoaXMucHJpbUhhbmRsZVByb3BDaGFuZ2UgPSB0aGlzLnByaW1IYW5kbGVQcm9wQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlID0gdGhpcy5vblByb3BDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcmltSGFuZGxlVmlld0NoYW5nZSA9IHRoaXMucHJpbUhhbmRsZVZpZXdDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblZpZXdDaGFuZ2UgPSB0aGlzLm9uVmlld0NoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjcmlwdENoYW5nZWQgPSB0aGlzLnNjcmlwdENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sYXlvdXRDaGFuZ2VkID0gdGhpcy5sYXlvdXRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdERpcmVjdGlvbkNoYW5nZWQgPSB0aGlzLmxpc3REaXJlY3Rpb25DaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdFdyYXBwaW5nQ2hhbmdlZCA9IHRoaXMubGlzdFdyYXBwaW5nQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnZSZXNpemluZ0NoYW5nZWQgPSB0aGlzLnZSZXNpemluZ0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oUmVzaXppbmdDaGFuZ2VkID0gdGhpcy5oUmVzaXppbmdDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlubmluZ0xlZnRDaGFuZ2VkID0gdGhpcy5waW5uaW5nTGVmdENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5uaW5nVG9wQ2hhbmdlZCA9IHRoaXMucGlubmluZ1RvcENoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5uaW5nQm90dG9tQ2hhbmdlZCA9IHRoaXMucGlubmluZ0JvdHRvbUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkID0gdGhpcy5waW5uaW5nUmlnaHRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdEFsaWdubWVudENoYW5nZWQgPSB0aGlzLmxpc3RBbGlnbm1lbnRDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubGlzdERpc3RyaWJ1dGlvbkNoYW5nZWQgPSB0aGlzLmxpc3REaXN0cmlidXRpb25DaGFuZ2VkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCB2aWV3IGNoYW5nZSByZWFjdGlvbiBtZXRob2RzXG4gICAgICAgIHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZCA9IHRoaXMuc3VicGFydE9yZGVyQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5ld1N1YnBhcnRWaWV3ID0gdGhpcy5uZXdTdWJwYXJ0Vmlldy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgSGFsbyByZWxhdGVkIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vcGVuSGFsbyA9IHRoaXMub3BlbkhhbG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUhhbG8gPSB0aGlzLmNsb3NlSGFsby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb0RlbGV0ZSA9IHRoaXMub25IYWxvRGVsZXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvT3BlbkVkaXRvciA9IHRoaXMub25IYWxvT3BlbkVkaXRvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb09wZW5TY3JpcHRFZGl0b3IgPSB0aGlzLm9uSGFsb09wZW5TY3JpcHRFZGl0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9SZXNpemUgPSB0aGlzLm9uSGFsb1Jlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1JvdGF0ZSA9IHRoaXMub25IYWxvUm90YXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvUGFzdGUgPSB0aGlzLm9uSGFsb1Bhc3RlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvQ29weSA9IHRoaXMub25IYWxvQ29weS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1RhcmdldCA9IHRoaXMub25IYWxvVGFyZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5kSGFsb1RhcmdldCA9IHRoaXMuZW5kSGFsb1RhcmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlRW50ZXIgPSB0aGlzLm9uSGFsb1RhcmdldEJ1dHRvbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUxlYXZlID0gdGhpcy5vbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrID0gdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkhhbG9PcGVuRWRpdG9yID0gdGhpcy5vbkhhbG9PcGVuRWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25BdXhDbGljayA9IHRoaXMub25BdXhDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2sgPSB0aGlzLm9uQ29udGV4dE1lbnVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0S2V5ID0gdGhpcy5oYW5kbGVUYXJnZXRLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZUNsaWNrID0gdGhpcy5oYW5kbGVUYXJnZXRNb3VzZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdmVyID0gdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU91dCA9IHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZENvbnRleHRNZW51SXRlbXMgPSB0aGlzLmFkZENvbnRleHRNZW51SXRlbXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VGFyZ2V0Vmlld3MgPSB0aGlzLmdldEN1cnJlbnRUYXJnZXRWaWV3cy5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJpbmQgZWRpdG9yIHJlbGF0ZWQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9wZW5FZGl0b3IgPSB0aGlzLm9wZW5FZGl0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvciA9IHRoaXMuY2xvc2VFZGl0b3IuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBDb250ZXh0IG1lbnVcbiAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnVBdCA9IHRoaXMub3BlbkNvbnRleHRNZW51QXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51ID0gdGhpcy5jbG9zZUNvbnRleHRNZW51LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gbWlzY1xuICAgICAgICB0aGlzLmhpZ2hsaWdodCA9IHRoaXMuaGlnaGxpZ2h0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQgPSB0aGlzLnVuaGlnaGxpZ2h0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQmluZCBsaWZlY3ljbGUgbWV0aG9kc1xuICAgICAgICB0aGlzLmFmdGVyTW9kZWxTZXQgPSB0aGlzLmFmdGVyTW9kZWxTZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZnRlck1vZGVsVW5zZXQgPSB0aGlzLmFmdGVyTW9kZWxVbnNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFmdGVyQ29ubmVjdGVkID0gdGhpcy5hZnRlckNvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFmdGVyRGlzY29ubmVjdGVkID0gdGhpcy5hZnRlckRpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgLy8gRG8gc29tZSB1bml2ZXJzYWwgUGFydFZpZXcgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgLy8gd2hlbiBhdHRhY2hlZCB0byBhIHBhcmVudCBlbGVtZW50LCBsaWtlXG4gICAgICAgICAgICAvLyByZWdpc3RlcmluZyBldmVudCBsaXN0ZW5lcnMgZXRjXG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIG1pZGRsZSBtb3VzZSBidXR0b24gY2xpY2tcbiAgICAgICAgICAgIC8vIHRvIHRvZ2dsZSB0aGUgaGFsb1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhdXhjbGljaycsIHRoaXMub25BdXhDbGljayk7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGRlZmF1bHQgZXZlbnQgaGFuZGxlcnMgbWFudWFsbHldXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVDbGljayk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGxpZmVjeWNsZSBtZXRob2Qgd2hlbiBkb25lXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBhYm92ZVxuICAgICAgICAgICAgdGhpcy5hZnRlckNvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhdXhjbGljaycsIHRoaXMub25BdXhDbGljayk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHRNZW51Q2xpY2spO1xuICAgICAgICB0aGlzLmFmdGVyRGlzY29ubmVjdGVkKCk7XG4gICAgfVxuXG4gICAgc2V0TW9kZWwoYU1vZGVsKXtcbiAgICAgICAgdGhpcy51bnNldE1vZGVsKCk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIGFNb2RlbC5hZGRQcm9wZXJ0eVN1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIGFNb2RlbC5hZGRWaWV3U3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgaWYodGhpcy5pc0xlbnNlZCl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2xlbnMtcGFydC1pZCcsIGFNb2RlbC5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnbGVucy1wYXJ0LWlkJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncGFydC1pZCcsIGFNb2RlbC5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2FkIGFsbCB0aGUgaW5pdGlhbCBzdHlsaW5nXG4gICAgICAgIHRoaXMuc3R5bGVDU1MoKTtcbiAgICAgICAgdGhpcy5zdHlsZVRleHRDU1MoKTtcbiAgICAgICAgdGhpcy5pbml0TGF5b3V0KCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJNb2RlbFNldCgpO1xuICAgIH1cblxuICAgIHVuc2V0TW9kZWwoKXtcbiAgICAgICAgaWYodGhpcy5tb2RlbCl7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZE1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucmVtb3ZlUHJvcGVydHlTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncGFydC1pZCcsIFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5hZnRlck1vZGVsVW5zZXQocmVtb3ZlZE1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldHVwQmFzZVByb3BIYW5kbGVycygpe1xuICAgICAgICAvLyBUaGlzIGlzIHdoZXJlIHdlIHNob3VsZCBzZXR1cCBhbnlcbiAgICAgICAgLy8gcHJvcCBjaGFuZ2UgaGFuZGxlcnMgdGhhdCBhcmUgdW5pdmVyc2FsXG4gICAgICAgIC8vIHRvIGFsbCBQYXJ0Vmlld3MuIFdlIHdvdWxkIGRvIHRoaXMgdmlhXG4gICAgICAgIC8vIHRoZSAjb25Qcm9wQ2hhbmdlIG1ldGhvZCwgd2hpY2ggcmVnaXN0ZXJzXG4gICAgICAgIC8vIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgLy8gRG8gbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCB0aGUgdW5pdmVyc2Fsc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnc2NyaXB0JywgdGhpcy5zY3JpcHRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ251bWJlcicsIHRoaXMubnVtYmVyQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjc3NTdHlsZScsIHRoaXMuc3R5bGVDU1MpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY3NzVGV4dFN0eWxlJywgdGhpcy5zdHlsZVRleHRDU1MpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbGF5b3V0JywgdGhpcy5sYXlvdXRDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2xpc3QtZGlyZWN0aW9uJywgdGhpcy5saXN0RGlyZWN0aW9uQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdsaXN0LXdyYXBwaW5nJywgdGhpcy5saXN0V3JhcHBpbmdDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ2xpc3QtYWxpZ25tZW50JywgdGhpcy5saXN0QWxpZ25tZW50Q2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdsaXN0LWRpc3RyaWJ1dGlvbicsIHRoaXMubGlzdERpc3RyaWJ1dGlvbkNoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnaG9yaXpvbnRhbC1yZXNpemluZycsIHRoaXMuaFJlc2l6aW5nQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCd2ZXJ0aWNhbC1yZXNpemluZycsIHRoaXMudlJlc2l6aW5nQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdwaW5uaW5nLXRvcCcsIHRoaXMucGlubmluZ1RvcENoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgncGlubmluZy1yaWdodCcsIHRoaXMucGlubmluZ1JpZ2h0Q2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdwaW5uaW5nLWxlZnQnLCB0aGlzLnBpbm5pbmdMZWZ0Q2hhbmdlZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdwaW5uaW5nLWJvdHRvbScsIHRoaXMucGlubmluZ0JvdHRvbUNoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnd2FudHMtbW92ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYodmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldHVwQmFzZVZpZXdDaGFuZ2VIYW5kbGVycygpe1xuICAgICAgICAvLyBUaGlzIGlzIHdoZXJlIHdlIHNob3VsZCBzZXR1cCBhbnlcbiAgICAgICAgLy8gdmlldyBjaGFuZ2UgaGFuZGxlcnMgdGhhdCBhcmUgdW5pdmVyc2FsXG4gICAgICAgIC8vIHRvIGFsbCBQYXJ0Vmlld3MuIFdlIHdvdWxkIGRvIHRoaXMgdmlhXG4gICAgICAgIC8vIHRoZSAjb25WaWV3Q2hhbmdlIG1ldGhvZCwgd2hpY2ggcmVnaXN0ZXJzXG4gICAgICAgIC8vIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgLy8gRG8gbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kXG4gICAgICAgIHRoaXMub25WaWV3Q2hhbmdlKCdzdWJwYXJ0LW9yZGVyJywgdGhpcy5zdWJwYXJ0T3JkZXJDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5vblZpZXdDaGFuZ2UoJ3N1YnBhcnQtbmV3JywgdGhpcy5uZXdTdWJwYXJ0Vmlldyk7XG4gICAgfVxuXG4gICAgaW5pdExheW91dCgpe1xuICAgICAgICAvLyBOb3QgYWxsIFBhcnQvUGFydFZpZXcgcGFpcnMgaGF2ZSB0aGUgbGF5b3V0XG4gICAgICAgIC8vIHByb3BlcnRpZXMuIEVuc3VyZSB0aGV5IGV4aXN0IGZpcnN0XG4gICAgICAgIGxldCBoYXNMYXlvdXQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCdsYXlvdXQnKTtcbiAgICAgICAgbGV0IGhhc0JveFJlc2l6aW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZCgndmVydGljYWwtcmVzaXppbmcnKTtcbiAgICAgICAgbGV0IGhhc1Bpbm5pbmcgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKCdwaW5uaW5nJyk7XG4gICAgICAgIGlmKGhhc0xheW91dCl7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbExheW91dCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdsYXlvdXQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxMaXN0RGlyZWN0aW9uID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2xpc3QtZGlyZWN0aW9uJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGlzdFdyYXBwaW5nID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2xpc3Qtd3JhcHBpbmcnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDaGFuZ2VkKGluaXRpYWxMYXlvdXQpO1xuICAgICAgICAgICAgdGhpcy5saXN0RGlyZWN0aW9uQ2hhbmdlZChpbml0aWFsTGlzdERpcmVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmxpc3RXcmFwcGluZ0NoYW5nZWQoaW5pdGlhbExpc3RXcmFwcGluZyk7XG4gICAgICAgICAgICB0aGlzLmxpc3RBbGlnbm1lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLmxpc3REaXN0cmlidXRpb25DaGFuZ2VkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihoYXNCb3hSZXNpemluZyl7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbFZSZXNpemluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICd2ZXJ0aWNhbC1yZXNpemluZydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbEhSZXNpemluZyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICdob3Jpem9udGFsLXJlc2l6aW5nJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMudlJlc2l6aW5nQ2hhbmdlZChpbml0aWFsVlJlc2l6aW5nKTtcbiAgICAgICAgICAgIHRoaXMuaFJlc2l6aW5nQ2hhbmdlZChpbml0aWFsSFJlc2l6aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGhhc1Bpbm5pbmcpe1xuICAgICAgICAgICAgdGhpcy5waW5uaW5nVG9wQ2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5waW5uaW5nQm90dG9tQ2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5waW5uaW5nTGVmdENoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoaXMucGlubmluZ1JpZ2h0Q2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3R5bGVDU1MoKXtcbiAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMsIFwiY3NzU3R5bGVcIik7XG4gICAgICAgIE9iamVjdC5rZXlzKGNzc1N0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNzc1N0eWxlW2tleV07XG4gICAgICAgICAgICB0aGlzLnN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3R5bGVUZXh0Q1NTKCl7XG4gICAgICAgIGxldCBjc3NTdHlsZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLCBcImNzc1RleHRTdHlsZVwiKTtcbiAgICAgICAgT2JqZWN0LmtleXMoY3NzU3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY3NzU3R5bGVba2V5XTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShhTWVzc2FnZSwgdGFyZ2V0KXtcbiAgICAgICAgaWYoIXRoaXMuaXNMZW5zZWQpe1xuICAgICAgICAgICAgLy8gTGVuc2VkIHZpZXdzIHNob3VsZCBub3Qgc2VuZCBtZXNzYWdlc1xuICAgICAgICAgICAgd2luZG93LlN5c3RlbS5zZW5kTWVzc2FnZShhTWVzc2FnZSwgdGhpcywgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlY2VpdmVNZXNzYWdlKGFNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoKGFNZXNzYWdlLnR5cGUpe1xuICAgICAgICBjYXNlICdwcm9wZXJ0eUNoYW5nZWQnOlxuICAgICAgICAgICAgdGhpcy5wcmltSGFuZGxlUHJvcENoYW5nZShcbiAgICAgICAgICAgICAgICBhTWVzc2FnZS5wcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UudmFsdWUsXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UucGFydElkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZpZXdDaGFuZ2VkJzpcbiAgICAgICAgICAgIHRoaXMucHJpbUhhbmRsZVZpZXdDaGFuZ2UoXG4gICAgICAgICAgICAgICAgYU1lc3NhZ2UuY2hhbmdlTmFtZSxcbiAgICAgICAgICAgICAgICAuLi5hTWVzc2FnZS5hcmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcmltSGFuZGxlUHJvcENoYW5nZShuYW1lLCB2YWx1ZSwgcGFydElkKXtcbiAgICAgICAgLy8gV2Ugbm90aWZ5IHRoZSBtb2RlbCB0aGF0IHRoZSBwcm9wZXJ0eSBjaGFuZ2Ugc28gdGhhdFxuICAgICAgICAvLyBvbiBwcm9wZXJ0eUNoYW5nZWQgY29tbWFuZCBoYW5kbGVycyBjb3VsZCBiZSBpbnZva2VkXG4gICAgICAgIC8vIGJ1dCB3ZSBtYWtlIHN1cmUgdGhhdCB0aGlzIHN0b3BzIGF0IHRoZSBzYWlkIG1vZGVsIGFuZFxuICAgICAgICAvLyBkb2VzIG5vdCBnbyB1cCB0aGUgZGVsZWdhdGlvbiBjaGFpblxuICAgICAgICBsZXQgY29tbWFuZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ3Byb3BlcnR5Q2hhbmdlZCcsXG4gICAgICAgICAgICBhcmdzOiBbbmFtZSwgdmFsdWVdLFxuICAgICAgICAgICAgc2hvdWxkTm90RGVsZWdhdGU6dHJ1ZSwgLy8gZG8gbm90IHNlbmQgdGhpcyB1cCB0aGUgZGVsZWdhdGlvbiBjaGFpblxuICAgICAgICAgICAgc2hvdWxkSWdub3JlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoY29tbWFuZE1lc3NhZ2UsIHRoaXMubW9kZWwpO1xuICAgICAgICAvLyBGaW5kIHRoZSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbmFtZWRcbiAgICAgICAgLy8gcHJvcGVydHkuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBkbyBub3RoaW5nXG4gICAgICAgIGxldCBoYW5kbGVyID0gdGhpcy5wcm9wQ2hhbmdlSGFuZGxlcnNbbmFtZV07XG4gICAgICAgIGlmKCFoYW5kbGVyKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKHZhbHVlLCBwYXJ0SWQpO1xuICAgIH1cblxuXG4gICAgb25Qcm9wQ2hhbmdlKG5hbWUsIGZ1bmMpe1xuICAgICAgICB0aGlzLnByb3BDaGFuZ2VIYW5kbGVyc1tuYW1lXSA9IGZ1bmM7XG4gICAgfVxuXG4gICAgcHJpbUhhbmRsZVZpZXdDaGFuZ2UobmFtZSwgLi4uYXJncyl7XG4gICAgICAgIC8vIEZpbmQgdGhlIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBuYW1lZFxuICAgICAgICAvLyBwcm9wZXJ0eS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIGRvIG5vdGhpbmdcbiAgICAgICAgbGV0IGhhbmRsZXIgPSB0aGlzLnZpZXdDaGFuZ2VIYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgaWYoIWhhbmRsZXIpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoLi4uYXJncyk7XG4gICAgfVxuXG4gICAgb25WaWV3Q2hhbmdlKG5hbWUsIGZ1bmMpe1xuICAgICAgICB0aGlzLnZpZXdDaGFuZ2VIYW5kbGVyc1tuYW1lXSA9IGZ1bmM7XG4gICAgfVxuXG4gICAgc2NyaXB0Q2hhbmdlZCh2YWx1ZSwgcGFydElkKXtcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tcGlsZScsXG4gICAgICAgICAgICBjb2RlU3RyaW5nOiB2YWx1ZSxcbiAgICAgICAgICAgIHRhcmdldElkOiBwYXJ0SWRcbiAgICAgICAgfSwgd2luZG93LlN5c3RlbSk7XG4gICAgfVxuXG4gICAgc3VicGFydE9yZGVyQ2hhbmdlZChpZCwgY3VycmVudEluZGV4LCBuZXdJbmRleCl7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcgZm9yIHRoZSB3cmFwcGVkIHZpZXdzXG4gICAgICAgIC8vIENhcmRSb3cgYW5kIFN0YWNrUm93IHdpbGwgaGFuZGxlIHRoZSB1cGRhdGVzXG4gICAgICAgIGlmKHRoaXMubmFtZSA9PSBcIldyYXBwZWRWaWV3XCIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJwYXJ0Tm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICBpZihuZXdJbmRleCA9PSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHN1YnBhcnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYWNjb3VudCBmb3Igd2hldGhlciB0aGUgaW5kZXggb2YgdGhpc1xuICAgICAgICAgICAgLy8gaXMgYmVmb3JlIG9yIGFmdGVyIHRoZSBuZXdJbmRleFxuICAgICAgICAgICAgaWYoY3VycmVudEluZGV4IDwgbmV3SW5kZXgpe1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gbmV3SW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbbmV3SW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoc3VicGFydE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV3U3VicGFydFZpZXcobmV3Vmlldyl7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Vmlldyk7XG4gICAgfVxuXG4gICAgbGF5b3V0Q2hhbmdlZCh2YWx1ZSwgcGFydElkKXtcbiAgICAgICAgaWYodmFsdWUgPT0gJ2xpc3QnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdC1sYXlvdXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnbGlzdC1sYXlvdXQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxpc3REaXJlY3Rpb25DaGFuZ2VkKHZhbHVlLCBwYXJ0SWQpe1xuICAgICAgICAvLyBSb3cgaXMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAgICAvLyBmb3IgYSBsaXN0IGxheW91dCwgc28gb25seSBvbmUgZXh0cmFcbiAgICAgICAgLy8gQ1NTIGNsYXNzIG5lZWRzIHRvIGJlIHRvZ2dsZWRcbiAgICAgICAgaWYodmFsdWUgPT0gJ3Jvdycpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdsaXN0LWNvbHVtbicpO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT0gJ2NvbHVtbicpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdsaXN0LWNvbHVtbicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdFdyYXBwaW5nQ2hhbmdlZCh2YWx1ZSwgcGFydElkKXtcbiAgICAgICAgaWYodmFsdWUgPT0gdHJ1ZSl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3dyYXAtbGlzdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCd3cmFwLWxpc3QnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhSZXNpemluZ0NoYW5nZWQodmFsdWUpe1xuICAgICAgICBpZih2YWx1ZSA9PSAnc3BhY2UtZmlsbCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoLXNwYWNlLWZpbGwnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICAgICAgICAnaC1yaWdpZCcsXG4gICAgICAgICAgICAgICAgJ2gtc2hyaW5rLXdyYXAnXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT0gJ3Nocmluay13cmFwJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2gtc2hyaW5rLXdyYXAnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICAgICAgICAnaC1yaWdpZCcsXG4gICAgICAgICAgICAgICAgJ2gtc3BhY2UtZmlsbCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAncmlnaWQnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaC1yaWdpZCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICdoLXNwYWNlLWZpbGwnLFxuICAgICAgICAgICAgICAgICdoLXNocmluay13cmFwJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZSZXNpemluZ0NoYW5nZWQodmFsdWUpe1xuICAgICAgICBpZih2YWx1ZSA9PSAnc3BhY2UtZmlsbCcpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd2LXNwYWNlLWZpbGwnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICAgICAgICAndi1yaWdpZCcsXG4gICAgICAgICAgICAgICAgJ3Ytc2hyaW5rLXdyYXAnXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT0gJ3Nocmluay13cmFwJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Ytc2hyaW5rLXdyYXAnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICAgICAgICAndi1yaWdpZCcsXG4gICAgICAgICAgICAgICAgJ3Ytc3BhY2UtZmlsbCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZih2YWx1ZSA9PSAncmlnaWQnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgndi1yaWdpZCcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgICAgICAgICd2LXNwYWNlLWZpbGwnLFxuICAgICAgICAgICAgICAgICd2LXNocmluay13cmFwJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBpbm5pbmdUb3BDaGFuZ2VkKCl7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3Bpbm5pbmctdG9wJ1xuICAgICAgICApO1xuICAgICAgICBpZih0b3Ape1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwaW4tdG9wJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Bpbi10b3AnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBpbm5pbmdMZWZ0Q2hhbmdlZCgpe1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAncGlubmluZy1sZWZ0J1xuICAgICAgICApO1xuICAgICAgICBpZihsZWZ0KXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGluLWxlZnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncGluLWxlZnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBpbm5pbmdSaWdodENoYW5nZWQoKXtcbiAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdwaW5uaW5nLXJpZ2h0J1xuICAgICAgICApO1xuICAgICAgICBpZihyaWdodCl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Bpbi1yaWdodCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdwaW4tcmlnaHQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBpbm5pbmdCb3R0b21DaGFuZ2VkKCl7XG4gICAgICAgIGxldCBib3R0b20gPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3Bpbm5pbmctYm90dG9tJ1xuICAgICAgICApO1xuICAgICAgICBpZihib3R0b20pe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwaW4tYm90dG9tJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Bpbi1ib3R0b20nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxpc3RBbGlnbm1lbnRDaGFuZ2VkKCl7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbGlzdC1hbGlnbm1lbnQnXG4gICAgICAgICk7XG4gICAgICAgIGxldCB2YWxpZCA9IFtcbiAgICAgICAgICAgICd0b3AnLFxuICAgICAgICAgICAgJ2JvdHRvbScsXG4gICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgICAgICAncmlnaHQnLFxuICAgICAgICAgICAgJ2NlbnRlcidcbiAgICAgICAgXTtcbiAgICAgICAgaWYodmFsaWQuaW5jbHVkZXModmFsdWUpKXtcbiAgICAgICAgICAgIHZhbGlkLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGBsaXN0LWFsaWduLSR7c2lkZX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKGBsaXN0LWFsaWduLSR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0RGlzdHJpYnV0aW9uQ2hhbmdlZCgpe1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2xpc3QtZGlzdHJpYnV0aW9uJ1xuICAgICAgICApO1xuICAgICAgICBsZXQgdmFsaWQgPSBbXG4gICAgICAgICAgICAnc3RhcnQnLFxuICAgICAgICAgICAgJ2VuZCcsXG4gICAgICAgICAgICAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAnc3BhY2UtYXJvdW5kJyxcbiAgICAgICAgICAgICdjZW50ZXInXG4gICAgICAgIF07XG4gICAgICAgIGlmKHZhbGlkLmluY2x1ZGVzKHZhbHVlKSl7XG4gICAgICAgICAgICB2YWxpZC5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShgbGlzdC1kaXN0cmlidXRpb24tJHtzaWRlfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoYGxpc3QtZGlzdHJpYnV0aW9uLSR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBMaWZlY3ljbGUgTWV0aG9kIERlZmF1bHRzICovXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFVuc2V0KHJlbW92ZWRNb2RlbCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzXG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAgIH1cblxuICAgIC8qIEhhbG8gUmVsYXRlZCBNZXRob2RzICovXG5cbiAgICBvcGVuSGFsbygpe1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIGhhbG8gaW5cbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCdzIHNoYWRvdyByb290IGFscmVhZHlcbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgbGV0IG5ld0hhbG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1oYWxvJyk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQobmV3SGFsbyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZUhhbG8oKXtcbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKGZvdW5kSGFsbyl7XG4gICAgICAgICAgICBmb3VuZEhhbG8ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGVBbnRzQm9yZGVyKCl7XG4gICAgICAgIGlmKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdtYXJjaGluZy1hbnRzJykpe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdtYXJjaGluZy1hbnRzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ21hcmNoaW5nLWFudHMnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSGFsb0RlbGV0ZSgpe1xuICAgICAgICAvLyBXaGF0IHRvIGRvIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZVxuICAgICAgICAvLyBkZWxldGUgYnV0dG9uIG9uIGEgaGFsbyBmb3IgdGhpcyBwYXJ0dmlldy5cbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgdG8gc2VuZCBhIG1lc3NhZ2VcbiAgICAgICAgLy8gdG8gdGhlIFN5c3RlbSB0byBkZWxldGUgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLy8gbW9kZWwgYW5kICphbGwqIHZpZXdzIHJlZmVyZW5jaW5nIHRoYXRcbiAgICAgICAgLy8gbW9kZWwuXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdkZWxldGVNb2RlbCcsXG4gICAgICAgICAgICBhcmdzOiBbdGhpcy5tb2RlbC5pZF1cbiAgICAgICAgfSwgd2luZG93LlN5c3RlbSk7XG4gICAgfVxuXG4gICAgb25IYWxvT3BlblNjcmlwdEVkaXRvcigpe1xuICAgICAgICAvLyBTZW5kIHRoZSBtZXNzYWdlIHRvIG9wZW4gYSBzY3JpcHQgZWRpdG9yXG4gICAgICAgIC8vIHdpdGggdGhpcyB2aWV3J3MgbW9kZWwgYXMgdGhlIHRhcmdldFxuICAgICAgICB0aGlzLm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICBhcmdzOiBbdGhpcy5tb2RlbC5pZF1cbiAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgfVxuXG4gICAgb25IYWxvT3BlbkVkaXRvcigpe1xuICAgICAgICB3aW5kb3cuU3lzdGVtLmVkaXRvci5yZW5kZXIodGhpcy5tb2RlbCk7XG4gICAgICAgIHdpbmRvdy5TeXN0ZW0uZWRpdG9yLm9wZW4oKTtcbiAgICB9XG5cbiAgICBvbkhhbG9SZXNpemUobW92ZW1lbnRYLCBtb3ZlbWVudFkpe1xuICAgICAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9uIHdoYXQgdG8gZG8gZHVyaW5nXG4gICAgICAgIC8vIGhhbG8gYnV0dG9uIHJlc2l6ZSBvcGVydGF0aW9ucy4gU3ViY2xhc3Nlc1xuICAgICAgICAvLyBjYW4gb3ZlcnJpZGUgZm9yIGN1c3RvbSBiZWhhdmlvci5cbiAgICAgICAgLy8gRGVmYXVsdCBpcyB0byB1cGRhdGUgdGhlIFZpZXcgY29tcG9uZW50J3NcbiAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBzdHlsZSBwcm9wZXJ0aWVzIGRpcmVjdGx5LlxuICAgICAgICAvLyBJZiB0aGUgcGFydCBpcyByb3RhdGVkIHRoaXMgd2lsbCB0aHJvdyBvZmYgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAgICAvLyBicm93c2VyIGNhbGN1YWx0aW9uLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHJvdGF0ZSB0aGUgcGFydCB0byAwXG4gICAgICAgIC8vIChpZiBuZWNlc3NhcnkpIGRvIHRoZSBjYWxjdWxhdGlvbnMgYW5kIHRoZW4gcm90YXRlIGl0IGJhY2tcbiAgICAgICAgbGV0IGFuZ2xlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIpO1xuICAgICAgICBpZihhbmdsZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIiwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgbmV3V2lkdGgsIG5ld0hlaWdodDtcbiAgICAgICAgaWYodGhpcy5wcmVzZXJ2ZUFzcGVjdE9uUmVzaXplKXtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IHJlY3Qud2lkdGggLyByZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGxldCBoeXAgPSBNYXRoLnNxcnQoKG1vdmVtZW50WCoqMikgKyAobW92ZW1lbnRZKioyKSk7XG4gICAgICAgICAgICBpZihtb3ZlbWVudFggPCAwIHx8IG1vdmVtZW50WSA8IDApe1xuICAgICAgICAgICAgICAgIGh5cCA9IGh5cCAqIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyBoeXA7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHJlY3Qud2lkdGggKyBoeXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IG1vdmVtZW50WCArIHJlY3Qud2lkdGg7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBtb3ZlbWVudFkgKyByZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJ3aWR0aFwiLCBuZXdXaWR0aCk7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImhlaWdodFwiLCBuZXdIZWlnaHQpO1xuICAgICAgICAvLyByZXNldCB0aGUgcm90YXRlIGFuZ2xlIHRvIHRoZSBvcmlnaW5hbCAoaWYgbmVjZXNzYXJ5KVxuICAgICAgICBpZihhbmdsZSl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJyb3RhdGVcIiwgYW5nbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25IYWxvUm90YXRlKG1vdmVtZW50WCwgbW92ZW1lbnRZKXtcbiAgICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvbiB3aGF0IHRvIGRvIGR1cmluZ1xuICAgICAgICAvLyBoYWxvIGJ1dHRvbiByb3RhdGUgb3BlcnRhdGlvbnMuIFN1YmNsYXNzZXNcbiAgICAgICAgLy8gY2FuIG92ZXJyaWRlIGZvciBjdXN0b20gYmVoYXZpb3IuXG4gICAgICAgIC8vIERlZmF1bHQgaXMgdG8gdXBkYXRlIHRoZSBWaWV3IGNvbXBvbmVudCdzXG4gICAgICAgIC8vIHJvdGF0ZSBzdHlsZSBwcm9wZXJ0eSBkaXJlY3RseS5cbiAgICAgICAgaWYobW92ZW1lbnRYIHx8IG1vdmVtZW50WSl7XG4gICAgICAgICAgICBsZXQgY3VycmVudEFuZ2xlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYoIWN1cnJlbnRBbmdsZSl7XG4gICAgICAgICAgICAgICAgY3VycmVudEFuZ2xlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aGV0YTEgPSBNYXRoLmF0YW4oKHJlY3QuaGVpZ2h0LzIpLyhyZWN0LndpZHRoLzIpKTtcbiAgICAgICAgICAgIGxldCB0aGV0YTIgPSBNYXRoLmF0YW4oKHJlY3QuaGVpZ2h0LzIgKyBtb3ZlbWVudFkpLyhyZWN0LndpZHRoLzIgKyBtb3ZlbWVudFgpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VBbmdsZSA9IE1hdGguYWJzKCh0aGV0YTIgLSB0aGV0YTEpKjE4MC9NYXRoLlBJKTtcbiAgICAgICAgICAgIGxldCBuZXdBbmdsZSA9IChjdXJyZW50QW5nbGUgKyBjaGFuZ2VBbmdsZSkgJSAzNjA7XG4gICAgICAgICAgICBpZihuZXdBbmdsZSA8IDApe1xuICAgICAgICAgICAgICAgIG5ld0FuZ2xlID0gMzYwICsgbmV3QW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihuZXdBbmdsZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicm90YXRlXCIsIG5ld0FuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSGFsb0NvcHkoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29weVBhcnQodGhpcy5tb2RlbCk7XG4gICAgfVxuXG4gICAgb25IYWxvUGFzdGUoKXtcbiAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQucGFzdGVDb250ZW50c0ludG8odGhpcy5tb2RlbCk7XG4gICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgfVxuXG4gICAgb25IYWxvVGFyZ2V0KGV2ZW50KXtcbiAgICAgICAgLy8gQWRkIHRhcmdldGluZyByZWNlaXZlIGxpc3RlbmVycyB0byBhbGwgUGFydFZpZXdzXG4gICAgICAgIC8vIG9uIHRoZSBjdXJyZW50IGNhcmQuXG4gICAgICAgIGxldCBjdXJyZW50U3RhY2tWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3dpbmRvdy5TeXN0ZW0ud29ybGQuY3VycmVudFN0YWNrLmlkfVwiXWApO1xuICAgICAgICBsZXQgY3VycmVudENhcmRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3dpbmRvdy5TeXN0ZW0ud29ybGQuY3VycmVudFN0YWNrLmN1cnJlbnRDYXJkLmlkfVwiXWApO1xuICAgICAgICBsZXQgdGFyZ2V0Q2FyZFBhcnRzID0gQXJyYXkuZnJvbShjdXJyZW50Q2FyZFZpZXcucXVlcnlTZWxlY3RvckFsbCgnW3BhcnQtaWRdJykpO1xuICAgICAgICBsZXQgdGFyZ2V0U3RhY2tQYXJ0cyA9IEFycmF5LmZyb20oY3VycmVudFN0YWNrVmlldy5xdWVyeVNlbGVjdG9yQWxsKCdbcGFydC1pZF06bm90KHN0LWNhcmQpOm5vdChzdC1zdGFjayknKSk7XG4gICAgICAgIGxldCBhbGxUYXJnZXRzID0gdGFyZ2V0Q2FyZFBhcnRzLmNvbmNhdCh0YXJnZXRTdGFja1BhcnRzKTtcbiAgICAgICAgYWxsVGFyZ2V0cy5mb3JFYWNoKHBhcnRWaWV3ID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZVRhcmdldEtleSk7XG4gICAgICAgICAgICBwYXJ0Vmlldy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3Zlcik7XG4gICAgICAgICAgICBwYXJ0Vmlldy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuaGFuZGxlVGFyZ2V0TW91c2VPdXQpO1xuICAgICAgICAgICAgcGFydFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlQ2xpY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCd0YXJnZXRpbmctbW9kZScpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBvbkhhbG9UYXJnZXRCdXR0b25Nb3VzZUVudGVyKCl7XG4gICAgICAgIC8vIGxpZ2h0IHVwIHRoZSBjdXJyZW50IHRhcmdldFxuICAgICAgICB0aGlzLmdldEN1cnJlbnRUYXJnZXRWaWV3cygpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0KFwicmdiKDU0LCAxNzIsIDEwMClcIik7IC8vZ3JlZW5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25IYWxvVGFyZ2V0QnV0dG9uTW91c2VMZWF2ZSgpe1xuICAgICAgICAvLyBsaWdodCB1cCB0aGUgY3VycmVudCB0YXJnZXRcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VGFyZ2V0Vmlld3MoKS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LnVuaGlnaGxpZ2h0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhpZ2hsaWdodChjb2xvcil7XG4gICAgICAgIGlmKHRoaXMubmFtZSAhPSBcIlN0YWNrVmlld1wiICYmIHRoaXMubmFtZSAhPSBcIldvcmxkVmlld1wiKXtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC1jb2xvclwiLCBjb2xvcik7XG4gICAgICAgICAgICB0aGlzLl90ZW1wQmFja2dyb3VuZFRyYW5zcGFyZW5jeSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtdHJhbnNwYXJlbmN5XCIpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiYmFja2dyb3VuZC10cmFuc3BhcmVuY3lcIiwgMSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHVuaGlnaGxpZ2h0KCl7XG4gICAgICAgIGlmKHRoaXMubmFtZSAhPSBcIlN0YWNrVmlld1wiICYmIHRoaXMubmFtZSAhPSBcIldvcmxkVmlld1wiKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcImJhY2tncm91bmQtY29sb3JcIiwgdGhpcy5fdGVtcEJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJiYWNrZ3JvdW5kLXRyYW5zcGFyZW5jeVwiLCB0aGlzLl90ZW1wQmFja2dyb3VuZFRyYW5zcGFyZW5jeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmRIYWxvVGFyZ2V0KCl7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgdGFyZ2V0aW5nIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRoYXQgd2VyZSBhZGRlZCBkdXJpbmcgdGhlIG9uSGFsb1RhcmdldFxuICAgICAgICAvLyBoYW5kbGVyXG4gICAgICAgIGxldCBjdXJyZW50U3RhY2tWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3dpbmRvdy5TeXN0ZW0ud29ybGQuY3VycmVudFN0YWNrLmlkfVwiXWApO1xuICAgICAgICBsZXQgY3VycmVudENhcmRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3dpbmRvdy5TeXN0ZW0ud29ybGQuY3VycmVudFN0YWNrLmN1cnJlbnRDYXJkLmlkfVwiXWApO1xuICAgICAgICBsZXQgdGFyZ2V0Q2FyZFBhcnRzID0gQXJyYXkuZnJvbShjdXJyZW50Q2FyZFZpZXcucXVlcnlTZWxlY3RvckFsbCgnW3BhcnQtaWRdJykpO1xuICAgICAgICBsZXQgdGFyZ2V0U3RhY2tQYXJ0cyA9IEFycmF5LmZyb20oY3VycmVudFN0YWNrVmlldy5xdWVyeVNlbGVjdG9yQWxsKCdbcGFydC1pZF06bm90KHN0LWNhcmQpOm5vdChzdC1zdGFjayknKSk7XG4gICAgICAgIGxldCBhbGxUYXJnZXRzID0gdGFyZ2V0Q2FyZFBhcnRzLmNvbmNhdCh0YXJnZXRTdGFja1BhcnRzKTtcbiAgICAgICAgYWxsVGFyZ2V0cy5mb3JFYWNoKHBhcnRWaWV3ID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZVRhcmdldEtleSk7XG4gICAgICAgICAgICBwYXJ0Vmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVUYXJnZXRLZXkpO1xuICAgICAgICAgICAgcGFydFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZU92ZXIpO1xuICAgICAgICAgICAgcGFydFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLmhhbmRsZVRhcmdldE1vdXNlT3V0KTtcbiAgICAgICAgICAgIHBhcnRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVUYXJnZXRNb3VzZUNsaWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgndGFyZ2V0aW5nLW1vZGUnKTtcbiAgICB9XG5cbiAgICBoYW5kbGVUYXJnZXRLZXkoZXZlbnQpe1xuICAgICAgICBpZihldmVudC5rZXkgPT0gJ0VzY2FwZScpe1xuICAgICAgICAgICAgdGhpcy5lbmRIYWxvVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUYXJnZXRNb3VzZU92ZXIoZXZlbnQpe1xuICAgICAgICBpZighZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGFyZ2V0aW5nJykpe1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ3RhcmdldGluZycpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmhpZ2hsaWdodChcInJnYigyMzQsIDU1LCA1NSlcIik7XG4gICAgICAgICAgICBldmVudC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudC50YXJnZXQub25DbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUYXJnZXRNb3VzZUxlYXZlKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGFyZ2V0aW5nJykpe1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3RhcmdldGluZycpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnVuaGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudC50YXJnZXQub25DbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUYXJnZXRNb3VzZUNsaWNrKGV2ZW50KXtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDAgJiYgZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCd0YXJnZXRpbmcnKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICd0YXJnZXQnLFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0Lm1vZGVsLmlkXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW5kSGFsb1RhcmdldCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnVuaGlnaGxpZ2h0KCk7XG4gICAgICAgIGV2ZW50LnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50LnRhcmdldC5vbkNsaWNrKTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50VGFyZ2V0Vmlld3MoKXtcbiAgICAgICAgLy8gY2xlYW4gdXAgdGhlIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwidGFyZ2V0XCIpO1xuICAgICAgICBpZihjdXJyZW50VGFyZ2V0KXtcbiAgICAgICAgICAgIGxldCBzZW1hbnRpY3MgPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgICAgICBzZW1hbnRpY3MuYWRkT3BlcmF0aW9uKFxuICAgICAgICAgICAgICAgICdpbnRlcnByZXQnLFxuICAgICAgICAgICAgICAgIGludGVycHJldGVyU2VtYW50aWNzKHRoaXMubW9kZWwsIHdpbmRvdy5TeXN0ZW0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IG0gPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIubWF0Y2goY3VycmVudFRhcmdldCwgXCJPYmplY3RTcGVjaWZpZXJcIik7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzZW1hbnRpY3MobSkuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LlN5c3RlbS5maW5kVmlld3NCeUlkKHRhcmdldElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgb25Db250ZXh0TWVudUNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy53YW50c0NvbnRleHRNZW51KXtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGV4dE1lbnVJc09wZW4pe1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Db250ZXh0TWVudUF0KFxuICAgICAgICAgICAgICAgICAgICBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5jbGllbnRZXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25BdXhDbGljayhldmVudCl7XG4gICAgICAgIC8vIFNob3VsZCBvbmx5IG9wZW4gaGFsbyB3aGVuIG1pZGRsZVxuICAgICAgICAvLyBtb3VzZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMSl7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5vbkhhbG9BY3RpdmF0aW9uQ2xpY2soZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKHRoaXMuY29udGV4dE1lbnVJc09wZW4pe1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZXZlbnQuYnV0dG9uID09IDAgJiYgZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMub25IYWxvQWN0aXZhdGlvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSGFsb0FjdGl2YXRpb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKHRoaXMud2FudHNIYWxvKXtcbiAgICAgICAgICAgIGlmKHRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VIYWxvKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgYW55IG90aGVyIG9wZW4gSGFsb3NcbiAgICAgICAgICAgICAgICAvLyBhbmQgYXV0b21hdGljYWxseSBjbG9zZSB0aGVtXG4gICAgICAgICAgICAgICAgbGV0IGV4U2VsZWN0b3IgPSBgLmVkaXRpbmc6bm90KFtwYXJ0LWlkPVwiJHt0aGlzLm1vZGVsLmlkfVwiXSlgO1xuICAgICAgICAgICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChleFNlbGVjdG9yKSkuZm9yRWFjaChvcGVuSGFsb0VsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbkhhbG9FbC5jbG9zZUhhbG8oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIG9wZW4gb24gdGhpcyB2aWV3XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuSGFsbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VzZURvd24oZXZlbnQpe1xuICAgICAgICBpZihldmVudC5idXR0b24gPT0gMCAmJiAhZXZlbnQuc2hpZnRLZXkpe1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbW92ZScsXG4gICAgICAgICAgICBhcmdzOiBbZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFldXG4gICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIG9uTW91c2VVcChldmVudCl7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgIH1cblxuICAgIG9wZW5Db250ZXh0TWVudUF0KHgsIHkpe1xuICAgICAgICBsZXQgbWVudUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtY29udGV4dC1tZW51Jyk7XG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbcGFydC1pZD1cIndvcmxkXCJdJyk7XG4gICAgICAgIG1lbnVFbC5yZW5kZXIodGhpcy5tb2RlbCk7XG4gICAgICAgIG1lbnVFbC5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gICAgICAgIG1lbnVFbC5zdHlsZS50b3AgPSBgJHt5fXB4YDtcbiAgICAgICAgd29ybGRWaWV3LmFwcGVuZChtZW51RWwpO1xuICAgIH1cblxuICAgIGNsb3NlQ29udGV4dE1lbnUoKXtcbiAgICAgICAgbGV0IGZvdW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtY29udGV4dC1tZW51Jyk7XG4gICAgICAgIGlmKGZvdW5kKXtcbiAgICAgICAgICAgIGZvdW5kLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ29udGV4dE1lbnVJdGVtcyhjb250ZXh0TWVudSl7XG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIHRvXG4gICAgICAgIC8vIGRvIG5vdGhpbnMuXG4gICAgICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIGFuZCB1c2UgdGhlXG4gICAgICAgIC8vIHBhc3NlZC1pbiBjb250ZXh0TWVudSBvYmplY3QgdG8gY29uc3RydWN0XG4gICAgICAgIC8vIGxpc3QgaXRlbXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhlaXIgbmVlZHNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldCB3YW50c0hhbG9Nb3ZlKCl7XG4gICAgICAgIGlmKCF0aGlzLnBhcmVudEVsZW1lbnQgfHwgIXRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50RWxlbWVudC5tb2RlbDtcbiAgICAgICAgaWYoIXBhcmVudE1vZGVsKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhc0xheW91dCA9IHBhcmVudE1vZGVsLnBhcnRQcm9wZXJ0aWVzLmZpbmRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgcGFyZW50TW9kZWwsXG4gICAgICAgICAgICAnbGF5b3V0J1xuICAgICAgICApO1xuXG4gICAgICAgIGlmKCFoYXNMYXlvdXQpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyZW50TGF5b3V0ID0gcGFyZW50TW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHBhcmVudE1vZGVsLFxuICAgICAgICAgICAgJ2xheW91dCdcbiAgICAgICAgKTtcbiAgICAgICAgaWYocGFyZW50TGF5b3V0ID09PSAnc3RyaWN0JyB8ICFwYXJlbnRMYXlvdXQgfHwgcGFyZW50TGF5b3V0ID09IFwiXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRleHRNZW51SXNPcGVuKCl7XG4gICAgICAgIGxldCBmb3VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LWNvbnRleHQtbWVudScpO1xuICAgICAgICBpZihmb3VuZCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyogRWRpdG9yIHJlbGF0ZWQgbWV0aG9kcyAqL1xuICAgIG9wZW5FZGl0b3IoKXtcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAgIH1cblxuICAgIGNsb3NlRWRpdG9yKCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBieSBkZWZhdWx0LlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIFBhcnRWaWV3LFxuICAgIFBhcnRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IGxpbmtJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWxpbmtcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTEwIDE0YTMuNSAzLjUgMCAwIDAgNSAwbDQgLTRhMy41IDMuNSAwIDAgMCAtNSAtNWwtLjUgLjVcIiAvPlxuICA8cGF0aCBkPVwiTTE0IDEwYTMuNSAzLjUgMCAwIDAgLTUgMGwtNCA0YTMuNSAzLjUgMCAwIDAgNSA1bC41IC0uNVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuOmhvc3Qge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHBhZGRpbmc6IDFweDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLndyYXBwZXJ7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbn1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwid3JhcHBlclwiPlxuICAgIDxzcGFuIGNsYXNzPVwibmFtZVwiPjwvc3Bhbj5cbiAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItYnVpbGRpbmctYnJpZGdlLTJcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICAgPHBhdGggZD1cIk02IDdoMTJhMiAyIDAgMCAxIDIgMnY5YTEgMSAwIDAgMSAtMSAxaC0yYTEgMSAwIDAgMSAtMSAtMXYtMmE0IDQgMCAwIDAgLTggMHYyYTEgMSAwIDAgMSAtMSAxaC0yYTEgMSAwIDAgMSAtMSAtMXYtOWEyIDIgMCAwIDEgMiAtMlwiPjwvcGF0aD5cbiAgICA8L3N2Zz5cbjwvZGl2PlxuYDtcblxuY2xhc3MgUmVzb3VyY2VWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyBkb21cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0Q3VzdG9tSGFsb0J1dHRvbiA9IHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVSZXNvdXJjZUxpbmsgPSB0aGlzLnVwZGF0ZVJlc291cmNlTGluay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluZGljYXRlUmVhZHlTdGF0ZSA9IHRoaXMuaW5kaWNhdGVSZWFkeVN0YXRlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgaWYoIXRoaXMuaGFsb0J1dHRvbil7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgLy8gaWYgdGhlIHJlc291cmNlTmFtZSBwcm9wZXJ0eSBpcyBzZXQgdGhlbiBtYWtlIHN1cmUgaXQgaXMgbG9hZGVkXG4gICAgICAgIC8vIFRPRE86IGkgZG9uJ3QgbGlrZSB0aGlzIHZpZXcgYXNraW5nIHRoZSBtb2RlbCB0byBsb2FkIVxuICAgICAgICBsZXQgcmVzb3VyY2VOYW1lID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwicmVzb3VyY2VOYW1lXCIpO1xuICAgICAgICBpZihyZXNvdXJjZU5hbWUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5sb2FkUmVzb3VyY2UoW3RoaXNdLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJzcmNcIik7XG4gICAgICAgIGlmKHNyYyl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldFNvdXJjZVRvKFt0aGlzXSwgc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZVNwYW4gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKTtcbiAgICAgICAgbmFtZVNwYW4uaW5uZXJUZXh0ID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwibmFtZVwiKTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIFwicmVhZHlTdGF0ZVwiLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmluZGljYXRlUmVhZHlTdGF0ZShzdGF0ZSk7XG4gICAgICAgIC8vIHByb3AgY2hhbmdlc1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZShcIm5hbWVcIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuYW1lU3Bhbi5pbm5lclRleHQgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwicmVhZHlTdGF0ZVwiLCB0aGlzLmluZGljYXRlUmVhZHlTdGF0ZSk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKFwic3JjXCIsICh1cmwpID0+IHtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmJ1dHRvbiA9PSAwKXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgdGhlIG9uIGNsaWNrIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkhhbG8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIXRoaXMuaGFzT3BlbkhhbG8pe1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNsaWNrIGNvbW1hbmQgbWVzc2FnZSB0byBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWUgLy8gU2hvdWxkIGlnbm9yZSBpZiBTeXN0ZW0gRE5VXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRpY2F0ZVJlYWR5U3RhdGUodmFsdWUpe1xuICAgICAgICBsZXQgYm9yZGVyQ29sb3IgPSBcInJlZFwiO1xuICAgICAgICBpZih2YWx1ZSA9PSBcImZldGNoaW5nXCIpe1xuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBcInllbGxvd1wiO1xuICAgICAgICB9IGVsc2UgaWYodmFsdWUgPT0gXCJyZWFkeVwiKXtcbiAgICAgICAgICAgIGJvcmRlckNvbG9yID0gXCJncmVlblwiO1xuICAgICAgICB9O1xuICAgICAgICBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl0uZm9yRWFjaCgoc2lkZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIGBib3JkZXItJHtzaWRlfS1jb2xvcmAsIGJvcmRlckNvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9CdXR0b24pO1xuICAgIH1cblxuICAgIGluaXRDdXN0b21IYWxvQnV0dG9uKCl7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaWQgPSAnaGFsby1yZXNvdXJjZS1saW5rJztcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hhbG8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pbm5lckhUTUwgPSBsaW5rSWNvbjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnN0eWxlLm1hcmdpblRvcCA9IFwiNnB4XCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAncmlnaHQtY29sdW1uJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0VkaXQgbGluayBmb3IgcmVzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy51cGRhdGVSZXNvdXJjZUxpbmspO1xuICAgIH1cblxuICAgIHVwZGF0ZVJlc291cmNlTGluayhldmVudCl7XG4gICAgICAgIC8vIFRlbGxzIHRoZSBtb2RlbCB0byB1cGRhdGUgaXRzXG4gICAgICAgIC8vIHNyYyBsaW5rIGZvciB0aGUgcmVzb3VyY2VcbiAgICAgICAgbGV0IGN1cnJlbnRTcmMgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3NyYydcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoXCJFZGl0IFVSTCBmb3IgcmVzb3VyY2U6XCIsIGN1cnJlbnRTcmMpO1xuICAgICAgICBpZihyZXN1bHQgJiYgcmVzdWx0ICE9PSAnJyAmJiByZXN1bHQgIT09IGN1cnJlbnRTcmMpe1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdsb2FkUmVzb3VyY2UnLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbIHJlc3VsdCBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG5cbmV4cG9ydCB7XG4gICAgUmVzb3VyY2VWaWV3LFxuICAgIFJlc291cmNlVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBTdGFja1ZpZXdcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBXZWJjb21wb25lbnQgKGN1c3RvbSBlbGVtZW50KSByZXByZXNlbnRpbmdcbiAqIHRoZSB2aWV3IG9mIGEgU3RhY2suXG4gKiBJIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAqIHdoZW4gSSBhbSBiZWluZyBkaXNwbGF5ZWQuXG4gKiBNeSBjaGlsZCBlbGVtZW50cyBhcmUgQmFja2dyb3VuZFZpZXcgYW5kIENhcmRWaWV3XG4gKi9cblxuaW1wb3J0IFBhcnRWaWV3IGZyb20gJy4vUGFydFZpZXcuanMnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4uL3BhcnRzL1N0YWNrLmpzJztcblxuLy8gYnkgZGVmYXVsdCwgc3RhY2tzIGFyZSBoaWRkZW4gdW5sZXNzIHRoZXkncmVcbi8vIHRoZSBjdXJyZW50IHN0YWNrLCBvciBlbHNlIHRoZXkgaGF2ZSB0aGUgY2xhc3Ncbi8vIHdpbmRvdy1zdGFjayAoc3VnZ2VzdGluZyB0aGVyZSdzIHdpbmRvdyBwYXJ0XG4vLyB3aG8gd2lzaGVzIHRvIGRpc3BsYXkgaXQpXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGA8c2xvdD48L3Nsb3Q+YDtcblxuY2xhc3MgU3RhY2tWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGluZyBhbmQgc2hhZG93IGRvbVxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBIYWxvIHNldHRpbmdzLiBDYXJkcyBkb24ndCB3YW50XG4gICAgICAgIC8vYSBoYWxvIHRvIG9wZW5cbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBIYW5kbGUgY3VycmVudC1uZXNzIHByb3AgY2hhbmdlXG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKTtcblxuICAgICAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlID0gdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICAvLyBEbyBhbiBpbml0aWFsIHNldHRpbmcgb2YgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgY2FyZFxuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDdXJyZW50Q2hhbmdlKCl7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBwcm9wIGlzIHRoZSBjYXJkIElEXG4gICAgICAgIC8vIG9mIHRoZSBjaGlsZCBDYXJkIHRoYXQgc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBjdXJyZW50IG9uZS4gV2UgcmVtb3ZlIHRoZSBjdXJyZW50LWNhcmQgY2xhc3MgZnJvbVxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgY3VycmVudCBjYXJkIGFuZCBhZGQgaXQgdG8gdGhlIG5ldyBvbmUuXG4gICAgICAgIGxldCBjdXJyZW50Q2FyZCA9IHRoaXMucXVlcnlTZWxlY3RvcignLmN1cnJlbnQtY2FyZCcpO1xuICAgICAgICBsZXQgbmV4dEN1cnJlbnRJZCA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnY3VycmVudCdcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHNob3VsZE5vdGlmeSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VsZWN0b3IgPSBgOnNjb3BlID4gc3QtY2FyZFtwYXJ0LWlkPVwiJHtuZXh0Q3VycmVudElkfVwiXWA7XG4gICAgICAgIGlmKHRoaXMuaXNMZW5zZWQpe1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBgOnNjb3BlID4gc3QtY2FyZFtsZW5zLXBhcnQtaWQ9XCIke25leHRDdXJyZW50SWR9XCJdYDtcbiAgICAgICAgICAgIHNob3VsZE5vdGlmeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRDdXJyZW50Q2FyZCA9IHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGN1cnJlbnRDYXJkIGFuZCBubyBuZXh0IGN1cnJlbnRDYXJkIHdlIHNldCBpdCB0byBiZSB0aGUgZmlyc3RcbiAgICAgICAgLy8gY2FyZCBjaGlsZCAodGhpcyBjYW4gaGFwcGVuIHdoZW4gbmV3IGlkcyBhcmUgY3JlYXRlZCBvbiBkZXNlcmlhbGl6YXRpb24gYW5kIHNvXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHByb3BlcnR5IHN0b3JlZCBpZCBpcyBubyBsb25nZXIgcmVsZXZhbnQpXG4gICAgICAgIGlmKCFuZXh0Q3VycmVudENhcmQgJiYgIWN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIG5leHRDdXJyZW50Q2FyZCA9IHRoaXMucXVlcnlTZWxlY3RvcihgOnNjb3BlID4gc3QtY2FyZGApO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGNhcmRzIGF0IGFsbCwgdGhpcyBtdXN0IGJlIGEgYnJhbmQgbmV3IHN0YWNrXG4gICAgICAgICAgICBpZighbmV4dEN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICAgICAgICBuZXh0Q3VycmVudENhcmQuaWQsXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90aWZ5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmKG5leHRDdXJyZW50Q2FyZCl7XG4gICAgICAgICAgICBuZXh0Q3VycmVudENhcmQuY2xhc3NMaXN0LmFkZCgnY3VycmVudC1jYXJkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoY3VycmVudENhcmQgJiYgY3VycmVudENhcmQgIT0gbmV4dEN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIGN1cnJlbnRDYXJkLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQtY2FyZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgc3ViY2xhc3MgbWV0aG9kc1xuICAgIG5ld1N1YnBhcnRWaWV3KG5ld1ZpZXcpe1xuICAgICAgICBpZih0aGlzLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5ld1ZpZXcubmFtZSA9PSBcIkNhcmRWaWV3XCIpe1xuICAgICAgICAgICAgbGV0IGxhc3RDYXJkTm9kZTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGNoaWxkLm5hbWUgPT0gXCJDYXJkVmlld1wiKXtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENhcmROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZihsYXN0Q2FyZE5vZGUpe1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBhZnRlciB0aGUgbGFzdCBjYXJkXG4gICAgICAgICAgICAgICAgbGFzdENhcmROb2RlLmFmdGVyKG5ld1ZpZXcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGVyZSBhcmUgbm8gY2FyZHNcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmVmb3JlIGFsbCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS5pbnNlcnRCZWZvcmUobmV3Vmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld1ZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5leHBvcnQge1xuICAgIFN0YWNrVmlldyxcbiAgICBTdGFja1ZpZXcgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogV2luZG93Vmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSB0aGUgdmlldyBvZiBhIFdpbmRvdyBQYXJ0LlxuICogV2luZG93cyBhcmUgd3JhcHBlcnMgZm9yIFN0YWNrcy9TdGFja1ZpZXdzIHRoYXRcbiAqIGFwcGVhciBhcyB0aGUgc3VicGFydHMgb2Ygb3RoZXIgU3RhY2tzIG9yIENhcmRzLlxuICogVGhleSBhcmUgZXhhbXBsZXMgb2YgaG93IHdlIGNhbiB1c2Ugc3RhY2sgYW5kIGNhcmRcbiAqIGNvbXBvc2l0aW9uIHRvIGNyZWF0ZSBtb3JlIGNvbXBsZXggVUlzLlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbiAqIHtcbiAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiB9XG5cbiAuc3Qtd2luZG93LWJhciB7XG4gICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgIHdpZHRoOiAxMDAlO1xuICAgICBtaW4taGVpZ2h0OiAyNXB4O1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjE4LCAyMTgsIDIxOCk7XG4gICAgIHBhZGRpbmctbGVmdDogOHB4O1xuICAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XG4gICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gfVxuIC5zdC13aW5kb3ctYnV0dG9uIHtcbiAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgIHdpZHRoOiAxMnB4O1xuICAgICBoZWlnaHQ6IDEycHg7XG4gICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAxNTAsIDE1MCk7XG4gICAgIG1hcmdpbi1yaWdodDogNHB4O1xuIH1cbiAuY2xvc2UtYnV0dG9uIHtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDUwLCA1MCwgMC40KTtcbiB9XG4gLnNoYWRlLWJ1dHRvbiB7XG4gICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDAuIDAuNCk7XG4gfVxuIC5leHBhbmQtYnV0dG9uIHtcbiAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNTAsIDI1NSwgMCwgMC44KTtcbiB9XG4gLnN0LXdpbmRvdy1wYW5lIHtcbiAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgbWluLWhlaWdodDogNTBweDtcbiAgICAgZmxleDogMTtcbiB9XG4gLnN0LXdpbmRvdy1wYW5lLnNoYWRlZCB7XG4gICAgIGRpc3BsYXk6IG5vbmU7XG4gfVxuIC5zdC13aW5kb3ctZ3JpcHBlciB7XG4gICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgIHRvcDogY2FsYygxMDAlIC0gMTVweCk7XG4gICAgIHdpZHRoOiAzMHB4O1xuICAgICBoZWlnaHQ6IDMwcHg7XG4gfVxuIC5zdC13aW5kb3ctdGl0bGUge1xuICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgIG1heC13aWR0aDogNzAlO1xuIH1cbiAucmlnaHQtZ3JpcHBlciB7XG4gICAgIGxlZnQ6IGNhbGMoMTAwJSAtIDE1cHgpO1xuIH1cbiAucmlnaHQtZ3JpcHBlcjpob3ZlciB7XG4gICAgIGN1cnNvcjogbndzZS1yZXNpemU7XG4gfVxuIC5sZWZ0LWdyaXBwZXIge1xuICAgICByaWdodDogY2FsYygxMDAlIC0gMTVweCk7XG4gfVxuIC5sZWZ0LWdyaXBwZXI6aG92ZXIge1xuICAgICBjdXJzb3I6IG5lc3ctcmVzaXplO1xuIH1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwic3Qtd2luZG93LWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYnV0dG9uIGNsb3NlLWJ1dHRvblwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYnV0dG9uIHNoYWRlLWJ1dHRvblwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdC13aW5kb3ctYnV0dG9uIGV4cGFuZC1idXR0b25cIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic3Qtd2luZG93LXRpdGxlXCI+XG4gICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cInN0LXdpbmRvdy1wYW5lXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwic3Qtd2luZG93LWdyaXBwZXIgcmlnaHQtZ3JpcHBlclwiIGRhdGEtZ3JpcC1lbmQ9XCJyaWdodFwiPjwvZGl2PlxuYDtcblxuY2xhc3MgV2luZG93VmlldyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHZhciB0ZW1wbGF0ZUNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZUNvbnRlbnQpO1xuXG4gICAgICAgIHRoaXMubW91c2VEb3duSW5CYXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1NoYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHBhbmRDYWNoZSA9IHt9O1xuXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBncmlwcGluZyB0aGVcbiAgICAgICAgLy8gYm90dG9tIHJpZ2h0IGNvcm5lciBmb3IgYSByZXNpemVcbiAgICAgICAgdGhpcy5pc0dyaXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNldHVwQ2xpY2tBbmREcmFnID0gdGhpcy5zZXR1cENsaWNrQW5kRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwQmFyQnV0dG9ucyA9IHRoaXMuc2V0dXBCYXJCdXR0b25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBFeHBhbmRlckFyZWFzID0gdGhpcy5zZXR1cEV4cGFuZGVyQXJlYXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycyA9IHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUluQmFyID0gdGhpcy5vbk1vdXNlTW92ZUluQmFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZURvd25JbkJhciA9IHRoaXMub25Nb3VzZURvd25JbkJhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcEFmdGVyRHJhZyA9IHRoaXMub25Nb3VzZVVwQWZ0ZXJEcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU2hhZGUgPSB0aGlzLm9uU2hhZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkV4cGFuZCA9IHRoaXMub25FeHBhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkdyaXBEb3duID0gdGhpcy5vbkdyaXBEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25HcmlwVXAgPSB0aGlzLm9uR3JpcFVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25HcmlwTW92ZSA9IHRoaXMub25HcmlwTW92ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldHVwIHByb3AgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvcEhhbmRsZXJzKCl7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCd0aXRsZScsIHRoaXMuc2V0VGl0bGUpO1xuICAgIH1cblxuICAgIGFmdGVyQ29ubmVjdGVkKCl7XG4gICAgICAgIHRoaXMuc2V0dXBDbGlja0FuZERyYWcoKTtcbiAgICAgICAgdGhpcy5zZXR1cEJhckJ1dHRvbnMoKTtcbiAgICAgICAgdGhpcy5zZXR1cEV4cGFuZGVyQXJlYXMoKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMuc2V0VGl0bGUoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAndGl0bGUnXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0dXBDbGlja0FuZERyYWcoKXtcbiAgICAgICAgbGV0IGJhciA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnN0LXdpbmRvdy1iYXInKTtcbiAgICAgICAgYmFyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd25JbkJhcik7XG4gICAgfVxuXG4gICAgc2V0dXBCYXJCdXR0b25zKCl7XG4gICAgICAgIGxldCBjbG9zZUJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmNsb3NlLWJ1dHRvbicpO1xuICAgICAgICBsZXQgc2hhZGVCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zaGFkZS1idXR0b24nKTtcbiAgICAgICAgbGV0IGV4cGFuZEJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmV4cGFuZC1idXR0b24nKTtcblxuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbG9zZSk7XG4gICAgICAgIHNoYWRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblNoYWRlKTtcbiAgICAgICAgZXhwYW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkV4cGFuZCk7XG4gICAgfVxuXG4gICAgc2V0dXBFeHBhbmRlckFyZWFzKCl7XG4gICAgICAgIGxldCBsb3dlclJpZ2h0ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcucmlnaHQtZ3JpcHBlcicpO1xuICAgICAgICBsb3dlclJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25HcmlwRG93bik7XG4gICAgfVxuXG4gICAgb25FeHBhbmQoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLmlzRXhwYW5kZWQpe1xuICAgICAgICAgICAgdGhpcy5zdHlsZS53aWR0aCA9IHRoaXMuZXhwYW5kQ2FjaGUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmhlaWdodCA9IHRoaXMuZXhwYW5kQ2FjaGUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZS50b3AgPSB0aGlzLmV4cGFuZENhY2hlLnRvcDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUubGVmdCA9IHRoaXMuZXhwYW5kQ2FjaGUubGVmdDtcbiAgICAgICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRDYWNoZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5zdHlsZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zdHlsZS50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zdHlsZS5sZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU2V0IG5ldyB2YWx1ZXMgYmFzZWQgb24gd2luZG93IHNpemVcbiAgICAgICAgICAgIHRoaXMuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gXCIxMDB2d1wiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCI7XG4gICAgICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25TaGFkZShldmVudCl7XG4gICAgICAgIGxldCBwYW5lID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3Qtd2luZG93LXBhbmUnKTtcbiAgICAgICAgaWYodGhpcy5pc1NoYWRlZCl7XG4gICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5yZW1vdmUoJ3NoYWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5pc1NoYWRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QuYWRkKCdzaGFkZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaXNTaGFkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DbG9zZShldmVudCl7XG4gICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ3dpbmRvd0Nsb3NlJyxcbiAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2UobXNnLCB0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlRG93bkluQmFyKGV2ZW50KXtcbiAgICAgICAgdGhpcy5tb3VzZURvd25JbkJhciA9IHRydWU7XG4gICAgICAgIGxldCBiYXIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVJbkJhcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcEFmdGVyRHJhZyk7XG4gICAgfVxuXG4gICAgb25Nb3VzZVVwQWZ0ZXJEcmFnKGV2ZW50KXtcbiAgICAgICAgdGhpcy5tb3VzZURvd25JbkJhciA9IGZhbHNlO1xuICAgICAgICBsZXQgYmFyID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXBBZnRlckRyYWcpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlSW5CYXIpO1xuICAgIH1cblxuICAgIG9uTW91c2VNb3ZlSW5CYXIoZXZlbnQpe1xuICAgICAgICBsZXQgY3VycmVudFRvcCA9IHBhcnNlSW50KHRoaXMuc3R5bGUudG9wKTtcbiAgICAgICAgbGV0IGN1cnJlbnRMZWZ0ID0gcGFyc2VJbnQodGhpcy5zdHlsZS5sZWZ0KTtcbiAgICAgICAgLy8gbGV0IG5ld1RvcCA9IGAke2N1cnJlbnRUb3AgKyBldmVudC5tb3ZlbWVudFl9cHhgO1xuICAgICAgICAvLyBsZXQgbmV3TGVmdCA9IGAke2N1cnJlbnRMZWZ0ICsgZXZlbnQubW92ZW1lbnRYfXB4YDtcbiAgICAgICAgbGV0IG5ld1RvcCA9IGN1cnJlbnRUb3AgKyBldmVudC5tb3ZlbWVudFk7XG4gICAgICAgIGxldCBuZXdMZWZ0ID0gY3VycmVudExlZnQgKyBldmVudC5tb3ZlbWVudFg7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcInRvcFwiLCBuZXdUb3ApO1xuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJsZWZ0XCIsIG5ld0xlZnQpO1xuICAgIH1cblxuICAgIG9uR3JpcFVwKGV2ZW50KXtcbiAgICAgICAgdGhpcy5pc0dyaXBwaW5nID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25HcmlwTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uR3JpcFVwKTtcbiAgICB9XG5cbiAgICBvbkdyaXBEb3duKGV2ZW50KXtcbiAgICAgICAgdGhpcy5pc0dyaXBwaW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkdyaXBNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25HcmlwVXApO1xuICAgIH1cblxuICAgIG9uR3JpcE1vdmUoZXZlbnQpe1xuICAgICAgICBpZih0aGlzLmlzR3JpcHBpbmcpe1xuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgY3VycmVudCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICAgICAgLy8gYW5kIHNldCB0aGUgcHJvcGVydHkgdG8gdGhlIG5ldyBvbmVcbiAgICAgICAgICAgIGxldCBib3ggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGV0IG5ld1dpZHRoID0gTWF0aC5mbG9vcihib3gud2lkdGgpICsgZXZlbnQubW92ZW1lbnRYO1xuICAgICAgICAgICAgaWYobmV3V2lkdGgpe1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZCh0aGlzLm1vZGVsLCBcIndpZHRoXCIsIG5ld1dpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdIZWlnaHQgPSBNYXRoLmZsb29yKGJveC5oZWlnaHQpICsgZXZlbnQubW92ZW1lbnRZO1xuICAgICAgICAgICAgaWYobmV3SGVpZ2h0KXtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJoZWlnaHRcIiwgbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFRpdGxlKGFTdHJpbmcpe1xuICAgICAgICBsZXQgdGl0bGVBcmVhID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgJy5zdC13aW5kb3ctdGl0bGUgPiBzcGFuJ1xuICAgICAgICApO1xuICAgICAgICB0aXRsZUFyZWEuaW5uZXJUZXh0ID0gYVN0cmluZztcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSBzdWJjbGFzcyBtZXRob2RzXG4gICAgbmV3U3VicGFydFZpZXcobmV3Vmlldyl7XG4gICAgICAgIC8vIHNsb3QgdGhlIG5ldyB2aWV3IGludG8gdGhlIHdpbmRvdyBwYW5lXG4gICAgICAgIGxldCBwYW5lID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3Qtd2luZG93LXBhbmUnKTtcbiAgICAgICAgcGFuZS5hcHBlbmQobmV3Vmlldyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Vmlldyk7XG4gICAgfVxuXG5cbn07XG5cbmV4cG9ydCB7XG4gICAgV2luZG93VmlldyxcbiAgICBXaW5kb3dWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFdvcmxkVmlld1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIGFtIGEgV2ViY29tcG9uZW50IChjdXN0b20gZWxlbWVudCkgdGhhdCByZXByZXNlbnRzXG4gKiBhIHZpZXcgb2YgYSBXb3JsZFN0YWNrIG1vZGVsLlxuICogTXkgZWxlbWVudCBjaGlsZHJlbiBzaG91bGQgY29udGFpbiBhIHNpbmdsZSBTdGFja1ZpZXcgcmVwcmVzZW50aW5nXG4gKiB0aGUgY3VycmVudCBkaXNwbGF5ZWQgc3RhY2sgKHRoaXMgY29tZXMgZnJvbSB0aGUgbW9kZWwpLlxuICogSSBhbSB0aGUgcm9vdC1sZXZlbCBlbGVtZW50IGZvciB0aGUgU2ltcGxlVGFsayBzeXN0ZW0gaW4gYSB3ZWJcbiAqIHBhZ2UuIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBvZiBtZSBvbiBhbnkgZ2l2ZW4gSFRNTCBwYWdlLlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYDxzbG90Pjwvc2xvdD5gO1xuXG5jbGFzcyBXb3JsZFZpZXcgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGVtcGxhdGluZyBhbmQgc2hhZG93IGRvbVxuICAgICAgICAvLyBUT0RPOiBQdXQgdGhlIHRlbXBsYXRlIGRlZmluaXRpb24gaW4gdGhpc1xuICAgICAgICAvLyBtb2R1bGUgYXMgZm9ybWF0dGVkIHRleHRcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVGhlIHdvcmxkIG5ldmVyIHdhbnRzIGEgaGFsb1xuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50U3RhY2sgPSB0aGlzLnVwZGF0ZUN1cnJlbnRTdGFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlID0gdGhpcy5yZWNlaXZlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldHVwUHJvcEhhbmRsZXJzID0gdGhpcy5zZXR1cFByb3BIYW5kbGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUtleURvd24gPSB0aGlzLmhhbmRsZUtleURvd24uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBTZXR1cCBwcm9wIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb3BIYW5kbGVycygpe1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY3VycmVudCcsIHRoaXMudXBkYXRlQ3VycmVudFN0YWNrKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIERvIGFuIGluaXRpYWwgdXBkYXRlIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gdGhlIG1vZGVsJ3MgY3VycmVudCBzdGFja1xuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRTdGFjaygpO1xuICAgIH1cblxuICAgIHVwZGF0ZUN1cnJlbnRTdGFjaygpe1xuICAgICAgICAvLyBUaGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgcHJvcCBpcyB0aGUgc3RhY2sgSURcbiAgICAgICAgLy8gb2YgdGhlIGNoaWxkIFN0YWNrIHRoYXQgc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBjdXJyZW50IG9uZS4gV2UgcmVtb3ZlIHRoZSBjdXJyZW50LXN0YWNrIGNsYXNzIGZyb21cbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIGN1cnJlbnQgc3RhY2sgYW5kIGFkZCBpdCB0byB0aGUgbmV3IG9uZS5cbiAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IHRoaXMucXVlcnlTZWxlY3RvcignLmN1cnJlbnQtc3RhY2snKTtcbiAgICAgICAgbGV0IG5leHRDdXJyZW50SWQgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ2N1cnJlbnQnXG4gICAgICAgICk7XG4gICAgICAgIGxldCBuZXh0Q3VycmVudFN0YWNrID0gdGhpcy5xdWVyeVNlbGVjdG9yKGA6c2NvcGUgPiBzdC1zdGFja1twYXJ0LWlkPVwiJHtuZXh0Q3VycmVudElkfVwiXWApO1xuICAgICAgICBpZihuZXh0Q3VycmVudFN0YWNrKXtcbiAgICAgICAgICAgIG5leHRDdXJyZW50U3RhY2suY2xhc3NMaXN0LmFkZCgnY3VycmVudC1zdGFjaycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvIHByZXZlbnQgdGhlIHNldHRpbmcgb2YgdGhlIHNhbWUgaWQgYXMgdGhlIGN1cnJlbnQgc3RhY2sgbWFrZSBzdXJlXG4gICAgICAgIC8vIG5leHQgYW5kIGN1cnJlbnQgYXJlIG5vdCB0aGUgc2FtZVxuICAgICAgICBpZihjdXJyZW50U3RhY2sgJiYgY3VycmVudFN0YWNrICE9IG5leHRDdXJyZW50U3RhY2spe1xuICAgICAgICAgICAgY3VycmVudFN0YWNrLmNsYXNzTGlzdC5yZW1vdmUoJ2N1cnJlbnQtc3RhY2snKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUtleURvd24oZXZlbnQpe1xuICAgICAgICBpZihldmVudC5hbHRLZXkgJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC5jb2RlID09IFwiU3BhY2VcIil7XG4gICAgICAgICAgICBsZXQgbmF2aWdhdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3QtbmF2aWdhdG9yJyk7XG4gICAgICAgICAgICBuYXZpZ2F0b3IudG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSBzdWJjbGFzcyBtZXRob2RzXG4gICAgbmV3U3VicGFydFZpZXcobmV3Vmlldyl7XG4gICAgICAgIGlmKHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggJiYgbmV3Vmlldy5uYW1lID09IFwiU3RhY2tWaWV3XCIpe1xuICAgICAgICAgICAgbGV0IGxhc3RTdGFja05vZGU7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZihjaGlsZC5uYW1lID09IFwiU3RhY2tWaWV3XCIpe1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tOb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZihsYXN0U3RhY2tOb2RlKXtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3Qgc3RhY2tcbiAgICAgICAgICAgICAgICBsYXN0U3RhY2tOb2RlLmFmdGVyKG5ld1ZpZXcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGVyZSBhcmUgbm8gc3RhY2tzXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGJlZm9yZSBhbGwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0uaW5zZXJ0QmVmb3JlKG5ld1ZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuZXhwb3J0IHtcbiAgICBXb3JsZFZpZXcsXG4gICAgV29ybGRWaWV3IGFzIGRlZmF1bHRcbn07XG4iLCIvLyBQUkVBTUJMRVxuaW1wb3J0IENvbnRleHRNZW51SXRlbSBmcm9tICcuL0NvbnRleHRNZW51SXRlbS5qcyc7XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0LWNvbnRleHQtbWVudS1pdGVtJywgQ29udGV4dE1lbnVJdGVtKTtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYm94LXNoYWRvdzogMXB4IDJweCAxMHB4IHJnYmEoNTAsIDUwLCA1MCwgMC43KTtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgICAgIG1pbi13aWR0aDogMjAwcHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICB9XG5cbiAgICA6aG9zdC1jb250ZXh0KGxpKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMTAwJTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgfVxuXG4gICAgOmhvc3QtY29udGV4dChsaSk6aG92ZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cblxuICAgIGhlYWRlciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTUwLCAxNTAsIDE1MCwgMC41KTtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTZweDtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xuICAgICAgICBwYWRkaW5nLXRvcDogOHB4O1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIH1cblxuICAgIGhlYWRlciA+IGg0IHtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgbWFyZ2luOjA7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtO1xuICAgIH1cblxuPC9zdHlsZT5cbjxoZWFkZXI+XG4gICAgPGg0PjwvaDQ+XG48L2hlYWRlcj5cbjx1bCBpZD1cImxpc3QtaXRlbXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L3VsPlxuYDtcblxuY2xhc3MgQ29udGV4dE1lbnUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmFkZEhhbG9Ub2dnbGVJdGVtID0gdGhpcy5hZGRIYWxvVG9nZ2xlSXRlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZENvcHlBbmRQYXN0ZUl0ZW1zID0gdGhpcy5hZGRDb3B5QW5kUGFzdGVJdGVtcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZE9wZW5FZGl0b3JJdGVtID0gdGhpcy5hZGRPcGVuRWRpdG9ySXRlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFNjcmlwdEVkaXRJdGVtID0gdGhpcy5hZGRTY3JpcHRFZGl0SXRlbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZE1vdmVtZW50SXRlbXMgPSB0aGlzLmFkZE1vdmVtZW50SXRlbXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRQYXJ0U3VibWVudSA9IHRoaXMuYWRkUGFydFN1Ym1lbnUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbSA9IHRoaXMuYWRkTGlzdEl0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRTcGFjZXIgPSB0aGlzLmFkZFNwYWNlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhpZGVIZWFkZXIgPSB0aGlzLmhpZGVIZWFkZXIuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICBsZXQgaGVhZGVyRWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlciA+IGg0Jyk7XG4gICAgICAgIGxldCBoZWFkZXJUZXh0ID0gYCR7dGhpcy5tb2RlbC50eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0aGlzLm1vZGVsLnR5cGUuc2xpY2UoMSl9YDtcbiAgICAgICAgaGVhZGVyVGV4dCA9IGBhICR7aGVhZGVyVGV4dH1gO1xuICAgICAgICBoZWFkZXJFbC50ZXh0Q29udGVudCA9IGhlYWRlclRleHQ7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBkZWZhdWx0IG1lbnUgaXRlbXNcbiAgICAgICAgdGhpcy5hZGRIYWxvVG9nZ2xlSXRlbSgpO1xuICAgICAgICB0aGlzLmFkZENvcHlBbmRQYXN0ZUl0ZW1zKCk7XG4gICAgICAgIHRoaXMuYWRkT3BlbkVkaXRvckl0ZW0oKTtcbiAgICAgICAgdGhpcy5hZGRQYXJ0U3VibWVudSgpO1xuICAgICAgICB0aGlzLmFkZFNjcmlwdEVkaXRJdGVtKCk7XG4gICAgICAgIHRoaXMuYWRkTW92ZW1lbnRJdGVtcygpO1xuXG4gICAgICAgIC8vIEFkZCBWaWV3LXNwZWNpZmljIGl0ZW1zXG4gICAgICAgIGxldCB2aWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3RoaXMubW9kZWwuaWR9XCJdYCk7XG4gICAgICAgIHZpZXcuYWRkQ29udGV4dE1lbnVJdGVtcyh0aGlzKTtcbiAgICB9XG5cbiAgICBhZGRMaXN0SXRlbShsYWJlbCwgY2FsbGJhY2ssIHN1Ym1lbnU9bnVsbCl7XG4gICAgICAgIGxldCBpdGVtRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdC1jb250ZXh0LW1lbnUtaXRlbScpO1xuICAgICAgICBpdGVtRWwudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICAgICAgaXRlbUVsLmNsYXNzTGlzdC5hZGQoJ2NvbnRleHQtbWVudS1pdGVtJyk7XG4gICAgICAgIGl0ZW1FbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYoc3VibWVudSl7ICAgICAgICAgICAgIFxuICAgICAgICAgICAgc3VibWVudS5jbGFzc0xpc3QuYWRkKCdjb250ZXh0LXN1Ym1lbnUnLCAnc3VibWVudS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHN1Ym1lbnUuc2V0QXR0cmlidXRlKCdzbG90JywgJ3N1Ym1lbnUnKTtcbiAgICAgICAgICAgIGl0ZW1FbC5hcHBlbmQoc3VibWVudSk7XG4gICAgICAgICAgICBpdGVtRWwuc2hvd0NhcmV0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmQoaXRlbUVsKTtcbiAgICB9XG5cbiAgICBhZGRIYWxvVG9nZ2xlSXRlbSgpe1xuICAgICAgICBsZXQgdGFyZ2V0ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIC8vIGRvbid0IGFkZCBoYWxvIG9wdGlvbiB0byBjYXJkcywgc2luY2UgeW91IGNhbid0IHNlZSB0aG9zZVxuICAgICAgICBpZih0YXJnZXQubmFtZSAhPSBcIkNhcmRWaWV3XCIpe1xuICAgICAgICAgICAgaWYodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZWRpdGluZycpKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICAgICAnQ2xvc2UgSGFsbycsXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsb3NlSGFsbygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgJ09wZW4gSGFsbycsXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm9wZW5IYWxvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ29weUFuZFBhc3RlSXRlbXMoKXtcbiAgICAgICAgLy8gQWRkIGNvcHkgaXRlbVxuICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgJ0NvcHknLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29weVBhcnQodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWRkIHBhc3RlIGJ1dCBvbmx5IGlmOlxuICAgICAgICAvLyAxLiBUaGVyZSBpcyBjbGlwYm9hcmQgY29udGVudHM7XG4gICAgICAgIC8vIDIuIFRoZSBwYXJ0IHR5cGUgaW4gdGhlIGNsaXBib2FyZCBpc1xuICAgICAgICAvLyAgICBvbmUgdGhhdCBpcyBhY2NlcHRlZCBieSB0aGlzIG1vZGVsJ3MgcGFydFxuICAgICAgICBpZih3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5jb250ZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgbGV0IHBhcnRUeXBlID0gd2luZG93LlN5c3RlbS5jbGlwYm9hcmQuY29udGVudHNbMF0ucGFydFR5cGU7XG4gICAgICAgICAgICBpZih0aGlzLm1vZGVsLmFjY2VwdHNTdWJwYXJ0KHBhcnRUeXBlKSl7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gYFBhc3RlIChhICR7cGFydFR5cGVbMF0udG9VcHBlckNhc2UoKX0ke3BhcnRUeXBlLnNsaWNlKDEpfSlgO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0obGFiZWwsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmNsaXBib2FyZC5wYXN0ZUNvbnRlbnRzSW50byh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZE9wZW5FZGl0b3JJdGVtKCl7XG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnT3BlbiBFZGl0b3InLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LlN5c3RlbS5vcGVuRWRpdG9yRm9yUGFydCh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhZGRTY3JpcHRFZGl0SXRlbSgpe1xuICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgJ0VkaXQgU2NyaXB0JyxcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnb3BlblNjcmlwdEVkaXRvcicsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLm1vZGVsLmlkXVxuICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAnRWRpdCBXb3JsZCBTY3JpcHQnLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWyd3b3JsZCddXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHdpbmRvd0FuY2VzdG9yID0gdGhpcy5tb2RlbC5maW5kQW5jZXN0b3JPZlR5cGUoJ3dpbmRvdycpO1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgIT0gJ3dpbmRvdycgJiYgd2luZG93QW5jZXN0b3IgIT09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnRWRpdCBPd25pbmcgV2luZG93IFNjcmlwdCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdvcGVuU2NyaXB0RWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt3aW5kb3dBbmNlc3Rvci5pZF1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IGNhcmRBbmNlc3RvciA9IHRoaXMubW9kZWwuZmluZEFuY2VzdG9yT2ZUeXBlKCdjYXJkJyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSAhPSAnY2FyZCcgJiYgY2FyZEFuY2VzdG9yKXtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ0VkaXQgT3duaW5nIENhcmQgU2NyaXB0JyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2NhcmRBbmNlc3Rvci5pZF1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFja0FuY2VzdG9yID0gdGhpcy5tb2RlbC5maW5kQW5jZXN0b3JPZlR5cGUoJ3N0YWNrJyk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSAhPSAnc3RhY2snICYmIHN0YWNrQW5jZXN0b3Ipe1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnRWRpdCBPd25pbmcgU3RhY2sgU2NyaXB0JyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3N0YWNrQW5jZXN0b3IuaWRdXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRQYXJ0U3VibWVudSgpe1xuICAgICAgICAvLyBGaXJzdCwgd2UgbmVlZCB0byBnZXQgYSBsaXN0IG9mIG5hbWVzXG4gICAgICAgIC8vIG9mIHN1YnBhcnRzIHRoYXQgdGhpcyBtb2RlbCBhY2NlcHRzXG4gICAgICAgIGxldCBzdWJwYXJ0TmFtZXM7XG4gICAgICAgIGlmKHRoaXMubW9kZWwuYWNjZXB0ZWRTdWJwYXJ0VHlwZXNbMF0gPT0gXCIqXCIpe1xuICAgICAgICAgICAgLy8gVGhpcyBtb2RlbCBhY2NlcHRzIGFsbCBzdWJwYXJ0IHR5cGVzLlxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgdGhlIG5hbWVzIGZvciB0aGVzZSBzdWJwYXJ0cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIGFyZSByZWdpc3RlcmVkIGF0IHRoZSBTeXN0ZW0gbGV2ZWwuXG4gICAgICAgICAgICBzdWJwYXJ0TmFtZXMgPSBPYmplY3Qua2V5cyh3aW5kb3cuU3lzdGVtLmF2YWlsYWJsZVZpZXdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnBhcnROYW1lcyA9IHRoaXMubW9kZWwuYWNjZXB0ZWRTdWJwYXJ0VHlwZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc3VicGFydCBuYW1lcyAobWVhbmluZ1xuICAgICAgICAvLyB0aGUgZ2l2ZW4gcGFydCwgbGlrZSBhIGJ1dHRvbiwgZG9lc24ndFxuICAgICAgICAvLyBhY2NlcHQgYW55IHN1YnBhcnRzKSwgdGhlbiB3ZSBkbyBub3RoaW5nLlxuICAgICAgICBpZihzdWJwYXJ0TmFtZXMubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHdlIGNvbnN0cnVjdCB0aGUgc3VibWVudSBmb3IgYWRkaW5nIHBhcnRzXG4gICAgICAgIC8vIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgICAgIGxldCBzdWJtZW51ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtY29udGV4dC1tZW51Jyk7XG4gICAgICAgIHN1Ym1lbnUuaGlkZUhlYWRlcigpO1xuICAgICAgICBzdWJwYXJ0TmFtZXMuZm9yRWFjaChzdWJwYXJ0TmFtZSA9PiB7XG4gICAgICAgICAgICBzdWJtZW51LmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgIHN1YnBhcnROYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBzdWJwYXJ0TmFtZS5zbGljZSgxKSxcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICduZXdNb2RlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGFydE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBOb3cgYWRkIHRoZSBsaXN0IGl0ZW0gdGhhdCB3aWxsIFwicmV2ZWFsXCJcbiAgICAgICAgLy8gdGhlIHN1Ym1lbnVcbiAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICdBZGQgYSBuZXcgcGFydCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3VibWVudVxuICAgICAgICApO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBhZGRNb3ZlbWVudEl0ZW1zKCl7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubW9kZWwuX293bmVyLnN1YnBhcnRzLmluZGV4T2YodGhpcy5tb2RlbCk7XG4gICAgICAgIGxldCBvd25lckxlbmd0aCA9IHRoaXMubW9kZWwuX293bmVyLnN1YnBhcnRzLmxlbmd0aDtcbiAgICAgICAgaWYob3duZXJMZW5ndGggJiYgaW5kZXggPCBvd25lckxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBtb3ZlRG93biBvcHRpb25cbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdEl0ZW0oXG4gICAgICAgICAgICAgICAgJ01vdmUgRG93bicsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3ZlRG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnTW92ZSB0byBMYXN0JyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmVUb0xhc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZihpbmRleCA+IDApe1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBtb3ZlVXAgb3B0aW9uXG4gICAgICAgICAgICB0aGlzLmFkZExpc3RJdGVtKFxuICAgICAgICAgICAgICAgICdNb3ZlIFVwJyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdmVVcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0SXRlbShcbiAgICAgICAgICAgICAgICAnTW92ZSB0byBGaXJzdCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3ZlVG9GaXJzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkU3BhY2VyKCl7XG4gICAgICAgIGxldCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdjb250ZXh0LW1lbnUtc3BhY2VyJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kKGl0ZW0pO1xuICAgIH1cblxuICAgIGhpZGVIZWFkZXIoKXtcbiAgICAgICAgbGV0IGhlYWRlckVsID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKTtcbiAgICAgICAgaGVhZGVyRWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgQ29udGV4dE1lbnUsXG4gICAgQ29udGV4dE1lbnUgYXMgZGVmYXVsdFxufTtcbiIsImNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgICAuc3VibWVudS1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAxMDAlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICB9XG5cbiAgICA6aG9zdCg6aG92ZXIpIC5zdWJtZW51LWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cblxuICAgIC5sYWJlbC1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAuY2FyZXQuaGlkZGVuIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgLmNhcmV0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICAgICAgICBmb250LXNpemU6IDEuMWVtO1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwibGFiZWwtYXJlYVwiPlxuICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj48c2xvdD48L3Nsb3Q+PC9zcGFuPlxuICAgIDxkaXYgY2xhc3M9XCJjYXJldCBoaWRkZW5cIj7ihpI8L2Rpdj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cInN1Ym1lbnUtYXJlYVwiPlxuICAgIDxzbG90IG5hbWU9XCJzdWJtZW51XCI+PC9zbG90PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBDb250ZXh0TWVudUl0ZW0gZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCBzaGFkb3cgZG9tIGFuZCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnNob3dDYXJldCA9IHRoaXMuc2hvd0NhcmV0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgc2hvd0NhcmV0KCl7XG4gICAgICAgIGxldCBjYXJldEVsID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuY2FyZXQnKTtcbiAgICAgICAgY2FyZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgXG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBDb250ZXh0TWVudUl0ZW0sXG4gICAgQ29udGV4dE1lbnVJdGVtIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIENvbG9yUGlja2VyVG9vbFxuICogSSBwcm92aWRlIGEgY29sb3IgY2hvb3JzZXIgY2FwYWJpbGl0eVxuICogZm9yIHRoZSBzaGFkb3cgY2FudmFzIG9mIG15IHBhcmVudCBlbGVtZW50LlxuICogQnJ1c2hlcyBvbiBteSBwYXJlbnQgRHJhd2luZyBjYW52YXMgd2lsbCB1c2VcbiAqIHdoYXRldmVyIGNvbG9yIEkgaGF2ZSBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gKiBJIGFtIGV4cGxpY2l0bHkgZGVzaWduZWQgZm9yIHVzZSB3aXRoXG4gKiBEcmF3aW5nVmlldyovXG5pbXBvcnQge0NvbG9yV2hlZWxXaWRnZXR9IGZyb20gJy4vQ29sb3JXaGVlbFdpZGdldC5qcyc7XG5jb25zdCBjb2xvclBpY2tlclNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jb2xvci1zd2F0Y2hcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTE5IDNoLTRhMiAyIDAgMCAwIC0yIDJ2MTJhNCA0IDAgMCAwIDggMHYtMTJhMiAyIDAgMCAwIC0yIC0yXCIgLz5cbiAgPHBhdGggZD1cIk0xMyA3LjM1bC0yIC0yYTIgMiAwIDAgMCAtMi44MjggMGwtMi44MjggMi44MjhhMiAyIDAgMCAwIDAgMi44MjhsOSA5XCIgLz5cbiAgPHBhdGggZD1cIk03LjMgMTNoLTIuM2EyIDIgMCAwIDAgLTIgMnY0YTIgMiAwIDAgMCAyIDJoMTJcIiAvPlxuICA8bGluZSB4MT1cIjE3XCIgeTE9XCIxN1wiIHgyPVwiMTdcIiB5Mj1cIjE3LjAxXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY29sb3JQaWNrZXJUZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDZweDtcbiAgICB9XG5cbiAgICAjdG9vbC1idXR0b24ge1xuICAgICAgICAtLWFjdGl2ZS1jb2xvcjogYmxhY2s7XG4gICAgICAgIC0taW5hY3RpdmUtY29sb3I6IHJnYigxNzAsIDE3MCwgMTcwKTtcbiAgICAgICAgLS1ob3Zlci1jb2xvcjogcmdiKDE0MCwgMTQwLCAxNDApO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBib3JkZXItd2lkdGg6IDFweDtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgfVxuXG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pID4gI3Rvb2wtYnV0dG9uIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgICAgICBjb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgY29sb3Itd2hlZWwge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuXG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pID4gY29sb3Itd2hlZWwge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwidG9vbC1idXR0b25cIj5cbiR7Y29sb3JQaWNrZXJTVkd9XG48L2Rpdj5cbjxjb2xvci13aGVlbD48L2NvbG9yLXdoZWVsPlxuYDtcblxuXG5jbGFzcyBDb2xvclBpY2tlclRvb2wgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXQgdXAgc2hhZG93IGRvbS4gVGhpcyB0b29sIHdpbGxcbiAgICAgICAgLy8gZGlzcGxheSBpdHNlbGYgYXMgYSBidXR0b24gdGhhdCBjYW4gYmVcbiAgICAgICAgLy8gdG9nZ2xlZCB3aXRoaW4gaXRzIHBhcmVudCBEcmF3aW5nVmlldy5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gY29sb3JQaWNrZXJUZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEZWZhdWx0IGRyYXdpbmcgY29udGV4dCBpcyBudWxsLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgc2V0IGlmIGFuZCB3aGVuIHRoaXMgdG9vbFxuICAgICAgICAvLyBpcyBjb25uZWN0ZWQgdG8gYSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAvLyB0aGF0IGhhcyBhIGNvbnRleHRcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmQgPSB0aGlzLmVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlID0gdGhpcy50b2dnbGVBY3RpdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNvbG9yU2VsZWN0ZWQgPSB0aGlzLm9uQ29sb3JTZWxlY3RlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlZCA9IHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzID0gdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICAgICAgICBpZighdGhpcy5oYXNBdHRyaWJ1dGUoJ2N1cnJlbnQtY29sb3InKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnQtY29sb3InLCAncmdiYSgwLCAwLCAwLCAwKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIElmIEkgYW0gdGhlIG9ubHkgdG9vbCBpbiBteSBwYXJlbnQsXG4gICAgICAgICAgICAgICAgLy8gc2V0IG15c2VsZiB0byBhY3RpdmVcbiAgICAgICAgICAgICAgICBsZXQgc2libGluZ1Rvb2xzID0gdGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpO1xuICAgICAgICAgICAgICAgIGlmKHNpYmxpbmdUb29scy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0b29sLWJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2ZSk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yV2hlZWwgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignY29sb3Itd2hlZWwnKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JXaGVlbC5hZGRFdmVudExpc3RlbmVyKCdjb2xvci1zZWxlY3RlZCcsIHRoaXMub25Db2xvclNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JXaGVlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc3BhcmVuY3ktY2hhbmdlZCcsIHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY29sb3JXaGVlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb2xvci1zZWxlY3RlZCcsIHRoaXMub25Db2xvclNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5jb2xvcldoZWVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zcGFyZW5jeS1jaGFuZ2VkJywgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZWQpO1xuICAgIH1cblxuICAgIHN0YXJ0KHgsIHkpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgaW4gdGhpcyB0b29sXG4gICAgfVxuXG4gICAgZW5kKHgsIHkpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgaW4gdGhpcyB0b29sXG4gICAgfVxuXG4gICAgb25Nb3ZlKHgsIHkpe1xuICAgICAgICAvLyBEb2VzIG5vdGhpbmcgaW4gdGhpcyB0b29sXG4gICAgfVxuXG4gICAgc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzKCl7XG4gICAgICAgIC8vIERvZXMgbm90aGluZyBpbiB0aGlzIHRvb2xcbiAgICB9XG5cbiAgICBvbkNvbG9yU2VsZWN0ZWQoZXZlbnQpe1xuICAgICAgICBsZXQgY29sb3JJbmZvID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBsZXQgY29sb3JTdHIgPSBgcmdiYSgke2NvbG9ySW5mby5yfSwgJHtjb2xvckluZm8uZ30sICR7Y29sb3JJbmZvLmJ9LCAke2NvbG9ySW5mby5hbHBoYX0pYDtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvclN0cjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3JTdHI7XG4gICAgfVxuXG4gICAgb25UcmFuc3BhcmVuY3lDaGFuZ2VkKGV2ZW50KXtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50Lm1vZGVsLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwic2V0UHJvcGVydHlcIixcbiAgICAgICAgICAgIGFyZ3M6IFtcInRyYW5zcGFyZW5jeVwiLCBldmVudC5kZXRhaWxdXG4gICAgICAgIH0sIHRoaXMucGFyZW50RWxlbWVudC5tb2RlbCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlQWN0aXZlKGV2ZW50KXtcbiAgICAgICAgbGV0IGlzQWN0aXZlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpO1xuICAgICAgICBpZihpc0FjdGl2ZSA9PSBcInRydWVcIil7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZmluZCBhbnkgb3RoZXIgdG9vbHMgaW4gbXkgcGFyZW50XG4gICAgICAgICAgICAvLyBlbGVtZW50IGFuZCBkZWFjdGl2YXRlIHRoZW0uXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnYWN0aXZlJykgPT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhpcyB0b29sIHRvIGJlIGFjdGl2ZVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY29sb3ItcGlja2VyLXRvb2wnLCBDb2xvclBpY2tlclRvb2wpO1xuXG5leHBvcnQge1xuICAgIENvbG9yUGlja2VyVG9vbCxcbiAgICBDb2xvclBpY2tlclRvb2wgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogQ29sb3JXaGVlbFdpZGdldFxuICogSSBhbSBhICpnZW5lcmljIHVzZSogd2ViY29tcG9uZW50IHJlcHJlc2VudGluZ1xuICogYSBDb2xvcldoZWVsIHNlbGVjdGlvbiB3aWRnZXQuXG4gKiBJIG9wZXJhdGUgYXMgYSBmbG9hdGluZyBtb2RhbCB3aW5kb3cgd2l0aCBhXG4gKiBjaXJjdWxhciBjb2xvciB3aGVlbCBhcyB3ZWxsIGFzIGEgbGlzdCBvZlxuICogcmVjZW50bHkgc2VsZWN0ZWQgY29sb3JzLlxuICogSSBhbSBkZXNpZ25lZCB0byBiZSB1c2VkIGJ5IGFueSBwYXJlbnQgZWxlbWVudC5cbiAqIEkgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGNhbGxlZCAnY29sb3ItY2hhbmdlJyB3aGVuZXZlclxuICogYSBuZXcgY29sb3IgaGFzIGJlZW4gc2VsZWN0ZWQgZnJvbSB3aXRoaW4gbWVcbiAqL1xuXG5jb25zdCBjb2xvcldoZWVsVGVtcGxhdGUgPSBgXG48c3R5bGU+XG4gIDpob3N0IHtcbiAgICBkaXNwbGF5OiBpbml0aWFsICFpbXBvcnRhbnQ7XG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgfVxuXG4gICNwYWxldHRlLWJhciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDAsIDIwMCwgMjAwKTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG5cbiAgI3BhbGV0dGUtdGl0bGUge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuXG4gICNjbG9zZS1idXR0b24ge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMnB4O1xuICAgIGhlaWdodDogMTJweDtcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDEycHg7XG4gIH1cblxuICAjcGFsZXR0ZS1jb250ZW50IHtcbiAgICBmbGV4OiAxO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuICAjaG92ZXItY29sb3Ige1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMjVweDtcbiAgfVxuICAjb3B0aW9ucyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDI1cHg7XG4gICAgbWFyZ2luLXRvcDogNXB4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB9XG5cbiAgI29wdGlvbnMgPiBsYWJlbHtcbiAgICBmb250LXNpemU6IC44cmVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuXG4gICNyZWNlbnQtY29sb3JzIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICBwYWRkaW5nLWxlZnQ6IDE1cHg7XG4gICAgcGFkZGluZy1yaWdodDogMTVweDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIH1cbiAgLnJlY2VudC1jb2xvci1pdGVtIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMjZweDtcbiAgICBoZWlnaHQ6IDI2cHg7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuOCk7XG4gIH1cblxuICAucmVjZW50LWNvbG9yLWl0ZW0uc2VsZWN0ZWQge1xuICAgIGJvcmRlcjogMnB4IHNvbGlkIGJsYWNrO1xuICB9XG5cbjwvc3R5bGU+XG48ZGl2IGlkPVwicGFsZXR0ZS13cmFwcGVyXCI+XG4gIDxkaXYgaWQ9XCJwYWxldHRlLWJhclwiPjxkaXYgaWQ9XCJjbG9zZS1idXR0b25cIj54PC9kaXY+PHNwYW4gaWQ9XCJwYWxldHRlLXRpdGxlXCI+PC9zcGFuPjwvZGl2PlxuICA8ZGl2IGlkPVwicGFsZXR0ZS1jb250ZW50XCI+XG4gICAgPGRpdiBpZD1cIm9wdGlvbnNcIj5cbiAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBpZD1cInRyYW5zcGFyZW5jeVwiIG5hbWU9XCJ0cmFuc3BhcmVuY3lcIiBtaW49XCIwXCIgbWF4PVwiMVwiIHN0ZXA9XCIwLjFcIiB2YWx1ZT1cIjFcIj5cbiAgICAgIDwhLS0gPGxhYmVsIGZvcj1cInRyYW5zcGFyZW5jeVwiPlRyYW5zcGFyZW5jeTwvbGFiZWw+LS0+XG4gICAgPC9kaXY+XG4gICAgPHVsIGlkPVwicmVjZW50LWNvbG9yc1wiPlxuICAgICAgPGxpIGNsYXNzPVwicmVjZW50LWNvbG9yLWl0ZW0gc2VsZWN0ZWRcIj48L2xpPlxuICAgICAgPGxpIGNsYXNzPVwicmVjZW50LWNvbG9yLWl0ZW1cIj48L2xpPlxuICAgICAgPGxpIGNsYXNzPVwicmVjZW50LWNvbG9yLWl0ZW1cIj48L2xpPlxuICAgIDwvdWw+XG4gICAgPGNhbnZhcyBpZD1cImNvbG9yLXdoZWVsXCIgd2lkdGg9XCIxNTBcIiBoZWlnaHQ9XCIxNTBcIj48L2NhbnZhcz5cbiAgICA8ZGl2IGlkPVwiaG92ZXItY29sb3JcIj48L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIENvbG9yV2hlZWxXaWRnZXQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBTZXR1cCBzaGFkb3cgZG9tIGFuZCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBjb2xvcldoZWVsVGVtcGxhdGU7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLnNoYWRvdy5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmluZCBsb2NhbCBtZXRob2RzXG4gICAgICAgIHRoaXMub25XaGVlbE1vdXNlRW50ZXIgPSB0aGlzLm9uV2hlZWxNb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25XaGVlbE1vdXNlTGVhdmUgPSB0aGlzLm9uV2hlZWxNb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25XaGVlbE1vdXNlTW92ZSA9IHRoaXMub25XaGVlbE1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uV2hlZWxDbGljayA9IHRoaXMub25XaGVlbENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25JdGVtQ2xpY2sgPSB0aGlzLm9uSXRlbUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25CYXJNb3VzZURvd24gPSB0aGlzLm9uQmFyTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25CYXJNb3VzZVVwID0gdGhpcy5vbkJhck1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkJhck1vdXNlTW92ZSA9IHRoaXMub25CYXJNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2UgPSB0aGlzLm9uVHJhbnNwYXJlbmN5Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2RyYXdXaGVlbCA9IHRoaXMuX2RyYXdXaGVlbC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgICAgICB0aGlzLmJhciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgncGFsZXR0ZS1iYXInKTtcbiAgICAgICAgICAgIC8vIGdpdmUgdGhlIHdpZGdldCBhIHRpdGxlIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBpZih0aGlzLm5hbWUpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgncGFsZXR0ZS10aXRsZScpLmlubmVyVGV4dCA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uV2hlZWxDbGljayk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbldoZWVsTW91c2VFbnRlcik7XG4gICAgICAgICAgICB0aGlzLmJhci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uQmFyTW91c2VEb3duKTtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZWNlbnQtY29sb3ItaXRlbScpKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25JdGVtQ2xpY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVNsaWRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndHJhbnNwYXJlbmN5Jyk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVNsaWRlci5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5vblRyYW5zcGFyZW5jeUNoYW5nZSk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGNvbG9yIHdoZWVsIHRvIHRoZSBjYW52YXNcbiAgICAgICAgICAgIHRoaXMuX2RyYXdXaGVlbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uV2hlZWxDbGljayk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uV2hlZWxNb3VzZUVudGVyKTtcbiAgICAgICAgdGhpcy5iYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbkJhck1vdXNlRG93bik7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5yZWNlbnQtY29sb3ItaXRlbScpKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkl0ZW1DbGljayk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVNsaWRlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25UcmFuc3BhcmVuY3lDaGFuZ2UpO1xuICAgIH1cblxuXG4gICAgb25XaGVlbE1vdXNlRW50ZXIoZXZlbnQpe1xuICAgICAgICAvLyBDYWNoZSB0aGUgaW1hZ2UgZGF0YSBmb3IgdGhlIHdob2xlIGNhbnZhc1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkSW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YShcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgICAgLy8gQmluZCBzdWJzZXF1ZW50IGV2ZW50c1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uV2hlZWxNb3VzZU1vdmUpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbldoZWVsTW91c2VMZWF2ZSk7XG4gICAgfVxuXG4gICAgb25XaGVlbE1vdXNlTGVhdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uV2hlZWxNb3VzZU1vdmUpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbldoZWVsTW91c2VMZWF2ZSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEltYWdlRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgb25XaGVlbE1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uRnJvbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgbGV0IHJnYiA9IGdldFJHQkZyb21JbWFnZURhdGEoXG4gICAgICAgICAgICBwb3NpdGlvbi54LFxuICAgICAgICAgICAgcG9zaXRpb24ueSxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkSW1hZ2VEYXRhLmRhdGFcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGhvdmVyQ29sb3JBcmVhID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdob3Zlci1jb2xvcicpO1xuICAgICAgICBsZXQgbmV3U3R5bGUgPSBgcmdiYSgke3JnYlswXX0sICR7cmdiWzFdfSwgJHtyZ2JbMl19LCAke3JnYlszXX0pYDtcbiAgICAgICAgaG92ZXJDb2xvckFyZWEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbmV3U3R5bGU7XG4gICAgfVxuXG4gICAgb25XaGVlbENsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb25Gcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICBsZXQgcmdiID0gZ2V0UkdCRnJvbUltYWdlRGF0YShcbiAgICAgICAgICAgIHBvc2l0aW9uLngsXG4gICAgICAgICAgICBwb3NpdGlvbi55LFxuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRJbWFnZURhdGEuZGF0YVxuICAgICAgICApO1xuICAgICAgICBsZXQgY29sb3JJbmZvID0ge1xuICAgICAgICAgICAgcjogcmdiWzBdLFxuICAgICAgICAgICAgZzogcmdiWzFdLFxuICAgICAgICAgICAgYjogcmdiWzJdLFxuICAgICAgICAgICAgYWxwaGE6IHJnYlszXVxuICAgICAgICB9O1xuICAgICAgICBsZXQgbmV3RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NvbG9yLXNlbGVjdGVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiBjb2xvckluZm9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb2xvciA9IGNvbG9ySW5mbztcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlY2VudCBjb2xvciBzd2F0Y2hlc1xuICAgICAgICBsZXQgY3VycmVudFN3YXRjaFNlbGVjdGlvbiA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcucmVjZW50LWNvbG9yLWl0ZW0uc2VsZWN0ZWQnKTtcbiAgICAgICAgaWYoY3VycmVudFN3YXRjaFNlbGVjdGlvbil7XG4gICAgICAgICAgICBjdXJyZW50U3dhdGNoU2VsZWN0aW9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGByZ2JhKCR7Y29sb3JJbmZvLnJ9LCAke2NvbG9ySW5mby5nfSwgJHtjb2xvckluZm8uYn0sICR7Y29sb3JJbmZvLmFscGhhfSlgO1xuICAgICAgICAgICAgY3VycmVudFN3YXRjaFNlbGVjdGlvbi5zZWxlY3RlZENvbG9yID0gY29sb3JJbmZvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25UcmFuc3BhcmVuY3lDaGFuZ2UoZXZlbnQpe1xuICAgICAgICBsZXQgY29tbWFuZCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwic2VsZWN0b3ItY29tbWFuZFwiKTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBjb3JyZXNwb25kaW5nIHRyYW5zcGFyZW5jeSAtIHRleHQgb3IgYmFja2dyb3VuZFxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gd2hhdCB0aGlzIGNvbG9yIHdoZWVsIGlzIHNldHVwIHRvIHVwZGF0ZVxuICAgICAgICBsZXQgcHJvcE5hbWUgPSBcImJhY2tncm91bmQtdHJhbnNwYXJlbmN5XCI7XG4gICAgICAgIGlmKGNvbW1hbmQgPT09IFwidGV4dC1jb2xvclwiKXtcbiAgICAgICAgICAgIHByb3BOYW1lID0gXCJ0ZXh0LXRyYW5zcGFyZW5jeVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudERldGFpbCA9IHtwcm9wTmFtZTogcHJvcE5hbWUsIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWV9O1xuICAgICAgICBsZXQgbmV3RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3RyYW5zcGFyZW5jeS1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiBldmVudERldGFpbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgfVxuXG4gICAgb25JdGVtQ2xpY2soZXZlbnQpe1xuICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaXMgbm90IHRoZSBjdXJyZW50bHlcbiAgICAgICAgLy8gc2VsZWN0ZWQgcmVjZW50IGl0ZW0sIGZpbmQgdGhlIG9uZSB0aGF0IGlzXG4gICAgICAgIC8vIGFuZCB0b2dnbGUgdGhlIHNlbGVjdGlvbiBjbGFzcywgdGhlbiB0b2dnbGVcbiAgICAgICAgLy8gdGhpcyBpdGVtJ3Mgc2VsZWN0aW9uIGNsYXNzLlxuICAgICAgICBpZighZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSl7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCcucmVjZW50LWNvbG9yLWl0ZW0uc2VsZWN0ZWQnKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihldmVudC50YXJnZXQuc2VsZWN0ZWRDb2xvcil7XG4gICAgICAgICAgICBsZXQgbmV3RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NvbG9yLXNlbGVjdGVkJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDogZXZlbnQudGFyZ2V0LnNlbGVjdGVkQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQmFyTW91c2VEb3duKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkJhck1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uQmFyTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25CYXJNb3VzZVVwKGV2ZW50KXtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkJhck1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uQmFyTW91c2VVcCk7XG4gICAgfVxuXG4gICAgb25CYXJNb3VzZU1vdmUoZXZlbnQpe1xuICAgICAgICBsZXQgbmV3VG9wID0gdGhpcy5vZmZzZXRUb3AgKyBldmVudC5tb3ZlbWVudFk7XG4gICAgICAgIGxldCBuZXdMZWZ0ID0gdGhpcy5vZmZzZXRMZWZ0ICsgZXZlbnQubW92ZW1lbnRYO1xuICAgICAgICB0aGlzLnN0eWxlLnRvcCA9IGAke25ld1RvcH1weGA7XG4gICAgICAgIHRoaXMuc3R5bGUubGVmdCA9IGAke25ld0xlZnR9cHhgO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoZXZlbnQpe1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIF9kcmF3V2hlZWwoKXtcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGRyYXdDaXJjbGUoY3R4LCB0aGlzLmNhbnZhcy53aWR0aCAvIDIpO1xuICAgIH1cbn07XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2NvbG9yLXdoZWVsJywgQ29sb3JXaGVlbFdpZGdldCk7XG5cbi8qKiBVdGlsaXR5IEZ1bmN0aW9ucyAqKi9cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb21cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AYmFudGljL2hhbmQtY29kaW5nLWEtY29sb3Itd2hlZWwtd2l0aC1jYW52YXMtNzgyNTZjOWQ3ZDQzXG5jb25zdCBkcmF3Q2lyY2xlID0gKGN0eCwgcmFkaXVzKSA9PiB7XG4gICAgbGV0IGltYWdlID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgyKnJhZGl1cywgMipyYWRpdXMpO1xuICAgIGxldCBkYXRhID0gaW1hZ2UuZGF0YTtcblxuICAgIGZvciAobGV0IHggPSAtcmFkaXVzOyB4IDwgcmFkaXVzOyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IC1yYWRpdXM7IHkgPCByYWRpdXM7IHkrKykge1xuXG4gICAgICAgICAgICBsZXQgW3IsIHBoaV0gPSB4eTJwb2xhcih4LCB5KTtcblxuICAgICAgICAgICAgaWYgKHIgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGFsbCAoeCx5KSBjb29yZGluYXRlcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaXJjbGVcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRlZyA9IHJhZDJkZWcocGhpKTtcblxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgc3RhcnRpbmcgaW5kZXggb2YgdGhpcyBwaXhlbCBpbiB0aGUgaW1hZ2UgZGF0YSBhcnJheS5cbiAgICAgICAgICAgIGxldCByb3dMZW5ndGggPSAyKnJhZGl1cztcbiAgICAgICAgICAgIGxldCBhZGp1c3RlZFggPSB4ICsgcmFkaXVzOyAvLyBjb252ZXJ0IHggZnJvbSBbLTUwLCA1MF0gdG8gWzAsIDEwMF0gKHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW1hZ2UgZGF0YSBhcnJheSlcbiAgICAgICAgICAgIGxldCBhZGp1c3RlZFkgPSB5ICsgcmFkaXVzOyAvLyBjb252ZXJ0IHkgZnJvbSBbLTUwLCA1MF0gdG8gWzAsIDEwMF0gKHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW1hZ2UgZGF0YSBhcnJheSlcbiAgICAgICAgICAgIGxldCBwaXhlbFdpZHRoID0gNDsgLy8gZWFjaCBwaXhlbCByZXF1aXJlcyA0IHNsb3RzIGluIHRoZSBkYXRhIGFycmF5XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAoYWRqdXN0ZWRYICsgKGFkanVzdGVkWSAqIHJvd0xlbmd0aCkpICogcGl4ZWxXaWR0aDtcblxuICAgICAgICAgICAgbGV0IGh1ZSA9IGRlZztcbiAgICAgICAgICAgIGxldCBzYXR1cmF0aW9uID0gciAvIHJhZGl1cztcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IDEuMDtcblxuICAgICAgICAgICAgbGV0IFtyZWQsIGdyZWVuLCBibHVlXSA9IGhzdjJyZ2IoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBsZXQgYWxwaGEgPSAyNTU7XG5cbiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gcmVkO1xuICAgICAgICAgICAgZGF0YVtpbmRleCsxXSA9IGdyZWVuO1xuICAgICAgICAgICAgZGF0YVtpbmRleCsyXSA9IGJsdWU7XG4gICAgICAgICAgICBkYXRhW2luZGV4KzNdID0gYWxwaGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbn07XG5cbi8vIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb206XG4vLyBodHRwczovL21lZGl1bS5jb20vQGJhbnRpYy9oYW5kLWNvZGluZy1hLWNvbG9yLXdoZWVsLXdpdGgtY2FudmFzLTc4MjU2YzlkN2Q0M1xuY29uc3QgeHkycG9sYXIgPSAoeCwgeSkgPT4ge1xuICAgIGxldCByID0gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG4gICAgbGV0IHBoaSA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgcmV0dXJuIFtyLCBwaGldO1xufTtcblxuLy8gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AYmFudGljL2hhbmQtY29kaW5nLWEtY29sb3Itd2hlZWwtd2l0aC1jYW52YXMtNzgyNTZjOWQ3ZDQzc1xuY29uc3QgcmFkMmRlZyA9IChyYWQpID0+IHtcbiAgICByZXR1cm4gKChyYWQgKyBNYXRoLlBJKSAvICgyICogTWF0aC5QSSkpICogMzYwO1xufTtcblxuLy8gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AYmFudGljL2hhbmQtY29kaW5nLWEtY29sb3Itd2hlZWwtd2l0aC1jYW52YXMtNzgyNTZjOWQ3ZDQzXG5jb25zdCBoc3YycmdiID0gKGh1ZSwgc2F0dXJhdGlvbiwgdmFsdWUpID0+IHtcbiAgICBsZXQgY2hyb21hID0gdmFsdWUgKiBzYXR1cmF0aW9uO1xuICAgIGxldCBodWUxID0gaHVlIC8gNjA7XG4gICAgbGV0IHggPSBjaHJvbWEgKiAoMS0gTWF0aC5hYnMoKGh1ZTEgJSAyKSAtIDEpKTtcbiAgICBsZXQgcjEsIGcxLCBiMTtcbiAgICBpZiAoaHVlMSA+PSAwICYmIGh1ZTEgPD0gMSkge1xuICAgICAgICAoW3IxLCBnMSwgYjFdID0gW2Nocm9tYSwgeCwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaHVlMSA+PSAxICYmIGh1ZTEgPD0gMikge1xuICAgICAgICAoW3IxLCBnMSwgYjFdID0gW3gsIGNocm9tYSwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaHVlMSA+PSAyICYmIGh1ZTEgPD0gMykge1xuICAgICAgICAoW3IxLCBnMSwgYjFdID0gWzAsIGNocm9tYSwgeF0pO1xuICAgIH0gZWxzZSBpZiAoaHVlMSA+PSAzICYmIGh1ZTEgPD0gNCkge1xuICAgICAgICAoW3IxLCBnMSwgYjFdID0gWzAsIHgsIGNocm9tYV0pO1xuICAgIH0gZWxzZSBpZiAoaHVlMSA+PSA0ICYmIGh1ZTEgPD0gNSkge1xuICAgICAgICAoW3IxLCBnMSwgYjFdID0gW3gsIDAsIGNocm9tYV0pO1xuICAgIH0gZWxzZSBpZiAoaHVlMSA+PSA1ICYmIGh1ZTEgPD0gNikge1xuICAgICAgICAoW3IxLCBnMSwgYjFdID0gW2Nocm9tYSwgMCwgeF0pO1xuICAgIH1cblxuICAgIGxldCBtID0gdmFsdWUgLSBjaHJvbWE7XG4gICAgbGV0IFtyLGcsYl0gPSBbcjErbSwgZzErbSwgYjErbV07XG5cbiAgICAvLyBDaGFuZ2UgcixnLGIgdmFsdWVzIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxuICAgIHJldHVybiBbMjU1KnIsMjU1KmcsMjU1KmJdO1xufTtcblxuY29uc3QgZ2V0UG9zaXRpb25Gcm9tRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGxldCBvZmZzZXRYID0gdGFyZ2V0Lm9mZnNldExlZnQ7XG4gICAgbGV0IG9mZnNldFkgPSB0YXJnZXQub2Zmc2V0VG9wO1xuICAgIGxldCBjaGVjayA9IHRhcmdldC5vZmZzZXRQYXJlbnQ7XG4gICAgd2hpbGUoY2hlY2spe1xuICAgICAgICBvZmZzZXRYICs9IGNoZWNrLm9mZnNldExlZnQ7XG4gICAgICAgIG9mZnNldFkgKz0gY2hlY2sub2Zmc2V0VG9wO1xuICAgICAgICBjaGVjayA9IGNoZWNrLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIG9mZnNldFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBvZmZzZXRZXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgZ2V0UkdCRnJvbUltYWdlRGF0YSA9ICh4LCB5LCB3aWR0aCwgZGF0YSkgPT4ge1xuICAgIGxldCBpbmRleCA9ICh5ICogd2lkdGggKyB4KSAqIDQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZGF0YVtpbmRleF0sIC8vIHJcbiAgICAgICAgZGF0YVtpbmRleCArIDFdLCAvLyBnXG4gICAgICAgIGRhdGFbaW5kZXggKyAyXSwgLy8gYlxuICAgICAgICBkYXRhW2luZGV4ICsgM10gLy8gYWxwaGFcbiAgICBdO1xufTtcblxuZXhwb3J0IHtcbiAgICBDb2xvcldoZWVsV2lkZ2V0LFxuICAgIENvbG9yV2hlZWxXaWRnZXQgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogRHJhd2luZ1ZpZXdcbiAqIEV4cGVyaW1lbnRhbC5cbiAqIFRoaXMgaXMgc3RpbGwgYSBwdXJlIHdlYmNvbXBvbmVudCBhbmQgaXMgbm90XG4gKiBsaW5rZWQgYXQgYWxsIHRvIFNpbXBsZVRhbGsgeWV0LlxuICpcbiAqL1xuaW1wb3J0IHtQYXJ0Vmlld30gZnJvbSAnLi4vUGFydFZpZXcuanMnO1xuaW1wb3J0IHtQZW5jaWxUb29sfSBmcm9tICcuL1BlbmNpbFRvb2wuanMnO1xuaW1wb3J0IHtFcmFzZXJUb29sfSBmcm9tICcuL0VyYXNlclRvb2wuanMnO1xuaW1wb3J0IHtDb2xvclBpY2tlclRvb2x9IGZyb20gJy4vQ29sb3JQaWNrZXJUb29sLmpzJztcblxuY29uc3QgaGFsb0J1dHRvblNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci10b29sXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk03IDEwaDN2LTNsLTMuNSAtMy41YTYgNiAwIDAgMSA4IDhsNiA2YTIgMiAwIDAgMSAtMyAzbC02LTZhNiA2IDAgMCAxIC04IC04bDMuNSAzLjVcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAjdG9vbC1idXR0b25zIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiBjYWxjKDEwMCUgKyA1cHgpO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICB9XG4gICAgOmhvc3QoLnNob3ctYm9yZGVyKXtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gICAgfVxuICAgIDpob3N0KDpub3QoW21vZGU9XCJkcmF3aW5nXCJdKSkgPiAjdG9vbC1idXR0b25zIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuPGNhbnZhcz48L2NhbnZhcyA+XG48ZGl2IGlkPVwidG9vbC1idXR0b25zXCI+XG48c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbmA7XG5cbmNsYXNzIERyYXdpbmdWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgc2hhZG93IGRvbVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyVG9vbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5pc0N1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gICAgICAgIHRoaXMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTGVhdmUgPSB0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGFsb1Jlc2l6ZSA9IHRoaXMub25IYWxvUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdEN1c3RvbUhhbG9CdXR0b24gPSB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlTW9kZSA9IHRoaXMudG9nZ2xlTW9kZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFmdGVyRHJhd0FjdGlvbiA9IHRoaXMuYWZ0ZXJEcmF3QWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVzdG9yZUltYWdlRnJvbU1vZGVsID0gdGhpcy5yZXN0b3JlSW1hZ2VGcm9tTW9kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFByb3BIYW5kbGVycyA9IHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb2RlQ2hhbmdlZCA9IHRoaXMubW9kZUNoYW5nZWQuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBTZXR1cCBwcm9wIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQcm9wSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb3BIYW5kbGVycygpe1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnbW9kZScsIHRoaXMubW9kZUNoYW5nZWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnaW1hZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW1hZ2VCaXRzID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZUltYWdlRnJvbU1vZGVsKGltYWdlQml0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnc2hvdy1ib3JkZXInLCAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZih2YWwpe1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc2hvdy1ib3JkZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdzaG93LWJvcmRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ3dpZHRoJywgKHZhbCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogd2hhdCB3ZSB3YW50IGlzIHRoZSBjYWxjdWxhdGVkIENTUywgbm90IHRoZSBTVCBwYXJ0IHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJjc3NTdHlsZVwiKTtcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvdy5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBjc3NTdHlsZS53aWR0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnaGVpZ2h0JywgKHZhbCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogd2hhdCB3ZSB3YW50IGlzIHRoZSBjYWxjdWxhdGVkIENTUywgbm90IHRoZSBTVCBwYXJ0IHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICBsZXQgY3NzU3R5bGUgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQodGhpcy5tb2RlbCwgXCJjc3NTdHlsZVwiKTtcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvdy5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgY3NzU3R5bGUuaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kZUNoYW5nZWQodmFsdWUpe1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kZScsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcblxuICAgICAgICAvLyBTZXQgYW5kIHN0b3JlIHRoZSBkcmF3aW5nIGNvbnRleHRcbiAgICAgICAgdGhpcy5kcmF3aW5nQ29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgLy8gSWYgSSBkb24ndCBoYXZlIHRoZSBkZWZhdWx0IHRvb2xzLCBhZGRcbiAgICAgICAgLy8gdGhlbSBhcyByZWFsIGRvbSBjaGlsZHJlbiBub3dcbiAgICAgICAgbGV0IHBlbmNpbENoaWxkID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdwZW5jaWwtdG9vbCcpO1xuICAgICAgICBpZighcGVuY2lsQ2hpbGQpe1xuICAgICAgICAgICAgbGV0IG5ld1BlbmNpbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BlbmNpbC10b29sJyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChuZXdQZW5jaWwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcmFzZXJDaGlsZCA9IHRoaXMucXVlcnlTZWxlY3RvcignZXJhc2VyLXRvb2wnKTtcbiAgICAgICAgaWYoIWVyYXNlckNoaWxkKXtcbiAgICAgICAgICAgIGxldCBuZXdFcmFzZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlcmFzZXItdG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQobmV3RXJhc2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2xvclBpY2tlckNoaWxkID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdjb2xvci1waWNrZXItdG9vbCcpO1xuICAgICAgICBpZighY29sb3JQaWNrZXJDaGlsZCl7XG4gICAgICAgICAgICBsZXQgbmV3Q29sb3JQaWNrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xvci1waWNrZXItdG9vbCcpO1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGlzIGEgdG90YWwgaGFjayBzaW5jZSBkcmF3aW5nIGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHN0eWxlcyBhdCB0aGUgbW9tZW50XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChuZXdDb2xvclBpY2tlcik7XG4gICAgICAgICAgICBuZXdDb2xvclBpY2tlci5jb2xvcldoZWVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZGl2I29wdGlvbnMnKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB0aGlzLmNvbG9yUGlja2VyVG9vbCA9IG5ld0NvbG9yUGlja2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMuaGFsb0J1dHRvbil7XG4gICAgICAgICAgICB0aGlzLmluaXRDdXN0b21IYWxvQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckRpc2Nvbm5lY3RlZCgpe1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIC8vIHNldHVwIHRoZSBjYW52YXMgaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICAvLyBOb3RlOiB3aGF0IHdlIHdhbnQgaXMgdGhlIGNhbGN1bGF0ZWQgQ1NTLCBub3QgdGhlIFNUIHBhcnQgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgbGV0IGNzc1N0eWxlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwiY3NzU3R5bGVcIik7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvdy5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBjc3NTdHlsZS5oZWlnaHQpO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgY3NzU3R5bGUud2lkdGgpO1xuICAgICAgICBsZXQgY3VycmVudEltYWdlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdpbWFnZSdcbiAgICAgICAgKTtcbiAgICAgICAgaWYoY3VycmVudEltYWdlKXtcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZUltYWdlRnJvbU1vZGVsKGN1cnJlbnRJbWFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5pdGlhbFNob3dCb3JkZXIgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ3Nob3ctYm9yZGVyJ1xuICAgICAgICApO1xuICAgICAgICBpZihpbml0aWFsU2hvd0JvcmRlcil7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Nob3ctYm9yZGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlRG93bihldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmKCF0aGlzLmluRHJhd2luZ01vZGUpIHtcbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIG1vdXNlVXAgY29tbWFuZCBtZXNzYWdlIHRvIHNlbGZcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ21vdXNlVXAnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZTogdHJ1ZSAvLyBTaG91bGQgaWdub3JlIGlmIFN5c3RlbSBETlVcbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlVG9vbCA9IHRoaXMucXVlcnlTZWxlY3RvcignW3JvbGU9XCJ0b29sXCJdW2FjdGl2ZT1cInRydWVcIl0nKTtcbiAgICAgICAgaWYoIXRoaXMuYWN0aXZlVG9vbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0N1cnJlbnRseURyYXdpbmcgPSB0cnVlO1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3cucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlVG9vbC5zdGFydChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmFjdGl2ZVRvb2wgJiYgdGhpcy5pbkRyYXdpbmdNb2RlKXtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVG9vbC5vbk1vdmUoXG4gICAgICAgICAgICAgICAgZXZlbnQub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICBldmVudC5vZmZzZXRZXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKHRoaXMubW9kZWwsIFwid2FudHMtbW92ZVwiKSl7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6ICdtb3ZlJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFldXG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91c2VVcChldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LnNoaWZ0S2V5KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmFjdGl2ZVRvb2wgJiYgdGhpcy5pbkRyYXdpbmdNb2RlICYmIHRoaXMuaXNDdXJyZW50bHlEcmF3aW5nKXtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVG9vbC5lbmQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgICAgICB0aGlzLmFmdGVyRHJhd0FjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvdy5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICB9XG5cblxuICAgIG9uTW91c2VMZWF2ZShldmVudCl7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBsZWZ0IHRoZSBhcmVhXG4gICAgICAgIC8vIHdoaWxlIGRyYXdpbmcuIFNvIGNhbGwgdGhlIGFjdGl2ZVRvb2wnc1xuICAgICAgICAvLyBlbmQgbWV0aG9kXG4gICAgICAgIHRoaXMuYWN0aXZlVG9vbC5lbmQoXG4gICAgICAgICAgICBldmVudC5vZmZzZXRYLFxuICAgICAgICAgICAgZXZlbnQub2Zmc2V0WVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmlzQ3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFmdGVyRHJhd0FjdGlvbigpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBvbkhhbG9SZXNpemUobW92ZW1lbnRYLCBtb3ZlbWVudFkpe1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICBsZXQgY3VycmVudEltYWdlID0gdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5nZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICdpbWFnZSdcbiAgICAgICAgKTtcbiAgICAgICAgLy8gY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoICsgbW92ZW1lbnRYO1xuICAgICAgICAvLyBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCArIG1vdmVtZW50WTtcbiAgICAgICAgbGV0IG5ld1dpZHRoID0gY2FudmFzLndpZHRoICsgbW92ZW1lbnRYO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gY2FudmFzLmhlaWdodCArIG1vdmVtZW50WTtcbiAgICAgICAgaWYobmV3V2lkdGggJiYgbmV3SGVpZ2h0KXtcbiAgICAgICAgICAgIC8vIHRoaXMuc3R5bGUud2lkdGggPSBgJHtuZXdXaWR0aH1weGA7XG4gICAgICAgICAgICAvLyB0aGlzLnN0eWxlLmhlaWdodCA9IGAke25ld0hlaWdodH1weGA7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3RvcmVJbWFnZUZyb21Nb2RlbChjdXJyZW50SW1hZ2UpO1xuICAgIH1cblxuICAgIGFmdGVyRHJhd0FjdGlvbigpe1xuICAgICAgICAvLyBFbmNvZGUgY2FudmFzIGNvbnRlbnRzIGFzIGJhc2U2NCBwbmdcbiAgICAgICAgLy8gYW5kIHNldCB0byBtb2RlbCdzIGltYWdlIHByb3BlcnR5XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgY2FudmFzLnRvRGF0YVVSTCgpXG4gICAgICAgICk7XG4gICAgICAgIC8vdGhpcy5zZXRBdHRyaWJ1dGUoXCJtb2RlXCIsIFwiXCIpO1xuICAgIH1cblxuICAgIHJlc3RvcmVJbWFnZUZyb21Nb2RlbChiYXNlNjRJbWFnZURhdGEpe1xuICAgICAgICAvLyBDbGVhciBhbmQgZHJhdyB0aGUgaW1hZ2UgdG8gcmVzdG9yZSB0b1xuICAgICAgICAvLyB0aGUgY2FudmFzXG4gICAgICAgIGlmKGJhc2U2NEltYWdlRGF0YSl7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGxldCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gYmFzZTY0SW1hZ2VEYXRhO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGJvcmRlciB0byBoaWRlXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAnc2hvdy1ib3JkZXInLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdEN1c3RvbUhhbG9CdXR0b24oKXtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5pZCA9IFwiaGFsby1kcmF3aW5nLXRvZ2dsZS1tb2RlXCI7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdoYWxvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLmhhbG9CdXR0b24uaW5uZXJIVE1MID0gaGFsb0J1dHRvblNWRztcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI2cHhcIjtcbiAgICAgICAgdGhpcy5oYWxvQnV0dG9uLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdib3R0b20tcm93Jyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ1RvZ2dsZSBkcmF3aW5nIHRvb2xzJyk7XG4gICAgICAgIHRoaXMuaGFsb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlTW9kZSk7XG4gICAgfVxuXG4gICAgb3BlbkhhbG8oKXtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdC4gSGVyZSB3ZSBhZGQgYSBjdXN0b20gYnV0dG9uXG4gICAgICAgIC8vIHdoZW4gc2hvd2luZy5cbiAgICAgICAgbGV0IGZvdW5kSGFsbyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzdC1oYWxvJyk7XG4gICAgICAgIGlmKCFmb3VuZEhhbG8pe1xuICAgICAgICAgICAgZm91bmRIYWxvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3QtaGFsbycpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGZvdW5kSGFsbyk7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRIYWxvLmFwcGVuZCh0aGlzLmhhbG9CdXR0b24pO1xuICAgIH1cblxuICAgIHRvZ2dsZU1vZGUoKXtcbiAgICAgICAgbGV0IGN1cnJlbnRNb2RlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21vZGUnKTtcbiAgICAgICAgbGV0IG5leHRNb2RlID0gJ3ZpZXdpbmcnOyAvLyBCeSBkZWZhdWx0LCBzZXQgdG8gdmlld2luZ1xuICAgICAgICBsZXQgaXNFbXB0eSA9ICghY3VycmVudE1vZGUgfHwgY3VycmVudE1vZGUgPT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRNb2RlID09IFwiXCIpO1xuICAgICAgICBpZihjdXJyZW50TW9kZSA9PSAndmlld2luZycgfHwgaXNFbXB0eSl7XG4gICAgICAgICAgICBuZXh0TW9kZSA9ICdkcmF3aW5nJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLnNldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgJ21vZGUnLFxuICAgICAgICAgICAgbmV4dE1vZGVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgaW5EcmF3aW5nTW9kZSgpe1xuICAgICAgICBpZighdGhpcy5tb2RlbCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1vZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kZScpO1xuICAgICAgICBpZihtb2RlID09ICdkcmF3aW5nJyl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBEcmF3aW5nVmlldyxcbiAgICBEcmF3aW5nVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBFcmFzZXJUb29sXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBwcm92aWRlIGVyYXNlci1saWtlIGZ1bmN0aW9uYWxpdHkgb25cbiAqIG15IHBhcmVudCBlbGVtZW50J3Mgc2hhZG93IGNhbnZhcy5cbiAqIEkgYW0gc3BlY2lmaWNhbGx5IGRlc2lnbmVkIGZvciB1c2UgYXMgYVxuICogY2hpbGQgb2YgRHJhd2luZ1ZpZXdcbiAqL1xuY29uc3QgZXJhc2VyU1ZHID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWVyYXNlclwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNMTkgMTloLTExbC00IC00YTEgMSAwIDAgMSAwIC0xLjQxbDEwIC0xMGExIDEgMCAwIDEgMS40MSAwbDUgNWExIDEgMCAwIDEgMCAxLjQxbC05IDlcIiAvPlxuICA8bGluZSB4MT1cIjE4XCIgeTE9XCIxMi4zXCIgeDI9XCIxMS43XCIgeTI9XCI2XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgZXJhc2VyVG9vbFRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA2cHg7XG4gICAgfVxuICAgICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIC0tYWN0aXZlLWNvbG9yOiBibGFjaztcbiAgICAgICAgLS1pbmFjdGl2ZS1jb2xvcjogcmdiKDE3MCwgMTcwLCAxNzApO1xuICAgICAgICAtLWhvdmVyLWNvbG9yOiByZ2IoMTQwLCAxNDAsIDE0MCk7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBib3JkZXItd2lkdGg6IDFweDtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1pbmFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgIDpob3N0KFthY3RpdmU9XCJ0cnVlXCJdKSA+ICN0b29sLWJ1dHRvbiB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgfVxuICAgICNicnVzaGVzLWNvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgI2JydXNoLWFkanVzdGVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBib3JkZXItd2lkdGg6IDFweDtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICAjYnJ1c2gtc2xpZGVyLFxuICAgICNicnVzaC1udW1iZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAjYnJ1c2gtbnVtYmVyIHtcbiAgICAgICAgbWF4LXdpZHRoOiAzcmVtO1xuICAgIH1cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiAjYnJ1c2hlcy1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwidG9vbC1idXR0b25cIj5cbiAgJHtlcmFzZXJTVkd9XG48L2Rpdj5cbjxkaXYgaWQ9XCJicnVzaGVzLWNvbnRhaW5lclwiPlxuICA8ZGl2IGlkPVwiYnJ1c2gtYWRqdXN0ZXJcIj5cbiAgICA8aW5wdXQgaWQ9XCJicnVzaC1zbGlkZXJcIiB0eXBlPVwicmFuZ2VcIiBtaW49XCIxXCIgbWF4PVwiMTAwXCIgc3RlcD1cIjFcIj5cbiAgICA8aW5wdXQgaWQ9XCJicnVzaC1udW1iZXJcIiB0eXBlPVwibnVtYmVyXCI+XG4gIDwvZGl2PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBFcmFzZXJUb29sIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgc2hhZG93IGRvbS4gVGhpcyB0b29sIHdpbGxcbiAgICAgICAgLy8gZGlzcGxheSBpdHNlbGYgYXMgYSBidXR0b24gdGhhdCBjYW5cbiAgICAgICAgLy8gYmUgdG9nZ2xlZC5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gZXJhc2VyVG9vbFRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5zaGFkb3cuYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZHJhd2luZyBjb250ZXh0IGlzIG51bGwuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBzZXQgaWYgYW5kIHdoZW4gdGhpcyB0b29sIGlzXG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byBhIHBhcmVudCBlbGVtZW50IHRoYXQgaGFzIGEgY29udGV4dFxuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG5cbiAgICAgICAgLy8gQmluZCBjb21wb25lbnQgbWV0aG9kc1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUgPSB0aGlzLnRvZ2dsZUFjdGl2ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcyA9IHRoaXMuc2V0Q29udGV4dEZyb21BdHRyaWJ1dGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UgPSB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZSA9IHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLmhhc0F0dHJpYnV0ZSgnd2lkdGgnKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMucGFyZW50RWxlbWVudC5kcmF3aW5nQ29udGV4dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBJIGFtIHRoZSBvbmx5IHRvb2wgaW4gbXkgcGFyZW50LFxuICAgICAgICAgICAgICAgIC8vIHNldCBteXNlbGYgdG8gYWN0aXZlXG4gICAgICAgICAgICAgICAgbGV0IHNpYmxpbmdUb29scyA9IHRoaXMucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xcIl0nKTtcbiAgICAgICAgICAgICAgICBpZihzaWJsaW5nVG9vbHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndG9vbC1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVBY3RpdmUpO1xuICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYnJ1c2gtc2xpZGVyJyk7XG4gICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2JydXNoLW51bWJlcicpO1xuICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGlzIGN1cnJlbnRseSBhIHdpZHRoIHNldCxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2xpZGVyIGFuZCBudW1iZXIgaW5wdXQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIGxldCBjdXJyZW50V2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRXaWR0aCl7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlci52YWx1ZSA9IHBhcnNlSW50KGN1cnJlbnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LnZhbHVlID0gcGFyc2VJbnQoY3VycmVudFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2ZSk7XG4gICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlKTtcbiAgICB9XG5cbiAgICBzdGFydCh4LCB5KXtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5jYWNoZWRTdHJva2VTdHlsZSA9IHRoaXMuY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBvbk1vdmUoeCwgeSl7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgZW5kKHgsIHkpe1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNhY2hlZFN0cm9rZVN0eWxlO1xuICAgIH1cblxuICAgIHNldENvbnRleHRGcm9tQXR0cmlidXRlcygpe1xuICAgICAgICAvLyBsaW5lIGNhcFxuICAgICAgICBsZXQgbGluZUNhcCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsaW5lLWNhcCcpO1xuICAgICAgICBpZihsaW5lQ2FwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUNhcCA9IFwicm91bmRcIjsgLy8gZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGluZSBqb2luXG4gICAgICAgIGxldCBsaW5lSm9pbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsaW5lLWpvaW4nKTtcbiAgICAgICAgaWYobGluZUpvaW4pe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGluZSB3aWR0aFxuICAgICAgICBsZXQgbGluZVdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICAgIGlmKGxpbmVXaWR0aCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSBwYXJzZUludChsaW5lV2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gNjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCl7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgJ2xpbmUtam9pbicsXG4gICAgICAgICAgICAnbGluZS1jYXAnXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbCwgbmV3VmFsKXtcbiAgICAgICAgaWYobmFtZSA9PSAnd2lkdGgnKXtcbiAgICAgICAgICAgIGlmKHRoaXMuYnJ1c2hTbGlkZXIpe1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIudmFsdWUgPSBwYXJzZUludChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5icnVzaE51bWJlcklucHV0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoTnVtYmVySW5wdXQudmFsdWUgPSBwYXJzZUludChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UoZXZlbnQpe1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cblxuICAgIGhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UoZXZlbnQpe1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cblxuICAgIHRvZ2dsZUFjdGl2ZShldmVudCl7XG4gICAgICAgIGxldCBpc0FjdGl2ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKTtcbiAgICAgICAgaWYoaXNBY3RpdmUgPT0gXCJ0cnVlXCIpe1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICdmYWxzZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QsIGZpbmQgYW55IG90aGVyIHRvb2xzIGluIG15IHBhcmVudFxuICAgICAgICAgICAgLy8gZWxlbWVudCBhbmQgZGVhY3RpdmF0ZSB0aGVtLlxuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpID09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG9vbCB0byBiZSBhY3RpdmVcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgfVxufTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VyYXNlci10b29sJywgRXJhc2VyVG9vbCk7XG5cbmV4cG9ydCB7XG4gICAgRXJhc2VyVG9vbCxcbiAgICBFcmFzZXJUb29sIGFzIGRlZmF1bHRcbn07XG4iLCIvKipcbiAqIFBlbmNpbFRvb2xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJIHByb3ZpZGUgcGVuY2lsLWxpa2UgZHJhd2luZyBjYXBhYmlsaXR5XG4gKiBvbiB0aGUgc2hhZG93IGNhbnZhcyBvZiBteSBwYXJlbnQgZWxlbWVudC5cbiAqIEkgYW0gZXhwbGljaXRseSBkZXNpZ25lZCBmb3IgdXNlIHdpdGhcbiAqIERyYXdpbmdWaWV3XG4gKi9cbmNvbnN0IHBlbmNpbFNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1wZW5jaWxcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTQgMjBoNGwxMC41IC0xMC41YTEuNSAxLjUgMCAwIDAgLTQgLTRsLTEwLjUgMTAuNXY0XCIgLz5cbiAgPGxpbmUgeDE9XCIxMy41XCIgeTE9XCI2LjVcIiB4Mj1cIjE3LjVcIiB5Mj1cIjEwLjVcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBwZW5jaWxUZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuICAgIH1cbiAgICAjdG9vbC1idXR0b24ge1xuICAgICAgICAtLWFjdGl2ZS1jb2xvcjogYmxhY2s7XG4gICAgICAgIC0taW5hY3RpdmUtY29sb3I6IHJnYigxNzAsIDE3MCwgMTcwKTtcbiAgICAgICAgLS1ob3Zlci1jb2xvcjogcmdiKDE0MCwgMTQwLCAxNDApO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0taW5hY3RpdmUtY29sb3IpO1xuICAgICAgICBjb2xvcjogdmFyKC0taW5hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICA6aG9zdChbYWN0aXZlPVwidHJ1ZVwiXSkgPiAjdG9vbC1idXR0b24ge1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWFjdGl2ZS1jb2xvcik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1hY3RpdmUtY29sb3IpO1xuICAgIH1cbiAgICAjYnJ1c2hlcy1jb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA2cHg7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgICNicnVzaC1hZGp1c3RlciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWN0aXZlLWNvbG9yKTtcbiAgICB9XG4gICAgI2JydXNoLXNsaWRlcixcbiAgICAjYnJ1c2gtbnVtYmVyIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG4gICAgI2JydXNoLW51bWJlciB7XG4gICAgICAgIG1heC13aWR0aDogM3JlbTtcbiAgICB9XG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pID4gI2JydXNoZXMtY29udGFpbmVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBpZD1cInRvb2wtYnV0dG9uXCI+XG4gICR7cGVuY2lsU1ZHfVxuPC9kaXY+XG48ZGl2IGlkPVwiYnJ1c2hlcy1jb250YWluZXJcIj5cbiAgPGRpdiBpZD1cImJydXNoLWFkanVzdGVyXCI+XG4gICAgPGlucHV0IGlkPVwiYnJ1c2gtc2xpZGVyXCIgdHlwZT1cInJhbmdlXCIgbWluPVwiMVwiIG1heD1cIjEwMFwiIHN0ZXA9XCIxXCI+XG4gICAgPGlucHV0IGlkPVwiYnJ1c2gtbnVtYmVyXCIgdHlwZT1cIm51bWJlclwiPlxuICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxuY2xhc3MgUGVuY2lsVG9vbCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldCB1cCBzaGFkb3cgZG9tLiBUaGlzIHRvb2wgd2lsbFxuICAgICAgICAvLyBkaXNwbGF5IGl0c2VsZiBhcyBhIGJ1dHRvbiB0aGF0IGNhblxuICAgICAgICAvLyBiZSB0b2dnbGVkLlxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSBwZW5jaWxUZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuc2hhZG93LmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEZWZhdWx0IGRyYXdpbmcgY29udGV4dFxuICAgICAgICAvLyBpcyBudWxsLiBUaGlzIHdpbGwgYmUgc2V0XG4gICAgICAgIC8vIGlmIGFuZCB3aGVuIHRoaXMgdG9vbCBpc1xuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gYSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAvLyB0aGF0IGhhcyBhIGNvbnRleHRcbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuXG4gICAgICAgIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmQgPSB0aGlzLmVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlID0gdGhpcy50b2dnbGVBY3RpdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMgPSB0aGlzLnNldENvbnRleHRGcm9tQXR0cmlidXRlcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlID0gdGhpcy5oYW5kbGVCcnVzaFNsaWRlckNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UgPSB0aGlzLmhhbmRsZUJydXNoTnVtYmVySW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICAgICAgICBpZighdGhpcy5oYXNBdHRyaWJ1dGUoJ3dpZHRoJykpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsICc2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLnBhcmVudEVsZW1lbnQuZHJhd2luZ0NvbnRleHQpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5wYXJlbnRFbGVtZW50LmRyYXdpbmdDb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgSSBhbSB0aGUgb25seSB0b29sIGluIG15IHBhcmVudCxcbiAgICAgICAgICAgICAgICAvLyBzZXQgbXlzZWxmIHRvIGFjdGl2ZVxuICAgICAgICAgICAgICAgIGxldCBzaWJsaW5nVG9vbHMgPSB0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYoc2libGluZ1Rvb2xzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5idXR0b24gPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2wtYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlQWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2JydXNoLXNsaWRlcicpO1xuICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlci5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hTbGlkZXJDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0ID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdicnVzaC1udW1iZXInKTtcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hOdW1iZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlQnJ1c2hOdW1iZXJJbnB1dENoYW5nZSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBpcyBjdXJyZW50bHkgYSB3aWR0aCBzZXQsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNsaWRlciBhbmQgbnVtYmVyIGlucHV0IGFjY29yZGluZ2x5XG4gICAgICAgICAgICBsZXQgY3VycmVudFdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZihjdXJyZW50V2lkdGgpe1xuICAgICAgICAgICAgdGhpcy5icnVzaFNsaWRlci52YWx1ZSA9IHBhcnNlSW50KGN1cnJlbnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LnZhbHVlID0gcGFyc2VJbnQoY3VycmVudFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2ZSk7XG4gICAgICAgIHRoaXMuYnJ1c2hTbGlkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5oYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlKTtcbiAgICB9XG5cbiAgICBzdGFydCh4LCB5KXtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBvbk1vdmUoeCwgeSl7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgZW5kKHgsIHkpe1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0RnJvbUF0dHJpYnV0ZXMoKXtcbiAgICAgICAgLy8gbGluZSBjYXBcbiAgICAgICAgbGV0IGxpbmVDYXAgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGluZS1jYXAnKTtcbiAgICAgICAgaWYobGluZUNhcCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7IC8vIGRlZmF1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbmUgam9pblxuICAgICAgICBsZXQgbGluZUpvaW4gPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGluZS1qb2luJyk7XG4gICAgICAgIGlmKGxpbmVKb2luKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVKb2luID0gbGluZUpvaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbmUgd2lkdGhcbiAgICAgICAgbGV0IGxpbmVXaWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgICAgICBpZihsaW5lV2lkdGgpe1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gcGFyc2VJbnQobGluZVdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IDY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpe1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICdsaW5lLWpvaW4nLFxuICAgICAgICAgICAgJ2xpbmUtY2FwJ1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWwsIG5ld1ZhbCl7XG4gICAgICAgIGlmKG5hbWUgPT0gJ3dpZHRoJyl7XG4gICAgICAgICAgICBpZih0aGlzLmJydXNoU2xpZGVyKXtcbiAgICAgICAgICAgICAgICB0aGlzLmJydXNoU2xpZGVyLnZhbHVlID0gcGFyc2VJbnQobmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuYnJ1c2hOdW1iZXJJbnB1dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaE51bWJlcklucHV0LnZhbHVlID0gcGFyc2VJbnQobmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUJydXNoU2xpZGVyQ2hhbmdlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVCcnVzaE51bWJlcklucHV0Q2hhbmdlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG5cbiAgICB0b2dnbGVBY3RpdmUoZXZlbnQpe1xuICAgICAgICBsZXQgaXNBY3RpdmUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlJyk7XG4gICAgICAgIGlmKGlzQWN0aXZlID09IFwidHJ1ZVwiKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnZmFsc2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBmaW5kIGFueSBvdGhlciB0b29scyBpbiBteSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgYW5kIGRlYWN0aXZhdGUgdGhlbS5cbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbFwiXScpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdhY3RpdmUnKSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIHRvb2wgdG8gYmUgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aXZlJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3BlbmNpbC10b29sJywgUGVuY2lsVG9vbCk7XG5cbmV4cG9ydCB7XG4gICAgUGVuY2lsVG9vbCxcbiAgICBQZW5jaWxUb29sIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgRWRpdG9yVGFiIGZyb20gJy4vRWRpdG9yVGFiLmpzJztcbmltcG9ydCBFZGl0b3JQcm9wTGlzdCBmcm9tICcuL0VkaXRvclByb3BMaXN0LmpzJztcbmltcG9ydCBFZGl0b3JNZXNzZW5nZXIgZnJvbSAnLi9FZGl0b3JNZXNzZW5nZXIuanMnO1xuaW1wb3J0IEVkaXRvckN1c3RvbUxpc3QgZnJvbSAnLi9FZGl0b3JDdXN0b21MaXN0LmpzJztcbmltcG9ydCBFZGl0b3JTdWJwYXJ0c1BhbmUgZnJvbSAnLi9FZGl0b3JTdWJwYXJ0c1BhbmUuanMnO1xuaW1wb3J0IHBhcnRJY29ucyBmcm9tICcuLi8uLi91dGlscy9pY29ucy5qcyc7XG4vLyBQUkVBTUJMRVxuXG4vLyBBZGQgZWRpdG9yIHRhYiBlbGVtZW50XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3ItdGFiJywgRWRpdG9yVGFiKTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1wcm9wcy1saXN0JywgRWRpdG9yUHJvcExpc3QpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZWRpdG9yLWN1c3RvbS1saXN0JywgRWRpdG9yQ3VzdG9tTGlzdCk7XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3ItbWVzc2VuZ2VyJywgRWRpdG9yTWVzc2VuZ2VyKTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1zdWJwYXJ0cycsIEVkaXRvclN1YnBhcnRzUGFuZSk7XG5cbmNvbnN0IGNsb3NlQnV0dG9uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXhcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzllOWU5ZVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8bGluZSB4MT1cIjE4XCIgeTE9XCI2XCIgeDI9XCI2XCIgeTI9XCIxOFwiIC8+XG4gIDxsaW5lIHgxPVwiNlwiIHkxPVwiNlwiIHgyPVwiMThcIiB5Mj1cIjE4XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3Qgc2NyaXB0SWNvbiA9IGBcbjxzdmcgaWQ9J3NjcmlwdCcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1maWxlLWNvZGVcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gICAgPHBhdGggZD1cIk0xNCAzdjRhMSAxIDAgMCAwIDEgMWg0XCIgLz5cbiAgICA8cGF0aCBkPVwiTTE3IDIxaC0xMGEyIDIgMCAwIDEgLTIgLTJ2LTE0YTIgMiAwIDAgMSAyIC0yaDdsNSA1djExYTIgMiAwIDAgMSAtMiAyelwiIC8+XG4gICAgPHBhdGggZD1cIk0xMCAxM2wtMSAybDEgMlwiIC8+XG4gICAgPHBhdGggZD1cIk0xNCAxM2wxIDJsLTEgMlwiIC8+XG48L3N2Zz5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMDUlKTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDE1MG1zIGxpbmVhcjtcbiAgICAgICAgd2lkdGg6IDQwMHB4O1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBwYWRkaW5nOiA4cHg7XG4gICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAxMHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgfVxuICAgIFxuICAgIDpob3N0KC5vcGVuKXtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDAlKTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDE1MG1zIGxpbmVhcjtcbiAgICAgICAgei1pbmRleDogMTAwO1xuICAgIH1cblxuICAgIDpob3N0KDo6YWZ0ZXIpIHtcbiAgICAgICAgY29udGVudDogXCIgXCI7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgd2lkdGg6IDVweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IC0xMDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDBweCAzcHggMTBweCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuNik7XG4gICAgfVxuXG4gICAgOjpzbG90dGVkKGVkaXRvci1wcm9wcy1saXN0Om5vdCguc2hvdy1wYW5lKSksXG4gICAgOjpzbG90dGVkKGVkaXRvci1tZXNzZW5nZXI6bm90KC5zaG93LXBhbmUpKSxcbiAgICA6OnNsb3R0ZWQoZWRpdG9yLWN1c3RvbS1saXN0Om5vdCguc2hvdy1wYW5lKSksXG4gICAgOjpzbG90dGVkKGVkaXRvci1zdWJwYXJ0czpub3QoLnNob3ctcGFuZSkpe1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgICN0YWItYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuICAgIFxuICAgICNwYW5lLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgbWFyZ2luLXRvcDogMjBweDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAjaGVhZGVyLWFyZWEge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgfVxuXG4gICAgLmhlYWRlci1zaWRlIHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgbWFyZ2luLXRvcDogMjBweDtcbiAgICB9XG5cbiAgICAjZGlzcGxheS1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMzBweDtcbiAgICB9XG5cbiAgICAjaGVhZGVyLWFyZWEgaDMge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA4cHg7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA1cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMS43cmVtO1xuICAgIH1cblxuICAgICNoZWFkZXItbGVmdCA+IGlucHV0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwYWRkaW5nOiA0cHg7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxMDAsIDEwMCwgMTAwLCAwLjgpO1xuICAgICAgICBmb250LXNpemU6IDEuMXJlbTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLXJpZ2h0ID4gYnV0dG9uIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBmb250LXNpemU6IDAuODVlbTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLXJpZ2h0ID4gYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMyk7XG4gICAgfVxuXG4gICAgI2hlYWRlci1yaWdodCA+IGJ1dHRvbjphY3RpdmUge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuOCk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjIwLCAyMjAsIDIyMCk7XG4gICAgfVxuXG4gICAgI2hlYWRlci1yaWdodCA+IGJ1dHRvbiA+IHN2ZyB7XG4gICAgICAgIGhlaWdodDogMS4zZW07XG4gICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICB9XG5cbiAgICAjaGVhZGVyLWxlZnQge1xuICAgICAgICBtYXgtd2lkdGg6IDgwJTtcbiAgICB9XG5cbiAgICAjaGVhZGVyLWxlZnQgc3BhbiB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xuICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUpO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAjaWNvbi1kaXNwbGF5LWFyZWEge1xuICAgICAgICB3aWR0aDogMS43cmVtO1xuICAgICAgICBoZWlnaHQ6IDEuN3JlbTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNXB4O1xuICAgIH1cbiAgICAjaWNvbi1kaXNwbGF5LWFyZWEgPiBzdmcge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgICNjbG9zZS1idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDU7XG4gICAgICAgIHJpZ2h0OiA1O1xuICAgIH1cbiAgICAjY2xvc2UtYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwiY2xvc2UtYnV0dG9uXCI+JHtjbG9zZUJ1dHRvbn08L2Rpdj5cbjxkaXYgaWQ9XCJoZWFkZXItYXJlYVwiPlxuICAgIDxkaXYgaWQ9XCJoZWFkZXItbGVmdFwiIGNsYXNzPVwiaGVhZGVyLXNpZGVcIj5cbiAgICAgICAgPGRpdiBpZD1cImRpc3BsYXktYXJlYVwiPlxuICAgICAgICAgICAgPGRpdiBpZD1cImljb24tZGlzcGxheS1hcmVhXCI+PC9kaXY+XG4gICAgICAgICAgICA8aDM+PC9oMz48c3Bhbj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cInBhcnQtbmFtZS1pbnB1dFwiLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwiaGVhZGVyLXJpZ2h0XCIgY2xhc3M9XCJoZWFkZXItc2lkZVwiPlxuICAgICAgICA8YnV0dG9uIGlkPVwiZWRpdC1zY3JpcHQtYnV0dG9uXCI+XG4gICAgICAgICAgICAke3NjcmlwdEljb259XG4gICAgICAgICAgICA8c3Bhbj5FZGl0IFNjcmlwdDwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG48L2Rpdj5cbjxkaXYgaWQ9XCJ0YWItYXJlYVwiPlxuICAgIDxlZGl0b3ItdGFiIGFjdGl2ZT1cInRydWVcIiBuYW1lPVwicHJvcGVydGllc1wiPlByb3BlcnRpZXM8L2VkaXRvci10YWI+XG4gICAgPGVkaXRvci10YWIgbmFtZT1cImN1c3RvbVwiPkN1c3RvbTwvZWRpdG9yLXRhYj5cbiAgICA8ZWRpdG9yLXRhYiBuYW1lPVwibWVzc2VuZ2VyXCI+TWVzc2VuZ2VyPC9lZGl0b3ItdGFiPlxuICAgIDxlZGl0b3ItdGFiIG5hbWU9XCJzdWJwYXJ0c1wiPlN1YnBhcnRzPC9lZGl0b3ItdGFiPlxuPC9kaXY+XG48ZGl2IGlkPVwicGFuZS1hcmVhXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC9kaXY+XG5gO1xuXG5jbGFzcyBFZGl0b3IgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnRvZ2dsZSA9IHRoaXMudG9nZ2xlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbiA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2VudGVyT25FbGVtZW50ID0gdGhpcy5jZW50ZXJPbkVsZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bmRvQ2VudGVyT25FbGVtZW50ID0gdGhpcy51bmRvQ2VudGVyT25FbGVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlSGVhZGVyID0gdGhpcy51cGRhdGVIZWFkZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGVja0Zvck5hdmlnYXRpb24gPSB0aGlzLmNoZWNrRm9yTmF2aWdhdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlID0gdGhpcy5yZWNlaXZlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVGFiQWN0aXZhdGVkID0gdGhpcy5vblRhYkFjdGl2YXRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTmFtZUlucHV0Q2hhbmdlID0gdGhpcy5vbk5hbWVJbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRWRpdFNjcmlwdENsaWNrID0gdGhpcy5vbkVkaXRTY3JpcHRDbGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hZGRFdmVudExpc3RlbmVyKCd0YWItYWN0aXZhdGVkJywgdGhpcy5vblRhYkFjdGl2YXRlZCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjbG9zZS1idXR0b24nKS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgICAgICBsZXQgbmFtZUlucHV0ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgncGFydC1uYW1lLWlucHV0Jyk7XG4gICAgICAgICAgICBuYW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbk5hbWVJbnB1dENoYW5nZSk7XG5cbiAgICAgICAgICAgIGxldCBlZGl0U2NyaXB0QnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRpdC1zY3JpcHQtYnV0dG9uJyk7XG4gICAgICAgICAgICBlZGl0U2NyaXB0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkVkaXRTY3JpcHRDbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhYi1hY3RpdmF0ZWQnLCB0aGlzLm9uVGFiQWN0aXZhdGVkKTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnY2xvc2UtYnV0dG9uJykucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICB0aGlzLmNsb3NlXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgbGV0IG5hbWVJbnB1dCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3BhcnQtbmFtZS1pbnB1dCcpO1xuICAgICAgICBuYW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbk5hbWVJbnB1dENoYW5nZSk7XG5cbiAgICAgICAgbGV0IGVkaXRTY3JpcHRCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdlZGl0LXNjcmlwdC1idXR0b24nKTtcbiAgICAgICAgZWRpdFNjcmlwdEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25FZGl0U2NyaXB0Q2xpY2spO1xuICAgIH1cblxuICAgIHRvZ2dsZSgpe1xuICAgICAgICBpZih0aGlzLmlzT3Blbil7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW4oKXtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdvcGVuJyk7XG4gICAgICAgIHRoaXMuY2VudGVyT25FbGVtZW50KCk7XG4gICAgfVxuXG4gICAgY2xvc2UoKXtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdvcGVuJyk7XG4gICAgICAgIHRoaXMudW5kb0NlbnRlck9uRWxlbWVudCgpO1xuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucmVtb3ZlUHJvcGVydHlTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG4gICAgICAgIHRoaXMubW9kZWwuYWRkUHJvcGVydHlTdWJzY3JpYmVyKHRoaXMpO1xuXG4gICAgICAgIC8vIElmIHRoZSBpbmNvbWluZyBtb2RlbCBpcyBhIENhcmQgb3JcbiAgICAgICAgLy8gU3RhY2sgdGhhdCBpcyBub3QgdGhlIGN1cnJlbnQgb25lLFxuICAgICAgICAvLyB3ZSBuYXZpZ2F0ZSB0byBpdFxuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ2NhcmQnIHx8IHRoaXMubW9kZWwudHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JOYXZpZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9zZSBhbnkgb3BlbiBIYWxvcy5cbiAgICAgICAgLy8gSWYgdGhlIG5ldyBtb2RlbCB3YW50cyBhIEhhbG8sXG4gICAgICAgIC8vIG9wZW4gaXQgb24gdGhlIFZpZXcgZm9yIHRoYXQgTW9kZWwuXG4gICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgLmVkaXRpbmdgKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBlbC5jbG9zZUhhbG8oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0YXJnZXRWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW3BhcnQtaWQ9XCIke3RoaXMubW9kZWwuaWR9XCJdYCk7XG4gICAgICAgIGlmKHRhcmdldFZpZXcgJiYgdGFyZ2V0Vmlldy53YW50c0hhbG8pe1xuICAgICAgICAgICAgdGFyZ2V0Vmlldy5vcGVuSGFsbygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnVwZGF0ZUhlYWRlcigpO1xuXG4gICAgICAgIC8vIENsZWFyIHNsb3R0ZWQgaW5uZXIgRE9NXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAvLyBBZGQgcGFuZXNcbiAgICAgICAgbGV0IHByb3BzUGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1wcm9wcy1saXN0Jyk7XG4gICAgICAgIHByb3BzUGFuZS5zZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJywgJ3Byb3BlcnRpZXMnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChwcm9wc1BhbmUpO1xuICAgICAgICBwcm9wc1BhbmUucmVuZGVyKHRoaXMubW9kZWwpO1xuXG4gICAgICAgIGxldCBtZXNzZW5nZXJQYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLW1lc3NlbmdlcicpO1xuICAgICAgICBtZXNzZW5nZXJQYW5lLnNldEF0dHJpYnV0ZSgndGFiLW5hbWUnLCAnbWVzc2VuZ2VyJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobWVzc2VuZ2VyUGFuZSk7XG4gICAgICAgIG1lc3NlbmdlclBhbmUucmVuZGVyKHRoaXMubW9kZWwpO1xuXG4gICAgICAgIGxldCBjdXN0b21QYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZWRpdG9yLWN1c3RvbS1saXN0Jyk7XG4gICAgICAgIGN1c3RvbVBhbmUuc2V0QXR0cmlidXRlKCd0YWItbmFtZScsICdjdXN0b20nKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjdXN0b21QYW5lKTtcbiAgICAgICAgY3VzdG9tUGFuZS5yZW5kZXIodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgbGV0IHN1YnBhcnRzUGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1zdWJwYXJ0cycpO1xuICAgICAgICBzdWJwYXJ0c1BhbmUuc2V0QXR0cmlidXRlKCd0YWItbmFtZScsICdzdWJwYXJ0cycpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHN1YnBhcnRzUGFuZSk7XG4gICAgICAgIHN1YnBhcnRzUGFuZS5yZW5kZXIodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgYWN0aXZlIHRhYiBhbmQgc2hvdyBpdHMgY29ycmVzcG9uZGluZyBwYW5lXG4gICAgICAgIGxldCBhY3RpdmVUYWIgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoYGVkaXRvci10YWJbYWN0aXZlPVwidHJ1ZVwiXWApO1xuICAgICAgICBpZihhY3RpdmVUYWIpe1xuICAgICAgICAgICAgbGV0IGFjdGl2ZU5hbWUgPSBhY3RpdmVUYWIuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW3RhYi1uYW1lXScpKS5mb3JFYWNoKHBhbmUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gcGFuZS5nZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJyk7XG4gICAgICAgICAgICAgICAgaWYobmFtZSA9PSBhY3RpdmVOYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5jbGFzc0xpc3QuYWRkKCdzaG93LXBhbmUnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3ctcGFuZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBwYW5lIGlzIGFscmVhZHkgb3BlbiwgdGhlbiBjZW50ZXJcbiAgICAgICAgLy8gb24gdGhlIHByaW1hcnkgdmlldyBlbGVtZW50IGZvciB0aGUgbW9kZWxcbiAgICAgICAgaWYodGhpcy5pc09wZW4pe1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJPbkVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNlbnRlck9uRWxlbWVudCgpe1xuICAgICAgICAvLyBVc2UgQ1NTIHRyYW5zZm9ybXMgb2YgdGhlIHdob2xlIFdvcmxkIHRvIGNlbnRlciBvblxuICAgICAgICAvLyB0aGUgcHJpbWFyeSB2aWV3IGVsZW1lbnQgb2YgdGhlIFBhcnQgYmVpbmcgZWRpdGVkLFxuICAgICAgICAvLyBpZiBzZXQuIElmIG5vdCBzZXQsIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGVkaXRpbmcgYSBDYXJkLCBTdGFjaywgb3IgV29ybGQsIHRoZW5cbiAgICAgICAgICAgIC8vIHdlIHVuY2VudGVyIGFuZCByZXR1cm5cbiAgICAgICAgICAgIGxldCBpc0NhcmRTdGFja09yV29ybGQgPSBbJ2NhcmQnLCAnc3RhY2snLCAnd29ybGQnXS5pbmNsdWRlcyh0aGlzLm1vZGVsLnR5cGUpO1xuICAgICAgICAgICAgaWYoaXNDYXJkU3RhY2tPcldvcmxkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bmRvQ2VudGVyT25FbGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBwYXJ0VmlldyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICAgICAgbGV0IHdvcmxkVmlldyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKCd3b3JsZCcpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB3b3JsZFZpZXcuZ2V0QXR0cmlidXRlKCdjZW50ZXJlZC1vbicpO1xuICAgICAgICAgICAgaWYoY3VycmVudCA9PSB0aGlzLm1vZGVsLmlkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1lbnVSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxldCBwYXJ0UmVjdCA9IHBhcnRWaWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCB2aWV3YWJsZSB3aWR0aCwgcGx1cyB0aGUgZWRpdG9yIG1lbnVcbiAgICAgICAgICAgIGxldCB2aWV3V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCArIG1lbnVSZWN0LndpZHRoO1xuICAgICAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIG1lbnVSZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIFggdHJhbnNsYXRpb25cbiAgICAgICAgICAgIGxldCB0YXJnZXRYID0gKHZpZXdXaWR0aCAtIHBhcnRSZWN0LndpZHRoKSAvIDI7XG4gICAgICAgICAgICBsZXQgbmV3WDtcbiAgICAgICAgICAgIGlmKHRhcmdldFggPCBwYXJ0UmVjdC5sZWZ0KXtcbiAgICAgICAgICAgICAgICBuZXdYID0gKHBhcnRSZWN0LmxlZnQgLSB0YXJnZXRYKSAqIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdYID0gdGFyZ2V0WCAtIHBhcnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBZIHRyYW5zbGF0aW9uXG4gICAgICAgICAgICBsZXQgdGFyZ2V0WSA9ICh2aWV3SGVpZ2h0IC0gcGFydFJlY3QuaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICBsZXQgbmV3WTtcbiAgICAgICAgICAgIGlmKHRhcmdldFkgPCBwYXJ0UmVjdC50b3Ape1xuICAgICAgICAgICAgICAgIG5ld1kgPSAocGFydFJlY3QudG9wIC0gdGFyZ2V0WSkgKiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3WSA9IHRhcmdldFkgLSBwYXJ0UmVjdC50b3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdvcmxkVmlldy5zZXRBdHRyaWJ1dGUoJ2NlbnRlcmVkLW9uJywgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNldCB0cmFuc2Zvcm0gYW5kIHRyYW5zaXRpb25cbiAgICAgICAgICAgIHdvcmxkVmlldy5zdHlsZS50cmFuc2l0aW9uID0gXCJ0cmFuc2Zvcm0gMC4zcyBlYXNlLW91dFwiO1xuICAgICAgICAgICAgd29ybGRWaWV3LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtuZXdYfXB4LCAke25ld1l9cHgpYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuZG9DZW50ZXJPbkVsZW1lbnQoKXtcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKCd3b3JsZCcpO1xuICAgICAgICB3b3JsZFZpZXcucmVtb3ZlQXR0cmlidXRlKCdjZW50ZXJlZC1vbicpO1xuICAgICAgICB3b3JsZFZpZXcuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgIH1cblxuICAgIHVwZGF0ZUhlYWRlcigpe1xuICAgICAgICBsZXQgbmFtZUlucHV0ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLWxlZnQgPiBpbnB1dCcpO1xuICAgICAgICBsZXQgdHlwZURpc3BsYXkgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNkaXNwbGF5LWFyZWEgPiBoMycpO1xuICAgICAgICBsZXQgaWREaXNwbGF5ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjZGlzcGxheS1hcmVhID4gc3BhbicpO1xuICAgICAgICBsZXQgaWNvbkRpc3BsYXkgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdpY29uLWRpc3BsYXktYXJlYScpO1xuXG4gICAgICAgIGxldCBwYXJ0TmFtZSA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnbmFtZSdcbiAgICAgICAgKTtcblxuICAgICAgICBpZihwYXJ0TmFtZSAmJiBwYXJ0TmFtZSAhPT0gXCJcIil7XG4gICAgICAgICAgICBuYW1lSW5wdXQudmFsdWUgPSBwYXJ0TmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVJbnB1dC52YWx1ZSA9IFwiKFVubmFtZWQpXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlRGlzcGxheS50ZXh0Q29udGVudCA9IHRoaXMubW9kZWwudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRoaXMubW9kZWwudHlwZS5zbGljZSgxKTtcbiAgICAgICAgaWREaXNwbGF5LnRleHRDb250ZW50ID0gYGlkPSR7dGhpcy5tb2RlbC5pZH1gO1xuICAgICAgICBpZERpc3BsYXkudGl0bGUgPSB0aGlzLm1vZGVsLmlkO1xuXG4gICAgICAgIGlmKE9iamVjdC5rZXlzKHBhcnRJY29ucykuaW5jbHVkZXModGhpcy5tb2RlbC50eXBlKSl7XG4gICAgICAgICAgICBpY29uRGlzcGxheS5pbm5lckhUTUwgPSBwYXJ0SWNvbnNbdGhpcy5tb2RlbC50eXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGljb25EaXNwbGF5LmlubmVySFRNTCA9IHBhcnRJY29ucy5nZW5lcmljO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tGb3JOYXZpZ2F0aW9uKCl7XG4gICAgICAgIC8vIElmIHRoZSBtb2RlbCBpcyBhIENhcmQgb3IgU3RhY2sgdGhhdFxuICAgICAgICAvLyBpcyBub3QgdGhlIGN1cnJlbnQgKGllLCBub3QgYmVpbmcgZGlzcGxheWVkXG4gICAgICAgIC8vIGluIHRoZSBtYWluIHdpbmRvdyksIHRoZW4gd2Ugc2hvdWxkIG5hdmlnYXRlXG4gICAgICAgIC8vIHRvIGl0XG4gICAgICAgIGxldCBjdXJyZW50U3RhY2sgPSB3aW5kb3cuU3lzdGVtLndvcmxkLmN1cnJlbnRTdGFjaztcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkID0gY3VycmVudFN0YWNrLmN1cnJlbnRDYXJkO1xuICAgICAgICBpZih0aGlzLm1vZGVsLnR5cGUgPT0gJ2NhcmQnICYmIHRoaXMubW9kZWwuaWQgIT0gY3VycmVudENhcmQuaWQpe1xuICAgICAgICAgICAgY3VycmVudFN0YWNrLmdvVG9DYXJkQnlJZCh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnc3RhY2snICYmIHRoaXMubW9kZWwuaWQgIT0gY3VycmVudFN0YWNrLmlkKXtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0ud29ybGQuZ29Ub1N0YWNrQnlJZCh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICByZWNlaXZlTWVzc2FnZShhTWVzc2FnZSl7XG4gICAgICAgIHN3aXRjaChhTWVzc2FnZS50eXBlKXtcbiAgICAgICAgY2FzZSAncHJvcGVydHlDaGFuZ2VkJzpcbiAgICAgICAgICAgIC8vIEZpbmQgYW55IG5lc3RlZCBlZGl0b3ItcHJvcC1pdGVtIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBhbmQgcmUtcmVuZGVyLCBzbyB0aGV5IGRpc3BsYXkgdGhlIGNvcnJlY3RcbiAgICAgICAgICAgIC8vIHZhbHVlcyBpbiB0aGUgZWRpdG9yXG4gICAgICAgICAgICBsZXQgcXVlcnlTdHJpbmcgPSBgZWRpdG9yLXByb3AtaXRlbVtuYW1lPVwiJHthTWVzc2FnZS5wcm9wZXJ0eU5hbWV9XCJdW293bmVyLWlkPVwiJHthTWVzc2FnZS5wYXJ0SWR9XCJdYDtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5U3RyaW5nKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYoZWwucHJvcGVydHkudmFsdWUgIT09IGFNZXNzYWdlLnZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uVGFiQWN0aXZhdGVkKGV2ZW50KXtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2VkaXRvci10YWInKSlcbiAgICAgICAgICAgIC5maWx0ZXIodGFiRWwgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWJFbCAhPT0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgfSkuZm9yRWFjaCh0YWJFbCA9PiB7XG4gICAgICAgICAgICAgICAgdGFiRWwucmVtb3ZlQXR0cmlidXRlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbmFtZSBvZiB0aGUgYWN0aXZhdGVkIHRhYlxuICAgICAgICBsZXQgdGFyZ2V0TmFtZSA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t0YWItbmFtZV0nKSkuZm9yRWFjaChwYW5lID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gcGFuZS5nZXRBdHRyaWJ1dGUoJ3RhYi1uYW1lJyk7XG4gICAgICAgICAgICBpZihuYW1lID09IHRhcmdldE5hbWUpe1xuICAgICAgICAgICAgICAgIHBhbmUuY2xhc3NMaXN0LmFkZCgnc2hvdy1wYW5lJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhbmUuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdy1wYW5lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uTmFtZUlucHV0Q2hhbmdlKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy5tb2RlbCl7XG4gICAgICAgICAgICBsZXQgbmV3TmFtZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICAgICBuZXdOYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25FZGl0U2NyaXB0Q2xpY2soZXZlbnQpe1xuICAgICAgICBpZih0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ29wZW5TY3JpcHRFZGl0b3InLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5pZFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGlzT3Blbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ29wZW4nKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvcixcbiAgICBFZGl0b3IgYXMgZGVmYXVsdFxufTtcbiIsIlxuXG4vLyBQUkVBTUJMRVxuXG5jb25zdCBjYXJldERvd25JY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNhcmV0LWRvd25cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTE4IDE1bC02IC02bC02IDZoMTJcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMTgwIDEyIDEyKVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IGNhcmV0UmlnaHRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNhcmV0LXJpZ2h0XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPHBhdGggZD1cIk0xOCAxNWwtNiAtNmwtNiA2aDEyXCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDEyKVwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgICAgICBmb250LXNpemU6IDAuOHJlbTtcbiAgICB9XG5cbiAgICAjcHJvcHMtbGlzdCB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB9XG4gICAgI2ZpbHRlci1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuICAgICNmaWx0ZXItYXJlYSA+IGlucHV0IHtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOiAxLjByZW07XG4gICAgICAgIHBhZGRpbmctbGVmdDogNnB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiA2cHg7XG4gICAgICAgIHBhZGRpbmctdG9wOiAzcHg7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAzcHg7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC44KTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgIH1cbiAgICBcbiAgICAjbmV3LXByb3AtYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgICNuZXctcHJvcC1hcmVhLm9wZW4gPiAjbmV3LXByb3AtZm9ybSB7XG4gICAgICAgIGRpc3BsYXk6ZmxleDtcbiAgICB9XG5cbiAgICAjbmV3LXByb3AtZm9ybSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIC5yb3cge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMWVtO1xuICAgIH1cblxuICAgIGgzIHtcbiAgICAgICAgcGFkZGluZzogMHB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxZW07XG4gICAgfVxuXG4gICAgI25ldy1wcm9wLWZvcm0gPiAucm93ID4gKiB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMTZweDtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcbiAgICB9XG4gICAgI25ldy1wcm9wLWZvcm0gaW5wdXQge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC43KTtcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICAgICAgcGFkZGluZzogNnB4O1xuICAgIH1cblxuICAgICNuZXctcHJvcC1uYW1lOmludmFsaWQge1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmVkO1xuICAgIH1cbiAgICBcbiAgICBzZWxlY3Qge1xuICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICB9XG4gICAgI2FkZC1wcm9wLWRyb3Bkb3duLWNvbnRyb2wge1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG5cbiAgICAjYWRkLXByb3AtZHJvcGRvd24tY29udHJvbDpob3ZlcixcbiAgICAjYWRkLXByb3AtZHJvcGRvd24tY29udHJvbCBsYWJlbCB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5cbiAgICAjY2FyZXQtYnV0dG9uIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMS41ZW07XG4gICAgICAgIGhlaWdodDogMS41ZW07XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xcyBsaW5lYXI7XG4gICAgfVxuXG4gICAgI2NhcmV0LWJ1dHRvbiA+IHN2ZyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICAgICNuZXctcHJvcC1hcmVhLm9wZW4gI2NhcmV0LWJ1dHRvbiB7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMXMgbGluZWFyO1xuICAgIH1cblxuPC9zdHlsZT5cbjxkaXYgaWQ9XCJuZXctcHJvcC1hcmVhXCI+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiIGlkPVwiYWRkLXByb3AtZHJvcGRvd24tY29udHJvbFwiPlxuICAgICAgICA8aDM+PGxhYmVsIGZvcj1cImNhcmV0LWJ1dHRvblwiPkFkZCBOZXcgUHJvcGVydHk8L2xhYmVsPjwvaDM+XG4gICAgICAgIDxkaXYgaWQ9XCJjYXJldC1idXR0b25cIj4ke2NhcmV0UmlnaHRJY29ufTwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJuZXctcHJvcC1mb3JtXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJuZXctcHJvcC1uYW1lXCI+UHJvcGVydHkgTmFtZSA8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJuZXctcHJvcC1uYW1lXCIgcGxhY2Vob2xkZXI9XCJwcm9wZXJ0eS1uYW1lXCIgcGF0dGVybj1cIlthLXpcXFxcLV17Myw2NH1cIi8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiZGVmYXVsdC12YWwtc2VsZWN0XCI+RGVmYXVsdCB2YWx1ZSB0eXBlPC9sYWJlbD5cbiAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJkZWZhdWx0LXZhbC1zZWxlY3RcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCIgc2VsZWN0ZWQ+Tm9uZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzdHJpbmdcIj5UZXh0PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm51bWJlclwiPk51bWJlcjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJib29sZWFuXCI+VHJ1ZSBvciBGYWxzZTwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiZGVmYXVsdC12YWx1ZVwiPkRlZmF1bHQgdmFsdWUgPC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiZGVmYXVsdC12YWx1ZVwiIHBsYWNlaG9sZGVyPVwiRGVmYXVsdCB2YWx1ZVwiIGRpc2FibGVkLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIiBpZD1cInN1Ym1pdC1jb250cm9sXCI+XG4gICAgICAgICAgICA8YnV0dG9uIGlkPVwic3VibWl0LXByb3BcIj5DcmVhdGU8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cbjxkaXYgaWQ9XCJmaWx0ZXItYXJlYVwiPlxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiZmlsdGVyLWlucHV0XCIgbmFtZT1cImZpbHRlci1pbnB1dFwiIHBsYWNlaG9sZGVyPVwiRmlsdGVyLi4uXCIvPlxuICAgIDxidXR0b24gaWQ9XCJjbGVhclwiPkNsZWFyPC9idXR0b24+XG48L2Rpdj5cbjx1bCBpZD1cInByb3BzLWxpc3RcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L3VsPlxuYDtcblxuY2xhc3MgRWRpdG9yQ3VzdG9tTGlzdCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNldEZvcm0gPSB0aGlzLnJlc2V0Rm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRGVmYXVsdE5ld1R5cGVDaGFuZ2UgPSB0aGlzLm9uRGVmYXVsdE5ld1R5cGVDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNhcmV0Q2xpY2sgPSB0aGlzLm9uQ2FyZXRDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ3JlYXRlU3VibWl0ID0gdGhpcy5vbkNyZWF0ZVN1Ym1pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRmlsdGVySW5wdXQgPSB0aGlzLm9uRmlsdGVySW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkZpbHRlckNsZWFyQ2xpY2sgPSB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wVHlwZVNlbGVjdCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2RlZmF1bHQtdmFsLXNlbGVjdCcpO1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wTmFtZUlucHV0ID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbmV3LXByb3AtbmFtZScpO1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZGVmYXVsdC12YWx1ZScpO1xuICAgICAgICAgICAgdGhpcy5hZGRQcm9wQ29udHJvbCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2FkZC1wcm9wLWRyb3Bkb3duLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcEZvcm0gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCduZXctcHJvcC1mb3JtJyk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3N1Ym1pdC1wcm9wJyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnY2xlYXInKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5wdXQgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXItaW5wdXQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5hZGRQcm9wQ29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DYXJldENsaWNrKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNyZWF0ZVN1Ym1pdCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbkZpbHRlcklucHV0KTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcblxuICAgICAgICAvLyBDbGVhciBhbnkgbWFpbiBkb20gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNvcnRlZCBjb3B5IG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgIGxldCBjdXN0b21Qcm9wcyA9IHRoaXMubW9kZWwucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAnY3VzdG9tLXByb3BlcnRpZXMnXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGF2YWlsYWJsZVxuICAgICAgICB0aGlzLnByb3BMaXN0ID0gT2JqZWN0LnZhbHVlcyhjdXN0b21Qcm9wcylcbiAgICAgICAgICAgIC5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Lm5hbWUubG9jYWxlQ29tcGFyZShzZWNvbmQubmFtZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHByb3BlcnR5IGl0ZW1zIGFuZCBpbnNlcnQgdGhlbVxuICAgICAgICB0aGlzLnByb3BMaXN0LmZvckVhY2gocHJvcE9iamVjdCA9PiB7XG4gICAgICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlZGl0b3ItcHJvcC1pdGVtJyk7XG4gICAgICAgICAgICBlbC5zZXRQcm9wZXJ0eShwcm9wT2JqZWN0LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbmFtZScsIHByb3BPYmplY3QubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLm5ld1Byb3BUeXBlU2VsZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25EZWZhdWx0TmV3VHlwZUNoYW5nZSk7XG4gICAgICAgIHRoaXMubmV3UHJvcFR5cGVTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbkRlZmF1bHROZXdUeXBlQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBvbkRlZmF1bHROZXdUeXBlQ2hhbmdlKGV2ZW50KXtcbiAgICAgICAgbGV0IG9wdGlvbiA9IGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnNbMF07XG4gICAgICAgIHN3aXRjaChvcHRpb24udmFsdWUpe1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIFwiXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ251bWJlcicpO1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihvcHRpb24udmFsdWUgPT0gXCJcIil7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2FyZXRDbGljayhldmVudCl7XG4gICAgICAgIGxldCBuZXdQcm9wQXJlYSA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25ldy1wcm9wLWFyZWEnKTtcbiAgICAgICAgbmV3UHJvcEFyZWEuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpO1xuICAgIH1cblxuICAgIG9uQ3JlYXRlU3VibWl0KGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy5tb2RlbCl7XG4gICAgICAgICAgICBsZXQgcHJvcE5hbWUgPSB0aGlzLm5ld1Byb3BOYW1lSW5wdXQudmFsdWU7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYodGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnR5cGUgPT0gJ2NoZWNrYm94Jyl7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gdGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLmNoZWNrZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnR5cGUgPT0gJ251bWJlcicpe1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5uZXdQcm9wRGVmYXVsdFZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2VuZCB0aGUgcHJvcGVydHkgY3JlYXRlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ25ld1Byb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmlkXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgY3JlYXRlZCBwcm9wIHRvIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5tb2RlbC5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBSZS1yZW5kZXIgdGhpcyBwYW5lXG4gICAgICAgICAgICB0aGlzLnJlc2V0Rm9ybSgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaWx0ZXJCeSh0ZXh0KXtcbiAgICAgICAgLy8gRmluZCBhbGwgb2YgdGhlIHByb3AgaXRlbSBlbGVtZW50cyB3aG9zZVxuICAgICAgICAvLyBwcm9wZXJ0eSBuYW1lIGRvZXMgKm5vdCogaW5jbHVkZSB0aGUgc3Vic3RyaW5nLFxuICAgICAgICAvLyBhbmQgc2V0IHRob3NlIHRvIG5vdCBkaXNwbGF5XG4gICAgICAgIGxldCBhbGxFbGVtZW50cyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdlZGl0b3ItcHJvcC1pdGVtJykpO1xuICAgICAgICBhbGxFbGVtZW50cy5mb3JFYWNoKHByb3BFbCA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHByb3BFbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgIGlmKG5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXh0KSl7XG4gICAgICAgICAgICAgICAgcHJvcEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2l0ZW0taGlkZGVuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BFbC5jbGFzc0xpc3QuYWRkKCdpdGVtLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkZpbHRlcklucHV0KGV2ZW50KXtcbiAgICAgICAgdGhpcy5maWx0ZXJCeShldmVudC50YXJnZXQudmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgb25GaWx0ZXJDbGVhckNsaWNrKGV2ZW50KXtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZmlsdGVyQnkoXCJcIik7XG4gICAgfVxuXG4gICAgcmVzZXRGb3JtKCl7XG4gICAgICAgIHRoaXMubmV3UHJvcE5hbWVJbnB1dC52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS52YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmKHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS50eXBlID09ICdjaGVja2VkJyl7XG4gICAgICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV3UHJvcERlZmF1bHRWYWx1ZS50eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLm5ld1Byb3BEZWZhdWx0VmFsdWUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB0aGlzLm5ld1Byb3BUeXBlU2VsZWN0LnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yQ3VzdG9tTGlzdCxcbiAgICBFZGl0b3JDdXN0b21MaXN0IGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgaW50ZXJwcmV0ZXJTZW1hbnRpY3MgZnJvbSAnLi4vLi4vLi4vb2htL2ludGVycHJldGVyLXNlbWFudGljcy5qcyc7XG5pbXBvcnQge29uTG9jYXRpb25MaW5rQ2xpY2ssIGdldExvY2F0aW9uU3RyaW5nRm9yfSBmcm9tICcuL3V0aWxzL3N1YnBhcnRzLmpzJztcblxuLy8gUFJFQU1CTEVcbmNvbnN0IGFycm93TGVmdEljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItYXJyb3ctbmFycm93LWxlZnRcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8bGluZSB4MT1cIjVcIiB5MT1cIjEyXCIgeDI9XCIxOVwiIHkyPVwiMTJcIiAvPlxuICA8bGluZSB4MT1cIjVcIiB5MT1cIjEyXCIgeDI9XCI5XCIgeTI9XCIxNlwiIC8+XG4gIDxsaW5lIHgxPVwiNVwiIHkxPVwiMTJcIiB4Mj1cIjlcIiB5Mj1cIjhcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCBjbGlwYm9hcmRJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLWNsaXBib2FyZFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjMDAwMDAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxwYXRoIGQ9XCJNOSA1aC0yYTIgMiAwIDAgMCAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTBhMiAyIDAgMCAwIDIgLTJ2LTEyYTIgMiAwIDAgMCAtMiAtMmgtMlwiIC8+XG4gIDxyZWN0IHg9XCI5XCIgeT1cIjNcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCI0XCIgcng9XCIyXCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3QoLmhpZGRlbil7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgIC5idXR0b24tbGluayB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGVhc2Utb3V0O1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbm1lbnQ6IGNlbnRlcjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIHBhZGRpbmc6IDBweDtcbiAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgfVxuXG4gICAgLmJ1dHRvbi1saW5rOmhvdmVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxNTAsIDE1MCwgMTUwLCAwLjcpO1xuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMC4ycyBlYXNlLW91dDtcbiAgICB9XG5cbiAgICAuYnV0dG9uLWxpbmsgPiBzdmcge1xuICAgICAgICBtYXJnaW4tbGVmdDogOHB4O1xuICAgICAgICBvcGFjaXR5OiAwLjc7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwcHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGVhc2Utb3V0O1xuICAgIH1cblxuICAgIC5idXR0b24tbGluazpob3ZlciA+IHN2ZyB7XG4gICAgICAgIG9wYWNpdHk6IDEuMDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01cHgpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGVhc2Utb3V0O1xuICAgIH1cbjwvc3R5bGU+XG48cCBjbGFzcz1cInBhcnQtaW5mb1wiPlxuICAgIE15IDxidXR0b24gaWQ9XCJvd25lci1saW5rXCIgY2xhc3M9XCJidXR0b24tbGlua1wiIHRpdGxlPVwiXCI+PHNwYW4+PC9zcGFuPiR7YXJyb3dMZWZ0SWNvbn08L2J1dHRvbj4gaXMgbmFtZWQgPHNwYW4gY2xhc3M9XCJwYXJ0LW5hbWVcIj48L3NwYW4+IGFuZCBpcyBsb2NhdGVkIGF0IDxidXR0b24gaWQ9XCJsb2NhdGlvbi1saW5rXCIgY2xhc3M9XCJidXR0b24tbGlua1wiIHRpdGxlPVwiQ29weSBsb2NhdGlvblwiPjxzcGFuPjwvc3Bhbj4ke2NsaXBib2FyZEljb259PC9idXR0b24+IDxidXR0b24gaWQ9XCJpZC1saW5rXCIgY2xhc3M9XCJidXR0b24tbGlua1wiIHRpdGxlPVwiQ29weSBpZFwiPjxzcGFuPkNvcHkgaWQ8L3NwYW4+JHtjbGlwYm9hcmRJY29ufTwvYnV0dG9uPlxuPC9wPlxuYDtcblxuY2xhc3MgRWRpdG9yTG9jYXRpb25JbmZvIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEFjY2VwdGVkIHZhbHVlcyBmb3IgdGhlIGtpbmQgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuYWxsb3dlZEtpbmRzID0gWydzdGFjaycsICdjYXJkJywgJ293bmVyJ107XG5cbiAgICAgICAgLy8gZGVmaW5lIGFuZCBiaW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblN0cmluZ0ZvciA9IGdldExvY2F0aW9uU3RyaW5nRm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayA9IG9uTG9jYXRpb25MaW5rQ2xpY2suYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuaGFuZGxlU3RhY2tLaW5kID0gdGhpcy5oYW5kbGVTdGFja0tpbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDYXJkS2luZCA9IHRoaXMuaGFuZGxlQ2FyZEtpbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbmZvID0gdGhpcy51cGRhdGVJbmZvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0QW5jZXN0b3JPZlR5cGVGb3IgPSB0aGlzLmdldEFuY2VzdG9yT2ZUeXBlRm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyA9IHRoaXMuZ2V0TG9jYXRpb25WaWV3cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTGlua0NsaWNrID0gdGhpcy5vbkxpbmtDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VFbnRlciA9IHRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZUxlYXZlID0gdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgbGV0IG93bmVyTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ293bmVyLWxpbmsnKTtcbiAgICAgICAgbGV0IGxvY2F0aW9uTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2xvY2F0aW9uLWxpbmsnKTtcbiAgICAgICAgbGV0IGlkTGlua0J1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2lkLWxpbmsnKTtcbiAgICAgICAgb3duZXJMaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxpbmtDbGljayk7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkNsaWNrKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uQ2xpY2spO1xuICAgICAgICBsb2NhdGlvbkxpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICAgICAgaWRMaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgICAgICBpZExpbmtCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlKTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBsZXQgb3duZXJMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnb3duZXItbGluaycpO1xuICAgICAgICBsZXQgbG9jYXRpb25MaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbG9jYXRpb24tbGluaycpO1xuICAgICAgICBsZXQgaWRMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaWQtbGluaycpO1xuICAgICAgICBsb2NhdGlvbkxpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25DbGljayk7XG4gICAgICAgIGlkTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkNsaWNrKTtcbiAgICAgICAgb3duZXJMaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgICAgIGxvY2F0aW9uTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuICAgICAgICBpZExpbmtCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICAgICAgbG9jYXRpb25MaW5rQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgICAgIGlkTGlua0J1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICBsZXQga2luZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdraW5kJyk7XG4gICAgICAgIGlmKCFraW5kIHx8ICF0aGlzLmFsbG93ZWRLaW5kcy5pbmNsdWRlcyhraW5kKSl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnd29ybGQnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBlbGVtZW50IHJlZmVyZW5jZXNcbiAgICAgICAgdGhpcy5vd25lckxpbmtCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdvd25lci1saW5rJyk7XG4gICAgICAgIHRoaXMub3duZXJMaW5rVHlwZVNwYW4gPSB0aGlzLm93bmVyTGlua0J1dHRvbi5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIHRoaXMubG9jYXRpb25MaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbG9jYXRpb24tbGluaycpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uTGlua1NwYW4gPSB0aGlzLmxvY2F0aW9uTGlua0J1dHRvbi5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIHRoaXMuaWRMaW5rQnV0dG9uID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnaWQtbGluaycpO1xuICAgICAgICB0aGlzLmlkTGlua1NwYW4gPSB0aGlzLmlkTGlua0J1dHRvbi5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIHRoaXMubmFtZVNwYW4gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3AgLnBhcnQtbmFtZScpO1xuXG4gICAgICAgIGlmKGtpbmQgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN0YWNrS2luZCgpO1xuICAgICAgICB9IGVsc2UgaWYoa2luZCA9PSdjYXJkJyl7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNhcmRLaW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluZm8oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUluZm8oKXtcbiAgICAgICAgbGV0IGtpbmQgPSB0aGlzLmdldEF0dHJpYnV0ZSgna2luZCcpO1xuICAgICAgICBsZXQgYW5jZXN0b3IgPSB0aGlzLm1vZGVsLl9vd25lcjtcbiAgICAgICAgaWYoa2luZCA9PSAnc3RhY2snIHx8IGtpbmQgPT0gJ2NhcmQnKXtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gdGhpcy5nZXRBbmNlc3Rvck9mVHlwZUZvcih0aGlzLm1vZGVsLCBraW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGNhbm5vdCBmaW5kIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlblxuICAgICAgICAvLyBraW5kLCB0aGVuIHdlIGhpZGUgdGhpcyBmaWVsZFxuICAgICAgICBpZighYW5jZXN0b3Ipe1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBuYW1lIHNwYW5cbiAgICAgICAgbGV0IGFuY2VzdG9yTmFtZSA9IGFuY2VzdG9yLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBhbmNlc3RvcixcbiAgICAgICAgICAgICduYW1lJ1xuICAgICAgICApO1xuICAgICAgICBpZighYW5jZXN0b3JOYW1lKXtcbiAgICAgICAgICAgIGFuY2VzdG9yTmFtZSA9ICcodW5uYW1lZCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jZXN0b3JOYW1lID0gYFwiJHthbmNlc3Rvck5hbWV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZVNwYW4udGV4dENvbnRlbnQgPSBhbmNlc3Rvck5hbWU7XG5cbiAgICAgICAgLy8gVXBkYXRlIGtpbmQgc3BhblxuICAgICAgICBsZXQga2luZExhYmVsID0ga2luZFswXS50b1VwcGVyQ2FzZSgpICsga2luZC5zbGljZSgxKTtcbiAgICAgICAgdGhpcy5vd25lckxpbmtUeXBlU3Bhbi50ZXh0Q29udGVudCA9IGtpbmRMYWJlbDtcblxuICAgICAgICAvLyBVcGRhdGUgbG9jYXRpb24gbGluayBzcGFuXG4gICAgICAgIHRoaXMubG9jYXRpb25MaW5rU3Bhbi50ZXh0Q29udGVudCA9IHRoaXMuZ2V0TG9jYXRpb25TdHJpbmdGb3IoYW5jZXN0b3IpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBidXR0b24gdGl0bGVzXG4gICAgICAgIGxldCBlZGl0VGl0bGUgPSBgRWRpdCBvd25pbmcgJHtraW5kTGFiZWx9YDtcbiAgICAgICAgaWYoa2luZCA9PSAnb3duZXInKXtcbiAgICAgICAgICAgIGVkaXRUaXRsZSA9ICdFZGl0IE93bmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm93bmVyTGlua0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAndGl0bGUnLFxuICAgICAgICAgICAgZWRpdFRpdGxlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSByZWYtaWQgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyZWYtaWQnLCBhbmNlc3Rvci5pZCk7XG4gICAgfVxuXG4gICAgaGFuZGxlU3RhY2tLaW5kKCl7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnc3RhY2snIHx8IHRoaXMubW9kZWwudHlwZSA9PSAnd29ybGQnKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbmZvKCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2FyZEtpbmQoKXtcbiAgICAgICAgaWYodGhpcy5tb2RlbC50eXBlID09ICdjYXJkJyB8fCB0aGlzLm1vZGVsLnR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSW5mbygpO1xuICAgIH1cblxuICAgIGdldEFuY2VzdG9yT2ZUeXBlRm9yKGFQYXJ0LCBhVHlwZSl7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGxldCBjdXJyZW50T3duZXIgPSBhUGFydC5fb3duZXI7XG4gICAgICAgIHdoaWxlKGN1cnJlbnRPd25lcil7XG4gICAgICAgICAgICBpZihjdXJyZW50T3duZXIudHlwZSA9PSBhVHlwZSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VycmVudE93bmVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE93bmVyID0gY3VycmVudE93bmVyLl9vd25lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG9uTGlua0NsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZi1pZCcpO1xuICAgICAgICBpZihpZCAmJiB0aGlzLm1vZGVsKXtcbiAgICAgICAgICAgIC8vIFJlLXJlbmRlciB0aGUgZWRpdG9yIG9uIHRoZSBQYXJ0XG4gICAgICAgICAgICAvLyByZWZlcmVuY2VkIGJ5IHRoZSBmb3VuZCBpZFxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW2lkXTtcbiAgICAgICAgICAgIHdpbmRvdy5TeXN0ZW0uZWRpdG9yLnJlbmRlcih0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VzZUVudGVyKGV2ZW50KXtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzKGV2ZW50KS5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LmhpZ2hsaWdodChcInJnYig1NCwgMTcyLCAxMDApXCIpOyAvLyBncmVlblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbk1vdXNlTGVhdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MoZXZlbnQpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0TG9jYXRpb25WaWV3cyhldmVudCl7XG4gICAgICAgIGxldCB0YXJnZXRJZDtcbiAgICAgICAgbGV0IHNwYW4gPSBldmVudC5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgaWYoc3Bhbi5wYXJlbnRFbGVtZW50LmlkID09ICdpZC1saW5rJyl7XG4gICAgICAgICAgICB0YXJnZXRJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWYtaWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZW1hbnRpY3MgPSB3aW5kb3cuU3lzdGVtLmdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCk7XG4gICAgICAgICAgICBzZW1hbnRpY3MuYWRkT3BlcmF0aW9uKFxuICAgICAgICAgICAgICAgICdpbnRlcnByZXQnLFxuICAgICAgICAgICAgICAgIGludGVycHJldGVyU2VtYW50aWNzKHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkWyd3b3JsZCddLCB3aW5kb3cuU3lzdGVtKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBtID0gd2luZG93LlN5c3RlbS5ncmFtbWFyLm1hdGNoKHNwYW4udGV4dENvbnRlbnQsIFwiT2JqZWN0U3BlY2lmaWVyXCIpO1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIHRhcmdldElkID0gc2VtYW50aWNzKG0pLmludGVycHJldCgpO1xuICAgICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgY2Fubm90IGxvY2F0ZSAke3NwYW4udGV4dENvbnRlbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdzQnlJZCh0YXJnZXRJZCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JMb2NhdGlvbkluZm8sXG4gICAgRWRpdG9yTG9jYXRpb25JbmZvIGFzIGRlZmF1bHRcbn07XG4iLCJcblxuLy8gUFJFQU1CTEVcbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgICAgICBmb250LXNpemU6IDAuOHJlbTtcbiAgICB9XG4gICBcbiAgICB0ZXh0YXJlYSB7XG4gICAgICAgIHJlc2l6ZTogbm9uZTtcbiAgICAgICAgZmxleDogMC4yNTtcbiAgICB9XG48L3N0eWxlPlxuPGgzPlNlbmQgdGhpcyA8c3Bhbj48L3NwYW4+IGEgTWVzc2FnZTo8L2gzPlxuPHRleHRhcmVhIHBsYWNlaG9sZGVyPVwiVHlwZSB5b3VyIFNpbXBsZXRhbGsgbWVzc2FnZSBoZXJlLi4uXCI+PC90ZXh0YXJlYT5cbjxidXR0b24+U2VuZDwvYnV0dG9uPlxuYDtcblxuY2xhc3MgRWRpdG9yTWVzc2VuZ2VyIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTWVzc2FnZUZpZWxkSW5wdXQgPSB0aGlzLm9uTWVzc2FnZUZpZWxkSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUZyb21UZXh0ID0gdGhpcy5zZW5kTWVzc2FnZUZyb21UZXh0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zZW5kTWVzc2FnZUZyb21UZXh0KTtcbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VGaWVsZCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbk1lc3NhZ2VGaWVsZElucHV0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMubWVzc2FnZUZpZWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbk1lc3NhZ2VGaWVsZElucHV0KTtcbiAgICAgICAgdGhpcy5zZW5kQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zZW5kTWVzc2FnZUZyb21UZXh0KTtcbiAgICB9XG5cbiAgICByZW5kZXIoYU1vZGVsKXtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGFNb2RlbDtcbiAgICAgICAgXG4gICAgICAgIGxldCBwYXJ0VHlwZUxhYmVsID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdoMyA+IHNwYW4nKTtcbiAgICAgICAgcGFydFR5cGVMYWJlbC50ZXh0Q29udGVudCA9IHRoaXMubW9kZWwudHlwZTtcbiAgICB9XG5cbiAgICBvbk1lc3NhZ2VGaWVsZElucHV0KGV2ZW50KXtcblxuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlRnJvbVRleHQoKXtcbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLm1lc3NhZ2VGaWVsZC52YWx1ZTtcbiAgICAgICAgbGV0IHNjcmlwdCA9IGBvbiBkb0l0XFxuXFx0JHt0ZXh0fVxcbmVuZCBkb0l0YDtcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tcGlsZScsXG4gICAgICAgICAgICBjb2RlU3RyaW5nOiBzY3JpcHQsXG4gICAgICAgICAgICB0YXJnZXRJZDogdGhpcy5tb2RlbC5pZFxuICAgICAgICB9LCB0aGlzLm1vZGVsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWFuZCcsXG4gICAgICAgICAgICBjb21tYW5kTmFtZTogJ2RvSXQnLFxuICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICBzaG91bGRJZ25vcmU6IHRydWVcbiAgICAgICAgfSwgdGhpcy5tb2RlbCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JNZXNzZW5nZXIsXG4gICAgRWRpdG9yTWVzc2VuZ2VyIGFzIGRlZmF1bHRcbn07XG4iLCIvLyBQUkVBTUJMRVxuXG5jb25zdCBjaGVja0ljb24gPSBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItY2lyY2xlLWNoZWNrXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cIiMwMGIzNDFcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICA8cGF0aCBzdHJva2U9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbiAgPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI5XCIgLz5cbiAgPHBhdGggZD1cIk05IDEybDIgMmw0IC00XCIgLz5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY2FuY2VsSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jaXJjbGUteFwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCIjZmYyODI1XCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj5cbiAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XG4gIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiOVwiIC8+XG4gIDxwYXRoIGQ9XCJNMTAgMTBsNCA0bTAgLTRsLTQgNFwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIGxpIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBwYWRkaW5nOiA2cHg7XG4gICAgICAgIHBhZGRpbmctbGVmdDogOHB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDZweDtcbiAgICB9XG4gICBcbiAgICBsaSA+IGxhYmVsIHtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG5cbiAgICA6aG9zdCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIDpob3N0KC5pdGVtLWhpZGRlbikge1xuICAgICAgICBkaXNwbGF5Om5vbmU7XG4gICAgfVxuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICBvcGFjaXR5OiAxLjA7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBsaW5lYXI7XG4gICAgfVxuXG4gICAgYnV0dG9uOmRpc2FibGVkIHtcbiAgICAgICAgb3BhY2l0eTogMC4wNTtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eTogMC4xcyBsaW5lYXI7XG4gICAgfVxuXG4gICAgYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cblxuICAgIGJ1dHRvbi5idXR0b24taGlkZGVuIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICBsYWJlbCB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgfVxuXG4gICAgaW5wdXQge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMTAwLCAxMDAsIDEwMCwgMC41KTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG4gICAgXG4gICAgaW5wdXQ6Zm9jdXMge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuOCk7XG4gICAgfVxuPC9zdHlsZT5cbjxsaT5cbiAgICA8bGFiZWwgZm9yPVwicHJvcC12YWx1ZVwiPjwvbGFiZWw+XG4gICAgPGlucHV0IGlkPVwicHJvcC12YWx1ZVwiIG5hbWU9XCJwcm9wLXZhbHVlXCIvPlxuICAgIDxidXR0b24gaWQ9XCJhY2NlcHRcIiBkaXNhYmxlZD4ke2NoZWNrSWNvbn08L2J1dHRvbj5cbiAgICA8YnV0dG9uIGlkPVwiY2FuY2VsXCIgZGlzYWJsZWQ+JHtjYW5jZWxJY29ufTwvYnV0dG9uPlxuPC9saT5cbmA7XG5cbmNsYXNzIEVkaXRvclByb3BJdGVtIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGVtcGxhdGUgYW5kIHNoYWRvdyByb290XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIHByb3BlcnR5XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBudWxsO1xuICAgICAgICB0aGlzLm93bmVyID0gbnVsbDtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbklucHV0Q2hhbmdlID0gdGhpcy5vbklucHV0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25JbnB1dElucHV0ID0gdGhpcy5vbklucHV0SW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkFjY2VwdENsaWNrID0gdGhpcy5vbkFjY2VwdENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DYW5jZWxDbGljayA9IHRoaXMub25DYW5jZWxDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRW50ZXJLZXkgPSB0aGlzLm9uRW50ZXJLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cE51bWVyaWNJbnB1dCA9IHRoaXMuc2V0dXBOdW1lcmljSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmFibGVCdXR0b25zID0gdGhpcy5lbmFibGVCdXR0b25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUJ1dHRvbnMgPSB0aGlzLmRpc2FibGVCdXR0b25zLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHkoYVByb3BlcnR5LCBhbk93bmVyKXtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBldmVudCBoYW5kbGVyc1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBhUHJvcGVydHk7XG4gICAgICAgIHRoaXMub3duZXIgPSBhbk93bmVyO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudCBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJywgdGhpcy5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ293bmVyLWlkJywgdGhpcy5vd25lci5pZCk7XG5cbiAgICAgICAgLy8gQWRkIG5ldyBldmVudCBoYW5kbGVyc1xuXG4gICAgICAgIC8vIFJlbmRlclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLm9uRW50ZXJLZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMub25FbnRlcktleSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCl7XG4gICAgICAgIHRoaXMubGFiZWxFbGVtZW50ID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudCA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdhY2NlcHQnKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24gPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdjYW5jZWwnKTtcblxuICAgICAgICAvLyBSZW1vdmUgYW55IGhpZGUgY2xhc3Nlc1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdidXR0b24taGlkZGVuJyk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2J1dHRvbi1oaWRkZW4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgYm91bmQgZXZlbnRzXG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0SW5wdXQpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uSW5wdXRDaGFuZ2UpO1xuICAgICAgICB0aGlzLmFjY2VwdEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25BY2NlcHRDbGljayk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNhbmNlbENsaWNrKTtcblxuICAgICAgICAvLyBBZGQgbmV3IGV2ZW50c1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25JbnB1dElucHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbklucHV0Q2hhbmdlKTtcbiAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQWNjZXB0Q2xpY2spO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DYW5jZWxDbGljayk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmxhYmVsRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RoaXMucHJvcGVydHkubmFtZX06YDtcbiAgICAgICAgbGV0IGN1cnJlbnRWYWwgPSB0aGlzLnByb3BlcnR5LmdldFZhbHVlKHRoaXMub3duZXIpO1xuICAgICAgICBpZihjdXJyZW50VmFsID09IG51bGwgfHwgY3VycmVudFZhbCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgLy8gRG8gc29tZXRoaW5nIGRpZmZlcmVudCBoZXJlXG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YoY3VycmVudFZhbCkgPT0gJ251bWJlcicpe1xuICAgICAgICAgICAgdGhpcy5zZXR1cE51bWVyaWNJbnB1dCgpO1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mKGN1cnJlbnRWYWwpID09ICdib29sZWFuJyl7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmNoZWNrZWQgPSBjdXJyZW50VmFsO1xuICAgICAgICAgICAgdGhpcy5hY2NlcHRCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnV0dG9uLWhpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnV0dG9uLWhpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCBjdXJyZW50VmFsKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUgPSBjdXJyZW50VmFsO1xuICAgIH1cblxuICAgIHNldHVwTnVtZXJpY0lucHV0KCl7XG4gICAgICAgIGlmKHRoaXMucHJvcGVydHkubmFtZS5lbmRzV2l0aCgnLXRyYW5zcGFyZW5jeScpKXtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGVwJywgJzAuMDUnKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWluJywgJzAuMCcpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdtYXgnLCAnMS4wJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbklucHV0Q2hhbmdlKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0LnR5cGUgPT0gXCJjaGVja2JveFwiKXtcbiAgICAgICAgICAgIHRoaXMub3duZXIucGFydFByb3BlcnRpZXMuc2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uSW5wdXRJbnB1dChldmVudCl7XG4gICAgICAgIGxldCBpbnB1dFR5cGUgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgIGlmKGlucHV0VHlwZSA9PSAncmFuZ2UnKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uQWNjZXB0Q2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBpZihldmVudC50YXJnZXQudmFsdWUgIT09IHRoaXMucHJvcGVydHkuZ2V0VmFsdWUodGhpcy5vd25lcikpe1xuICAgICAgICAgICAgdGhpcy5lbmFibGVCdXR0b25zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVCdXR0b25zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkVudGVyS2V5KGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQua2V5ID09ICdFbnRlcicpe1xuICAgICAgICAgICAgdGhpcy5vbkFjY2VwdENsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmFibGVCdXR0b25zKCl7XG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIGRpc2FibGVCdXR0b25zKCl7XG4gICAgICAgIHRoaXMuYWNjZXB0QnV0dG9uLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIG9uQWNjZXB0Q2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgaWYodGhpcy5pbnB1dEVsZW1lbnQudHlwZSA9PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgaWYoaXNOYU4odmFsdWUpKXtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBwYXJzZSB0aGUgdmFsdWUganVzdCBsZXQgaXQgZ28gdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIGFzIGl0IG1pZ2h0IGJlIGEgcHJvcCBzdHlsZSBrZXl3b3JkIHN1Y2ggYXMgXCJmaWxsXCJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSBtaWdodCB3YW50IHRvIGxpbWl0IHRoaXMgdG8gYSBzZXQgb2YgcHJvcCBrZXl3b3Jkc1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnB1dEVsZW1lbnQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmlucHV0RWxlbWVudC50eXBlID09ICdyYW5nZScpe1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuaW5wdXRFbGVtZW50LnR5cGUgPT0gJ2NoZWNrYm94Jyl7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LmNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vd25lci5wYXJ0UHJvcGVydGllcy5zZXRQcm9wZXJ0eU5hbWVkKFxuICAgICAgICAgICAgdGhpcy5vd25lcixcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkubmFtZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgICB9XG5cbiAgICBvbkNhbmNlbENsaWNrKGV2ZW50KXtcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUgPSB0aGlzLm93bmVyLnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICB0aGlzLm93bmVyLFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS5uYW1lXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgICB9XG59O1xuXG5leHBvcnQge1xuICAgIEVkaXRvclByb3BJdGVtLFxuICAgIEVkaXRvclByb3BJdGVtIGFzIGRlZmF1bHRcbn07XG4iLCJpbXBvcnQgRWRpdG9yUHJvcEl0ZW0gZnJvbSAnLi9FZGl0b3JQcm9wSXRlbS5qcyc7XG5cbi8vIFBSRUFNQkxFXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdlZGl0b3ItcHJvcC1pdGVtJywgRWRpdG9yUHJvcEl0ZW0pO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhJywgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC1zaXplOiAwLjhyZW07XG4gICAgfVxuXG4gICAgI3Byb3BzLWxpc3Qge1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgfVxuICAgICNmaWx0ZXItYXJlYSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cbiAgICAjZmlsdGVyLWFyZWEgPiBpbnB1dCB7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGZvbnQtc2l6ZTogMS4wcmVtO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDZweDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogNnB4O1xuICAgICAgICBwYWRkaW5nLXRvcDogM3B4O1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogM3B4O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuOCk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBpZD1cImZpbHRlci1hcmVhXCI+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJmaWx0ZXItaW5wdXRcIiBuYW1lPVwiZmlsdGVyLWlucHV0XCIgcGxhY2Vob2xkZXI9XCJGaWx0ZXIuLi5cIi8+XG4gICAgPGJ1dHRvbiBpZD1cImNsZWFyXCI+Q2xlYXI8L2J1dHRvbj5cbjwvZGl2PlxuPHVsIGlkPVwicHJvcHMtbGlzdFwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbjwvdWw+XG5gO1xuXG5jb25zdCBzcGVjaWFsUHJvcHMgPSBbXG4gICAgJ2Nzc1N0eWxlJyxcbiAgICAnY3NzVGV4dFN0eWxlJyxcbiAgICAnaWQnLFxuICAgICduYW1lJyxcbiAgICAndGFyZ2V0JyxcbiAgICAnZXZlbnRzJyxcbiAgICAnY3VycmVudCcsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ2N1c3RvbS1wcm9wZXJ0aWVzJ1xuXTtcblxuY2xhc3MgRWRpdG9yUHJvcExpc3QgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSBhbmQgc2hhZG93IHJvb3RcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25JbnB1dCA9IHRoaXMub25JbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyQ2xlYXJDbGljayA9IHRoaXMub25GaWx0ZXJDbGVhckNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcklucHV0RWxlbWVudCA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IHRoaXMuX3NoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2NsZWFyJyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkZpbHRlckNsZWFyQ2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKGFNb2RlbCl7XG4gICAgICAgIHRoaXMubW9kZWwgPSBhTW9kZWw7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIG1haW4gRE9NIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgbGV0IGlucHV0RWwgPSB0aGlzLl9zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXItaW5wdXQnKTtcbiAgICAgICAgaW5wdXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMub25JbnB1dCk7XG4gICAgICAgIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uSW5wdXQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNvcnRlZCBjb3B5IG9mIHRoZSBwcm9wZXJ0eSBvYmplY3RzXG4gICAgICAgIHRoaXMucHJvcExpc3QgPSB0aGlzLm1vZGVsLnBhcnRQcm9wZXJ0aWVzLmFsbC5zbGljZSgpLmZpbHRlcihwcm9wID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXNwZWNpYWxQcm9wcy5pbmNsdWRlcyhwcm9wLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcExpc3RcbiAgICAgICAgICAgIC5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QubmFtZS5sb2NhbGVDb21wYXJlKHNlY29uZC5uYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBsaXN0IGl0ZW0gZWxlbWVudHMgYW5kIGluc2VydCB0aGVtXG4gICAgICAgIHRoaXMucHJvcExpc3QuZm9yRWFjaChwcm9wT2JqZWN0ID0+IHtcbiAgICAgICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1wcm9wLWl0ZW0nKTtcbiAgICAgICAgICAgIGVsLnNldFByb3BlcnR5KHByb3BPYmplY3QsIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCduYW1lJywgcHJvcE9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmaWx0ZXJCeSh0ZXh0KXtcbiAgICAgICAgLy8gRmluZCBhbGwgb2YgdGhlIHByb3AgaXRlbSBlbGVtZW50cyB3aG9zZVxuICAgICAgICAvLyBwcm9wZXJ0eSBuYW1lIGRvZXMgKm5vdCogaW5jbHVkZSB0aGUgc3Vic3RyaW5nLFxuICAgICAgICAvLyBhbmQgc2V0IHRob3NlIHRvIG5vdCBkaXNwbGF5XG4gICAgICAgIGxldCBhbGxFbGVtZW50cyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdlZGl0b3ItcHJvcC1pdGVtJykpO1xuICAgICAgICBhbGxFbGVtZW50cy5mb3JFYWNoKHByb3BFbCA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHByb3BFbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgIGlmKG5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXh0KSl7XG4gICAgICAgICAgICAgICAgcHJvcEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2l0ZW0taGlkZGVuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BFbC5jbGFzc0xpc3QuYWRkKCdpdGVtLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbklucHV0KGV2ZW50KXtcbiAgICAgICAgdGhpcy5maWx0ZXJCeShldmVudC50YXJnZXQudmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgb25GaWx0ZXJDbGVhckNsaWNrKGV2ZW50KXtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnB1dEVsZW1lbnQudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmZpbHRlckJ5KFwiXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yUHJvcExpc3QsXG4gICAgRWRpdG9yUHJvcExpc3QgYXMgZGVmYXVsdFxufTtcbiIsIi8vIFBSRUFNQkxFXG5pbXBvcnQgRWRpdG9yTG9jYXRpb25JbmZvIGZyb20gJy4vRWRpdG9yTG9jYXRpb25JbmZvLmpzJztcbmltcG9ydCBwYXJ0SWNvbnMgZnJvbSAnLi4vLi4vdXRpbHMvaWNvbnMuanMnO1xuaW1wb3J0IHtvbkxvY2F0aW9uTGlua0NsaWNrLCBnZXRMb2NhdGlvblN0cmluZ0Zvcn0gZnJvbSAnLi91dGlscy9zdWJwYXJ0cy5qcyc7XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkaXRvci1sb2NhdGlvbi1pbmZvJywgRWRpdG9yTG9jYXRpb25JbmZvKTtcblxuY29uc3QgY2xpcGJvYXJkSWNvbiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1jbGlwYm9hcmRcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+XG4gIDxwYXRoIHN0cm9rZT1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIvPlxuICA8cGF0aCBkPVwiTTkgNWgtMmEyIDIgMCAwIDAgLTIgMnYxMmEyIDIgMCAwIDAgMiAyaDEwYTIgMiAwIDAgMCAyIC0ydi0xMmEyIDIgMCAwIDAgLTIgLTJoLTJcIiAvPlxuICA8cmVjdCB4PVwiOVwiIHk9XCIzXCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMlwiIC8+XG48L3N2Zz5cbmA7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdIZWx2ZXRpY2EnLCBzYW5zLXNlcmlmO1xuICAgICAgICBmb250LXNpemU6IDAuOHJlbTtcbiAgICB9XG5cbiAgICA6aG9zdCgpID4gbGkge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XG4gICAgfVxuXG4gICAgLmlkLWxpbmssXG4gICAgLmxvY2F0aW9uLWxpbmsge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxNTAsIDE1MCwgMTUwLCAwLjMpO1xuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMC4ycyBlYXNlLW91dDtcbiAgICAgICAgdmVydGljYWwtYWxpZ25tZW50OiBjZW50ZXI7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICBwYWRkaW5nOiAwcHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMWVtO1xuICAgIH1cblxuICAgIC5pZC1saW5rOmhvdmVyLFxuICAgIC5sb2NhdGlvbi1saW5rOmhvdmVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgxNTAsIDE1MCwgMTUwLCAwLjcpO1xuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMC4ycyBlYXNlLW91dDtcbiAgICB9XG5cbiAgICAuaWQtbGluayA+IHN2ZyxcbiAgICAubG9jYXRpb24tbGluayA+IHN2ZyB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA4cHg7XG4gICAgICAgIG9wYWNpdHk6IDAuNztcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDBweCk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgLmlkLWxpbms6aG92ZXIgPiBzdmcsXG4gICAgLmxvY2F0aW9uLWxpbms6aG92ZXIgPiBzdmcge1xuICAgICAgICBvcGFjaXR5OiAxLjA7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNXB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBlYXNlLW91dDtcbiAgICB9XG5cbiAgICBzZWN0aW9uIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgbWFyZ2luOiA2cHg7XG4gICAgfVxuXG4gICAgI2J1dHRvbi1hcmVhIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47J1xuICAgIH1cblxuICAgICNzdWJwYXJ0cy1saXN0LXdyYXBwZXIge1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBvdmVyZmxvdy15OiBoaWRkZW47XG4gICAgfVxuXG4gICAgLmhpZGRlbiB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgI3N1YnBhcnRzLWFyZWEge1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBmb250LWZhbWlseTogJ0hlbHZldGljYScsIHNhbnMtc2VyaWY7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDMycHg7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgfVxuPC9zdHlsZT5cbjxzZWN0aW9uIGlkPVwiYnV0dG9uLWFyZWFcIj5cbiAgICA8c2xvdCBuYW1lPVwiYnV0dG9uXCI+PC9zbG90PlxuPC9zZWN0aW9uPlxuPHNlY3Rpb24gaWQ9XCJsb2NhdGlvbi1hcmVhXCI+XG4gICAgPGgzPlBhcnQgTG9jYXRpb24gYW5kIE93bmVyczwvaDM+XG4gICAgPHAgY2xhc3M9XCJwYXJ0LWluZm9cIj5cbiAgICAgICAgSSBhbSBsb2NhdGVkIGF0IDxidXR0b24gY2xhc3M9XCJsb2NhdGlvbi1saW5rXCI+PHNwYW4+PC9zcGFuPiR7Y2xpcGJvYXJkSWNvbn08L2J1dHRvbj5cbiAgICAgICAgYW5kIG15IGlkIGlzIDxidXR0b24gY2xhc3M9XCJpZC1saW5rXCI+PHNwYW4+PC9zcGFuPiR7Y2xpcGJvYXJkSWNvbn08L2J1dHRvbj5cbiAgICA8L3A+XG4gICAgPHNsb3QgbmFtZT1cImFuY2VzdG9yLWluZm9cIj48L3Nsb3Q+XG48L3NlY3Rpb24+XG48c2VjdGlvbiBpZD1cInN1YnBhcnRzLWxpc3Qtd3JhcHBlclwiPlxuICAgIDxoMz5TdWJwYXJ0czwvaDM+XG4gICAgPG9sIGlkPVwic3VicGFydHMtYXJlYVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9vbD5cbjwvc2VjdGlvbj5cbmA7XG5cbmNsYXNzIEVkaXRvclN1YnBhcnRzUGFuZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBkZWZpbmUgYW5kIGJpbmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uU3RyaW5nRm9yID0gZ2V0TG9jYXRpb25TdHJpbmdGb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrID0gb25Mb2NhdGlvbkxpbmtDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy5vbkFkZFN1YnBhcnQgPSB0aGlzLm9uQWRkU3VicGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU3VicGFydEl0ZW1DbGljayA9IHRoaXMub25TdWJwYXJ0SXRlbUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlRW50ZXIgPSB0aGlzLm9uU3VicGFydEl0ZW1Nb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlTGVhdmUgPSB0aGlzLm9uU3VicGFydEl0ZW1Nb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlQWRkUGFydEJ1dHRvbiA9IHRoaXMuY3JlYXRlQWRkUGFydEJ1dHRvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZVN1YnBhcnRDb21wb25lbnQgPSB0aGlzLmNyZWF0ZVN1YnBhcnRDb21wb25lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRMb2NhdGlvblZpZXdzID0gdGhpcy5nZXRMb2NhdGlvblZpZXdzLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKXtcbiAgICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCl7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckVsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbG9jYXRpb24tYXJlYScpO1xuICAgICAgICAgICAgdGhpcy5teUxvY2F0aW9uQXJlYSA9IHRoaXMuaGVhZGVyRWwucXVlcnlTZWxlY3RvcigncCcpO1xuICAgICAgICAgICAgdGhpcy5teUxvY2F0aW9uQnV0dG9uID0gdGhpcy5teUxvY2F0aW9uQXJlYS5xdWVyeVNlbGVjdG9yKCcubG9jYXRpb24tbGluaycpO1xuICAgICAgICAgICAgdGhpcy5teUlkQnV0dG9uID0gdGhpcy5teUxvY2F0aW9uQXJlYS5xdWVyeVNlbGVjdG9yKCcuaWQtbGluaycpO1xuXG4gICAgICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgdG8gYnV0dG9uc1xuICAgICAgICAgICAgdGhpcy5teUxvY2F0aW9uQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkxvY2F0aW9uTGlua0NsaWNrKTtcbiAgICAgICAgICAgIHRoaXMubXlJZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Mb2NhdGlvbkxpbmtDbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICB0aGlzLm15TG9jYXRpb25CdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2spO1xuICAgICAgICB0aGlzLm15SWRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uTG9jYXRpb25MaW5rQ2xpY2spO1xuICAgIH1cblxuICAgIHJlbmRlcihhTW9kZWwpe1xuICAgICAgICB0aGlzLm1vZGVsID0gYU1vZGVsO1xuICAgICAgICB0aGlzLmhlYWRlckVsID0gdGhpcy5fc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbG9jYXRpb24tYXJlYScpO1xuXG4gICAgICAgIC8vIENsZWFyIGFueSBET00gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuXG5cbiAgICAgICAgLy8gQ3JlYXRlIGxvY2F0aW9uIGxpbmsgZWxlbWVudHNcbiAgICAgICAgLy8gYW5kIGFsc28gdGhlIHNlbGYtbG9jYXRpb24gZWxlbWVudFxuICAgICAgICBsZXQgbXlMb2NhdGlvblRleHQgPSB0aGlzLmdldExvY2F0aW9uU3RyaW5nRm9yKHRoaXMubW9kZWwpO1xuICAgICAgICB0aGlzLm15TG9jYXRpb25CdXR0b24ucXVlcnlTZWxlY3Rvcignc3BhbicpLnRleHRDb250ZW50ID0gbXlMb2NhdGlvblRleHQ7XG4gICAgICAgIHRoaXMubXlJZEJ1dHRvbi5xdWVyeVNlbGVjdG9yKCdzcGFuJykudGV4dENvbnRlbnQgPSB0aGlzLm1vZGVsLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKHRoaXMubW9kZWwudHlwZSA9PSAnd29ybGQnKXtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGluZm8gZWxlbWVudHNcbiAgICAgICAgICAgIFsnc3RhY2snLCAnY2FyZCcsICdvd25lciddLmZvckVhY2goa2luZCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGluZm9FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2VkaXRvci1sb2NhdGlvbi1pbmZvJyk7XG4gICAgICAgICAgICAgICAgaW5mb0VsLnNldEF0dHJpYnV0ZSgnc2xvdCcsICdhbmNlc3Rvci1pbmZvJyk7XG4gICAgICAgICAgICAgICAgaW5mb0VsLnNldEF0dHJpYnV0ZSgna2luZCcsIGtpbmQpO1xuICAgICAgICAgICAgICAgIGluZm9FbC5yZW5kZXIodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChpbmZvRWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIFwiYWRkIHN1YnBhcnRcIiBidXR0b25zIGZvciBwYXJ0cyB0aGF0IGFyZSBhY2NlcHRlZCBieSB0aGVcbiAgICAgICAgLy8gY3VycmVudCBNb2RlbCBwYXJ0LlxuICAgICAgICB0aGlzLm1vZGVsLmFjY2VwdGVkU3VicGFydFR5cGVzLmZvckVhY2gocGFydFR5cGUgPT4ge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZUFkZFBhcnRCdXR0b24ocGFydFR5cGUpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGxhYmVsSGVhZGVyID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjc3VicGFydHMtbGlzdC13cmFwcGVyID4gaDMnKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC5zdWJwYXJ0cy5sZW5ndGgpe1xuICAgICAgICAgICAgbGFiZWxIZWFkZXIudGV4dENvbnRlbnQgPSBcIkN1cnJlbnQgU3VicGFydHNcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsSGVhZGVyLnRleHRDb250ZW50ID0gXCJUaGVyZSBhcmUgbm8gc3VicGFydHNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWwuc3VicGFydHMuZm9yRWFjaChzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5jcmVhdGVTdWJwYXJ0Q29tcG9uZW50KHN1YnBhcnQpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3JlYXRlU3VicGFydENvbXBvbmVudChhUGFydCl7XG4gICAgICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdzdWJwYXJ0LWl0ZW0nKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3JlZi1pZCcsIGFQYXJ0LmlkKTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25TdWJwYXJ0SXRlbUNsaWNrKTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vblN1YnBhcnRJdGVtTW91c2VFbnRlcik7XG4gICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25TdWJwYXJ0SXRlbU1vdXNlTGVhdmUpO1xuXG4gICAgICAgIC8vIEFkZCBpY29uIGFyZWEgYW4gU1ZHIGZvciBQYXJ0XG4gICAgICAgIGxldCBpY29uQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpY29uQXJlYS5jbGFzc0xpc3QuYWRkKCdpY29uLWRpc3BsYXktYXJlYScpO1xuICAgICAgICBsZXQgaWNvbkltYWdlO1xuICAgICAgICBpZihPYmplY3Qua2V5cyhwYXJ0SWNvbnMpLmluY2x1ZGVzKGFQYXJ0LnR5cGUpKXtcbiAgICAgICAgICAgIGljb25JbWFnZSA9IHBhcnRJY29uc1thUGFydC50eXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGljb25JbWFnZSA9IHBhcnRJY29ucy5nZW5lcmljO1xuICAgICAgICB9XG4gICAgICAgIGljb25BcmVhLmlubmVySFRNTCA9IGljb25JbWFnZTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoaWNvbkFyZWEpO1xuXG4gICAgICAgIC8vIEFkZCBsYWJlbCwgbmFtZSwgYW5kIGlkIGluZm9cbiAgICAgICAgbGV0IGxhYmVsQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgICAgIGxhYmVsQXJlYS50ZXh0Q29udGVudCA9IGBhICR7YVBhcnQudHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7YVBhcnQudHlwZS5zbGljZSgxKX1gO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZChsYWJlbEFyZWEpO1xuICAgICAgICBsZXQgbmFtZSA9IGFQYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICBhUGFydCxcbiAgICAgICAgICAgICduYW1lJ1xuICAgICAgICApO1xuICAgICAgICBpZihuYW1lICYmIG5hbWUgIT0gXCJcIil7XG4gICAgICAgICAgICBsZXQgbmFtZUFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBuYW1lQXJlYS5jbGFzc0xpc3QuYWRkKCduYW1lLXNwYW4nKTtcbiAgICAgICAgICAgIG5hbWVBcmVhLnRleHRDb250ZW50ID0gYFwiJHtuYW1lfVwiYDtcbiAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kKG5hbWVBcmVhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpZEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGlkQXJlYS5jbGFzc0xpc3QuYWRkKCdpZC1zcGFuJyk7XG4gICAgICAgIGlkQXJlYS50ZXh0Q29udGVudCA9IGAoJHthUGFydC5pZH0pYDtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoaWRBcmVhKTtcblxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICBjcmVhdGVBZGRQYXJ0QnV0dG9uKGFQYXJ0TmFtZSl7XG4gICAgICAgIGxldCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgbGV0IGljb24gPSBwYXJ0SWNvbnNbYVBhcnROYW1lXTtcbiAgICAgICAgaWYoIWljb24pe1xuICAgICAgICAgICAgaWNvbiA9IHBhcnRJY29ucy5nZW5lcmljO1xuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScsIGFQYXJ0TmFtZSk7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgYEFkZCBhICR7YVBhcnROYW1lfSB0byB0aGlzICR7dGhpcy5tb2RlbC50eXBlfWApO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnYWRkLXBhcnQtYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25BZGRTdWJwYXJ0KTtcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGljb247XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuXG4gICAgb25TdWJwYXJ0SXRlbUNsaWNrKGV2ZW50KXtcbiAgICAgICAgbGV0IGlkID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlZi1pZCcpO1xuICAgICAgICBsZXQgdGFyZ2V0UGFydCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW2lkXTtcbiAgICAgICAgaWYodGFyZ2V0UGFydCl7XG4gICAgICAgICAgICB3aW5kb3cuU3lzdGVtLmVkaXRvci5yZW5kZXIodGFyZ2V0UGFydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblN1YnBhcnRJdGVtTW91c2VFbnRlcihldmVudCl7XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25WaWV3cyhldmVudCkuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgdmlldy5oaWdobGlnaHQoXCJyZ2IoNTQsIDE3MiwgMTAwKVwiKTsgLy8gZ3JlZW5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25TdWJwYXJ0SXRlbU1vdXNlTGVhdmUoZXZlbnQpe1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uVmlld3MoZXZlbnQpLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25BZGRTdWJwYXJ0KGV2ZW50KXtcbiAgICAgICAgbGV0IHR5cGUgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJyk7XG4gICAgICAgIGlmKHR5cGUpe1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hbmQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiAnbmV3TW9kZWwnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5pZFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sIHRoaXMubW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIGdldExvY2F0aW9uVmlld3MoZXZlbnQpe1xuICAgICAgICBsZXQgdGFyZ2V0SWQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgncmVmLWlkJyk7XG4gICAgICAgIGxldCBzcGFuID0gZXZlbnQuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU3lzdGVtLmZpbmRWaWV3c0J5SWQodGFyZ2V0SWQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgRWRpdG9yU3VicGFydHNQYW5lLFxuICAgIEVkaXRvclN1YnBhcnRzUGFuZSBhcyBkZWZhdWx0XG59O1xuIiwiLy8gUFJFQU1CTEVcblxuY29uc3QgdGVtcGxhdGVTdHJpbmcgPSBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgcGFkZGluZzogNnB4O1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCByZ2JhKDEwMCwgMTAwLCAxMDAsIDAuNyk7XG4gICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAwLjJzIGxpbmVhciwgb3BhY2l0eSAwLjJzIGxpbmVhcjtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgfVxuXG4gICAgOmhvc3QoW2FjdGl2ZT1cInRydWVcIl0pe1xuICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgcmdiYSgyMDAsIDAsIDAsIDAuOSk7XG4gICAgICAgIG9wYWNpdHk6IDEuMDtcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyIDAuMnMgbGluZWFyLCBvcGFjaXR5IDAuMnMgbGluZWFyO1xuICAgIH1cblxuICAgIDpob3N0KDpob3Zlcil7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG48L3N0eWxlPlxuPHNwYW4gaWQ9XCJsYWJlbFwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbjwvc3Bhbj5cbmA7XG5cbmNsYXNzIEVkaXRvclRhYiBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIFNldHVwIHRlbXBsYXRlIGFuZCBzaGFkb3cgcm9vdFxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0YWIgaXMgY3VycmVudGx5IGFjdGl2YXRlZCwgZW1pdFxuICAgICAgICAgICAgLy8gdGhlIHRhYi1hY3RpdmFlZCBtZXNzYWdlXG4gICAgICAgICAgICBpZih0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlJykgPT0gXCJ0cnVlXCIpe1xuICAgICAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcInRhYi1hY3RpdmF0ZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCl7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIH1cblxuICAgIG9uQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgaXNBY3RpdmUgPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZScpID09IFwidHJ1ZVwiKTtcbiAgICAgICAgaWYoIWlzQWN0aXZlKXtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAndHJ1ZScpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwidGFiLWFjdGl2YXRlZFwiLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBFZGl0b3JUYWIsXG4gICAgRWRpdG9yVGFiIGFzIGRlZmF1bHRcbn07XG4iLCIgY29uc3QgZ2V0TG9jYXRpb25TdHJpbmdGb3IgPSAoYVBhcnQpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGxldCBjdXJyZW50UGFydCA9IGFQYXJ0O1xuICAgICAgICBsZXQgY3VycmVudE93bmVyID0gYVBhcnQuX293bmVyO1xuICAgICAgICB3aGlsZShjdXJyZW50T3duZXIpe1xuICAgICAgICAgICAgbGV0IGluZGV4SW5QYXJlbnQgPSBjdXJyZW50T3duZXIuc3VicGFydHMuZmlsdGVyKChzdWJwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSBjdXJyZW50UGFydC50eXBlO1xuICAgICAgICAgICAgfSkuaW5kZXhPZihjdXJyZW50UGFydCkgKyAxO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGAke2N1cnJlbnRQYXJ0LnR5cGV9ICR7aW5kZXhJblBhcmVudH0gb2YgYDtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJ0ID0gY3VycmVudFBhcnQuX293bmVyO1xuICAgICAgICAgICAgY3VycmVudE93bmVyID0gY3VycmVudE93bmVyLl9vd25lcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJ3RoaXMgd29ybGQnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmNvbnN0IG9uTG9jYXRpb25MaW5rQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IHRleHQgPSBldmVudC5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS50ZXh0Q29udGVudDtcbiAgICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wdXQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBpbnB1dC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoaW5wdXQpO1xuICAgICAgICBsZXQgY3VycmVudEZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0ZXh0O1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dC52YWx1ZSk7XG4gICAgICAgIGlucHV0LnNlbGVjdCgpO1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgICAgICBpbnB1dC5yZW1vdmUoKTtcbiAgICAgICAgY3VycmVudEZvY3VzLmZvY3VzKCk7XG59XG5cbmV4cG9ydCB7XG4gICAgZ2V0TG9jYXRpb25TdHJpbmdGb3IsXG4gICAgb25Mb2NhdGlvbkxpbmtDbGlja1xufTtcbiIsIi8qKlxuICogTmF2aWdhdG9yIENhcmQgUm93XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHZpZXcgb24gYSBnaXZlbiBTdGFjayB0aGF0IHNob3dzIGVhY2hcbiAqIHN1YnBhcnQgY2FyZCBpdGVtIGFzIGEgd3JhcHBlZCBsZW5zIHZpZXcgYWxvbmdcbiAqIGEgcm93LlxuICovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi4vUGFydFZpZXcuanMnO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cbjwvc3R5bGU+XG48c2xvdCBuYW1lPVwiY2FyZHNcIj48L3Nsb3Q+XG5gO1xuXG5jbGFzcyBDYXJkUm93IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgdXAgdGVtcGxhdGVcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQm91bmQgbWV0aG9kc1xuICAgICAgICB0aGlzLmluaXRWaWV3ID0gdGhpcy5pbml0Vmlldy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFdyYXBwZWRDYXJkID0gdGhpcy5hZGRXcmFwcGVkQ2FyZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UgPSB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0QWRkZWQgPSB0aGlzLmhhbmRsZVBhcnRBZGRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkID0gdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNob3dJbml0aWFsbHkgPSB0aGlzLnNob3dJbml0aWFsbHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbldyYXBwZXJDbGljayA9IHRoaXMub25XcmFwcGVyQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZnRlckNvbm5lY3RlZCgpe1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBjb250ZXh0IG1lbnUgdG8gb3BlbiBpbiB0aGUgbmF2IHNpbmNlXG4gICAgICAgIC8vIGl0IGRvZW5zJ3QgbWFrZSBzZW5zZSBhdG0gYW5kIHdpbGwgZXJyb3JcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUNsaWNrKTtcbiAgICB9XG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjYXJkLWlkJywgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlKCdjdXJyZW50JywgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBTdGFjayBNb2RlbCdzIG1haW4gdmlldyBlbGVtZW50LlxuICAgICAgICAvLyBXZSBhZGQgdGhlIHN0LXZpZXctYWRkZWQvcmVtb3ZlZCBDdXN0b21FdmVudCBsaXN0ZW5lcnNcbiAgICAgICAgLy8gaGVyZSBzbyB3ZSBjYW4gcmVhY3Qgb25seSB0byBkaXJlY3Qgc3RhY2sgYWRkaXRpb25zXG4gICAgICAgIC8vIHRvIHRoZSBTdGFjayAoYW5kIG5vdCwgc2F5LCB0byBXaW5kb3dzIG9yIG90aGVyIG5lc3RlZCBraW5kcylcbiAgICAgICAgbGV0IHN0YWNrVmlldyA9IHdpbmRvdy5TeXN0ZW0uZmluZFZpZXdCeUlkKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICBzdGFja1ZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1hZGRlZCcsIHRoaXMuaGFuZGxlUGFydEFkZGVkKTtcbiAgICAgICAgc3RhY2tWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctcmVtb3ZlZCcsIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxVbnNldChyZW1vdmVkTW9kZWwpe1xuICAgICAgICBsZXQgc3RhY2tWaWV3ID0gd2luZG93LlN5c3RlbS5maW5kVmlld0J5SWQocmVtb3ZlZE1vZGVsLmlkKTtcbiAgICAgICAgc3RhY2tWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctYWRkZWQnLCB0aGlzLmhhbmRsZVBhcnRBZGRlZCk7XG4gICAgICAgIHN0YWNrVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LXJlbW92ZWQnLCB0aGlzLmhhbmRsZVBhcnRSZW1vdmVkKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDdXJyZW50Q2hhbmdlKCl7XG4gICAgICAgIGlmKCF0aGlzLm1vZGVsLmN1cnJlbnRDYXJkKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd3JhcHBlcnMgPSBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnd3JhcHBlZC12aWV3JykpO1xuICAgICAgICB3cmFwcGVycy5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgbGV0IHdyYXBwZWRJZCA9IHdyYXBwZXIuZ2V0QXR0cmlidXRlKCd3cmFwcGVkLWlkJyk7XG4gICAgICAgICAgICBpZih3cmFwcGVkSWQgPT0gdGhpcy5tb2RlbC5jdXJyZW50Q2FyZC5pZC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdjdXJyZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZVBhcnRBZGRlZChldmVudCl7XG4gICAgICAgIC8vIFRoaXMgaGFuZGxlciBpcyBmb3IgdGhlIHN0LXZpZXctYWRkZWRcbiAgICAgICAgLy8gQ3VzdG9tRXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYnkgU3lzdGVtIHdoZW5cbiAgICAgICAgLy8gbmV3TW9kZWwoKSBoYXMgY29tcGxldGVkLlxuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ2NhcmQnKXtcbiAgICAgICAgICAgIGxldCBjYXJkUGFydCA9IHdpbmRvdy5TeXN0ZW0ucGFydHNCeUlkW2V2ZW50LmRldGFpbC5wYXJ0SWRdO1xuICAgICAgICAgICAgdGhpcy5hZGRXcmFwcGVkQ2FyZChjYXJkUGFydCk7XG4gICAgICAgICAgICB0aGlzLnNob3dJbml0aWFsbHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVBhcnRSZW1vdmVkKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdjYXJkJyl7XG4gICAgICAgICAgICBsZXQgd3JhcHBlZFZpZXcgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYHdyYXBwZWQtdmlld1t3cmFwcGVkLWlkPVwiJHtldmVudC5kZXRhaWwucGFydElkfVwiXWApO1xuICAgICAgICAgICAgaWYod3JhcHBlZFZpZXcpe1xuICAgICAgICAgICAgICAgIHdyYXBwZWRWaWV3LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIGRpc3BsYXkgb2YgYWxsIHdyYXBwZWQgdmlld3MgaW4gdGhlIHJvd1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoYHdyYXBwZWQtdmlld2ApKS5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbldyYXBwZXJDbGljayhldmVudCl7XG4gICAgICAgIGxldCB3cmFwcGVySXNDdXJyZW50ID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnY3VycmVudCcpO1xuICAgICAgICBpZih0aGlzLm1vZGVsICYmICF3cmFwcGVySXNDdXJyZW50KXtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuZ29Ub0NhcmRCeUlkKGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3dyYXBwZWQtaWQnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Vmlldygpe1xuICAgICAgICAvLyBGaXJzdCwgd2UgY2xlYXIgb3V0IGFueSBleGlzdGluZyBjaGlsZHJlblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBvdmVyIGVhY2ggY2FyZCBvZiB0aGUgc3RhY2sgYW5kOlxuICAgICAgICAvLyAqIENyZWF0ZSBhIGNsb25lIG9mIHRoZSBjYXJkIHZpZXcgZWxlbWVudDtcbiAgICAgICAgLy8gKiBBdHRhY2ggdGhlIGNvcnJlY3QgbW9kZWw7XG4gICAgICAgIC8vICogU2V0IGl0IHRvIGJlIGEgbGVuc2VkIHZpZXc7XG4gICAgICAgIC8vICogRG8gdGhlIHNhbWUgZm9yIGFsbCBjaGlsZHJlbiwgcmVjdXJzaXZlbHlcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJwYXJ0cy5maWx0ZXIoc3VicGFydCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VicGFydC50eXBlID09ICdjYXJkJztcbiAgICAgICAgfSkuZm9yRWFjaChjYXJkUGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFdyYXBwZWRDYXJkKGNhcmRQYXJ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHNldHRpbmcgdGhlIGN1cnJlbnRcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlKCk7XG4gICAgfVxuXG4gICAgc2hvd0luaXRpYWxseSgpe1xuICAgICAgICAvLyBOb3RoaW5nIGZvciBub3dcbiAgICB9XG5cbiAgICBhZGRXcmFwcGVkQ2FyZChhQ2FyZCl7XG4gICAgICAgIC8vIEluc2VydCB0aGUgbGVuc2VkIENhcmRWaWV3IGludG8gdGhlIHdyYXBwZXJcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd3cmFwcGVkLXZpZXcnKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnY2FyZHMnKTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25XcmFwcGVyQ2xpY2spO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICB3cmFwcGVyLnNldE1vZGVsKGFDYXJkKTtcbiAgICB9XG5cbiAgICBzdWJwYXJ0T3JkZXJDaGFuZ2VkKGlkLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4KXtcbiAgICAgICAgbGV0IHN1YnBhcnROb2RlID0gdGhpcy5jaGlsZE5vZGVzW2N1cnJlbnRJbmRleF07XG4gICAgICAgIGlmKCFzdWJwYXJ0Tm9kZSl7XG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgbW9kZWwgc3VicGFydCB3aGljaCBpcyBub3QgYSBjYXJkIGFuZCBoZW5jZSBub3RcbiAgICAgICAgICAgIC8vIGRpc3BsYXllZCBpbiB0aGUgQ2FyZFJvd1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKG5ld0luZGV4ID09IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3VicGFydE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhY2NvdW50IGZvciB3aGV0aGVyIHRoZSBpbmRleCBvZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIG5ld0luZGV4XG4gICAgICAgICAgICBpZihjdXJyZW50SW5kZXggPCBuZXdJbmRleCl7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tuZXdJbmRleF07XG4gICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShzdWJwYXJ0Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIG51bWJlciBkaXNwbGF5IG9mIGFsbCB3cmFwcGVkIHZpZXdzIGluIHRoZSByb3dcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoYHdyYXBwZWQtdmlld2ApKS5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgd3JhcHBlci51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufTtcblxuZXhwb3J0IHtcbiAgICBDYXJkUm93LFxuICAgIENhcmRSb3cgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogU2ltcGxlVGFsayBOYXZpZ2F0b3IgV2ViY29tcG9uZW50XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRoaXMgaXMgYSBzdGFuZGFsb25lIGNvbXBvbmVudCB0aGF0IGFsbG93c1xuICogYXV0aG9ycyB0byBuYXZpZ2F0ZSB0aGUgV29ybGRTdGFjayBhbmQgaW5kaXZpZHVhbFxuICogU3RhY2tzIHRoZXJlaW4gdXNpbmcgYSBjb252ZW5pZW50IHBvcC1vdXQgdHJheSBmcm9tXG4gKiB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uXG4gKiovXG5pbXBvcnQgUGFydFZpZXcgZnJvbSAnLi4vUGFydFZpZXcuanMnO1xuaW1wb3J0IFdyYXBwZWRWaWV3IGZyb20gJy4vV3JhcHBlZFZpZXcuanMnO1xuaW1wb3J0IFN0YWNrUm93IGZyb20gJy4vU3RhY2tSb3cuanMnO1xuaW1wb3J0IENhcmRSb3cgZnJvbSAnLi9DYXJkUm93LmpzJztcblxuLy8gQWRkIGFueSBuZWVkZWQgY3VzdG9tRWxlbWVudHNcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ25hdi1zdGFjay1yb3cnLCBTdGFja1Jvdyk7XG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCduYXYtY2FyZC1yb3cnLCBDYXJkUm93KTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3dyYXBwZWQtdmlldycsIFdyYXBwZWRWaWV3KTtcblxuY29uc3Qgc3RhY2tJY29uID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJpY29uIGljb24tdGFibGVyIGljb24tdGFibGVyLXN0YWNrXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxuICAgPHBhdGggc3Ryb2tlPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIj48L3BhdGg+XG4gICA8cG9seWxpbmUgcG9pbnRzPVwiMTIgNCA0IDggMTIgMTIgMjAgOCAxMiA0XCI+PC9wb2x5bGluZT5cbiAgIDxwb2x5bGluZSBwb2ludHM9XCI0IDEyIDEyIDE2IDIwIDEyXCI+PC9wb2x5bGluZT5cbiAgIDxwb2x5bGluZSBwb2ludHM9XCI0IDE2IDEyIDIwIDIwIDE2XCI+PC9wb2x5bGluZT5cbjwvc3ZnPlxuYDtcblxuY29uc3QgY2FyZEljb24gPSBgXG48c3ZnXG4gICB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCJcbiAgIHhtbG5zOmNjPVwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXCJcbiAgIHhtbG5zOnJkZj1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIlxuICAgeG1sbnM6c3ZnPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICBjbGFzcz1cImljb24gaWNvbi10YWJsZXIgaWNvbi10YWJsZXItc3RhY2tcIlxuICAgd2lkdGg9XCI1MFwiXG4gICBoZWlnaHQ9XCIyMC44MzMzMDlcIlxuICAgdmlld0JveD1cIjAgMCAyNCA5Ljk5OTk4ODRcIlxuICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgZmlsbD1cIm5vbmVcIlxuICAgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiXG4gICBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiXG4gICB2ZXJzaW9uPVwiMS4xXCJcbiAgIGlkPVwic3ZnODkzXCI+XG4gIDxtZXRhZGF0YVxuICAgICBpZD1cIm1ldGFkYXRhODk5XCI+XG4gICAgPHJkZjpSREY+XG4gICAgICA8Y2M6V29ya1xuICAgICAgICAgcmRmOmFib3V0PVwiXCI+XG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxuICAgICAgICA8ZGM6dHlwZVxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVwiIC8+XG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxuICAgICAgPC9jYzpXb3JrPlxuICAgIDwvcmRmOlJERj5cbiAgPC9tZXRhZGF0YT5cbiAgPGRlZnNcbiAgICAgaWQ9XCJkZWZzODk3XCIgLz5cbiAgPHBhdGhcbiAgICAgc3Ryb2tlPVwibm9uZVwiXG4gICAgIGQ9XCJNIC0yLjc2NjkxNTEsLTEuMjU2NDk0OCBIIDIxLjIzMzA4NSBWIDIyLjc0MzUwNSBIIC0yLjc2NjkxNTEgWlwiXG4gICAgIGZpbGw9XCJub25lXCJcbiAgICAgaWQ9XCJwYXRoODg1XCIgLz5cbiAgPHBvbHlsaW5lXG4gICAgIHBvaW50cz1cIjEyIDQgNCA4IDEyIDEyIDIwIDggMTIgNFwiXG4gICAgIGlkPVwicG9seWxpbmU4ODdcIlxuICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwtMylcIiAvPlxuPC9zdmc+XG5gO1xuXG5jb25zdCB0ZW1wbGF0ZVN0cmluZyA9IGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbWluLWhlaWdodDogMjcxcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQ7XG4gICAgICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDAlKTtcbiAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYmEoNTAsIDUwLCA1MCwgMC40KTtcbiAgICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgICAgICBvdmVyZmxvdy14OiBhdXRvO1xuICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgIH1cblxuICAgIC5uYXYtZGlzcGxheS1yb3cge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMTVweDtcbiAgICB9XG4gICAgLm5hdi1pY29uIHtcbiAgICAgICAgY29sb3I6IGdyYXk7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMzBweDtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBpZD1cInN0YWNrcy1kaXNwbGF5XCIgY2xhc3M9XCJuYXYtZGlzcGxheS1yb3dcIj5cbiAgICA8ZGl2IGlkPVwic3RhY2staWNvblwiIGNsYXNzPVwibmF2LWljb25cIj4ke3N0YWNrSWNvbn08L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwic3RhY2stcm93XCI+PC9zbG90PlxuPC9kaXY+XG48ZGl2IGlkPVwiY2FyZHMtZGlzcGxheVwiIGNsYXNzPVwibmF2LWRpc3BsYXktcm93XCI+XG4gICAgPGRpdiBpZD1cImNhcmQtaWNvblwiIGNsYXNzPVwibmF2LWljb25cIj4ke2NhcmRJY29ufTwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJjYXJkLXJvd1wiPjwvc2xvdD5cbjwvZGl2PlxuYDtcblxuY2xhc3MgU1ROYXZpZ2F0b3IgZXh0ZW5kcyBQYXJ0VmlldyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRlbXBsYXRlXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmlubmVySFRNTCA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICB0aGlzLl9zaGFkb3dSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJvdW5kIG1ldGhvZHNcbiAgICAgICAgdGhpcy50b2dnbGUgPSB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW4gPSB0aGlzLm9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlID0gdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydEFkZGVkID0gdGhpcy5oYW5kbGVQYXJ0QWRkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCA9IHRoaXMuaGFuZGxlUGFydFJlbW92ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDYXJkUm93Rm9yID0gdGhpcy5jcmVhdGVDYXJkUm93Rm9yLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgY29udGV4dCBtZW51IHRvIG9wZW4gaW4gdGhlIG5hdiBzaW5jZVxuICAgICAgICAvLyBpdCBkb2Vucyd0IG1ha2Ugc2Vuc2UgYXRtIGFuZCB3aWxsIGVycm9yXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVDbGljayk7XG4gICAgfVxuXG4gICAgYWZ0ZXJEaXNjb25uZWN0ZWQoKXtcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICB3b3JsZFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFNldCgpe1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgncGFydC1pZCcpO1xuXG4gICAgICAgIC8vIFJlc3BvbmQgdG8gdGhlIFN5c3RlbSBwYXJ0LWFkZGVkIEN1c3RvbUV2ZW50XG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpO1xuICAgICAgICB3b3JsZFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1hZGRlZCcsIHRoaXMuaGFuZGxlUGFydEFkZGVkKTtcbiAgICAgICAgd29ybGRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctcmVtb3ZlZCcsIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQpO1xuXG4gICAgICAgIC8vIEFkZCBhIFN0YWNrUm93IHZpZXcuXG4gICAgICAgIHRoaXMuc3RhY2tSb3dFbCA9IHRoaXMucXVlcnlTZWxlY3RvcignOnNjb3BlID4gbmF2LXN0YWNrLXJvdycpO1xuICAgICAgICBpZighdGhpcy5zdGFja1Jvd0VsKXtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tSb3dFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25hdi1zdGFjay1yb3cnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tSb3dFbC5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnc3RhY2stcm93Jyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuc3RhY2tSb3dFbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja1Jvd0VsLnNldE1vZGVsKHRoaXMubW9kZWwpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbnkgbmVlZGVkIENhcmRSb3cgdmlld3MgZm9yIGFsbCBzdGFja3NcbiAgICAgICAgLy8gY3VycmVudGx5IGluIHRoZSB3b3JsZFxuICAgICAgICB0aGlzLm1vZGVsLnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gJ3N0YWNrJztcbiAgICAgICAgfSkuZm9yRWFjaChzdGFja1BhcnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDYXJkUm93Rm9yKHN0YWNrUGFydCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluaXQgdGhlIFN0YWNrUm93XG4gICAgICAgIHRoaXMuc3RhY2tSb3dFbC5pbml0VmlldygpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNhcmQvc3RhY2sgdmFsdWVzXG4gICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSgpO1xuXG4gICAgICAgIC8vIFJlc3BvbmQgdG8gZXZlbnR1YWwgY3VycmVudC1uZXNzIHByb3BcbiAgICAgICAgLy8gY2hhbmdlcyBmcm9tIHRoZSBXb3JsZFN0YWNrLlxuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY3VycmVudCcsIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ3VycmVudENoYW5nZSgpe1xuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhpcyBtZWFucyB0aGF0IHRoZSBjdXJyZW50ICpzdGFjayogaGFzIGNoYW5nZWQuXG4gICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gZmluZCB0aGUgY29ycmVjdCBDYXJkUm93IGZvciBpdCBhbmQgc2V0IGl0XG4gICAgICAgIC8vIHRvIGJlIHRoZSBzbG90dGVkIG9uZSBpbiB0aGUgc2hhZG93IERPTVxuICAgICAgICBsZXQgY3VycmVudFN0YWNrSWQgPSB0aGlzLm1vZGVsLmN1cnJlbnRTdGFjay5pZC50b1N0cmluZygpO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnbmF2LWNhcmQtcm93JykpLmZvckVhY2goY2FyZFJvdyA9PiB7XG4gICAgICAgICAgICBsZXQgcm93SWQgPSBjYXJkUm93LmdldEF0dHJpYnV0ZSgnc3RhY2staWQnKTtcbiAgICAgICAgICAgIGNhcmRSb3cucmVtb3ZlQXR0cmlidXRlKCdzbG90Jyk7XG4gICAgICAgICAgICBpZihjdXJyZW50U3RhY2tJZCA9PSByb3dJZCl7XG4gICAgICAgICAgICAgICAgY2FyZFJvdy5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCAnY2FyZC1yb3cnKTtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGNhcmRSb3cucXVlcnlTZWxlY3RvckFsbCgnd3JhcHBlZC12aWV3JykpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIudXBkYXRlU2NhbGluZygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVQYXJ0QWRkZWQoZXZlbnQpe1xuICAgICAgICAvLyBJZiBhIG5ldyBzdGFjayBpcyBhZGRlZCwgd2UgbmVlZCB0byBjcmVhdGVcbiAgICAgICAgLy8gYSBuZXcgQ2FyZFJvdyBmb3IgaXQuXG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIGxldCBzdGFja1BhcnQgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtldmVudC5kZXRhaWwucGFydElkXTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2FyZFJvd0ZvcihzdGFja1BhcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlUGFydFJlbW92ZWQoZXZlbnQpe1xuICAgICAgICAvLyBJZiBhIHN0YWNrIGhhcyBiZWVuIHJlbW92ZWQsIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb3JyZXNwb25kaW5nIENhcmRSb3dcbiAgICAgICAgaWYoZXZlbnQuZGV0YWlsLnBhcnRUeXBlID09ICdzdGFjaycpe1xuICAgICAgICAgICAgbGV0IGNhcmRSb3cgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYFtzdGFjay1pZD1cIiR7ZXZlbnQuZGV0YWlsLnBhcnRJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmKGNhcmRSb3cpe1xuICAgICAgICAgICAgICAgIGNhcmRSb3cucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVDYXJkUm93Rm9yKGFTdGFjayl7XG4gICAgICAgIGxldCBjYXJkUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmF2LWNhcmQtcm93Jyk7XG4gICAgICAgIGNhcmRSb3cuc2V0QXR0cmlidXRlKCdzdGFjay1pZCcsIGFTdGFjay5pZCk7XG4gICAgICAgIGNhcmRSb3cuc2V0TW9kZWwoYVN0YWNrKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjYXJkUm93KTtcbiAgICAgICAgY2FyZFJvdy5pbml0VmlldygpO1xuICAgIH1cblxuICAgIHRvZ2dsZSgpe1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKTtcbiAgICAgICAgaWYodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ29wZW4nKSl7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW4oKXtcbiAgICAgICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVkoMClcIjtcbiAgICB9XG5cbiAgICBjbG9zZSgpe1xuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgxMDAlKVwiO1xuICAgIH1cblxuICAgIFxufTtcblxuZXhwb3J0IHtcbiAgICBTVE5hdmlnYXRvcixcbiAgICBTVE5hdmlnYXRvciBhcyBkZWZhdWx0XG59O1xuIiwiLyoqXG4gKiBOYXZpZ2F0b3IgU3RhY2sgUm93XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSSBhbSBhIHZpZXcgb24gdGhlIFdvcmxkU3RhY2sgdGhhdCBzaG93cyBlYWNoXG4gKiBzdWJwYXJ0IHN0YWNrIGl0ZW0gYXMgYSB3cmFwcGVkIGxlbnMgdmlldyBhbG9uZ1xuICogYSByb3cuXG4gKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgfVxuPC9zdHlsZT5cbjxzbG90IG5hbWU9XCJzdGFja3NcIj48L3Nsb3Q+XG5gO1xuXG5jbGFzcyBTdGFja1JvdyBleHRlbmRzIFBhcnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndhbnRzSGFsbyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCB1cCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgdGhpcy5fc2hhZG93Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCb3VuZCBtZXRob2RzXG4gICAgICAgIHRoaXMuaW5pdFZpZXcgPSB0aGlzLmluaXRWaWV3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkV3JhcHBlZFN0YWNrID0gdGhpcy5hZGRXcmFwcGVkU3RhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlID0gdGhpcy5oYW5kbGVDdXJyZW50Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydEFkZGVkID0gdGhpcy5oYW5kbGVQYXJ0QWRkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCA9IHRoaXMuaGFuZGxlUGFydFJlbW92ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zaG93SW5pdGlhbGx5ID0gdGhpcy5zaG93SW5pdGlhbGx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25XcmFwcGVyQ2xpY2sgPSB0aGlzLm9uV3JhcHBlckNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDb25uZWN0ZWQoKXtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgY29udGV4dCBtZW51IHRvIG9wZW4gaW4gdGhlIG5hdiBzaW5jZVxuICAgICAgICAvLyBpdCBkb2Vucyd0IG1ha2Ugc2Vuc2UgYXRtIGFuZCB3aWxsIGVycm9yXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVDbGljayk7XG4gICAgfVxuXG5cbiAgICBhZnRlck1vZGVsU2V0KCl7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGFjay1pZCcsIHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB0aGlzLm9uUHJvcENoYW5nZSgnY3VycmVudCcsIHRoaXMuaGFuZGxlQ3VycmVudENoYW5nZSk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgV29ybGQgTW9kZWwncyBtYWluIHZpZXcgZWxlbWVudC5cbiAgICAgICAgLy8gV2UgYWRkIHRoZSBzdC12aWV3LWFkZGVkIEN1c3RvbUV2ZW50IGxpc3RlbmVyXG4gICAgICAgIC8vIGhlcmUgc28gd2UgY2FuIHJlYWN0IG9ubHkgdG8gZGlyZWN0IHN0YWNrIGFkZGl0aW9uc1xuICAgICAgICAvLyB0byB0aGUgV29ybGRTdGFjayAoYW5kIG5vdCwgc2F5LCB0byBXaW5kb3dzIG9yIG90aGVyIG5lc3RlZCBraW5kcylcbiAgICAgICAgbGV0IHdvcmxkVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0LXdvcmxkJyk7XG4gICAgICAgIHdvcmxkVmlldy5hZGRFdmVudExpc3RlbmVyKCdzdC12aWV3LWFkZGVkJywgdGhpcy5oYW5kbGVQYXJ0QWRkZWQpO1xuICAgICAgICB3b3JsZFZpZXcuYWRkRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1yZW1vdmVkJywgdGhpcy5oYW5kbGVQYXJ0UmVtb3ZlZCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJNb2RlbFVuc2V0KCl7XG4gICAgICAgIGxldCB3b3JsZFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdC13b3JsZCcpO1xuICAgICAgICB3b3JsZFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3Qtdmlldy1hZGRlZCcsIHRoaXMuaGFuZGxlUGFydEFkZGVkKTtcbiAgICAgICAgd29ybGRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0LXZpZXctcmVtb3ZlZCcsIHRoaXMuaGFuZGxlUGFydFJlbW92ZWQpO1xuICAgIH1cblxuICAgIGhhbmRsZUN1cnJlbnRDaGFuZ2UoKXtcbiAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHRoaXMubW9kZWwuY3VycmVudFN0YWNrLmlkO1xuICAgICAgICBsZXQgd3JhcHBlZFZpZXdzID0gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvckFsbCgnd3JhcHBlZC12aWV3JylcbiAgICAgICAgKTtcbiAgICAgICAgd3JhcHBlZFZpZXdzLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlZElkID0gd3JhcHBlci5nZXRBdHRyaWJ1dGUoJ3dyYXBwZWQtaWQnKTtcbiAgICAgICAgICAgIGlmKHdyYXBwZWRJZCA9PSB0aGlzLm1vZGVsLmN1cnJlbnRTdGFjay5pZC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdjdXJyZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZVBhcnRBZGRlZChldmVudCl7XG4gICAgICAgIC8vIFRoaXMgaGFuZGxlciBpcyBmb3IgdGhlIHN0LXZpZXctYWRkZWRcbiAgICAgICAgLy8gQ3VzdG9tRXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYnkgU3lzdGVtIHdoZW5cbiAgICAgICAgLy8gbmV3TW9kZWwoKSBoYXMgY29tcGxldGVkLlxuICAgICAgICBpZihldmVudC5kZXRhaWwucGFydFR5cGUgPT0gJ3N0YWNrJyl7XG4gICAgICAgICAgICBsZXQgc3RhY2tQYXJ0ID0gd2luZG93LlN5c3RlbS5wYXJ0c0J5SWRbZXZlbnQuZGV0YWlsLnBhcnRJZF07XG4gICAgICAgICAgICB0aGlzLmFkZFdyYXBwZWRTdGFjayhzdGFja1BhcnQpO1xuICAgICAgICAgICAgdGhpcy5zaG93SW5pdGlhbGx5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVQYXJ0UmVtb3ZlZChldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LmRldGFpbC5wYXJ0VHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgIGxldCB3cmFwcGVkVmlldyA9IHRoaXMucXVlcnlTZWxlY3Rvcihgd3JhcHBlZC12aWV3W3dyYXBwZWQtaWQ9XCIke2V2ZW50LmRldGFpbC5wYXJ0SWR9XCJdYCk7XG4gICAgICAgICAgICBpZih3cmFwcGVkVmlldyl7XG4gICAgICAgICAgICAgICAgd3JhcHBlZFZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBudW1iZXJzIG9mIHJlbWFpbmluZyB3cmFwcGVkIHZpZXdzIGluIHRoaXMgU3RhY2tSb3dcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd3cmFwcGVkLXZpZXcnKSkuZm9yRWFjaCh3cmFwcGVyID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25XcmFwcGVyQ2xpY2soZXZlbnQpe1xuICAgICAgICBsZXQgd3JhcHBlcklzQ3VycmVudCA9IGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2N1cnJlbnQnKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbCAmJiAhd3JhcHBlcklzQ3VycmVudCl7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLmdvVG9TdGFja0J5SWQoXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnd3JhcHBlZC1pZCcpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFZpZXcoKXtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyB3cmFwcGVkIHZpZXdzXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAvLyBXZSBpdGVyYXRlIG92ZXIgZWFjaCBjb3JyZXNwb25kaW5nIFN0YWNrIGFuZDpcbiAgICAgICAgLy8gKiBDcmVhdGUgYSBjbG9uZSBvZiBpdHMgdmlldyBub2RlO1xuICAgICAgICAvLyAqIEF0dGFjaCB0aGUgY29ycmVjdCBtb2RlbDtcbiAgICAgICAgLy8gKiBTZXQgaXQgdG8gYmUgYSBsZW5zZWQgdmlld1xuICAgICAgICAvLyAqIERvIHRoZSBzYW1lIGZvciBhbGwgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5XG4gICAgICAgIHRoaXMubW9kZWwuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSAnc3RhY2snO1xuICAgICAgICB9KS5mb3JFYWNoKHN0YWNrUGFydCA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFdyYXBwZWRTdGFjayhzdGFja1BhcnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXR1cCB0aGUgaW5pdGlhbCBjdXJyZW50LW5lc3MgZGlzcGxheVxuICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzaG93SW5pdGlhbGx5KCl7XG4gICAgICAgIC8vIE5vdGhpbmcgZm9yIG5vd1xuICAgIH1cblxuICAgIGFkZFdyYXBwZWRTdGFjayhhU3RhY2speyAgXG4gICAgICAgIC8vIEluc2VydCB0aGUgbGVuc2VkIFN0YWNrVmlldyBpbnRvIHRoZSB3cmFwcGVyXG4gICAgICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnd3JhcHBlZC12aWV3Jyk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwic2xvdFwiLCBcInN0YWNrc1wiKTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25XcmFwcGVyQ2xpY2spO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICB3cmFwcGVyLnNldE1vZGVsKGFTdGFjayk7XG4gICAgfVxuXG4gICAgc3VicGFydE9yZGVyQ2hhbmdlZChpZCwgY3VycmVudEluZGV4LCBuZXdJbmRleCl7XG4gICAgICAgIGxldCBzdWJwYXJ0Tm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICBpZighc3VicGFydE5vZGUpe1xuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIG1vZGVsIHN1YnBhcnQgd2hpY2ggaXMgbm90IGEgc3RhY2sgYW5kIGhlbmNlIG5vdFxuICAgICAgICAgICAgLy8gZGlzcGxheWVkIGluIHRoZSBTdGFja1Jvd1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKG5ld0luZGV4ID09IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3VicGFydE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhY2NvdW50IGZvciB3aGV0aGVyIHRoZSBpbmRleCBvZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIG5ld0luZGV4XG4gICAgICAgICAgICBpZihjdXJyZW50SW5kZXggPCBuZXdJbmRleCl7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tuZXdJbmRleF07XG4gICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShzdWJwYXJ0Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIG51bWJlciBkaXNwbGF5IG9mIGFsbCB3cmFwcGVkIHZpZXdzIGluIHRoZSByb3dcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoYHdyYXBwZWQtdmlld2ApKS5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgd3JhcHBlci51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7XG4gICAgU3RhY2tSb3csXG4gICAgU3RhY2tSb3cgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogV3JhcHBlZFZpZXcgQ29tcG9uZW50XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEkgYW0gYSBwbGFpbiBXZWJjb21wb25lbnQgd2hvc2UgcHVycG9zZSBpcyB0b1xuICogd3JhcCBhIHZpc3VhbCBjb3B5IG9mIGFuIGFjdHVhbCBTaW1wbGVUYWxrIFZpZXdcbiAqIGVsZW1lbnQgYW5kIGRpc3BsYXkgaXQgaW4gYSBzY2FsZWQgZG93biBmb3JtYXQuXG4gKiBJIG1ha2UgYSBjbG9uZWQgY29weSBvZiB0aGUgdW5kZXJseWluZyB2aWV3IGFuZFxuICogYXR0YWNoIGl0IHRvIHRoZSBzYW1lIG1vZGVsIGFzIHRoZSBvcmlnaW5hbC5cbiAqKi9cbmltcG9ydCBQYXJ0VmlldyBmcm9tICcuLi9QYXJ0Vmlldy5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlU3RyaW5nID0gYFxuPHN0eWxlPlxuICAgICNudW1iZXItZGlzcGxheSB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlLWluO1xuICAgICAgICBmb250LXNpemU6IDIuMnJlbTtcbiAgICB9XG5cbiAgICAjbnVtYmVyLWRpc3BsYXkgPiBzcGFuIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMHB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgbGluZWFyO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICA6aG9zdCg6bm90KC5jdXJyZW50KSkgPiAjbnVtYmVyLWRpc3BsYXkge1xuICAgICAgICBvcGFjaXR5OiAwLjg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC41KTtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2Utb3V0O1xuICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgIH1cblxuICAgIDpob3N0KDpub3QoLmN1cnJlbnQpKSA+ICNudW1iZXItZGlzcGxheSA+IHNwYW4ge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMHB4KTtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgbGluZWFyO1xuICAgIH1cbjwvc3R5bGU+XG48ZGl2IGlkPVwibnVtYmVyLWRpc3BsYXlcIj5cbiAgICA8c3Bhbj48L3NwYW4+XG48L2Rpdj5cbjxzbG90IG5hbWU9XCJ3cmFwcGVkLXZpZXdcIj48L3Nsb3Q+XG5gO1xuXG5cbmNsYXNzIFdyYXBwZWRWaWV3IGV4dGVuZHMgUGFydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2FudHNIYWxvID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRlbXBsYXRlIGFuZCBzaGFkb3dEb21cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgIHRoaXMuX3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmluZCBtZXRob2RzXG4gICAgICAgIHRoaXMub25DaGlsZFNsb3R0ZWQgPSB0aGlzLm9uQ2hpbGRTbG90dGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2NhbGluZyA9IHRoaXMudXBkYXRlU2NhbGluZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZU51bWJlckNoYW5nZSA9IHRoaXMuaGFuZGxlTnVtYmVyQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkV3JhcHBlZFZpZXcgPSB0aGlzLmFkZFdyYXBwZWRWaWV3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZWx5VXBkYXRlTGVuc1ZpZXdzID0gdGhpcy5fcmVjdXJzaXZlbHlVcGRhdGVMZW5zVmlld3MuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBpZih0aGlzLmlzQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIC8vIEJpbmQgYSBsaXN0ZW5lciBmb3IgdGhlIHNsb3QgY2hhbmdlLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuZXZlciBhbnlcbiAgICAgICAgICAgIC8vIHVuZGVybHlpbmcgZWxlbWVudCBpcyBzbG90dGVkLCBzbyB3ZVxuICAgICAgICAgICAgLy8ga25vdyB0byByZWNvbXB1dGUgdGhlIGFwcHJvcHJpYXRlIHNpemluZ1xuICAgICAgICAgICAgLy8gYW5kIHN0eWxpbmdcbiAgICAgICAgICAgIGxldCBzbG90RWwgPSB0aGlzLl9zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3Nsb3QnKTtcbiAgICAgICAgICAgIHNsb3RFbC5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5vbkNoaWxkU2xvdHRlZCk7XG5cbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIGNvbnRleHQgbWVudSB0byBvcGVuIGluIHRoZSBuYXYgc2luY2VcbiAgICAgICAgICAgIC8vIGl0IGRvZW5zJ3QgbWFrZSBzZW5zZSBhdG0gYW5kIHdpbGwgZXJyb3JcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVDbGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpe1xuICAgICAgICBsZXQgc2xvdEVsID0gdGhpcy5fc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzbG90Jyk7XG4gICAgICAgIHNsb3RFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5vbkNoaWxkU2xvdHRlZCk7XG4gICAgfVxuXG4gICAgb25DaGlsZFNsb3R0ZWQoZXZlbnQpe1xuICAgICAgICAvL3RoaXMudXBkYXRlU2NhbGluZygpO1xuICAgICAgICAvL3RoaXMudXBkYXRlTnVtYmVyRGlzcGxheSgpO1xuICAgIH1cblxuICAgIGFmdGVyTW9kZWxTZXQoKXtcbiAgICAgICAgdGhpcy5vblByb3BDaGFuZ2UoJ251bWJlcicsIHRoaXMuaGFuZGxlTnVtYmVyQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgdGhpcy5hZGRXcmFwcGVkVmlldyh0aGlzLm1vZGVsKTtcbiAgICAgICAgdGhpcy51cGRhdGVOdW1iZXJEaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2NhbGluZygpe1xuICAgICAgICBsZXQgZmlyc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bMF07XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZmluZCB0aGUgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAgICAvLyBhY3R1YWwgdmlldyBmb3IgdGhlIGxlbnMtZWQgcGFydCwgaW4gb3JkZXIgdG8gZ2V0XG4gICAgICAgIC8vIGl0cyBjdXJyZW50IGRpbWVuc2lvbnMuXG4gICAgICAgIGxldCBwYXJ0SWQgPSBmaXJzdENoaWxkLmdldEF0dHJpYnV0ZSgnbGVucy1wYXJ0LWlkJyk7XG4gICAgICAgIGxldCByZWZFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3Qtd29ybGRgKTtcbiAgICAgICAgbGV0IHdyYXBCb3ggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgaW5uZXJCb3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdC13b3JsZGApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2NhbGluZ1ggPSAod3JhcEJveC53aWR0aCAvIGlubmVyQm94LndpZHRoKTtcbiAgICAgICAgbGV0IHJlZkVsZW1lbnRCb3ggPSByZWZFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBmaXJzdENoaWxkLnN0eWxlLndpZHRoID0gYCR7cmVmRWxlbWVudEJveC53aWR0aH1weGA7XG4gICAgICAgIGZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gYCR7cmVmRWxlbWVudEJveC5oZWlnaHR9cHhgO1xuICAgICAgICBmaXJzdENoaWxkLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3NjYWxpbmdYfSlgO1xuICAgICAgICBmaXJzdENoaWxkLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwiMHB4IDBweFwiO1xuICAgIH1cblxuICAgIHVwZGF0ZU51bWJlckRpc3BsYXkoKXtcbiAgICAgICAgbGV0IGZpcnN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuWzBdO1xuICAgICAgICBsZXQgbW9kZWwgPSBmaXJzdENoaWxkLm1vZGVsO1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gbG9vayBhdCBzdWJwYXJ0cyBvZiB0aGUgc2FtZSB0eXBlIChzdGFjayBvciBjYXJkKVxuICAgICAgICBsZXQgc3VicGFydHMgPSBtb2RlbC5fb3duZXIuc3VicGFydHMuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwudHlwZSA9PSBwYXJ0LnR5cGU7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbnVtRGlzcGxheSA9IHRoaXMuX3NoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI251bWJlci1kaXNwbGF5ID4gc3BhbicpO1xuICAgICAgICBudW1EaXNwbGF5LmlubmVyVGV4dCA9IHN1YnBhcnRzLmluZGV4T2YobW9kZWwpICsgMTtcbiAgICB9XG5cbiAgICBoYW5kbGVOdW1iZXJDaGFuZ2UoKXtcbiAgICAgICAgLy8gVXBkYXRlIG51bWJlciBkaXNwbGF5IG9mIGFsbCB3cmFwcGVkIHZpZXdzIGluIHRoZSByb3dcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChgd3JhcHBlZC12aWV3YCkpLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLnVwZGF0ZU51bWJlckRpc3BsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkV3JhcHBlZFZpZXcoYVBhcnRNb2RlbCl7XG4gICAgICAgIC8vIEZpcnN0LCBjbGVhciBvdXQgYW55IGV4aXN0aW5nXG4gICAgICAgIC8vIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAvLyBDcmVhdGUgYSBsZW5zZWQgY29weSBvZiB0aGUgZ2l2ZW5cbiAgICAgICAgLy8gdmlldyBhbmQgdXBkYXRlIGtleSBhdHRyaWJ1dGVzIG9uIGl0XG4gICAgICAgIGxldCBvcmlnaW5hbFZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbcGFydC1pZD1cIiR7YVBhcnRNb2RlbC5pZH1cIl1gKTtcbiAgICAgICAgbGV0IGxlbnNlZFZpZXcgPSBvcmlnaW5hbFZpZXcuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBsZW5zZWRWaWV3LnNldEF0dHJpYnV0ZSgnbGVucy1wYXJ0LWlkJywgYVBhcnRNb2RlbC5pZCk7XG4gICAgICAgIGxlbnNlZFZpZXcuc2V0QXR0cmlidXRlKCdzbG90JywgJ3dyYXBwZWQtdmlldycpO1xuICAgICAgICBsZW5zZWRWaWV3LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgbGVuc2VkVmlldy53YW50c0hhbG8gPSBmYWxzZTtcblxuICAgICAgICAvLyBJbmxpbmUgdGhlIGluaXRpYWwgc2NhbGluZyBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBXZSBiZWdpbiB3aXRoIGFuIGV4dHJlbWVseSBzbWFsbCBhbW91bnQgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBhZGp1c3RlZCBsYXRlciBkdXJpbmcgdXBkYXRlU2NhbGluZygpO1xuICAgICAgICBsZW5zZWRWaWV3LnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgkezAuMDAxfSlgO1xuICAgICAgICBsZW5zZWRWaWV3LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwiMHB4IDBweFwiO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY3JlYXRlIGxlbnMgdmlld3Mgb2YgYWxsIHN1YnBhcnQgY2hpbGRyZW5cbiAgICAgICAgLy8gYW5kIGFwcGVuZCB0aGVtIGluIHRoZSBjb3JyZWN0IHBsYWNlc1xuICAgICAgICBsZW5zZWRWaWV3LmlzTGVuc2VkID0gdHJ1ZTtcbiAgICAgICAgbGVuc2VkVmlldy5zZXRNb2RlbChhUGFydE1vZGVsKTtcbiAgICAgICAgbGVuc2VkVmlldy5yZW1vdmVBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgaWYobGVuc2VkVmlldy5oYW5kbGVDdXJyZW50Q2hhbmdlKXtcbiAgICAgICAgICAgIGxlbnNlZFZpZXcuaGFuZGxlQ3VycmVudENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZWx5VXBkYXRlTGVuc1ZpZXdzKGxlbnNlZFZpZXcsIGFQYXJ0TW9kZWwuaWQpO1xuXG4gICAgICAgIC8vIEluc2VydCB0aGUgcm9vdCBsZW5zZWQgdmlldyBpbnRvIHRoZSB3cmFwcGVyXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3cmFwcGVkLWlkJywgYVBhcnRNb2RlbC5pZCk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGVuc2VkVmlldyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2NhbGluZygpO1xuICAgIH1cblxuICAgIF9yZWN1cnNpdmVseVVwZGF0ZUxlbnNWaWV3cyhsZW5zZWRWaWV3LCBhbklkKXtcbiAgICAgICAgbGV0IHN1YlZpZXdzID0gQXJyYXkuZnJvbShsZW5zZWRWaWV3LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlzUGFydFZpZXc7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJWaWV3cy5mb3JFYWNoKHN1YlZpZXcgPT4ge1xuICAgICAgICAgICAgc3ViVmlldy5pc0xlbnNlZCA9IHRydWU7XG4gICAgICAgICAgICBzdWJWaWV3LndhbnRzSGFsbyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHN1YklkID0gc3ViVmlldy5nZXRBdHRyaWJ1dGUoJ3BhcnQtaWQnKTtcbiAgICAgICAgICAgIHN1YlZpZXcuc2V0QXR0cmlidXRlKCdsZW5zLXBhcnQtaWQnLCBzdWJJZCk7XG4gICAgICAgICAgICBsZXQgbW9kZWwgPSB3aW5kb3cuU3lzdGVtLnBhcnRzQnlJZFtzdWJJZF07XG4gICAgICAgICAgICBzdWJWaWV3LnNldE1vZGVsKG1vZGVsKTtcbiAgICAgICAgICAgIHN1YlZpZXcucmVtb3ZlQXR0cmlidXRlKCdwYXJ0LWlkJyk7XG4gICAgICAgICAgICB0aGlzLl9yZWN1cnNpdmVseVVwZGF0ZUxlbnNWaWV3cyhzdWJWaWV3LCBzdWJJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBQYXJ0VmlldyBPdmVycmlkZXMgKiovXG4gICAgc3R5bGVDU1MoKXtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cblxuICAgIHN0eWxlVGV4dENTUygpe1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuXG4gICAgbGF5b3V0Q2hhbmdlZCgpe1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxufTtcblxuZXhwb3J0IHtcbiAgICBXcmFwcGVkVmlldyxcbiAgICBXcmFwcGVkVmlldyBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IHtBY3RpdmF0aW9uQ29udGV4dH0gZnJvbSAnLi4vb2JqZWN0cy9FeGVjdXRpb25TdGFjay5qcyc7XG5cbi8vIEhlbHBlcnNcbmZ1bmN0aW9uIGZpbmROZWFyZXN0UGFyZW50T2ZLaW5kKGFQYXJ0LCBhUGFydFR5cGUpe1xuICAgIGxldCBvd25lciA9IGFQYXJ0Ll9vd25lcjtcbiAgICB3aGlsZShvd25lcil7XG4gICAgICAgIGlmKG93bmVyLnR5cGUgPT0gYVBhcnRUeXBlKXtcbiAgICAgICAgICAgIHJldHVybiBvd25lcjtcbiAgICAgICAgfVxuICAgICAgICBvd25lciA9IG93bmVyLl9vd25lcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGAndGhpcycgaXMgYSAke2FQYXJ0LnR5cGV9LCBub3QgYSAke2FQYXJ0VHlwZX0gb3IgZG9lcyBub3QgaGF2ZSBhIHBhcmVudCBvZiBhICR7YVBhcnRUeXBlfSFgKTtcbn1cblxuLy8gY2hlY2sgZm9yIHBvc3NpYmxlQW5jZXN0b3IuYWNjZXB0c1N1YnBhcnQoYVBhcnQudHlwZSlcbi8vIGFuZCBpZiBub3QgZ28gdG8gb3duZXIgYW5kIGNoZWNrIGFnYWluXG5mdW5jdGlvbiBmaW5kRmlyc3RQb3NzaWJsZUFuY2VzdG9yKGFQYXJ0LCBhUGFydFR5cGUpe1xuICAgIGlmKF9zdWJwYXJ0Q2hlY2soYVBhcnQsIGFQYXJ0VHlwZSkpe1xuICAgICAgICByZXR1cm4gYVBhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG93bmVyID0gYVBhcnQuX293bmVyO1xuICAgICAgICB3aGlsZShvd25lcil7XG4gICAgICAgICAgICBpZihfc3VicGFydENoZWNrKG93bmVyLCBhUGFydFR5cGUpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvd25lciA9IG93bmVyLl9vd25lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYGEgJHthUGFydC50eXBlfSwgZG9lcyBub3QgYWNjZXB0IG5vciBoYXMgYW55IGFuY2VzdG9ycyB3aGljaCBhY2NlcHQgcGFydCB0eXBlICR7YVBhcnRUeXBlfWApO1xufVxuXG5mdW5jdGlvbiBfc3VicGFydENoZWNrKGFQYXJ0LCBhUGFydFR5cGUpe1xuICAgIGlmKGFQYXJ0VHlwZSA9PSAncGFydCcpe1xuICAgICAgICByZXR1cm4gYVBhcnQuYWNjZXB0ZWRTdWJwYXJ0VHlwZXMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGFQYXJ0LmFjY2VwdHNTdWJwYXJ0KGFQYXJ0VHlwZSk7XG59XG5cbmNsYXNzIFNUVmFyaWFibGVSZWZlcmVuY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICBTVFZhcmlhYmxlUmVmZXJlbmNlRXJyb3IucHJvdG90eXBlLFxuICAgICduYW1lJyxcbiAgICB7XG4gICAgICAgIHZhbHVlOiAnU1RWYXJpYWJsZVJlZmVyZW5jZUVycm9yJ1xuICAgIH1cbik7XG5cbmNvbnN0IGNyZWF0ZUludGVycHJldGVyU2VtYW50aWNzID0gKHBhcnRDb250ZXh0LCBzeXN0ZW1Db250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgU2NyaXB0OiBmdW5jdGlvbihzY3JpcHRQYXJ0cywgXyl7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UGFydHMuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIE1lc3NhZ2VIYW5kbGVyOiBmdW5jdGlvbihoYW5kbGVyT3BlbiwgbGluZVRlcm0sIG9wdGlvbmFsU3RhdGVtZW50TGlzdCwgaGFuZGxlckNsb3NlKXtcbiAgICAgICAgICAgIGxldCB7bWVzc2FnZU5hbWUsIHBhcmFtZXRlcnN9ID0gaGFuZGxlck9wZW4uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgaGFuZGxlckZ1bmN0aW9uID0gZnVuY3Rpb24oc2VuZGVycywgLi4uYXJncyl7XG5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgZ3JhbW1hciwgdGhlIFN0YXRlbWVudExpc3QgaXNcbiAgICAgICAgICAgICAgICAvLyBhbiBvcHRpb25hbCBydWxlLCBtZWFuaW5nIHRoZSByZXN1bHQgb2YgdGhlIHJ1bGVcbiAgICAgICAgICAgICAgICAvLyBpcyBhbiBlbXB0eSBhcnJheSAobm8gc3RhdGVtZW50bGlzdCkgb3IgYSBzaW5nbGVcbiAgICAgICAgICAgICAgICAvLyBpdGVtIGFycmF5ICh0aGUgc3RhdGVtZW50bGlzdClcbiAgICAgICAgICAgICAgICBpZihvcHRpb25hbFN0YXRlbWVudExpc3QuY2hpbGRyZW4ubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzdGF0ZW1lbnRMaXN0ID0gb3B0aW9uYWxTdGF0ZW1lbnRMaXN0LmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gTmV4dCwgd2UgaW5pdGlhbGl6ZSBhIG5ldyBBY3RpdmF0aW9uQ29udGV4dFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2lsbCBob2xkIGFsbCB2YXJpYWJsZSBpbmZvcm1hdGlvbiBmb3JcbiAgICAgICAgICAgICAgICAvLyB0aGUgZXhlY3V0aW9uIG9mIHRoaXMgaGFuZGxlci5cbiAgICAgICAgICAgICAgICAvLyBXZSBwdXNoIGl0IHRvIHRoZSB0b3Agb2YgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIHN0YWNrXG4gICAgICAgICAgICAgICAgLy8gYW5kIHNldCB0aGUgYXJndW1lbnQgdmFyaWFibGVzIHRvIGxvY2Fsc1xuICAgICAgICAgICAgICAgIGFyZ3MuZm9yRWFjaCgoYXJnVmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmdOYW1lID0gcGFyYW1ldGVyc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHN5c3RlbUNvbnRleHQuZXhlY3V0aW9uU3RhY2suY3VycmVudC5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBTdGF0ZW1lbnRMaXN0IGlzIGJvdGggb3B0aW9uYWwgKmFuZCogbWFkZSB1cFxuICAgICAgICAgICAgICAgIC8vIG9mIGl0ZXJhYmxlIFN0YXRlbWVudExpbmUgcnVsZXMgKGllLCAnU3RhdGVtZW50TGluZSsnIGluIGdyYW1tYXIpLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gXCJ1bndyYXBcIiB0aGVzZSBub2RlcyB3aXRob3V0IGNhbGxpbmcgaW50ZXJwcmV0KCkgb24gdGhlbS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBleHByZXNzaW9ucyB3aXRoaW4gdGhlIHN0YXRlbWVudHMsIGxpa2UgdmFyaWFibGUgbG9va3VwcyxcbiAgICAgICAgICAgICAgICAvLyBhcmUgbm90IGNhbGxlZCBiZWZvcmUgYW55IHByZWNlZGluZyBzdGF0ZW1lbnRzIGhhdmUgYmVlbiBpbnRlcnByZXRlZCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29ycmVzcG9uZGluZyBtZXNzYWdlcyBoYXZlIGFscmVhZHkgYmVlbiBzZW50LiBGb3IgZXhhbXBsZSwgc3RhdGVtZW50IDEgbWlnaHRcbiAgICAgICAgICAgICAgICAvLyBzZXQgYSB2YXJpYWJsZSB0aGF0IHN0YXRlbWVudCAyIG5lZWRzIHRvIGxvb2t1cCBhbmQgdXNlLCBzbyB3ZSB3YW50IHRoZSBsb29rdXAgdG9cbiAgICAgICAgICAgICAgICAvLyBvY2N1ciBhZnRlciBzdGF0ZW1lbnQgMSBoYXMgYmVlbiBpbnRlcnByZXRlZCBhbmQgdGhlIG1lc3NhZ2UgZm9yIGl0IGhhc1xuICAgICAgICAgICAgICAgIC8vIGJlZW4gc2VudC5cbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRMaXN0LmNoaWxkcmVuLmZvckVhY2goc3RhdGVtZW50TGluZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRMaW5lcy5jaGlsZHJlbi5mb3JFYWNoKHN0YXRlbWVudExpbmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBzdGF0ZW1lbnRMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHBhcnRDb250ZXh0Ll9jb21tYW5kSGFuZGxlcnNbbWVzc2FnZU5hbWVdID0gaGFuZGxlckZ1bmN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIE1lc3NhZ2VIYW5kbGVyT3BlbjogZnVuY3Rpb24obGl0ZXJhbE9uLCBtZXNzYWdlTmFtZSwgb3B0aW9uYWxQYXJhbWV0ZXJMaXN0KXtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIFBhcmFtZXRlckxpc3QgaGVyZSBpcyBvcHRpb25hbCwgaWZcbiAgICAgICAgICAgIC8vIGl0IGlzIHNldCBpdCB3aWxsIGJlIGluIHRoZSBmb3JtIG9mIGEgc2l6ZSAxIGFycmF5LlxuICAgICAgICAgICAgLy8gVGhpcyBzaW5nbGUgYXJyYXkgaXRlbSB3aWxsIGl0c2VsZiBiZSBhbiBhcnJheSBvZiB0aGVcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciB2YXJpYWJsZSBuYW1lcy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYW4gZW1wdHkgYXJyYXkgaW5kaWNhdGVzIG5vIHBhcmFtc1xuICAgICAgICAgICAgLy8gYXJlIHBhc3NlZCBpbiBmb3IgdGhpcyBoYW5kbGVyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gb3B0aW9uYWxQYXJhbWV0ZXJMaXN0LmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYocGFyYW1zLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZU5hbWU6IG1lc3NhZ2VOYW1lLnNvdXJjZVN0cmluZyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUGFyYW1ldGVyTGlzdDogZnVuY3Rpb24ocGFyYW1ldGVyU3RyaW5nKXtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJTdHJpbmcuYXNJdGVyYXRpb24oKS5jaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIEluQ2xhdXNlOiBmdW5jdGlvbihpbkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYW5zd2VyOiBmdW5jdGlvbihhbnN3ZXIsIGV4cHJlc3Npb24pe1xuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJhbnN3ZXJcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uaW50ZXJwcmV0KClcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2dvVG9EaXJlY3Rpb246IGZ1bmN0aW9uKGdvVG9MaXRlcmFsLCBuZXh0UHJldmlvdXMsIHN5c3RlbU9iamVjdCl7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICAgICAgYXJncy5wdXNoKG5leHRQcmV2aW91cy5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKHN5c3RlbU9iamVjdC5zb3VyY2VTdHJpbmcpe1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChzeXN0ZW1PYmplY3Quc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJnbyB0byBkaXJlY3Rpb25cIixcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2dvVG9CeU9iamVjdFNwZWNpZmllcjogZnVuY3Rpb24oZ29Ub0xpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCkgLy8gaWQgb2YgdGhlIG9iamVjdFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJnbyB0b1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfZ29Ub1dlYnNpdGU6IGZ1bmN0aW9uKGdvVG9MaXRlcmFsLCB3ZWJzaXRlTGl0ZXJhbCwgdXJsKXtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHVybC5pbnRlcnByZXQoKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJnbyB0byB3ZWJzaXRlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hZGRQcm9wZXJ0eTogZnVuY3Rpb24oYWRkTGl0ZXJhbCwgcHJvcGVydHlMaXRlcmFsLCBwcm9wTmFtZUFzTGl0ZXJhbCwgdG9MaXRlcmFsLCBzeXN0ZW1PYmplY3Qpe1xuICAgICAgICAgICAgbGV0IHNwZWNpZmllZE9iamVjdElkID0gc3lzdGVtT2JqZWN0LmludGVycHJldCgpWzBdIHx8IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZUFzTGl0ZXJhbC5pbnRlcnByZXQoKSwgLy8gVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBzcGVjaWZpZWRPYmplY3RJZFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJuZXdQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfYWRkTW9kZWw6IGZ1bmN0aW9uKGFkZExpdGVyYWwsIG5ld1BhcnRUeXBlLCBvcHRpb25hbFBhcnROYW1lKXtcbiAgICAgICAgICAgIC8vIGhlcmUgbm8gb3duZXIgaGFzIGJlZW4gcHJvdmlkZWQgc28gd2UgYXNzdW1lIGl0IGlzIHRoZSBmaXJzdCBwb3NzaWJsZSBvbmVcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBmaW5kRmlyc3RQb3NzaWJsZUFuY2VzdG9yKHBhcnRDb250ZXh0LCBuZXdQYXJ0VHlwZS5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgbmV3UGFydFR5cGUuc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIHBhcmVudC5pZFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBvcHRpb25hbE5hbWUgPSBvcHRpb25hbFBhcnROYW1lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYob3B0aW9uYWxOYW1lICYmIG9wdGlvbmFsTmFtZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChvcHRpb25hbE5hbWVbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcIm5ld01vZGVsXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hZGRNb2RlbFRvOiBmdW5jdGlvbihhZGRMaXRlcmFsLCBuZXdQYXJ0VHlwZSwgb3B0aW9uYWxQYXJ0TmFtZSwgdG9MaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIpe1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgbmV3UGFydFR5cGUuc291cmNlU3RyaW5nLCAvLyBUaGUga2luZCBvZiBwYXJ0IHRvIGFkZFxuICAgICAgICAgICAgICAgIG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKSAvLyBpZCBvZiB0aGUgcGFyZW50IG1vZGVsIHBhcnRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBvcHRpb25hbE5hbWUgPSBvcHRpb25hbFBhcnROYW1lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYob3B0aW9uYWxOYW1lICYmIG9wdGlvbmFsTmFtZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChvcHRpb25hbE5hbWVbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXNnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lOiBcIm5ld01vZGVsXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9wdXRWYXJpYWJsZTogZnVuY3Rpb24ocHV0TGl0ZXJhbCwgdmFsdWUsIGludG9MaXRlcmFsLCBnbG9iYWxMaXRlcmFsLCBkZXN0aW5hdGlvbil7XG4gICAgICAgICAgICBsZXQgZ2xvYmFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZihnbG9iYWxMaXRlcmFsLnNvdXJjZVN0cmluZyl7XG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICB2YWx1ZS5pbnRlcnByZXQoKSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5zb3VyY2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgZ2xvYmFsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ3B1dEludG8nLFxuICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uKGRlbGV0ZUxpdGVyYWwsIHByb3BlcnR5TGl0ZXJhbCwgcHJvcE5hbWVBc0xpdGVyYWwsIGZyb21MaXRlcmFsLCBzeXN0ZW1PYmplY3Qpe1xuICAgICAgICAgICAgbGV0IHNwZWNpZmllZE9iamVjdElkID0gc3lzdGVtT2JqZWN0LmludGVycHJldCgpWzBdIHx8IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZUFzTGl0ZXJhbC5pbnRlcnByZXQoKSwgLy8gVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBzcGVjaWZpZWRPYmplY3RJZFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJkZWxldGVQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfZGVsZXRlTW9kZWw6IGZ1bmN0aW9uKGRlbGV0ZUxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBvYmplY3RTcGVjaWZpZXIuaW50ZXJwcmV0KCkgLy8gaWQgb2YgdGhlIG9iamVjdFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJkZWxldGVNb2RlbFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfc2V0UHJvcGVydHk6IGZ1bmN0aW9uKHNldExpdGVyYWwsIHByb3BOYW1lQXNMaXRlcmFsLCB0b0xpdGVyYWwsIGxpdGVyYWxPclZhck5hbWUsIG9wdGlvbmFsSW5DbGF1c2Upe1xuICAgICAgICAgICAgbGV0IHNwZWNpZmllZE9iamVjdElkID0gb3B0aW9uYWxJbkNsYXVzZS5pbnRlcnByZXQoKVswXSB8fCBudWxsO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgcHJvcE5hbWVBc0xpdGVyYWwuaW50ZXJwcmV0KCksIC8vIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgbGl0ZXJhbE9yVmFyTmFtZS5pbnRlcnByZXQoKSwgLy8gVGhlIHZhbHVlIG9yIGEgdmFyIHJlcHJlc2VudGluZyB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICBzcGVjaWZpZWRPYmplY3RJZFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogXCJzZXRQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfc2V0U2VsZWN0aW9uOiBmdW5jdGlvbihzZXRMaXRlcmFsLCBzZWxlY3Rpb25MaXRlcmFsLCBwcm9wTmFtZUFzTGl0ZXJhbCwgdG9MaXRlcmFsLCBsaXRlcmFsT3JWYXJOYW1lLCBvcHRpb25hbEluQ2xhdXNlKXtcbiAgICAgICAgICAgIGxldCBzcGVjaWZpZWRPYmplY3RJZCA9IG9wdGlvbmFsSW5DbGF1c2UuaW50ZXJwcmV0KClbMF0gfHwgbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzID0gW1xuICAgICAgICAgICAgICAgIHByb3BOYW1lQXNMaXRlcmFsLmludGVycHJldCgpLCAvLyBUaGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIGxpdGVyYWxPclZhck5hbWUuaW50ZXJwcmV0KCksIC8vIFRoZSB2YWx1ZSBvciBhIHZhciByZXByZXNlbnRpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVkT2JqZWN0SWRcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwic2V0U2VsZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tbWFuZF9hc2s6IGZ1bmN0aW9uKGFza0xpdGVyYWwsIHF1ZXN0aW9uKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZE5hbWU6IFwiYXNrXCIsXG4gICAgICAgICAgICAgICAgYXJnczogWyBxdWVzdGlvbi5pbnRlcnByZXQoKSBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRfdGVsbENvbW1hbmQ6IGZ1bmN0aW9uKHRlbGxMaXRlcmFsLCBvYmplY3RTcGVjaWZpZXIsIHRvTGl0ZXJhbCwgY29tbWFuZCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogJ3RlbGwnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kLmludGVycHJldCgpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21tYW5kX2FyYml0cmFyeUNvbW1hbmQ6IGZ1bmN0aW9uKGNvbW1hbmROYW1lLCBvcHRpb25hbEFyZ3VtZW50TGlzdCl7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBhcmd1bWVudCBsaXN0IGlzIG9wdGlvbmFsIGhlcmUsIGl0IHdpbGxcbiAgICAgICAgICAgIC8vIGJlIGVpdGhlciBhbiBlbXB0eSBhcnJheSAobm8gYXJndW1lbnRzKSBvciBhIHNpemUgMVxuICAgICAgICAgICAgLy8gYXJyYXkgKHdoaWNoIGl0c2VsZiB3aWxsIGNvbnRhaW4gYW4gYXJyYXkgb2YgdGhlIGFyZ3VtZW50cylcbiAgICAgICAgICAgIGxldCBvcHRpb25hbEFyZ3VtZW50cyA9IG9wdGlvbmFsQXJndW1lbnRMaXN0LmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYob3B0aW9uYWxBcmd1bWVudHMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxBcmd1bWVudHMgPSBvcHRpb25hbEFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZTogY29tbWFuZE5hbWUuc291cmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIGFyZ3M6IG9wdGlvbmFsQXJndW1lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbW1hbmRBcmd1bWVudExpc3Q6IGZ1bmN0aW9uKGxpc3Qpe1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QuYXNJdGVyYXRpb24oKS5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBTdGF0ZW1lbnRMaW5lOiBmdW5jdGlvbihzdGF0ZW1lbnQsIG5ld2xpbmUpe1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBzdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG5cbiAgICAgICAgICAgIC8vIFNvbWUgc3RhdGVtZW50cywgbGlrZSBpZi10aGVuIGNvbnRyb2xzXG4gICAgICAgICAgICAvLyBhbmQgcmVwZWF0IGNvbnRyb2xzLCBkbyBub3QgcmVzdWx0IGluXG4gICAgICAgICAgICAvLyBtZXNzYWdlcyBidXQgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhlc2UuXG4gICAgICAgICAgICBpZihtZXNzYWdlICYmIHR5cGVvZihtZXNzYWdlKSAhPT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kUmVzdWx0ID0gcGFydENvbnRleHQuc2VuZE1lc3NhZ2UobWVzc2FnZSwgcGFydENvbnRleHQpO1xuICAgICAgICAgICAgICAgIHN5c3RlbUNvbnRleHQuZXhlY3V0aW9uU3RhY2suY3VycmVudC5zZXRMb2NhbCgnaXQnLCBjb21tYW5kUmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3RhdGVtZW50OiBmdW5jdGlvbihhY3R1YWxTdGF0ZW1lbnQsIG9wdGlvbmFsQ29tbWVudCl7XG4gICAgICAgICAgICByZXR1cm4gYWN0dWFsU3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fYWRkRXhwcjogZnVuY3Rpb24oZmlyc3RFeHByZXNzaW9uLCBvcGVyYXRpb24sIHNlY29uZEV4cHJlc3Npb24pe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHNlY29uZEV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgKyBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvbl9taW51c0V4cHI6IGZ1bmN0aW9uKGZpcnN0RXhwciwgb3BlcmF0aW9uLCBzZWNvbmRFeHByKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZpcnN0RXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25fZGl2aWRlRXhwcjogZnVuY3Rpb24oZmlyc3RFeHByLCBvcGVyYXRpb24sIHNlY29uZEV4cHIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHNlY29uZEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgLyBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvbl9tb2R1bG9EaXZpZGVFeHByOiBmdW5jdGlvbihmaXJzdEV4cHIsIG9wZXJhdGlvbiwgc2Vjb25kRXhwcil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmaXJzdEV4cHIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gc2Vjb25kRXhwci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCAlIHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uX3RpbWVzRXhwcjogZnVuY3Rpb24oZmlyc3RFeHByZXNzaW9uLCBvcGVyYXRpb24sIHNlY29uZEV4cHJlc3Npb24pe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmlyc3RFeHByZXNzaW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHNlY29uZEV4cHJlc3Npb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgKiBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvbl9zdHJpbmdDb25jYXRFeHByOiBmdW5jdGlvbihmaXJzdEV4cHJlc3Npb24sIG9wZXJhdGlvbiwgc2Vjb25kRXhwcmVzc2lvbil7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGVuY291bnRlciB0aGUgXCImXCIgb3BlcmF0b3IsIHdlIGNvZXJjZSBib3RoIGV4cHJlc3Npb25zIGludG9cbiAgICAgICAgICAgIC8vIGEgc3RyaW5nXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmaXJzdEV4cHJlc3Npb24uaW50ZXJwcmV0KCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBzZWNvbmRFeHByZXNzaW9uLmludGVycHJldCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7Zmlyc3R9JHtzZWNvbmR9YDtcbiAgICAgICAgfSxcblxuICAgICAgICBGYWN0b3JfcGFyZW5GYWN0b3I6IGZ1bmN0aW9uKGxlZnRQYXJlbiwgZXhwcmVzc2lvbiwgcmlnaHRQYXJlbil7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBGYWN0b3Jfbm90RmFjdG9yOiBmdW5jdGlvbihub3RMaXRlcmFsLCBleHByZXNzaW9uKXtcbiAgICAgICAgICAgIHJldHVybiAhZXhwcmVzc2lvbi5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFcXVhbGl0eUNvbmRpdGlvbmFsOiBmdW5jdGlvbihleHByMSwgY29tcGFyYXRvckxpdGVyYWwsIGV4cHIyKXtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGV4cHIxLmludGVycHJldCgpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGV4cHIyLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTm9uRXF1YWxpdHlDb25kaXRpb25hbDogZnVuY3Rpb24oZXhwcjEsIGNvbXBhcmF0b3JMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBleHByMS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBleHByMi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCAhPT0gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsX2d0Q29tcGFyaXNvbjogZnVuY3Rpb24oZXhwcjEsIGd0TGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxfbHRDb21wYXJpc29uOiBmdW5jdGlvbihleHByMSwgbHRMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBleHByMS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBleHByMi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA8IHNlY29uZDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb25kaXRpb25hbF9ndGVDb21wYXJpc29uOiBmdW5jdGlvbihleHByMSwgZ3RlTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZXhwcjEuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gZXhwcjIuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPj0gc2Vjb25kO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsX2x0ZUNvbXBhcmlzb246IGZ1bmN0aW9uKGV4cHIxLCBsdGVMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBleHByMS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCBzZWNvbmQgPSBleHByMi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA8PSBzZWNvbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhlcmVJc0FuT2JqZWN0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uKHRoZXJlTGl0ZXJhbCwgaXNMaXRlcmFsLCBhT3JBbkxpdGVyYWwsIG9iamVjdFNwZWNpZmllcil7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZXJlSXNOb3RBbk9iamVjdENvbmRpdGlvbmFsOiBmdW5jdGlvbih0aGVyZUxpdGVyYWwsIGlzTGl0ZXJhbCwgbm90TGl0ZXJhbCwgYU9yQW5MaXRlcmFsLCBpbkNsYXVzZSl7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgb2JqZWN0U3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZXJlSXNBUHJvcGVydHlDb25kaXRpb25hbF93aXRoU3BlY2lmaWVyOiBmdW5jdGlvbih0aGVyZUxpdGVyYWwsIGlzTGl0ZXJhbCwgYUxpdGVyYWwsIHByb3BlcnR5TGl0ZXJhbCwgcHJvcE5hbWUsIG9mTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBzeXN0ZW1Db250ZXh0LnBhcnRzQnlJZFt0YXJnZXRJZF07XG4gICAgICAgICAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhcnQgd2l0aCBpZCAke3RhcmdldElkfSAoJHt0aGlzLnNvdXJjZVN0cmluZ30pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUuaW50ZXJwcmV0KCkpO1xuICAgICAgICAgICAgaWYocHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZXJlSXNBUHJvcGVydHlDb25kaXRpb25hbF93aXRob3V0U3BlY2lmaWVyOiBmdW5jdGlvbih0aGVyZUxpdGVyYWwsIGlzTGl0ZXJhbCwgYUxpdGVyYWwsIHByb3BlcnR5TGl0ZXJhbCwgcHJvcE5hbWUpe1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gcGFydENvbnRleHQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUuaW50ZXJwcmV0KCkpO1xuICAgICAgICAgICAgaWYocHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZXJlSXNOb3RBUHJvcGVydHlDb25kaXRpb25hbF93aXRoU3BlY2lmaWVyOiBmdW5jdGlvbih0aGVyZUxpdGVyYWwsIGlzTGl0ZXJhbCwgbm90TGl0ZXJhbCwgYUxpdGVyYWwsIHByb3BlcnR5TGl0ZXJhbCwgcHJvcE5hbWUsIG9mTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBzeXN0ZW1Db250ZXh0LnBhcnRzQnlJZFt0YXJnZXRJZF07XG4gICAgICAgICAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhcnQgd2l0aCBpZCAke3RhcmdldElkfSAoJHt0aGlzLnNvdXJjZVN0cmluZ30pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSB0YXJnZXQucGFydFByb3BlcnRpZXMuZmluZFByb3BlcnR5TmFtZWQocHJvcE5hbWUuaW50ZXJwcmV0KCkpO1xuICAgICAgICAgICAgaWYocHJvcGVydHkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoZXJlSXNOb3RBUHJvcGVydHlDb25kaXRpb25hbF93aXRob3V0U3BlY2lmaWVyOiBmdW5jdGlvbih0aGVyZUxpdGVyYWwsIGlzTGl0ZXJhbCwgbm90TGl0ZXJhbCwgYUxpdGVyYWwsIHByb3BMaXRlcmFsLCBwcm9wTmFtZSl7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBwYXJ0Q29udGV4dC5wYXJ0UHJvcGVydGllcy5maW5kUHJvcGVydHlOYW1lZChwcm9wTmFtZS5pbnRlcnByZXQoKSk7XG4gICAgICAgICAgICBpZihwcm9wZXJ0eSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZUaGVuSW5saW5lOiBmdW5jdGlvbihpZkxpdGVyYWwsIGNvbmRpdGlvbmFsLCB0aGVuTGl0ZXJhbCwgc3RhdGVtZW50LCBvcHRpb25hbENvbW1lbnQpe1xuICAgICAgICAgICAgbGV0IHNob3VsZEV2YWx1YXRlID0gY29uZGl0aW9uYWwuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihzaG91bGRFdmFsdWF0ZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZUaGVuU2luZ2xlbGluZV93aXRob3V0RWxzZTogZnVuY3Rpb24oaWZMaW5lLCBsaW5lVGVybTEsIHRoZW5MaW5lKXtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBpZkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihjb25kaXRpb24pe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGVuTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZUaGVuU2luZ2xlbGluZV93aXRoRWxzZTogZnVuY3Rpb24oaWZMaW5lLCBsaW5lVGVybTEsIHRoZW5MaW5lLCBsaW5lVGVybTIsIGVsc2VMaW5lKXtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBpZkxpbmUuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihjb25kaXRpb24pe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGVuTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsc2VMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlbk11bHRpbGluZV93aXRoRWxzZTogZnVuY3Rpb24oaWZMaW5lLCBsaW5lVGVybSwgbXVsdGlUaGVuLCBtdWx0aUVsc2UsIGVuZElmTGluZSl7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gaWZMaW5lLmludGVycHJldCgpO1xuICAgICAgICAgICAgaWYoY29uZGl0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXVsdGlUaGVuLmludGVycHJldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXVsdGlFbHNlLmludGVycHJldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIElmVGhlbk11bHRpbGluZV93aXRob3V0RWxzZTogZnVuY3Rpb24oaWZMaW5lLCBsaW5lVGVybSwgbXVsdGlUaGVuLCBlbmRJZkxpbmUpe1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvbiA9IGlmTGluZS5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKGNvbmRpdGlvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11bHRpVGhlbi5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIElmTGluZTogZnVuY3Rpb24oaWZMaXRlcmFsLCBjb25kaXRpb25hbCwgb3B0aW9uYWxDb21tZW50KXtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25hbC5pbnRlcnByZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGVuTGluZTogZnVuY3Rpb24odGhlbkxpdGVyYWwsIHN0YXRlbWVudCwgb3B0aW9uYWxDb21tZW50KXtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRWxzZUxpbmU6IGZ1bmN0aW9uKGVsc2VMaXRlcmFsLCBzdGF0ZW1lbnQsIG9wdGlvbmFsQ29tbWVudCl7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbnRyb2xTdGF0ZW1lbnRMaW5lOiBmdW5jdGlvbihzdGF0ZW1lbnRMaW5lKXtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRMaW5lLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE11bHRpVGhlbjogZnVuY3Rpb24odGhlbkxpdGVyYWwsIG9wdGlvbmFsQ29tbWVudCwgbGludFRlcm0sIGNvbnRyb2xTdGF0ZW1lbnRMaW5lcyl7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbFN0YXRlbWVudExpbmVzLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE11bHRpRWxzZTogZnVuY3Rpb24oZWxzZUxpdGVyYWwsIG9wdGlvbmFsQ29tbWVudCwgbGluZVRlcm0sIGNvbnRyb2xTdGF0ZW1lbnRMaW5lcyl7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbFN0YXRlbWVudExpbmVzLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEtpbmRDb25kaXRpb25hbDogZnVuY3Rpb24oZXhwcjEsIGNvbXBhcmF0b3JMaXRlcmFsLCBleHByMil7XG4gICAgICAgICAgICAvLyBUT0RPOiBGbGVzaCBvdXQgdGhpcyBmdW5jdGlvbiB0byBhY2NvdW50IGZvclxuICAgICAgICAgICAgLy8gdmFyaW91cyBvYmplY3QgdHlwZXMgYW5kIHRoZWlyIGtpbmQgY29tcGFyaXNvbnNcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBOb3RLaW5kQ29uZGl0aW9uYWw6IGZ1bmN0aW9uKGV4cHIxLCBjb21wYXJhdG9yTGl0ZXJhbCwgZXhwcjIpe1xuICAgICAgICAgICAgLy8gVE9ETzogRmxlc2ggb3V0IHRoaXMgZnVuY3Rpb24gdG8gYWNjb3VudCBmb3JcbiAgICAgICAgICAgIC8vIHZhcmlvdXMgb2JqZWN0IHR5cGVzIGFuZCB0aGVpciBraW5kIGNvbXBhcmlzb25zXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRDb250cm9sRm9ybV9mb3JOdW1UaW1lczogZnVuY3Rpb24ocmVwZWF0TGl0LCBvcHRpb25hbEZvckxpdCwgaW50T3JWYXIsIHRpbWVzTGl0KXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVwZWF0VHlwZTogJ2Zvck51bVRpbWVzJyxcbiAgICAgICAgICAgICAgICBudW1UaW1lczogaW50T3JWYXIuaW50ZXJwcmV0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVwZWF0Q29udHJvbEZvcm1fdW50aWxDb25kaXRpb246IGZ1bmN0aW9uKHJlcGVhdExpdCwgdW50aWxMaXQsIGNvbmRpdGlvbmFsKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVwZWF0VHlwZTogJ3VudGlsQ29uZGl0aW9uJyxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGNvbmRpdGlvbmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdENvbnRyb2xGb3JtX3doaWxlQ29uZGl0aW9uOiBmdW5jdGlvbihyZXBlYXRMaXQsIHdoaWxlTGl0LCBjb25kaXRpb25hbCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcGVhdFR5cGU6ICd3aGlsZUNvbmRpdGlvbicsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBjb25kaXRpb25hbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXBlYXRDb250cm9sRm9ybV93aXRoU3RhcnRGaW5pc2g6IGZ1bmN0aW9uKHJlcGVhdExpdCwgd2l0aExpdCwgdmFyTmFtZSwgZXFMaXQsIGZpcnN0VmFsLCB0b0xpdCwgc2Vjb25kVmFsKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVwZWF0VHlwZTogJ3dpdGhTdGFydEZpbmlzaCcsXG4gICAgICAgICAgICAgICAgdmFyTmFtZTogdmFyTmFtZS5zb3VyY2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0VmFsLmludGVycHJldCgpLFxuICAgICAgICAgICAgICAgIGZpbmlzaDogc2Vjb25kVmFsLmludGVycHJldCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdEFkanVzdF9leGl0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJldHVybiAnZXhpdCByZXBlYXQnO1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdEFkanVzdF9uZXh0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJldHVybiAnbmV4dCByZXBlYXQnO1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlcGVhdEJsb2NrOiBmdW5jdGlvbihyZXBlYXRDb250cm9sLCBsaW5lVGVybSwgc3RhdGVtZW50TGluZU9yUmVwQWRqdXN0UGx1cywgZW5kTGl0ZXJhbCl7XG4gICAgICAgICAgICBsZXQgcmVwZWF0SW5mbyA9IHJlcGVhdENvbnRyb2wuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBsZXQgc3RhdGVtZW50TGluZXMgPSBzdGF0ZW1lbnRMaW5lT3JSZXBBZGp1c3RQbHVzLmNoaWxkcmVuO1xuICAgICAgICAgICAgc3dpdGNoKHJlcGVhdEluZm8ucmVwZWF0VHlwZSl7XG4gICAgICAgICAgICBjYXNlICdmb3JOdW1UaW1lcyc6XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8PSByZXBlYXRJbmZvLm51bVRpbWVzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZFBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHN0YXRlbWVudExpbmVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGVtZW50ID0gc3RhdGVtZW50TGluZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudFN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCA9PSAnZXhpdCByZXBlYXQnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihyZXN1bHQgPT0gJ25leHQgcmVwZWF0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRQYXNzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRCcmVhayl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoZSBtYWluIGZvciBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIEJyZWFrIG91dCBvZiB0aGUgc3dpdGNoXG4gICAgICAgICAgICBjYXNlICd1bnRpbENvbmRpdGlvbic6XG4gICAgICAgICAgICAgICAgbGV0IHVudGlsVGVzdENvbmRpdGlvbiA9IHJlcGVhdEluZm8uY29uZGl0aW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlKCF1bnRpbFRlc3RDb25kaXRpb24pe1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHN0YXRlbWVudExpbmVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGVtZW50ID0gc3RhdGVtZW50TGluZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudFN0YXRlbWVudC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09ICdleGl0IHJlcGVhdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihyZXN1bHQgPT0gJ25leHQgcmVwZWF0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRCcmVhayl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoZSBvdXRlciB3aGlsZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW50aWxUZXN0Q29uZGl0aW9uID0gcmVwZWF0SW5mby5jb25kaXRpb24uaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBCcmVhayBvdXQgb2YgdGhlIHN3aXRjaCBjYXNlXG4gICAgICAgICAgICBjYXNlICd3aGlsZUNvbmRpdGlvbic6XG4gICAgICAgICAgICAgICAgbGV0IHdoaWxlVGVzdENvbmRpdGlvbiA9IHJlcGVhdEluZm8uY29uZGl0aW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlKHdoaWxlVGVzdENvbmRpdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50TGluZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRMaW5lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBjdXJyZW50U3RhdGVtZW50LmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0ID09ICdleGl0IHJlcGVhdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoaXMgaW5uZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHJlc3VsdCA9PSBcIm5leHQgcmVwZWF0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhpcyBpbm5lciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkQnJlYWspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiBvdXRlciB3aGlsZSBsb29wIChlbmQgcmVwZWF0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlVGVzdENvbmRpdGlvbiA9IHJlcGVhdEluZm8uY29uZGl0aW9uLmludGVycHJldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHN3aXRjaCBjYXNlXG4gICAgICAgICAgICBjYXNlICd3aXRoU3RhcnRGaW5pc2gnOlxuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIHdlIGFzc3VtZSB0aGF0IHN0YXJ0IGlzIGxlc3MgdGhhblxuICAgICAgICAgICAgICAgIC8vIGZpbmlzaC4gV2Ugc2hvdWxkIHByb2JhYmx5IHRocm93IGFuIGVycm9yIGlmXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgaWYocmVwZWF0SW5mby5zdGFydCA+IHJlcGVhdEluZm8uZmluaXNoKXtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXBlYXQgZXJyb3I6IHN0YXJ0IGdyZWF0ZXIgdGhhbiBmaW5pc2hgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSByZXBlYXRJbmZvLnN0YXJ0OyBpIDw9IHJlcGVhdEluZm8uZmluaXNoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1Db250ZXh0LmV4ZWN1dGlvblN0YWNrLmN1cnJlbnQuc2V0TG9jYWwocmVwZWF0SW5mby52YXJOYW1lLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRQYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBzdGF0ZW1lbnRMaW5lcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlbWVudCA9IHN0YXRlbWVudExpbmVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGN1cnJlbnRTdGF0ZW1lbnQuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQgPT0gXCJleGl0IHJlcGVhdFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGJyZWFrIG91dCBvZiB0aGlzIGlubmVyIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihyZXN1bHQgPT0gXCJuZXh0IHJlcGVhdFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYnJlYWsgb3V0IG9mIHRoaXMgaW5uZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHNob3VsZFBhc3Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHNob3VsZEJyZWFrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBicmVhayBvdXQgb2YgdGhlIG91dGVyIChyZXBlYXQpIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb3BlcnR5VmFsdWVfd2l0aFNwZWNpZmllcjogZnVuY3Rpb24odGhlTGl0ZXJhbCwgcHJvcE5hbWUsIG9mTGl0ZXJhbCwgb2JqZWN0U3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IG9iamVjdFNwZWNpZmllci5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBzeXN0ZW1Db250ZXh0LnBhcnRzQnlJZFt0YXJnZXRJZF07XG4gICAgICAgICAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhcnQgd2l0aCBpZCAke3RhcmdldElkfSAoJHt0aGlzLnNvdXJjZVN0cmluZ30pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHByb3BOYW1lLmludGVycHJldCgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb3BlcnR5VmFsdWVfd2l0aG91dFNwZWNpZmllcjogZnVuY3Rpb24odGhlTGl0ZXJhbCwgcHJvcE5hbWUpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRDb250ZXh0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgcGFydENvbnRleHQsXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUuaW50ZXJwcmV0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIE9iamVjdCBTcGVjaWZpZXJzICoqL1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlUYXJnZXQgUGFydGlhbCBTcGVjaWZpZXJcbiAgICAgICAgICogcmVmZXJzIHRvIHBhcnRpYWxzIHRoYXQgc3BlY2lmeSBhIHBhcnRcbiAgICAgICAgICogc3BlY2lmaWVkIGluIHRoZSBcInRhcmdldFwiIFBhcnRQcm9wZXJ0eVxuICAgICAgICAgKiBvZiB0aGUgY29udGV4dCBwYXJ0LiBUaGUgdmFsdWUgb2YgdGhlXG4gICAgICAgICAqIHRhcmdldCBwcm9wZXJ0eSBpcyBhbnkgdmFsaWQgT2JqZWN0U3BlY2lmaWVyXG4gICAgICAgICAqIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpYWxTcGVjaWZpZXJfcGFydEJ5VGFyZ2V0KHRhcmdldExpdGVyYWwpe1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFByb3BWYWx1ZSA9IGNvbnRleHQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChjb250ZXh0LCBcInRhcmdldFwiKTtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHBhcnRDb250ZXh0IHNpbmNlIHRoZSBjb250ZXh0IG9iamVjdCBtaWdodCBub3QgaGF2ZSBhbnkgc2VtYW50aWNzIHNldCBvbiBpdFxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBhIGNvbnRleHQgb2JqZWN0L3BhcnQgd2hpY2ggZG9lcyBub3QgaGF2ZSBhIHNjcmlwdCB3aGljaCBoYXMgYmVlblxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIHdpbGwgbm90IGhhdmUgaGFkIGNvbnRleHQuX3NlbWFudGljcyBzZXQuXG4gICAgICAgICAgICAgICAgbGV0IHNlbWFudGljcyA9IHBhcnRDb250ZXh0Ll9zZW1hbnRpY3M7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoT2JqZWN0ID0gc3lzdGVtQ29udGV4dC5ncmFtbWFyLm1hdGNoKHRhcmdldFByb3BWYWx1ZSwgJ09iamVjdFNwZWNpZmllcicpO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IHNlbWFudGljcyhtYXRjaE9iamVjdCkuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbUNvbnRleHQucGFydHNCeUlkW3RhcmdldElkXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50Q2FyZCBQYXJ0aWFsIFNwZWNpZmllclxuICAgICAgICAgKiByZWZlcnMgdG8gcGFydGlhbHMgdGhhdCBzcGVjaWZ5IHRoZSBjdXJyZW50IGNhcmRcbiAgICAgICAgICogZGVwZW5kaW5nIG9uIHRoZSBzdGFjayBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgUGFydGlhbFNwZWNpZmllcl9jdXJyZW50Q2FyZDogZnVuY3Rpb24oY3VycmVudExpdGVyYWwsIGNhcmRMaXRlcmFsKXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRQYXJ0LmN1cnJlbnRDYXJkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnRCeUluZGV4IFBhcnRpYWwgU3BlY2lmaWVyXG4gICAgICAgICAqIHJlZmVycyB0byBwYXJ0aWFscyB0aGF0IHNwZWNpZnkgYSBwYXJ0XG4gICAgICAgICAqIHR5cGUgYW5kIGFuIGludGVnZXIgbGl0ZXJhbCwgZm9yIGV4OlxuICAgICAgICAgKiAgICAgZmllbGQgM1xuICAgICAgICAgKiBUaGUgYWJvdmUgZXhhbXBsZSByZWZlcnMgdG8gdGhlIHRoaXJkXG4gICAgICAgICAqIGZpZWxkIHBhcnQgaW4gaXRzIG93bmVyL3BhcmVudCBwYXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgUGFydGlhbFNwZWNpZmllcl9wYXJ0QnlJbmRleDogZnVuY3Rpb24ob2JqZWN0VHlwZSwgaW50ZWdlckxpdGVyYWwpe1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gaW50ZWdlckxpdGVyYWwuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICBpZihpbmRleCA8IDEpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFydCBpbmRpY2VzIG11c3QgYmUgMSBvciBncmVhdGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFBhcnQpe1xuICAgICAgICAgICAgICAgIGlmKG9iamVjdFR5cGUuc291cmNlU3RyaW5nID09ICdwYXJ0Jyl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ID4gY29udGV4dFBhcnQuc3VicGFydHMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0UGFydC50eXBlfVske2NvbnRleHRQYXJ0LmlkfV0gZG9lcyBub3QgaGF2ZSBhIHBhcnQgbnVtYmVyZWQgJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFBhcnQuc3VicGFydHNbaW5kZXgtMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzT2ZUeXBlID0gY29udGV4dFBhcnQuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSBvYmplY3RUeXBlLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ID4gcGFydHNPZlR5cGUubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0UGFydC50eXBlfVske2NvbnRleHRQYXJ0LmlkfV0gZG9lcyBub3QgaGF2ZSBhICR7b2JqZWN0VHlwZS5zb3VyY2VTdHJpbmd9IG51bWJlcmVkICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzT2ZUeXBlW2luZGV4LTFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJ0QnlOdW1lcmljYWxJbmRleCBQYXJ0aWFsIFNwZWNpZmllclxuICAgICAgICAgKiByZWZlcnMgdG8gcGFydGlhbCB0aGF0IHNwZWNpZnkgYSBwYXJ0XG4gICAgICAgICAqIHR5cGUgcHJlY2VkZWQgYnkgdGhlIEVuZ2xpc2ggd29yZCBmb3IgdGhlXG4gICAgICAgICAqIG51bWJlci4gRm9yIHRoZSBtb21lbnQgd2UgYWNjZXB0IGZpcnN0IC0gdGVudGhcbiAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICogICAgIHNpeHRoIGJ1dHRvblxuICAgICAgICAgKi9cbiAgICAgICAgUGFydGlhbFNwZWNpZmllcl9wYXJ0QnlOdW1lcmljYWxJbmRleDogZnVuY3Rpb24obnVtZXJpY2FsS2V5d29yZCwgb2JqZWN0VHlwZSl7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBudW1lcmljYWxLZXl3b3JkLmludGVycHJldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICBpZihvYmplY3RUeXBlLnNvdXJjZVN0cmluZyA9PSAncGFydCcpe1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA+IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dFBhcnQudHlwZX1bJHtjb250ZXh0UGFydC5pZH1dIGRvZXMgbm90IGhhdmUgYSBwYXJ0IG51bWJlcmVkICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIGluZGV4IG9mIC0xIGluZGljYXRlcyB0aGUgXCJsYXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gb2YgdGhlIGRlc2lyZWQgY29sbGVjdGlvbiB3YXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRQYXJ0LnN1YnBhcnRzW2NvbnRleHRQYXJ0LnN1YnBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRQYXJ0LnN1YnBhcnRzW2luZGV4LTFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzT2ZUeXBlID0gY29udGV4dFBhcnQuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnBhcnQudHlwZSA9PSBvYmplY3RUeXBlLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ID4gcGFydHNPZlR5cGUubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0UGFydC50eXBlfVske2NvbnRleHRQYXJ0LmlkfV0gZG9lcyBub3QgaGF2ZSBhICR7b2JqZWN0VHlwZS5zb3VyY2VTdHJpbmd9IG51bWJlcmVkICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIGluZGV4IG9mIC0xIGluZGljYXRlcyB0aGUgXCJsYXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gb2YgdGhlIGRlc2lyZWQgY29sbGVjdGlvbiB3YXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzT2ZUeXBlW3BhcnRzT2ZUeXBlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzT2ZUeXBlW2luZGV4LTFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnRCeU5hbWUgUGFydGlhbCBTcGVjaWZpZXJcbiAgICAgICAgICogcmVmZXJzIHRvIGEgcGFydGlhbCB0aGF0IHNwZWNpZmllcyBhIHBhcnRcbiAgICAgICAgICogYnkgaXRzIG5hbWUgcHJvcGVydHkuIEV4YW1wbGU6XG4gICAgICAgICAqICAgICBjYXJkIFwiTXkgQ3VzdG9tIENhcmRcIlxuICAgICAgICAgKi9cbiAgICAgICAgUGFydGlhbFNwZWNpZmllcl9wYXJ0QnlOYW1lOiBmdW5jdGlvbihvYmplY3RUeXBlLCBzdHJpbmdMaXRlcmFsKXtcbiAgICAgICAgICAgIGxldCBuYW1lID0gc3RyaW5nTGl0ZXJhbC5pbnRlcnByZXQoKTtcbiAgICAgICAgICAgIGlmKG9iamVjdFR5cGUuc291cmNlU3RyaW5nID09ICdwYXJ0Jyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29udGV4dFBhcnQuc3VicGFydHMuZmlsdGVyKHN1YnBhcnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kTmFtZSA9IHN1YnBhcnQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJwYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09IGZvdW5kTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGZvdW5kLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHRQYXJ0LnR5cGV9WyR7Y29udGV4dFBhcnQuaWR9XSBkb2VzIG5vdCBoYXZlIGEgcGFydCBuYW1lZCBcIiR7bmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbnRleHRQYXJ0LnN1YnBhcnRzLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0LnR5cGUgPT0gb2JqZWN0VHlwZS5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbHRlcihzdWJwYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZE5hbWUgPSBzdWJwYXJ0LnBhcnRQcm9wZXJ0aWVzLmdldFByb3BlcnR5TmFtZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmROYW1lID09IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihmb3VuZC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0UGFydC50eXBlfVske2NvbnRleHRQYXJ0LmlkfV0gZG9lcyBub3QgaGF2ZSBhICR7b2JqZWN0VHlwZS5zb3VyY2VTdHJpbmd9IG5hbWVkIFwiJHtuYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICd0aGlzJyBzcGVjaWZpZXIgaXMgYSB0ZXJtaW5hbCAoZmluYWwpXG4gICAgICAgICAqIHNwZWNpZmllciB0aGF0IHJlZmVycyB0byBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgICAgICAgKiAxLiB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBwYXJ0IGV4ZWN1dGluZyB0aGUgc2NyaXB0LFxuICAgICAgICAgKiAgICBleGFtcGxlOiB0aGlzIGJ1dHRvblxuICAgICAgICAgKiAyLiBDYXJkLCB3aGljaCByZWZlcnMgdG8gdGhlIGNhcmQgdGhhdCBvd25zIHRoZVxuICAgICAgICAgKiAgICBwYXJ0IHRoYXQgaXMgY3VycmVudGx5IGV4ZWN1dGluZyB0aGUgc2NyaXB0LCBleDpcbiAgICAgICAgICogICAgdGhpcyBjYXJkXG4gICAgICAgICAqIDMuIFN0YWNrLCB3aGljaCByZWZlcnMgdG8gdGhlIHN0YWNrIHRoYXQgb3ducyB0aGVcbiAgICAgICAgICogICAgcGFydCB0aGF0IGlzIGN1cnJlbnRseSBleGVjdXRpbmcgdGhlIHNjcmlwdCwgZXg6XG4gICAgICAgICAqICAgIHRoaXMgc3RhY2tcbiAgICAgICAgICovXG4gICAgICAgIFRlcm1pbmFsU3BlY2lmaWVyX3RoaXNTeXN0ZW1PYmplY3Q6IGZ1bmN0aW9uKHRoaXNMaXRlcmFsLCBzeXN0ZW1PYmplY3Qpe1xuICAgICAgICAgICAgbGV0IHRhcmdldFR5cGUgPSBzeXN0ZW1PYmplY3Quc291cmNlU3RyaW5nO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICBpZih0YXJnZXRUeXBlID09IHBhcnRDb250ZXh0LnR5cGUpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydENvbnRleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmROZWFyZXN0UGFyZW50T2ZLaW5kKHBhcnRDb250ZXh0LCB0YXJnZXRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ2N1cnJlbnQnIHNwZWNpZmllciBpcyBhIHRlcm1pbmFsIChmaW5hbClcbiAgICAgICAgICogc3BlY2lmaWVyIHRoYXQgcmVmZXJzIHRvIGVpdGhlciB0aGUgY3VycmVudCBjYXJkIG9yIHN0YWNrXG4gICAgICAgICAqIGJlaW5nIGRpc3BsYXllZCB0byB0aGUgdXNlci5cbiAgICAgICAgICogVGhlcmUgYXJlIG9ubHkgdHdvIHBvc3NpYmxlIHZhbGlkIG9wdGlvbnM6XG4gICAgICAgICAqICAgICBgY3VycmVudCBjYXJkYFxuICAgICAgICAgKiAgICAgYGN1cnJlbnQgc3RhY2tgXG4gICAgICAgICAqL1xuICAgICAgICBUZXJtaW5hbFNwZWNpZmllcl9jdXJyZW50U3lzdGVtT2JqZWN0OiBmdW5jdGlvbihjdXJyZW50TGl0ZXJhbCwgc3lzdGVtT2JqZWN0KXtcbiAgICAgICAgICAgIGxldCB0YXJnZXRUeXBlID0gc3lzdGVtT2JqZWN0LnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0UGFydCl7XG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0VHlwZSA9PSAnc3RhY2snKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbUNvbnRleHQuZ2V0Q3VycmVudFN0YWNrTW9kZWwoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGFyZ2V0VHlwZSA9PSAnY2FyZCcpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtQ29udGV4dC5nZXRDdXJyZW50Q2FyZE1vZGVsKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RhcmdldFR5cGV9IGNhbm5vdCBiZSBhICdjdXJyZW50JyBzeXN0ZW0gb2JqZWN0YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnRCeUlkIHNwZWNpZmllciBpcyBhIHRlcm1pbmFsIChmaW5hbClcbiAgICAgICAgICogc3BlY2lmaWVyIHRoYXQgcmVmZXJzIHRvIGEgZ2l2ZW4gcGFydCB0eXBlXG4gICAgICAgICAqIGJ5IGl0cyB1bmlxdWUgc3lzdGVtIGlkLiBGb3IgYW55IGtpbmQgb2YgcGFydCxcbiAgICAgICAgICogd2UgdXNlIGBwYXJ0IGlkIDxvYmplY3RJZD5gXG4gICAgICAgICAqIEV4YW1wbGVzOiBgY2FyZCBpZCAyNjZgIGBwYXJ0IGlkIDVgXG4gICAgICAgICAqL1xuICAgICAgICBUZXJtaW5hbFNwZWNpZmllcl9wYXJ0QnlJZDogZnVuY3Rpb24ob2JqZWN0VHlwZSwgaWRMaXRlcmFsLCBvYmplY3RJZCl7XG4gICAgICAgICAgICBsZXQgaWQgPSBvYmplY3RJZC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBzeXN0ZW1Db250ZXh0LnBhcnRzQnlJZFtpZF07XG4gICAgICAgICAgICBpZighZm91bmQpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgJHtvYmplY3RUeXBlLnNvdXJjZVN0cmluZ30gd2l0aCBpZCAke29iamVjdElkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgXCJwcmVmaXhlZFwiIHF1ZXJpZWQgc3BlY2lmaWVyIGlzIGp1c3RcbiAgICAgICAgICogYSBQYXJ0aWFsU3BlY2lmaWVyIHdpdGggXCJvZlwiIGluIGZyb250IG9mIGl0LCBpbmRpY2F0aW5nXG4gICAgICAgICAqIHRoYXQgYSBkaWZmZXJlbnQgcGFydGlhbCB3aWxsIHByZWNlZGUgaXQgYmUgcXVlcmllZCBpbnNpZGUgb2YgaXQuXG4gICAgICAgICAqIEV4YW1wbGUgYG9mIGJ1dHRvbiBcIk15IEJ1dHRvblwiYFxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcmllZFNwZWNpZmllcl9wcmVmaXhlZDogZnVuY3Rpb24ocGFydGlhbFNwZWNpZmllciwgb2ZMaXRlcmFsKXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsU3BlY2lmaWVyLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG5lc3RlZCBxdWVyaWVkIHNwZWNpZmllciBpcyBvbmUgdGhhdCBoYXMgdHdvXG4gICAgICAgICAqIG9yIG1vcmUgcHJlZml4ZWQgc3BlY2lmaWVycy4gVGhlIHNpbXBsZXN0IHdvdWxkIGJlXG4gICAgICAgICAqIHNvbWV0aGluZyBsaWtlOlxuICAgICAgICAgKiAgICAgYG9mIGNhcmQgXCJNeSBDYXJkXCIgb2Ygc3RhY2sgXCJBbm90aGVyIG5hbWVkIHN0YWNrXCJgXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyaWVkU3BlY2lmaWVyX25lc3RlZDogZnVuY3Rpb24oZmlyc3RRdWVyeSwgc2Vjb25kUXVlcnkpe1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRQYXJ0KXtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBzZWNvbmRRdWVyeS5pbnRlcnByZXQoKShjb250ZXh0UGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IG91dGVyID0gZmlyc3RRdWVyeS5pbnRlcnByZXQoKShpbm5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JqZWN0U3BlY2lmaWVyIHdpdGhvdXQgYW4gYW5ub3RhdGVkXG4gICAgICAgICAqIHJ1bGUgbWVhbnMgaXQgd2FzIGludGVycHJldGVkIGFzIGp1c3RcbiAgICAgICAgICogYSBUZXJtaW5hbFNwZWNpZmllciBvZiBzb21lIHNvcnQuXG4gICAgICAgICAqIEhvd2V2ZXIsIHdlIG5lZWQgdG8gZXh0cmFjdCB0aGUgaWRcbiAgICAgICAgICogYW5kIHJldHVybiB0aGF0IHJlc3VsdCwgc2luY2UgdGhhdCBpcyB3aGF0IGlzXG4gICAgICAgICAqIGV4cGVjdGVkIG9mIGFsbCBpbnRlcnByZXRlZCBPYmplY3RTcGVjaWZpZXJzXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3RTcGVjaWZpZXJfc2luZ2xlVGVybWluYWw6IGZ1bmN0aW9uKHRlcm1pbmFsU3BlY2lmaWVyKXtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRlcm1pbmFsU3BlY2lmaWVyLmludGVycHJldCgpKCk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQuaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgQ29tcG91bmQgd2l0aCB0ZXJtaW5hbCBzcGVjaWZpZXIgaXMgYSBRdWVyaWVkU3BlY2lmaWVyXG4gICAgICAgICAqIHRoYXQgZmluaXNoZXMgd2l0aCBhIFRlcm1pbmFsIHNwZWNpZmllci5cbiAgICAgICAgICogRXhhbXBsZTogYG9mIGJ1dHRvbiAzIG9mIGNhcmQgXCJTb21lIG5hbWVkIGNhcmRcIiBvZiBjdXJyZW50IHN0YWNrYFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX2NvbXBvdW5kUXVlcnlXaXRoVGVybWluYWw6IGZ1bmN0aW9uKHF1ZXJpZWRTcGVjaWZpZXIsIHRlcm1pbmFsU3BlY2lmaWVyKXtcbiAgICAgICAgICAgIC8vIFRoZSB0ZXJtaW5hbCBoZXJlIGlzIHRoZSB1bHRpbWF0ZSBwYXJ0IGNvbnRleHRcbiAgICAgICAgICAgIGxldCBmaW5hbFBhcnQgPSB0ZXJtaW5hbFNwZWNpZmllci5pbnRlcnByZXQoKSgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHF1ZXJpZWRTcGVjaWZpZXIuaW50ZXJwcmV0KCkoZmluYWxQYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgQ29tcG91bmQgd2l0aG91dCB0ZXJtaW5hbCBzcGVjaWZpZXIgaXMgYSBRdWVyaWVkU3BlY2lmaWVyXG4gICAgICAgICAqIHRoYXQgZmluaXNoZXMgd2l0aCBhIFBhcnRpYWwgc3BlY2lmaWVyLlxuICAgICAgICAgKiBFeGFtcGxlOiBgb2YgYnV0dG9uIDMgb2YgZmlyc3QgY2FyZGAgKHdoaWNoIGNhbiBjb250aW51ZSBgLi5vZiBjdXJyZW50IHN0YWNrYCBldGMpXG4gICAgICAgICAqIGBmaXJzdCBidXR0b24gb2YgZmlyc3QgYXJlYSBvZiBzdGFjayAzYFxuICAgICAgICAgKiBgZmlyc3QgYnV0dG9uIG9mIGFyZWEgdHdvIG9mIHN0YWNrIDNgXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3RTcGVjaWZpZXJfY29tcG91bmRRdWVyeVdpdGhvdXRUZXJtaW5hbDogZnVuY3Rpb24ocXVlcmllZFNwZWNpZmllciwgcGFydGlhbFNwZWNpZmllcil7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFydGlhbFNwZWNmaWVyIHJlZmVycyB0byBlaXRoZXIgYXJlYSwgY2FyZCBvciBzdGFja1xuICAgICAgICAgICAgLy8gdGhlbiBnbyB0byBpdHMgb3duZXIgZm9yIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAvLyBpZiBpdCByZWZlcnMgdG8gdGhlIGN1cnJlbnQgY2FyZCB0aGVuIGZpbmQgdGhlIG93bmVyIGZvciB0aGUgY29udGV4dFxuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gcGFydGlhbFNwZWNpZmllci5jaGlsZHJlblswXS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGxldCBzeXN0ZW1PYmplY3RTdHJpbmc7XG4gICAgICAgICAgICBpZihjaGlsZHJlblswXS5zb3VyY2VTdHJpbmcgPT0gXCJjdXJyZW50XCIgJiYgY2hpbGRyZW5bMV0uc291cmNlU3RyaW5nID09IFwiY2FyZFwiKXtcbiAgICAgICAgICAgICAgICBzeXN0ZW1PYmplY3RTdHJpbmcgPSBcImNhcmRcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQuY3Rvck5hbWUgPT0gXCJzeXN0ZW1PYmplY3RcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeXN0ZW1PYmplY3RTdHJpbmcgPSBjaGlsZC5zb3VyY2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaW5hbFBhcnQgPSBmaW5kRmlyc3RQb3NzaWJsZUFuY2VzdG9yKHBhcnRDb250ZXh0LCBzeXN0ZW1PYmplY3RTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IGZpbmFsUGFydGlhbCA9IHBhcnRpYWxTcGVjaWZpZXIuaW50ZXJwcmV0KCkoZmluYWxQYXJ0KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBxdWVyaWVkU3BlY2lmaWVyLmludGVycHJldCgpKGZpbmFsUGFydGlhbCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpbmdsZSBub24tdGVybWluYWwgT2JqZWN0U3BlY2lmaWVyIGlzIGp1c3QgYSBQYXJ0aWFsXG4gICAgICAgICAqIHNwZWNpZmllciBieSBpdHNlbGYuIFdoZW4gcHJlc2VudCBvdXRzaWRlIG9mIGEgUXVlcmllZFNwZWNpZmllcixcbiAgICAgICAgICogaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBpbiB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB0cmVhdGVkXG4gICAgICAgICAqIGFzIHRlcm1pbmFsL2ZpbmFsLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICogICAgIGJ1dHRvbiA0XG4gICAgICAgICAqIGJ5IGl0c2VsZiBhcyBhIHdob2xlIHNwZWNpZmllciB3aWxsIGJlIGludGVycHJldGVkIGFzXG4gICAgICAgICAqIGBidXR0b24gNCBvZiB0aGlzIGNhcmRgXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3RTcGVjaWZpZXJfc2luZ2xlTm9uVGVybWluYWw6IGZ1bmN0aW9uKHBhcnRpYWxTcGVjaWZpZXIpe1xuICAgICAgICAgICAgLy8gQSBzaW5nbGUgbm9uLXRlcm1pbmFsIG9iamVjdCBzcGVjaWZpZXIgaXMgb25lXG4gICAgICAgICAgICAvLyB3aG9zZSB0ZXJtaW5hbCBvYmplY3QgaXMgaW1wbGljaXRseSBhc3N1bWVkIHRvXG4gICAgICAgICAgICAvLyBiZSB0aGUgY2FyZCBvciB0aGUgc3RhY2sgaW4gd2hpY2ggdGhlIGN1cnJlbnQgY29udGV4dCBwYXJ0XG4gICAgICAgICAgICAvLyBleGlzdHMuXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBwYXJ0aWFsU3BlY2lmaWVyLmNoaWxkcmVuWzBdLmNoaWxkcmVuO1xuICAgICAgICAgICAgbGV0IHN5c3RlbU9iamVjdFN0cmluZztcbiAgICAgICAgICAgIGlmKGNoaWxkcmVuWzBdLnNvdXJjZVN0cmluZyA9PSBcImN1cnJlbnRcIiAmJiBjaGlsZHJlblsxXS5zb3VyY2VTdHJpbmcgPT0gXCJjYXJkXCIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1Db250ZXh0LmdldEN1cnJlbnRDYXJkTW9kZWwoKS5pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQuc291cmNlU3RyaW5nID09IFwicGFydFwiIHx8IGNoaWxkLnNvdXJjZVN0cmluZyA9PSBcInRhcmdldFwiIHx8IGNoaWxkLmN0b3JOYW1lID09ICdzeXN0ZW1PYmplY3QnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5c3RlbU9iamVjdFN0cmluZyA9IGNoaWxkLnNvdXJjZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlIHN5c3RlbU9iamVjdCBpcyB0aGUgdGFyZ2V0IChkZWZpbmVkIGluIGl0J3MgXCJ0YXJnZXRcIiBwYXJ0IHByb3BlcnR5KSwgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBmaXJzdCBnZXQgdGhlIHRhcmdldCBwcm9wZXJ0eSB2YWx1ZSAoc3RyaW5nKSBhbmQgaW50ZXJwcmV0IHRoYXRcbiAgICAgICAgICAgIGlmKHN5c3RlbU9iamVjdFN0cmluZyA9PSBcInRhcmdldFwiKXtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0UHJvcFZhbHVlID0gcGFydENvbnRleHQucGFydFByb3BlcnRpZXMuZ2V0UHJvcGVydHlOYW1lZChwYXJ0Q29udGV4dCwgXCJ0YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgbGV0IHNlbWFudGljcyA9IHBhcnRDb250ZXh0Ll9zZW1hbnRpY3M7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoT2JqZWN0ID0gc3lzdGVtQ29udGV4dC5ncmFtbWFyLm1hdGNoKHRhcmdldFByb3BWYWx1ZSwgJ09iamVjdFNwZWNpZmllcicpO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IHNlbWFudGljcyhtYXRjaE9iamVjdCkuaW50ZXJwcmV0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldElkO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHN5c3RlbU9iamVjdFN0cmluZyA9PSBcImN1cnJlbnQgY2FyZFwiKXtcbiAgICAgICAgICAgICAgICBzeXN0ZW1PYmplY3RTdHJpbmcgPSBcImNhcmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaW5hbFBhcnQgPSBmaW5kRmlyc3RQb3NzaWJsZUFuY2VzdG9yKHBhcnRDb250ZXh0LCBzeXN0ZW1PYmplY3RTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnRpYWxTcGVjaWZpZXIuaW50ZXJwcmV0KCkoZmluYWxQYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgT2JqZWN0U3BlY2lmaWVyX3NpbmdsZVRlcm1pbmFsOiBmdW5jdGlvbih0ZXJtaW5hbFNwZWNpZmllcil7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGVybWluYWxTcGVjaWZpZXIuaW50ZXJwcmV0KCkocGFydENvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICBhbnlMaXRlcmFsOiBmdW5jdGlvbih0aGVMaXRlcmFsKXtcbiAgICAgICAgICAgIHJldHVybiB0aGVMaXRlcmFsLmludGVycHJldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKG9wZW5RdW90ZSwgdGV4dCwgY2xvc2VRdW90ZSl7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5zb3VyY2VTdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYm9vbGVhbkxpdGVyYWw6IGZ1bmN0aW9uKHRleHQpe1xuICAgICAgICAgICAgaWYodGV4dC5zb3VyY2VTdHJpbmcgPT0gJ3RydWUnKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRleHQuc291cmNlU3RyaW5nID09ICdmYWxzZScpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBib29sZWFuIGxpdGVyYWw6ICR7dGV4dH1gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlZ2VyTGl0ZXJhbDogZnVuY3Rpb24obmVnYXRpdmVTaWduLCBpbnRlZ2VyKXtcbiAgICAgICAgICAgIGxldCBpbnQgPSBwYXJzZUludChpbnRlZ2VyLnNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICBsZXQgaGFzTmVnYXRpdmUgPSAobmVnYXRpdmVTaWduLnNvdXJjZVN0cmluZyA9PSBcIi1cIik7XG4gICAgICAgICAgICBpZihoYXNOZWdhdGl2ZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xICogaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludDsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxvYXRMaXRlcmFsOiBmdW5jdGlvbihuZWdhdGl2ZVNpZ24sIG9uZXNQbGFjZSwgZGVjaW1hbCwgcmVzdFBsYWNlKXtcbiAgICAgICAgICAgIGxldCBmbG9hdFN0cmluZyA9IGAke29uZXNQbGFjZS5zb3VyY2VTdHJpbmd9LiR7cmVzdFBsYWNlLnNvdXJjZVN0cmluZ31gO1xuICAgICAgICAgICAgbGV0IGhhc05lZ2F0aXZlID0gKG5lZ2F0aXZlU2lnbi5zb3VyY2VTdHJpbmcgPT0gXCItXCIpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRmxvYXQoZmxvYXRTdHJpbmcpO1xuICAgICAgICAgICAgaWYoaGFzTmVnYXRpdmUpe1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbnVtZXJpY2FsS2V5d29yZDogZnVuY3Rpb24obnVtZXJhbE5hbWUpe1xuICAgICAgICAgICAgc3dpdGNoKG51bWVyYWxOYW1lLnNvdXJjZVN0cmluZyl7XG4gICAgICAgICAgICBjYXNlICdmaXJzdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAndGhpcmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgY2FzZSAnZm91cnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgIGNhc2UgJ2ZpZnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgIGNhc2UgJ3NpeHRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgICAgIGNhc2UgJ3NldmVudGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICAgICAgY2FzZSAnZWlnaHRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIGNhc2UgJ25pbnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIGNhc2UgJ3RlbnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YXJpYWJsZU5hbWU6IGZ1bmN0aW9uKGxldHRlclBsdXMsIG9wdGlvbmFsRGlnaXRzKXtcbiAgICAgICAgICAgIC8vIExvb2t1cCB0aGUgdmFyaWFibGUgaW4gdGhlIHBhcnQnc1xuICAgICAgICAgICAgLy8gY3VycmVudCBleGVjdXRpb24gY29udGV4dFxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhcmlhYmxlIGlzIG5vdCBhIGtleSBvbiB0aGUgb2JqZWN0LFxuICAgICAgICAgICAgLy8gd2UgdGhyb3cgYW4gZXJyb3I6IHRoaXMgbWVhbnMgdGhlIHZhcmlhYmxlIGhhcyBub3QgeWV0XG4gICAgICAgICAgICAvLyBiZWVuIGRlZmluZWQgYnV0IGlzIGJlaW5nIGxvb2tlZCB1cC5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHN5c3RlbUNvbnRleHQuZXhlY3V0aW9uU3RhY2suY3VycmVudC5nZXQodGhpcy5zb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgaWYodmFsdWUgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU1RWYXJpYWJsZVJlZmVyZW5jZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgVmFyaWFibGUgJHt0aGlzLnNvdXJjZVN0cmluZ30gaGFzIG5vdCBiZWVuIGRlZmluZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21tZW50OiBmdW5jdGlvbihkYXNoZXNMaXRlcmFsLCBub25MaW5lVGVybWluYXRvckNoYXJzKXtcbiAgICAgICAgICAgIC8vIEludGVycHJldCBkb2Vzbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAvLyB3aXRoIGNvbW1lbnRzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Rlcm1pbmFsKCl7XG5cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbmV4cG9ydCB7XG4gICAgY3JlYXRlSW50ZXJwcmV0ZXJTZW1hbnRpY3MsXG4gICAgY3JlYXRlSW50ZXJwcmV0ZXJTZW1hbnRpY3MgYXMgZGVmYXVsdFxufTtcbiIsInZhciBvaG0gPSByZXF1aXJlKCcuLicpO1xubW9kdWxlLmV4cG9ydHMgPSBvaG0ubWFrZVJlY2lwZShbXCJncmFtbWFyXCIse1wic291cmNlXCI6XCJCdWlsdEluUnVsZXMge1xcblxcbiAgYWxudW0gIChhbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcilcXG4gICAgPSBsZXR0ZXJcXG4gICAgfCBkaWdpdFxcblxcbiAgbGV0dGVyICAoYSBsZXR0ZXIpXFxuICAgID0gbG93ZXJcXG4gICAgfCB1cHBlclxcbiAgICB8IHVuaWNvZGVMdG1vXFxuXFxuICBkaWdpdCAgKGEgZGlnaXQpXFxuICAgID0gXFxcIjBcXFwiLi5cXFwiOVxcXCJcXG5cXG4gIGhleERpZ2l0ICAoYSBoZXhhZGVjaW1hbCBkaWdpdClcXG4gICAgPSBkaWdpdFxcbiAgICB8IFxcXCJhXFxcIi4uXFxcImZcXFwiXFxuICAgIHwgXFxcIkFcXFwiLi5cXFwiRlxcXCJcXG5cXG4gIExpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gTm9uZW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICB8IEVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG5cXG4gIE5vbmVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgPSBlbGVtIChzZXAgZWxlbSkqXFxuXFxuICBFbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgID0gLyogbm90aGluZyAqL1xcblxcbiAgbGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgPSBub25lbXB0eUxpc3RPZjxlbGVtLCBzZXA+XFxuICAgIHwgZW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcblxcbiAgbm9uZW1wdHlMaXN0T2Y8ZWxlbSwgc2VwPlxcbiAgICA9IGVsZW0gKHNlcCBlbGVtKSpcXG5cXG4gIGVtcHR5TGlzdE9mPGVsZW0sIHNlcD5cXG4gICAgPSAvKiBub3RoaW5nICovXFxuXFxufVwifSxcIkJ1aWx0SW5SdWxlc1wiLG51bGwsbnVsbCx7XCJhbG51bVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4LDc4XX0sXCJhbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlclwiLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYwLDc4XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjAsNjZdfSxcImxldHRlclwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3Myw3OF19LFwiZGlnaXRcIixbXV1dXSxcImxldHRlclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzgyLDE0Ml19LFwiYSBsZXR0ZXJcIixbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDcsMTQyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTA3LDExMl19LFwibG93ZXJcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTE5LDEyNF19LFwidXBwZXJcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDE0Ml19LFwidW5pY29kZUx0bW9cIixbXV1dXSxcImRpZ2l0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ2LDE3N119LFwiYSBkaWdpdFwiLFtdLFtcInJhbmdlXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTY5LDE3N119LFwiMFwiLFwiOVwiXV0sXCJoZXhEaWdpdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4MSwyNTRdfSxcImEgaGV4YWRlY2ltYWwgZGlnaXRcIixbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTksMjU0XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE5LDIyNF19LFwiZGlnaXRcIixbXV0sW1wicmFuZ2VcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzEsMjM5XX0sXCJhXCIsXCJmXCJdLFtcInJhbmdlXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ2LDI1NF19LFwiQVwiLFwiRlwiXV1dLFwiTGlzdE9mXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU4LDMzNl19LG51bGwsW1wiZWxlbVwiLFwic2VwXCJdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI4MiwzMzZdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyODIsMzA3XX0sXCJOb25lbXB0eUxpc3RPZlwiLFtbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI5NywzMDFdfSwwXSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzMwMywzMDZdfSwxXV1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzMxNCwzMzZdfSxcIkVtcHR5TGlzdE9mXCIsW1tcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzI2LDMzMF19LDBdLFtcInBhcmFtXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzMyLDMzNV19LDFdXV1dXSxcIk5vbmVtcHR5TGlzdE9mXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzQwLDM4OF19LG51bGwsW1wiZWxlbVwiLFwic2VwXCJdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM3MiwzODhdfSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM3MiwzNzZdfSwwXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzc3LDM4OF19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM3OCwzODZdfSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM3OCwzODFdfSwxXSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4MiwzODZdfSwwXV1dXV0sXCJFbXB0eUxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzM5Miw0MzRdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0MzgsNDM4XX1dXSxcImxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzQzOCw1MTZdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NjIsNTE2XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDYyLDQ4N119LFwibm9uZW1wdHlMaXN0T2ZcIixbW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NzcsNDgxXX0sMF0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0ODMsNDg2XX0sMV1dXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0OTQsNTE2XX0sXCJlbXB0eUxpc3RPZlwiLFtbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzUwNiw1MTBdfSwwXSxbXCJwYXJhbVwiLHtcInNvdXJjZUludGVydmFsXCI6WzUxMiw1MTVdfSwxXV1dXV0sXCJub25lbXB0eUxpc3RPZlwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzUyMCw1NjhdfSxudWxsLFtcImVsZW1cIixcInNlcFwiXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NTIsNTY4XX0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NTIsNTU2XX0sMF0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzU1Nyw1NjhdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NTgsNTY2XX0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NTgsNTYxXX0sMV0sW1wicGFyYW1cIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NjIsNTY2XX0sMF1dXV1dLFwiZW1wdHlMaXN0T2ZcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1NzIsNjE0XX0sbnVsbCxbXCJlbGVtXCIsXCJzZXBcIl0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjE2LDYxNl19XV19XSk7XG4iLCJ2YXIgb2htID0gcmVxdWlyZSgnLi4nKTtcbm1vZHVsZS5leHBvcnRzID0gb2htLm1ha2VSZWNpcGUoW1wiZ3JhbW1hclwiLHtcInNvdXJjZVwiOlwiT2htIHtcXG5cXG4gIEdyYW1tYXJzXFxuICAgID0gR3JhbW1hcipcXG5cXG4gIEdyYW1tYXJcXG4gICAgPSBpZGVudCBTdXBlckdyYW1tYXI/IFxcXCJ7XFxcIiBSdWxlKiBcXFwifVxcXCJcXG5cXG4gIFN1cGVyR3JhbW1hclxcbiAgICA9IFxcXCI8OlxcXCIgaWRlbnRcXG5cXG4gIFJ1bGVcXG4gICAgPSBpZGVudCBGb3JtYWxzPyBydWxlRGVzY3I/IFxcXCI9XFxcIiAgUnVsZUJvZHkgIC0tIGRlZmluZVxcbiAgICB8IGlkZW50IEZvcm1hbHM/ICAgICAgICAgICAgXFxcIjo9XFxcIiBPdmVycmlkZVJ1bGVCb2R5ICAtLSBvdmVycmlkZVxcbiAgICB8IGlkZW50IEZvcm1hbHM/ICAgICAgICAgICAgXFxcIis9XFxcIiBSdWxlQm9keSAgLS0gZXh0ZW5kXFxuXFxuICBSdWxlQm9keVxcbiAgICA9IFxcXCJ8XFxcIj8gTm9uZW1wdHlMaXN0T2Y8VG9wTGV2ZWxUZXJtLCBcXFwifFxcXCI+XFxuXFxuICBUb3BMZXZlbFRlcm1cXG4gICAgPSBTZXEgY2FzZU5hbWUgIC0tIGlubGluZVxcbiAgICB8IFNlcVxcblxcbiAgT3ZlcnJpZGVSdWxlQm9keVxcbiAgICA9IFxcXCJ8XFxcIj8gTm9uZW1wdHlMaXN0T2Y8T3ZlcnJpZGVUb3BMZXZlbFRlcm0sIFxcXCJ8XFxcIj5cXG5cXG4gIE92ZXJyaWRlVG9wTGV2ZWxUZXJtXFxuICAgID0gXFxcIi4uLlxcXCIgIC0tIHN1cGVyU3BsaWNlXFxuICAgIHwgVG9wTGV2ZWxUZXJtXFxuXFxuICBGb3JtYWxzXFxuICAgID0gXFxcIjxcXFwiIExpc3RPZjxpZGVudCwgXFxcIixcXFwiPiBcXFwiPlxcXCJcXG5cXG4gIFBhcmFtc1xcbiAgICA9IFxcXCI8XFxcIiBMaXN0T2Y8U2VxLCBcXFwiLFxcXCI+IFxcXCI+XFxcIlxcblxcbiAgQWx0XFxuICAgID0gTm9uZW1wdHlMaXN0T2Y8U2VxLCBcXFwifFxcXCI+XFxuXFxuICBTZXFcXG4gICAgPSBJdGVyKlxcblxcbiAgSXRlclxcbiAgICA9IFByZWQgXFxcIipcXFwiICAtLSBzdGFyXFxuICAgIHwgUHJlZCBcXFwiK1xcXCIgIC0tIHBsdXNcXG4gICAgfCBQcmVkIFxcXCI/XFxcIiAgLS0gb3B0XFxuICAgIHwgUHJlZFxcblxcbiAgUHJlZFxcbiAgICA9IFxcXCJ+XFxcIiBMZXggIC0tIG5vdFxcbiAgICB8IFxcXCImXFxcIiBMZXggIC0tIGxvb2thaGVhZFxcbiAgICB8IExleFxcblxcbiAgTGV4XFxuICAgID0gXFxcIiNcXFwiIEJhc2UgIC0tIGxleFxcbiAgICB8IEJhc2VcXG5cXG4gIEJhc2VcXG4gICAgPSBpZGVudCBQYXJhbXM/IH4ocnVsZURlc2NyPyBcXFwiPVxcXCIgfCBcXFwiOj1cXFwiIHwgXFxcIis9XFxcIikgIC0tIGFwcGxpY2F0aW9uXFxuICAgIHwgb25lQ2hhclRlcm1pbmFsIFxcXCIuLlxcXCIgb25lQ2hhclRlcm1pbmFsICAgICAgICAgICAtLSByYW5nZVxcbiAgICB8IHRlcm1pbmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gdGVybWluYWxcXG4gICAgfCBcXFwiKFxcXCIgQWx0IFxcXCIpXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIHBhcmVuXFxuXFxuICBydWxlRGVzY3IgIChhIHJ1bGUgZGVzY3JpcHRpb24pXFxuICAgID0gXFxcIihcXFwiIHJ1bGVEZXNjclRleHQgXFxcIilcXFwiXFxuXFxuICBydWxlRGVzY3JUZXh0XFxuICAgID0gKH5cXFwiKVxcXCIgYW55KSpcXG5cXG4gIGNhc2VOYW1lXFxuICAgID0gXFxcIi0tXFxcIiAoflxcXCJcXFxcblxcXCIgc3BhY2UpKiBuYW1lICh+XFxcIlxcXFxuXFxcIiBzcGFjZSkqIChcXFwiXFxcXG5cXFwiIHwgJlxcXCJ9XFxcIilcXG5cXG4gIG5hbWUgIChhIG5hbWUpXFxuICAgID0gbmFtZUZpcnN0IG5hbWVSZXN0KlxcblxcbiAgbmFtZUZpcnN0XFxuICAgID0gXFxcIl9cXFwiXFxuICAgIHwgbGV0dGVyXFxuXFxuICBuYW1lUmVzdFxcbiAgICA9IFxcXCJfXFxcIlxcbiAgICB8IGFsbnVtXFxuXFxuICBpZGVudCAgKGFuIGlkZW50aWZpZXIpXFxuICAgID0gbmFtZVxcblxcbiAgdGVybWluYWxcXG4gICAgPSBcXFwiXFxcXFxcXCJcXFwiIHRlcm1pbmFsQ2hhciogXFxcIlxcXFxcXFwiXFxcIlxcblxcbiAgb25lQ2hhclRlcm1pbmFsXFxuICAgID0gXFxcIlxcXFxcXFwiXFxcIiB0ZXJtaW5hbENoYXIgXFxcIlxcXFxcXFwiXFxcIlxcblxcbiAgdGVybWluYWxDaGFyXFxuICAgID0gZXNjYXBlQ2hhclxcbiAgICB8IH5cXFwiXFxcXFxcXFxcXFwiIH5cXFwiXFxcXFxcXCJcXFwiIH5cXFwiXFxcXG5cXFwiIGFueVxcblxcbiAgZXNjYXBlQ2hhciAgKGFuIGVzY2FwZSBzZXF1ZW5jZSlcXG4gICAgPSBcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gYmFja3NsYXNoXFxuICAgIHwgXFxcIlxcXFxcXFxcXFxcXFxcXCJcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIGRvdWJsZVF1b3RlXFxuICAgIHwgXFxcIlxcXFxcXFxcXFxcXCdcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIHNpbmdsZVF1b3RlXFxuICAgIHwgXFxcIlxcXFxcXFxcYlxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIGJhY2tzcGFjZVxcbiAgICB8IFxcXCJcXFxcXFxcXG5cXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBsaW5lRmVlZFxcbiAgICB8IFxcXCJcXFxcXFxcXHJcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBjYXJyaWFnZVJldHVyblxcbiAgICB8IFxcXCJcXFxcXFxcXHRcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSB0YWJcXG4gICAgfCBcXFwiXFxcXFxcXFx1XFxcIiBoZXhEaWdpdCBoZXhEaWdpdCBoZXhEaWdpdCBoZXhEaWdpdCAgLS0gdW5pY29kZUVzY2FwZVxcbiAgICB8IFxcXCJcXFxcXFxcXHhcXFwiIGhleERpZ2l0IGhleERpZ2l0ICAgICAgICAgICAgICAgICAgICAtLSBoZXhFc2NhcGVcXG5cXG4gIHNwYWNlXFxuICAgKz0gY29tbWVudFxcblxcbiAgY29tbWVudFxcbiAgICA9IFxcXCIvL1xcXCIgKH5cXFwiXFxcXG5cXFwiIGFueSkqICYoXFxcIlxcXFxuXFxcIiB8IGVuZCkgIC0tIHNpbmdsZUxpbmVcXG4gICAgfCBcXFwiLypcXFwiICh+XFxcIiovXFxcIiBhbnkpKiBcXFwiKi9cXFwiICAtLSBtdWx0aUxpbmVcXG5cXG4gIHRva2VucyA9IHRva2VuKlxcblxcbiAgdG9rZW4gPSBjYXNlTmFtZSB8IGNvbW1lbnQgfCBpZGVudCB8IG9wZXJhdG9yIHwgcHVuY3R1YXRpb24gfCB0ZXJtaW5hbCB8IGFueVxcblxcbiAgb3BlcmF0b3IgPSBcXFwiPDpcXFwiIHwgXFxcIj1cXFwiIHwgXFxcIjo9XFxcIiB8IFxcXCIrPVxcXCIgfCBcXFwiKlxcXCIgfCBcXFwiK1xcXCIgfCBcXFwiP1xcXCIgfCBcXFwiflxcXCIgfCBcXFwiJlxcXCJcXG5cXG4gIHB1bmN0dWF0aW9uID0gXFxcIjxcXFwiIHwgXFxcIj5cXFwiIHwgXFxcIixcXFwiIHwgXFxcIi0tXFxcIlxcbn1cIn0sXCJPaG1cIixudWxsLFwiR3JhbW1hcnNcIix7XCJHcmFtbWFyc1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzksMzJdfSxudWxsLFtdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNCwzMl19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0LDMxXX0sXCJHcmFtbWFyXCIsW11dXV0sXCJHcmFtbWFyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzYsODNdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzUwLDgzXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTAsNTVdfSxcImlkZW50XCIsW11dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzU2LDY5XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTYsNjhdfSxcIlN1cGVyR3JhbW1hclwiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MCw3M119LFwie1wiXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQsNzldfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NCw3OF19LFwiUnVsZVwiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4MCw4M119LFwifVwiXV1dLFwiU3VwZXJHcmFtbWFyXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODcsMTE2XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDYsMTE2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDYsMTEwXX0sXCI8OlwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTEsMTE2XX0sXCJpZGVudFwiLFtdXV1dLFwiUnVsZV9kZWZpbmVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEsMTgxXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEsMTcwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxLDEzNl19LFwiaWRlbnRcIixbXV0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM3LDE0NV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNywxNDRdfSxcIkZvcm1hbHNcIixbXV1dLFtcIm9wdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NiwxNTZdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDYsMTU1XX0sXCJydWxlRGVzY3JcIixbXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU3LDE2MF19LFwiPVwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjIsMTcwXX0sXCJSdWxlQm9keVwiLFtdXV1dLFwiUnVsZV9vdmVycmlkZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4OCwyNDhdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4OCwyMzVdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODgsMTkzXX0sXCJpZGVudFwiLFtdXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTQsMjAyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTk0LDIwMV19LFwiRm9ybWFsc1wiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTQsMjE4XX0sXCI6PVwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTksMjM1XX0sXCJPdmVycmlkZVJ1bGVCb2R5XCIsW11dXV0sXCJSdWxlX2V4dGVuZFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NSwzMDVdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NSwyOTRdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTUsMjYwXX0sXCJpZGVudFwiLFtdXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNjEsMjY5XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjYxLDI2OF19LFwiRm9ybWFsc1wiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyODEsMjg1XX0sXCIrPVwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyODYsMjk0XX0sXCJSdWxlQm9keVwiLFtdXV1dLFwiUnVsZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMCwzMDVdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMSwzMDVdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEsMTcwXX0sXCJSdWxlX2RlZmluZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODgsMjM1XX0sXCJSdWxlX292ZXJyaWRlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NSwyOTRdfSxcIlJ1bGVfZXh0ZW5kXCIsW11dXV0sXCJSdWxlQm9keVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzMwOSwzNjJdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzMyNCwzNjJdfSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMjQsMzI4XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMjQsMzI3XX0sXCJ8XCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszMjksMzYyXX0sXCJOb25lbXB0eUxpc3RPZlwiLFtbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNDQsMzU2XX0sXCJUb3BMZXZlbFRlcm1cIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNTgsMzYxXX0sXCJ8XCJdXV1dXSxcIlRvcExldmVsVGVybV9pbmxpbmVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODUsNDA4XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODUsMzk3XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDM4OF19LFwiU2VxXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzM4OSwzOTddfSxcImNhc2VOYW1lXCIsW11dXV0sXCJUb3BMZXZlbFRlcm1cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszNjYsNDE4XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlszODUsNDE4XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMzg1LDM5N119LFwiVG9wTGV2ZWxUZXJtX2lubGluZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0MTUsNDE4XX0sXCJTZXFcIixbXV1dXSxcIk92ZXJyaWRlUnVsZUJvZHlcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0MjIsNDkxXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0NDUsNDkxXX0sW1wib3B0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDQ1LDQ0OV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDQ1LDQ0OF19LFwifFwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDUwLDQ5MV19LFwiTm9uZW1wdHlMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNDY1LDQ4NV19LFwiT3ZlcnJpZGVUb3BMZXZlbFRlcm1cIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0ODcsNDkwXX0sXCJ8XCJdXV1dXSxcIk92ZXJyaWRlVG9wTGV2ZWxUZXJtX3N1cGVyU3BsaWNlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTIyLDU0M119LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MjIsNTI3XX0sXCIuLi5cIl1dLFwiT3ZlcnJpZGVUb3BMZXZlbFRlcm1cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls0OTUsNTYyXX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1MjIsNTYyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTIyLDUyN119LFwiT3ZlcnJpZGVUb3BMZXZlbFRlcm1fc3VwZXJTcGxpY2VcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTUwLDU2Ml19LFwiVG9wTGV2ZWxUZXJtXCIsW11dXV0sXCJGb3JtYWxzXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTY2LDYwNl19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTgwLDYwNl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTgwLDU4M119LFwiPFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1ODQsNjAyXX0sXCJMaXN0T2ZcIixbW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTkxLDU5Nl19LFwiaWRlbnRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls1OTgsNjAxXX0sXCIsXCJdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MDMsNjA2XX0sXCI+XCJdXV0sXCJQYXJhbXNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MTAsNjQ3XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MjMsNjQ3XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MjMsNjI2XX0sXCI8XCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzYyNyw2NDNdfSxcIkxpc3RPZlwiLFtbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MzQsNjM3XX0sXCJTZXFcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2MzksNjQyXX0sXCIsXCJdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2NDQsNjQ3XX0sXCI+XCJdXV0sXCJBbHRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2NTEsNjg1XX0sbnVsbCxbXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2NjEsNjg1XX0sXCJOb25lbXB0eUxpc3RPZlwiLFtbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2NzYsNjc5XX0sXCJTZXFcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2ODEsNjg0XX0sXCJ8XCJdXV1dLFwiU2VxXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjg5LDcwNF19LG51bGwsW10sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzY5OSw3MDRdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls2OTksNzAzXX0sXCJJdGVyXCIsW11dXV0sXCJJdGVyX3N0YXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MTksNzM2XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MTksNzI3XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDcyM119LFwiUHJlZFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzcyNCw3MjddfSxcIipcIl1dXSxcIkl0ZXJfcGx1c1wiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0Myw3NjBdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0Myw3NTFdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NDMsNzQ3XX0sXCJQcmVkXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzQ4LDc1MV19LFwiK1wiXV1dLFwiSXRlcl9vcHRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NjcsNzgzXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NjcsNzc1XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzY3LDc3MV19LFwiUHJlZFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc3Miw3NzVdfSxcIj9cIl1dXSxcIkl0ZXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MDgsNzk0XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3MTksNzk0XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzE5LDcyN119LFwiSXRlcl9zdGFyXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzc0Myw3NTFdfSxcIkl0ZXJfcGx1c1wiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3NjcsNzc1XX0sXCJJdGVyX29wdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls3OTAsNzk0XX0sXCJQcmVkXCIsW11dXV0sXCJQcmVkX25vdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzgwOSw4MjRdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzgwOSw4MTZdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgwOSw4MTJdfSxcIn5cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODEzLDgxNl19LFwiTGV4XCIsW11dXV0sXCJQcmVkX2xvb2thaGVhZFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzgzMSw4NTJdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzgzMSw4MzhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgzMSw4MzRdfSxcIiZcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODM1LDgzOF19LFwiTGV4XCIsW11dXV0sXCJQcmVkXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNzk4LDg2Ml19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbODA5LDg2Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgwOSw4MTZdfSxcIlByZWRfbm90XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzgzMSw4MzhdfSxcIlByZWRfbG9va2FoZWFkXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg1OSw4NjJdfSxcIkxleFwiLFtdXV1dLFwiTGV4X2xleFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3Niw4OTJdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3Niw4ODRdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3Niw4NzldfSxcIiNcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODgwLDg4NF19LFwiQmFzZVwiLFtdXV1dLFwiTGV4XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODY2LDkwM119LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbODc2LDkwM119LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzg3Niw4ODRdfSxcIkxleF9sZXhcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbODk5LDkwM119LFwiQmFzZVwiLFtdXV1dLFwiQmFzZV9hcHBsaWNhdGlvblwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzkxOCw5NzldfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzkxOCw5NjNdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MTgsOTIzXX0sXCJpZGVudFwiLFtdXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MjQsOTMxXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTI0LDkzMF19LFwiUGFyYW1zXCIsW11dXSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MzIsOTYzXX0sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTM0LDk2Ml19LFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzkzNCw5NDhdfSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MzQsOTQ0XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTM0LDk0M119LFwicnVsZURlc2NyXCIsW11dXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk0NSw5NDhdfSxcIj1cIl1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTUxLDk1NV19LFwiOj1cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5NTgsOTYyXX0sXCIrPVwiXV1dXV0sXCJCYXNlX3JhbmdlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTg2LDEwNDFdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk4NiwxMDIyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTg2LDEwMDFdfSxcIm9uZUNoYXJUZXJtaW5hbFwiLFtdXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwMDIsMTAwNl19LFwiLi5cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTAwNywxMDIyXX0sXCJvbmVDaGFyVGVybWluYWxcIixbXV1dXSxcIkJhc2VfdGVybWluYWxcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDQ4LDExMDZdfSxudWxsLFtdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNDgsMTA1Nl19LFwidGVybWluYWxcIixbXV1dLFwiQmFzZV9wYXJlblwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzExMTMsMTE2OF19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExMywxMTI0XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTEzLDExMTZdfSxcIihcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTExNywxMTIwXX0sXCJBbHRcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTIxLDExMjRdfSxcIilcIl1dXSxcIkJhc2VcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MDcsMTE2OF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbOTE4LDExNjhdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MTgsOTYzXX0sXCJCYXNlX2FwcGxpY2F0aW9uXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6Wzk4NiwxMDIyXX0sXCJCYXNlX3JhbmdlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEwNDgsMTA1Nl19LFwiQmFzZV90ZXJtaW5hbFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTEzLDExMjRdfSxcIkJhc2VfcGFyZW5cIixbXV1dXSxcInJ1bGVEZXNjclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzExNzIsMTIzMV19LFwiYSBydWxlIGRlc2NyaXB0aW9uXCIsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIxMCwxMjMxXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjEwLDEyMTNdfSxcIihcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIxNCwxMjI3XX0sXCJydWxlRGVzY3JUZXh0XCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIyOCwxMjMxXX0sXCIpXCJdXV0sXCJydWxlRGVzY3JUZXh0XCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTIzNSwxMjY2XX0sbnVsbCxbXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI1NSwxMjY2XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI1NiwxMjY0XX0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI1NiwxMjYwXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjU3LDEyNjBdfSxcIilcIl1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyNjEsMTI2NF19LFwiYW55XCIsW11dXV1dLFwiY2FzZU5hbWVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjcwLDEzMzhdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyODUsMTMzOF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI4NSwxMjg5XX0sXCItLVwiXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5MCwxMzA0XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5MSwxMzAyXX0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5MSwxMjk2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjkyLDEyOTZdfSxcIlxcblwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTI5NywxMzAyXX0sXCJzcGFjZVwiLFtdXV1dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMDUsMTMwOV19LFwibmFtZVwiLFtdXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxMCwxMzI0XX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxMSwxMzIyXX0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxMSwxMzE2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzEyLDEzMTZdfSxcIlxcblwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMxNywxMzIyXX0sXCJzcGFjZVwiLFtdXV1dLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzMjYsMTMzN119LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMyNiwxMzMwXX0sXCJcXG5cIl0sW1wibG9va2FoZWFkXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTMzMywxMzM3XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzM0LDEzMzddfSxcIn1cIl1dXV1dLFwibmFtZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNDIsMTM4Ml19LFwiYSBuYW1lXCIsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM2MywxMzgyXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM2MywxMzcyXX0sXCJuYW1lRmlyc3RcIixbXV0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNzMsMTM4Ml19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEzNzMsMTM4MV19LFwibmFtZVJlc3RcIixbXV1dXV0sXCJuYW1lRmlyc3RcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMzg2LDE0MThdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MDIsMTQxOF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQwMiwxNDA1XX0sXCJfXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MTIsMTQxOF19LFwibGV0dGVyXCIsW11dXV0sXCJuYW1lUmVzdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0MjIsMTQ1Ml19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQzNywxNDUyXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDM3LDE0NDBdfSxcIl9cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQ0NywxNDUyXX0sXCJhbG51bVwiLFtdXV1dLFwiaWRlbnRcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDU2LDE0ODldfSxcImFuIGlkZW50aWZpZXJcIixbXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDg1LDE0ODldfSxcIm5hbWVcIixbXV1dLFwidGVybWluYWxcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNDkzLDE1MzFdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1MDgsMTUzMV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTUwOCwxNTEyXX0sXCJcXFwiXCJdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTEzLDE1MjZdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTEzLDE1MjVdfSxcInRlcm1pbmFsQ2hhclwiLFtdXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTI3LDE1MzFdfSxcIlxcXCJcIl1dXSxcIm9uZUNoYXJUZXJtaW5hbFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1MzUsMTU3OV19LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU1NywxNTc5XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTU3LDE1NjFdfSxcIlxcXCJcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTU2MiwxNTc0XX0sXCJ0ZXJtaW5hbENoYXJcIixbXV0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNTc1LDE1NzldfSxcIlxcXCJcIl1dXSxcInRlcm1pbmFsQ2hhclwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE1ODMsMTY0MF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYwMiwxNjQwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYwMiwxNjEyXX0sXCJlc2NhcGVDaGFyXCIsW11dLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MTksMTY0MF19LFtcIm5vdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MTksMTYyNF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYyMCwxNjI0XX0sXCJcXFxcXCJdXSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjI1LDE2MzBdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2MjYsMTYzMF19LFwiXFxcIlwiXV0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYzMSwxNjM2XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjMyLDE2MzZdfSxcIlxcblwiXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTYzNywxNjQwXX0sXCJhbnlcIixbXV1dXV0sXCJlc2NhcGVDaGFyX2JhY2tzbGFzaFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2ODMsMTczOF19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgzLDE2ODldfSxcIlxcXFxcXFxcXCJdXSxcImVzY2FwZUNoYXJfZG91YmxlUXVvdGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNzQ1LDE4MDJdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTc0NSwxNzUxXX0sXCJcXFxcXFxcIlwiXV0sXCJlc2NhcGVDaGFyX3NpbmdsZVF1b3RlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTgwOSwxODY2XX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4MDksMTgxNV19LFwiXFxcXCdcIl1dLFwiZXNjYXBlQ2hhcl9iYWNrc3BhY2VcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODczLDE5MjhdfSxudWxsLFtdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTg3MywxODc4XX0sXCJcXFxcYlwiXV0sXCJlc2NhcGVDaGFyX2xpbmVGZWVkXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTkzNSwxOTg5XX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5MzUsMTk0MF19LFwiXFxcXG5cIl1dLFwiZXNjYXBlQ2hhcl9jYXJyaWFnZVJldHVyblwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5OTYsMjA1Nl19LG51bGwsW10sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTk2LDIwMDFdfSxcIlxcXFxyXCJdXSxcImVzY2FwZUNoYXJfdGFiXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjA2MywyMTEyXX0sbnVsbCxbXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIwNjMsMjA2OF19LFwiXFxcXHRcIl1dLFwiZXNjYXBlQ2hhcl91bmljb2RlRXNjYXBlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjExOSwyMTc4XX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTE5LDIxNjBdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxMTksMjEyNF19LFwiXFxcXHVcIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjEyNSwyMTMzXX0sXCJoZXhEaWdpdFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTM0LDIxNDJdfSxcImhleERpZ2l0XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxNDMsMjE1MV19LFwiaGV4RGlnaXRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE1MiwyMTYwXX0sXCJoZXhEaWdpdFwiLFtdXV1dLFwiZXNjYXBlQ2hhcl9oZXhFc2NhcGVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTg1LDIyNDBdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIxODUsMjIwOF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE4NSwyMTkwXX0sXCJcXFxceFwiXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTkxLDIxOTldfSxcImhleERpZ2l0XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyMDAsMjIwOF19LFwiaGV4RGlnaXRcIixbXV1dXSxcImVzY2FwZUNoYXJcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjQ0LDIyNDBdfSxcImFuIGVzY2FwZSBzZXF1ZW5jZVwiLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2ODMsMjI0MF19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2ODMsMTY4OV19LFwiZXNjYXBlQ2hhcl9iYWNrc2xhc2hcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTc0NSwxNzUxXX0sXCJlc2NhcGVDaGFyX2RvdWJsZVF1b3RlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE4MDksMTgxNV19LFwiZXNjYXBlQ2hhcl9zaW5nbGVRdW90ZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxODczLDE4NzhdfSxcImVzY2FwZUNoYXJfYmFja3NwYWNlXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5MzUsMTk0MF19LFwiZXNjYXBlQ2hhcl9saW5lRmVlZFwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxOTk2LDIwMDFdfSxcImVzY2FwZUNoYXJfY2FycmlhZ2VSZXR1cm5cIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjA2MywyMDY4XX0sXCJlc2NhcGVDaGFyX3RhYlwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTE5LDIxNjBdfSxcImVzY2FwZUNoYXJfdW5pY29kZUVzY2FwZVwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMTg1LDIyMDhdfSxcImVzY2FwZUNoYXJfaGV4RXNjYXBlXCIsW11dXV0sXCJzcGFjZVwiOltcImV4dGVuZFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyNDQsMjI2M119LG51bGwsW10sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI1NiwyMjYzXX0sXCJjb21tZW50XCIsW11dXSxcImNvbW1lbnRfc2luZ2xlTGluZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODEsMjMyN119LG51bGwsW10sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4MSwyMzEyXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjgxLDIyODVdfSxcIi8vXCJdLFtcInN0YXJcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjg2LDIyOThdfSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjg3LDIyOTZdfSxbXCJub3RcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjg3LDIyOTJdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyODgsMjI5Ml19LFwiXFxuXCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMjkzLDIyOTZdfSxcImFueVwiLFtdXV1dLFtcImxvb2thaGVhZFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyOTksMjMxMl19LFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMDEsMjMxMV19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMwMSwyMzA1XX0sXCJcXG5cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMwOCwyMzExXX0sXCJlbmRcIixbXV1dXV1dLFwiY29tbWVudF9tdWx0aUxpbmVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzM0LDIzNzBdfSxudWxsLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIzMzQsMjM1Nl19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMzNCwyMzM4XX0sXCIvKlwiXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMzOSwyMzUxXX0sW1wic2VxXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM0MCwyMzQ5XX0sW1wibm90XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM0MCwyMzQ1XX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzQxLDIzNDVdfSxcIiovXCJdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzQ2LDIzNDldfSxcImFueVwiLFtdXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM1MiwyMzU2XX0sXCIqL1wiXV1dLFwiY29tbWVudFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyNjcsMjM3MF19LG51bGwsW10sW1wiYWx0XCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4MSwyMzcwXX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjI4MSwyMzEyXX0sXCJjb21tZW50X3NpbmdsZUxpbmVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjMzNCwyMzU2XX0sXCJjb21tZW50X211bHRpTGluZVwiLFtdXV1dLFwidG9rZW5zXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM3NCwyMzg5XX0sbnVsbCxbXSxbXCJzdGFyXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM4MywyMzg5XX0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjM4MywyMzg4XX0sXCJ0b2tlblwiLFtdXV1dLFwidG9rZW5cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyMzkzLDI0NjldfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MDEsMjQ2OV19LFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MDEsMjQwOV19LFwiY2FzZU5hbWVcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQxMiwyNDE5XX0sXCJjb21tZW50XCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MjIsMjQyN119LFwiaWRlbnRcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQzMCwyNDM4XX0sXCJvcGVyYXRvclwiLFtdXSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDQxLDI0NTJdfSxcInB1bmN0dWF0aW9uXCIsW11dLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0NTUsMjQ2M119LFwidGVybWluYWxcIixbXV0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ2NiwyNDY5XX0sXCJhbnlcIixbXV1dXSxcIm9wZXJhdG9yXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjQ3MywyNTM4XX0sbnVsbCxbXSxbXCJhbHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDg0LDI1MzhdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0ODQsMjQ4OF19LFwiPDpcIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDkxLDI0OTRdfSxcIj1cIl0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNDk3LDI1MDFdfSxcIjo9XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjUwNCwyNTA4XX0sXCIrPVwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MTEsMjUxNF19LFwiKlwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MTcsMjUyMF19LFwiK1wiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MjMsMjUyNl19LFwiP1wiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MjksMjUzMl19LFwiflwiXSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1MzUsMjUzOF19LFwiJlwiXV1dLFwicHVuY3R1YXRpb25cIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyNTQyLDI1NzhdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI1NTYsMjU3OF19LFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU1NiwyNTU5XX0sXCI8XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU2MiwyNTY1XX0sXCI+XCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU2OCwyNTcxXX0sXCIsXCJdLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjU3NCwyNTc4XX0sXCItLVwiXV1dfV0pO1xuIiwidmFyIG9obSA9IHJlcXVpcmUoJy4uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG9obS5tYWtlUmVjaXBlKFtcImdyYW1tYXJcIix7XCJzb3VyY2VcIjpcIk9wZXJhdGlvbnNBbmRBdHRyaWJ1dGVzIHtcXG5cXG4gIEF0dHJpYnV0ZVNpZ25hdHVyZSA9XFxuICAgIG5hbWVcXG5cXG4gIE9wZXJhdGlvblNpZ25hdHVyZSA9XFxuICAgIG5hbWUgRm9ybWFscz9cXG5cXG4gIEZvcm1hbHNcXG4gICAgPSBcXFwiKFxcXCIgTGlzdE9mPG5hbWUsIFxcXCIsXFxcIj4gXFxcIilcXFwiXFxuXFxuICBuYW1lICAoYSBuYW1lKVxcbiAgICA9IG5hbWVGaXJzdCBuYW1lUmVzdCpcXG5cXG4gIG5hbWVGaXJzdFxcbiAgICA9IFxcXCJfXFxcIlxcbiAgICB8IGxldHRlclxcblxcbiAgbmFtZVJlc3RcXG4gICAgPSBcXFwiX1xcXCJcXG4gICAgfCBhbG51bVxcblxcbn1cIn0sXCJPcGVyYXRpb25zQW5kQXR0cmlidXRlc1wiLG51bGwsXCJBdHRyaWJ1dGVTaWduYXR1cmVcIix7XCJBdHRyaWJ1dGVTaWduYXR1cmVcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsyOSw1OF19LG51bGwsW10sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNTQsNThdfSxcIm5hbWVcIixbXV1dLFwiT3BlcmF0aW9uU2lnbmF0dXJlXCI6W1wiZGVmaW5lXCIse1wic291cmNlSW50ZXJ2YWxcIjpbNjIsMTAwXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4NywxMDBdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls4Nyw5MV19LFwibmFtZVwiLFtdXSxbXCJvcHRcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5MiwxMDBdfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOls5Miw5OV19LFwiRm9ybWFsc1wiLFtdXV1dXSxcIkZvcm1hbHNcIjpbXCJkZWZpbmVcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMDQsMTQzXX0sbnVsbCxbXSxbXCJzZXFcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTgsMTQzXX0sW1widGVybWluYWxcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMTgsMTIxXX0sXCIoXCJdLFtcImFwcFwiLHtcInNvdXJjZUludGVydmFsXCI6WzEyMiwxMzldfSxcIkxpc3RPZlwiLFtbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxMjksMTMzXX0sXCJuYW1lXCIsW11dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTM1LDEzOF19LFwiLFwiXV1dLFtcInRlcm1pbmFsXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMTQwLDE0M119LFwiKVwiXV1dLFwibmFtZVwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE0NywxODddfSxcImEgbmFtZVwiLFtdLFtcInNlcVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE2OCwxODddfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNjgsMTc3XX0sXCJuYW1lRmlyc3RcIixbXV0sW1wic3RhclwiLHtcInNvdXJjZUludGVydmFsXCI6WzE3OCwxODddfSxbXCJhcHBcIix7XCJzb3VyY2VJbnRlcnZhbFwiOlsxNzgsMTg2XX0sXCJuYW1lUmVzdFwiLFtdXV1dXSxcIm5hbWVGaXJzdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzE5MSwyMjNdfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIwNywyMjNdfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzIwNywyMTBdfSxcIl9cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjE3LDIyM119LFwibGV0dGVyXCIsW11dXV0sXCJuYW1lUmVzdFwiOltcImRlZmluZVwiLHtcInNvdXJjZUludGVydmFsXCI6WzIyNywyNTddfSxudWxsLFtdLFtcImFsdFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MiwyNTddfSxbXCJ0ZXJtaW5hbFwiLHtcInNvdXJjZUludGVydmFsXCI6WzI0MiwyNDVdfSxcIl9cIl0sW1wiYXBwXCIse1wic291cmNlSW50ZXJ2YWxcIjpbMjUyLDI1N119LFwiYWxudW1cIixbXV1dXX1dKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJy4uL3NyYy9jb21tb24nKS5hc3NlcnQ7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBIZWxwZXJzXG5cbmZ1bmN0aW9uIGdldFByb3AobmFtZSwgdGhpbmcsIGZuKSB7XG4gIHJldHVybiBmbih0aGluZ1tuYW1lXSk7XG59XG5cbmZ1bmN0aW9uIG1hcFByb3AobmFtZSwgdGhpbmcsIGZuKSB7XG4gIHJldHVybiB0aGluZ1tuYW1lXS5tYXAoZm4pO1xufVxuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHdhbGsgYSBzaW5nbGUgcHJvcGVydHkgb2YgYSBub2RlLlxuLy8gYGRlc2NyaXB0b3JgIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHByb3BlcnR5IG5hbWUsIG9wdGlvbmFsbHkgZW5kaW5nXG4vLyB3aXRoICdbXScgKGUuZy4sICdjaGlsZHJlbltdJykuXG5mdW5jdGlvbiBnZXRQcm9wV2Fsa0ZuKGRlc2NyaXB0b3IpIHtcbiAgY29uc3QgcGFydHMgPSBkZXNjcmlwdG9yLnNwbGl0KC8gP1xcW1xcXS8pO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIG1hcFByb3AuYmluZChudWxsLCBwYXJ0c1swXSk7XG4gIH1cbiAgcmV0dXJuIGdldFByb3AuYmluZChudWxsLCBkZXNjcmlwdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcHMod2Fsa0ZucywgdGhpbmcsIGZuKSB7XG4gIHJldHVybiB3YWxrRm5zLm1hcCh3YWxrRm4gPT4gd2Fsa0ZuKHRoaW5nLCBmbikpO1xufVxuXG5mdW5jdGlvbiBnZXRXYWxrRm4oc2hhcGUpIHtcbiAgaWYgKHR5cGVvZiBzaGFwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0UHJvcHMuYmluZChudWxsLCBbZ2V0UHJvcFdhbGtGbihzaGFwZSldKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNoYXBlKSkge1xuICAgIHJldHVybiBnZXRQcm9wcy5iaW5kKG51bGwsIHNoYXBlLm1hcChnZXRQcm9wV2Fsa0ZuKSk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBzaGFwZSA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIGEgc3RyaW5nLCBBcnJheSwgb3IgZnVuY3Rpb24nKTtcbiAgICBhc3NlcnQoc2hhcGUubGVuZ3RoID09PSAyLCAnRXhwZWN0ZWQgYSBmdW5jdGlvbiBvZiBhcml0eSAyLCBnb3QgJyArIHNoYXBlLmxlbmd0aCk7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUmVzdHJpY3RlZElkZW50aWZpZXIoc3RyKSB7XG4gIHJldHVybiAvXlthLXpBLVpfXVswLTlhLXpBLVpfXSokLy50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIHRyaW0ocykge1xuICByZXR1cm4gcy50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlKHNpZykge1xuICBjb25zdCBwYXJ0cyA9IHNpZy5zcGxpdCgvWygpXS8pLm1hcCh0cmltKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMyAmJiBwYXJ0c1syXSA9PT0gJycpIHtcbiAgICBjb25zdCBuYW1lID0gcGFydHNbMF07XG4gICAgbGV0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChwYXJ0c1sxXS5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJhbXMgPSBwYXJ0c1sxXS5zcGxpdCgnLCcpLm1hcCh0cmltKTtcbiAgICB9XG4gICAgaWYgKGlzUmVzdHJpY3RlZElkZW50aWZpZXIobmFtZSkgJiYgcGFyYW1zLmV2ZXJ5KGlzUmVzdHJpY3RlZElkZW50aWZpZXIpKSB7XG4gICAgICByZXR1cm4ge25hbWUsIGZvcm1hbHM6IHBhcmFtc307XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcGVyYXRpb24gc2lnbmF0dXJlOiAnICsgc2lnKTtcbn1cblxuLypcbiAgQSBWaXNpdG9yRmFtaWx5IGNvbnRhaW5zIGEgc2V0IG9mIHJlY3Vyc2l2ZSBvcGVyYXRpb25zIHRoYXQgYXJlIGRlZmluZWQgb3ZlciBzb21lIGtpbmQgb2ZcbiAgdHJlZSBzdHJ1Y3R1cmUuIFRoZSBgY29uZmlnYCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGhvdyB0byB3YWxrIHRoZSB0cmVlOlxuICAtICdnZXRUYWcnIGlzIGZ1bmN0aW9uIHdoaWNoLCBnaXZlbiBhIG5vZGUgaW4gdGhlIHRyZWUsIHJldHVybnMgdGhlIG5vZGUncyAndGFnJyAodHlwZSlcbiAgLSAnc2hhcGVzJyBhbiBvYmplY3QgdGhhdCBtYXBzIGZyb20gYSB0YWcgdG8gYSB2YWx1ZSB0aGF0IGRlc2NyaWJlcyBob3cgdG8gcmVjdXJzaXZlbHlcbiAgICBldmFsdWF0ZSB0aGUgb3BlcmF0aW9uIGZvciBub2RlcyBvZiB0aGF0IHR5cGUuIFRoZSB2YWx1ZSBjYW4gYmU6XG4gICAgKiBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBwcm9wZXJ0eSBuYW1lIHRoYXQgaG9sZHMgdGhhdCBub2RlJ3Mgb25seSBjaGlsZFxuICAgICogYW4gQXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgKG9yIGFuIGVtcHR5IGFycmF5IGluZGljYXRpbmcgYSBsZWFmIHR5cGUpLCBvclxuICAgICogYSBmdW5jdGlvbiB0YWtpbmcgdHdvIGFyZ3VtZW50cyAobm9kZSwgZm4pLCBhbmQgcmV0dXJuaW5nIGFuIEFycmF5IHdoaWNoIGlzIHRoZSByZXN1bHRcbiAgICAgIG9mIGFwcGx5IGBmbmAgdG8gZWFjaCBvZiB0aGUgbm9kZSdzIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBWaXNpdG9yRmFtaWx5KGNvbmZpZykge1xuICB0aGlzLl9zaGFwZXMgPSBjb25maWcuc2hhcGVzO1xuICB0aGlzLl9nZXRUYWcgPSBjb25maWcuZ2V0VGFnO1xuXG4gIHRoaXMuQWRhcHRlciA9IGZ1bmN0aW9uKHRoaW5nLCBmYW1pbHkpIHtcbiAgICB0aGlzLl9hZGFwdGVlID0gdGhpbmc7XG4gICAgdGhpcy5fZmFtaWx5ID0gZmFtaWx5O1xuICB9O1xuICB0aGlzLkFkYXB0ZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlZWV5IScpO1xuICB9O1xuICB0aGlzLm9wZXJhdGlvbnMgPSB7fTtcblxuICB0aGlzLl9hcml0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fZ2V0Q2hpbGRyZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBPYmplY3Qua2V5cyh0aGlzLl9zaGFwZXMpLmZvckVhY2goayA9PiB7XG4gICAgY29uc3Qgc2hhcGUgPSBzZWxmLl9zaGFwZXNba107XG4gICAgc2VsZi5fZ2V0Q2hpbGRyZW5ba10gPSBnZXRXYWxrRm4oc2hhcGUpO1xuXG4gICAgLy8gQSBmdW5jdGlvbiBtZWFucyB0aGUgYXJpdHkgaXNuJ3QgZml4ZWQsIHNvIGRvbid0IHB1dCBhbiBlbnRyeSBpbiB0aGUgYXJpdHkgbWFwLlxuICAgIGlmICh0eXBlb2Ygc2hhcGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGYuX2FyaXRpZXNba10gPSBBcnJheS5pc0FycmF5KHNoYXBlKSA/IHNoYXBlLmxlbmd0aCA6IDE7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5fd3JhcCA9IGZ1bmN0aW9uKHRoaW5nKSB7IHJldHVybiBuZXcgc2VsZi5BZGFwdGVyKHRoaW5nLCBzZWxmKTsgfTtcbn1cblxuVmlzaXRvckZhbWlseS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHRoaW5nKSB7XG4gIHJldHVybiB0aGlzLl93cmFwKHRoaW5nKTtcbn07XG5cblZpc2l0b3JGYW1pbHkucHJvdG90eXBlLl9jaGVja0FjdGlvbkRpY3QgPSBmdW5jdGlvbihkaWN0KSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBPYmplY3Qua2V5cyhkaWN0KS5mb3JFYWNoKGsgPT4ge1xuICAgIGFzc2VydChrIGluIHNlbGYuX2dldENoaWxkcmVuLCBcIlVucmVjb2duaXplZCBhY3Rpb24gbmFtZSAnXCIgKyBrICsgXCInXCIpO1xuICAgIGNvbnN0IGFjdGlvbiA9IGRpY3Rba107XG4gICAgYXNzZXJ0KHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicsIFwiS2V5ICdcIiArIGsgKyBcIic6IGV4cGVjdGVkIGZ1bmN0aW9uLCBnb3QgXCIgKyBhY3Rpb24pO1xuICAgIGlmIChrIGluIHNlbGYuX2FyaXRpZXMpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkID0gc2VsZi5fYXJpdGllc1trXTtcbiAgICAgIGNvbnN0IGFjdHVhbCA9IGRpY3Rba10ubGVuZ3RoO1xuICAgICAgYXNzZXJ0KGFjdHVhbCA9PT0gZXhwZWN0ZWQsXG4gICAgICAgICAgXCJBY3Rpb24gJ1wiICsgayArIFwiJyBoYXMgdGhlIHdyb25nIGFyaXR5OiBleHBlY3RlZCBcIiArIGV4cGVjdGVkICsgJywgZ290ICcgKyBhY3R1YWwpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5WaXNpdG9yRmFtaWx5LnByb3RvdHlwZS5hZGRPcGVyYXRpb24gPSBmdW5jdGlvbihzaWduYXR1cmUsIGFjdGlvbnMpIHtcbiAgY29uc3Qgc2lnID0gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgY29uc3QgbmFtZSA9IHNpZy5uYW1lO1xuICB0aGlzLl9jaGVja0FjdGlvbkRpY3QoYWN0aW9ucyk7XG4gIHRoaXMub3BlcmF0aW9uc1tuYW1lXSA9IHtcbiAgICBuYW1lLFxuICAgIGZvcm1hbHM6IHNpZy5mb3JtYWxzLFxuICAgIGFjdGlvbnNcbiAgfTtcblxuICBjb25zdCBmYW1pbHkgPSB0aGlzO1xuICB0aGlzLkFkYXB0ZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdGFnID0gZmFtaWx5Ll9nZXRUYWcodGhpcy5fYWRhcHRlZSk7XG4gICAgYXNzZXJ0KHRhZyBpbiBmYW1pbHkuX2dldENoaWxkcmVuLCBcImdldFRhZyByZXR1cm5lZCB1bnJlY29nbml6ZWQgdGFnICdcIiArIHRhZyArIFwiJ1wiKTtcbiAgICBhc3NlcnQodGFnIGluIGFjdGlvbnMsIFwiTm8gYWN0aW9uIGZvciAnXCIgKyB0YWcgKyBcIicgaW4gb3BlcmF0aW9uICdcIiArIG5hbWUgKyBcIidcIik7XG5cbiAgICAvLyBDcmVhdGUgYW4gXCJhcmd1bWVudHMgb2JqZWN0XCIgZnJvbSB0aGUgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhpc1xuICAgIC8vIG9wZXJhdGlvbiAvIGF0dHJpYnV0ZS5cbiAgICBjb25zdCBhcmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tzaWcuZm9ybWFsc1tpXV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkQXJncyA9IHRoaXMuYXJncztcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIGNvbnN0IGFucyA9IGFjdGlvbnNbdGFnXS5hcHBseSh0aGlzLCBmYW1pbHkuX2dldENoaWxkcmVuW3RhZ10odGhpcy5fYWRhcHRlZSwgZmFtaWx5Ll93cmFwKSk7XG4gICAgdGhpcy5hcmdzID0gb2xkQXJncztcbiAgICByZXR1cm4gYW5zO1xuICB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpc2l0b3JGYW1pbHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBWaXNpdG9yRmFtaWx5OiByZXF1aXJlKCcuL1Zpc2l0b3JGYW1pbHknKSxcbiAgc2VtYW50aWNzRm9yVG9BU1Q6IHJlcXVpcmUoJy4vc2VtYW50aWNzLXRvQVNUJykuc2VtYW50aWNzLFxuICB0b0FTVDogcmVxdWlyZSgnLi9zZW1hbnRpY3MtdG9BU1QnKS5oZWxwZXJcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuLi9zcmMvcGV4cHJzJyk7XG5jb25zdCBNYXRjaFJlc3VsdCA9IHJlcXVpcmUoJy4uL3NyYy9NYXRjaFJlc3VsdCcpO1xuY29uc3QgR3JhbW1hciA9IHJlcXVpcmUoJy4uL3NyYy9HcmFtbWFyJyk7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd1dGlsLWV4dGVuZCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZGVmYXVsdE9wZXJhdGlvbiA9IHtcbiAgX3Rlcm1pbmFsKCkge1xuICAgIHJldHVybiB0aGlzLnByaW1pdGl2ZVZhbHVlO1xuICB9LFxuXG4gIF9ub250ZXJtaW5hbChjaGlsZHJlbikge1xuICAgIGNvbnN0IGN0b3JOYW1lID0gdGhpcy5fbm9kZS5jdG9yTmFtZTtcbiAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5hcmdzLm1hcHBpbmc7XG5cbiAgICAvLyB3aXRob3V0IGN1c3RvbWl6YXRpb25cbiAgICBpZiAoIW1hcHBpbmcuaGFzT3duUHJvcGVydHkoY3Rvck5hbWUpKSB7XG4gICAgICAvLyBpbnRlcm1lZGlhdGUgbm9kZVxuICAgICAgaWYgKHRoaXMuX25vZGUgaW5zdGFuY2VvZiBwZXhwcnMuQWx0IHx8IHRoaXMuX25vZGUgaW5zdGFuY2VvZiBwZXhwcnMuQXBwbHkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdLnRvQVNUKG1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICAvLyBsZXhpY2FsIHJ1bGVcbiAgICAgIGlmICh0aGlzLmlzTGV4aWNhbCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZVN0cmluZztcbiAgICAgIH1cblxuICAgICAgLy8gc2luZ3VsYXIgbm9kZSAoZS5nLiBvbmx5IHN1cnJvdW5kZWQgYnkgbGl0ZXJhbHMgb3IgbG9va2FoZWFkcylcbiAgICAgIGNvbnN0IHJlYWxDaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuaXNUZXJtaW5hbCgpKTtcbiAgICAgIGlmIChyZWFsQ2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZWFsQ2hpbGRyZW5bMF0udG9BU1QobWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3Q6IHRlcm1zIHdpdGggbXVsdGlwbGUgY2hpbGRyZW5cbiAgICB9XG5cbiAgICAvLyBkaXJlY3QgZm9yd2FyZFxuICAgIGlmICh0eXBlb2YgbWFwcGluZ1tjdG9yTmFtZV0gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bbWFwcGluZ1tjdG9yTmFtZV1dLnRvQVNUKG1hcHBpbmcpO1xuICAgIH1cblxuICAgIC8vIG5hbWVkL21hcHBlZCBjaGlsZHJlbiBvciB1bm5hbWVkIGNoaWxkcmVuICgnMCcsICcxJywgJzInLCAuLi4pXG4gICAgY29uc3QgcHJvcE1hcCA9IG1hcHBpbmdbY3Rvck5hbWVdIHx8IGNoaWxkcmVuO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBjdG9yTmFtZVxuICAgIH07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BNYXApIHtcbiAgICAgIGNvbnN0IG1hcHBlZFByb3AgPSBtYXBwaW5nW2N0b3JOYW1lXSAmJiBtYXBwaW5nW2N0b3JOYW1lXVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgbWFwcGVkUHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gZGlyZWN0IGZvcndhcmRcbiAgICAgICAgbm9kZVtwcm9wXSA9IGNoaWxkcmVuW21hcHBlZFByb3BdLnRvQVNUKG1hcHBpbmcpO1xuICAgICAgfSBlbHNlIGlmICgodHlwZW9mIG1hcHBlZFByb3AgPT09ICdzdHJpbmcnKSB8fCAodHlwZW9mIG1hcHBlZFByb3AgPT09ICdib29sZWFuJykgfHxcbiAgICAgICAgICAobWFwcGVkUHJvcCA9PT0gbnVsbCkpIHtcbiAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgIG5vZGVbcHJvcF0gPSBtYXBwZWRQcm9wO1xuICAgICAgfSBlbHNlIGlmICgodHlwZW9mIG1hcHBlZFByb3AgPT09ICdvYmplY3QnKSAmJiAobWFwcGVkUHJvcCBpbnN0YW5jZW9mIE51bWJlcikpIHtcbiAgICAgICAgLy8gcHJpbWl0aXZlIG51bWJlciAobXVzdCBiZSB1bmJveGVkKVxuICAgICAgICBub2RlW3Byb3BdID0gTnVtYmVyKG1hcHBlZFByb3ApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWFwcGVkUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBjb21wdXRlZCB2YWx1ZVxuICAgICAgICBub2RlW3Byb3BdID0gbWFwcGVkUHJvcC5jYWxsKHRoaXMsIGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSBpZiAobWFwcGVkUHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltwcm9wXSAmJiAhY2hpbGRyZW5bcHJvcF0uaXNUZXJtaW5hbCgpKSB7XG4gICAgICAgICAgbm9kZVtwcm9wXSA9IGNoaWxkcmVuW3Byb3BdLnRvQVNUKG1hcHBpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlbGV0ZSBwcmVkZWZpbmVkICd0eXBlJyBwcm9wZXJ0aWVzLCBsaWtlICd0eXBlJywgaWYgZXhwbGljaXRlbHkgcmVtb3ZlZFxuICAgICAgICAgIGRlbGV0ZSBub2RlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIF9pdGVyKGNoaWxkcmVuKSB7XG4gICAgaWYgKHRoaXMuX25vZGUuaXNPcHRpb25hbCgpKSB7XG4gICAgICBpZiAodGhpcy5udW1DaGlsZHJlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXS50b0FTVCh0aGlzLmFyZ3MubWFwcGluZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnRvQVNUKHRoaXMuYXJncy5tYXBwaW5nKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBOb25lbXB0eUxpc3RPZihmaXJzdCwgc2VwLCByZXN0KSB7XG4gICAgcmV0dXJuIFtmaXJzdC50b0FTVCh0aGlzLmFyZ3MubWFwcGluZyldLmNvbmNhdChyZXN0LnRvQVNUKHRoaXMuYXJncy5tYXBwaW5nKSk7XG4gIH0sXG5cbiAgRW1wdHlMaXN0T2YoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vLyBSZXR1cm5zIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBpbmNsdWRlcyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSAoQVNUKVxuLy8gZm9yIHRoZSBnaXZlbiBtYXRjaCByZXN1bHQgYHJlc2AgY29udGFpbmcgYSBjb25jcmV0ZSBzeW50YXggdHJlZSAoQ1NUKSBhbmQgZ3JhbW1hci5cbi8vIFRoZSBvcHRpb25hbCBgbWFwcGluZ2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGN1c3RvbWl6ZSBob3cgdGhlIG5vZGVzIG9mIHRoZSBDU1Rcbi8vIGFyZSBtYXBwZWQgdG8gdGhlIEFTVCAoc2VlIC9kb2MvZXh0cmFzLm1kI3RvYXN0bWF0Y2hyZXN1bHQtbWFwcGluZykuXG5mdW5jdGlvbiB0b0FTVChyZXMsIG1hcHBpbmcpIHtcbiAgaWYgKCEocmVzIGluc3RhbmNlb2YgTWF0Y2hSZXN1bHQpIHx8IHJlcy5mYWlsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9BU1QoKSBleHBlY3RzIGEgc3VjY2VzZnVsbCBNYXRjaFJlc3VsdCBhcyBmaXJzdCBwYXJhbWV0ZXInKTtcbiAgfVxuXG4gIG1hcHBpbmcgPSBleHRlbmQoe30sIG1hcHBpbmcpO1xuICBjb25zdCBvcGVyYXRpb24gPSBleHRlbmQoe30sIGRlZmF1bHRPcGVyYXRpb24pO1xuICBmb3IgKGNvbnN0IHRlcm1OYW1lIGluIG1hcHBpbmcpIHtcbiAgICBpZiAodHlwZW9mIG1hcHBpbmdbdGVybU5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcGVyYXRpb25bdGVybU5hbWVdID0gbWFwcGluZ1t0ZXJtTmFtZV07XG4gICAgICBkZWxldGUgbWFwcGluZ1t0ZXJtTmFtZV07XG4gICAgfVxuICB9XG4gIGNvbnN0IGcgPSByZXMuX2NzdC5ncmFtbWFyO1xuICBjb25zdCBzID0gZy5jcmVhdGVTZW1hbnRpY3MoKS5hZGRPcGVyYXRpb24oJ3RvQVNUKG1hcHBpbmcpJywgb3BlcmF0aW9uKTtcbiAgcmV0dXJuIHMocmVzKS50b0FTVChtYXBwaW5nKTtcbn1cblxuLy8gUmV0dXJucyBhIHNlbWFudGljcyBjb250YWluZyB0aGUgdG9BU1QobWFwcGluZykgb3BlcmF0aW9uIGZvciB0aGUgZ2l2ZW4gZ3JhbW1hciBnLlxuZnVuY3Rpb24gc2VtYW50aWNzRm9yVG9BU1QoZykge1xuICBpZiAoIShnIGluc3RhbmNlb2YgR3JhbW1hcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbWFudGljc1RvQVNUKCkgZXhwZWN0cyBhIEdyYW1tYXIgYXMgcGFyYW1ldGVyJyk7XG4gIH1cblxuICByZXR1cm4gZy5jcmVhdGVTZW1hbnRpY3MoKS5hZGRPcGVyYXRpb24oJ3RvQVNUKG1hcHBpbmcpJywgZGVmYXVsdE9wZXJhdGlvbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoZWxwZXI6IHRvQVNULFxuICBzZW1hbnRpY3M6IHNlbWFudGljc0ZvclRvQVNUXG59O1xuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmXG4gICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgR3JhbW1hckRlY2wgPSByZXF1aXJlKCcuL0dyYW1tYXJEZWNsJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gQnVpbGRlcigpIHt9XG5cbkJ1aWxkZXIucHJvdG90eXBlID0ge1xuICBjdXJyZW50RGVjbDogbnVsbCxcbiAgY3VycmVudFJ1bGVOYW1lOiBudWxsLFxuXG4gIG5ld0dyYW1tYXIobmFtZSkge1xuICAgIHJldHVybiBuZXcgR3JhbW1hckRlY2wobmFtZSk7XG4gIH0sXG5cbiAgZ3JhbW1hcihtZXRhSW5mbywgbmFtZSwgc3VwZXJHcmFtbWFyLCBkZWZhdWx0U3RhcnRSdWxlLCBydWxlcykge1xuICAgIGNvbnN0IGdEZWNsID0gbmV3IEdyYW1tYXJEZWNsKG5hbWUpO1xuICAgIGlmIChzdXBlckdyYW1tYXIpIHtcbiAgICAgIGdEZWNsLndpdGhTdXBlckdyYW1tYXIodGhpcy5mcm9tUmVjaXBlKHN1cGVyR3JhbW1hcikpO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFN0YXJ0UnVsZSkge1xuICAgICAgZ0RlY2wud2l0aERlZmF1bHRTdGFydFJ1bGUoZGVmYXVsdFN0YXJ0UnVsZSk7XG4gICAgfVxuICAgIGlmIChtZXRhSW5mbyAmJiBtZXRhSW5mby5zb3VyY2UpIHtcbiAgICAgIGdEZWNsLndpdGhTb3VyY2UobWV0YUluZm8uc291cmNlKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnREZWNsID0gZ0RlY2w7XG4gICAgT2JqZWN0LmtleXMocnVsZXMpLmZvckVhY2gocnVsZU5hbWUgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50UnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgICAgIGNvbnN0IHJ1bGVSZWNpcGUgPSBydWxlc1tydWxlTmFtZV07XG5cbiAgICAgIGNvbnN0IGFjdGlvbiA9IHJ1bGVSZWNpcGVbMF07IC8vIGRlZmluZS9leHRlbmQvb3ZlcnJpZGVcbiAgICAgIGNvbnN0IG1ldGFJbmZvID0gcnVsZVJlY2lwZVsxXTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gcnVsZVJlY2lwZVsyXTtcbiAgICAgIGNvbnN0IGZvcm1hbHMgPSBydWxlUmVjaXBlWzNdO1xuICAgICAgY29uc3QgYm9keSA9IHRoaXMuZnJvbVJlY2lwZShydWxlUmVjaXBlWzRdKTtcblxuICAgICAgbGV0IHNvdXJjZTtcbiAgICAgIGlmIChnRGVjbC5zb3VyY2UgJiYgbWV0YUluZm8gJiYgbWV0YUluZm8uc291cmNlSW50ZXJ2YWwpIHtcbiAgICAgICAgc291cmNlID0gZ0RlY2wuc291cmNlLnN1YkludGVydmFsKFxuICAgICAgICAgICAgbWV0YUluZm8uc291cmNlSW50ZXJ2YWxbMF0sXG4gICAgICAgICAgICBtZXRhSW5mby5zb3VyY2VJbnRlcnZhbFsxXSAtIG1ldGFJbmZvLnNvdXJjZUludGVydmFsWzBdKTtcbiAgICAgIH1cbiAgICAgIGdEZWNsW2FjdGlvbl0ocnVsZU5hbWUsIGZvcm1hbHMsIGJvZHksIGRlc2NyaXB0aW9uLCBzb3VyY2UpO1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudFJ1bGVOYW1lID0gdGhpcy5jdXJyZW50RGVjbCA9IG51bGw7XG4gICAgcmV0dXJuIGdEZWNsLmJ1aWxkKCk7XG4gIH0sXG5cbiAgdGVybWluYWwoeCkge1xuICAgIHJldHVybiBuZXcgcGV4cHJzLlRlcm1pbmFsKHgpO1xuICB9LFxuXG4gIHJhbmdlKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuUmFuZ2UoZnJvbSwgdG8pO1xuICB9LFxuXG4gIHBhcmFtKGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuUGFyYW0oaW5kZXgpO1xuICB9LFxuXG4gIGFsdCgvKiB0ZXJtMSwgdGVybTIsIC4uLiAqLykge1xuICAgIGxldCB0ZXJtcyA9IFtdO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFyZ3VtZW50cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBsZXQgYXJnID0gYXJndW1lbnRzW2lkeF07XG4gICAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICAgIGFyZyA9IHRoaXMuZnJvbVJlY2lwZShhcmcpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIHBleHBycy5BbHQpIHtcbiAgICAgICAgdGVybXMgPSB0ZXJtcy5jb25jYXQoYXJnLnRlcm1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlcm1zLnB1c2goYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlcm1zLmxlbmd0aCA9PT0gMSA/IHRlcm1zWzBdIDogbmV3IHBleHBycy5BbHQodGVybXMpO1xuICB9LFxuXG4gIHNlcSgvKiBmYWN0b3IxLCBmYWN0b3IyLCAuLi4gKi8pIHtcbiAgICBsZXQgZmFjdG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFyZ3VtZW50cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBsZXQgYXJnID0gYXJndW1lbnRzW2lkeF07XG4gICAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICAgIGFyZyA9IHRoaXMuZnJvbVJlY2lwZShhcmcpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIHBleHBycy5TZXEpIHtcbiAgICAgICAgZmFjdG9ycyA9IGZhY3RvcnMuY29uY2F0KGFyZy5mYWN0b3JzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnMucHVzaChhcmcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFjdG9ycy5sZW5ndGggPT09IDEgPyBmYWN0b3JzWzBdIDogbmV3IHBleHBycy5TZXEoZmFjdG9ycyk7XG4gIH0sXG5cbiAgc3RhcihleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLlN0YXIoZXhwcik7XG4gIH0sXG5cbiAgcGx1cyhleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLlBsdXMoZXhwcik7XG4gIH0sXG5cbiAgb3B0KGV4cHIpIHtcbiAgICBpZiAoIShleHByIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgZXhwciA9IHRoaXMuZnJvbVJlY2lwZShleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuT3B0KGV4cHIpO1xuICB9LFxuXG4gIG5vdChleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIHBleHBycy5QRXhwcikpIHtcbiAgICAgIGV4cHIgPSB0aGlzLmZyb21SZWNpcGUoZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcGV4cHJzLk5vdChleHByKTtcbiAgfSxcblxuICBsYShleHByKSB7XG4gICAgLy8gVE9ETzogdGVtcG9yYXJ5IHRvIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBvbGQgcmVjaXBlc1xuICAgIHJldHVybiB0aGlzLmxvb2thaGVhZChleHByKTtcbiAgfSxcblxuICBsb29rYWhlYWQoZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIpKSB7XG4gICAgICBleHByID0gdGhpcy5mcm9tUmVjaXBlKGV4cHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5Mb29rYWhlYWQoZXhwcik7XG4gIH0sXG5cbiAgbGV4KGV4cHIpIHtcbiAgICBpZiAoIShleHByIGluc3RhbmNlb2YgcGV4cHJzLlBFeHByKSkge1xuICAgICAgZXhwciA9IHRoaXMuZnJvbVJlY2lwZShleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuTGV4KGV4cHIpO1xuICB9LFxuXG4gIGFwcChydWxlTmFtZSwgb3B0UGFyYW1zKSB7XG4gICAgaWYgKG9wdFBhcmFtcyAmJiBvcHRQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgb3B0UGFyYW1zID0gb3B0UGFyYW1zLm1hcChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gaW5zdGFuY2VvZiBwZXhwcnMuUEV4cHIgPyBwYXJhbSA6XG4gICAgICAgICAgdGhpcy5mcm9tUmVjaXBlKHBhcmFtKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5BcHBseShydWxlTmFtZSwgb3B0UGFyYW1zKTtcbiAgfSxcblxuICAvLyBOb3RlIHRoYXQgdW5saWtlIG90aGVyIG1ldGhvZHMgaW4gdGhpcyBjbGFzcywgdGhpcyBtZXRob2QgY2Fubm90IGJlIHVzZWQgYXMgYVxuICAvLyBjb252ZW5pZW5jZSBjb25zdHJ1Y3Rvci4gSXQgb25seSB3b3JrcyB3aXRoIHJlY2lwZXMsIGJlY2F1c2UgaXQgcmVsaWVzIG9uXG4gIC8vIGB0aGlzLmN1cnJlbnREZWNsYCBhbmQgYHRoaXMuY3VycmVudFJ1bGVOYW1lYCBiZWluZyBzZXQuXG4gIHNwbGljZShiZWZvcmVUZXJtcywgYWZ0ZXJUZXJtcykge1xuICAgIHJldHVybiBuZXcgcGV4cHJzLlNwbGljZShcbiAgICAgICAgdGhpcy5jdXJyZW50RGVjbC5zdXBlckdyYW1tYXIsXG4gICAgICAgIHRoaXMuY3VycmVudFJ1bGVOYW1lLFxuICAgICAgICBiZWZvcmVUZXJtcy5tYXAodGVybSA9PiB0aGlzLmZyb21SZWNpcGUodGVybSkpLFxuICAgICAgICBhZnRlclRlcm1zLm1hcCh0ZXJtID0+IHRoaXMuZnJvbVJlY2lwZSh0ZXJtKSkpO1xuICB9LFxuXG4gIGZyb21SZWNpcGUocmVjaXBlKSB7XG4gICAgLy8gdGhlIG1ldGEtaW5mbyBvZiAnZ3JhbW1hcicgaXMgcHJvY2Vzc2VkIGluIEJ1aWxkZXIuZ3JhbW1hclxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNbcmVjaXBlWzBdXS5hcHBseSh0aGlzLFxuICAgICAgcmVjaXBlWzBdID09PSAnZ3JhbW1hcicgPyByZWNpcGUuc2xpY2UoMSkgOiByZWNpcGUuc2xpY2UoMikpO1xuXG4gICAgY29uc3QgbWV0YUluZm8gPSByZWNpcGVbMV07XG4gICAgaWYgKG1ldGFJbmZvKSB7XG4gICAgICBpZiAobWV0YUluZm8uc291cmNlSW50ZXJ2YWwgJiYgdGhpcy5jdXJyZW50RGVjbCkge1xuICAgICAgICByZXN1bHQud2l0aFNvdXJjZShcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERlY2wuc291cmNlSW50ZXJ2YWwuYXBwbHkodGhpcy5jdXJyZW50RGVjbCwgbWV0YUluZm8uc291cmNlSW50ZXJ2YWwpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBGYWlsdXJlID0gcmVxdWlyZSgnLi9GYWlsdXJlJyk7XG5jb25zdCBUZXJtaW5hbE5vZGUgPSByZXF1aXJlKCcuL25vZGVzJykuVGVybWluYWxOb2RlO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jb21tb24nKS5hc3NlcnQ7XG5jb25zdCB7UEV4cHIsIFRlcm1pbmFsfSA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbmNsYXNzIENhc2VJbnNlbnNpdGl2ZVRlcm1pbmFsIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihwYXJhbSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYmogPSBwYXJhbTtcbiAgfVxuXG4gIF9nZXRTdHJpbmcoc3RhdGUpIHtcbiAgICBjb25zdCB0ZXJtaW5hbCA9IHN0YXRlLmN1cnJlbnRBcHBsaWNhdGlvbigpLmFyZ3NbdGhpcy5vYmouaW5kZXhdO1xuICAgIGFzc2VydCh0ZXJtaW5hbCBpbnN0YW5jZW9mIFRlcm1pbmFsLCAnZXhwZWN0ZWQgYSBUZXJtaW5hbCBleHByZXNzaW9uJyk7XG4gICAgcmV0dXJuIHRlcm1pbmFsLm9iajtcbiAgfVxuXG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIHRoZSBQRXhwciBBUElcblxuICBhbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZXZhbChzdGF0ZSkge1xuICAgIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gICAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgICBjb25zdCBtYXRjaFN0ciA9IHRoaXMuX2dldFN0cmluZyhzdGF0ZSk7XG4gICAgaWYgKCFpbnB1dFN0cmVhbS5tYXRjaFN0cmluZyhtYXRjaFN0ciwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoQmluZGluZyhuZXcgVGVybWluYWxOb2RlKHN0YXRlLmdyYW1tYXIsIG1hdGNoU3RyKSwgb3JpZ1Bvcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBnZW5lcmF0ZUV4YW1wbGUoZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICAgIC8vIFN0YXJ0IHdpdGggYSBleGFtcGxlIGdlbmVyYXRlZCBmcm9tIHRoZSBUZXJtaW5hbC4uLlxuICAgIGNvbnN0IHN0ciA9IHRoaXMub2JqLmdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKS52YWx1ZTtcblxuICAgIC8vIC4uLmFuZCByYW5kb21seSBzd2l0Y2ggY2hhcmFjdGVycyB0byB1cHBlcmNhc2UvbG93ZXJjYXNlLlxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YWx1ZSArPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gc3RyW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkgOiBzdHJbaV0udG9Mb2NhbGVVcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHt2YWx1ZX07XG4gIH1cblxuICBnZXRBcml0eSgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykge1xuICAgIHJldHVybiBuZXcgQ2FzZUluc2Vuc2l0aXZlVGVybWluYWwodGhpcy5vYmouc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSk7XG4gIH1cblxuICB0b0Rpc3BsYXlTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqLnRvRGlzcGxheVN0cmluZygpICsgJyAoY2FzZS1pbnNlbnNpdGl2ZSknO1xuICB9XG5cbiAgdG9GYWlsdXJlKGdyYW1tYXIpIHtcbiAgICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgdGhpcy5vYmoudG9GYWlsdXJlKGdyYW1tYXIpICsgJyAoY2FzZS1pbnNlbnNpdGl2ZSknLCAnZGVzY3JpcHRpb24nKTtcbiAgfVxuXG4gIF9pc051bGxhYmxlKGdyYW1tYXIsIG1lbW8pIHtcbiAgICByZXR1cm4gdGhpcy5vYmouX2lzTnVsbGFibGUoZ3JhbW1hciwgbWVtbyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYXNlSW5zZW5zaXRpdmVUZXJtaW5hbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gIGBGYWlsdXJlYHMgcmVwcmVzZW50IGV4cHJlc3Npb25zIHRoYXQgd2VyZW4ndCBtYXRjaGVkIHdoaWxlIHBhcnNpbmcuIFRoZXkgYXJlIHVzZWQgdG8gZ2VuZXJhdGVcbiAgZXJyb3IgbWVzc2FnZXMgYXV0b21hdGljYWxseS4gVGhlIGludGVyZmFjZSBvZiBgRmFpbHVyZWBzIGluY2x1ZGVzIHRoZSBjb2xsb3dpbmcgbWV0aG9kczpcblxuICAtIGdldFRleHQoKSA6IFN0cmluZ1xuICAtIGdldFR5cGUoKSA6IFN0cmluZyAgKG9uZSBvZiB7XCJkZXNjcmlwdGlvblwiLCBcInN0cmluZ1wiLCBcImNvZGVcIn0pXG4gIC0gaXNEZXNjcmlwdGlvbigpIDogYm9vbFxuICAtIGlzU3RyaW5nVGVybWluYWwoKSA6IGJvb2xcbiAgLSBpc0NvZGUoKSA6IGJvb2xcbiAgLSBpc0ZsdWZmeSgpIDogYm9vbFxuICAtIG1ha2VGbHVmZnkoKSA6IHZvaWRcbiAgLSBzdWJzdW1lcyhGYWlsdXJlKSA6IGJvb2xcbiovXG5cbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgPT09ICdkZXNjcmlwdGlvbicgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ2NvZGUnO1xufVxuXG5mdW5jdGlvbiBGYWlsdXJlKHBleHByLCB0ZXh0LCB0eXBlKSB7XG4gIGlmICghaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgRmFpbHVyZSB0eXBlOiAnICsgdHlwZSk7XG4gIH1cbiAgdGhpcy5wZXhwciA9IHBleHByO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmZsdWZmeSA9IGZhbHNlO1xufVxuXG5GYWlsdXJlLnByb3RvdHlwZS5nZXRQRXhwciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wZXhwcjtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGV4dDtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmlzRGVzY3JpcHRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2Rlc2NyaXB0aW9uJztcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLmlzU3RyaW5nVGVybWluYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3N0cmluZyc7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5pc0NvZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2NvZGUnO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuaXNGbHVmZnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmx1ZmZ5O1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUubWFrZUZsdWZmeSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZsdWZmeSA9IHRydWU7XG59O1xuXG5GYWlsdXJlLnByb3RvdHlwZS5jbGVhckZsdWZmeSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZsdWZmeSA9IGZhbHNlO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuc3Vic3VtZXMgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiB0aGlzLmdldFRleHQoKSA9PT0gdGhhdC5nZXRUZXh0KCkgJiZcbiAgICAgIHRoaXMudHlwZSA9PT0gdGhhdC50eXBlICYmXG4gICAgICAoIXRoaXMuaXNGbHVmZnkoKSB8fCB0aGlzLmlzRmx1ZmZ5KCkgJiYgdGhhdC5pc0ZsdWZmeSgpKTtcbn07XG5cbkZhaWx1cmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09ICdzdHJpbmcnID9cbiAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmdldFRleHQoKSkgOlxuICAgIHRoaXMuZ2V0VGV4dCgpO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZmFpbHVyZSA9IG5ldyBGYWlsdXJlKHRoaXMucGV4cHIsIHRoaXMudGV4dCwgdGhpcy50eXBlKTtcbiAgaWYgKHRoaXMuaXNGbHVmZnkoKSkge1xuICAgIGZhaWx1cmUubWFrZUZsdWZmeSgpO1xuICB9XG4gIHJldHVybiBmYWlsdXJlO1xufTtcblxuRmFpbHVyZS5wcm90b3R5cGUudG9LZXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKSArICcjJyArIHRoaXMudHlwZTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZhaWx1cmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBDYXNlSW5zZW5zaXRpdmVUZXJtaW5hbCA9IHJlcXVpcmUoJy4vQ2FzZUluc2Vuc2l0aXZlVGVybWluYWwnKTtcbmNvbnN0IE1hdGNoZXIgPSByZXF1aXJlKCcuL01hdGNoZXInKTtcbmNvbnN0IFNlbWFudGljcyA9IHJlcXVpcmUoJy4vU2VtYW50aWNzJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWRSdWxlVmFsdWVzKGdyYW1tYXIpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGdyYW1tYXIucnVsZXMpLnNvcnQoKS5tYXAobmFtZSA9PiBncmFtbWFyLnJ1bGVzW25hbWVdKTtcbn1cblxuZnVuY3Rpb24gR3JhbW1hcihcbiAgICBuYW1lLFxuICAgIHN1cGVyR3JhbW1hcixcbiAgICBydWxlcyxcbiAgICBvcHREZWZhdWx0U3RhcnRSdWxlKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuc3VwZXJHcmFtbWFyID0gc3VwZXJHcmFtbWFyO1xuICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gIGlmIChvcHREZWZhdWx0U3RhcnRSdWxlKSB7XG4gICAgaWYgKCEob3B0RGVmYXVsdFN0YXJ0UnVsZSBpbiBydWxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhcnQgcnVsZTogJ1wiICsgb3B0RGVmYXVsdFN0YXJ0UnVsZSArXG4gICAgICAgICAgICAgICAgICAgICAgXCInIGlzIG5vdCBhIHJ1bGUgaW4gZ3JhbW1hciAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRTdGFydFJ1bGUgPSBvcHREZWZhdWx0U3RhcnRSdWxlO1xuICB9XG59XG5cbmxldCBvaG1HcmFtbWFyO1xubGV0IGJ1aWxkR3JhbW1hcjtcblxuLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGZyb20gbWFpbi5qcyBvbmNlIE9obSBoYXMgbG9hZGVkLlxuR3JhbW1hci5pbml0QXBwbGljYXRpb25QYXJzZXIgPSBmdW5jdGlvbihncmFtbWFyLCBidWlsZGVyRm4pIHtcbiAgb2htR3JhbW1hciA9IGdyYW1tYXI7XG4gIGJ1aWxkR3JhbW1hciA9IGJ1aWxkZXJGbjtcbn07XG5cbkdyYW1tYXIucHJvdG90eXBlID0ge1xuICBtYXRjaGVyKCkge1xuICAgIHJldHVybiBuZXcgTWF0Y2hlcih0aGlzKTtcbiAgfSxcblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ3JhbW1hciBpcyBhIGJ1aWx0LWluIGdyYW1tYXIsIG90aGVyd2lzZSBmYWxzZS5cbiAgLy8gTk9URTogVGhpcyBtaWdodCBnaXZlIGFuIHVuZXhwZWN0ZWQgcmVzdWx0IGlmIGNhbGxlZCBiZWZvcmUgQnVpbHRJblJ1bGVzIGlzIGRlZmluZWQhXG4gIGlzQnVpbHRJbigpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gR3JhbW1hci5Qcm90b0J1aWx0SW5SdWxlcyB8fCB0aGlzID09PSBHcmFtbWFyLkJ1aWx0SW5SdWxlcztcbiAgfSxcblxuICBlcXVhbHMoZykge1xuICAgIGlmICh0aGlzID09PSBnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRG8gdGhlIGNoZWFwZXN0IGNvbXBhcmlzb25zIGZpcnN0LlxuICAgIGlmIChnID09IG51bGwgfHxcbiAgICAgICAgdGhpcy5uYW1lICE9PSBnLm5hbWUgfHxcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhcnRSdWxlICE9PSBnLmRlZmF1bHRTdGFydFJ1bGUgfHxcbiAgICAgICAgISh0aGlzLnN1cGVyR3JhbW1hciA9PT0gZy5zdXBlckdyYW1tYXIgfHwgdGhpcy5zdXBlckdyYW1tYXIuZXF1YWxzKGcuc3VwZXJHcmFtbWFyKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbXlSdWxlcyA9IGdldFNvcnRlZFJ1bGVWYWx1ZXModGhpcyk7XG4gICAgY29uc3Qgb3RoZXJSdWxlcyA9IGdldFNvcnRlZFJ1bGVWYWx1ZXMoZyk7XG4gICAgcmV0dXJuIG15UnVsZXMubGVuZ3RoID09PSBvdGhlclJ1bGVzLmxlbmd0aCAmJiBteVJ1bGVzLmV2ZXJ5KChydWxlLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcnVsZS5kZXNjcmlwdGlvbiA9PT0gb3RoZXJSdWxlc1tpXS5kZXNjcmlwdGlvbiAmJlxuICAgICAgICAgICAgIHJ1bGUuZm9ybWFscy5qb2luKCcsJykgPT09IG90aGVyUnVsZXNbaV0uZm9ybWFscy5qb2luKCcsJykgJiZcbiAgICAgICAgICAgICBydWxlLmJvZHkudG9TdHJpbmcoKSA9PT0gb3RoZXJSdWxlc1tpXS5ib2R5LnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgbWF0Y2goaW5wdXQsIG9wdFN0YXJ0QXBwbGljYXRpb24pIHtcbiAgICBjb25zdCBtID0gdGhpcy5tYXRjaGVyKCk7XG4gICAgbS5yZXBsYWNlSW5wdXRSYW5nZSgwLCAwLCBpbnB1dCk7XG4gICAgcmV0dXJuIG0ubWF0Y2gob3B0U3RhcnRBcHBsaWNhdGlvbik7XG4gIH0sXG5cbiAgdHJhY2UoaW5wdXQsIG9wdFN0YXJ0QXBwbGljYXRpb24pIHtcbiAgICBjb25zdCBtID0gdGhpcy5tYXRjaGVyKCk7XG4gICAgbS5yZXBsYWNlSW5wdXRSYW5nZSgwLCAwLCBpbnB1dCk7XG4gICAgcmV0dXJuIG0udHJhY2Uob3B0U3RhcnRBcHBsaWNhdGlvbik7XG4gIH0sXG5cbiAgc2VtYW50aWNzKCkge1xuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkhIERlcHJlY2F0ZWQgaW4gdjAuMTIuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZW1hbnRpY3MoKSBpcyBkZXByZWNhdGVkIC0tIHVzZSBjcmVhdGVTZW1hbnRpY3MoKSBpbnN0ZWFkLicpO1xuICB9LFxuXG4gIGNyZWF0ZVNlbWFudGljcygpIHtcbiAgICByZXR1cm4gU2VtYW50aWNzLmNyZWF0ZVNlbWFudGljcyh0aGlzKTtcbiAgfSxcblxuICBleHRlbmRTZW1hbnRpY3Moc3VwZXJTZW1hbnRpY3MpIHtcbiAgICByZXR1cm4gU2VtYW50aWNzLmNyZWF0ZVNlbWFudGljcyh0aGlzLCBzdXBlclNlbWFudGljcy5fZ2V0U2VtYW50aWNzKCkpO1xuICB9LFxuXG4gIC8vIENoZWNrIHRoYXQgZXZlcnkga2V5IGluIGBhY3Rpb25EaWN0YCBjb3JyZXNwb25kcyB0byBhIHNlbWFudGljIGFjdGlvbiwgYW5kIHRoYXQgaXQgbWFwcyB0b1xuICAvLyBhIGZ1bmN0aW9uIG9mIHRoZSBjb3JyZWN0IGFyaXR5LiBJZiBub3QsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgX2NoZWNrVG9wRG93bkFjdGlvbkRpY3Qod2hhdCwgbmFtZSwgYWN0aW9uRGljdCkge1xuICAgIGZ1bmN0aW9uIGlzU3BlY2lhbEFjdGlvbihhKSB7XG4gICAgICByZXR1cm4gYSA9PT0gJ19pdGVyJyB8fCBhID09PSAnX3Rlcm1pbmFsJyB8fCBhID09PSAnX25vbnRlcm1pbmFsJyB8fCBhID09PSAnX2RlZmF1bHQnO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2JsZW1zID0gW107XG4gICAgZm9yIChjb25zdCBrIGluIGFjdGlvbkRpY3QpIHtcbiAgICAgIGNvbnN0IHYgPSBhY3Rpb25EaWN0W2tdO1xuICAgICAgaWYgKCFpc1NwZWNpYWxBY3Rpb24oaykgJiYgIShrIGluIHRoaXMucnVsZXMpKSB7XG4gICAgICAgIHByb2JsZW1zLnB1c2goXCInXCIgKyBrICsgXCInIGlzIG5vdCBhIHZhbGlkIHNlbWFudGljIGFjdGlvbiBmb3IgJ1wiICsgdGhpcy5uYW1lICsgXCInXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9ibGVtcy5wdXNoKFxuICAgICAgICAgICAgXCInXCIgKyBrICsgXCInIG11c3QgYmUgYSBmdW5jdGlvbiBpbiBhbiBhY3Rpb24gZGljdGlvbmFyeSBmb3IgJ1wiICsgdGhpcy5uYW1lICsgXCInXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWN0dWFsID0gdi5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gdGhpcy5fdG9wRG93bkFjdGlvbkFyaXR5KGspO1xuICAgICAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgIHByb2JsZW1zLnB1c2goXG4gICAgICAgICAgICAgIFwiU2VtYW50aWMgYWN0aW9uICdcIiArIGsgKyBcIicgaGFzIHRoZSB3cm9uZyBhcml0eTogXCIgK1xuICAgICAgICAgICAgICAnZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJywgZ290ICcgKyBhY3R1YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9ibGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwcmV0dHlQcm9ibGVtcyA9IHByb2JsZW1zLm1hcChwcm9ibGVtID0+ICctICcgKyBwcm9ibGVtKTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgIFwiRm91bmQgZXJyb3JzIGluIHRoZSBhY3Rpb24gZGljdGlvbmFyeSBvZiB0aGUgJ1wiICsgbmFtZSArIFwiJyBcIiArIHdoYXQgKyAnOlxcbicgK1xuICAgICAgICAgIHByZXR0eVByb2JsZW1zLmpvaW4oJ1xcbicpKTtcbiAgICAgIGVycm9yLnByb2JsZW1zID0gcHJvYmxlbXM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmV0dXJuIHRoZSBleHBlY3RlZCBhcml0eSBmb3IgYSBzZW1hbnRpYyBhY3Rpb24gbmFtZWQgYGFjdGlvbk5hbWVgLCB3aGljaFxuICAvLyBpcyBlaXRoZXIgYSBydWxlIG5hbWUgb3IgYSBzcGVjaWFsIGFjdGlvbiBuYW1lIGxpa2UgJ19ub250ZXJtaW5hbCcuXG4gIF90b3BEb3duQWN0aW9uQXJpdHkoYWN0aW9uTmFtZSkge1xuICAgIGlmIChhY3Rpb25OYW1lID09PSAnX2l0ZXInIHx8IGFjdGlvbk5hbWUgPT09ICdfbm9udGVybWluYWwnIHx8IGFjdGlvbk5hbWUgPT09ICdfZGVmYXVsdCcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYWN0aW9uTmFtZSA9PT0gJ190ZXJtaW5hbCcpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ydWxlc1thY3Rpb25OYW1lXS5ib2R5LmdldEFyaXR5KCk7XG4gIH0sXG5cbiAgX2luaGVyaXRzRnJvbShncmFtbWFyKSB7XG4gICAgbGV0IGcgPSB0aGlzLnN1cGVyR3JhbW1hcjtcbiAgICB3aGlsZSAoZykge1xuICAgICAgaWYgKGcuZXF1YWxzKGdyYW1tYXIsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZyA9IGcuc3VwZXJHcmFtbWFyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgdG9SZWNpcGUob3B0VmFyTmFtZSkge1xuICAgIGNvbnN0IG1ldGFJbmZvID0ge307XG4gICAgLy8gSW5jbHVkZSB0aGUgZ3JhbW1hciBzb3VyY2UgaWYgaXQgaXMgYXZhaWxhYmxlLlxuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgbWV0YUluZm8uc291cmNlID0gdGhpcy5zb3VyY2UuY29udGVudHM7XG4gICAgfVxuXG4gICAgbGV0IHN1cGVyR3JhbW1hciA9IG51bGw7XG4gICAgaWYgKHRoaXMuc3VwZXJHcmFtbWFyICYmICF0aGlzLnN1cGVyR3JhbW1hci5pc0J1aWx0SW4oKSkge1xuICAgICAgc3VwZXJHcmFtbWFyID0gSlNPTi5wYXJzZSh0aGlzLnN1cGVyR3JhbW1hci50b1JlY2lwZSgpKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnRSdWxlID0gbnVsbDtcbiAgICBpZiAodGhpcy5kZWZhdWx0U3RhcnRSdWxlKSB7XG4gICAgICBzdGFydFJ1bGUgPSB0aGlzLmRlZmF1bHRTdGFydFJ1bGU7XG4gICAgfVxuXG4gICAgY29uc3QgcnVsZXMgPSB7fTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLnJ1bGVzKS5mb3JFYWNoKHJ1bGVOYW1lID0+IHtcbiAgICAgIGNvbnN0IHJ1bGVJbmZvID0gc2VsZi5ydWxlc1tydWxlTmFtZV07XG4gICAgICBjb25zdCBib2R5ID0gcnVsZUluZm8uYm9keTtcbiAgICAgIGNvbnN0IGlzRGVmaW5pdGlvbiA9ICFzZWxmLnN1cGVyR3JhbW1hciB8fCAhc2VsZi5zdXBlckdyYW1tYXIucnVsZXNbcnVsZU5hbWVdO1xuXG4gICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgaWYgKGlzRGVmaW5pdGlvbikge1xuICAgICAgICBvcGVyYXRpb24gPSAnZGVmaW5lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZXJhdGlvbiA9IGJvZHkgaW5zdGFuY2VvZiBwZXhwcnMuRXh0ZW5kID8gJ2V4dGVuZCcgOiAnb3ZlcnJpZGUnO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtZXRhSW5mbyA9IHt9O1xuICAgICAgaWYgKHJ1bGVJbmZvLnNvdXJjZSAmJiBzZWxmLnNvdXJjZSkge1xuICAgICAgICBjb25zdCBhZGp1c3RlZCA9IHJ1bGVJbmZvLnNvdXJjZS5yZWxhdGl2ZVRvKHNlbGYuc291cmNlKTtcbiAgICAgICAgbWV0YUluZm8uc291cmNlSW50ZXJ2YWwgPSBbYWRqdXN0ZWQuc3RhcnRJZHgsIGFkanVzdGVkLmVuZElkeF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gaXNEZWZpbml0aW9uID8gcnVsZUluZm8uZGVzY3JpcHRpb24gOiBudWxsO1xuICAgICAgY29uc3QgYm9keVJlY2lwZSA9IGJvZHkub3V0cHV0UmVjaXBlKHJ1bGVJbmZvLmZvcm1hbHMsIHNlbGYuc291cmNlKTtcblxuICAgICAgcnVsZXNbcnVsZU5hbWVdID0gW1xuICAgICAgICBvcGVyYXRpb24sIC8vIFwiZGVmaW5lXCIvXCJleHRlbmRcIi9cIm92ZXJyaWRlXCJcbiAgICAgICAgbWV0YUluZm8sXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBydWxlSW5mby5mb3JtYWxzLFxuICAgICAgICBib2R5UmVjaXBlXG4gICAgICBdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICdncmFtbWFyJyxcbiAgICAgIG1ldGFJbmZvLFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgc3VwZXJHcmFtbWFyLFxuICAgICAgc3RhcnRSdWxlLFxuICAgICAgcnVsZXNcbiAgICBdKTtcbiAgfSxcblxuICAvLyBUT0RPOiBDb21lIHVwIHdpdGggYmV0dGVyIG5hbWVzIGZvciB0aGVzZSBtZXRob2RzLlxuICAvLyBUT0RPOiBXcml0ZSB0aGUgYW5hbG9nIG9mIHRoZXNlIG1ldGhvZHMgZm9yIGluaGVyaXRlZCBhdHRyaWJ1dGVzLlxuICB0b09wZXJhdGlvbkFjdGlvbkRpY3Rpb25hcnlUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9PcGVyYXRpb25PckF0dHJpYnV0ZUFjdGlvbkRpY3Rpb25hcnlUZW1wbGF0ZSgpO1xuICB9LFxuICB0b0F0dHJpYnV0ZUFjdGlvbkRpY3Rpb25hcnlUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9PcGVyYXRpb25PckF0dHJpYnV0ZUFjdGlvbkRpY3Rpb25hcnlUZW1wbGF0ZSgpO1xuICB9LFxuXG4gIF90b09wZXJhdGlvbk9yQXR0cmlidXRlQWN0aW9uRGljdGlvbmFyeVRlbXBsYXRlKCkge1xuICAgIC8vIFRPRE86IGFkZCB0aGUgc3VwZXItZ3JhbW1hcidzIHRlbXBsYXRlcyBhdCB0aGUgcmlnaHQgcGxhY2UsIGUuZy4sIGEgY2FzZSBmb3IgQWRkRXhwcl9wbHVzXG4gICAgLy8gc2hvdWxkIGFwcGVhciBuZXh0IHRvIG90aGVyIGNhc2VzIG9mIEFkZEV4cHIuXG5cbiAgICBjb25zdCBzYiA9IG5ldyBjb21tb24uU3RyaW5nQnVmZmVyKCk7XG4gICAgc2IuYXBwZW5kKCd7Jyk7XG5cbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcnVsZU5hbWUgaW4gdGhpcy5ydWxlcykge1xuICAgICAgY29uc3QgYm9keSA9IHRoaXMucnVsZXNbcnVsZU5hbWVdLmJvZHk7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNiLmFwcGVuZCgnLCcpO1xuICAgICAgfVxuICAgICAgc2IuYXBwZW5kKCdcXG4nKTtcbiAgICAgIHNiLmFwcGVuZCgnICAnKTtcbiAgICAgIHRoaXMuYWRkU2VtYW50aWNBY3Rpb25UZW1wbGF0ZShydWxlTmFtZSwgYm9keSwgc2IpO1xuICAgIH1cblxuICAgIHNiLmFwcGVuZCgnXFxufScpO1xuICAgIHJldHVybiBzYi5jb250ZW50cygpO1xuICB9LFxuXG4gIGFkZFNlbWFudGljQWN0aW9uVGVtcGxhdGUocnVsZU5hbWUsIGJvZHksIHNiKSB7XG4gICAgc2IuYXBwZW5kKHJ1bGVOYW1lKTtcbiAgICBzYi5hcHBlbmQoJzogZnVuY3Rpb24oJyk7XG4gICAgY29uc3QgYXJpdHkgPSB0aGlzLl90b3BEb3duQWN0aW9uQXJpdHkocnVsZU5hbWUpO1xuICAgIHNiLmFwcGVuZChjb21tb24ucmVwZWF0KCdfJywgYXJpdHkpLmpvaW4oJywgJykpO1xuICAgIHNiLmFwcGVuZCgnKSB7XFxuJyk7XG4gICAgc2IuYXBwZW5kKCcgIH0nKTtcbiAgfSxcblxuICAvLyBQYXJzZSBhIHN0cmluZyB3aGljaCBleHByZXNzZXMgYSBydWxlIGFwcGxpY2F0aW9uIGluIHRoaXMgZ3JhbW1hciwgYW5kIHJldHVybiB0aGVcbiAgLy8gcmVzdWx0aW5nIEFwcGx5IG5vZGUuXG4gIHBhcnNlQXBwbGljYXRpb24oc3RyKSB7XG4gICAgbGV0IGFwcDtcbiAgICBpZiAoc3RyLmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgIC8vIHNpbXBsZSBhcHBsaWNhdGlvblxuICAgICAgYXBwID0gbmV3IHBleHBycy5BcHBseShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJhbWV0ZXJpemVkIGFwcGxpY2F0aW9uXG4gICAgICBjb25zdCBjc3QgPSBvaG1HcmFtbWFyLm1hdGNoKHN0ciwgJ0Jhc2VfYXBwbGljYXRpb24nKTtcbiAgICAgIGFwcCA9IGJ1aWxkR3JhbW1hcihjc3QsIHt9KTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYXBwbGljYXRpb24gaXMgdmFsaWQuXG4gICAgaWYgKCEoYXBwLnJ1bGVOYW1lIGluIHRoaXMucnVsZXMpKSB7XG4gICAgICB0aHJvdyBlcnJvcnMudW5kZWNsYXJlZFJ1bGUoYXBwLnJ1bGVOYW1lLCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYWxzID0gdGhpcy5ydWxlc1thcHAucnVsZU5hbWVdLmZvcm1hbHM7XG4gICAgaWYgKGZvcm1hbHMubGVuZ3RoICE9PSBhcHAuYXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucnVsZXNbYXBwLnJ1bGVOYW1lXS5zb3VyY2U7XG4gICAgICB0aHJvdyBlcnJvcnMud3JvbmdOdW1iZXJPZlBhcmFtZXRlcnMoYXBwLnJ1bGVOYW1lLCBmb3JtYWxzLmxlbmd0aCwgYXBwLmFyZ3MubGVuZ3RoLCBzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gYXBwO1xuICB9XG59O1xuXG4vLyBUaGUgZm9sbG93aW5nIGdyYW1tYXIgY29udGFpbnMgYSBmZXcgcnVsZXMgdGhhdCBjb3VsZG4ndCBiZSB3cml0dGVuICBpbiBcInVzZXJsYW5kXCIuXG4vLyBBdCB0aGUgYm90dG9tIG9mIHNyYy9tYWluLmpzLCB3ZSBjcmVhdGUgYSBzdWItZ3JhbW1hciBvZiB0aGlzIGdyYW1tYXIgdGhhdCdzIGNhbGxlZFxuLy8gYEJ1aWx0SW5SdWxlc2AuIFRoYXQgZ3JhbW1hciBjb250YWlucyBzZXZlcmFsIGNvbnZlbmllbmNlIHJ1bGVzLCBlLmcuLCBgbGV0dGVyYCBhbmRcbi8vIGBkaWdpdGAsIGFuZCBpcyBpbXBsaWNpdGx5IHRoZSBzdXBlci1ncmFtbWFyIG9mIGFueSBncmFtbWFyIHdob3NlIHN1cGVyLWdyYW1tYXJcbi8vIGlzbid0IHNwZWNpZmllZC5cbkdyYW1tYXIuUHJvdG9CdWlsdEluUnVsZXMgPSBuZXcgR3JhbW1hcihcbiAgICAnUHJvdG9CdWlsdEluUnVsZXMnLCAvLyBuYW1lXG4gICAgdW5kZWZpbmVkLCAvLyBzdXBlcmdyYW1tYXJcbiAgICB7XG4gICAgICBhbnk6IHtcbiAgICAgICAgYm9keTogcGV4cHJzLmFueSxcbiAgICAgICAgZm9ybWFsczogW10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnYW55IGNoYXJhY3RlcicsXG4gICAgICAgIHByaW1pdGl2ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBib2R5OiBwZXhwcnMuZW5kLFxuICAgICAgICBmb3JtYWxzOiBbXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdlbmQgb2YgaW5wdXQnLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIGNhc2VJbnNlbnNpdGl2ZToge1xuICAgICAgICBib2R5OiBuZXcgQ2FzZUluc2Vuc2l0aXZlVGVybWluYWwobmV3IHBleHBycy5QYXJhbSgwKSksXG4gICAgICAgIGZvcm1hbHM6IFsnc3RyJ10sXG4gICAgICAgIHByaW1pdGl2ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxvd2VyOiB7XG4gICAgICAgIGJvZHk6IG5ldyBwZXhwcnMuVW5pY29kZUNoYXIoJ0xsJyksXG4gICAgICAgIGZvcm1hbHM6IFtdLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2EgbG93ZXJjYXNlIGxldHRlcicsXG4gICAgICAgIHByaW1pdGl2ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHVwcGVyOiB7XG4gICAgICAgIGJvZHk6IG5ldyBwZXhwcnMuVW5pY29kZUNoYXIoJ0x1JyksXG4gICAgICAgIGZvcm1hbHM6IFtdLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2FuIHVwcGVyY2FzZSBsZXR0ZXInLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBVbmlvbiBvZiBMdCAodGl0bGVjYXNlKSwgTG0gKG1vZGlmaWVyKSwgYW5kIExvIChvdGhlciksIGkuZS4gYW55IGxldHRlciBub3QgaW4gTGwgb3IgTHUuXG4gICAgICB1bmljb2RlTHRtbzoge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlVuaWNvZGVDaGFyKCdMdG1vJyksXG4gICAgICAgIGZvcm1hbHM6IFtdLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2EgVW5pY29kZSBjaGFyYWN0ZXIgaW4gTHQsIExtLCBvciBMbycsXG4gICAgICAgIHByaW1pdGl2ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLy8gVGhlc2UgcnVsZXMgYXJlIG5vdCB0cnVseSBwcmltaXRpdmUgKHRoZXkgY291bGQgYmUgd3JpdHRlbiBpbiB1c2VybGFuZCkgYnV0IGFyZSBkZWZpbmVkXG4gICAgICAvLyBoZXJlIGZvciBib290c3RyYXBwaW5nIHB1cnBvc2VzLlxuICAgICAgc3BhY2VzOiB7XG4gICAgICAgIGJvZHk6IG5ldyBwZXhwcnMuU3RhcihuZXcgcGV4cHJzLkFwcGx5KCdzcGFjZScpKSxcbiAgICAgICAgZm9ybWFsczogW11cbiAgICAgIH0sXG4gICAgICBzcGFjZToge1xuICAgICAgICBib2R5OiBuZXcgcGV4cHJzLlJhbmdlKCdcXHgwMCcsICcgJyksXG4gICAgICAgIGZvcm1hbHM6IFtdLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2Egc3BhY2UnXG4gICAgICB9XG4gICAgfVxuKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gR3JhbW1hcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEdyYW1tYXIgPSByZXF1aXJlKCcuL0dyYW1tYXInKTtcbmNvbnN0IElucHV0U3RyZWFtID0gcmVxdWlyZSgnLi9JbnB1dFN0cmVhbScpO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBTdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQ29uc3RydWN0b3JzXG5cbmZ1bmN0aW9uIEdyYW1tYXJEZWNsKG5hbWUpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbn1cblxuLy8gSGVscGVyc1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuc291cmNlSW50ZXJ2YWwgPSBmdW5jdGlvbihzdGFydElkeCwgZW5kSWR4KSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZS5zdWJJbnRlcnZhbChzdGFydElkeCwgZW5kSWR4IC0gc3RhcnRJZHgpO1xufTtcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLmVuc3VyZVN1cGVyR3JhbW1hciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuc3VwZXJHcmFtbWFyKSB7XG4gICAgdGhpcy53aXRoU3VwZXJHcmFtbWFyKFxuICAgICAgICAvLyBUT0RPOiBUaGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBiZWxvdyBpcyBhbiB1Z2x5IGhhY2suIEl0J3Mga2luZCBvZiBvayBiZWNhdXNlXG4gICAgICAgIC8vIEkgZG91YnQgYW55b25lIHdpbGwgZXZlciB0cnkgdG8gZGVjbGFyZSBhIGdyYW1tYXIgY2FsbGVkIGBCdWlsdEluUnVsZXNgLiBTdGlsbCxcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHRyeSB0byBmaW5kIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzLlxuICAgICAgICB0aGlzLm5hbWUgPT09ICdCdWlsdEluUnVsZXMnID9cbiAgICAgICAgICAgIEdyYW1tYXIuUHJvdG9CdWlsdEluUnVsZXMgOlxuICAgICAgICAgICAgR3JhbW1hci5CdWlsdEluUnVsZXMpO1xuICB9XG4gIHJldHVybiB0aGlzLnN1cGVyR3JhbW1hcjtcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5lbnN1cmVTdXBlckdyYW1tYXJSdWxlRm9yT3ZlcnJpZGluZyA9IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICBjb25zdCBydWxlSW5mbyA9IHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyKCkucnVsZXNbbmFtZV07XG4gIGlmICghcnVsZUluZm8pIHtcbiAgICB0aHJvdyBlcnJvcnMuY2Fubm90T3ZlcnJpZGVVbmRlY2xhcmVkUnVsZShuYW1lLCB0aGlzLnN1cGVyR3JhbW1hci5uYW1lLCBzb3VyY2UpO1xuICB9XG4gIHJldHVybiBydWxlSW5mbztcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5pbnN0YWxsT3ZlcnJpZGRlbk9yRXh0ZW5kZWRSdWxlID0gZnVuY3Rpb24obmFtZSwgZm9ybWFscywgYm9keSwgc291cmNlKSB7XG4gIGNvbnN0IGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzID0gY29tbW9uLmdldER1cGxpY2F0ZXMoZm9ybWFscyk7XG4gIGlmIChkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgZXJyb3JzLmR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzKG5hbWUsIGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzLCBzb3VyY2UpO1xuICB9XG4gIGNvbnN0IHJ1bGVJbmZvID0gdGhpcy5lbnN1cmVTdXBlckdyYW1tYXIoKS5ydWxlc1tuYW1lXTtcbiAgY29uc3QgZXhwZWN0ZWRGb3JtYWxzID0gcnVsZUluZm8uZm9ybWFscztcbiAgY29uc3QgZXhwZWN0ZWROdW1Gb3JtYWxzID0gZXhwZWN0ZWRGb3JtYWxzID8gZXhwZWN0ZWRGb3JtYWxzLmxlbmd0aCA6IDA7XG4gIGlmIChmb3JtYWxzLmxlbmd0aCAhPT0gZXhwZWN0ZWROdW1Gb3JtYWxzKSB7XG4gICAgdGhyb3cgZXJyb3JzLndyb25nTnVtYmVyT2ZQYXJhbWV0ZXJzKG5hbWUsIGV4cGVjdGVkTnVtRm9ybWFscywgZm9ybWFscy5sZW5ndGgsIHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5zdGFsbChuYW1lLCBmb3JtYWxzLCBib2R5LCBydWxlSW5mby5kZXNjcmlwdGlvbiwgc291cmNlKTtcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24obmFtZSwgZm9ybWFscywgYm9keSwgZGVzY3JpcHRpb24sIHNvdXJjZSkge1xuICB0aGlzLnJ1bGVzW25hbWVdID0ge1xuICAgIGJvZHk6IGJvZHkuaW50cm9kdWNlUGFyYW1zKGZvcm1hbHMpLFxuICAgIGZvcm1hbHMsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc291cmNlXG4gIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU3R1ZmYgdGhhdCB5b3Ugc2hvdWxkIG9ubHkgZG8gb25jZVxuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUud2l0aFN1cGVyR3JhbW1hciA9IGZ1bmN0aW9uKHN1cGVyR3JhbW1hcikge1xuICBpZiAodGhpcy5zdXBlckdyYW1tYXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBzdXBlciBncmFtbWFyIG9mIGEgR3JhbW1hckRlY2wgY2Fubm90IGJlIHNldCBtb3JlIHRoYW4gb25jZScpO1xuICB9XG4gIHRoaXMuc3VwZXJHcmFtbWFyID0gc3VwZXJHcmFtbWFyO1xuICB0aGlzLnJ1bGVzID0gT2JqZWN0LmNyZWF0ZShzdXBlckdyYW1tYXIucnVsZXMpO1xuXG4gIC8vIEdyYW1tYXJzIHdpdGggYW4gZXhwbGljaXQgc3VwZXJncmFtbWFyIGluaGVyaXQgYSBkZWZhdWx0IHN0YXJ0IHJ1bGUuXG4gIGlmICghc3VwZXJHcmFtbWFyLmlzQnVpbHRJbigpKSB7XG4gICAgdGhpcy5kZWZhdWx0U3RhcnRSdWxlID0gc3VwZXJHcmFtbWFyLmRlZmF1bHRTdGFydFJ1bGU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUud2l0aERlZmF1bHRTdGFydFJ1bGUgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICB0aGlzLmRlZmF1bHRTdGFydFJ1bGUgPSBydWxlTmFtZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUud2l0aFNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICB0aGlzLnNvdXJjZSA9IG5ldyBJbnB1dFN0cmVhbShzb3VyY2UpLmludGVydmFsKDAsIHNvdXJjZS5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIENyZWF0ZXMgYSBHcmFtbWFyIGluc3RhbmNlLCBhbmQgaWYgaXQgcGFzc2VzIHRoZSBzYW5pdHkgY2hlY2tzLCByZXR1cm5zIGl0LlxuR3JhbW1hckRlY2wucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGdyYW1tYXIgPSBuZXcgR3JhbW1hcihcbiAgICAgIHRoaXMubmFtZSxcbiAgICAgIHRoaXMuZW5zdXJlU3VwZXJHcmFtbWFyKCksXG4gICAgICB0aGlzLnJ1bGVzLFxuICAgICAgdGhpcy5kZWZhdWx0U3RhcnRSdWxlKTtcblxuICAvLyBUT0RPOiBjaGFuZ2UgdGhlIHBleHByLnByb3RvdHlwZS5hc3NlcnQuLi4gbWV0aG9kcyB0byBtYWtlIHRoZW0gYWRkXG4gIC8vIGV4Y2VwdGlvbnMgdG8gYW4gYXJyYXkgdGhhdCdzIHByb3ZpZGVkIGFzIGFuIGFyZy4gVGhlbiB3ZSdsbCBiZSBhYmxlIHRvXG4gIC8vIHNob3cgbW9yZSB0aGFuIG9uZSBlcnJvciBvZiB0aGUgc2FtZSB0eXBlIGF0IGEgdGltZS5cbiAgLy8gVE9ETzogaW5jbHVkZSB0aGUgb2ZmZW5kaW5nIHBleHByIGluIHRoZSBlcnJvcnMsIHRoYXQgd2F5IHdlIGNhbiBzaG93XG4gIC8vIHRoZSBwYXJ0IG9mIHRoZSBzb3VyY2UgdGhhdCBjYXVzZWQgaXQuXG4gIGNvbnN0IGdyYW1tYXJFcnJvcnMgPSBbXTtcbiAgbGV0IGdyYW1tYXJIYXNJbnZhbGlkQXBwbGljYXRpb25zID0gZmFsc2U7XG4gIE9iamVjdC5rZXlzKGdyYW1tYXIucnVsZXMpLmZvckVhY2gocnVsZU5hbWUgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBncmFtbWFyLnJ1bGVzW3J1bGVOYW1lXS5ib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5LmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5KHJ1bGVOYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBncmFtbWFyRXJyb3JzLnB1c2goZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBib2R5LmFzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBncmFtbWFyRXJyb3JzLnB1c2goZSk7XG4gICAgICBncmFtbWFySGFzSW52YWxpZEFwcGxpY2F0aW9ucyA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFncmFtbWFySGFzSW52YWxpZEFwcGxpY2F0aW9ucykge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgY2FuIG9ubHkgYmUgZG9uZSBpZiB0aGUgZ3JhbW1hciBoYXMgbm8gaW52YWxpZCBhcHBsaWNhdGlvbnMuXG4gICAgT2JqZWN0LmtleXMoZ3JhbW1hci5ydWxlcykuZm9yRWFjaChydWxlTmFtZSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gZ3JhbW1hci5ydWxlc1tydWxlTmFtZV0uYm9keTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJvZHkuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlKGdyYW1tYXIsIFtdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZ3JhbW1hckVycm9ycy5wdXNoKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChncmFtbWFyRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICBlcnJvcnMudGhyb3dFcnJvcnMoZ3JhbW1hckVycm9ycyk7XG4gIH1cbiAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgZ3JhbW1hci5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiBncmFtbWFyO1xufTtcblxuLy8gUnVsZSBkZWNsYXJhdGlvbnNcblxuR3JhbW1hckRlY2wucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGJvZHksIGRlc2NyaXB0aW9uLCBzb3VyY2UpIHtcbiAgdGhpcy5lbnN1cmVTdXBlckdyYW1tYXIoKTtcbiAgaWYgKHRoaXMuc3VwZXJHcmFtbWFyLnJ1bGVzW25hbWVdKSB7XG4gICAgdGhyb3cgZXJyb3JzLmR1cGxpY2F0ZVJ1bGVEZWNsYXJhdGlvbihuYW1lLCB0aGlzLm5hbWUsIHRoaXMuc3VwZXJHcmFtbWFyLm5hbWUsIHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5ydWxlc1tuYW1lXSkge1xuICAgIHRocm93IGVycm9ycy5kdXBsaWNhdGVSdWxlRGVjbGFyYXRpb24obmFtZSwgdGhpcy5uYW1lLCB0aGlzLm5hbWUsIHNvdXJjZSk7XG4gIH1cbiAgY29uc3QgZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMgPSBjb21tb24uZ2V0RHVwbGljYXRlcyhmb3JtYWxzKTtcbiAgaWYgKGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBlcnJvcnMuZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMobmFtZSwgZHVwbGljYXRlUGFyYW1ldGVyTmFtZXMsIHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5zdGFsbChuYW1lLCBmb3JtYWxzLCBib2R5LCBkZXNjcmlwdGlvbiwgc291cmNlKTtcbn07XG5cbkdyYW1tYXJEZWNsLnByb3RvdHlwZS5vdmVycmlkZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcm1hbHMsIGJvZHksIGRlc2NJZ25vcmVkLCBzb3VyY2UpIHtcbiAgdGhpcy5lbnN1cmVTdXBlckdyYW1tYXJSdWxlRm9yT3ZlcnJpZGluZyhuYW1lLCBzb3VyY2UpO1xuICB0aGlzLmluc3RhbGxPdmVycmlkZGVuT3JFeHRlbmRlZFJ1bGUobmFtZSwgZm9ybWFscywgYm9keSwgc291cmNlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFtbWFyRGVjbC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24obmFtZSwgZm9ybWFscywgZnJhZ21lbnQsIGRlc2NJZ25vcmVkLCBzb3VyY2UpIHtcbiAgY29uc3QgcnVsZUluZm8gPSB0aGlzLmVuc3VyZVN1cGVyR3JhbW1hcigpLnJ1bGVzW25hbWVdO1xuICBpZiAoIXJ1bGVJbmZvKSB7XG4gICAgdGhyb3cgZXJyb3JzLmNhbm5vdEV4dGVuZFVuZGVjbGFyZWRSdWxlKG5hbWUsIHRoaXMuc3VwZXJHcmFtbWFyLm5hbWUsIHNvdXJjZSk7XG4gIH1cbiAgY29uc3QgYm9keSA9IG5ldyBwZXhwcnMuRXh0ZW5kKHRoaXMuc3VwZXJHcmFtbWFyLCBuYW1lLCBmcmFnbWVudCk7XG4gIGJvZHkuc291cmNlID0gZnJhZ21lbnQuc291cmNlO1xuICB0aGlzLmluc3RhbGxPdmVycmlkZGVuT3JFeHRlbmRlZFJ1bGUobmFtZSwgZm9ybWFscywgYm9keSwgc291cmNlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFtbWFyRGVjbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEludGVydmFsID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gSW5wdXRTdHJlYW0oc291cmNlKSB7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMuZXhhbWluZWRMZW5ndGggPSAwO1xufVxuXG5JbnB1dFN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIGF0RW5kKCkge1xuICAgIGNvbnN0IGFucyA9IHRoaXMucG9zID09PSB0aGlzLnNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5leGFtaW5lZExlbmd0aCA9IE1hdGgubWF4KHRoaXMuZXhhbWluZWRMZW5ndGgsIHRoaXMucG9zICsgMSk7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBuZXh0KCkge1xuICAgIGNvbnN0IGFucyA9IHRoaXMuc291cmNlW3RoaXMucG9zKytdO1xuICAgIHRoaXMuZXhhbWluZWRMZW5ndGggPSBNYXRoLm1heCh0aGlzLmV4YW1pbmVkTGVuZ3RoLCB0aGlzLnBvcyk7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBtYXRjaFN0cmluZyhzLCBvcHRJZ25vcmVDYXNlKSB7XG4gICAgbGV0IGlkeDtcbiAgICBpZiAob3B0SWdub3JlQ2FzZSkge1xuICAgICAgLypcbiAgICAgICAgQ2FzZS1pbnNlbnNpdGl2ZSBjb21wYXJpc29uIGlzIGEgdHJpY2t5IGJ1c2luZXNzLiBTb21lIG5vdGFibGUgZ290Y2hhcyBpbmNsdWRlIHRoZVxuICAgICAgICBcIlR1cmtpc2ggSVwiIHByb2JsZW0gKGh0dHA6Ly93d3cuaTE4bmd1eS5jb20vdW5pY29kZS90dXJraXNoLWkxOG4uaHRtbCkgYW5kIHRoZSBmYWN0XG4gICAgICAgIHRoYXQgdGhlIEdlcm1hbiBFc3N6ZXQgKMOfKSB0dXJucyBpbnRvIFwiU1NcIiBpbiB1cHBlciBjYXNlLlxuXG4gICAgICAgIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYSBsb2NhbGUtaW52YXJpYW50IGNvbXBhcmlzb24sIHdoaWNoIG1lYW5zIGl0IG1heSBub3Qgb2JleVxuICAgICAgICBsb2NhbGUtc3BlY2lmaWMgZXhwZWN0YXRpb25zIChlLmcuIFwiaVwiID0+IFwixLBcIikuXG4gICAgICAgKi9cbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbCA9IHRoaXMubmV4dCgpO1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IHNbaWR4XTtcbiAgICAgICAgaWYgKGFjdHVhbCA9PSBudWxsIHx8IGFjdHVhbC50b1VwcGVyQ2FzZSgpICE9PSBleHBlY3RlZC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRGVmYXVsdCBpcyBjYXNlLXNlbnNpdGl2ZSBjb21wYXJpc29uLlxuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAodGhpcy5uZXh0KCkgIT09IHNbaWR4XSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgc291cmNlU2xpY2Uoc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zbGljZShzdGFydElkeCwgZW5kSWR4KTtcbiAgfSxcblxuICBpbnRlcnZhbChzdGFydElkeCwgb3B0RW5kSWR4KSB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZSwgc3RhcnRJZHgsIG9wdEVuZElkeCA/IG9wdEVuZElkeCA6IHRoaXMucG9zKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXRTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCcuL2NvbW1vbicpLmFzc2VydDtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBJbnRlcnZhbChzb3VyY2VTdHJpbmcsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgdGhpcy5zb3VyY2VTdHJpbmcgPSBzb3VyY2VTdHJpbmc7XG4gIHRoaXMuc3RhcnRJZHggPSBzdGFydElkeDtcbiAgdGhpcy5lbmRJZHggPSBlbmRJZHg7XG59XG5cbkludGVydmFsLmNvdmVyYWdlID0gZnVuY3Rpb24oLyogaW50ZXJ2YWwxLCBpbnRlcnZhbDIsIC4uLiAqLykge1xuICBjb25zdCBzb3VyY2VTdHJpbmcgPSBhcmd1bWVudHNbMF0uc291cmNlU3RyaW5nO1xuICBsZXQgc3RhcnRJZHggPSBhcmd1bWVudHNbMF0uc3RhcnRJZHg7XG4gIGxldCBlbmRJZHggPSBhcmd1bWVudHNbMF0uZW5kSWR4O1xuICBmb3IgKGxldCBpZHggPSAxOyBpZHggPCBhcmd1bWVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgIGNvbnN0IGludGVydmFsID0gYXJndW1lbnRzW2lkeF07XG4gICAgaWYgKGludGVydmFsLnNvdXJjZVN0cmluZyAhPT0gc291cmNlU3RyaW5nKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW50ZXJ2YWxTb3VyY2VzRG9udE1hdGNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SWR4ID0gTWF0aC5taW4oc3RhcnRJZHgsIGFyZ3VtZW50c1tpZHhdLnN0YXJ0SWR4KTtcbiAgICAgIGVuZElkeCA9IE1hdGgubWF4KGVuZElkeCwgYXJndW1lbnRzW2lkeF0uZW5kSWR4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBJbnRlcnZhbChzb3VyY2VTdHJpbmcsIHN0YXJ0SWR4LCBlbmRJZHgpO1xufTtcblxuSW50ZXJ2YWwucHJvdG90eXBlID0ge1xuICBjb3ZlcmFnZVdpdGgoLyogaW50ZXJ2YWwxLCBpbnRlcnZhbDIsIC4uLiAqLykge1xuICAgIGNvbnN0IGludGVydmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaW50ZXJ2YWxzLnB1c2godGhpcyk7XG4gICAgcmV0dXJuIEludGVydmFsLmNvdmVyYWdlLmFwcGx5KHVuZGVmaW5lZCwgaW50ZXJ2YWxzKTtcbiAgfSxcblxuICBjb2xsYXBzZWRMZWZ0KCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHRoaXMuc3RhcnRJZHgsIHRoaXMuc3RhcnRJZHgpO1xuICB9LFxuXG4gIGNvbGxhcHNlZFJpZ2h0KCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHRoaXMuZW5kSWR4LCB0aGlzLmVuZElkeCk7XG4gIH0sXG5cbiAgZ2V0TGluZUFuZENvbHVtbigpIHtcbiAgICByZXR1cm4gdXRpbC5nZXRMaW5lQW5kQ29sdW1uKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLnN0YXJ0SWR4KTtcbiAgfSxcblxuICBnZXRMaW5lQW5kQ29sdW1uTWVzc2FnZSgpIHtcbiAgICBjb25zdCByYW5nZSA9IFt0aGlzLnN0YXJ0SWR4LCB0aGlzLmVuZElkeF07XG4gICAgcmV0dXJuIHV0aWwuZ2V0TGluZUFuZENvbHVtbk1lc3NhZ2UodGhpcy5zb3VyY2VTdHJpbmcsIHRoaXMuc3RhcnRJZHgsIHJhbmdlKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIDAsIDEsIG9yIDIgaW50ZXJ2YWxzIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIHRoZVxuICAvLyBpbnRlcnZhbCBkaWZmZXJlbmNlIG9wZXJhdGlvbi5cbiAgbWludXModGhhdCkge1xuICAgIGlmICh0aGlzLnNvdXJjZVN0cmluZyAhPT0gdGhhdC5zb3VyY2VTdHJpbmcpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbnRlcnZhbFNvdXJjZXNEb250TWF0Y2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRJZHggPT09IHRoYXQuc3RhcnRJZHggJiYgdGhpcy5lbmRJZHggPT09IHRoYXQuZW5kSWR4KSB7XG4gICAgICAvLyBgdGhpc2AgYW5kIGB0aGF0YCBhcmUgdGhlIHNhbWUgaW50ZXJ2YWwhXG4gICAgICByZXR1cm4gW1xuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRJZHggPCB0aGF0LnN0YXJ0SWR4ICYmIHRoYXQuZW5kSWR4IDwgdGhpcy5lbmRJZHgpIHtcbiAgICAgIC8vIGB0aGF0YCBzcGxpdHMgYHRoaXNgIGludG8gdHdvIGludGVydmFsc1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLnN0YXJ0SWR4LCB0aGF0LnN0YXJ0SWR4KSxcbiAgICAgICAgbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGF0LmVuZElkeCwgdGhpcy5lbmRJZHgpXG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGFydElkeCA8IHRoYXQuZW5kSWR4ICYmIHRoYXQuZW5kSWR4IDwgdGhpcy5lbmRJZHgpIHtcbiAgICAgIC8vIGB0aGF0YCBjb250YWlucyBhIHByZWZpeCBvZiBgdGhpc2BcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBJbnRlcnZhbCh0aGlzLnNvdXJjZVN0cmluZywgdGhhdC5lbmRJZHgsIHRoaXMuZW5kSWR4KVxuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRJZHggPCB0aGF0LnN0YXJ0SWR4ICYmIHRoYXQuc3RhcnRJZHggPCB0aGlzLmVuZElkeCkge1xuICAgICAgLy8gYHRoYXRgIGNvbnRhaW5zIGEgc3VmZml4IG9mIGB0aGlzYFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLCB0aGlzLnN0YXJ0SWR4LCB0aGF0LnN0YXJ0SWR4KVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHRoYXRgIGFuZCBgdGhpc2AgZG8gbm90IG92ZXJsYXBcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXNcbiAgICAgIF07XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgYSBuZXcgSW50ZXJ2YWwgdGhhdCBoYXMgdGhlIHNhbWUgZXh0ZW50IGFzIHRoaXMgb25lLCBidXQgd2hpY2ggaXMgcmVsYXRpdmVcbiAgLy8gdG8gYHRoYXRgLCBhbiBJbnRlcnZhbCB0aGF0IGZ1bGx5IGNvdmVycyB0aGlzIG9uZS5cbiAgcmVsYXRpdmVUbyh0aGF0KSB7XG4gICAgaWYgKHRoaXMuc291cmNlU3RyaW5nICE9PSB0aGF0LnNvdXJjZVN0cmluZykge1xuICAgICAgdGhyb3cgZXJyb3JzLmludGVydmFsU291cmNlc0RvbnRNYXRjaCgpO1xuICAgIH1cbiAgICBhc3NlcnQodGhpcy5zdGFydElkeCA+PSB0aGF0LnN0YXJ0SWR4ICYmIHRoaXMuZW5kSWR4IDw9IHRoYXQuZW5kSWR4LFxuICAgICAgICAnb3RoZXIgaW50ZXJ2YWwgZG9lcyBub3QgY292ZXIgdGhpcyBvbmUnKTtcbiAgICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuc291cmNlU3RyaW5nLFxuICAgICAgICB0aGlzLnN0YXJ0SWR4IC0gdGhhdC5zdGFydElkeCxcbiAgICAgICAgdGhpcy5lbmRJZHggLSB0aGF0LnN0YXJ0SWR4KTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgbmV3IEludGVydmFsIHdoaWNoIGNvbnRhaW5zIHRoZSBzYW1lIGNvbnRlbnRzIGFzIHRoaXMgb25lLFxuICAvLyBidXQgd2l0aCB3aGl0ZXNwYWNlIHRyaW1tZWQgZnJvbSBib3RoIGVuZHMuIChUaGlzIG9ubHkgbWFrZXMgc2Vuc2Ugd2hlblxuICAvLyB0aGUgaW5wdXQgc3RyZWFtIGlzIGEgc3RyaW5nLilcbiAgdHJpbW1lZCgpIHtcbiAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29udGVudHM7XG4gICAgY29uc3Qgc3RhcnRJZHggPSB0aGlzLnN0YXJ0SWR4ICsgY29udGVudHMubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IGVuZElkeCA9IHRoaXMuZW5kSWR4IC0gY29udGVudHMubWF0Y2goL1xccyokLylbMF0ubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIHN0YXJ0SWR4LCBlbmRJZHgpO1xuICB9LFxuXG4gIHN1YkludGVydmFsKG9mZnNldCwgbGVuKSB7XG4gICAgY29uc3QgbmV3U3RhcnRJZHggPSB0aGlzLnN0YXJ0SWR4ICsgb2Zmc2V0O1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zb3VyY2VTdHJpbmcsIG5ld1N0YXJ0SWR4LCBuZXdTdGFydElkeCArIGxlbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEludGVydmFsLnByb3RvdHlwZSwge1xuICBjb250ZW50czoge1xuICAgIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9jb250ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRzID0gdGhpcy5zb3VyY2VTdHJpbmcuc2xpY2UodGhpcy5zdGFydElkeCwgdGhpcy5lbmRJZHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9LFxuICBsZW5ndGg6IHtcbiAgICBnZXQoKSB7IHJldHVybiB0aGlzLmVuZElkeCAtIHRoaXMuc3RhcnRJZHg7IH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJ2YWw7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBJbnRlcnZhbCA9IHJlcXVpcmUoJy4vSW50ZXJ2YWwnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIE1hdGNoUmVzdWx0KFxuICAgIG1hdGNoZXIsXG4gICAgaW5wdXQsXG4gICAgc3RhcnRFeHByLFxuICAgIGNzdCxcbiAgICBjc3RPZmZzZXQsXG4gICAgcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uLFxuICAgIG9wdFJlY29yZGVkRmFpbHVyZXMpIHtcblxuICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIHRoaXMuc3RhcnRFeHByID0gc3RhcnRFeHByO1xuICB0aGlzLl9jc3QgPSBjc3Q7XG4gIHRoaXMuX2NzdE9mZnNldCA9IGNzdE9mZnNldDtcbiAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uO1xuICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlcyA9IG9wdFJlY29yZGVkRmFpbHVyZXM7XG5cbiAgaWYgKHRoaXMuZmFpbGVkKCkpIHtcbiAgICBjb21tb24uZGVmaW5lTGF6eVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBkZXRhaWwgPSAnRXhwZWN0ZWQgJyArIHRoaXMuZ2V0RXhwZWN0ZWRUZXh0KCk7XG4gICAgICByZXR1cm4gdXRpbC5nZXRMaW5lQW5kQ29sdW1uTWVzc2FnZSh0aGlzLmlucHV0LCB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpKSArIGRldGFpbDtcbiAgICB9KTtcbiAgICBjb21tb24uZGVmaW5lTGF6eVByb3BlcnR5KHRoaXMsICdzaG9ydE1lc3NhZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGRldGFpbCA9ICdleHBlY3RlZCAnICsgdGhpcy5nZXRFeHBlY3RlZFRleHQoKTtcbiAgICAgIGNvbnN0IGVycm9ySW5mbyA9IHV0aWwuZ2V0TGluZUFuZENvbHVtbih0aGlzLmlucHV0LCB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpKTtcbiAgICAgIHJldHVybiAnTGluZSAnICsgZXJyb3JJbmZvLmxpbmVOdW0gKyAnLCBjb2wgJyArIGVycm9ySW5mby5jb2xOdW0gKyAnOiAnICsgZGV0YWlsO1xuICAgIH0pO1xuICB9XG59XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS5zdWNjZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5fY3N0O1xufTtcblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLmZhaWxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuc3VjY2VlZGVkKCk7XG59O1xuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuZ2V0UmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb247XG59O1xuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuZ2V0UmlnaHRtb3N0RmFpbHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yaWdodG1vc3RGYWlsdXJlcykge1xuICAgIHRoaXMubWF0Y2hlci5zZXRJbnB1dCh0aGlzLmlucHV0KTtcbiAgICBjb25zdCBtYXRjaFJlc3VsdFdpdGhGYWlsdXJlcyA9XG4gICAgICAgIHRoaXMubWF0Y2hlci5fbWF0Y2godGhpcy5zdGFydEV4cHIsIGZhbHNlLCB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpKTtcbiAgICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlcyA9IG1hdGNoUmVzdWx0V2l0aEZhaWx1cmVzLmdldFJpZ2h0bW9zdEZhaWx1cmVzKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVzO1xufTtcblxuTWF0Y2hSZXN1bHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN1Y2NlZWRlZCgpID9cbiAgICAgICdbbWF0Y2ggc3VjY2VlZGVkXScgOlxuICAgICAgJ1ttYXRjaCBmYWlsZWQgYXQgcG9zaXRpb24gJyArIHRoaXMuZ2V0UmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKCkgKyAnXSc7XG59O1xuXG4vLyBSZXR1cm4gYSBzdHJpbmcgc3VtbWFyaXppbmcgdGhlIGV4cGVjdGVkIGNvbnRlbnRzIG9mIHRoZSBpbnB1dCBzdHJlYW0gd2hlblxuLy8gdGhlIG1hdGNoIGZhaWx1cmUgb2NjdXJyZWQuXG5NYXRjaFJlc3VsdC5wcm90b3R5cGUuZ2V0RXhwZWN0ZWRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1Y2NlZWRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2V0IGV4cGVjdGVkIHRleHQgb2YgYSBzdWNjZXNzZnVsIE1hdGNoUmVzdWx0Jyk7XG4gIH1cblxuICBjb25zdCBzYiA9IG5ldyBjb21tb24uU3RyaW5nQnVmZmVyKCk7XG4gIGxldCBmYWlsdXJlcyA9IHRoaXMuZ2V0UmlnaHRtb3N0RmFpbHVyZXMoKTtcblxuICAvLyBGaWx0ZXIgb3V0IHRoZSBmbHVmZnkgZmFpbHVyZXMgdG8gbWFrZSB0aGUgZGVmYXVsdCBlcnJvciBtZXNzYWdlcyBtb3JlIHVzZWZ1bFxuICBmYWlsdXJlcyA9IGZhaWx1cmVzLmZpbHRlcihmYWlsdXJlID0+ICFmYWlsdXJlLmlzRmx1ZmZ5KCkpO1xuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGZhaWx1cmVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgaWYgKGlkeCA9PT0gZmFpbHVyZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBzYi5hcHBlbmQoZmFpbHVyZXMubGVuZ3RoID4gMiA/ICcsIG9yICcgOiAnIG9yICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2IuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuICAgIH1cbiAgICBzYi5hcHBlbmQoZmFpbHVyZXNbaWR4XS50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gc2IuY29udGVudHMoKTtcbn07XG5cbk1hdGNoUmVzdWx0LnByb3RvdHlwZS5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBwb3MgPSB0aGlzLmdldFJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbigpO1xuICByZXR1cm4gbmV3IEludGVydmFsKHRoaXMuaW5wdXQsIHBvcywgcG9zKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGNoUmVzdWx0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgSW5wdXRTdHJlYW0gPSByZXF1aXJlKCcuL0lucHV0U3RyZWFtJyk7XG5jb25zdCBNYXRjaFJlc3VsdCA9IHJlcXVpcmUoJy4vTWF0Y2hSZXN1bHQnKTtcbmNvbnN0IFBvc0luZm8gPSByZXF1aXJlKCcuL1Bvc0luZm8nKTtcbmNvbnN0IFRyYWNlID0gcmVxdWlyZSgnLi9UcmFjZScpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGFwcGx5U3BhY2VzID0gbmV3IHBleHBycy5BcHBseSgnc3BhY2VzJyk7XG5cbmZ1bmN0aW9uIE1hdGNoU3RhdGUobWF0Y2hlciwgc3RhcnRFeHByLCBvcHRQb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpIHtcbiAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgdGhpcy5zdGFydEV4cHIgPSBzdGFydEV4cHI7XG5cbiAgdGhpcy5ncmFtbWFyID0gbWF0Y2hlci5ncmFtbWFyO1xuICB0aGlzLmlucHV0ID0gbWF0Y2hlci5pbnB1dDtcbiAgdGhpcy5pbnB1dFN0cmVhbSA9IG5ldyBJbnB1dFN0cmVhbShtYXRjaGVyLmlucHV0KTtcbiAgdGhpcy5tZW1vVGFibGUgPSBtYXRjaGVyLm1lbW9UYWJsZTtcblxuICB0aGlzLl9iaW5kaW5ncyA9IFtdO1xuICB0aGlzLl9iaW5kaW5nT2Zmc2V0cyA9IFtdO1xuICB0aGlzLl9hcHBsaWNhdGlvblN0YWNrID0gW107XG4gIHRoaXMuX3Bvc1N0YWNrID0gWzBdO1xuICB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2sgPSBbZmFsc2VdO1xuXG4gIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gLTE7XG4gIHRoaXMuX3JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvblN0YWNrID0gW107XG4gIHRoaXMuX3JlY29yZGVkRmFpbHVyZXNTdGFjayA9IFtdO1xuXG4gIGlmIChvcHRQb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMucG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzID0gb3B0UG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzO1xuICAgIHRoaXMucmVjb3JkZWRGYWlsdXJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbn1cblxuTWF0Y2hTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHBvc1RvT2Zmc2V0KHBvcykge1xuICAgIHJldHVybiBwb3MgLSB0aGlzLl9wb3NTdGFja1t0aGlzLl9wb3NTdGFjay5sZW5ndGggLSAxXTtcbiAgfSxcblxuICBlbnRlckFwcGxpY2F0aW9uKHBvc0luZm8sIGFwcCkge1xuICAgIHRoaXMuX3Bvc1N0YWNrLnB1c2godGhpcy5pbnB1dFN0cmVhbS5wb3MpO1xuICAgIHRoaXMuX2FwcGxpY2F0aW9uU3RhY2sucHVzaChhcHApO1xuICAgIHRoaXMuaW5MZXhpZmllZENvbnRleHRTdGFjay5wdXNoKGZhbHNlKTtcbiAgICBwb3NJbmZvLmVudGVyKGFwcCk7XG4gICAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uU3RhY2sucHVzaCh0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbik7XG4gICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSAtMTtcbiAgfSxcblxuICBleGl0QXBwbGljYXRpb24ocG9zSW5mbywgb3B0Tm9kZSkge1xuICAgIGNvbnN0IG9yaWdQb3MgPSB0aGlzLl9wb3NTdGFjay5wb3AoKTtcbiAgICB0aGlzLl9hcHBsaWNhdGlvblN0YWNrLnBvcCgpO1xuICAgIHRoaXMuaW5MZXhpZmllZENvbnRleHRTdGFjay5wb3AoKTtcbiAgICBwb3NJbmZvLmV4aXQoKTtcblxuICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgIHRoaXMucmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uLFxuICAgICAgICB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb25TdGFjay5wb3AoKSk7XG5cbiAgICBpZiAob3B0Tm9kZSkge1xuICAgICAgdGhpcy5wdXNoQmluZGluZyhvcHROb2RlLCBvcmlnUG9zKTtcbiAgICB9XG4gIH0sXG5cbiAgZW50ZXJMZXhpZmllZENvbnRleHQoKSB7XG4gICAgdGhpcy5pbkxleGlmaWVkQ29udGV4dFN0YWNrLnB1c2godHJ1ZSk7XG4gIH0sXG5cbiAgZXhpdExleGlmaWVkQ29udGV4dCgpIHtcbiAgICB0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2sucG9wKCk7XG4gIH0sXG5cbiAgY3VycmVudEFwcGxpY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9hcHBsaWNhdGlvblN0YWNrW3RoaXMuX2FwcGxpY2F0aW9uU3RhY2subGVuZ3RoIC0gMV07XG4gIH0sXG5cbiAgaW5TeW50YWN0aWNDb250ZXh0KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5pbnB1dFN0cmVhbS5zb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRBcHBsaWNhdGlvbiA9IHRoaXMuY3VycmVudEFwcGxpY2F0aW9uKCk7XG4gICAgaWYgKGN1cnJlbnRBcHBsaWNhdGlvbikge1xuICAgICAgcmV0dXJuIGN1cnJlbnRBcHBsaWNhdGlvbi5pc1N5bnRhY3RpYygpICYmICF0aGlzLmluTGV4aWZpZWRDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSB0b3AtbGV2ZWwgY29udGV4dCBpcyBzeW50YWN0aWMgaWYgdGhlIHN0YXJ0IGFwcGxpY2F0aW9uIGlzLlxuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRFeHByLmZhY3RvcnNbMF0uaXNTeW50YWN0aWMoKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5MZXhpZmllZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5MZXhpZmllZENvbnRleHRTdGFja1t0aGlzLmluTGV4aWZpZWRDb250ZXh0U3RhY2subGVuZ3RoIC0gMV07XG4gIH0sXG5cbiAgc2tpcFNwYWNlcygpIHtcbiAgICB0aGlzLnB1c2hGYWlsdXJlc0luZm8oKTtcbiAgICB0aGlzLmV2YWwoYXBwbHlTcGFjZXMpO1xuICAgIHRoaXMucG9wQmluZGluZygpO1xuICAgIHRoaXMucG9wRmFpbHVyZXNJbmZvKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRTdHJlYW0ucG9zO1xuICB9LFxuXG4gIHNraXBTcGFjZXNJZkluU3ludGFjdGljQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pblN5bnRhY3RpY0NvbnRleHQoKSA/XG4gICAgICAgIHRoaXMuc2tpcFNwYWNlcygpIDpcbiAgICAgICAgdGhpcy5pbnB1dFN0cmVhbS5wb3M7XG4gIH0sXG5cbiAgbWF5YmVTa2lwU3BhY2VzQmVmb3JlKGV4cHIpIHtcbiAgICBpZiAoZXhwciBpbnN0YW5jZW9mIHBleHBycy5BcHBseSAmJiBleHByLmlzU3ludGFjdGljKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraXBTcGFjZXMoKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSgpICYmIGV4cHIgIT09IGFwcGx5U3BhY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5za2lwU3BhY2VzSWZJblN5bnRhY3RpY0NvbnRleHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRTdHJlYW0ucG9zO1xuICAgIH1cbiAgfSxcblxuICBwdXNoQmluZGluZyhub2RlLCBvcmlnUG9zKSB7XG4gICAgdGhpcy5fYmluZGluZ3MucHVzaChub2RlKTtcbiAgICB0aGlzLl9iaW5kaW5nT2Zmc2V0cy5wdXNoKHRoaXMucG9zVG9PZmZzZXQob3JpZ1BvcykpO1xuICB9LFxuXG4gIHBvcEJpbmRpbmcoKSB7XG4gICAgdGhpcy5fYmluZGluZ3MucG9wKCk7XG4gICAgdGhpcy5fYmluZGluZ09mZnNldHMucG9wKCk7XG4gIH0sXG5cbiAgbnVtQmluZGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcbiAgfSxcblxuICB0cnVuY2F0ZUJpbmRpbmdzKG5ld0xlbmd0aCkge1xuICAgIC8vIFllcywgdGhpcyBpcyB0aGlzIHJlYWxseSBmYXN0ZXIgdGhhbiBzZXR0aW5nIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eSAodGVzdGVkIHdpdGhcbiAgICAvLyBiaW4vZXM1YmVuY2ggb24gTm9kZSB2Ni4xLjApLlxuICAgIHdoaWxlICh0aGlzLl9iaW5kaW5ncy5sZW5ndGggPiBuZXdMZW5ndGgpIHtcbiAgICAgIHRoaXMucG9wQmluZGluZygpO1xuICAgIH1cbiAgfSxcblxuICBnZXRDdXJyZW50UG9zSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb3NJbmZvKHRoaXMuaW5wdXRTdHJlYW0ucG9zKTtcbiAgfSxcblxuICBnZXRQb3NJbmZvKHBvcykge1xuICAgIGxldCBwb3NJbmZvID0gdGhpcy5tZW1vVGFibGVbcG9zXTtcbiAgICBpZiAoIXBvc0luZm8pIHtcbiAgICAgIHBvc0luZm8gPSB0aGlzLm1lbW9UYWJsZVtwb3NdID0gbmV3IFBvc0luZm8oKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc0luZm87XG4gIH0sXG5cbiAgcHJvY2Vzc0ZhaWx1cmUocG9zLCBleHByKSB7XG4gICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSBNYXRoLm1heCh0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiwgcG9zKTtcblxuICAgIGlmICh0aGlzLnJlY29yZGVkRmFpbHVyZXMgJiYgcG9zID09PSB0aGlzLnBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcykge1xuICAgICAgY29uc3QgYXBwID0gdGhpcy5jdXJyZW50QXBwbGljYXRpb24oKTtcbiAgICAgIGlmIChhcHApIHtcbiAgICAgICAgLy8gU3Vic3RpdHV0ZSBwYXJhbWV0ZXJzIHdpdGggdGhlIGFjdHVhbCBwZXhwcnMgdGhhdCB3ZXJlIHBhc3NlZCB0b1xuICAgICAgICAvLyB0aGUgY3VycmVudCBydWxlLlxuICAgICAgICBleHByID0gZXhwci5zdWJzdGl0dXRlUGFyYW1zKGFwcC5hcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgYnJhbmNoIGlzIG9ubHkgcmVhY2hlZCBmb3IgdGhlIFwiZW5kLWNoZWNrXCIgdGhhdCBpc1xuICAgICAgICAvLyBwZXJmb3JtZWQgYWZ0ZXIgdGhlIHRvcC1sZXZlbCBhcHBsaWNhdGlvbi4gSW4gdGhhdCBjYXNlLFxuICAgICAgICAvLyBleHByID09PSBwZXhwcnMuZW5kIHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gc3Vic3RpdHV0ZVxuICAgICAgICAvLyBwYXJhbWV0ZXJzLlxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlY29yZEZhaWx1cmUoZXhwci50b0ZhaWx1cmUodGhpcy5ncmFtbWFyKSwgZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICByZWNvcmRGYWlsdXJlKGZhaWx1cmUsIHNob3VsZENsb25lSWZOZXcpIHtcbiAgICBjb25zdCBrZXkgPSBmYWlsdXJlLnRvS2V5KCk7XG4gICAgaWYgKCF0aGlzLnJlY29yZGVkRmFpbHVyZXNba2V5XSkge1xuICAgICAgdGhpcy5yZWNvcmRlZEZhaWx1cmVzW2tleV0gPSBzaG91bGRDbG9uZUlmTmV3ID8gZmFpbHVyZS5jbG9uZSgpIDogZmFpbHVyZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlc1trZXldLmlzRmx1ZmZ5KCkgJiYgIWZhaWx1cmUuaXNGbHVmZnkoKSkge1xuICAgICAgdGhpcy5yZWNvcmRlZEZhaWx1cmVzW2tleV0uY2xlYXJGbHVmZnkoKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVjb3JkRmFpbHVyZXMoZmFpbHVyZXMsIHNob3VsZENsb25lSWZOZXcpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhmYWlsdXJlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgc2VsZi5yZWNvcmRGYWlsdXJlKGZhaWx1cmVzW2tleV0sIHNob3VsZENsb25lSWZOZXcpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNsb25lUmVjb3JkZWRGYWlsdXJlcygpIHtcbiAgICBpZiAoIXRoaXMucmVjb3JkZWRGYWlsdXJlcykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBhbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKHRoaXMucmVjb3JkZWRGYWlsdXJlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgYW5zW2tleV0gPSBzZWxmLnJlY29yZGVkRmFpbHVyZXNba2V5XS5jbG9uZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgZ2V0UmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbjtcbiAgfSxcblxuICBfZ2V0UmlnaHRtb3N0RmFpbHVyZU9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPj0gMCA/XG4gICAgICAgIHRoaXMucG9zVG9PZmZzZXQodGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24pIDpcbiAgICAgICAgLTE7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgbWVtb2l6ZWQgdHJhY2UgZW50cnkgZm9yIGBleHByYCBhdCBgcG9zYCwgaWYgb25lIGV4aXN0cywgYG51bGxgIG90aGVyd2lzZS5cbiAgZ2V0TWVtb2l6ZWRUcmFjZUVudHJ5KHBvcywgZXhwcikge1xuICAgIGNvbnN0IHBvc0luZm8gPSB0aGlzLm1lbW9UYWJsZVtwb3NdO1xuICAgIGlmIChwb3NJbmZvICYmIGV4cHIucnVsZU5hbWUpIHtcbiAgICAgIGNvbnN0IG1lbW9SZWMgPSBwb3NJbmZvLm1lbW9bZXhwci50b01lbW9LZXkoKV07XG4gICAgICBpZiAobWVtb1JlYyAmJiBtZW1vUmVjLnRyYWNlRW50cnkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBtZW1vUmVjLnRyYWNlRW50cnkuY2xvbmVXaXRoRXhwcihleHByKTtcbiAgICAgICAgZW50cnkuaXNNZW1vaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIG5ldyB0cmFjZSBlbnRyeSwgd2l0aCB0aGUgY3VycmVudGx5IGFjdGl2ZSB0cmFjZSBhcnJheSBhcyBpdHMgY2hpbGRyZW4uXG4gIGdldFRyYWNlRW50cnkocG9zLCBleHByLCBzdWNjZWVkZWQsIGJpbmRpbmdzKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBwZXhwcnMuQXBwbHkpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY3VycmVudEFwcGxpY2F0aW9uKCk7XG4gICAgICBjb25zdCBhY3R1YWxzID0gYXBwID8gYXBwLmFyZ3MgOiBbXTtcbiAgICAgIGV4cHIgPSBleHByLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1lbW9pemVkVHJhY2VFbnRyeShwb3MsIGV4cHIpIHx8XG4gICAgICAgICAgIG5ldyBUcmFjZSh0aGlzLmlucHV0LCBwb3MsIHRoaXMuaW5wdXRTdHJlYW0ucG9zLCBleHByLCBzdWNjZWVkZWQsIGJpbmRpbmdzLCB0aGlzLnRyYWNlKTtcbiAgfSxcblxuICBpc1RyYWNpbmcoKSB7XG4gICAgcmV0dXJuICEhdGhpcy50cmFjZTtcbiAgfSxcblxuICBoYXNOZWNlc3NhcnlJbmZvKG1lbW9SZWMpIHtcbiAgICBpZiAodGhpcy50cmFjZSAmJiAhbWVtb1JlYy50cmFjZUVudHJ5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcyAmJlxuICAgICAgICB0aGlzLmlucHV0U3RyZWFtLnBvcyArIG1lbW9SZWMucmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9PT0gdGhpcy5wb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpIHtcbiAgICAgIHJldHVybiAhIW1lbW9SZWMuZmFpbHVyZXNBdFJpZ2h0bW9zdFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG5cbiAgdXNlTWVtb2l6ZWRSZXN1bHQob3JpZ1BvcywgbWVtb1JlYykge1xuICAgIGlmICh0aGlzLnRyYWNlKSB7XG4gICAgICB0aGlzLnRyYWNlLnB1c2gobWVtb1JlYy50cmFjZUVudHJ5KTtcbiAgICB9XG5cbiAgICBjb25zdCBtZW1vUmVjUmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uID0gdGhpcy5pbnB1dFN0cmVhbS5wb3MgKyBtZW1vUmVjLnJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQ7XG4gICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPVxuICAgICAgICBNYXRoLm1heCh0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiwgbWVtb1JlY1JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbik7XG4gICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcyAmJlxuICAgICAgICB0aGlzLnBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcyA9PT0gbWVtb1JlY1JpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbiAmJlxuICAgICAgICBtZW1vUmVjLmZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbikge1xuICAgICAgdGhpcy5yZWNvcmRGYWlsdXJlcyhtZW1vUmVjLmZhaWx1cmVzQXRSaWdodG1vc3RQb3NpdGlvbiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCA9XG4gICAgICAgIE1hdGgubWF4KHRoaXMuaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGgsIG1lbW9SZWMuZXhhbWluZWRMZW5ndGggKyBvcmlnUG9zKTtcblxuICAgIGlmIChtZW1vUmVjLnZhbHVlKSB7XG4gICAgICB0aGlzLmlucHV0U3RyZWFtLnBvcyArPSBtZW1vUmVjLm1hdGNoTGVuZ3RoO1xuICAgICAgdGhpcy5wdXNoQmluZGluZyhtZW1vUmVjLnZhbHVlLCBvcmlnUG9zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLy8gRXZhbHVhdGUgYGV4cHJgIGFuZCByZXR1cm4gYHRydWVgIGlmIGl0IHN1Y2NlZWRlZCwgYGZhbHNlYCBvdGhlcndpc2UuIE9uIHN1Y2Nlc3MsIGBiaW5kaW5nc2BcbiAgLy8gd2lsbCBoYXZlIGBleHByLmdldEFyaXR5KClgIG1vcmUgZWxlbWVudHMgdGhhbiBiZWZvcmUsIGFuZCB0aGUgaW5wdXQgc3RyZWFtJ3MgcG9zaXRpb24gbWF5XG4gIC8vIGhhdmUgaW5jcmVhc2VkLiBPbiBmYWlsdXJlLCBgYmluZGluZ3NgIGFuZCBwb3NpdGlvbiB3aWxsIGJlIHVuY2hhbmdlZC5cbiAgZXZhbChleHByKSB7XG4gICAgY29uc3QgaW5wdXRTdHJlYW0gPSB0aGlzLmlucHV0U3RyZWFtO1xuICAgIGNvbnN0IG9yaWdOdW1CaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcblxuICAgIGxldCBvcmlnUmVjb3JkZWRGYWlsdXJlcztcbiAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzKSB7XG4gICAgICBvcmlnUmVjb3JkZWRGYWlsdXJlcyA9IHRoaXMucmVjb3JkZWRGYWlsdXJlcztcbiAgICAgIHRoaXMucmVjb3JkZWRGYWlsdXJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgICBjb25zdCBtZW1vUG9zID0gdGhpcy5tYXliZVNraXBTcGFjZXNCZWZvcmUoZXhwcik7XG5cbiAgICBsZXQgb3JpZ1RyYWNlO1xuICAgIGlmICh0aGlzLnRyYWNlKSB7XG4gICAgICBvcmlnVHJhY2UgPSB0aGlzLnRyYWNlO1xuICAgICAgdGhpcy50cmFjZSA9IFtdO1xuICAgIH1cblxuICAgIC8vIERvIHRoZSBhY3R1YWwgZXZhbHVhdGlvbi5cbiAgICBjb25zdCBhbnMgPSBleHByLmV2YWwodGhpcyk7XG5cbiAgICBpZiAodGhpcy50cmFjZSkge1xuICAgICAgY29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncy5zbGljZShvcmlnTnVtQmluZGluZ3MpO1xuICAgICAgY29uc3QgdHJhY2VFbnRyeSA9IHRoaXMuZ2V0VHJhY2VFbnRyeShtZW1vUG9zLCBleHByLCBhbnMsIGJpbmRpbmdzKTtcbiAgICAgIHRyYWNlRW50cnkuaXNJbXBsaWNpdFNwYWNlcyA9IGV4cHIgPT09IGFwcGx5U3BhY2VzO1xuICAgICAgdHJhY2VFbnRyeS5pc1Jvb3ROb2RlID0gZXhwciA9PT0gdGhpcy5zdGFydEV4cHI7XG4gICAgICBvcmlnVHJhY2UucHVzaCh0cmFjZUVudHJ5KTtcbiAgICAgIHRoaXMudHJhY2UgPSBvcmlnVHJhY2U7XG4gICAgfVxuXG4gICAgaWYgKGFucykge1xuICAgICAgaWYgKHRoaXMucmVjb3JkZWRGYWlsdXJlcyAmJiBpbnB1dFN0cmVhbS5wb3MgPT09IHRoaXMucG9zaXRpb25Ub1JlY29yZEZhaWx1cmVzKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnJlY29yZGVkRmFpbHVyZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBzZWxmLnJlY29yZGVkRmFpbHVyZXNba2V5XS5tYWtlRmx1ZmZ5KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCB0aGUgcG9zaXRpb24gYW5kIHRoZSBiaW5kaW5ncy5cbiAgICAgIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3M7XG4gICAgICB0aGlzLnRydW5jYXRlQmluZGluZ3Mob3JpZ051bUJpbmRpbmdzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzKSB7XG4gICAgICB0aGlzLnJlY29yZEZhaWx1cmVzKG9yaWdSZWNvcmRlZEZhaWx1cmVzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBnZXRNYXRjaFJlc3VsdCgpIHtcbiAgICB0aGlzLmV2YWwodGhpcy5zdGFydEV4cHIpO1xuICAgIGxldCByaWdodG1vc3RGYWlsdXJlcztcbiAgICBpZiAodGhpcy5yZWNvcmRlZEZhaWx1cmVzKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzID0gT2JqZWN0LmtleXModGhpcy5yZWNvcmRlZEZhaWx1cmVzKS5tYXAoa2V5ID0+IHNlbGYucmVjb3JkZWRGYWlsdXJlc1trZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNYXRjaFJlc3VsdChcbiAgICAgICAgdGhpcy5tYXRjaGVyLFxuICAgICAgICB0aGlzLmlucHV0LFxuICAgICAgICB0aGlzLnN0YXJ0RXhwcixcbiAgICAgICAgdGhpcy5fYmluZGluZ3NbMF0sXG4gICAgICAgIHRoaXMuX2JpbmRpbmdPZmZzZXRzWzBdLFxuICAgICAgICB0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbixcbiAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXMpO1xuICB9LFxuXG4gIGdldFRyYWNlKCkge1xuICAgIHRoaXMudHJhY2UgPSBbXTtcbiAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHRoaXMuZ2V0TWF0Y2hSZXN1bHQoKTtcblxuICAgIC8vIFRoZSB0cmFjZSBub2RlIGZvciB0aGUgc3RhcnQgcnVsZSBpcyBhbHdheXMgdGhlIGxhc3QgZW50cnkuIElmIGl0IGlzIGEgc3ludGFjdGljIHJ1bGUsXG4gICAgLy8gdGhlIGZpcnN0IGVudHJ5IGlzIGZvciBhbiBhcHBsaWNhdGlvbiBvZiAnc3BhY2VzJy5cbiAgICAvLyBUT0RPKHBkdWJyb3kpOiBDbGVhbiB0aGlzIHVwIGJ5IGludHJvZHVjaW5nIGEgc3BlY2lhbCBgTWF0Y2g8c3RhcnRBcHBsPmAgcnVsZSwgd2hpY2ggd2lsbFxuICAgIC8vIGVuc3VyZSB0aGF0IHRoZXJlIGlzIGFsd2F5cyBhIHNpbmdsZSByb290IHRyYWNlIG5vZGUuXG4gICAgY29uc3Qgcm9vdFRyYWNlID0gdGhpcy50cmFjZVt0aGlzLnRyYWNlLmxlbmd0aCAtIDFdO1xuICAgIHJvb3RUcmFjZS5yZXN1bHQgPSBtYXRjaFJlc3VsdDtcbiAgICByZXR1cm4gcm9vdFRyYWNlO1xuICB9LFxuXG4gIHB1c2hGYWlsdXJlc0luZm8oKSB7XG4gICAgdGhpcy5fcmlnaHRtb3N0RmFpbHVyZVBvc2l0aW9uU3RhY2sucHVzaCh0aGlzLnJpZ2h0bW9zdEZhaWx1cmVQb3NpdGlvbik7XG4gICAgdGhpcy5fcmVjb3JkZWRGYWlsdXJlc1N0YWNrLnB1c2godGhpcy5yZWNvcmRlZEZhaWx1cmVzKTtcbiAgfSxcblxuICBwb3BGYWlsdXJlc0luZm8oKSB7XG4gICAgdGhpcy5yaWdodG1vc3RGYWlsdXJlUG9zaXRpb24gPSB0aGlzLl9yaWdodG1vc3RGYWlsdXJlUG9zaXRpb25TdGFjay5wb3AoKTtcbiAgICB0aGlzLnJlY29yZGVkRmFpbHVyZXMgPSB0aGlzLl9yZWNvcmRlZEZhaWx1cmVzU3RhY2sucG9wKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGNoU3RhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBNYXRjaFN0YXRlID0gcmVxdWlyZSgnLi9NYXRjaFN0YXRlJyk7XG5cbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBNYXRjaGVyKGdyYW1tYXIpIHtcbiAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgdGhpcy5tZW1vVGFibGUgPSBbXTtcbiAgdGhpcy5pbnB1dCA9ICcnO1xufVxuXG5NYXRjaGVyLnByb3RvdHlwZS5nZXRJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pbnB1dDtcbn07XG5cbk1hdGNoZXIucHJvdG90eXBlLnNldElucHV0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmICh0aGlzLmlucHV0ICE9PSBzdHIpIHtcbiAgICB0aGlzLnJlcGxhY2VJbnB1dFJhbmdlKDAsIHRoaXMuaW5wdXQubGVuZ3RoLCBzdHIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWF0Y2hlci5wcm90b3R5cGUucmVwbGFjZUlucHV0UmFuZ2UgPSBmdW5jdGlvbihzdGFydElkeCwgZW5kSWR4LCBzdHIpIHtcbiAgY29uc3QgY3VycmVudElucHV0ID0gdGhpcy5pbnB1dDtcbiAgaWYgKHN0YXJ0SWR4IDwgMCB8fCBzdGFydElkeCA+IGN1cnJlbnRJbnB1dC5sZW5ndGggfHxcbiAgICAgIGVuZElkeCA8IDAgfHwgZW5kSWR4ID4gY3VycmVudElucHV0Lmxlbmd0aCB8fFxuICAgICAgc3RhcnRJZHggPiBlbmRJZHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kaWNlczogJyArIHN0YXJ0SWR4ICsgJyBhbmQgJyArIGVuZElkeCk7XG4gIH1cblxuICAvLyB1cGRhdGUgaW5wdXRcbiAgdGhpcy5pbnB1dCA9IGN1cnJlbnRJbnB1dC5zbGljZSgwLCBzdGFydElkeCkgKyBzdHIgKyBjdXJyZW50SW5wdXQuc2xpY2UoZW5kSWR4KTtcblxuICAvLyB1cGRhdGUgbWVtbyB0YWJsZSAoc2ltaWxhciB0byB0aGUgYWJvdmUpXG4gIGNvbnN0IHJlc3RPZk1lbW9UYWJsZSA9IHRoaXMubWVtb1RhYmxlLnNsaWNlKGVuZElkeCk7XG4gIHRoaXMubWVtb1RhYmxlLmxlbmd0aCA9IHN0YXJ0SWR4O1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzdHIubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXMubWVtb1RhYmxlLnB1c2godW5kZWZpbmVkKTtcbiAgfVxuICByZXN0T2ZNZW1vVGFibGUuZm9yRWFjaChcbiAgICAgIGZ1bmN0aW9uKHBvc0luZm8pIHsgdGhpcy5tZW1vVGFibGUucHVzaChwb3NJbmZvKTsgfSxcbiAgICAgIHRoaXMpO1xuXG4gIC8vIEludmFsaWRhdGUgbWVtb1JlY3NcbiAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgc3RhcnRJZHg7IHBvcysrKSB7XG4gICAgY29uc3QgcG9zSW5mbyA9IHRoaXMubWVtb1RhYmxlW3Bvc107XG4gICAgaWYgKHBvc0luZm8pIHtcbiAgICAgIHBvc0luZm8uY2xlYXJPYnNvbGV0ZUVudHJpZXMocG9zLCBzdGFydElkeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKG9wdFN0YXJ0QXBwbGljYXRpb25TdHIpIHtcbiAgcmV0dXJuIHRoaXMuX21hdGNoKHRoaXMuX2dldFN0YXJ0RXhwcihvcHRTdGFydEFwcGxpY2F0aW9uU3RyKSwgZmFsc2UpO1xufTtcblxuTWF0Y2hlci5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbihvcHRTdGFydEFwcGxpY2F0aW9uU3RyKSB7XG4gIHJldHVybiB0aGlzLl9tYXRjaCh0aGlzLl9nZXRTdGFydEV4cHIob3B0U3RhcnRBcHBsaWNhdGlvblN0ciksIHRydWUpO1xufTtcblxuTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoID0gZnVuY3Rpb24oc3RhcnRFeHByLCB0cmFjaW5nLCBvcHRQb3NpdGlvblRvUmVjb3JkRmFpbHVyZXMpIHtcbiAgY29uc3Qgc3RhdGUgPSBuZXcgTWF0Y2hTdGF0ZSh0aGlzLCBzdGFydEV4cHIsIG9wdFBvc2l0aW9uVG9SZWNvcmRGYWlsdXJlcyk7XG4gIHJldHVybiB0cmFjaW5nID8gc3RhdGUuZ2V0VHJhY2UoKSA6IHN0YXRlLmdldE1hdGNoUmVzdWx0KCk7XG59O1xuXG4vKlxuICBSZXR1cm5zIHRoZSBzdGFydGluZyBleHByZXNzaW9uIGZvciB0aGlzIE1hdGNoZXIncyBhc3NvY2lhdGVkIGdyYW1tYXIuIElmIGBvcHRTdGFydEFwcGxpY2F0aW9uU3RyYFxuICBpcyBzcGVjaWZpZWQsIGl0IGlzIGEgc3RyaW5nIGV4cHJlc3NpbmcgYSBydWxlIGFwcGxpY2F0aW9uIGluIHRoZSBncmFtbWFyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcbiAgZ3JhbW1hcidzIGRlZmF1bHQgc3RhcnQgcnVsZSB3aWxsIGJlIHVzZWQuXG4qL1xuTWF0Y2hlci5wcm90b3R5cGUuX2dldFN0YXJ0RXhwciA9IGZ1bmN0aW9uKG9wdFN0YXJ0QXBwbGljYXRpb25TdHIpIHtcbiAgY29uc3QgYXBwbGljYXRpb25TdHIgPSBvcHRTdGFydEFwcGxpY2F0aW9uU3RyIHx8IHRoaXMuZ3JhbW1hci5kZWZhdWx0U3RhcnRSdWxlO1xuICBpZiAoIWFwcGxpY2F0aW9uU3RyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHN0YXJ0IHJ1bGUgYXJndW1lbnQgLS0gdGhlIGdyYW1tYXIgaGFzIG5vIGRlZmF1bHQgc3RhcnQgcnVsZS4nKTtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0QXBwID0gdGhpcy5ncmFtbWFyLnBhcnNlQXBwbGljYXRpb24oYXBwbGljYXRpb25TdHIpO1xuICByZXR1cm4gbmV3IHBleHBycy5TZXEoW3N0YXJ0QXBwLCBwZXhwcnMuZW5kXSk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgndXRpbC1leHRlbmQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIE5hbWVzcGFjZSgpIHtcbn1cbk5hbWVzcGFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5OYW1lc3BhY2UuYXNOYW1lc3BhY2UgPSBmdW5jdGlvbihvYmpPck5hbWVzcGFjZSkge1xuICBpZiAob2JqT3JOYW1lc3BhY2UgaW5zdGFuY2VvZiBOYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gb2JqT3JOYW1lc3BhY2U7XG4gIH1cbiAgcmV0dXJuIE5hbWVzcGFjZS5jcmVhdGVOYW1lc3BhY2Uob2JqT3JOYW1lc3BhY2UpO1xufTtcblxuLy8gQ3JlYXRlIGEgbmV3IG5hbWVzcGFjZS4gSWYgYG9wdFByb3BzYCBpcyBzcGVjaWZpZWQsIGFsbCBvZiBpdHMgcHJvcGVydGllc1xuLy8gd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBuYW1lc3BhY2UuXG5OYW1lc3BhY2UuY3JlYXRlTmFtZXNwYWNlID0gZnVuY3Rpb24ob3B0UHJvcHMpIHtcbiAgcmV0dXJuIE5hbWVzcGFjZS5leHRlbmQoTmFtZXNwYWNlLnByb3RvdHlwZSwgb3B0UHJvcHMpO1xufTtcblxuLy8gQ3JlYXRlIGEgbmV3IG5hbWVzcGFjZSB3aGljaCBleHRlbmRzIGFub3RoZXIgbmFtZXNwYWNlLiBJZiBgb3B0UHJvcHNgIGlzXG4vLyBzcGVjaWZpZWQsIGFsbCBvZiBpdHMgcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IG5hbWVzcGFjZS5cbk5hbWVzcGFjZS5leHRlbmQgPSBmdW5jdGlvbihuYW1lc3BhY2UsIG9wdFByb3BzKSB7XG4gIGlmIChuYW1lc3BhY2UgIT09IE5hbWVzcGFjZS5wcm90b3R5cGUgJiYgIShuYW1lc3BhY2UgaW5zdGFuY2VvZiBOYW1lc3BhY2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgTmFtZXNwYWNlIG9iamVjdDogJyArIG5hbWVzcGFjZSk7XG4gIH1cbiAgY29uc3QgbnMgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogTmFtZXNwYWNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBleHRlbmQobnMsIG9wdFByb3BzKTtcbn07XG5cbi8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGEgcmVndWxhciBtZXRob2Q/XG5OYW1lc3BhY2UudG9TdHJpbmcgPSBmdW5jdGlvbihucykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5zKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5hbWVzcGFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIFBvc0luZm8oKSB7XG4gIHRoaXMuYXBwbGljYXRpb25NZW1vS2V5U3RhY2sgPSBbXTsgLy8gYWN0aXZlIGFwcGxpY2F0aW9ucyBhdCB0aGlzIHBvc2l0aW9uXG4gIHRoaXMubWVtbyA9IHt9O1xuICB0aGlzLm1heEV4YW1pbmVkTGVuZ3RoID0gMDtcbiAgdGhpcy5tYXhSaWdodG1vc3RGYWlsdXJlT2Zmc2V0ID0gLTE7XG4gIHRoaXMuY3VycmVudExlZnRSZWN1cnNpb24gPSB1bmRlZmluZWQ7XG59XG5cblBvc0luZm8ucHJvdG90eXBlID0ge1xuICBpc0FjdGl2ZShhcHBsaWNhdGlvbikge1xuICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLmluZGV4T2YoYXBwbGljYXRpb24udG9NZW1vS2V5KCkpID49IDA7XG4gIH0sXG5cbiAgZW50ZXIoYXBwbGljYXRpb24pIHtcbiAgICB0aGlzLmFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLnB1c2goYXBwbGljYXRpb24udG9NZW1vS2V5KCkpO1xuICB9LFxuXG4gIGV4aXQoKSB7XG4gICAgdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5wb3AoKTtcbiAgfSxcblxuICBzdGFydExlZnRSZWN1cnNpb24oaGVhZEFwcGxpY2F0aW9uLCBtZW1vUmVjKSB7XG4gICAgbWVtb1JlYy5pc0xlZnRSZWN1cnNpb24gPSB0cnVlO1xuICAgIG1lbW9SZWMuaGVhZEFwcGxpY2F0aW9uID0gaGVhZEFwcGxpY2F0aW9uO1xuICAgIG1lbW9SZWMubmV4dExlZnRSZWN1cnNpb24gPSB0aGlzLmN1cnJlbnRMZWZ0UmVjdXJzaW9uO1xuICAgIHRoaXMuY3VycmVudExlZnRSZWN1cnNpb24gPSBtZW1vUmVjO1xuXG4gICAgY29uc3QgYXBwbGljYXRpb25NZW1vS2V5U3RhY2sgPSB0aGlzLmFwcGxpY2F0aW9uTWVtb0tleVN0YWNrO1xuICAgIGNvbnN0IGluZGV4T2ZGaXJzdEludm9sdmVkUnVsZSA9XG4gICAgICAgIGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrLmluZGV4T2YoaGVhZEFwcGxpY2F0aW9uLnRvTWVtb0tleSgpKSArIDE7XG4gICAgY29uc3QgaW52b2x2ZWRBcHBsaWNhdGlvbk1lbW9LZXlzID0gYXBwbGljYXRpb25NZW1vS2V5U3RhY2suc2xpY2UoaW5kZXhPZkZpcnN0SW52b2x2ZWRSdWxlKTtcblxuICAgIG1lbW9SZWMuaXNJbnZvbHZlZCA9IGZ1bmN0aW9uKGFwcGxpY2F0aW9uTWVtb0tleSkge1xuICAgICAgcmV0dXJuIGludm9sdmVkQXBwbGljYXRpb25NZW1vS2V5cy5pbmRleE9mKGFwcGxpY2F0aW9uTWVtb0tleSkgPj0gMDtcbiAgICB9O1xuXG4gICAgbWVtb1JlYy51cGRhdGVJbnZvbHZlZEFwcGxpY2F0aW9uTWVtb0tleXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAobGV0IGlkeCA9IGluZGV4T2ZGaXJzdEludm9sdmVkUnVsZTsgaWR4IDwgYXBwbGljYXRpb25NZW1vS2V5U3RhY2subGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBhcHBsaWNhdGlvbk1lbW9LZXkgPSBhcHBsaWNhdGlvbk1lbW9LZXlTdGFja1tpZHhdO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbnZvbHZlZChhcHBsaWNhdGlvbk1lbW9LZXkpKSB7XG4gICAgICAgICAgaW52b2x2ZWRBcHBsaWNhdGlvbk1lbW9LZXlzLnB1c2goYXBwbGljYXRpb25NZW1vS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgZW5kTGVmdFJlY3Vyc2lvbigpIHtcbiAgICB0aGlzLmN1cnJlbnRMZWZ0UmVjdXJzaW9uID0gdGhpcy5jdXJyZW50TGVmdFJlY3Vyc2lvbi5uZXh0TGVmdFJlY3Vyc2lvbjtcbiAgfSxcblxuICAvLyBOb3RlOiB0aGlzIG1ldGhvZCBkb2Vzbid0IGdldCBjYWxsZWQgZm9yIHRoZSBcImhlYWRcIiBvZiBhIGxlZnQgcmVjdXJzaW9uIC0tIGZvciBMUiBoZWFkcyxcbiAgLy8gdGhlIG1lbW9pemVkIHJlc3VsdCAod2hpY2ggc3RhcnRzIG91dCBiZWluZyBhIGZhaWx1cmUpIGlzIGFsd2F5cyB1c2VkLlxuICBzaG91bGRVc2VNZW1vaXplZFJlc3VsdChtZW1vUmVjKSB7XG4gICAgaWYgKCFtZW1vUmVjLmlzTGVmdFJlY3Vyc2lvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFwcGxpY2F0aW9uTWVtb0tleVN0YWNrID0gdGhpcy5hcHBsaWNhdGlvbk1lbW9LZXlTdGFjaztcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcHBsaWNhdGlvbk1lbW9LZXlTdGFjay5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBhcHBsaWNhdGlvbk1lbW9LZXkgPSBhcHBsaWNhdGlvbk1lbW9LZXlTdGFja1tpZHhdO1xuICAgICAgaWYgKG1lbW9SZWMuaXNJbnZvbHZlZChhcHBsaWNhdGlvbk1lbW9LZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgbWVtb2l6ZShtZW1vS2V5LCBtZW1vUmVjKSB7XG4gICAgdGhpcy5tZW1vW21lbW9LZXldID0gbWVtb1JlYztcbiAgICB0aGlzLm1heEV4YW1pbmVkTGVuZ3RoID0gTWF0aC5tYXgodGhpcy5tYXhFeGFtaW5lZExlbmd0aCwgbWVtb1JlYy5leGFtaW5lZExlbmd0aCk7XG4gICAgdGhpcy5tYXhSaWdodG1vc3RGYWlsdXJlT2Zmc2V0ID1cbiAgICAgICAgTWF0aC5tYXgodGhpcy5tYXhSaWdodG1vc3RGYWlsdXJlT2Zmc2V0LCBtZW1vUmVjLnJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQpO1xuICAgIHJldHVybiBtZW1vUmVjO1xuICB9LFxuXG4gIGNsZWFyT2Jzb2xldGVFbnRyaWVzKHBvcywgaW52YWxpZGF0ZWRJZHgpIHtcbiAgICBpZiAocG9zICsgdGhpcy5tYXhFeGFtaW5lZExlbmd0aCA8PSBpbnZhbGlkYXRlZElkeCkge1xuICAgICAgLy8gT3B0aW1pemF0aW9uOiBub25lIG9mIHRoZSBydWxlIGFwcGxpY2F0aW9ucyB0aGF0IHdlcmUgbWVtb2l6ZWQgaGVyZSBleGFtaW5lZCB0aGVcbiAgICAgIC8vIGludGVydmFsIG9mIHRoZSBpbnB1dCB0aGF0IGNoYW5nZWQsIHNvIG5vdGhpbmcgaGFzIHRvIGJlIGludmFsaWRhdGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lbW8gPSB0aGlzLm1lbW87XG4gICAgdGhpcy5tYXhFeGFtaW5lZExlbmd0aCA9IDA7XG4gICAgdGhpcy5tYXhSaWdodG1vc3RGYWlsdXJlT2Zmc2V0ID0gLTE7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMobWVtbykuZm9yRWFjaChrID0+IHtcbiAgICAgIGNvbnN0IG1lbW9SZWMgPSBtZW1vW2tdO1xuICAgICAgaWYgKHBvcyArIG1lbW9SZWMuZXhhbWluZWRMZW5ndGggPiBpbnZhbGlkYXRlZElkeCkge1xuICAgICAgICBkZWxldGUgbWVtb1trXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYubWF4RXhhbWluZWRMZW5ndGggPSBNYXRoLm1heChzZWxmLm1heEV4YW1pbmVkTGVuZ3RoLCBtZW1vUmVjLmV4YW1pbmVkTGVuZ3RoKTtcbiAgICAgICAgc2VsZi5tYXhSaWdodG1vc3RGYWlsdXJlT2Zmc2V0ID1cbiAgICAgICAgICAgIE1hdGgubWF4KHNlbGYubWF4UmlnaHRtb3N0RmFpbHVyZU9mZnNldCwgbWVtb1JlYy5yaWdodG1vc3RGYWlsdXJlT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gUG9zSW5mbztcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IElucHV0U3RyZWFtID0gcmVxdWlyZSgnLi9JbnB1dFN0cmVhbScpO1xuY29uc3QgSXRlcmF0aW9uTm9kZSA9IHJlcXVpcmUoJy4vbm9kZXMnKS5JdGVyYXRpb25Ob2RlO1xuY29uc3QgTWF0Y2hSZXN1bHQgPSByZXF1aXJlKCcuL01hdGNoUmVzdWx0Jyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgc3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGdsb2JhbEFjdGlvblN0YWNrID0gW107XG5sZXQgcHJvdG90eXBlR3JhbW1hcjtcbmxldCBwcm90b3R5cGVHcmFtbWFyU2VtYW50aWNzO1xuXG4vLyBKU09OIGlzIG5vdCBhIHZhbGlkIHN1YnNldCBvZiBKYXZhU2NyaXB0IGJlY2F1c2UgdGhlcmUgYXJlIHR3byBwb3NzaWJsZSBsaW5lIHRlcm1pbmF0b3JzLFxuLy8gVSsyMDI4IChsaW5lIHNlcGFyYXRvcikgYW5kIFUrMjAyOSAocGFyYWdyYXBoIHNlcGFyYXRvcikgdGhhdCBhcmUgYWxsb3dlZCBpbiBKU09OIHN0cmluZ3Ncbi8vIGJ1dCBub3QgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxuLy8ganNvblRvSlMoKSBwcm9wZXJseSBlbmNvZGVzIHRob3NlIHR3byBjaGFyYWN0ZXJzIGluIEpTT04gc28gdGhhdCBpdCBjYW4gc2VhbWxlc3NseSBiZVxuLy8gaW5zZXJ0ZWQgaW50byBKYXZhU2NyaXB0IGNvZGUgKHBsdXMgdGhlIGVuY29kZWQgdmVyc2lvbiBpcyBzdGlsbCB2YWxpZCBKU09OKVxuZnVuY3Rpb24ganNvblRvSlMoc3RyKSB7XG4gIGNvbnN0IG91dHB1dCA9IHN0ci5yZXBsYWNlKC9bXFx1MjAyOFxcdTIwMjldL2csIChjaGFyLCBwb3MsIHN0cikgPT4ge1xuICAgIGNvbnN0IGhleCA9IGNoYXIuY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiAnXFxcXHUnICsgJzAwMDAnLnNsaWNlKGhleC5sZW5ndGgpICsgaGV4O1xuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gV3JhcHBlcnMgLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gV3JhcHBlcnMgZGVjb3JhdGUgQ1NUIG5vZGVzIHdpdGggYWxsIG9mIHRoZSBmdW5jdGlvbmFsaXR5IChpLmUuLCBvcGVyYXRpb25zIGFuZCBhdHRyaWJ1dGVzKVxuLy8gcHJvdmlkZWQgYnkgYSBTZW1hbnRpY3MgKHNlZSBiZWxvdykuIGBXcmFwcGVyYCBpcyB0aGUgYWJzdHJhY3Qgc3VwZXJjbGFzcyBvZiBhbGwgd3JhcHBlcnMuIEFcbi8vIGBXcmFwcGVyYCBtdXN0IGhhdmUgYF9ub2RlYCBhbmQgYF9zZW1hbnRpY3NgIGluc3RhbmNlIHZhcmlhYmxlcywgd2hpY2ggcmVmZXIgdG8gdGhlIENTVCBub2RlIGFuZFxuLy8gU2VtYW50aWNzIChyZXNwLikgZm9yIHdoaWNoIGl0IHdhcyBjcmVhdGVkLCBhbmQgYSBgX2NoaWxkV3JhcHBlcnNgIGluc3RhbmNlIHZhcmlhYmxlIHdoaWNoIGlzXG4vLyB1c2VkIHRvIGNhY2hlIHRoZSB3cmFwcGVyIGluc3RhbmNlcyB0aGF0IGFyZSBjcmVhdGVkIGZvciBpdHMgY2hpbGQgbm9kZXMuIFNldHRpbmcgdGhlc2UgaW5zdGFuY2Vcbi8vIHZhcmlhYmxlcyBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNvbnN0cnVjdG9yIG9mIGVhY2ggU2VtYW50aWNzLXNwZWNpZmljIHN1YmNsYXNzIG9mXG4vLyBgV3JhcHBlcmAuXG5jbGFzcyBXcmFwcGVyIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgc291cmNlSW50ZXJ2YWwsIGJhc2VJbnRlcnZhbCkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlSW50ZXJ2YWw7XG5cbiAgICAvLyBUaGUgaW50ZXJ2YWwgdGhhdCB0aGUgY2hpbGRPZmZzZXRzIG9mIGBub2RlYCBhcmUgcmVsYXRpdmUgdG8uIEl0IHNob3VsZCBiZSB0aGUgc291cmNlXG4gICAgLy8gb2YgdGhlIGNsb3Nlc3QgTm9udGVybWluYWwgbm9kZS5cbiAgICB0aGlzLl9iYXNlSW50ZXJ2YWwgPSBiYXNlSW50ZXJ2YWw7XG5cbiAgICBpZiAobm9kZS5pc05vbnRlcm1pbmFsKCkpIHtcbiAgICAgIGNvbW1vbi5hc3NlcnQoc291cmNlSW50ZXJ2YWwgPT09IGJhc2VJbnRlcnZhbCk7XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkV3JhcHBlcnMgPSBbXTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW3NlbWFudGljcyB3cmFwcGVyIGZvciAnICsgdGhpcy5fbm9kZS5ncmFtbWFyLm5hbWUgKyAnXSc7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyB1c2VkIGJ5IG9obSBlZGl0b3IgdG8gZGlzcGxheSBhIG5vZGUgd3JhcHBlciBhcHByb3ByaWF0ZWx5LlxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxuXG4gIF9mb3JnZXRNZW1vaXplZFJlc3VsdEZvcihhdHRyaWJ1dGVOYW1lKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBtZW1vaXplZCBhdHRyaWJ1dGUgZnJvbSB0aGUgY3N0Tm9kZSBhbmQgYWxsIGl0cyBjaGlsZHJlbi5cbiAgICBkZWxldGUgdGhpcy5fbm9kZVt0aGlzLl9zZW1hbnRpY3MuYXR0cmlidXRlS2V5c1thdHRyaWJ1dGVOYW1lXV07XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNoaWxkLl9mb3JnZXRNZW1vaXplZFJlc3VsdEZvcihhdHRyaWJ1dGVOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHdyYXBwZXIgb2YgdGhlIHNwZWNpZmllZCBjaGlsZCBub2RlLiBDaGlsZCB3cmFwcGVycyBhcmUgY3JlYXRlZCBsYXppbHkgYW5kXG4gIC8vIGNhY2hlZCBpbiB0aGUgcGFyZW50IHdyYXBwZXIncyBgX2NoaWxkV3JhcHBlcnNgIGluc3RhbmNlIHZhcmlhYmxlLlxuICBjaGlsZChpZHgpIHtcbiAgICBpZiAoISgwIDw9IGlkeCAmJiBpZHggPCB0aGlzLl9ub2RlLm51bUNoaWxkcmVuKCkpKSB7XG4gICAgICAvLyBUT0RPOiBDb25zaWRlciB0aHJvd2luZyBhbiBleGNlcHRpb24gaGVyZS5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBjaGlsZFdyYXBwZXIgPSB0aGlzLl9jaGlsZFdyYXBwZXJzW2lkeF07XG4gICAgaWYgKCFjaGlsZFdyYXBwZXIpIHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuX25vZGUuY2hpbGRBdChpZHgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbm9kZS5jaGlsZE9mZnNldHNbaWR4XTtcblxuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5fYmFzZUludGVydmFsLnN1YkludGVydmFsKG9mZnNldCwgY2hpbGROb2RlLm1hdGNoTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGJhc2UgPSBjaGlsZE5vZGUuaXNOb250ZXJtaW5hbCgpID8gc291cmNlIDogdGhpcy5fYmFzZUludGVydmFsO1xuICAgICAgY2hpbGRXcmFwcGVyID0gdGhpcy5fY2hpbGRXcmFwcGVyc1tpZHhdID0gdGhpcy5fc2VtYW50aWNzLndyYXAoY2hpbGROb2RlLCBzb3VyY2UsIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRXcmFwcGVyO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSB3cmFwcGVycyBvZiBhbGwgb2YgdGhlIGNoaWxkcmVuIG9mIHRoZSBub2RlIGFzc29jaWF0ZWRcbiAgLy8gd2l0aCB0aGlzIHdyYXBwZXIuXG4gIF9jaGlsZHJlbigpIHtcbiAgICAvLyBGb3JjZSB0aGUgY3JlYXRpb24gb2YgYWxsIGNoaWxkIHdyYXBwZXJzXG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5fbm9kZS5udW1DaGlsZHJlbigpOyBpZHgrKykge1xuICAgICAgdGhpcy5jaGlsZChpZHgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2hpbGRXcmFwcGVycztcbiAgfVxuXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3cmFwcGVyIGNvcnJlc3BvbmRzIHRvIGFuIGl0ZXJhdGlvblxuICAvLyBleHByZXNzaW9uLCBpLmUuLCBhIEtsZWVuZS0qLCBLbGVlbmUtKywgb3IgYW4gb3B0aW9uYWwuIFJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UuXG4gIGlzSXRlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLmlzSXRlcmF0aW9uKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBpcyBhIHRlcm1pbmFsIG5vZGUsIGBmYWxzZWBcbiAgLy8gb3RoZXJ3aXNlLlxuICBpc1Rlcm1pbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLmlzVGVybWluYWwoKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3cmFwcGVyIGlzIGEgbm9udGVybWluYWwgbm9kZSwgYGZhbHNlYFxuICAvLyBvdGhlcndpc2UuXG4gIGlzTm9udGVybWluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuaXNOb250ZXJtaW5hbCgpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHdyYXBwZXIgaXMgYSBub250ZXJtaW5hbCBub2RlXG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gYSBzeW50YWN0aWMgcnVsZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gIGlzU3ludGFjdGljKCkge1xuICAgIHJldHVybiB0aGlzLmlzTm9udGVybWluYWwoKSAmJiB0aGlzLl9ub2RlLmlzU3ludGFjdGljKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgQ1NUIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JhcHBlciBpcyBhIG5vbnRlcm1pbmFsIG5vZGVcbiAgLy8gY29ycmVzcG9uZGluZyB0byBhIGxleGljYWwgcnVsZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gIGlzTGV4aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vbnRlcm1pbmFsKCkgJiYgdGhpcy5fbm9kZS5pc0xleGljYWwoKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBDU1Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3cmFwcGVyIGlzIGFuIGl0ZXJhdG9yIG5vZGVcbiAgLy8gaGF2aW5nIGVpdGhlciBvbmUgb3Igbm8gY2hpbGQgKD8gb3BlcmF0b3IpLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8gT3RoZXJ3aXNlLCB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICBpc09wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLmlzT3B0aW9uYWwoKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBfaXRlciB3cmFwcGVyIGluIHRoZSBzYW1lIHNlbWFudGljcyBhcyB0aGlzIHdyYXBwZXIuXG4gIGl0ZXJhdGlvbihvcHRDaGlsZFdyYXBwZXJzKSB7XG4gICAgY29uc3QgY2hpbGRXcmFwcGVycyA9IG9wdENoaWxkV3JhcHBlcnMgfHwgW107XG5cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gY2hpbGRXcmFwcGVycy5tYXAoYyA9PiBjLl9ub2RlKTtcbiAgICBjb25zdCBpdGVyID0gbmV3IEl0ZXJhdGlvbk5vZGUodGhpcy5fbm9kZS5ncmFtbWFyLCBjaGlsZE5vZGVzLCBbXSwgLTEsIGZhbHNlKTtcblxuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLl9zZW1hbnRpY3Mud3JhcChpdGVyLCBudWxsLCBudWxsKTtcbiAgICB3cmFwcGVyLl9jaGlsZFdyYXBwZXJzID0gY2hpbGRXcmFwcGVycztcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgY2hpbGRyZW4gb2YgdGhpcyBDU1Qgbm9kZS5cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbigpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgbmFtZSBvZiBncmFtbWFyIHJ1bGUgdGhhdCBjcmVhdGVkIHRoaXMgQ1NUIG5vZGUuXG4gIGdldCBjdG9yTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5jdG9yTmFtZTtcbiAgfVxuXG4gIC8vIFRPRE86IFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkgKGRlcHJlY2F0ZWQgaW4gdjAuMTIpLlxuICBnZXQgaW50ZXJ2YWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGludGVydmFsYCBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIC0tIHVzZSBgc291cmNlYCBpbnN0ZWFkJyk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gb2YgdGhpcyBDU1Qgbm9kZS5cbiAgZ2V0IG51bUNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLm51bUNoaWxkcmVuKCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBwcmltaXRpdmUgdmFsdWUgb2YgdGhpcyBDU1Qgbm9kZSwgaWYgaXQncyBhIHRlcm1pbmFsIG5vZGUuIE90aGVyd2lzZSxcbiAgLy8gdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgZ2V0IHByaW1pdGl2ZVZhbHVlKCkge1xuICAgIGlmICh0aGlzLmlzVGVybWluYWwoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX25vZGUucHJpbWl0aXZlVmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwidHJpZWQgdG8gYWNjZXNzIHRoZSAncHJpbWl0aXZlVmFsdWUnIGF0dHJpYnV0ZSBvZiBhIG5vbi10ZXJtaW5hbCBDU1Qgbm9kZVwiKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBpbnB1dCBzdHJlYW0gY29uc3VtZWQgYnkgdGhpcyBDU1Qgbm9kZS5cbiAgZ2V0IHNvdXJjZVN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UuY29udGVudHM7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gU2VtYW50aWNzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEEgU2VtYW50aWNzIGlzIGEgY29udGFpbmVyIGZvciBhIGZhbWlseSBvZiBPcGVyYXRpb25zIGFuZCBBdHRyaWJ1dGVzIGZvciBhIGdpdmVuIGdyYW1tYXIuXG4vLyBTZW1hbnRpY3MgZW5hYmxlIG1vZHVsYXJpdHkgKGRpZmZlcmVudCBjbGllbnRzIG9mIGEgZ3JhbW1hciBjYW4gY3JlYXRlIHRoZWlyIHNldCBvZiBvcGVyYXRpb25zXG4vLyBhbmQgYXR0cmlidXRlcyBpbiBpc29sYXRpb24pIGFuZCBleHRlbnNpYmlsaXR5IGV2ZW4gd2hlbiBvcGVyYXRpb25zIGFuZCBhdHRyaWJ1dGVzIGFyZSBtdXR1YWxseS1cbi8vIHJlY3Vyc2l2ZS4gVGhpcyBjb25zdHJ1Y3RvciBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSBleGNlcHQgZnJvbVxuLy8gYFNlbWFudGljcy5jcmVhdGVTZW1hbnRpY3NgLiBUaGUgbm9ybWFsIHdheXMgdG8gY3JlYXRlIGEgU2VtYW50aWNzLCBnaXZlbiBhIGdyYW1tYXIgJ2cnLCBhcmVcbi8vIGBnLmNyZWF0ZVNlbWFudGljcygpYCBhbmQgYGcuZXh0ZW5kU2VtYW50aWNzKHBhcmVudFNlbWFudGljcylgLlxuZnVuY3Rpb24gU2VtYW50aWNzKGdyYW1tYXIsIHN1cGVyU2VtYW50aWNzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuICB0aGlzLmNoZWNrZWRBY3Rpb25EaWN0cyA9IGZhbHNlO1xuXG4gIC8vIENvbnN0cnVjdG9yIGZvciB3cmFwcGVyIGluc3RhbmNlcywgd2hpY2ggYXJlIHBhc3NlZCBhcyB0aGUgYXJndW1lbnRzIHRvIHRoZSBzZW1hbnRpYyBhY3Rpb25zXG4gIC8vIG9mIGFuIG9wZXJhdGlvbiBvciBhdHRyaWJ1dGUuIE9wZXJhdGlvbnMgYW5kIGF0dHJpYnV0ZXMgcmVxdWlyZSBkb3VibGUgZGlzcGF0Y2g6IHRoZSBzZW1hbnRpY1xuICAvLyBhY3Rpb24gaXMgY2hvc2VuIGJhc2VkIG9uIGJvdGggdGhlIG5vZGUncyB0eXBlIGFuZCB0aGUgc2VtYW50aWNzLiBXcmFwcGVycyBlbnN1cmUgdGhhdFxuICAvLyB0aGUgYGV4ZWN1dGVgIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCB0aGUgY29ycmVjdCAobW9zdCBzcGVjaWZpYykgc2VtYW50aWNzIG9iamVjdCBhcyBhblxuICAvLyBhcmd1bWVudC5cbiAgdGhpcy5XcmFwcGVyID0gY2xhc3MgZXh0ZW5kcyAoc3VwZXJTZW1hbnRpY3MgPyBzdXBlclNlbWFudGljcy5XcmFwcGVyIDogV3JhcHBlcikge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHNvdXJjZUludGVydmFsLCBiYXNlSW50ZXJ2YWwpIHtcbiAgICAgIHN1cGVyKG5vZGUsIHNvdXJjZUludGVydmFsLCBiYXNlSW50ZXJ2YWwpO1xuICAgICAgc2VsZi5jaGVja0FjdGlvbkRpY3RzSWZIYXZlbnRBbHJlYWR5KCk7XG4gICAgICB0aGlzLl9zZW1hbnRpY3MgPSBzZWxmO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnN1cGVyID0gc3VwZXJTZW1hbnRpY3M7XG4gIGlmIChzdXBlclNlbWFudGljcykge1xuICAgIGlmICghKGdyYW1tYXIuZXF1YWxzKHRoaXMuc3VwZXIuZ3JhbW1hcikgfHwgZ3JhbW1hci5faW5oZXJpdHNGcm9tKHRoaXMuc3VwZXIuZ3JhbW1hcikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3QgZXh0ZW5kIGEgc2VtYW50aWNzIGZvciBncmFtbWFyICdcIiArIHRoaXMuc3VwZXIuZ3JhbW1hci5uYW1lICtcbiAgICAgICAgICBcIicgZm9yIHVzZSB3aXRoIGdyYW1tYXIgJ1wiICsgZ3JhbW1hci5uYW1lICsgXCInIChub3QgYSBzdWItZ3JhbW1hcilcIik7XG4gICAgfVxuICAgIHRoaXMub3BlcmF0aW9ucyA9IE9iamVjdC5jcmVhdGUodGhpcy5zdXBlci5vcGVyYXRpb25zKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKHRoaXMuc3VwZXIuYXR0cmlidXRlcyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIEFzc2lnbiB1bmlxdWUgc3ltYm9scyBmb3IgZWFjaCBvZiB0aGUgYXR0cmlidXRlcyBpbmhlcml0ZWQgZnJvbSB0aGUgc3VwZXItc2VtYW50aWNzIHNvIHRoYXRcbiAgICAvLyB0aGV5IGFyZSBtZW1vaXplZCBpbmRlcGVuZGVudGx5LlxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmF0dHJpYnV0ZUtleXMsIGF0dHJpYnV0ZU5hbWUsIHtcbiAgICAgICAgdmFsdWU6IHV0aWwudW5pcXVlSWQoYXR0cmlidXRlTmFtZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxufVxuXG5TZW1hbnRpY3MucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnW3NlbWFudGljcyBmb3IgJyArIHRoaXMuZ3JhbW1hci5uYW1lICsgJ10nO1xufTtcblxuU2VtYW50aWNzLnByb3RvdHlwZS5jaGVja0FjdGlvbkRpY3RzSWZIYXZlbnRBbHJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jaGVja2VkQWN0aW9uRGljdHMpIHtcbiAgICB0aGlzLmNoZWNrQWN0aW9uRGljdHMoKTtcbiAgICB0aGlzLmNoZWNrZWRBY3Rpb25EaWN0cyA9IHRydWU7XG4gIH1cbn07XG5cbi8vIENoZWNrcyB0aGF0IHRoZSBhY3Rpb24gZGljdGlvbmFyaWVzIGZvciBhbGwgb3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcyBpbiB0aGlzIHNlbWFudGljcyxcbi8vIGluY2x1ZGluZyB0aGUgb25lcyB0aGF0IHdlcmUgaW5oZXJpdGVkIGZyb20gdGhlIHN1cGVyLXNlbWFudGljcywgYWdyZWUgd2l0aCB0aGUgZ3JhbW1hci5cbi8vIFRocm93cyBhbiBleGNlcHRpb24gaWYgb25lIG9yIG1vcmUgb2YgdGhlbSBkb2Vzbid0LlxuU2VtYW50aWNzLnByb3RvdHlwZS5jaGVja0FjdGlvbkRpY3RzID0gZnVuY3Rpb24oKSB7XG4gIGxldCBuYW1lO1xuICBmb3IgKG5hbWUgaW4gdGhpcy5vcGVyYXRpb25zKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zW25hbWVdLmNoZWNrQWN0aW9uRGljdCh0aGlzLmdyYW1tYXIpO1xuICB9XG4gIGZvciAobmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0uY2hlY2tBY3Rpb25EaWN0KHRoaXMuZ3JhbW1hcik7XG4gIH1cbn07XG5cblNlbWFudGljcy5wcm90b3R5cGUudG9SZWNpcGUgPSBmdW5jdGlvbihzZW1hbnRpY3NPbmx5KSB7XG4gIGZ1bmN0aW9uIGhhc1N1cGVyU2VtYW50aWNzKHMpIHtcbiAgICByZXR1cm4gcy5zdXBlciAhPT0gU2VtYW50aWNzLkJ1aWx0SW5TZW1hbnRpY3MuX2dldFNlbWFudGljcygpO1xuICB9XG5cbiAgbGV0IHN0ciA9ICcoZnVuY3Rpb24oZykge1xcbic7XG4gIGlmIChoYXNTdXBlclNlbWFudGljcyh0aGlzKSkge1xuICAgIHN0ciArPSAnICB2YXIgc2VtYW50aWNzID0gJyArIHRoaXMuc3VwZXIudG9SZWNpcGUodHJ1ZSkgKyAnKGcnO1xuXG4gICAgY29uc3Qgc3VwZXJTZW1hbnRpY3NHcmFtbWFyID0gdGhpcy5zdXBlci5ncmFtbWFyO1xuICAgIGxldCByZWxhdGVkR3JhbW1hciA9IHRoaXMuZ3JhbW1hcjtcbiAgICB3aGlsZSAocmVsYXRlZEdyYW1tYXIgIT09IHN1cGVyU2VtYW50aWNzR3JhbW1hcikge1xuICAgICAgc3RyICs9ICcuc3VwZXJHcmFtbWFyJztcbiAgICAgIHJlbGF0ZWRHcmFtbWFyID0gcmVsYXRlZEdyYW1tYXIuc3VwZXJHcmFtbWFyO1xuICAgIH1cblxuICAgIHN0ciArPSAnKTtcXG4nO1xuICAgIHN0ciArPSAnICByZXR1cm4gZy5leHRlbmRTZW1hbnRpY3Moc2VtYW50aWNzKSc7XG4gIH0gZWxzZSB7XG4gICAgc3RyICs9ICcgIHJldHVybiBnLmNyZWF0ZVNlbWFudGljcygpJztcbiAgfVxuICBbJ09wZXJhdGlvbicsICdBdHRyaWJ1dGUnXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIGNvbnN0IHNlbWFudGljT3BlcmF0aW9ucyA9IHRoaXNbdHlwZS50b0xvd2VyQ2FzZSgpICsgJ3MnXTtcbiAgICBPYmplY3Qua2V5cyhzZW1hbnRpY09wZXJhdGlvbnMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBjb25zdCB7YWN0aW9uRGljdCwgZm9ybWFscywgYnVpbHRJbkRlZmF1bHR9ID0gc2VtYW50aWNPcGVyYXRpb25zW25hbWVdO1xuXG4gICAgICBsZXQgc2lnbmF0dXJlID0gbmFtZTtcbiAgICAgIGlmIChmb3JtYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2lnbmF0dXJlICs9ICcoJyArIGZvcm1hbHMuam9pbignLCAnKSArICcpJztcbiAgICAgIH1cblxuICAgICAgbGV0IG1ldGhvZDtcbiAgICAgIGlmIChoYXNTdXBlclNlbWFudGljcyh0aGlzKSAmJiB0aGlzLnN1cGVyW3R5cGUudG9Mb3dlckNhc2UoKSArICdzJ11bbmFtZV0pIHtcbiAgICAgICAgbWV0aG9kID0gJ2V4dGVuZCcgKyB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0aG9kID0gJ2FkZCcgKyB0eXBlO1xuICAgICAgfVxuICAgICAgc3RyICs9ICdcXG4gICAgLicgKyBtZXRob2QgKyAnKCcgKyBKU09OLnN0cmluZ2lmeShzaWduYXR1cmUpICsgJywgeyc7XG5cbiAgICAgIGNvbnN0IHNyY0FycmF5ID0gW107XG4gICAgICBPYmplY3Qua2V5cyhhY3Rpb25EaWN0KS5mb3JFYWNoKGFjdGlvbk5hbWUgPT4ge1xuICAgICAgICBpZiAoYWN0aW9uRGljdFthY3Rpb25OYW1lXSAhPT0gYnVpbHRJbkRlZmF1bHQpIHtcbiAgICAgICAgICBsZXQgc291cmNlID0gYWN0aW9uRGljdFthY3Rpb25OYW1lXS50b1N0cmluZygpLnRyaW0oKTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgbWV0aG9kIHNob3J0aGFuZCB0byBwbGFpbiBvbGQgZnVuY3Rpb24gc3ludGF4LlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oYXJjL29obS9pc3N1ZXMvMjYzXG4gICAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoL14uKlxcKC8sICdmdW5jdGlvbignKTtcblxuICAgICAgICAgIHNyY0FycmF5LnB1c2goJ1xcbiAgICAgICcgKyBKU09OLnN0cmluZ2lmeShhY3Rpb25OYW1lKSArICc6ICcgKyBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN0ciArPSBzcmNBcnJheS5qb2luKCcsJykgKyAnXFxuICAgIH0pJztcbiAgICB9KTtcbiAgfSk7XG4gIHN0ciArPSAnO1xcbiAgfSknO1xuXG4gIGlmICghc2VtYW50aWNzT25seSkge1xuICAgIHN0ciA9XG4gICAgICAnKGZ1bmN0aW9uKCkge1xcbicgK1xuICAgICAgJyAgdmFyIGdyYW1tYXIgPSB0aGlzLmZyb21SZWNpcGUoJyArIGpzb25Ub0pTKHRoaXMuZ3JhbW1hci50b1JlY2lwZSgpKSArICcpO1xcbicgK1xuICAgICAgJyAgdmFyIHNlbWFudGljcyA9ICcgKyBzdHIgKyAnKGdyYW1tYXIpO1xcbicgK1xuICAgICAgJyAgcmV0dXJuIHNlbWFudGljcztcXG4nICtcbiAgICAgICd9KTtcXG4nO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSwgdHlwZSkge1xuICBpZiAoIXByb3RvdHlwZUdyYW1tYXIpIHtcbiAgICAvLyBUaGUgT3BlcmF0aW9ucyBhbmQgQXR0cmlidXRlcyBncmFtbWFyIHdvbid0IGJlIGF2YWlsYWJsZSB3aGlsZSBPaG0gaXMgbG9hZGluZyxcbiAgICAvLyBidXQgd2UgY2FuIGdldCBhd2F5IHRoZSBmb2xsb3dpbmcgc2ltcGxpZmljYXRpb24gYi9jIG5vbmUgb2YgdGhlIG9wZXJhdGlvbnNcbiAgICAvLyB0aGF0IGFyZSB1c2VkIHdoaWxlIGxvYWRpbmcgdGFrZSBhcmd1bWVudHMuXG4gICAgY29tbW9uLmFzc2VydChzaWduYXR1cmUuaW5kZXhPZignKCcpID09PSAtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHNpZ25hdHVyZSxcbiAgICAgIGZvcm1hbHM6IFtdXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHIgPSBwcm90b3R5cGVHcmFtbWFyLm1hdGNoKFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgdHlwZSA9PT0gJ29wZXJhdGlvbicgPyAnT3BlcmF0aW9uU2lnbmF0dXJlJyA6ICdBdHRyaWJ1dGVTaWduYXR1cmUnKTtcbiAgaWYgKHIuZmFpbGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Ioci5tZXNzYWdlKTtcbiAgfVxuXG4gIHJldHVybiBwcm90b3R5cGVHcmFtbWFyU2VtYW50aWNzKHIpLnBhcnNlKCk7XG59XG5cbmZ1bmN0aW9uIG5ld0RlZmF1bHRBY3Rpb24odHlwZSwgbmFtZSwgZG9JdCkge1xuICByZXR1cm4gZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB0aGlzVGhpbmcgPSB0aGlzLl9zZW1hbnRpY3Mub3BlcmF0aW9uc1tuYW1lXSB8fCB0aGlzLl9zZW1hbnRpY3MuYXR0cmlidXRlc1tuYW1lXTtcbiAgICBjb25zdCBhcmdzID0gdGhpc1RoaW5nLmZvcm1hbHMubWFwKGZvcm1hbCA9PiBzZWxmLmFyZ3NbZm9ybWFsXSk7XG5cbiAgICBpZiAodGhpcy5pc0l0ZXJhdGlvbigpKSB7XG4gICAgICAvLyBUaGlzIENTVCBub2RlIGNvcnJlc3BvbmRzIHRvIGFuIGl0ZXJhdGlvbiBleHByZXNzaW9uIGluIHRoZSBncmFtbWFyICgqLCArLCBvciA/KS4gVGhlXG4gICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIG1hcCB0aGlzIG9wZXJhdGlvbiBvciBhdHRyaWJ1dGUgb3ZlciBhbGwgb2YgaXRzIGNoaWxkIG5vZGVzLlxuICAgICAgcmV0dXJuIGNoaWxkcmVuLm1hcChjaGlsZCA9PiBkb0l0LmFwcGx5KGNoaWxkLCBhcmdzKSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBDU1Qgbm9kZSBjb3JyZXNwb25kcyB0byBhIG5vbi10ZXJtaW5hbCBpbiB0aGUgZ3JhbW1hciAoZS5nLiwgQWRkRXhwcikuIFRoZSBmYWN0IHRoYXRcbiAgICAvLyB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoaXMgYWN0aW9uIGRpY3Rpb25hcnkgZG9lc24ndCBoYXZlIGFuIGFjdGlvbiBmb3IgdGhpcyBwYXJ0aWN1bGFyXG4gICAgLy8gbm9uLXRlcm1pbmFsIG9yIGEgZ2VuZXJpYyBgX25vbnRlcm1pbmFsYCBhY3Rpb24uXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQXMgYSBjb252ZW5pZW5jZSwgaWYgdGhpcyBub2RlIG9ubHkgaGFzIG9uZSBjaGlsZCwgd2UganVzdCByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICAgICAgLy8gYXBwbHlpbmcgdGhpcyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUgdG8gdGhlIGNoaWxkIG5vZGUuXG4gICAgICByZXR1cm4gZG9JdC5hcHBseShjaGlsZHJlblswXSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgd2UgdGhyb3cgYW4gZXhjZXB0aW9uIHRvIGxldCB0aGUgcHJvZ3JhbW1lciBrbm93IHRoYXQgd2UgZG9uJ3Qga25vdyB3aGF0XG4gICAgICAvLyB0byBkbyB3aXRoIHRoaXMgbm9kZS5cbiAgICAgIHRocm93IGVycm9ycy5taXNzaW5nU2VtYW50aWNBY3Rpb24odGhpcy5jdG9yTmFtZSwgbmFtZSwgdHlwZSwgZ2xvYmFsQWN0aW9uU3RhY2spO1xuICAgIH1cbiAgfTtcbn1cblxuU2VtYW50aWNzLnByb3RvdHlwZS5hZGRPcGVyYXRpb25PckF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHR5cGUsIHNpZ25hdHVyZSwgYWN0aW9uRGljdCkge1xuICBjb25zdCB0eXBlUGx1cmFsID0gdHlwZSArICdzJztcblxuICBjb25zdCBwYXJzZWROYW1lQW5kRm9ybWFsQXJncyA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSwgdHlwZSk7XG4gIGNvbnN0IG5hbWUgPSBwYXJzZWROYW1lQW5kRm9ybWFsQXJncy5uYW1lO1xuICBjb25zdCBmb3JtYWxzID0gcGFyc2VkTmFtZUFuZEZvcm1hbEFyZ3MuZm9ybWFscztcblxuICAvLyBUT0RPOiBjaGVjayB0aGF0IHRoZXJlIGFyZSBubyBkdXBsaWNhdGUgZm9ybWFsIGFyZ3VtZW50c1xuXG4gIHRoaXMuYXNzZXJ0TmV3TmFtZShuYW1lLCB0eXBlKTtcblxuICAvLyBDcmVhdGUgdGhlIGFjdGlvbiBkaWN0aW9uYXJ5IGZvciB0aGlzIG9wZXJhdGlvbiAvIGF0dHJpYnV0ZSB0aGF0IGNvbnRhaW5zIGEgYF9kZWZhdWx0YCBhY3Rpb25cbiAgLy8gd2hpY2ggZGVmaW5lcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBpdGVyYXRpb24sIHRlcm1pbmFsLCBhbmQgbm9uLXRlcm1pbmFsIG5vZGVzLi4uXG4gIGNvbnN0IGJ1aWx0SW5EZWZhdWx0ID0gbmV3RGVmYXVsdEFjdGlvbih0eXBlLCBuYW1lLCBkb0l0KTtcbiAgY29uc3QgcmVhbEFjdGlvbkRpY3QgPSB7X2RlZmF1bHQ6IGJ1aWx0SW5EZWZhdWx0fTtcbiAgLy8gLi4uIGFuZCBhZGQgaW4gdGhlIGFjdGlvbnMgc3VwcGxpZWQgYnkgdGhlIHByb2dyYW1tZXIsIHdoaWNoIG1heSBvdmVycmlkZSBzb21lIG9yIGFsbCBvZiB0aGVcbiAgLy8gZGVmYXVsdCBvbmVzLlxuICBPYmplY3Qua2V5cyhhY3Rpb25EaWN0KS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIHJlYWxBY3Rpb25EaWN0W25hbWVdID0gYWN0aW9uRGljdFtuYW1lXTtcbiAgfSk7XG5cbiAgY29uc3QgZW50cnkgPSB0eXBlID09PSAnb3BlcmF0aW9uJyA/XG4gICAgICBuZXcgT3BlcmF0aW9uKG5hbWUsIGZvcm1hbHMsIHJlYWxBY3Rpb25EaWN0LCBidWlsdEluRGVmYXVsdCkgOlxuICAgICAgbmV3IEF0dHJpYnV0ZShuYW1lLCByZWFsQWN0aW9uRGljdCwgYnVpbHRJbkRlZmF1bHQpO1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgaXMgbm90IHN0cmljdGx5IG5lY2Vzc2FyeSAoaXQgd2lsbCBoYXBwZW4gbGF0ZXIgYW55d2F5KSBidXQgaXQncyBiZXR0ZXIgdG9cbiAgLy8gY2F0Y2ggZXJyb3JzIGVhcmx5LlxuICBlbnRyeS5jaGVja0FjdGlvbkRpY3QodGhpcy5ncmFtbWFyKTtcblxuICB0aGlzW3R5cGVQbHVyYWxdW25hbWVdID0gZW50cnk7XG5cbiAgZnVuY3Rpb24gZG9JdCgpIHtcbiAgICAvLyBEaXNwYXRjaCB0byBtb3N0IHNwZWNpZmljIHZlcnNpb24gb2YgdGhpcyBvcGVyYXRpb24gLyBhdHRyaWJ1dGUgLS0gaXQgbWF5IGhhdmUgYmVlblxuICAgIC8vIG92ZXJyaWRkZW4gYnkgYSBzdWItc2VtYW50aWNzLlxuICAgIGNvbnN0IHRoaXNUaGluZyA9IHRoaXMuX3NlbWFudGljc1t0eXBlUGx1cmFsXVtuYW1lXTtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGNhbGxlciBwYXNzZWQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gdGhpc1RoaW5nLmZvcm1hbHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gJyArIG5hbWUgKyAnICcgKyB0eXBlICsgJyAoZXhwZWN0ZWQgJyArXG4gICAgICAgICAgdGhpc1RoaW5nLmZvcm1hbHMubGVuZ3RoICsgJywgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyknKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gXCJhcmd1bWVudHMgb2JqZWN0XCIgZnJvbSB0aGUgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhpc1xuICAgIC8vIG9wZXJhdGlvbiAvIGF0dHJpYnV0ZS5cbiAgICBjb25zdCBhcmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhcmd1bWVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29uc3QgZm9ybWFsID0gdGhpc1RoaW5nLmZvcm1hbHNbaWR4XTtcbiAgICAgIGFyZ3NbZm9ybWFsXSA9IGFyZ3VtZW50c1tpZHhdO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZEFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICBjb25zdCBhbnMgPSB0aGlzVGhpbmcuZXhlY3V0ZSh0aGlzLl9zZW1hbnRpY3MsIHRoaXMpO1xuICAgIHRoaXMuYXJncyA9IG9sZEFyZ3M7XG4gICAgcmV0dXJuIGFucztcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnb3BlcmF0aW9uJykge1xuICAgIHRoaXMuV3JhcHBlci5wcm90b3R5cGVbbmFtZV0gPSBkb0l0O1xuICAgIHRoaXMuV3JhcHBlci5wcm90b3R5cGVbbmFtZV0udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnWycgKyBuYW1lICsgJyBvcGVyYXRpb25dJztcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLldyYXBwZXIucHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICBnZXQ6IGRvSXQsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUgLy8gU28gdGhlIHByb3BlcnR5IGNhbiBiZSBkZWxldGVkLlxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmF0dHJpYnV0ZUtleXMsIG5hbWUsIHtcbiAgICAgIHZhbHVlOiB1dGlsLnVuaXF1ZUlkKG5hbWUpXG4gICAgfSk7XG4gIH1cbn07XG5cblNlbWFudGljcy5wcm90b3R5cGUuZXh0ZW5kT3BlcmF0aW9uT3JBdHRyaWJ1dGUgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBhY3Rpb25EaWN0KSB7XG4gIGNvbnN0IHR5cGVQbHVyYWwgPSB0eXBlICsgJ3MnO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IGBuYW1lYCByZWFsbHkgaXMganVzdCBhIG5hbWUsIGkuZS4sIHRoYXQgaXQgZG9lc24ndCBhbHNvIGNvbnRhaW4gZm9ybWFscy5cbiAgcGFyc2VTaWduYXR1cmUobmFtZSwgJ2F0dHJpYnV0ZScpO1xuXG4gIGlmICghKHRoaXMuc3VwZXIgJiYgbmFtZSBpbiB0aGlzLnN1cGVyW3R5cGVQbHVyYWxdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4dGVuZCAnICsgdHlwZSArIFwiICdcIiArIG5hbWUgK1xuICAgICAgICBcIic6IGRpZCBub3QgaW5oZXJpdCBhbiBcIiArIHR5cGUgKyAnIHdpdGggdGhhdCBuYW1lJyk7XG4gIH1cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzW3R5cGVQbHVyYWxdLCBuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4dGVuZCAnICsgdHlwZSArIFwiICdcIiArIG5hbWUgKyBcIicgYWdhaW5cIik7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgb3BlcmF0aW9uIC8gYXR0cmlidXRlIHdob3NlIGFjdGlvbkRpY3QgZGVsZWdhdGVzIHRvIHRoZSBzdXBlciBvcGVyYXRpb24gL1xuICAvLyBhdHRyaWJ1dGUncyBhY3Rpb25EaWN0LCBhbmQgd2hpY2ggaGFzIGFsbCB0aGUga2V5cyBmcm9tIGBpbmhlcml0ZWRBY3Rpb25EaWN0YC5cbiAgY29uc3QgaW5oZXJpdGVkRm9ybWFscyA9IHRoaXNbdHlwZVBsdXJhbF1bbmFtZV0uZm9ybWFscztcbiAgY29uc3QgaW5oZXJpdGVkQWN0aW9uRGljdCA9IHRoaXNbdHlwZVBsdXJhbF1bbmFtZV0uYWN0aW9uRGljdDtcbiAgY29uc3QgbmV3QWN0aW9uRGljdCA9IE9iamVjdC5jcmVhdGUoaW5oZXJpdGVkQWN0aW9uRGljdCk7XG4gIE9iamVjdC5rZXlzKGFjdGlvbkRpY3QpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgbmV3QWN0aW9uRGljdFtuYW1lXSA9IGFjdGlvbkRpY3RbbmFtZV07XG4gIH0pO1xuXG4gIHRoaXNbdHlwZVBsdXJhbF1bbmFtZV0gPSB0eXBlID09PSAnb3BlcmF0aW9uJyA/XG4gICAgICBuZXcgT3BlcmF0aW9uKG5hbWUsIGluaGVyaXRlZEZvcm1hbHMsIG5ld0FjdGlvbkRpY3QpIDpcbiAgICAgIG5ldyBBdHRyaWJ1dGUobmFtZSwgbmV3QWN0aW9uRGljdCk7XG5cbiAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBpcyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IChpdCB3aWxsIGhhcHBlbiBsYXRlciBhbnl3YXkpIGJ1dCBpdCdzIGJldHRlciB0b1xuICAvLyBjYXRjaCBlcnJvcnMgZWFybHkuXG4gIHRoaXNbdHlwZVBsdXJhbF1bbmFtZV0uY2hlY2tBY3Rpb25EaWN0KHRoaXMuZ3JhbW1hcik7XG59O1xuXG5TZW1hbnRpY3MucHJvdG90eXBlLmFzc2VydE5ld05hbWUgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gIGlmIChXcmFwcGVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBhZGQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICsgXCInOiB0aGF0J3MgYSByZXNlcnZlZCBuYW1lXCIpO1xuICB9XG4gIGlmIChuYW1lIGluIHRoaXMub3BlcmF0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBhZGQgJyArIHR5cGUgKyBcIiAnXCIgKyBuYW1lICsgXCInOiBhbiBvcGVyYXRpb24gd2l0aCB0aGF0IG5hbWUgYWxyZWFkeSBleGlzdHNcIik7XG4gIH1cbiAgaWYgKG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGFkZCAnICsgdHlwZSArIFwiICdcIiArIG5hbWUgKyBcIic6IGFuIGF0dHJpYnV0ZSB3aXRoIHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgfVxufTtcblxuLy8gUmV0dXJucyBhIHdyYXBwZXIgZm9yIHRoZSBnaXZlbiBDU1QgYG5vZGVgIGluIHRoaXMgc2VtYW50aWNzLlxuLy8gSWYgYG5vZGVgIGlzIGFscmVhZHkgYSB3cmFwcGVyLCByZXR1cm5zIGBub2RlYCBpdHNlbGYuICAvLyBUT0RPOiB3aHkgaXMgdGhpcyBuZWVkZWQ/XG5TZW1hbnRpY3MucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihub2RlLCBzb3VyY2UsIG9wdEJhc2VJbnRlcnZhbCkge1xuICBjb25zdCBiYXNlSW50ZXJ2YWwgPSBvcHRCYXNlSW50ZXJ2YWwgfHwgc291cmNlO1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRoaXMuV3JhcHBlciA/IG5vZGUgOiBuZXcgdGhpcy5XcmFwcGVyKG5vZGUsIHNvdXJjZSwgYmFzZUludGVydmFsKTtcbn07XG5cbi8vIENyZWF0ZXMgYSBuZXcgU2VtYW50aWNzIGluc3RhbmNlIGZvciBgZ3JhbW1hcmAsIGluaGVyaXRpbmcgb3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcyBmcm9tXG4vLyBgb3B0U3VwZXJTZW1hbnRpY3NgLCBpZiBpdCBpcyBzcGVjaWZpZWQuIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXMgYSBwcm94eSBmb3IgdGhlIG5ld1xuLy8gU2VtYW50aWNzIGluc3RhbmNlLiBXaGVuIHRoYXQgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIGEgQ1NUIG5vZGUgYXMgYW4gYXJndW1lbnQsIGl0IHJldHVybnNcbi8vIGEgd3JhcHBlciBmb3IgdGhhdCBub2RlIHdoaWNoIGdpdmVzIGFjY2VzcyB0byB0aGUgb3BlcmF0aW9ucyBhbmQgYXR0cmlidXRlcyBwcm92aWRlZCBieSB0aGlzXG4vLyBzZW1hbnRpY3MuXG5TZW1hbnRpY3MuY3JlYXRlU2VtYW50aWNzID0gZnVuY3Rpb24oZ3JhbW1hciwgb3B0U3VwZXJTZW1hbnRpY3MpIHtcbiAgY29uc3QgcyA9IG5ldyBTZW1hbnRpY3MoXG4gICAgICBncmFtbWFyLFxuICAgICAgb3B0U3VwZXJTZW1hbnRpY3MgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgb3B0U3VwZXJTZW1hbnRpY3MgOlxuICAgICAgICAgIFNlbWFudGljcy5CdWlsdEluU2VtYW50aWNzLl9nZXRTZW1hbnRpY3MoKSk7XG5cbiAgLy8gVG8gZW5hYmxlIGNsaWVudHMgdG8gaW52b2tlIGEgc2VtYW50aWNzIGxpa2UgYSBmdW5jdGlvbiwgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhY3RzIGFzIGEgcHJveHlcbiAgLy8gZm9yIGBzYCwgd2hpY2ggaXMgdGhlIHJlYWwgYFNlbWFudGljc2AgaW5zdGFuY2UuXG4gIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gQVNlbWFudGljcyhtYXRjaFJlc3VsdCkge1xuICAgIGlmICghKG1hdGNoUmVzdWx0IGluc3RhbmNlb2YgTWF0Y2hSZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdTZW1hbnRpY3MgZXhwZWN0ZWQgYSBNYXRjaFJlc3VsdCwgYnV0IGdvdCAnICsgY29tbW9uLnVuZXhwZWN0ZWRPYmpUb1N0cmluZyhtYXRjaFJlc3VsdCkpO1xuICAgIH1cbiAgICBpZiAobWF0Y2hSZXN1bHQuZmFpbGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBhcHBseSBTZW1hbnRpY3MgdG8gJyArIG1hdGNoUmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGNzdCA9IG1hdGNoUmVzdWx0Ll9jc3Q7XG4gICAgaWYgKGNzdC5ncmFtbWFyICE9PSBncmFtbWFyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3QgdXNlIGEgTWF0Y2hSZXN1bHQgZnJvbSBncmFtbWFyICdcIiArIGNzdC5ncmFtbWFyLm5hbWUgK1xuICAgICAgICAgIFwiJyB3aXRoIGEgc2VtYW50aWNzIGZvciAnXCIgKyBncmFtbWFyLm5hbWUgKyBcIidcIik7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0U3RyZWFtID0gbmV3IElucHV0U3RyZWFtKG1hdGNoUmVzdWx0LmlucHV0KTtcbiAgICByZXR1cm4gcy53cmFwKGNzdCwgaW5wdXRTdHJlYW0uaW50ZXJ2YWwobWF0Y2hSZXN1bHQuX2NzdE9mZnNldCwgbWF0Y2hSZXN1bHQuaW5wdXQubGVuZ3RoKSk7XG4gIH07XG5cbiAgLy8gRm9yd2FyZCBwdWJsaWMgbWV0aG9kcyBmcm9tIHRoZSBwcm94eSB0byB0aGUgc2VtYW50aWNzIGluc3RhbmNlLlxuICBwcm94eS5hZGRPcGVyYXRpb24gPSBmdW5jdGlvbihzaWduYXR1cmUsIGFjdGlvbkRpY3QpIHtcbiAgICBzLmFkZE9wZXJhdGlvbk9yQXR0cmlidXRlKCdvcGVyYXRpb24nLCBzaWduYXR1cmUsIGFjdGlvbkRpY3QpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcHJveHkuZXh0ZW5kT3BlcmF0aW9uID0gZnVuY3Rpb24obmFtZSwgYWN0aW9uRGljdCkge1xuICAgIHMuZXh0ZW5kT3BlcmF0aW9uT3JBdHRyaWJ1dGUoJ29wZXJhdGlvbicsIG5hbWUsIGFjdGlvbkRpY3QpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcHJveHkuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgYWN0aW9uRGljdCkge1xuICAgIHMuYWRkT3BlcmF0aW9uT3JBdHRyaWJ1dGUoJ2F0dHJpYnV0ZScsIG5hbWUsIGFjdGlvbkRpY3QpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcHJveHkuZXh0ZW5kQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgYWN0aW9uRGljdCkge1xuICAgIHMuZXh0ZW5kT3BlcmF0aW9uT3JBdHRyaWJ1dGUoJ2F0dHJpYnV0ZScsIG5hbWUsIGFjdGlvbkRpY3QpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcHJveHkuX2dldEFjdGlvbkRpY3QgPSBmdW5jdGlvbihvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzLm9wZXJhdGlvbnNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXSB8fCBzLmF0dHJpYnV0ZXNbb3BlcmF0aW9uT3JBdHRyaWJ1dGVOYW1lXTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWUgKyAnXCIgaXMgbm90IGEgdmFsaWQgb3BlcmF0aW9uIG9yIGF0dHJpYnV0ZSAnICtcbiAgICAgICAgJ25hbWUgaW4gdGhpcyBzZW1hbnRpY3MgZm9yIFwiJyArIGdyYW1tYXIubmFtZSArICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uLmFjdGlvbkRpY3Q7XG4gIH07XG4gIHByb3h5Ll9yZW1vdmUgPSBmdW5jdGlvbihvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWUpIHtcbiAgICBsZXQgc2VtYW50aWM7XG4gICAgaWYgKG9wZXJhdGlvbk9yQXR0cmlidXRlTmFtZSBpbiBzLm9wZXJhdGlvbnMpIHtcbiAgICAgIHNlbWFudGljID0gcy5vcGVyYXRpb25zW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV07XG4gICAgICBkZWxldGUgcy5vcGVyYXRpb25zW29wZXJhdGlvbk9yQXR0cmlidXRlTmFtZV07XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWUgaW4gcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBzZW1hbnRpYyA9IHMuYXR0cmlidXRlc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgICAgZGVsZXRlIHMuYXR0cmlidXRlc1tvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgICBkZWxldGUgcy5XcmFwcGVyLnByb3RvdHlwZVtvcGVyYXRpb25PckF0dHJpYnV0ZU5hbWVdO1xuICAgIHJldHVybiBzZW1hbnRpYztcbiAgfTtcbiAgcHJveHkuZ2V0T3BlcmF0aW9uTmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocy5vcGVyYXRpb25zKTtcbiAgfTtcbiAgcHJveHkuZ2V0QXR0cmlidXRlTmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocy5hdHRyaWJ1dGVzKTtcbiAgfTtcbiAgcHJveHkuZ2V0R3JhbW1hciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzLmdyYW1tYXI7XG4gIH07XG4gIHByb3h5LnRvUmVjaXBlID0gZnVuY3Rpb24oc2VtYW50aWNzT25seSkge1xuICAgIHJldHVybiBzLnRvUmVjaXBlKHNlbWFudGljc09ubHkpO1xuICB9O1xuXG4gIC8vIE1ha2UgdGhlIHByb3h5J3MgdG9TdHJpbmcoKSB3b3JrLlxuICBwcm94eS50b1N0cmluZyA9IHMudG9TdHJpbmcuYmluZChzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBzZW1hbnRpY3MgZm9yIHRoZSBwcm94eS5cbiAgcHJveHkuX2dldFNlbWFudGljcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzO1xuICB9O1xuXG4gIHJldHVybiBwcm94eTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIE9wZXJhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBbiBPcGVyYXRpb24gcmVwcmVzZW50cyBhIGZ1bmN0aW9uIHRvIGJlIGFwcGxpZWQgdG8gYSBjb25jcmV0ZSBzeW50YXggdHJlZSAoQ1NUKSAtLSBpdCdzIHZlcnlcbi8vIHNpbWlsYXIgdG8gYSBWaXNpdG9yIChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Zpc2l0b3JfcGF0dGVybikuIEFuIG9wZXJhdGlvbiBpcyBleGVjdXRlZCBieVxuLy8gcmVjdXJzaXZlbHkgd2Fsa2luZyB0aGUgQ1NULCBhbmQgYXQgZWFjaCBub2RlLCBpbnZva2luZyB0aGUgbWF0Y2hpbmcgc2VtYW50aWMgYWN0aW9uIGZyb21cbi8vIGBhY3Rpb25EaWN0YC4gU2VlIGBPcGVyYXRpb24ucHJvdG90eXBlLmV4ZWN1dGVgIGZvciBkZXRhaWxzIG9mIGhvdyBhIENTVCBub2RlJ3MgbWF0Y2hpbmcgc2VtYW50aWNcbi8vIGFjdGlvbiBpcyBmb3VuZC5cbmNsYXNzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGZvcm1hbHMsIGFjdGlvbkRpY3QsIGJ1aWx0SW5EZWZhdWx0KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmZvcm1hbHMgPSBmb3JtYWxzO1xuICAgIHRoaXMuYWN0aW9uRGljdCA9IGFjdGlvbkRpY3Q7XG4gICAgdGhpcy5idWlsdEluRGVmYXVsdCA9IGJ1aWx0SW5EZWZhdWx0O1xuICB9XG5cbiAgY2hlY2tBY3Rpb25EaWN0KGdyYW1tYXIpIHtcbiAgICBncmFtbWFyLl9jaGVja1RvcERvd25BY3Rpb25EaWN0KHRoaXMudHlwZU5hbWUsIHRoaXMubmFtZSwgdGhpcy5hY3Rpb25EaWN0KTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgdGhpcyBvcGVyYXRpb24gb24gdGhlIENTVCBub2RlIGFzc29jaWF0ZWQgd2l0aCBgbm9kZVdyYXBwZXJgIGluIHRoZSBjb250ZXh0IG9mIHRoZVxuICAvLyBnaXZlbiBTZW1hbnRpY3MgaW5zdGFuY2UuXG4gIGV4ZWN1dGUoc2VtYW50aWNzLCBub2RlV3JhcHBlcikge1xuICAgIHRyeSB7XG4gICAgICAvLyBMb29rIGZvciBhIHNlbWFudGljIGFjdGlvbiB3aG9zZSBuYW1lIG1hdGNoZXMgdGhlIG5vZGUncyBjb25zdHJ1Y3RvciBuYW1lLCB3aGljaCBpcyBlaXRoZXJcbiAgICAgIC8vIHRoZSBuYW1lIG9mIGEgcnVsZSBpbiB0aGUgZ3JhbW1hciwgb3IgJ190ZXJtaW5hbCcgKGZvciBhIHRlcm1pbmFsIG5vZGUpLCBvciAnX2l0ZXInIChmb3IgYW5cbiAgICAgIC8vIGl0ZXJhdGlvbiBub2RlKS4gSW4gdGhlIGxhdHRlciBjYXNlLCB0aGUgYWN0aW9uIGZ1bmN0aW9uIHJlY2VpdmVzIGEgc2luZ2xlIGFyZ3VtZW50LCB3aGljaFxuICAgICAgLy8gaXMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlIGNoaWxkcmVuIG9mIHRoZSBDU1Qgbm9kZS5cbiAgICAgIGNvbnN0IGN0b3JOYW1lID0gbm9kZVdyYXBwZXIuX25vZGUuY3Rvck5hbWU7XG4gICAgICBsZXQgYWN0aW9uRm4gPSB0aGlzLmFjdGlvbkRpY3RbY3Rvck5hbWVdO1xuICAgICAgbGV0IGFucztcbiAgICAgIGlmIChhY3Rpb25Gbikge1xuICAgICAgICBnbG9iYWxBY3Rpb25TdGFjay5wdXNoKFt0aGlzLCBjdG9yTmFtZV0pO1xuICAgICAgICBhbnMgPSB0aGlzLmRvQWN0aW9uKHNlbWFudGljcywgbm9kZVdyYXBwZXIsIGFjdGlvbkZuLCBub2RlV3JhcHBlci5pc0l0ZXJhdGlvbigpKTtcbiAgICAgICAgcmV0dXJuIGFucztcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGFjdGlvbiBkaWN0aW9uYXJ5IGRvZXMgbm90IGNvbnRhaW4gYSBzZW1hbnRpYyBhY3Rpb24gZm9yIHRoaXMgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIG5vbnRlcm1pbmFsIG5vZGUgYW5kIHRoZSBwcm9ncmFtbWVyIGhhcyBwcm92aWRlZCBhIGBfbm9udGVybWluYWxgIHNlbWFudGljXG4gICAgICAvLyBhY3Rpb24sIHdlIGludm9rZSBpdDpcbiAgICAgIGlmIChub2RlV3JhcHBlci5pc05vbnRlcm1pbmFsKCkpIHtcbiAgICAgICAgYWN0aW9uRm4gPSB0aGlzLmFjdGlvbkRpY3QuX25vbnRlcm1pbmFsO1xuICAgICAgICBpZiAoYWN0aW9uRm4pIHtcbiAgICAgICAgICBnbG9iYWxBY3Rpb25TdGFjay5wdXNoKFt0aGlzLCAnX25vbnRlcm1pbmFsJywgY3Rvck5hbWVdKTtcbiAgICAgICAgICBhbnMgPSB0aGlzLmRvQWN0aW9uKHNlbWFudGljcywgbm9kZVdyYXBwZXIsIGFjdGlvbkZuLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gYW5zO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UgaW52b2tlIHRoZSAnX2RlZmF1bHQnIHNlbWFudGljIGFjdGlvbi5cbiAgICAgIGdsb2JhbEFjdGlvblN0YWNrLnB1c2goW3RoaXMsICdkZWZhdWx0IGFjdGlvbicsIGN0b3JOYW1lXSk7XG4gICAgICBhbnMgPSB0aGlzLmRvQWN0aW9uKHNlbWFudGljcywgbm9kZVdyYXBwZXIsIHRoaXMuYWN0aW9uRGljdC5fZGVmYXVsdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gYW5zO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBnbG9iYWxBY3Rpb25TdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2UgYGFjdGlvbkZuYCBvbiB0aGUgQ1NUIG5vZGUgdGhhdCBjb3JyZXNwb25kcyB0byBgbm9kZVdyYXBwZXJgLCBpbiB0aGUgY29udGV4dCBvZlxuICAvLyBgc2VtYW50aWNzYC4gSWYgYG9wdFBhc3NDaGlsZHJlbkFzQXJyYXlgIGlzIHRydXRoeSwgYGFjdGlvbkZuYCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgc2luZ2xlXG4gIC8vIGFyZ3VtZW50LCB3aGljaCBpcyBhbiBhcnJheSBvZiB3cmFwcGVycy4gT3RoZXJ3aXNlLCB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBgYWN0aW9uRm5gIHdpbGxcbiAgLy8gYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGUgQ1NUIG5vZGUuXG4gIGRvQWN0aW9uKHNlbWFudGljcywgbm9kZVdyYXBwZXIsIGFjdGlvbkZuLCBvcHRQYXNzQ2hpbGRyZW5Bc0FycmF5KSB7XG4gICAgcmV0dXJuIG9wdFBhc3NDaGlsZHJlbkFzQXJyYXkgP1xuICAgICAgICBhY3Rpb25Gbi5jYWxsKG5vZGVXcmFwcGVyLCBub2RlV3JhcHBlci5fY2hpbGRyZW4oKSkgOlxuICAgICAgICBhY3Rpb25Gbi5hcHBseShub2RlV3JhcHBlciwgbm9kZVdyYXBwZXIuX2NoaWxkcmVuKCkpO1xuICB9XG59XG5cbk9wZXJhdGlvbi5wcm90b3R5cGUudHlwZU5hbWUgPSAnb3BlcmF0aW9uJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gQXR0cmlidXRlIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEF0dHJpYnV0ZXMgYXJlIE9wZXJhdGlvbnMgd2hvc2UgcmVzdWx0cyBhcmUgbWVtb2l6ZWQuIFRoaXMgbWVhbnMgdGhhdCwgZm9yIGFueSBnaXZlbiBzZW1hbnRpY3MsXG4vLyB0aGUgc2VtYW50aWMgYWN0aW9uIGZvciBhIENTVCBub2RlIHdpbGwgYmUgaW52b2tlZCBubyBtb3JlIHRoYW4gb25jZS5cbmNsYXNzIEF0dHJpYnV0ZSBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGFjdGlvbkRpY3QsIGJ1aWx0SW5EZWZhdWx0KSB7XG4gICAgc3VwZXIobmFtZSwgW10sIGFjdGlvbkRpY3QsIGJ1aWx0SW5EZWZhdWx0KTtcbiAgfVxuXG4gIGV4ZWN1dGUoc2VtYW50aWNzLCBub2RlV3JhcHBlcikge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlV3JhcHBlci5fbm9kZTtcbiAgICBjb25zdCBrZXkgPSBzZW1hbnRpY3MuYXR0cmlidXRlS2V5c1t0aGlzLm5hbWVdO1xuICAgIGlmICghbm9kZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgc3VwZXItc2VuZCAtLSBpc24ndCBKUyBiZWF1dGlmdWw/IDovXG4gICAgICBub2RlW2tleV0gPSBPcGVyYXRpb24ucHJvdG90eXBlLmV4ZWN1dGUuY2FsbCh0aGlzLCBzZW1hbnRpY3MsIG5vZGVXcmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVba2V5XTtcbiAgfVxufVxuXG5BdHRyaWJ1dGUucHJvdG90eXBlLnR5cGVOYW1lID0gJ2F0dHJpYnV0ZSc7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gRGVmZXJyZWQgaW5pdGlhbGl6YXRpb24gLS0tLS0tLS0tLS0tLS0tLS1cblxudXRpbC5hd2FpdEJ1aWx0SW5SdWxlcyhidWlsdEluUnVsZXMgPT4ge1xuICBjb25zdCBvcGVyYXRpb25zQW5kQXR0cmlidXRlc0dyYW1tYXIgPSByZXF1aXJlKCcuLi9kaXN0L29wZXJhdGlvbnMtYW5kLWF0dHJpYnV0ZXMnKTtcbiAgaW5pdEJ1aWx0SW5TZW1hbnRpY3MoYnVpbHRJblJ1bGVzKTtcbiAgaW5pdFByb3RvdHlwZVBhcnNlcihvcGVyYXRpb25zQW5kQXR0cmlidXRlc0dyYW1tYXIpOyAvLyByZXF1aXJlcyBCdWlsdEluU2VtYW50aWNzXG59KTtcblxuZnVuY3Rpb24gaW5pdEJ1aWx0SW5TZW1hbnRpY3MoYnVpbHRJblJ1bGVzKSB7XG4gIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgZW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVyYXRpb24oKTtcbiAgICB9LFxuICAgIG5vbkVtcHR5KGZpcnN0LCBfLCByZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVyYXRpb24oW2ZpcnN0XS5jb25jYXQocmVzdC5jaGlsZHJlbikpO1xuICAgIH1cbiAgfTtcblxuICBTZW1hbnRpY3MuQnVpbHRJblNlbWFudGljcyA9IFNlbWFudGljc1xuICAgICAgLmNyZWF0ZVNlbWFudGljcyhidWlsdEluUnVsZXMsIG51bGwpXG4gICAgICAuYWRkT3BlcmF0aW9uKCdhc0l0ZXJhdGlvbicsIHtcbiAgICAgICAgZW1wdHlMaXN0T2Y6IGFjdGlvbnMuZW1wdHksXG4gICAgICAgIG5vbmVtcHR5TGlzdE9mOiBhY3Rpb25zLm5vbkVtcHR5LFxuICAgICAgICBFbXB0eUxpc3RPZjogYWN0aW9ucy5lbXB0eSxcbiAgICAgICAgTm9uZW1wdHlMaXN0T2Y6IGFjdGlvbnMubm9uRW1wdHlcbiAgICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0UHJvdG90eXBlUGFyc2VyKGdyYW1tYXIpIHtcbiAgcHJvdG90eXBlR3JhbW1hclNlbWFudGljcyA9IGdyYW1tYXIuY3JlYXRlU2VtYW50aWNzKCkuYWRkT3BlcmF0aW9uKCdwYXJzZScsIHtcbiAgICBBdHRyaWJ1dGVTaWduYXR1cmUobmFtZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZS5wYXJzZSgpLFxuICAgICAgICBmb3JtYWxzOiBbXVxuICAgICAgfTtcbiAgICB9LFxuICAgIE9wZXJhdGlvblNpZ25hdHVyZShuYW1lLCBvcHRGb3JtYWxzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLnBhcnNlKCksXG4gICAgICAgIGZvcm1hbHM6IG9wdEZvcm1hbHMucGFyc2UoKVswXSB8fCBbXVxuICAgICAgfTtcbiAgICB9LFxuICAgIEZvcm1hbHMob3BhcmVuLCBmcywgY3BhcmVuKSB7XG4gICAgICByZXR1cm4gZnMuYXNJdGVyYXRpb24oKS5wYXJzZSgpO1xuICAgIH0sXG4gICAgbmFtZShmaXJzdCwgcmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3RyaW5nO1xuICAgIH1cbiAgfSk7XG4gIHByb3RvdHlwZUdyYW1tYXIgPSBncmFtbWFyO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gU2VtYW50aWNzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBzdHVmZlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGB0b1N0cmluZ2Agb3V0cHV0LlxuY29uc3QgQkFMTE9UX1ggPSAnXFx1MjcxNyc7XG5jb25zdCBDSEVDS19NQVJLID0gJ1xcdTI3MTMnO1xuY29uc3QgRE9UX09QRVJBVE9SID0gJ1xcdTIyQzUnO1xuY29uc3QgUklHSFRXQVJEU19ET1VCTEVfQVJST1cgPSAnXFx1MjFEMic7XG5jb25zdCBTWU1CT0xfRk9SX0hPUklaT05UQUxfVEFCVUxBVElPTiA9ICdcXHUyNDA5JztcbmNvbnN0IFNZTUJPTF9GT1JfTElORV9GRUVEID0gJ1xcdTI0MEEnO1xuY29uc3QgU1lNQk9MX0ZPUl9DQVJSSUFHRV9SRVRVUk4gPSAnXFx1MjQwRCc7XG5cbmNvbnN0IEZsYWdzID0ge1xuICBzdWNjZWVkZWQ6IDEgPDwgMCxcbiAgaXNSb290Tm9kZTogMSA8PCAxLFxuICBpc0ltcGxpY2l0U3BhY2VzOiAxIDw8IDIsXG4gIGlzTWVtb2l6ZWQ6IDEgPDwgMyxcbiAgaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uOiAxIDw8IDQsXG4gIHRlcm1pbmF0ZXNMUjogMSA8PCA1XG59O1xuXG5mdW5jdGlvbiBzcGFjZXMobikge1xuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIG4pLmpvaW4oJycpO1xufVxuXG4vLyBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBwb3J0aW9uIG9mIGBpbnB1dGAgYXQgb2Zmc2V0IGBwb3NgLlxuLy8gVGhlIHJlc3VsdCB3aWxsIGNvbnRhaW4gZXhhY3RseSBgbGVuYCBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gZ2V0SW5wdXRFeGNlcnB0KGlucHV0LCBwb3MsIGxlbikge1xuICBjb25zdCBleGNlcnB0ID0gYXNFc2NhcGVkU3RyaW5nKGlucHV0LnNsaWNlKHBvcywgcG9zICsgbGVuKSk7XG5cbiAgLy8gUGFkIHRoZSBvdXRwdXQgaWYgbmVjZXNzYXJ5LlxuICBpZiAoZXhjZXJwdC5sZW5ndGggPCBsZW4pIHtcbiAgICByZXR1cm4gZXhjZXJwdCArIGNvbW1vbi5yZXBlYXQoJyAnLCBsZW4gLSBleGNlcnB0Lmxlbmd0aCkuam9pbignJyk7XG4gIH1cbiAgcmV0dXJuIGV4Y2VycHQ7XG59XG5cbmZ1bmN0aW9uIGFzRXNjYXBlZFN0cmluZyhvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gUmVwbGFjZSBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMgd2l0aCB2aXNpYmxlIHN5bWJvbHMuXG4gICAgcmV0dXJuIG9ialxuICAgICAgICAucmVwbGFjZSgvIC9nLCBET1RfT1BFUkFUT1IpXG4gICAgICAgIC5yZXBsYWNlKC9cXHQvZywgU1lNQk9MX0ZPUl9IT1JJWk9OVEFMX1RBQlVMQVRJT04pXG4gICAgICAgIC5yZXBsYWNlKC9cXG4vZywgU1lNQk9MX0ZPUl9MSU5FX0ZFRUQpXG4gICAgICAgIC5yZXBsYWNlKC9cXHIvZywgU1lNQk9MX0ZPUl9DQVJSSUFHRV9SRVRVUk4pO1xuICB9XG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gVHJhY2UgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gVHJhY2UoaW5wdXQsIHBvczEsIHBvczIsIGV4cHIsIHN1Y2NlZWRlZCwgYmluZGluZ3MsIG9wdENoaWxkcmVuKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5wb3MgPSB0aGlzLnBvczEgPSBwb3MxO1xuICB0aGlzLnBvczIgPSBwb3MyO1xuICB0aGlzLnNvdXJjZSA9IG5ldyBJbnRlcnZhbChpbnB1dCwgcG9zMSwgcG9zMik7XG4gIHRoaXMuZXhwciA9IGV4cHI7XG4gIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgdGhpcy5jaGlsZHJlbiA9IG9wdENoaWxkcmVuIHx8IFtdO1xuICB0aGlzLnRlcm1pbmF0aW5nTFJFbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5fZmxhZ3MgPSBzdWNjZWVkZWQgPyBGbGFncy5zdWNjZWVkZWQgOiAwO1xufVxuXG4vLyBBIHZhbHVlIHRoYXQgY2FuIGJlIHJldHVybmVkIGZyb20gdmlzaXRvciBmdW5jdGlvbnMgdG8gaW5kaWNhdGUgdGhhdCBhXG4vLyBub2RlIHNob3VsZCBub3QgYmUgcmVjdXJzZWQgaW50by5cblRyYWNlLnByb3RvdHlwZS5TS0lQID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFjZS5wcm90b3R5cGUsICdkaXNwbGF5U3RyaW5nJywge1xuICBnZXQoKSB7IHJldHVybiB0aGlzLmV4cHIudG9EaXNwbGF5U3RyaW5nKCk7IH1cbn0pO1xuXG4vLyBGb3IgY29udmVuaWVuY2UsIGNyZWF0ZSBhIGdldHRlciBhbmQgc2V0dGVyIGZvciB0aGUgYm9vbGVhbiBmbGFncyBpbiBgRmxhZ3NgLlxuT2JqZWN0LmtleXMoRmxhZ3MpLmZvckVhY2gobmFtZSA9PiB7XG4gIGNvbnN0IG1hc2sgPSBGbGFnc1tuYW1lXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYWNlLnByb3RvdHlwZSwgbmFtZSwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiBtYXNrKSAhPT0gMDtcbiAgICB9LFxuICAgIHNldCh2YWwpIHtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MgfD0gbWFzaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzICY9IH5tYXNrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KTtcblxuVHJhY2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNsb25lV2l0aEV4cHIodGhpcy5leHByKTtcbn07XG5cblRyYWNlLnByb3RvdHlwZS5jbG9uZVdpdGhFeHByID0gZnVuY3Rpb24oZXhwcikge1xuICBjb25zdCBhbnMgPSBuZXcgVHJhY2UoXG4gICAgICB0aGlzLmlucHV0LCB0aGlzLnBvcywgdGhpcy5wb3MyLCBleHByLCB0aGlzLnN1Y2NlZWRlZCwgdGhpcy5iaW5kaW5ncywgdGhpcy5jaGlsZHJlbik7XG5cbiAgYW5zLmlzSGVhZE9mTGVmdFJlY3Vyc2lvbiA9IHRoaXMuaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uO1xuICBhbnMuaXNJbXBsaWNpdFNwYWNlcyA9IHRoaXMuaXNJbXBsaWNpdFNwYWNlcztcbiAgYW5zLmlzTWVtb2l6ZWQgPSB0aGlzLmlzTWVtb2l6ZWQ7XG4gIGFucy5pc1Jvb3ROb2RlID0gdGhpcy5pc1Jvb3ROb2RlO1xuICBhbnMudGVybWluYXRlc0xSID0gdGhpcy50ZXJtaW5hdGVzTFI7XG4gIGFucy50ZXJtaW5hdGluZ0xSRW50cnkgPSB0aGlzLnRlcm1pbmF0aW5nTFJFbnRyeTtcbiAgcmV0dXJuIGFucztcbn07XG5cbi8vIFJlY29yZCB0aGUgdHJhY2UgaW5mb3JtYXRpb24gZm9yIHRoZSB0ZXJtaW5hdGluZyBjb25kaXRpb24gb2YgdGhlIExSIGxvb3AuXG5UcmFjZS5wcm90b3R5cGUucmVjb3JkTFJUZXJtaW5hdGlvbiA9IGZ1bmN0aW9uKHJ1bGVCb2R5VHJhY2UsIHZhbHVlKSB7XG4gIHRoaXMudGVybWluYXRpbmdMUkVudHJ5ID1cbiAgICAgIG5ldyBUcmFjZSh0aGlzLmlucHV0LCB0aGlzLnBvcywgdGhpcy5wb3MyLCB0aGlzLmV4cHIsIGZhbHNlLCBbdmFsdWVdLCBbcnVsZUJvZHlUcmFjZV0pO1xuICB0aGlzLnRlcm1pbmF0aW5nTFJFbnRyeS50ZXJtaW5hdGVzTFIgPSB0cnVlO1xufTtcblxuLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhpcyB0cmFjZSBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRlbnRzLCBjYWxsaW5nIGEgdmlzaXRvciBmdW5jdGlvblxuLy8gZm9yIGVhY2ggbm9kZSB0aGF0IGlzIHZpc2l0ZWQuIElmIGB2aXN0b3JPYmpPckZuYCBpcyBhbiBvYmplY3QsIHRoZW4gaXRzICdlbnRlcicgcHJvcGVydHlcbi8vIGlzIGEgZnVuY3Rpb24gdG8gY2FsbCBiZWZvcmUgdmlzaXRpbmcgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSwgYW5kIGl0cyAnZXhpdCcgcHJvcGVydHkgaXNcbi8vIGEgZnVuY3Rpb24gdG8gY2FsbCBhZnRlcndhcmRzLiBJZiBgdmlzaXRvck9iak9yRm5gIGlzIGEgZnVuY3Rpb24sIGl0IHJlcHJlc2VudHMgdGhlICdlbnRlcidcbi8vIGZ1bmN0aW9uLlxuLy9cbi8vIFRoZSBmdW5jdGlvbnMgYXJlIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogdGhlIFRyYWNlIG5vZGUsIGl0cyBwYXJlbnQgVHJhY2UsIGFuZCBhIG51bWJlclxuLy8gcmVwcmVzZW50aW5nIHRoZSBkZXB0aCBvZiB0aGUgbm9kZSBpbiB0aGUgdHJlZS4gKFRoZSByb290IG5vZGUgaGFzIGRlcHRoIDAuKSBgb3B0VGhpc0FyZ2AsIGlmXG4vLyBzcGVjaWZpZWQsIGlzIHRoZSB2YWx1ZSB0byB1c2UgZm9yIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyB0aGUgdmlzaXRvciBmdW5jdGlvbnMuXG5UcmFjZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uKHZpc2l0b3JPYmpPckZuLCBvcHRUaGlzQXJnKSB7XG4gIGxldCB2aXNpdG9yID0gdmlzaXRvck9iak9yRm47XG4gIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZpc2l0b3IgPSB7ZW50ZXI6IHZpc2l0b3J9O1xuICB9XG5cbiAgZnVuY3Rpb24gX3dhbGsobm9kZSwgcGFyZW50LCBkZXB0aCkge1xuICAgIGxldCByZWN1cnNlID0gdHJ1ZTtcbiAgICBpZiAodmlzaXRvci5lbnRlcikge1xuICAgICAgaWYgKHZpc2l0b3IuZW50ZXIuY2FsbChvcHRUaGlzQXJnLCBub2RlLCBwYXJlbnQsIGRlcHRoKSA9PT0gVHJhY2UucHJvdG90eXBlLlNLSVApIHtcbiAgICAgICAgcmVjdXJzZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjdXJzZSkge1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgX3dhbGsoY2hpbGQsIG5vZGUsIGRlcHRoICsgMSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh2aXNpdG9yLmV4aXQpIHtcbiAgICAgICAgdmlzaXRvci5leGl0LmNhbGwob3B0VGhpc0FyZywgbm9kZSwgcGFyZW50LCBkZXB0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLmlzUm9vdE5vZGUpIHtcbiAgICAvLyBEb24ndCB2aXNpdCB0aGUgcm9vdCBub2RlIGl0c2VsZiwgb25seSBpdHMgY2hpbGRyZW4uXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGMgPT4geyBfd2FsayhjLCBudWxsLCAwKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgX3dhbGsodGhpcywgbnVsbCwgMCk7XG4gIH1cbn07XG5cbi8vIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhY2UuXG4vLyBTYW1wbGU6XG4vLyAgICAgMTLii4Ur4ouFMuKLhSrii4UzIOKckyBleHAg4oeSICBcIjEyXCJcbi8vICAgICAxMuKLhSvii4Uy4ouFKuKLhTMgICDinJMgYWRkRXhwIChMUikg4oeSICBcIjEyXCJcbi8vICAgICAxMuKLhSvii4Uy4ouFKuKLhTMgICAgICAg4pyXIGFkZEV4cF9wbHVzXG5UcmFjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc2IgPSBuZXcgY29tbW9uLlN0cmluZ0J1ZmZlcigpO1xuICB0aGlzLndhbGsoKG5vZGUsIHBhcmVudCwgZGVwdGgpID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLlNLSVA7XG4gICAgfVxuICAgIGNvbnN0IGN0b3JOYW1lID0gbm9kZS5leHByLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgLy8gRG9uJ3QgcHJpbnQgYW55dGhpbmcgZm9yIEFsdCBub2Rlcy5cbiAgICBpZiAoY3Rvck5hbWUgPT09ICdBbHQnKSB7XG4gICAgICByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICB9XG4gICAgc2IuYXBwZW5kKGdldElucHV0RXhjZXJwdChub2RlLmlucHV0LCBub2RlLnBvcywgMTApICsgc3BhY2VzKGRlcHRoICogMiArIDEpKTtcbiAgICBzYi5hcHBlbmQoKG5vZGUuc3VjY2VlZGVkID8gQ0hFQ0tfTUFSSyA6IEJBTExPVF9YKSArICcgJyArIG5vZGUuZGlzcGxheVN0cmluZyk7XG4gICAgaWYgKG5vZGUuaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uKSB7XG4gICAgICBzYi5hcHBlbmQoJyAoTFIpJyk7XG4gICAgfVxuICAgIGlmIChub2RlLnN1Y2NlZWRlZCkge1xuICAgICAgY29uc3QgY29udGVudHMgPSBhc0VzY2FwZWRTdHJpbmcobm9kZS5zb3VyY2UuY29udGVudHMpO1xuICAgICAgc2IuYXBwZW5kKCcgJyArIFJJR0hUV0FSRFNfRE9VQkxFX0FSUk9XICsgJyAgJyk7XG4gICAgICBzYi5hcHBlbmQodHlwZW9mIGNvbnRlbnRzID09PSAnc3RyaW5nJyA/ICdcIicgKyBjb250ZW50cyArICdcIicgOiBjb250ZW50cyk7XG4gICAgfVxuICAgIHNiLmFwcGVuZCgnXFxuJyk7XG4gIH0pO1xuICByZXR1cm4gc2IuY29udGVudHMoKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgndXRpbC1leHRlbmQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgU3R1ZmZcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEhlbHBlcnNcblxuY29uc3QgZXNjYXBlU3RyaW5nRm9yID0ge307XG5mb3IgKGxldCBjID0gMDsgYyA8IDEyODsgYysrKSB7XG4gIGVzY2FwZVN0cmluZ0ZvcltjXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG59XG5lc2NhcGVTdHJpbmdGb3JbXCInXCIuY2hhckNvZGVBdCgwKV0gPSBcIlxcXFwnXCI7XG5lc2NhcGVTdHJpbmdGb3JbJ1wiJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcXCInO1xuZXNjYXBlU3RyaW5nRm9yWydcXFxcJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcXFxcXCc7XG5lc2NhcGVTdHJpbmdGb3JbJ1xcYicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXGInO1xuZXNjYXBlU3RyaW5nRm9yWydcXGYnLmNoYXJDb2RlQXQoMCldID0gJ1xcXFxmJztcbmVzY2FwZVN0cmluZ0ZvclsnXFxuJy5jaGFyQ29kZUF0KDApXSA9ICdcXFxcbic7XG5lc2NhcGVTdHJpbmdGb3JbJ1xccicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXHInO1xuZXNjYXBlU3RyaW5nRm9yWydcXHQnLmNoYXJDb2RlQXQoMCldID0gJ1xcXFx0JztcbmVzY2FwZVN0cmluZ0ZvclsnXFx1MDAwYicuY2hhckNvZGVBdCgwKV0gPSAnXFxcXHYnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5hYnN0cmFjdCA9IGZ1bmN0aW9uKG9wdE1ldGhvZE5hbWUpIHtcbiAgY29uc3QgbWV0aG9kTmFtZSA9IG9wdE1ldGhvZE5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICd0aGlzIG1ldGhvZCAnICsgbWV0aG9kTmFtZSArICcgaXMgYWJzdHJhY3QhICcgK1xuICAgICAgJyhpdCBoYXMgbm8gaW1wbGVtZW50YXRpb24gaW4gY2xhc3MgJyArIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcpJyk7XG4gIH07XG59O1xuXG5leHBvcnRzLmFzc2VydCA9IGZ1bmN0aW9uKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vLyBEZWZpbmUgYSBsYXppbHktY29tcHV0ZWQsIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVkIGBwcm9wTmFtZWBcbi8vIG9uIHRoZSBvYmplY3QgYG9iamAuIGBnZXR0ZXJGbmAgd2lsbCBiZSBjYWxsZWQgdG8gY29tcHV0ZSB0aGUgdmFsdWUgdGhlXG4vLyBmaXJzdCB0aW1lIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZC5cbmV4cG9ydHMuZGVmaW5lTGF6eVByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wTmFtZSwgZ2V0dGVyRm4pIHtcbiAgbGV0IG1lbW87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BOYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYgKCFtZW1vKSB7XG4gICAgICAgIG1lbW8gPSBnZXR0ZXJGbi5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuICB9KTtcbn07XG5cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKG9iaikge1xuICAgIHJldHVybiBleHRlbmQoe30sIG9iaik7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuXG5leHBvcnRzLnJlcGVhdEZuID0gZnVuY3Rpb24oZm4sIG4pIHtcbiAgY29uc3QgYXJyID0gW107XG4gIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgYXJyLnB1c2goZm4oKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbmV4cG9ydHMucmVwZWF0U3RyID0gZnVuY3Rpb24oc3RyLCBuKSB7XG4gIHJldHVybiBuZXcgQXJyYXkobiArIDEpLmpvaW4oc3RyKTtcbn07XG5cbmV4cG9ydHMucmVwZWF0ID0gZnVuY3Rpb24oeCwgbikge1xuICByZXR1cm4gZXhwb3J0cy5yZXBlYXRGbigoKSA9PiB4LCBuKTtcbn07XG5cbmV4cG9ydHMuZ2V0RHVwbGljYXRlcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIGNvbnN0IGR1cGxpY2F0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYXJyYXkubGVuZ3RoOyBpZHgrKykge1xuICAgIGNvbnN0IHggPSBhcnJheVtpZHhdO1xuICAgIGlmIChhcnJheS5sYXN0SW5kZXhPZih4KSAhPT0gaWR4ICYmIGR1cGxpY2F0ZXMuaW5kZXhPZih4KSA8IDApIHtcbiAgICAgIGR1cGxpY2F0ZXMucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cGxpY2F0ZXM7XG59O1xuXG5leHBvcnRzLmNvcHlXaXRob3V0RHVwbGljYXRlcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIGNvbnN0IG5vRHVwbGljYXRlcyA9IFtdO1xuICBhcnJheS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBpZiAobm9EdXBsaWNhdGVzLmluZGV4T2YoZW50cnkpIDwgMCkge1xuICAgICAgbm9EdXBsaWNhdGVzLnB1c2goZW50cnkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBub0R1cGxpY2F0ZXM7XG59O1xuXG5leHBvcnRzLmlzU3ludGFjdGljID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgY29uc3QgZmlyc3RDaGFyID0gcnVsZU5hbWVbMF07XG4gIHJldHVybiBmaXJzdENoYXIgPT09IGZpcnN0Q2hhci50b1VwcGVyQ2FzZSgpO1xufTtcblxuZXhwb3J0cy5pc0xleGljYWwgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICByZXR1cm4gIWV4cG9ydHMuaXNTeW50YWN0aWMocnVsZU5hbWUpO1xufTtcblxuZXhwb3J0cy5wYWRMZWZ0ID0gZnVuY3Rpb24oc3RyLCBsZW4sIG9wdENoYXIpIHtcbiAgY29uc3QgY2ggPSBvcHRDaGFyIHx8ICcgJztcbiAgaWYgKHN0ci5sZW5ndGggPCBsZW4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yZXBlYXRTdHIoY2gsIGxlbiAtIHN0ci5sZW5ndGgpICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG4vLyBTdHJpbmdCdWZmZXJcblxuZXhwb3J0cy5TdHJpbmdCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdHJpbmdzID0gW107XG59O1xuXG5leHBvcnRzLlN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc3RyKSB7XG4gIHRoaXMuc3RyaW5ncy5wdXNoKHN0cik7XG59O1xuXG5leHBvcnRzLlN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29udGVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3RyaW5ncy5qb2luKCcnKTtcbn07XG5cbi8vIENoYXJhY3RlciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZ1xuXG5leHBvcnRzLmVzY2FwZUNoYXIgPSBmdW5jdGlvbihjLCBvcHREZWxpbSkge1xuICBjb25zdCBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgaWYgKChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSAmJiBvcHREZWxpbSAmJiBjICE9PSBvcHREZWxpbSkge1xuICAgIHJldHVybiBjO1xuICB9IGVsc2UgaWYgKGNoYXJDb2RlIDwgMTI4KSB7XG4gICAgcmV0dXJuIGVzY2FwZVN0cmluZ0ZvcltjaGFyQ29kZV07XG4gIH0gZWxzZSBpZiAoMTI4IDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDwgMjU2KSB7XG4gICAgcmV0dXJuICdcXFxceCcgKyBleHBvcnRzLnBhZExlZnQoY2hhckNvZGUudG9TdHJpbmcoMTYpLCAyLCAnMCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnXFxcXHUnICsgZXhwb3J0cy5wYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KSwgNCwgJzAnKTtcbiAgfVxufTtcblxuZXhwb3J0cy51bmVzY2FwZUNoYXIgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzLmNoYXJBdCgwKSA9PT0gJ1xcXFwnKSB7XG4gICAgc3dpdGNoIChzLmNoYXJBdCgxKSkge1xuICAgICAgY2FzZSAnYic6IHJldHVybiAnXFxiJztcbiAgICAgIGNhc2UgJ2YnOiByZXR1cm4gJ1xcZic7XG4gICAgICBjYXNlICduJzogcmV0dXJuICdcXG4nO1xuICAgICAgY2FzZSAncic6IHJldHVybiAnXFxyJztcbiAgICAgIGNhc2UgJ3QnOiByZXR1cm4gJ1xcdCc7XG4gICAgICBjYXNlICd2JzogcmV0dXJuICdcXHYnO1xuICAgICAgY2FzZSAneCc6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHMuc3Vic3RyaW5nKDIsIDQpLCAxNikpO1xuICAgICAgY2FzZSAndSc6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHMuc3Vic3RyaW5nKDIsIDYpLCAxNikpO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIHMuY2hhckF0KDEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufTtcblxuLy8gSGVscGVyIGZvciBwcm9kdWNpbmcgYSBkZXNjcmlwdGlvbiBvZiBhbiB1bmtub3duIG9iamVjdCBpbiBhIHNhZmUgd2F5LlxuLy8gRXNwZWNpYWxseSB1c2VmdWwgZm9yIGVycm9yIG1lc3NhZ2VzIHdoZXJlIGFuIHVuZXhwZWN0ZWQgdHlwZSBvZiBvYmplY3Qgd2FzIGVuY291bnRlcmVkLlxuZXhwb3J0cy51bmV4cGVjdGVkT2JqVG9TdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFN0cmluZyhvYmopO1xuICB9XG4gIGNvbnN0IGJhc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICB0cnkge1xuICAgIGxldCB0eXBlTmFtZTtcbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICB0eXBlTmFtZSA9IG9iai5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH0gZWxzZSBpZiAoYmFzZVRvU3RyaW5nLmluZGV4T2YoJ1tvYmplY3QgJykgPT09IDApIHtcbiAgICAgIHR5cGVOYW1lID0gYmFzZVRvU3RyaW5nLnNsaWNlKDgsIC0xKTsgLy8gRXh0cmFjdCBlLmcuIFwiQXJyYXlcIiBmcm9tIFwiW29iamVjdCBBcnJheV1cIi5cbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZU5hbWUgPSB0eXBlb2Ygb2JqO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZU5hbWUgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkoU3RyaW5nKG9iaikpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGJhc2VUb1N0cmluZztcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbmNvbnN0IE5hbWVzcGFjZSA9IHJlcXVpcmUoJy4vTmFtZXNwYWNlJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBvcHRJbnRlcnZhbCkge1xuICBsZXQgZTtcbiAgaWYgKG9wdEludGVydmFsKSB7XG4gICAgZSA9IG5ldyBFcnJvcihvcHRJbnRlcnZhbC5nZXRMaW5lQW5kQ29sdW1uTWVzc2FnZSgpICsgbWVzc2FnZSk7XG4gICAgZS5zaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIGUuaW50ZXJ2YWwgPSBvcHRJbnRlcnZhbDtcbiAgfSBlbHNlIHtcbiAgICBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBlcnJvcnMgYWJvdXQgaW50ZXJ2YWxzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGludGVydmFsU291cmNlc0RvbnRNYXRjaCgpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFwiSW50ZXJ2YWwgc291cmNlcyBkb24ndCBtYXRjaFwiKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0gZXJyb3JzIGFib3V0IGdyYW1tYXJzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEdyYW1tYXIgc3ludGF4IGVycm9yXG5cbmZ1bmN0aW9uIGdyYW1tYXJTeW50YXhFcnJvcihtYXRjaEZhaWx1cmUpIHtcbiAgY29uc3QgZSA9IG5ldyBFcnJvcigpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ21lc3NhZ2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gbWF0Y2hGYWlsdXJlLm1lc3NhZ2U7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdzaG9ydE1lc3NhZ2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0V4cGVjdGVkICcgKyBtYXRjaEZhaWx1cmUuZ2V0RXhwZWN0ZWRUZXh0KCk7XG4gICAgfVxuICB9KTtcbiAgZS5pbnRlcnZhbCA9IG1hdGNoRmFpbHVyZS5nZXRJbnRlcnZhbCgpO1xuICByZXR1cm4gZTtcbn1cblxuLy8gVW5kZWNsYXJlZCBncmFtbWFyXG5cbmZ1bmN0aW9uIHVuZGVjbGFyZWRHcmFtbWFyKGdyYW1tYXJOYW1lLCBuYW1lc3BhY2UsIGludGVydmFsKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBuYW1lc3BhY2UgP1xuICAgICAgJ0dyYW1tYXIgJyArIGdyYW1tYXJOYW1lICsgJyBpcyBub3QgZGVjbGFyZWQgaW4gbmFtZXNwYWNlICcgKyBOYW1lc3BhY2UudG9TdHJpbmcobmFtZXNwYWNlKSA6XG4gICAgICAnVW5kZWNsYXJlZCBncmFtbWFyICcgKyBncmFtbWFyTmFtZTtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGludGVydmFsKTtcbn1cblxuLy8gRHVwbGljYXRlIGdyYW1tYXIgZGVjbGFyYXRpb25cblxuZnVuY3Rpb24gZHVwbGljYXRlR3JhbW1hckRlY2xhcmF0aW9uKGdyYW1tYXIsIG5hbWVzcGFjZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoJ0dyYW1tYXIgJyArIGdyYW1tYXIubmFtZSArICcgaXMgYWxyZWFkeSBkZWNsYXJlZCBpbiB0aGlzIG5hbWVzcGFjZScpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBydWxlcyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBVbmRlY2xhcmVkIHJ1bGVcblxuZnVuY3Rpb24gdW5kZWNsYXJlZFJ1bGUocnVsZU5hbWUsIGdyYW1tYXJOYW1lLCBvcHRJbnRlcnZhbCkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnUnVsZSAnICsgcnVsZU5hbWUgKyAnIGlzIG5vdCBkZWNsYXJlZCBpbiBncmFtbWFyICcgKyBncmFtbWFyTmFtZSxcbiAgICAgIG9wdEludGVydmFsKTtcbn1cblxuLy8gQ2Fubm90IG92ZXJyaWRlIHVuZGVjbGFyZWQgcnVsZVxuXG5mdW5jdGlvbiBjYW5ub3RPdmVycmlkZVVuZGVjbGFyZWRSdWxlKHJ1bGVOYW1lLCBncmFtbWFyTmFtZSwgb3B0U291cmNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdDYW5ub3Qgb3ZlcnJpZGUgcnVsZSAnICsgcnVsZU5hbWUgKyAnIGJlY2F1c2UgaXQgaXMgbm90IGRlY2xhcmVkIGluICcgKyBncmFtbWFyTmFtZSxcbiAgICAgIG9wdFNvdXJjZSk7XG59XG5cbi8vIENhbm5vdCBleHRlbmQgdW5kZWNsYXJlZCBydWxlXG5cbmZ1bmN0aW9uIGNhbm5vdEV4dGVuZFVuZGVjbGFyZWRSdWxlKHJ1bGVOYW1lLCBncmFtbWFyTmFtZSwgb3B0U291cmNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdDYW5ub3QgZXh0ZW5kIHJ1bGUgJyArIHJ1bGVOYW1lICsgJyBiZWNhdXNlIGl0IGlzIG5vdCBkZWNsYXJlZCBpbiAnICsgZ3JhbW1hck5hbWUsXG4gICAgICBvcHRTb3VyY2UpO1xufVxuXG4vLyBEdXBsaWNhdGUgcnVsZSBkZWNsYXJhdGlvblxuXG5mdW5jdGlvbiBkdXBsaWNhdGVSdWxlRGVjbGFyYXRpb24ocnVsZU5hbWUsIGdyYW1tYXJOYW1lLCBkZWNsR3JhbW1hck5hbWUsIG9wdFNvdXJjZSkge1xuICBsZXQgbWVzc2FnZSA9IFwiRHVwbGljYXRlIGRlY2xhcmF0aW9uIGZvciBydWxlICdcIiArIHJ1bGVOYW1lICtcbiAgICAgIFwiJyBpbiBncmFtbWFyICdcIiArIGdyYW1tYXJOYW1lICsgXCInXCI7XG4gIGlmIChncmFtbWFyTmFtZSAhPT0gZGVjbEdyYW1tYXJOYW1lKSB7XG4gICAgbWVzc2FnZSArPSBcIiAob3JpZ2luYWxseSBkZWNsYXJlZCBpbiAnXCIgKyBkZWNsR3JhbW1hck5hbWUgKyBcIicpXCI7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIG9wdFNvdXJjZSk7XG59XG5cbi8vIFdyb25nIG51bWJlciBvZiBwYXJhbWV0ZXJzXG5cbmZ1bmN0aW9uIHdyb25nTnVtYmVyT2ZQYXJhbWV0ZXJzKHJ1bGVOYW1lLCBleHBlY3RlZCwgYWN0dWFsLCBzb3VyY2UpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ1dyb25nIG51bWJlciBvZiBwYXJhbWV0ZXJzIGZvciBydWxlICcgKyBydWxlTmFtZSArXG4gICAgICAgICAgJyAoZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJywgZ290ICcgKyBhY3R1YWwgKyAnKScsXG4gICAgICBzb3VyY2UpO1xufVxuXG4vLyBXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXG5cbmZ1bmN0aW9uIHdyb25nTnVtYmVyT2ZBcmd1bWVudHMocnVsZU5hbWUsIGV4cGVjdGVkLCBhY3R1YWwsIGV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIHJ1bGUgJyArIHJ1bGVOYW1lICtcbiAgICAgICAgICAnIChleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnLCBnb3QgJyArIGFjdHVhbCArICcpJyxcbiAgICAgIGV4cHIuc291cmNlKTtcbn1cblxuLy8gRHVwbGljYXRlIHBhcmFtZXRlciBuYW1lc1xuXG5mdW5jdGlvbiBkdXBsaWNhdGVQYXJhbWV0ZXJOYW1lcyhydWxlTmFtZSwgZHVwbGljYXRlcywgc291cmNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzIGluIHJ1bGUgJyArIHJ1bGVOYW1lICsgJzogJyArIGR1cGxpY2F0ZXMuam9pbignLCAnKSxcbiAgICAgIHNvdXJjZSk7XG59XG5cbi8vIEludmFsaWQgcGFyYW1ldGVyIGV4cHJlc3Npb25cblxuZnVuY3Rpb24gaW52YWxpZFBhcmFtZXRlcihydWxlTmFtZSwgZXhwcikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICAnSW52YWxpZCBwYXJhbWV0ZXIgdG8gcnVsZSAnICsgcnVsZU5hbWUgKyAnOiAnICsgZXhwciArICcgaGFzIGFyaXR5ICcgKyBleHByLmdldEFyaXR5KCkgK1xuICAgICAgICAgJywgYnV0IHBhcmFtZXRlciBleHByZXNzaW9ucyBtdXN0IGhhdmUgYXJpdHkgMScsXG4gICAgICBleHByLnNvdXJjZSk7XG59XG5cbi8vIEFwcGxpY2F0aW9uIG9mIHN5bnRhY3RpYyBydWxlIGZyb20gbGV4aWNhbCBydWxlXG5cbmZ1bmN0aW9uIGFwcGxpY2F0aW9uT2ZTeW50YWN0aWNSdWxlRnJvbUxleGljYWxDb250ZXh0KHJ1bGVOYW1lLCBhcHBseUV4cHIpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ0Nhbm5vdCBhcHBseSBzeW50YWN0aWMgcnVsZSAnICsgcnVsZU5hbWUgKyAnIGZyb20gaGVyZSAoaW5zaWRlIGEgbGV4aWNhbCBjb250ZXh0KScsXG4gICAgICBhcHBseUV4cHIuc291cmNlKTtcbn1cblxuLy8gSW5jb3JyZWN0IGFyZ3VtZW50IHR5cGVcblxuZnVuY3Rpb24gaW5jb3JyZWN0QXJndW1lbnRUeXBlKGV4cGVjdGVkVHlwZSwgZXhwcikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoJ0luY29ycmVjdCBhcmd1bWVudCB0eXBlOiBleHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlLCBleHByLnNvdXJjZSk7XG59XG5cbi8vIE11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGUgc3VwZXItc3BsaWNlIG9wZXJhdG9yIChgLi4uYCkgaW4gdGhlIHJ1bGUgYm9keS5cblxuZnVuY3Rpb24gbXVsdGlwbGVTdXBlclNwbGljZXMoZXhwcikge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXCInLi4uJyBjYW4gYXBwZWFyIGF0IG1vc3Qgb25jZSBpbiBhIHJ1bGUgYm9keVwiLCBleHByLnNvdXJjZSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIEtsZWVuZSBvcGVyYXRvcnMgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24ga2xlZW5lRXhwckhhc051bGxhYmxlT3BlcmFuZChrbGVlbmVFeHByLCBhcHBsaWNhdGlvblN0YWNrKSB7XG4gIGNvbnN0IGFjdHVhbHMgPSBhcHBsaWNhdGlvblN0YWNrLmxlbmd0aCA+IDAgP1xuICAgIGFwcGxpY2F0aW9uU3RhY2tbYXBwbGljYXRpb25TdGFjay5sZW5ndGggLSAxXS5hcmdzIDpcbiAgICBbXTtcbiAgY29uc3QgZXhwciA9IGtsZWVuZUV4cHIuZXhwci5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpO1xuICBsZXQgbWVzc2FnZSA9XG4gICAgJ051bGxhYmxlIGV4cHJlc3Npb24gJyArIGV4cHIgKyBcIiBpcyBub3QgYWxsb3dlZCBpbnNpZGUgJ1wiICtcbiAgICBrbGVlbmVFeHByLm9wZXJhdG9yICsgXCInIChwb3NzaWJsZSBpbmZpbml0ZSBsb29wKVwiO1xuICBpZiAoYXBwbGljYXRpb25TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RhY2tUcmFjZSA9IGFwcGxpY2F0aW9uU3RhY2tcbiAgICAgICAgLm1hcChhcHAgPT4gbmV3IHBleHBycy5BcHBseShhcHAucnVsZU5hbWUsIGFwcC5hcmdzKSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIG1lc3NhZ2UgKz0gJ1xcbkFwcGxpY2F0aW9uIHN0YWNrIChtb3N0IHJlY2VudCBhcHBsaWNhdGlvbiBsYXN0KTpcXG4nICsgc3RhY2tUcmFjZTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRXJyb3IobWVzc2FnZSwga2xlZW5lRXhwci5leHByLnNvdXJjZSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIGFyaXR5IC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGluY29uc2lzdGVudEFyaXR5KHJ1bGVOYW1lLCBleHBlY3RlZCwgYWN0dWFsLCBleHByKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihcbiAgICAgICdSdWxlICcgKyBydWxlTmFtZSArICcgaW52b2x2ZXMgYW4gYWx0ZXJuYXRpb24gd2hpY2ggaGFzIGluY29uc2lzdGVudCBhcml0eSAnICtcbiAgICAgICAgICAnKGV4cGVjdGVkICcgKyBleHBlY3RlZCArICcsIGdvdCAnICsgYWN0dWFsICsgJyknLFxuICAgICAgZXhwci5zb3VyY2UpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBwcm9wZXJ0aWVzIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGR1cGxpY2F0ZVByb3BlcnR5TmFtZXMoZHVwbGljYXRlcykge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoJ09iamVjdCBwYXR0ZXJuIGhhcyBkdXBsaWNhdGUgcHJvcGVydHkgbmFtZXM6ICcgKyBkdXBsaWNhdGVzLmpvaW4oJywgJykpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBjb25zdHJ1Y3RvcnMgLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaW52YWxpZENvbnN0cnVjdG9yQ2FsbChncmFtbWFyLCBjdG9yTmFtZSwgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKFxuICAgICAgJ0F0dGVtcHQgdG8gaW52b2tlIGNvbnN0cnVjdG9yICcgKyBjdG9yTmFtZSArICcgd2l0aCBpbnZhbGlkIG9yIHVuZXhwZWN0ZWQgYXJndW1lbnRzJyk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tIGNvbnZlbmllbmNlIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIG11bHRpcGxlRXJyb3JzKGVycm9ycykge1xuICBjb25zdCBtZXNzYWdlcyA9IGVycm9ycy5tYXAoZSA9PiBlLm1lc3NhZ2UpO1xuICByZXR1cm4gY3JlYXRlRXJyb3IoXG4gICAgICBbJ0Vycm9yczonXS5jb25jYXQobWVzc2FnZXMpLmpvaW4oJ1xcbi0gJyksXG4gICAgICBlcnJvcnNbMF0uaW50ZXJ2YWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLSBzZW1hbnRpYyAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBtaXNzaW5nU2VtYW50aWNBY3Rpb24oY3Rvck5hbWUsIG5hbWUsIHR5cGUsIHN0YWNrKSB7XG4gIGxldCBzdGFja1RyYWNlID0gc3RhY2suc2xpY2UoMCwgLTEpLm1hcChpbmZvID0+IHtcbiAgICBjb25zdCBhbnMgPSAnICAnICsgaW5mb1swXS5uYW1lICsgJyA+ICcgKyBpbmZvWzFdO1xuICAgIHJldHVybiBpbmZvLmxlbmd0aCA9PT0gM1xuICAgICAgICA/IGFucyArIFwiIGZvciAnXCIgKyBpbmZvWzJdICsgXCInXCJcbiAgICAgICAgOiBhbnM7XG4gIH0pLmpvaW4oJ1xcbicpO1xuICBzdGFja1RyYWNlICs9ICdcXG4gICcgKyBuYW1lICsgJyA+ICcgKyBjdG9yTmFtZTtcblxuICBjb25zdCB3aGVyZSA9IHR5cGUgKyBcIiAnXCIgKyBuYW1lICsgXCInXCI7XG4gIGNvbnN0IG1lc3NhZ2UgPSBcIk1pc3Npbmcgc2VtYW50aWMgYWN0aW9uIGZvciAnXCIgKyBjdG9yTmFtZSArIFwiJyBpbiBcIiArIHdoZXJlICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdBY3Rpb24gc3RhY2sgKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6XFxuJyArIHN0YWNrVHJhY2U7XG5cbiAgY29uc3QgZSA9IGNyZWF0ZUVycm9yKG1lc3NhZ2UpO1xuICBlLm5hbWUgPSAnbWlzc2luZ1NlbWFudGljQWN0aW9uJztcbiAgcmV0dXJuIGU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwbGljYXRpb25PZlN5bnRhY3RpY1J1bGVGcm9tTGV4aWNhbENvbnRleHQsXG4gIGNhbm5vdEV4dGVuZFVuZGVjbGFyZWRSdWxlLFxuICBjYW5ub3RPdmVycmlkZVVuZGVjbGFyZWRSdWxlLFxuICBkdXBsaWNhdGVHcmFtbWFyRGVjbGFyYXRpb24sXG4gIGR1cGxpY2F0ZVBhcmFtZXRlck5hbWVzLFxuICBkdXBsaWNhdGVQcm9wZXJ0eU5hbWVzLFxuICBkdXBsaWNhdGVSdWxlRGVjbGFyYXRpb24sXG4gIGluY29uc2lzdGVudEFyaXR5LFxuICBpbmNvcnJlY3RBcmd1bWVudFR5cGUsXG4gIGludGVydmFsU291cmNlc0RvbnRNYXRjaCxcbiAgaW52YWxpZENvbnN0cnVjdG9yQ2FsbCxcbiAgaW52YWxpZFBhcmFtZXRlcixcbiAgZ3JhbW1hclN5bnRheEVycm9yLFxuICBrbGVlbmVFeHBySGFzTnVsbGFibGVPcGVyYW5kLFxuICBtaXNzaW5nU2VtYW50aWNBY3Rpb24sXG4gIG11bHRpcGxlU3VwZXJTcGxpY2VzLFxuICB1bmRlY2xhcmVkR3JhbW1hcixcbiAgdW5kZWNsYXJlZFJ1bGUsXG4gIHdyb25nTnVtYmVyT2ZBcmd1bWVudHMsXG4gIHdyb25nTnVtYmVyT2ZQYXJhbWV0ZXJzLFxuXG4gIHRocm93RXJyb3JzKGVycm9ycykge1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcnNbMF07XG4gICAgfVxuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbXVsdGlwbGVFcnJvcnMoZXJyb3JzKTtcbiAgICB9XG4gIH1cbn07XG4iLCIvKiBnbG9iYWwgZG9jdW1lbnQsIFhNTEh0dHBSZXF1ZXN0ICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKTtcbmNvbnN0IEdyYW1tYXIgPSByZXF1aXJlKCcuL0dyYW1tYXInKTtcbmNvbnN0IE5hbWVzcGFjZSA9IHJlcXVpcmUoJy4vTmFtZXNwYWNlJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbmNvbnN0IGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBUaGUgbWV0YWdyYW1tYXIsIGkuZS4gdGhlIGdyYW1tYXIgZm9yIE9obSBncmFtbWFycy4gSW5pdGlhbGl6ZWQgYXQgdGhlXG4vLyBib3R0b20gb2YgdGhpcyBmaWxlIGJlY2F1c2UgbG9hZGluZyB0aGUgZ3JhbW1hciByZXF1aXJlcyBPaG0gaXRzZWxmLlxubGV0IG9obUdyYW1tYXI7XG5cbi8vIEFuIG9iamVjdCB3aGljaCBtYWtlcyBpdCBwb3NzaWJsZSB0byBzdHViIG91dCB0aGUgZG9jdW1lbnQgQVBJIGZvciB0ZXN0aW5nLlxubGV0IGRvY3VtZW50SW50ZXJmYWNlID0ge1xuICBxdWVyeVNlbGVjdG9yKHNlbCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWwpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsKHNlbCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWwpOyB9XG59O1xuXG5jb25zdCBzdXBlclNwbGljZVBsYWNlaG9sZGVyID0gT2JqZWN0LmNyZWF0ZShwZXhwcnMuUEV4cHIucHJvdG90eXBlKTtcblxuLy8gQ2hlY2sgaWYgYG9iamAgaXMgYSBET00gZWxlbWVudC5cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXZvaWRcbn1cblxuY29uc3QgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbn1cblxuLy8gVE9ETzoganVzdCB1c2UgdGhlIGpRdWVyeSB0aGluZ1xuZnVuY3Rpb24gbG9hZCh1cmwpIHtcbiAgY29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcS5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgdHJ5IHtcbiAgICByZXEuc2VuZCgpO1xuICAgIGlmIChyZXEuc3RhdHVzID09PSAwIHx8IHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgcmV0dXJuIHJlcS5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2FkIHVybCAnICsgdXJsKTtcbn1cblxuLy8gUmV0dXJucyBhIEdyYW1tYXIgaW5zdGFuY2UgKGkuZS4sIGFuIG9iamVjdCB3aXRoIGEgYG1hdGNoYCBtZXRob2QpIGZvclxuLy8gYHRyZWVgLCB3aGljaCBpcyB0aGUgY29uY3JldGUgc3ludGF4IHRyZWUgb2YgYSB1c2VyLXdyaXR0ZW4gZ3JhbW1hci5cbi8vIFRoZSBncmFtbWFyIHdpbGwgYmUgYXNzaWduZWQgaW50byBgbmFtZXNwYWNlYCB1bmRlciB0aGUgbmFtZSBvZiB0aGUgZ3JhbW1hclxuLy8gYXMgc3BlY2lmaWVkIGluIHRoZSBzb3VyY2UuXG5mdW5jdGlvbiBidWlsZEdyYW1tYXIobWF0Y2gsIG5hbWVzcGFjZSwgb3B0T2htR3JhbW1hckZvclRlc3RpbmcpIHtcbiAgY29uc3QgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gIGxldCBkZWNsO1xuICBsZXQgY3VycmVudFJ1bGVOYW1lO1xuICBsZXQgY3VycmVudFJ1bGVGb3JtYWxzO1xuICBsZXQgb3ZlcnJpZGluZyA9IGZhbHNlO1xuICBjb25zdCBtZXRhR3JhbW1hciA9IG9wdE9obUdyYW1tYXJGb3JUZXN0aW5nIHx8IG9obUdyYW1tYXI7XG5cbiAgLy8gQSB2aXNpdG9yIHRoYXQgcHJvZHVjZXMgYSBHcmFtbWFyIGluc3RhbmNlIGZyb20gdGhlIENTVC5cbiAgY29uc3QgaGVscGVycyA9IG1ldGFHcmFtbWFyLmNyZWF0ZVNlbWFudGljcygpLmFkZE9wZXJhdGlvbigndmlzaXQnLCB7XG4gICAgR3JhbW1hcihuLCBzLCBvcGVuLCBycywgY2xvc2UpIHtcbiAgICAgIGNvbnN0IGdyYW1tYXJOYW1lID0gbi52aXNpdCgpO1xuICAgICAgZGVjbCA9IGJ1aWxkZXIubmV3R3JhbW1hcihncmFtbWFyTmFtZSwgbmFtZXNwYWNlKTtcbiAgICAgIHMudmlzaXQoKTtcbiAgICAgIHJzLnZpc2l0KCk7XG4gICAgICBjb25zdCBnID0gZGVjbC5idWlsZCgpO1xuICAgICAgZy5zb3VyY2UgPSB0aGlzLnNvdXJjZS50cmltbWVkKCk7XG4gICAgICBpZiAoZ3JhbW1hck5hbWUgaW4gbmFtZXNwYWNlKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5kdXBsaWNhdGVHcmFtbWFyRGVjbGFyYXRpb24oZywgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIG5hbWVzcGFjZVtncmFtbWFyTmFtZV0gPSBnO1xuICAgICAgcmV0dXJuIGc7XG4gICAgfSxcblxuICAgIFN1cGVyR3JhbW1hcihfLCBuKSB7XG4gICAgICBjb25zdCBzdXBlckdyYW1tYXJOYW1lID0gbi52aXNpdCgpO1xuICAgICAgaWYgKHN1cGVyR3JhbW1hck5hbWUgPT09ICdudWxsJykge1xuICAgICAgICBkZWNsLndpdGhTdXBlckdyYW1tYXIobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW5hbWVzcGFjZSB8fCAhKHN1cGVyR3JhbW1hck5hbWUgaW4gbmFtZXNwYWNlKSkge1xuICAgICAgICAgIHRocm93IGVycm9ycy51bmRlY2xhcmVkR3JhbW1hcihzdXBlckdyYW1tYXJOYW1lLCBuYW1lc3BhY2UsIG4uc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNsLndpdGhTdXBlckdyYW1tYXIobmFtZXNwYWNlW3N1cGVyR3JhbW1hck5hbWVdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgUnVsZV9kZWZpbmUobiwgZnMsIGQsIF8sIGIpIHtcbiAgICAgIGN1cnJlbnRSdWxlTmFtZSA9IG4udmlzaXQoKTtcbiAgICAgIGN1cnJlbnRSdWxlRm9ybWFscyA9IGZzLnZpc2l0KClbMF0gfHwgW107XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBkZWZhdWx0IHN0YXJ0IHJ1bGUgeWV0LCBzZXQgaXQgbm93LiBUaGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdmlzaXRpbmdcbiAgICAgIC8vIHRoZSBib2R5LCBiZWNhdXNlIGl0IG1pZ2h0IGNvbnRhaW4gYW4gaW5saW5lIHJ1bGUgZGVmaW5pdGlvbi5cbiAgICAgIGlmICghZGVjbC5kZWZhdWx0U3RhcnRSdWxlICYmIGRlY2wuZW5zdXJlU3VwZXJHcmFtbWFyKCkgIT09IEdyYW1tYXIuUHJvdG9CdWlsdEluUnVsZXMpIHtcbiAgICAgICAgZGVjbC53aXRoRGVmYXVsdFN0YXJ0UnVsZShjdXJyZW50UnVsZU5hbWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IGIudmlzaXQoKTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZC52aXNpdCgpWzBdO1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UudHJpbW1lZCgpO1xuICAgICAgcmV0dXJuIGRlY2wuZGVmaW5lKGN1cnJlbnRSdWxlTmFtZSwgY3VycmVudFJ1bGVGb3JtYWxzLCBib2R5LCBkZXNjcmlwdGlvbiwgc291cmNlKTtcbiAgICB9LFxuICAgIFJ1bGVfb3ZlcnJpZGUobiwgZnMsIF8sIGIpIHtcbiAgICAgIGN1cnJlbnRSdWxlTmFtZSA9IG4udmlzaXQoKTtcbiAgICAgIGN1cnJlbnRSdWxlRm9ybWFscyA9IGZzLnZpc2l0KClbMF0gfHwgW107XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLnRyaW1tZWQoKTtcbiAgICAgIGRlY2wuZW5zdXJlU3VwZXJHcmFtbWFyUnVsZUZvck92ZXJyaWRpbmcoY3VycmVudFJ1bGVOYW1lLCBzb3VyY2UpO1xuXG4gICAgICBvdmVycmlkaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGJvZHkgPSBiLnZpc2l0KCk7XG4gICAgICBvdmVycmlkaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gZGVjbC5vdmVycmlkZShjdXJyZW50UnVsZU5hbWUsIGN1cnJlbnRSdWxlRm9ybWFscywgYm9keSwgbnVsbCwgc291cmNlKTtcbiAgICB9LFxuICAgIFJ1bGVfZXh0ZW5kKG4sIGZzLCBfLCBiKSB7XG4gICAgICBjdXJyZW50UnVsZU5hbWUgPSBuLnZpc2l0KCk7XG4gICAgICBjdXJyZW50UnVsZUZvcm1hbHMgPSBmcy52aXNpdCgpWzBdIHx8IFtdO1xuICAgICAgY29uc3QgYm9keSA9IGIudmlzaXQoKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLnRyaW1tZWQoKTtcbiAgICAgIHJldHVybiBkZWNsLmV4dGVuZChjdXJyZW50UnVsZU5hbWUsIGN1cnJlbnRSdWxlRm9ybWFscywgYm9keSwgbnVsbCwgc291cmNlKTtcbiAgICB9LFxuICAgIFJ1bGVCb2R5KF8sIHRlcm1zKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGVybXMudmlzaXQoKTtcbiAgICAgIHJldHVybiBidWlsZGVyLmFsdC5hcHBseShidWlsZGVyLCBhcmdzKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIE92ZXJyaWRlUnVsZUJvZHkoXywgdGVybXMpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0ZXJtcy52aXNpdCgpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgc3VwZXItc3BsaWNlIG9wZXJhdG9yIChgLi4uYCkgYXBwZWFycyBpbiB0aGUgdGVybXMuXG4gICAgICBjb25zdCBleHBhbnNpb25Qb3MgPSBhcmdzLmluZGV4T2Yoc3VwZXJTcGxpY2VQbGFjZWhvbGRlcik7XG4gICAgICBpZiAoZXhwYW5zaW9uUG9zID49IDApIHtcbiAgICAgICAgY29uc3QgYmVmb3JlVGVybXMgPSBhcmdzLnNsaWNlKDAsIGV4cGFuc2lvblBvcyk7XG4gICAgICAgIGNvbnN0IGFmdGVyVGVybXMgPSBhcmdzLnNsaWNlKGV4cGFuc2lvblBvcyArIDEpO1xuXG4gICAgICAgIC8vIEVuc3VyZSBpdCBhcHBlYXJzIG5vIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBhZnRlclRlcm1zLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgaWYgKHQgPT09IHN1cGVyU3BsaWNlUGxhY2Vob2xkZXIpIHRocm93IGVycm9ycy5tdWx0aXBsZVN1cGVyU3BsaWNlcyh0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBwZXhwcnMuU3BsaWNlKFxuICAgICAgICAgICAgZGVjbC5zdXBlckdyYW1tYXIsIGN1cnJlbnRSdWxlTmFtZSwgYmVmb3JlVGVybXMsIGFmdGVyVGVybXMpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuYWx0LmFwcGx5KGJ1aWxkZXIsIGFyZ3MpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgRm9ybWFscyhvcG9pbnR5LCBmcywgY3BvaW50eSkge1xuICAgICAgcmV0dXJuIGZzLnZpc2l0KCk7XG4gICAgfSxcblxuICAgIFBhcmFtcyhvcG9pbnR5LCBwcywgY3BvaW50eSkge1xuICAgICAgcmV0dXJuIHBzLnZpc2l0KCk7XG4gICAgfSxcblxuICAgIEFsdChzZXFzKSB7XG4gICAgICBjb25zdCBhcmdzID0gc2Vxcy52aXNpdCgpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuYWx0LmFwcGx5KGJ1aWxkZXIsIGFyZ3MpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG5cbiAgICBUb3BMZXZlbFRlcm1faW5saW5lKGIsIG4pIHtcbiAgICAgIGNvbnN0IGlubGluZVJ1bGVOYW1lID0gY3VycmVudFJ1bGVOYW1lICsgJ18nICsgbi52aXNpdCgpO1xuICAgICAgY29uc3QgYm9keSA9IGIudmlzaXQoKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLnRyaW1tZWQoKTtcbiAgICAgIGNvbnN0IGlzTmV3UnVsZURlY2xhcmF0aW9uID1cbiAgICAgICAgICAhKGRlY2wuc3VwZXJHcmFtbWFyICYmIGRlY2wuc3VwZXJHcmFtbWFyLnJ1bGVzW2lubGluZVJ1bGVOYW1lXSk7XG4gICAgICBpZiAob3ZlcnJpZGluZyAmJiAhaXNOZXdSdWxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgZGVjbC5vdmVycmlkZShpbmxpbmVSdWxlTmFtZSwgY3VycmVudFJ1bGVGb3JtYWxzLCBib2R5LCBudWxsLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjbC5kZWZpbmUoaW5saW5lUnVsZU5hbWUsIGN1cnJlbnRSdWxlRm9ybWFscywgYm9keSwgbnVsbCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmFtcyA9IGN1cnJlbnRSdWxlRm9ybWFscy5tYXAoZm9ybWFsID0+IGJ1aWxkZXIuYXBwKGZvcm1hbCkpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuYXBwKGlubGluZVJ1bGVOYW1lLCBwYXJhbXMpLndpdGhTb3VyY2UoYm9keS5zb3VyY2UpO1xuICAgIH0sXG4gICAgT3ZlcnJpZGVUb3BMZXZlbFRlcm1fc3VwZXJTcGxpY2UoXykge1xuICAgICAgcmV0dXJuIHN1cGVyU3BsaWNlUGxhY2Vob2xkZXI7XG4gICAgfSxcblxuICAgIFNlcShleHByKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5zZXEuYXBwbHkoYnVpbGRlciwgZXhwci52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuXG4gICAgSXRlcl9zdGFyKHgsIF8pIHtcbiAgICAgIHJldHVybiBidWlsZGVyLnN0YXIoeC52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuICAgIEl0ZXJfcGx1cyh4LCBfKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5wbHVzKHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBJdGVyX29wdCh4LCBfKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5vcHQoeC52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuXG4gICAgUHJlZF9ub3QoXywgeCkge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIubm90KHgudmlzaXQoKSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBQcmVkX2xvb2thaGVhZChfLCB4KSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5sb29rYWhlYWQoeC52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuXG4gICAgTGV4X2xleChfLCB4KSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5sZXgoeC52aXNpdCgpKS53aXRoU291cmNlKHRoaXMuc291cmNlKTtcbiAgICB9LFxuXG4gICAgQmFzZV9hcHBsaWNhdGlvbihydWxlLCBwcykge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuYXBwKHJ1bGUudmlzaXQoKSwgcHMudmlzaXQoKVswXSB8fCBbXSkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gICAgfSxcbiAgICBCYXNlX3JhbmdlKGZyb20sIF8sIHRvKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci5yYW5nZShmcm9tLnZpc2l0KCksIHRvLnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgQmFzZV90ZXJtaW5hbChleHByKSB7XG4gICAgICByZXR1cm4gYnVpbGRlci50ZXJtaW5hbChleHByLnZpc2l0KCkpLndpdGhTb3VyY2UodGhpcy5zb3VyY2UpO1xuICAgIH0sXG4gICAgQmFzZV9wYXJlbihvcGVuLCB4LCBjbG9zZSkge1xuICAgICAgcmV0dXJuIHgudmlzaXQoKTtcbiAgICB9LFxuXG4gICAgcnVsZURlc2NyKG9wZW4sIHQsIGNsb3NlKSB7XG4gICAgICByZXR1cm4gdC52aXNpdCgpO1xuICAgIH0sXG4gICAgcnVsZURlc2NyVGV4dChfKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VTdHJpbmcudHJpbSgpO1xuICAgIH0sXG5cbiAgICBjYXNlTmFtZShfLCBzcGFjZTEsIG4sIHNwYWNlMiwgZW5kKSB7XG4gICAgICByZXR1cm4gbi52aXNpdCgpO1xuICAgIH0sXG5cbiAgICBuYW1lKGZpcnN0LCByZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VTdHJpbmc7XG4gICAgfSxcbiAgICBuYW1lRmlyc3QoZXhwcikge30sXG4gICAgbmFtZVJlc3QoZXhwcikge30sXG5cbiAgICB0ZXJtaW5hbChvcGVuLCBjcywgY2xvc2UpIHtcbiAgICAgIHJldHVybiBjcy52aXNpdCgpLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBvbmVDaGFyVGVybWluYWwob3BlbiwgYywgY2xvc2UpIHtcbiAgICAgIHJldHVybiBjLnZpc2l0KCk7XG4gICAgfSxcblxuICAgIHRlcm1pbmFsQ2hhcihfKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnVuZXNjYXBlQ2hhcih0aGlzLnNvdXJjZVN0cmluZyk7XG4gICAgfSxcblxuICAgIGVzY2FwZUNoYXIoXykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3RyaW5nO1xuICAgIH0sXG5cbiAgICBOb25lbXB0eUxpc3RPZih4LCBfLCB4cykge1xuICAgICAgcmV0dXJuIFt4LnZpc2l0KCldLmNvbmNhdCh4cy52aXNpdCgpKTtcbiAgICB9LFxuICAgIEVtcHR5TGlzdE9mKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICBfdGVybWluYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmltaXRpdmVWYWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaGVscGVycyhtYXRjaCkudmlzaXQoKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZUFuZExvYWQoc291cmNlLCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgbSA9IG9obUdyYW1tYXIubWF0Y2goc291cmNlLCAnR3JhbW1hcnMnKTtcbiAgaWYgKG0uZmFpbGVkKCkpIHtcbiAgICB0aHJvdyBlcnJvcnMuZ3JhbW1hclN5bnRheEVycm9yKG0pO1xuICB9XG4gIHJldHVybiBidWlsZEdyYW1tYXIobSwgbmFtZXNwYWNlKTtcbn1cblxuLy8gUmV0dXJuIHRoZSBjb250ZW50cyBvZiBhIHNjcmlwdCBlbGVtZW50LCBmZXRjaGluZyBpdCB2aWEgWEhSIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGdldFNjcmlwdEVsZW1lbnRDb250ZW50cyhlbCkge1xuICBpZiAoIWlzRWxlbWVudChlbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIERPTSBOb2RlLCBnb3QgJyArIGNvbW1vbi51bmV4cGVjdGVkT2JqVG9TdHJpbmcoZWwpKTtcbiAgfVxuICBpZiAoZWwudHlwZSAhPT0gJ3RleHQvb2htLWpzJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBzY3JpcHQgdGFnIHdpdGggdHlwZT1cInRleHQvb2htLWpzXCIsIGdvdCAnICsgZWwpO1xuICB9XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ3NyYycpID8gbG9hZChlbC5nZXRBdHRyaWJ1dGUoJ3NyYycpKSA6IGVsLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gZ3JhbW1hcihzb3VyY2UsIG9wdE5hbWVzcGFjZSkge1xuICBjb25zdCBucyA9IGdyYW1tYXJzKHNvdXJjZSwgb3B0TmFtZXNwYWNlKTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgc291cmNlIGNvbnRhaW5lZCBubyBtb3JlIHRoYW4gb25lIGdyYW1tYXIgZGVmaW5pdGlvbi5cbiAgY29uc3QgZ3JhbW1hck5hbWVzID0gT2JqZWN0LmtleXMobnMpO1xuICBpZiAoZ3JhbW1hck5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBncmFtbWFyIGRlZmluaXRpb24nKTtcbiAgfSBlbHNlIGlmIChncmFtbWFyTmFtZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHNlY29uZEdyYW1tYXIgPSBuc1tncmFtbWFyTmFtZXNbMV1dO1xuICAgIGNvbnN0IGludGVydmFsID0gc2Vjb25kR3JhbW1hci5zb3VyY2U7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB1dGlsLmdldExpbmVBbmRDb2x1bW5NZXNzYWdlKGludGVydmFsLnNvdXJjZVN0cmluZywgaW50ZXJ2YWwuc3RhcnRJZHgpICtcbiAgICAgICAgJ0ZvdW5kIG1vcmUgdGhhbiBvbmUgZ3JhbW1hciBkZWZpbml0aW9uIC0tIHVzZSBvaG0uZ3JhbW1hcnMoKSBpbnN0ZWFkLicpO1xuICB9XG4gIHJldHVybiBuc1tncmFtbWFyTmFtZXNbMF1dOyAvLyBSZXR1cm4gdGhlIG9uZSBhbmQgb25seSBncmFtbWFyLlxufVxuXG5mdW5jdGlvbiBncmFtbWFycyhzb3VyY2UsIG9wdE5hbWVzcGFjZSkge1xuICBjb25zdCBucyA9IE5hbWVzcGFjZS5leHRlbmQoTmFtZXNwYWNlLmFzTmFtZXNwYWNlKG9wdE5hbWVzcGFjZSkpO1xuICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBGb3IgY29udmVuaWVuY2UsIGRldGVjdCBOb2RlLmpzIEJ1ZmZlciBvYmplY3RzIGFuZCBhdXRvbWF0aWNhbGx5IGNhbGwgdG9TdHJpbmcoKS5cbiAgICBpZiAoaXNCdWZmZXIoc291cmNlKSkge1xuICAgICAgc291cmNlID0gc291cmNlLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIHN0cmluZyBhcyBmaXJzdCBhcmd1bWVudCwgZ290ICcgKyBjb21tb24udW5leHBlY3RlZE9ialRvU3RyaW5nKHNvdXJjZSkpO1xuICAgIH1cbiAgfVxuICBjb21waWxlQW5kTG9hZChzb3VyY2UsIG5zKTtcbiAgcmV0dXJuIG5zO1xufVxuXG5mdW5jdGlvbiBncmFtbWFyRnJvbVNjcmlwdEVsZW1lbnQob3B0Tm9kZSkge1xuICBsZXQgbm9kZSA9IG9wdE5vZGU7XG4gIGlmIChpc1VuZGVmaW5lZChub2RlKSkge1xuICAgIGNvbnN0IG5vZGVMaXN0ID0gZG9jdW1lbnRJbnRlcmZhY2UucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W3R5cGU9XCJ0ZXh0L29obS1qc1wiXScpO1xuICAgIGlmIChub2RlTGlzdC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXhwZWN0ZWQgZXhhY3RseSBvbmUgc2NyaXB0IHRhZyB3aXRoIHR5cGU9XCJ0ZXh0L29obS1qc1wiLCBmb3VuZCAnICsgbm9kZUxpc3QubGVuZ3RoKTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGVMaXN0WzBdO1xuICB9XG4gIHJldHVybiBncmFtbWFyKGdldFNjcmlwdEVsZW1lbnRDb250ZW50cyhub2RlKSk7XG59XG5cbmZ1bmN0aW9uIGdyYW1tYXJzRnJvbVNjcmlwdEVsZW1lbnRzKG9wdE5vZGVPck5vZGVMaXN0KSB7XG4gIC8vIFNpbXBsZSBjYXNlOiB0aGUgYXJndW1lbnQgaXMgYSBET00gbm9kZS5cbiAgaWYgKGlzRWxlbWVudChvcHROb2RlT3JOb2RlTGlzdCkpIHtcbiAgICByZXR1cm4gZ3JhbW1hcnMob3B0Tm9kZU9yTm9kZUxpc3QpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgaXQgbXVzdCBiZSBlaXRoZXIgdW5kZWZpbmVkIG9yIGEgTm9kZUxpc3QuXG4gIGxldCBub2RlTGlzdCA9IG9wdE5vZGVPck5vZGVMaXN0O1xuICBpZiAoaXNVbmRlZmluZWQobm9kZUxpc3QpKSB7XG4gICAgLy8gRmluZCBhbGwgc2NyaXB0IGVsZW1lbnRzIHdpdGggdHlwZT1cInRleHQvb2htLWpzXCIuXG4gICAgbm9kZUxpc3QgPSBkb2N1bWVudEludGVyZmFjZS5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbdHlwZT1cInRleHQvb2htLWpzXCJdJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVMaXN0ID09PSAnc3RyaW5nJyB8fCAoIWlzRWxlbWVudChub2RlTGlzdCkgJiYgIWlzQXJyYXlMaWtlKG5vZGVMaXN0KSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIE5vZGUsIE5vZGVMaXN0LCBvciBBcnJheSwgYnV0IGdvdCAnICsgbm9kZUxpc3QpO1xuICB9XG4gIGNvbnN0IG5zID0gTmFtZXNwYWNlLmNyZWF0ZU5hbWVzcGFjZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgLy8gQ29weSB0aGUgbmV3IGdyYW1tYXJzIGludG8gYG5zYCB0byBrZWVwIHRoZSBuYW1lc3BhY2UgZmxhdC5cbiAgICBjb21tb24uZXh0ZW5kKG5zLCBncmFtbWFycyhnZXRTY3JpcHRFbGVtZW50Q29udGVudHMobm9kZUxpc3RbaV0pLCBucykpO1xuICB9XG4gIHJldHVybiBucztcbn1cblxuZnVuY3Rpb24gbWFrZVJlY2lwZShyZWNpcGUpIHtcbiAgaWYgKHR5cGVvZiByZWNpcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVjaXBlLmNhbGwobmV3IEJ1aWxkZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiByZWNpcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBzdHJpbmdpZmllZCBKU09OIHJlY2lwZVxuICAgICAgcmVjaXBlID0gSlNPTi5wYXJzZShyZWNpcGUpO1xuICAgIH1cbiAgICByZXR1cm4gKG5ldyBCdWlsZGVyKCkpLmZyb21SZWNpcGUocmVjaXBlKTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gU3R1ZmYgdGhhdCB1c2VycyBzaG91bGQga25vdyBhYm91dFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZU5hbWVzcGFjZTogTmFtZXNwYWNlLmNyZWF0ZU5hbWVzcGFjZSxcbiAgZ3JhbW1hcixcbiAgZ3JhbW1hcnMsXG4gIGdyYW1tYXJGcm9tU2NyaXB0RWxlbWVudCxcbiAgZ3JhbW1hcnNGcm9tU2NyaXB0RWxlbWVudHMsXG4gIG1ha2VSZWNpcGUsXG4gIG9obUdyYW1tYXI6IG51bGwsIC8vIEluaXRpYWxpemVkIGJlbG93LCBhZnRlciBHcmFtbWFyLkJ1aWx0SW5SdWxlcy5cbiAgcGV4cHJzLFxuICB1dGlsLFxuICBleHRyYXM6IHJlcXVpcmUoJy4uL2V4dHJhcycpLFxuICB2ZXJzaW9uXG59O1xuXG4vLyBTdHVmZiBmb3IgdGVzdGluZywgZXRjLlxubW9kdWxlLmV4cG9ydHMuX2J1aWxkR3JhbW1hciA9IGJ1aWxkR3JhbW1hcjtcbm1vZHVsZS5leHBvcnRzLl9zZXREb2N1bWVudEludGVyZmFjZUZvclRlc3RpbmcgPSBmdW5jdGlvbihkb2MpIHsgZG9jdW1lbnRJbnRlcmZhY2UgPSBkb2M7IH07XG5cbi8vIExhdGUgaW5pdGlhbGl6YXRpb24gZm9yIHN0dWZmIHRoYXQgaXMgYm9vdHN0cmFwcGVkLlxuXG5HcmFtbWFyLkJ1aWx0SW5SdWxlcyA9IHJlcXVpcmUoJy4uL2Rpc3QvYnVpbHQtaW4tcnVsZXMnKTtcbnV0aWwuYW5ub3VuY2VCdWlsdEluUnVsZXMoR3JhbW1hci5CdWlsdEluUnVsZXMpO1xuXG5tb2R1bGUuZXhwb3J0cy5vaG1HcmFtbWFyID0gb2htR3JhbW1hciA9IHJlcXVpcmUoJy4uL2Rpc3Qvb2htLWdyYW1tYXInKTtcbkdyYW1tYXIuaW5pdEFwcGxpY2F0aW9uUGFyc2VyKG9obUdyYW1tYXIsIGJ1aWxkR3JhbW1hcik7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jbGFzcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZ3JhbW1hciwgY3Rvck5hbWUsIG1hdGNoTGVuZ3RoKSB7XG4gICAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgICB0aGlzLmN0b3JOYW1lID0gY3Rvck5hbWU7XG4gICAgdGhpcy5tYXRjaExlbmd0aCA9IG1hdGNoTGVuZ3RoO1xuICB9XG5cbiAgbnVtQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuLmxlbmd0aCA6IDA7XG4gIH1cblxuICBjaGlsZEF0KGlkeCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpZHhdO1xuICAgIH1cbiAgfVxuXG4gIGluZGV4T2ZDaGlsZChhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGFyZyk7XG4gIH1cblxuICBoYXNDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5udW1DaGlsZHJlbigpID4gMTtcbiAgfVxuXG4gIGhhc05vQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuICF0aGlzLmhhc0NoaWxkcmVuKCk7XG4gIH1cblxuICBvbmx5Q2hpbGQoKSB7XG4gICAgaWYgKHRoaXMubnVtQ2hpbGRyZW4oKSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdjYW5ub3QgZ2V0IG9ubHkgY2hpbGQgb2YgYSBub2RlIG9mIHR5cGUgJyArIHRoaXMuY3Rvck5hbWUgK1xuICAgICAgICAgICcgKGl0IGhhcyAnICsgdGhpcy5udW1DaGlsZHJlbigpICsgJyBjaGlsZHJlbiknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmlyc3RDaGlsZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZpcnN0Q2hpbGQoKSB7XG4gICAgaWYgKHRoaXMuaGFzTm9DaGlsZHJlbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBnZXQgZmlyc3QgY2hpbGQgb2YgYSAnICsgdGhpcy5jdG9yTmFtZSArICcgbm9kZSwgd2hpY2ggaGFzIG5vIGNoaWxkcmVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoMCk7XG4gICAgfVxuICB9XG5cbiAgbGFzdENoaWxkKCkge1xuICAgIGlmICh0aGlzLmhhc05vQ2hpbGRyZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdjYW5ub3QgZ2V0IGxhc3QgY2hpbGQgb2YgYSAnICsgdGhpcy5jdG9yTmFtZSArICcgbm9kZSwgd2hpY2ggaGFzIG5vIGNoaWxkcmVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQodGhpcy5udW1DaGlsZHJlbigpIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgY2hpbGRCZWZvcmUoY2hpbGQpIHtcbiAgICBjb25zdCBjaGlsZElkeCA9IHRoaXMuaW5kZXhPZkNoaWxkKGNoaWxkKTtcbiAgICBpZiAoY2hpbGRJZHggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUuY2hpbGRCZWZvcmUoKSBjYWxsZWQgdy8gYW4gYXJndW1lbnQgdGhhdCBpcyBub3QgYSBjaGlsZCcpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRJZHggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBjaGlsZCBiZWZvcmUgZmlyc3QgY2hpbGQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRBdChjaGlsZElkeCAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIGNoaWxkQWZ0ZXIoY2hpbGQpIHtcbiAgICBjb25zdCBjaGlsZElkeCA9IHRoaXMuaW5kZXhPZkNoaWxkKGNoaWxkKTtcbiAgICBpZiAoY2hpbGRJZHggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUuY2hpbGRBZnRlcigpIGNhbGxlZCB3LyBhbiBhcmd1bWVudCB0aGF0IGlzIG5vdCBhIGNoaWxkJyk7XG4gICAgfSBlbHNlIGlmIChjaGlsZElkeCA9PT0gdGhpcy5udW1DaGlsZHJlbigpIC0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2V0IGNoaWxkIGFmdGVyIGxhc3QgY2hpbGQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRBdChjaGlsZElkeCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIGlzVGVybWluYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNOb250ZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0l0ZXJhdGlvbigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1t0aGlzLmN0b3JOYW1lXTogdGhpcy5jaGlsZHJlbn07XG4gIH1cbn1cblxuLy8gVGVybWluYWxzXG5cbmNsYXNzIFRlcm1pbmFsTm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihncmFtbWFyLCB2YWx1ZSkge1xuICAgIGNvbnN0IG1hdGNoTGVuZ3RoID0gdmFsdWUgPyB2YWx1ZS5sZW5ndGggOiAwO1xuICAgIHN1cGVyKGdyYW1tYXIsICdfdGVybWluYWwnLCBtYXRjaExlbmd0aCk7XG4gICAgdGhpcy5wcmltaXRpdmVWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgaXNUZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1t0aGlzLmN0b3JOYW1lXTogdGhpcy5wcmltaXRpdmVWYWx1ZX07XG4gIH1cbn1cblxuLy8gTm9udGVybWluYWxzXG5cbmNsYXNzIE5vbnRlcm1pbmFsTm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihncmFtbWFyLCBydWxlTmFtZSwgY2hpbGRyZW4sIGNoaWxkT2Zmc2V0cywgbWF0Y2hMZW5ndGgpIHtcbiAgICBzdXBlcihncmFtbWFyLCBydWxlTmFtZSwgbWF0Y2hMZW5ndGgpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmNoaWxkT2Zmc2V0cyA9IGNoaWxkT2Zmc2V0cztcbiAgfVxuXG4gIGlzTm9udGVybWluYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc0xleGljYWwoKSB7XG4gICAgcmV0dXJuIGNvbW1vbi5pc0xleGljYWwodGhpcy5jdG9yTmFtZSk7XG4gIH1cblxuICBpc1N5bnRhY3RpYygpIHtcbiAgICByZXR1cm4gY29tbW9uLmlzU3ludGFjdGljKHRoaXMuY3Rvck5hbWUpO1xuICB9XG59XG5cbi8vIEl0ZXJhdGlvbnNcblxuY2xhc3MgSXRlcmF0aW9uTm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihncmFtbWFyLCBjaGlsZHJlbiwgY2hpbGRPZmZzZXRzLCBtYXRjaExlbmd0aCwgaXNPcHRpb25hbCkge1xuICAgIHN1cGVyKGdyYW1tYXIsICdfaXRlcicsIG1hdGNoTGVuZ3RoKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5jaGlsZE9mZnNldHMgPSBjaGlsZE9mZnNldHM7XG4gICAgdGhpcy5vcHRpb25hbCA9IGlzT3B0aW9uYWw7XG4gIH1cblxuICBpc0l0ZXJhdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWw7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBOb2RlLFxuICBUZXJtaW5hbE5vZGUsXG4gIE5vbnRlcm1pbmFsTm9kZSxcbiAgSXRlcmF0aW9uTm9kZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgUmV0dXJuIHRydWUgaWYgd2Ugc2hvdWxkIHNraXAgc3BhY2VzIHByZWNlZGluZyB0aGlzIGV4cHJlc3Npb24gaW4gYSBzeW50YWN0aWMgY29udGV4dC5cbiovXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPSBjb21tb24uYWJzdHJhY3QoXG4gICAgJ2FsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UnXG4pO1xuXG4vKlxuICBHZW5lcmFsbHksIHRoZXNlIGFyZSBhbGwgZmlyc3Qtb3JkZXIgZXhwcmVzc2lvbnMgYW5kICh3aXRoIHRoZSBleGNlcHRpb24gb2YgQXBwbHkpXG4gIGRpcmVjdGx5IHJlYWQgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLlxuKi9cbnBleHBycy5hbnkuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuZW5kLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLypcbiAgSGlnaGVyLW9yZGVyIGV4cHJlc3Npb25zIHRoYXQgZG9uJ3QgZGlyZWN0bHkgY29uc3VtZSBpbnB1dC5cbiovXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5JdGVyLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5MZXgucHJvdG90eXBlLmFsbG93c1NraXBwaW5nUHJlY2VkaW5nU3BhY2UgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZSA9XG5wZXhwcnMuU2VxLnByb3RvdHlwZS5hbGxvd3NTa2lwcGluZ1ByZWNlZGluZ1NwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBCdWlsdEluUnVsZXM7XG5cbnV0aWwuYXdhaXRCdWlsdEluUnVsZXMoZyA9PiB7IEJ1aWx0SW5SdWxlcyA9IGc7IH0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubGV0IGxleGlmeUNvdW50O1xuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmFzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgbGV4aWZ5Q291bnQgPSAwO1xuICB0aGlzLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG59O1xuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9IGNvbW1vbi5hYnN0cmFjdChcbiAgICAnX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkJ1xuKTtcblxucGV4cHJzLmFueS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLmVuZC5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBmdW5jdGlvbihydWxlTmFtZSwgZ3JhbW1hcikge1xuICAvLyBuby1vcFxufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgbGV4aWZ5Q291bnQrKztcbiAgdGhpcy5leHByLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZChydWxlTmFtZSwgZ3JhbW1hcik7XG4gIGxleGlmeUNvdW50LS07XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBmdW5jdGlvbihydWxlTmFtZSwgZ3JhbW1hcikge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnRlcm1zLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLnRlcm1zW2lkeF0uX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbiAgfVxufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5mYWN0b3JzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLmZhY3RvcnNbaWR4XS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xuICB9XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID1cbnBleHBycy5Ob3QucHJvdG90eXBlLl9hc3NlcnRBbGxBcHBsaWNhdGlvbnNBcmVWYWxpZCA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQgPSBmdW5jdGlvbihydWxlTmFtZSwgZ3JhbW1hcikge1xuICB0aGlzLmV4cHIuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkKHJ1bGVOYW1lLCBncmFtbWFyKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuX2Fzc2VydEFsbEFwcGxpY2F0aW9uc0FyZVZhbGlkID0gZnVuY3Rpb24ocnVsZU5hbWUsIGdyYW1tYXIpIHtcbiAgY29uc3QgcnVsZUluZm8gPSBncmFtbWFyLnJ1bGVzW3RoaXMucnVsZU5hbWVdO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBydWxlIGV4aXN0cy4uLlxuICBpZiAoIXJ1bGVJbmZvKSB7XG4gICAgdGhyb3cgZXJyb3JzLnVuZGVjbGFyZWRSdWxlKHRoaXMucnVsZU5hbWUsIGdyYW1tYXIubmFtZSwgdGhpcy5zb3VyY2UpO1xuICB9XG5cbiAgLy8gLi4uYW5kIHRoYXQgdGhpcyBhcHBsaWNhdGlvbiBpcyBhbGxvd2VkXG4gIGlmIChjb21tb24uaXNTeW50YWN0aWModGhpcy5ydWxlTmFtZSkgJiYgKCFjb21tb24uaXNTeW50YWN0aWMocnVsZU5hbWUpIHx8IGxleGlmeUNvdW50ID4gMCkpIHtcbiAgICB0aHJvdyBlcnJvcnMuYXBwbGljYXRpb25PZlN5bnRhY3RpY1J1bGVGcm9tTGV4aWNhbENvbnRleHQodGhpcy5ydWxlTmFtZSwgdGhpcyk7XG4gIH1cblxuICAvLyAuLi5hbmQgdGhhdCB0aGlzIGFwcGxpY2F0aW9uIGhhcyB0aGUgY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXG4gIGNvbnN0IGFjdHVhbCA9IHRoaXMuYXJncy5sZW5ndGg7XG4gIGNvbnN0IGV4cGVjdGVkID0gcnVsZUluZm8uZm9ybWFscy5sZW5ndGg7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgdGhyb3cgZXJyb3JzLndyb25nTnVtYmVyT2ZBcmd1bWVudHModGhpcy5ydWxlTmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCwgdGhpcy5zb3VyY2UpO1xuICB9XG5cbiAgLy8gLi4uYW5kIHRoYXQgYWxsIG9mIHRoZSBhcmd1bWVudCBleHByZXNzaW9ucyBvbmx5IGhhdmUgdmFsaWQgYXBwbGljYXRpb25zIGFuZCBoYXZlIGFyaXR5IDEuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICB0aGlzLmFyZ3MuZm9yRWFjaChhcmcgPT4ge1xuICAgIGFyZy5fYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQocnVsZU5hbWUsIGdyYW1tYXIpO1xuICAgIGlmIChhcmcuZ2V0QXJpdHkoKSAhPT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3JzLmludmFsaWRQYXJhbWV0ZXIoc2VsZi5ydWxlTmFtZSwgYXJnKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEV4dHJhIGNoZWNrcyBmb3IgXCJzcGVjaWFsXCIgYXBwbGljYXRpb25zXG5cbiAgLy8gSWYgaXQncyBhbiBhcHBsaWNhdGlvbiBvZiAnY2FzZUluc2Vuc2l0aXZlJywgZW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGEgVGVybWluYWwuXG4gIGlmIChCdWlsdEluUnVsZXMgJiYgcnVsZUluZm8gPT09IEJ1aWx0SW5SdWxlcy5ydWxlcy5jYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBpZiAoISh0aGlzLmFyZ3NbMF0gaW5zdGFuY2VvZiBwZXhwcnMuVGVybWluYWwpKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuaW5jb3JyZWN0QXJndW1lbnRUeXBlKCdhIFRlcm1pbmFsIChlLmcuIFxcXCJhYmNcXFwiKScsIHRoaXMuYXJnc1swXSk7XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGNvbW1vbi5hYnN0cmFjdChcbiAgICAnYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHknXG4pO1xuXG5wZXhwcnMuYW55LmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5lbmQuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9XG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIC8vIG5vLW9wXG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIGlmICh0aGlzLnRlcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhcml0eSA9IHRoaXMudGVybXNbMF0uZ2V0QXJpdHkoKTtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy50ZXJtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgY29uc3QgdGVybSA9IHRoaXMudGVybXNbaWR4XTtcbiAgICB0ZXJtLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5KCk7XG4gICAgY29uc3Qgb3RoZXJBcml0eSA9IHRlcm0uZ2V0QXJpdHkoKTtcbiAgICBpZiAoYXJpdHkgIT09IG90aGVyQXJpdHkpIHtcbiAgICAgIHRocm93IGVycm9ycy5pbmNvbnNpc3RlbnRBcml0eShydWxlTmFtZSwgYXJpdHksIG90aGVyQXJpdHksIHRlcm0pO1xuICAgIH1cbiAgfVxufTtcblxucGV4cHJzLkV4dGVuZC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICAvLyBFeHRlbmQgaXMgYSBzcGVjaWFsIGNhc2Ugb2YgQWx0IHRoYXQncyBndWFyYW50ZWVkIHRvIGhhdmUgZXhhY3RseSB0d29cbiAgLy8gY2FzZXM6IFtleHRlbnNpb25zLCBvcmlnQm9keV0uXG4gIGNvbnN0IGFjdHVhbEFyaXR5ID0gdGhpcy50ZXJtc1swXS5nZXRBcml0eSgpO1xuICBjb25zdCBleHBlY3RlZEFyaXR5ID0gdGhpcy50ZXJtc1sxXS5nZXRBcml0eSgpO1xuICBpZiAoYWN0dWFsQXJpdHkgIT09IGV4cGVjdGVkQXJpdHkpIHtcbiAgICB0aHJvdyBlcnJvcnMuaW5jb25zaXN0ZW50QXJpdHkocnVsZU5hbWUsIGV4cGVjdGVkQXJpdHksIGFjdHVhbEFyaXR5LCB0aGlzLnRlcm1zWzBdKTtcbiAgfVxufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXMuZmFjdG9yc1tpZHhdLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5KHJ1bGVOYW1lKTtcbiAgfVxufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgdGhpcy5leHByLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5KHJ1bGVOYW1lKTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLmFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5ID0gZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgLy8gbm8tb3AgKG5vdCByZXF1aXJlZCBiL2MgdGhlIG5lc3RlZCBleHByIGRvZXNuJ3Qgc2hvdyB1cCBpbiB0aGUgQ1NUKVxufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkgPSBmdW5jdGlvbihydWxlTmFtZSkge1xuICB0aGlzLmV4cHIuYXNzZXJ0Q2hvaWNlc0hhdmVVbmlmb3JtQXJpdHkocnVsZU5hbWUpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5hc3NlcnRDaG9pY2VzSGF2ZVVuaWZvcm1Bcml0eSA9IGZ1bmN0aW9uKHJ1bGVOYW1lKSB7XG4gIC8vIFRoZSBhcml0aWVzIG9mIHRoZSBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgaXMgcmVxdWlyZWQgdG8gYmUgMSBieVxuICAvLyBgYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQoKWAuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBjb21tb24uYWJzdHJhY3QoXG4gICAgJ2Fzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSdcbik7XG5cbnBleHBycy5hbnkuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5lbmQuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICAvLyBuby1vcFxufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnRlcm1zLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzLnRlcm1zW2lkeF0uYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlKGdyYW1tYXIpO1xuICB9XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuZmFjdG9ycy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpcy5mYWN0b3JzW2lkeF0uYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlKGdyYW1tYXIpO1xuICB9XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICAvLyBOb3RlOiB0aGlzIGlzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBmb3IgYFN0YXJgIGFuZCBgUGx1c2AgZXhwcmVzc2lvbnMuXG4gIC8vIEl0IGlzIG92ZXJyaWRkZW4gZm9yIGBPcHRgIGJlbG93LlxuICB0aGlzLmV4cHIuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlKGdyYW1tYXIpO1xuICBpZiAodGhpcy5leHByLmlzTnVsbGFibGUoZ3JhbW1hcikpIHtcbiAgICB0aHJvdyBlcnJvcnMua2xlZW5lRXhwckhhc051bGxhYmxlT3BlcmFuZCh0aGlzLCBbXSk7XG4gIH1cbn07XG5cbnBleHBycy5PcHQucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID1cbnBleHBycy5MZXgucHJvdG90eXBlLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgdGhpcy5leHByLmFzc2VydEl0ZXJhdGVkRXhwcnNBcmVOb3ROdWxsYWJsZShncmFtbWFyKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuYXNzZXJ0SXRlcmF0ZWRFeHByc0FyZU5vdE51bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICB0aGlzLmFyZ3MuZm9yRWFjaChhcmcgPT4ge1xuICAgIGFyZy5hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUoZ3JhbW1hcik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLmNoZWNrID0gY29tbW9uLmFic3RyYWN0KCdjaGVjaycpO1xuXG5wZXhwcnMuYW55LmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFscy5sZW5ndGggPj0gMTtcbn07XG5cbnBleHBycy5lbmQuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB2YWxzWzBdIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSAmJlxuICAgICAgICAgdmFsc1swXS5pc1Rlcm1pbmFsKCkgJiZcbiAgICAgICAgIHZhbHNbMF0ucHJpbWl0aXZlVmFsdWUgPT09IHVuZGVmaW5lZDtcbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB2YWxzWzBdIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSAmJlxuICAgICAgICAgdmFsc1swXS5pc1Rlcm1pbmFsKCkgJiZcbiAgICAgICAgIHZhbHNbMF0ucHJpbWl0aXZlVmFsdWUgPT09IHRoaXMub2JqO1xufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGdyYW1tYXIsIHZhbHMpIHtcbiAgcmV0dXJuIHZhbHNbMF0gaW5zdGFuY2VvZiBub2Rlcy5Ob2RlICYmXG4gICAgICAgICB2YWxzWzBdLmlzVGVybWluYWwoKSAmJlxuICAgICAgICAgdHlwZW9mIHZhbHNbMF0ucHJpbWl0aXZlVmFsdWUgPT09IHR5cGVvZiB0aGlzLmZyb207XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFscy5sZW5ndGggPj0gMTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGVybXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0ZXJtID0gdGhpcy50ZXJtc1tpXTtcbiAgICBpZiAodGVybS5jaGVjayhncmFtbWFyLCB2YWxzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICBsZXQgcG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSB0aGlzLmZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3Rvci5jaGVjayhncmFtbWFyLCB2YWxzLnNsaWNlKHBvcykpKSB7XG4gICAgICBwb3MgKz0gZmFjdG9yLmdldEFyaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIGNvbnN0IGFyaXR5ID0gdGhpcy5nZXRBcml0eSgpO1xuICBjb25zdCBjb2x1bW5zID0gdmFscy5zbGljZSgwLCBhcml0eSk7XG4gIGlmIChjb2x1bW5zLmxlbmd0aCAhPT0gYXJpdHkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm93Q291bnQgPSBjb2x1bW5zWzBdLmxlbmd0aDtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7IGkgPCBhcml0eTsgaSsrKSB7XG4gICAgaWYgKGNvbHVtbnNbaV0ubGVuZ3RoICE9PSByb3dDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcml0eTsgaisrKSB7XG4gICAgICByb3cucHVzaChjb2x1bW5zW2pdW2ldKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmV4cHIuY2hlY2soZ3JhbW1hciwgcm93KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLk5vdC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuY2hlY2sgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihncmFtbWFyLCB2YWxzKSB7XG4gIHJldHVybiB0aGlzLmV4cHIuY2hlY2soZ3JhbW1hciwgdmFscyk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICBpZiAoISh2YWxzWzBdIGluc3RhbmNlb2Ygbm9kZXMuTm9kZSAmJlxuICAgICAgICB2YWxzWzBdLmdyYW1tYXIgPT09IGdyYW1tYXIgJiZcbiAgICAgICAgdmFsc1swXS5jdG9yTmFtZSA9PT0gdGhpcy5ydWxlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUT0RPOiB0aGluayBhYm91dCAqbm90KiBkb2luZyB0aGUgZm9sbG93aW5nIGNoZWNrcywgaS5lLiwgdHJ1c3RpbmcgdGhhdCB0aGUgcnVsZVxuICAvLyB3YXMgY29ycmVjdGx5IGNvbnN0cnVjdGVkLlxuICBjb25zdCBydWxlTm9kZSA9IHZhbHNbMF07XG4gIGNvbnN0IGJvZHkgPSBncmFtbWFyLnJ1bGVzW3RoaXMucnVsZU5hbWVdLmJvZHk7XG4gIHJldHVybiBib2R5LmNoZWNrKGdyYW1tYXIsIHJ1bGVOb2RlLmNoaWxkcmVuKSAmJiBydWxlTm9kZS5udW1DaGlsZHJlbigpID09PSBib2R5LmdldEFyaXR5KCk7XG59O1xuXG5wZXhwcnMuVW5pY29kZUNoYXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oZ3JhbW1hciwgdmFscykge1xuICByZXR1cm4gdmFsc1swXSBpbnN0YW5jZW9mIG5vZGVzLk5vZGUgJiZcbiAgICAgICAgIHZhbHNbMF0uaXNUZXJtaW5hbCgpICYmXG4gICAgICAgICB0eXBlb2YgdmFsc1swXS5wcmltaXRpdmVWYWx1ZSA9PT0gJ3N0cmluZyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL1RyYWNlJyk7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuY29uc3QgVGVybWluYWxOb2RlID0gbm9kZXMuVGVybWluYWxOb2RlO1xuY29uc3QgTm9udGVybWluYWxOb2RlID0gbm9kZXMuTm9udGVybWluYWxOb2RlO1xuY29uc3QgSXRlcmF0aW9uTm9kZSA9IG5vZGVzLkl0ZXJhdGlvbk5vZGU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBFdmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBhbmQgcmV0dXJuIGB0cnVlYCBpZiBpdCBzdWNjZWVkcywgYGZhbHNlYCBvdGhlcndpc2UuIFRoaXMgbWV0aG9kIHNob3VsZFxuICBvbmx5IGJlIGNhbGxlZCBkaXJlY3RseSBieSBgU3RhdGUucHJvdG90eXBlLmV2YWwoZXhwcilgLCB3aGljaCBhbHNvIHVwZGF0ZXMgdGhlIGRhdGEgc3RydWN0dXJlc1xuICB0aGF0IGFyZSB1c2VkIGZvciB0cmFjaW5nLiAoTWFraW5nIHRob3NlIHVwZGF0ZXMgaW4gYSBtZXRob2Qgb2YgYFN0YXRlYCBlbmFibGVzIHRoZSB0cmFjZS1zcGVjaWZpY1xuICBkYXRhIHN0cnVjdHVyZXMgdG8gYmUgXCJzZWNyZXRzXCIgb2YgdGhhdCBjbGFzcywgd2hpY2ggaXMgZ29vZCBmb3IgbW9kdWxhcml0eS4pXG5cbiAgVGhlIGNvbnRyYWN0IG9mIHRoaXMgbWV0aG9kIGlzIGFzIGZvbGxvd3M6XG4gICogV2hlbiB0aGUgcmV0dXJuIHZhbHVlIGlzIGB0cnVlYCxcbiAgICAtIHRoZSBzdGF0ZSBvYmplY3Qgd2lsbCBoYXZlIGBleHByLmdldEFyaXR5KClgIG1vcmUgYmluZGluZ3MgdGhhbiBpdCBkaWQgYmVmb3JlIHRoZSBjYWxsLlxuICAqIFdoZW4gdGhlIHJldHVybiB2YWx1ZSBpcyBgZmFsc2VgLFxuICAgIC0gdGhlIHN0YXRlIG9iamVjdCBtYXkgaGF2ZSBtb3JlIGJpbmRpbmdzIHRoYW4gaXQgZGlkIGJlZm9yZSB0aGUgY2FsbCwgYW5kXG4gICAgLSBpdHMgaW5wdXQgc3RyZWFtJ3MgcG9zaXRpb24gbWF5IGJlIGFueXdoZXJlLlxuXG4gIE5vdGUgdGhhdCBgU3RhdGUucHJvdG90eXBlLmV2YWwoZXhwcilgLCB1bmxpa2UgdGhpcyBtZXRob2QsIGd1YXJhbnRlZXMgdGhhdCBuZWl0aGVyIHRoZSBzdGF0ZVxuICBvYmplY3QncyBiaW5kaW5ncyBub3IgaXRzIGlucHV0IHN0cmVhbSdzIHBvc2l0aW9uIHdpbGwgY2hhbmdlIGlmIHRoZSBleHByZXNzaW9uIGZhaWxzIHRvIG1hdGNoLlxuKi9cbnBleHBycy5QRXhwci5wcm90b3R5cGUuZXZhbCA9IGNvbW1vbi5hYnN0cmFjdCgnZXZhbCcpOyAvLyBmdW5jdGlvbihzdGF0ZSkgeyAuLi4gfVxuXG5wZXhwcnMuYW55LmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBjb25zdCBjaCA9IGlucHV0U3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoKSB7XG4gICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCBjaCksIG9yaWdQb3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLmVuZC5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgaWYgKGlucHV0U3RyZWFtLmF0RW5kKCkpIHtcbiAgICBzdGF0ZS5wdXNoQmluZGluZyhuZXcgVGVybWluYWxOb2RlKHN0YXRlLmdyYW1tYXIsIHVuZGVmaW5lZCksIG9yaWdQb3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgaWYgKCFpbnB1dFN0cmVhbS5tYXRjaFN0cmluZyh0aGlzLm9iaikpIHtcbiAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCB0aGlzLm9iaiksIG9yaWdQb3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBjb25zdCBjaCA9IGlucHV0U3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoICYmIHRoaXMuZnJvbSA8PSBjaCAmJiBjaCA8PSB0aGlzLnRvKSB7XG4gICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCBjaCksIG9yaWdQb3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmV2YWwoc3RhdGUuY3VycmVudEFwcGxpY2F0aW9uKCkuYXJnc1t0aGlzLmluZGV4XSk7XG59O1xuXG5wZXhwcnMuTGV4LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUuZW50ZXJMZXhpZmllZENvbnRleHQoKTtcbiAgY29uc3QgYW5zID0gc3RhdGUuZXZhbCh0aGlzLmV4cHIpO1xuICBzdGF0ZS5leGl0TGV4aWZpZWRDb250ZXh0KCk7XG4gIHJldHVybiBhbnM7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy50ZXJtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgaWYgKHN0YXRlLmV2YWwodGhpcy50ZXJtc1tpZHhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmZhY3RvcnMubGVuZ3RoOyBpZHgrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IHRoaXMuZmFjdG9yc1tpZHhdO1xuICAgIGlmICghc3RhdGUuZXZhbChmYWN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBjb25zdCBhcml0eSA9IHRoaXMuZ2V0QXJpdHkoKTtcbiAgY29uc3QgY29scyA9IFtdO1xuICBjb25zdCBjb2xPZmZzZXRzID0gW107XG4gIHdoaWxlIChjb2xzLmxlbmd0aCA8IGFyaXR5KSB7XG4gICAgY29scy5wdXNoKFtdKTtcbiAgICBjb2xPZmZzZXRzLnB1c2goW10pO1xuICB9XG5cbiAgbGV0IG51bU1hdGNoZXMgPSAwO1xuICBsZXQgcHJldlBvcyA9IG9yaWdQb3M7XG4gIGxldCBpZHg7XG4gIHdoaWxlIChudW1NYXRjaGVzIDwgdGhpcy5tYXhOdW1NYXRjaGVzICYmIHN0YXRlLmV2YWwodGhpcy5leHByKSkge1xuICAgIGlmIChpbnB1dFN0cmVhbS5wb3MgPT09IHByZXZQb3MpIHtcbiAgICAgIHRocm93IGVycm9ycy5rbGVlbmVFeHBySGFzTnVsbGFibGVPcGVyYW5kKHRoaXMsIHN0YXRlLl9hcHBsaWNhdGlvblN0YWNrKTtcbiAgICB9XG4gICAgcHJldlBvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgICBudW1NYXRjaGVzKys7XG4gICAgY29uc3Qgcm93ID0gc3RhdGUuX2JpbmRpbmdzLnNwbGljZShzdGF0ZS5fYmluZGluZ3MubGVuZ3RoIC0gYXJpdHksIGFyaXR5KTtcbiAgICBjb25zdCByb3dPZmZzZXRzID0gc3RhdGUuX2JpbmRpbmdPZmZzZXRzLnNwbGljZShzdGF0ZS5fYmluZGluZ09mZnNldHMubGVuZ3RoIC0gYXJpdHksIGFyaXR5KTtcbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHJvdy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBjb2xzW2lkeF0ucHVzaChyb3dbaWR4XSk7XG4gICAgICBjb2xPZmZzZXRzW2lkeF0ucHVzaChyb3dPZmZzZXRzW2lkeF0pO1xuICAgIH1cbiAgfVxuICBpZiAobnVtTWF0Y2hlcyA8IHRoaXMubWluTnVtTWF0Y2hlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gc3RhdGUucG9zVG9PZmZzZXQob3JpZ1Bvcyk7XG4gIGxldCBtYXRjaExlbmd0aCA9IDA7XG4gIGlmIChudW1NYXRjaGVzID4gMCkge1xuICAgIGNvbnN0IGxhc3RDb2wgPSBjb2xzW2FyaXR5IC0gMV07XG4gICAgY29uc3QgbGFzdENvbE9mZnNldHMgPSBjb2xPZmZzZXRzW2FyaXR5IC0gMV07XG5cbiAgICBjb25zdCBlbmRPZmZzZXQgPVxuICAgICAgICBsYXN0Q29sT2Zmc2V0c1tsYXN0Q29sT2Zmc2V0cy5sZW5ndGggLSAxXSArIGxhc3RDb2xbbGFzdENvbC5sZW5ndGggLSAxXS5tYXRjaExlbmd0aDtcbiAgICBvZmZzZXQgPSBjb2xPZmZzZXRzWzBdWzBdO1xuICAgIG1hdGNoTGVuZ3RoID0gZW5kT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IGlzT3B0aW9uYWwgPSB0aGlzIGluc3RhbmNlb2YgcGV4cHJzLk9wdDtcbiAgZm9yIChpZHggPSAwOyBpZHggPCBjb2xzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBzdGF0ZS5fYmluZGluZ3MucHVzaChcbiAgICAgICAgbmV3IEl0ZXJhdGlvbk5vZGUoc3RhdGUuZ3JhbW1hciwgY29sc1tpZHhdLCBjb2xPZmZzZXRzW2lkeF0sIG1hdGNoTGVuZ3RoLCBpc09wdGlvbmFsKSk7XG4gICAgc3RhdGUuX2JpbmRpbmdPZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAvKlxuICAgIFRPRE86XG4gICAgLSBSaWdodCBub3cgd2UncmUganVzdCB0aHJvd2luZyBhd2F5IGFsbCBvZiB0aGUgZmFpbHVyZXMgdGhhdCBoYXBwZW4gaW5zaWRlIGEgYG5vdGAsIGFuZFxuICAgICAgcmVjb3JkaW5nIGB0aGlzYCBhcyBhIGZhaWxlZCBleHByZXNzaW9uLlxuICAgIC0gRG91YmxlIG5lZ2F0aW9uIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIGxvb2thaGVhZCwgYnV0IHRoYXQncyBub3QgdGhlIGNhc2UgcmlnaHQgbm93IHdydFxuICAgICAgZmFpbHVyZXMuIEUuZy4sIH5+J2ZvbycgcHJvZHVjZXMgYSBmYWlsdXJlIGZvciB+fidmb28nLCBidXQgbWF5YmUgaXQgc2hvdWxkIHByb2R1Y2VcbiAgICAgIGEgZmFpbHVyZSBmb3IgJ2ZvbycgaW5zdGVhZC5cbiAgKi9cblxuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuICBzdGF0ZS5wdXNoRmFpbHVyZXNJbmZvKCk7XG5cbiAgY29uc3QgYW5zID0gc3RhdGUuZXZhbCh0aGlzLmV4cHIpO1xuXG4gIHN0YXRlLnBvcEZhaWx1cmVzSW5mbygpO1xuICBpZiAoYW5zKSB7XG4gICAgc3RhdGUucHJvY2Vzc0ZhaWx1cmUob3JpZ1BvcywgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaW5wdXRTdHJlYW0ucG9zID0gb3JpZ1BvcztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgaWYgKHN0YXRlLmV2YWwodGhpcy5leHByKSkge1xuICAgIGlucHV0U3RyZWFtLnBvcyA9IG9yaWdQb3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBjb25zdCBjYWxsZXIgPSBzdGF0ZS5jdXJyZW50QXBwbGljYXRpb24oKTtcbiAgY29uc3QgYWN0dWFscyA9IGNhbGxlciA/IGNhbGxlci5hcmdzIDogW107XG4gIGNvbnN0IGFwcCA9IHRoaXMuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKTtcblxuICBjb25zdCBwb3NJbmZvID0gc3RhdGUuZ2V0Q3VycmVudFBvc0luZm8oKTtcbiAgaWYgKHBvc0luZm8uaXNBY3RpdmUoYXBwKSkge1xuICAgIC8vIFRoaXMgcnVsZSBpcyBhbHJlYWR5IGFjdGl2ZSBhdCB0aGlzIHBvc2l0aW9uLCBpLmUuLCBpdCBpcyBsZWZ0LXJlY3Vyc2l2ZS5cbiAgICByZXR1cm4gYXBwLmhhbmRsZUN5Y2xlKHN0YXRlKTtcbiAgfVxuXG4gIGNvbnN0IG1lbW9LZXkgPSBhcHAudG9NZW1vS2V5KCk7XG4gIGNvbnN0IG1lbW9SZWMgPSBwb3NJbmZvLm1lbW9bbWVtb0tleV07XG5cbiAgaWYgKG1lbW9SZWMgJiYgcG9zSW5mby5zaG91bGRVc2VNZW1vaXplZFJlc3VsdChtZW1vUmVjKSkge1xuICAgIGlmIChzdGF0ZS5oYXNOZWNlc3NhcnlJbmZvKG1lbW9SZWMpKSB7XG4gICAgICByZXR1cm4gc3RhdGUudXNlTWVtb2l6ZWRSZXN1bHQoc3RhdGUuaW5wdXRTdHJlYW0ucG9zLCBtZW1vUmVjKTtcbiAgICB9XG4gICAgZGVsZXRlIHBvc0luZm8ubWVtb1ttZW1vS2V5XTtcbiAgfVxuICByZXR1cm4gYXBwLnJlYWxseUV2YWwoc3RhdGUpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5oYW5kbGVDeWNsZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IHBvc0luZm8gPSBzdGF0ZS5nZXRDdXJyZW50UG9zSW5mbygpO1xuICBjb25zdCBjdXJyZW50TGVmdFJlY3Vyc2lvbiA9IHBvc0luZm8uY3VycmVudExlZnRSZWN1cnNpb247XG4gIGNvbnN0IG1lbW9LZXkgPSB0aGlzLnRvTWVtb0tleSgpO1xuICBsZXQgbWVtb1JlYyA9IHBvc0luZm8ubWVtb1ttZW1vS2V5XTtcblxuICBpZiAoY3VycmVudExlZnRSZWN1cnNpb24gJiYgY3VycmVudExlZnRSZWN1cnNpb24uaGVhZEFwcGxpY2F0aW9uLnRvTWVtb0tleSgpID09PSBtZW1vS2V5KSB7XG4gICAgLy8gV2UgYWxyZWFkeSBrbm93IGFib3V0IHRoaXMgbGVmdCByZWN1cnNpb24sIGJ1dCBpdCdzIHBvc3NpYmxlIHRoZXJlIGFyZSBcImludm9sdmVkXG4gICAgLy8gYXBwbGljYXRpb25zXCIgdGhhdCB3ZSBkb24ndCBhbHJlYWR5IGtub3cgYWJvdXQsIHNvLi4uXG4gICAgbWVtb1JlYy51cGRhdGVJbnZvbHZlZEFwcGxpY2F0aW9uTWVtb0tleXMoKTtcbiAgfSBlbHNlIGlmICghbWVtb1JlYykge1xuICAgIC8vIE5ldyBsZWZ0IHJlY3Vyc2lvbiBkZXRlY3RlZCEgTWVtb2l6ZSBhIGZhaWx1cmUgdG8gdHJ5IHRvIGdldCBhIHNlZWQgcGFyc2UuXG4gICAgbWVtb1JlYyA9IHBvc0luZm8ubWVtb2l6ZShcbiAgICAgICAgbWVtb0tleSxcbiAgICAgICAge21hdGNoTGVuZ3RoOiAwLCBleGFtaW5lZExlbmd0aDogMCwgdmFsdWU6IGZhbHNlLCByaWdodG1vc3RGYWlsdXJlT2Zmc2V0OiAtMX0pO1xuICAgIHBvc0luZm8uc3RhcnRMZWZ0UmVjdXJzaW9uKHRoaXMsIG1lbW9SZWMpO1xuICB9XG4gIHJldHVybiBzdGF0ZS51c2VNZW1vaXplZFJlc3VsdChzdGF0ZS5pbnB1dFN0cmVhbS5wb3MsIG1lbW9SZWMpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5yZWFsbHlFdmFsID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBzdGF0ZS5pbnB1dFN0cmVhbTtcbiAgY29uc3Qgb3JpZ1BvcyA9IGlucHV0U3RyZWFtLnBvcztcbiAgY29uc3Qgb3JpZ1Bvc0luZm8gPSBzdGF0ZS5nZXRDdXJyZW50UG9zSW5mbygpO1xuICBjb25zdCBydWxlSW5mbyA9IHN0YXRlLmdyYW1tYXIucnVsZXNbdGhpcy5ydWxlTmFtZV07XG4gIGNvbnN0IGJvZHkgPSBydWxlSW5mby5ib2R5O1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHJ1bGVJbmZvLmRlc2NyaXB0aW9uO1xuXG4gIHN0YXRlLmVudGVyQXBwbGljYXRpb24ob3JpZ1Bvc0luZm8sIHRoaXMpO1xuXG4gIGlmIChkZXNjcmlwdGlvbikge1xuICAgIHN0YXRlLnB1c2hGYWlsdXJlc0luZm8oKTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBpbnB1dCBzdHJlYW0ncyBleGFtaW5lZExlbmd0aCBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiB0cmFja1xuICAvLyB0aGUgZXhhbWluZWQgbGVuZ3RoIG9mIHRoaXMgcGFydGljdWxhciBhcHBsaWNhdGlvbi5cbiAgY29uc3Qgb3JpZ0lucHV0U3RyZWFtRXhhbWluZWRMZW5ndGggPSBpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aDtcbiAgaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGggPSAwO1xuXG4gIGxldCB2YWx1ZSA9IHRoaXMuZXZhbE9uY2UoYm9keSwgc3RhdGUpO1xuICBjb25zdCBjdXJyZW50TFIgPSBvcmlnUG9zSW5mby5jdXJyZW50TGVmdFJlY3Vyc2lvbjtcbiAgY29uc3QgbWVtb0tleSA9IHRoaXMudG9NZW1vS2V5KCk7XG4gIGNvbnN0IGlzSGVhZE9mTGVmdFJlY3Vyc2lvbiA9IGN1cnJlbnRMUiAmJiBjdXJyZW50TFIuaGVhZEFwcGxpY2F0aW9uLnRvTWVtb0tleSgpID09PSBtZW1vS2V5O1xuICBsZXQgbWVtb1JlYztcblxuICBpZiAoaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uKSB7XG4gICAgdmFsdWUgPSB0aGlzLmdyb3dTZWVkUmVzdWx0KGJvZHksIHN0YXRlLCBvcmlnUG9zLCBjdXJyZW50TFIsIHZhbHVlKTtcbiAgICBvcmlnUG9zSW5mby5lbmRMZWZ0UmVjdXJzaW9uKCk7XG4gICAgbWVtb1JlYyA9IGN1cnJlbnRMUjtcbiAgICBtZW1vUmVjLmV4YW1pbmVkTGVuZ3RoID0gaW5wdXRTdHJlYW0uZXhhbWluZWRMZW5ndGggLSBvcmlnUG9zO1xuICAgIG1lbW9SZWMucmlnaHRtb3N0RmFpbHVyZU9mZnNldCA9IHN0YXRlLl9nZXRSaWdodG1vc3RGYWlsdXJlT2Zmc2V0KCk7XG4gICAgb3JpZ1Bvc0luZm8ubWVtb2l6ZShtZW1vS2V5LCBtZW1vUmVjKTsgLy8gdXBkYXRlcyBvcmlnUG9zSW5mbydzIG1heEV4YW1pbmVkTGVuZ3RoXG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRMUiB8fCAhY3VycmVudExSLmlzSW52b2x2ZWQobWVtb0tleSkpIHtcbiAgICAvLyBUaGlzIGFwcGxpY2F0aW9uIGlzIG5vdCBpbnZvbHZlZCBpbiBsZWZ0IHJlY3Vyc2lvbiwgc28gaXQncyBvayB0byBtZW1vaXplIGl0LlxuICAgIG1lbW9SZWMgPSBvcmlnUG9zSW5mby5tZW1vaXplKG1lbW9LZXksIHtcbiAgICAgIG1hdGNoTGVuZ3RoOiBpbnB1dFN0cmVhbS5wb3MgLSBvcmlnUG9zLFxuICAgICAgZXhhbWluZWRMZW5ndGg6IGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoIC0gb3JpZ1BvcyxcbiAgICAgIHZhbHVlLFxuICAgICAgZmFpbHVyZXNBdFJpZ2h0bW9zdFBvc2l0aW9uOiBzdGF0ZS5jbG9uZVJlY29yZGVkRmFpbHVyZXMoKSxcbiAgICAgIHJpZ2h0bW9zdEZhaWx1cmVPZmZzZXQ6IHN0YXRlLl9nZXRSaWdodG1vc3RGYWlsdXJlT2Zmc2V0KClcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzdWNjZWVkZWQgPSAhIXZhbHVlO1xuXG4gIGlmIChkZXNjcmlwdGlvbikge1xuICAgIHN0YXRlLnBvcEZhaWx1cmVzSW5mbygpO1xuICAgIGlmICghc3VjY2VlZGVkKSB7XG4gICAgICBzdGF0ZS5wcm9jZXNzRmFpbHVyZShvcmlnUG9zLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1lbW9SZWMpIHtcbiAgICAgIG1lbW9SZWMuZmFpbHVyZXNBdFJpZ2h0bW9zdFBvc2l0aW9uID0gc3RhdGUuY2xvbmVSZWNvcmRlZEZhaWx1cmVzKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVjb3JkIHRyYWNlIGluZm9ybWF0aW9uIGluIHRoZSBtZW1vIHRhYmxlLCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBpZiB0aGUgbWVtb2l6ZWQgcmVzdWx0XG4gIC8vIGlzIHVzZWQgbGF0ZXIuXG4gIGlmIChzdGF0ZS5pc1RyYWNpbmcoKSAmJiBtZW1vUmVjKSB7XG4gICAgY29uc3QgZW50cnkgPSBzdGF0ZS5nZXRUcmFjZUVudHJ5KG9yaWdQb3MsIHRoaXMsIHN1Y2NlZWRlZCwgc3VjY2VlZGVkID8gW3ZhbHVlXSA6IFtdKTtcbiAgICBpZiAoaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uKSB7XG4gICAgICBjb21tb24uYXNzZXJ0KGVudHJ5LnRlcm1pbmF0aW5nTFJFbnRyeSAhPSBudWxsIHx8ICFzdWNjZWVkZWQpO1xuICAgICAgZW50cnkuaXNIZWFkT2ZMZWZ0UmVjdXJzaW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgbWVtb1JlYy50cmFjZUVudHJ5ID0gZW50cnk7XG4gIH1cblxuICAvLyBGaXggdGhlIGlucHV0IHN0cmVhbSdzIGV4YW1pbmVkTGVuZ3RoIC0tIGl0IHNob3VsZCBiZSB0aGUgbWF4aW11bSBleGFtaW5lZCBsZW5ndGhcbiAgLy8gYWNyb3NzIGFsbCBhcHBsaWNhdGlvbnMsIG5vdCBqdXN0IHRoaXMgb25lLlxuICBpbnB1dFN0cmVhbS5leGFtaW5lZExlbmd0aCA9IE1hdGgubWF4KGlucHV0U3RyZWFtLmV4YW1pbmVkTGVuZ3RoLCBvcmlnSW5wdXRTdHJlYW1FeGFtaW5lZExlbmd0aCk7XG5cbiAgc3RhdGUuZXhpdEFwcGxpY2F0aW9uKG9yaWdQb3NJbmZvLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHN1Y2NlZWRlZDtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuZXZhbE9uY2UgPSBmdW5jdGlvbihleHByLCBzdGF0ZSkge1xuICBjb25zdCBpbnB1dFN0cmVhbSA9IHN0YXRlLmlucHV0U3RyZWFtO1xuICBjb25zdCBvcmlnUG9zID0gaW5wdXRTdHJlYW0ucG9zO1xuXG4gIGlmIChzdGF0ZS5ldmFsKGV4cHIpKSB7XG4gICAgY29uc3QgYXJpdHkgPSBleHByLmdldEFyaXR5KCk7XG4gICAgY29uc3QgYmluZGluZ3MgPSBzdGF0ZS5fYmluZGluZ3Muc3BsaWNlKHN0YXRlLl9iaW5kaW5ncy5sZW5ndGggLSBhcml0eSwgYXJpdHkpO1xuICAgIGNvbnN0IG9mZnNldHMgPSBzdGF0ZS5fYmluZGluZ09mZnNldHMuc3BsaWNlKHN0YXRlLl9iaW5kaW5nT2Zmc2V0cy5sZW5ndGggLSBhcml0eSwgYXJpdHkpO1xuICAgIHJldHVybiBuZXcgTm9udGVybWluYWxOb2RlKFxuICAgICAgICBzdGF0ZS5ncmFtbWFyLCB0aGlzLnJ1bGVOYW1lLCBiaW5kaW5ncywgb2Zmc2V0cywgaW5wdXRTdHJlYW0ucG9zIC0gb3JpZ1Bvcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmdyb3dTZWVkUmVzdWx0ID0gZnVuY3Rpb24oYm9keSwgc3RhdGUsIG9yaWdQb3MsIGxyTWVtb1JlYywgbmV3VmFsdWUpIHtcbiAgaWYgKCFuZXdWYWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBsck1lbW9SZWMubWF0Y2hMZW5ndGggPSBpbnB1dFN0cmVhbS5wb3MgLSBvcmlnUG9zO1xuICAgIGxyTWVtb1JlYy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGxyTWVtb1JlYy5mYWlsdXJlc0F0UmlnaHRtb3N0UG9zaXRpb24gPSBzdGF0ZS5jbG9uZVJlY29yZGVkRmFpbHVyZXMoKTtcblxuICAgIGlmIChzdGF0ZS5pc1RyYWNpbmcoKSkge1xuICAgICAgLy8gQmVmb3JlIGV2YWx1YXRpbmcgdGhlIGJvZHkgYWdhaW4sIGFkZCBhIHRyYWNlIG5vZGUgZm9yIHRoaXMgYXBwbGljYXRpb24gdG8gdGhlIG1lbW8gZW50cnkuXG4gICAgICAvLyBJdHMgb25seSBjaGlsZCBpcyBhIGNvcHkgb2YgdGhlIHRyYWNlIG5vZGUgZnJvbSBgbmV3VmFsdWVgLCB3aGljaCB3aWxsIGFsd2F5cyBiZSB0aGUgbGFzdFxuICAgICAgLy8gZWxlbWVudCBpbiBgc3RhdGUudHJhY2VgLlxuICAgICAgY29uc3Qgc2VlZFRyYWNlID0gc3RhdGUudHJhY2Vbc3RhdGUudHJhY2UubGVuZ3RoIC0gMV07XG4gICAgICBsck1lbW9SZWMudHJhY2VFbnRyeSA9IG5ldyBUcmFjZShcbiAgICAgICAgICBzdGF0ZS5pbnB1dCwgb3JpZ1BvcywgaW5wdXRTdHJlYW0ucG9zLCB0aGlzLCB0cnVlLCBbbmV3VmFsdWVdLCBbc2VlZFRyYWNlLmNsb25lKCldKTtcbiAgICB9XG4gICAgaW5wdXRTdHJlYW0ucG9zID0gb3JpZ1BvcztcbiAgICBuZXdWYWx1ZSA9IHRoaXMuZXZhbE9uY2UoYm9keSwgc3RhdGUpO1xuICAgIGlmIChpbnB1dFN0cmVhbS5wb3MgLSBvcmlnUG9zIDw9IGxyTWVtb1JlYy5tYXRjaExlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5pc1RyYWNpbmcoKSkge1xuICAgICAgc3RhdGUudHJhY2Uuc3BsaWNlKC0yLCAxKTsgLy8gRHJvcCB0aGUgdHJhY2UgZm9yIHRoZSBvbGQgc2VlZC5cbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLmlzVHJhY2luZygpKSB7XG4gICAgLy8gVGhlIGxhc3QgZW50cnkgaXMgZm9yIGFuIHVudXNlZCByZXN1bHQgLS0gcG9wIGl0IGFuZCBzYXZlIGl0IGluIHRoZSBcInJlYWxcIiBlbnRyeS5cbiAgICBsck1lbW9SZWMudHJhY2VFbnRyeS5yZWNvcmRMUlRlcm1pbmF0aW9uKHN0YXRlLnRyYWNlLnBvcCgpLCBuZXdWYWx1ZSk7XG4gIH1cbiAgaW5wdXRTdHJlYW0ucG9zID0gb3JpZ1BvcyArIGxyTWVtb1JlYy5tYXRjaExlbmd0aDtcbiAgcmV0dXJuIGxyTWVtb1JlYy52YWx1ZTtcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IGlucHV0U3RyZWFtID0gc3RhdGUuaW5wdXRTdHJlYW07XG4gIGNvbnN0IG9yaWdQb3MgPSBpbnB1dFN0cmVhbS5wb3M7XG4gIGNvbnN0IGNoID0gaW5wdXRTdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggJiYgdGhpcy5wYXR0ZXJuLnRlc3QoY2gpKSB7XG4gICAgc3RhdGUucHVzaEJpbmRpbmcobmV3IFRlcm1pbmFsTm9kZShzdGF0ZS5ncmFtbWFyLCBjaCksIG9yaWdQb3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLnByb2Nlc3NGYWlsdXJlKG9yaWdQb3MsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZmxhdHRlbihsaXN0T2ZMaXN0cykge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgbGlzdE9mTGlzdHMpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBjb21tb24uYWJzdHJhY3QoJ2dlbmVyYXRlRXhhbXBsZScpO1xuXG5mdW5jdGlvbiBjYXRlZ29yaXplRXhhbXBsZXMoZXhhbXBsZXMpIHtcbiAgLy8gQSBsaXN0IG9mIHJ1bGVzIHRoYXQgdGhlIHN5c3RlbSBuZWVkcyBleGFtcGxlcyBvZiwgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gZXhhbXBsZVxuICAvLyAgIGZvciB0aGUgY3VycmVudCBydWxlXG4gIGxldCBleGFtcGxlc05lZWRlZCA9IGV4YW1wbGVzLmZpbHRlcihleGFtcGxlID0+IGV4YW1wbGUuaGFzT3duUHJvcGVydHkoJ2V4YW1wbGVzTmVlZGVkJykpXG4gICAgICAubWFwKGV4YW1wbGUgPT4gZXhhbXBsZS5leGFtcGxlc05lZWRlZCk7XG5cbiAgZXhhbXBsZXNOZWVkZWQgPSBmbGF0dGVuKGV4YW1wbGVzTmVlZGVkKTtcblxuICBjb25zdCB1bmlxdWVFeGFtcGxlc05lZWRlZCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4YW1wbGVzTmVlZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudEV4YW1wbGVOZWVkZWQgPSBleGFtcGxlc05lZWRlZFtpXTtcbiAgICB1bmlxdWVFeGFtcGxlc05lZWRlZFtjdXJyZW50RXhhbXBsZU5lZWRlZF0gPSB0cnVlO1xuICB9XG4gIGV4YW1wbGVzTmVlZGVkID0gT2JqZWN0LmtleXModW5pcXVlRXhhbXBsZXNOZWVkZWQpO1xuXG4gIC8vIEEgbGlzdCBvZiBzdWNjZXNzZnVsbHkgZ2VuZXJhdGVkIGV4YW1wbGVzXG4gIGNvbnN0IHN1Y2Nlc3NmdWxFeGFtcGxlcyA9IGV4YW1wbGVzLmZpbHRlcihleGFtcGxlID0+IGV4YW1wbGUuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpXG4gICAgICAubWFwKGl0ZW0gPT4gaXRlbS52YWx1ZSk7XG5cbiAgLy8gVGhpcyBmbGFnIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3lzdGVtIGNhbm5vdCBnZW5lcmF0ZSB0aGUgcnVsZSBpdCBpcyBjdXJyZW50bHlcbiAgLy8gICBhdHRlbXB0aW5nIHRvIGdlbmVyYXRlLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IGl0IGhhcyB0aGUgZXhhbXBsZXMgaXQgbmVlZHMuXG4gIC8vICAgQ3VycmVudGx5LCB0aGlzIGlzIG9ubHkgdXNlZCBpbiBvdmVycmlkaW5nIGdlbmVyYXRvcnMgdG8gcHJldmVudCB0aGUgc3lzdGVtIGZyb21cbiAgLy8gICBnZW5lcmF0aW5nIGV4YW1wbGVzIGZvciBjZXJ0YWluIHJ1bGVzIChlLmcuICdpZGVudCcpLlxuICBjb25zdCBuZWVkSGVscCA9IGV4YW1wbGVzLnNvbWUoaXRlbSA9PiBpdGVtLm5lZWRIZWxwKTtcblxuICByZXR1cm4ge1xuICAgIGV4YW1wbGVzTmVlZGVkLFxuICAgIHN1Y2Nlc3NmdWxFeGFtcGxlcyxcbiAgICBuZWVkSGVscFxuICB9O1xufVxuXG5wZXhwcnMuYW55LmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgcmV0dXJuIHt2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpKX07XG59O1xuXG4vLyBBc3N1bWVzIHRoYXQgdGVybWluYWwncyBvYmplY3QgaXMgYWx3YXlzIGEgc3RyaW5nXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQpIHtcbiAgcmV0dXJuIHt2YWx1ZTogdGhpcy5vYmp9O1xufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0KSB7XG4gIGNvbnN0IHJhbmdlU2l6ZSA9IHRoaXMudG8uY2hhckNvZGVBdCgwKSAtIHRoaXMuZnJvbS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4ge3ZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgdGhpcy5mcm9tLmNoYXJDb2RlQXQoMCkgKyBNYXRoLmZsb29yKHJhbmdlU2l6ZSAqIE1hdGgucmFuZG9tKCkpXG4gICl9O1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIHJldHVybiBhY3R1YWxzW3RoaXMuaW5kZXhdLmdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKTtcbn07XG5cbnBleHBycy5BbHQucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgLy8gaXRlbXMgLT4gdGVybUV4YW1wbGVzXG4gIGNvbnN0IHRlcm1FeGFtcGxlcyA9IHRoaXMudGVybXMubWFwKHRlcm0gPT4ge1xuICAgIHJldHVybiB0ZXJtLmdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKTtcbiAgfSk7XG5cbiAgY29uc3QgY2F0ZWdvcml6ZWRFeGFtcGxlcyA9IGNhdGVnb3JpemVFeGFtcGxlcyh0ZXJtRXhhbXBsZXMpO1xuXG4gIGNvbnN0IGV4YW1wbGVzTmVlZGVkID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5leGFtcGxlc05lZWRlZDtcbiAgY29uc3Qgc3VjY2Vzc2Z1bEV4YW1wbGVzID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5zdWNjZXNzZnVsRXhhbXBsZXM7XG4gIGNvbnN0IG5lZWRIZWxwID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5uZWVkSGVscDtcblxuICBjb25zdCBhbnMgPSB7fTtcblxuICAvLyBBbHQgY2FuIGNvbnRhaW4gYm90aCBhbiBleGFtcGxlIGFuZCBhIHJlcXVlc3QgZm9yIGV4YW1wbGVzXG4gIGlmIChzdWNjZXNzZnVsRXhhbXBsZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzdWNjZXNzZnVsRXhhbXBsZXMubGVuZ3RoKTtcbiAgICBhbnMudmFsdWUgPSBzdWNjZXNzZnVsRXhhbXBsZXNbaV07XG4gIH1cbiAgaWYgKGV4YW1wbGVzTmVlZGVkLmxlbmd0aCA+IDApIHtcbiAgICBhbnMuZXhhbXBsZXNOZWVkZWQgPSBleGFtcGxlc05lZWRlZDtcbiAgfVxuICBhbnMubmVlZEhlbHAgPSBuZWVkSGVscDtcblxuICByZXR1cm4gYW5zO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICBjb25zdCBmYWN0b3JFeGFtcGxlcyA9IHRoaXMuZmFjdG9ycy5tYXAoZmFjdG9yID0+IHtcbiAgICByZXR1cm4gZmFjdG9yLmdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKTtcbiAgfSk7XG4gIGNvbnN0IGNhdGVnb3JpemVkRXhhbXBsZXMgPSBjYXRlZ29yaXplRXhhbXBsZXMoZmFjdG9yRXhhbXBsZXMpO1xuXG4gIGNvbnN0IGV4YW1wbGVzTmVlZGVkID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5leGFtcGxlc05lZWRlZDtcbiAgY29uc3Qgc3VjY2Vzc2Z1bEV4YW1wbGVzID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5zdWNjZXNzZnVsRXhhbXBsZXM7XG4gIGNvbnN0IG5lZWRIZWxwID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5uZWVkSGVscDtcblxuICBjb25zdCBhbnMgPSB7fTtcblxuICAvLyBJbiBhIFNlcSwgYWxsIHBpZWNlcyBtdXN0IHN1Y2NlZWQgaW4gb3JkZXIgdG8gaGF2ZSBhIHN1Y2Nlc3NmdWwgZXhhbXBsZS5cbiAgaWYgKGV4YW1wbGVzTmVlZGVkLmxlbmd0aCA+IDAgfHwgbmVlZEhlbHApIHtcbiAgICBhbnMuZXhhbXBsZXNOZWVkZWQgPSBleGFtcGxlc05lZWRlZDtcbiAgICBhbnMubmVlZEhlbHAgPSBuZWVkSGVscDtcbiAgfSBlbHNlIHtcbiAgICBhbnMudmFsdWUgPSBzdWNjZXNzZnVsRXhhbXBsZXMuam9pbihpblN5bnRhY3RpY0NvbnRleHQgPyAnICcgOiAnJyk7XG4gIH1cblxuICByZXR1cm4gYW5zO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpIHtcbiAgY29uc3QgcmFuZ2VUaW1lcyA9IE1hdGgubWluKHRoaXMubWF4TnVtTWF0Y2hlcyAtIHRoaXMubWluTnVtTWF0Y2hlcywgMyk7XG4gIGNvbnN0IG51bVRpbWVzID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHJhbmdlVGltZXMgKyAxKSArIHRoaXMubWluTnVtTWF0Y2hlcyk7XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lczsgaSsrKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLmV4cHIuZ2VuZXJhdGVFeGFtcGxlKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQsIGFjdHVhbHMpKTtcbiAgfVxuXG4gIGNvbnN0IGNhdGVnb3JpemVkRXhhbXBsZXMgPSBjYXRlZ29yaXplRXhhbXBsZXMoaXRlbXMpO1xuXG4gIGNvbnN0IGV4YW1wbGVzTmVlZGVkID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5leGFtcGxlc05lZWRlZDtcbiAgY29uc3Qgc3VjY2Vzc2Z1bEV4YW1wbGVzID0gY2F0ZWdvcml6ZWRFeGFtcGxlcy5zdWNjZXNzZnVsRXhhbXBsZXM7XG5cbiAgY29uc3QgYW5zID0ge307XG5cbiAgLy8gSXQncyBhbHdheXMgZWl0aGVyIG9uZSBvciB0aGUgb3RoZXIuXG4gIC8vIFRPRE86IGluc3RlYWQgb2YgJyAnLCBjYWxsICdzcGFjZXMuZ2VuZXJhdGVFeGFtcGxlKCknXG4gIGFucy52YWx1ZSA9IHN1Y2Nlc3NmdWxFeGFtcGxlcy5qb2luKGluU3ludGFjdGljQ29udGV4dCA/ICcgJyA6ICcnKTtcbiAgaWYgKGV4YW1wbGVzTmVlZGVkLmxlbmd0aCA+IDApIHtcbiAgICBhbnMuZXhhbXBsZXNOZWVkZWQgPSBleGFtcGxlc05lZWRlZDtcbiAgfVxuXG4gIHJldHVybiBhbnM7XG59O1xuXG4vLyBSaWdodCBub3csICdOb3QnIGFuZCAnTG9va2FoZWFkJyBnZW5lcmF0ZSBub3RoaW5nIGFuZCBhc3N1bWUgdGhhdCB3aGF0ZXZlciBmb2xsb3dzIHdpbGxcbi8vICAgd29yayBhY2NvcmRpbmcgdG8gdGhlIGVuY29kZWQgY29uc3RyYWludHMuXG5wZXhwcnMuTm90LnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0KSB7XG4gIHJldHVybiB7dmFsdWU6ICcnfTtcbn07XG5cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLmdlbmVyYXRlRXhhbXBsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIGV4YW1wbGVzLCBpblN5bnRhY3RpY0NvbnRleHQpIHtcbiAgcmV0dXJuIHt2YWx1ZTogJyd9O1xufTtcblxucGV4cHJzLkxleC5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICByZXR1cm4gdGhpcy5leHByLmdlbmVyYXRlRXhhbXBsZShncmFtbWFyLCBleGFtcGxlcywgZmFsc2UsIGFjdHVhbHMpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5nZW5lcmF0ZUV4YW1wbGUgPSBmdW5jdGlvbihncmFtbWFyLCBleGFtcGxlcywgaW5TeW50YWN0aWNDb250ZXh0LCBhY3R1YWxzKSB7XG4gIGNvbnN0IGFucyA9IHt9O1xuXG4gIGNvbnN0IHJ1bGVOYW1lID0gdGhpcy5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpLnRvU3RyaW5nKCk7XG5cbiAgaWYgKCFleGFtcGxlcy5oYXNPd25Qcm9wZXJ0eShydWxlTmFtZSkpIHtcbiAgICBhbnMuZXhhbXBsZXNOZWVkZWQgPSBbcnVsZU5hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlbGV2YW50RXhhbXBsZXMgPSBleGFtcGxlc1tydWxlTmFtZV07XG4gICAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlbGV2YW50RXhhbXBsZXMubGVuZ3RoKTtcbiAgICBhbnMudmFsdWUgPSByZWxldmFudEV4YW1wbGVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFucztcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuZ2VuZXJhdGVFeGFtcGxlID0gZnVuY3Rpb24oXG4gICAgZ3JhbW1hciwgZXhhbXBsZXMsIGluU3ludGFjdGljQ29udGV4dCwgYWN0dWFscykge1xuICBsZXQgY2hhcjtcbiAgc3dpdGNoICh0aGlzLmNhdGVnb3J5KSB7XG4gICAgY2FzZSAnTHUnOiBjaGFyID0gJ8OBJzsgYnJlYWs7XG4gICAgY2FzZSAnTGwnOiBjaGFyID0gJ8WPJzsgYnJlYWs7XG4gICAgY2FzZSAnTHQnOiBjaGFyID0gJ8eFJzsgYnJlYWs7XG4gICAgY2FzZSAnTG0nOiBjaGFyID0gJ8uuJzsgYnJlYWs7XG4gICAgY2FzZSAnTG8nOiBjaGFyID0gJ8a7JzsgYnJlYWs7XG5cbiAgICBjYXNlICdObCc6IGNoYXIgPSAn4oaCJzsgYnJlYWs7XG4gICAgY2FzZSAnTmQnOiBjaGFyID0gJ8K9JzsgYnJlYWs7XG5cbiAgICBjYXNlICdNbic6IGNoYXIgPSAnXFx1MDQ4Nyc7IGJyZWFrO1xuICAgIGNhc2UgJ01jJzogY2hhciA9ICfgpL8nOyBicmVhaztcblxuICAgIGNhc2UgJ1BjJzogY2hhciA9ICfigYAnOyBicmVhaztcblxuICAgIGNhc2UgJ1pzJzogY2hhciA9ICdcXHUyMDAxJzsgYnJlYWs7XG5cbiAgICBjYXNlICdMJzogY2hhciA9ICfDgSc7IGJyZWFrO1xuICAgIGNhc2UgJ0x0bW8nOiBjaGFyID0gJ8eFJzsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHt2YWx1ZTogY2hhcn07IC8vIPCfkqlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuZ2V0QXJpdHkgPSBjb21tb24uYWJzdHJhY3QoJ2dldEFyaXR5Jyk7XG5cbnBleHBycy5hbnkuZ2V0QXJpdHkgPVxucGV4cHJzLmVuZC5nZXRBcml0eSA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLmdldEFyaXR5ID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuZ2V0QXJpdHkgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5nZXRBcml0eSA9XG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmdldEFyaXR5ID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDE7XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS5nZXRBcml0eSA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIGlzIG9rIGIvYyBhbGwgdGVybXMgbXVzdCBoYXZlIHRoZSBzYW1lIGFyaXR5IC0tIHRoaXMgcHJvcGVydHkgaXNcbiAgLy8gY2hlY2tlZCBieSB0aGUgR3JhbW1hciBjb25zdHJ1Y3Rvci5cbiAgcmV0dXJuIHRoaXMudGVybXMubGVuZ3RoID09PSAwID8gMCA6IHRoaXMudGVybXNbMF0uZ2V0QXJpdHkoKTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmdldEFyaXR5ID0gZnVuY3Rpb24oKSB7XG4gIGxldCBhcml0eSA9IDA7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuZmFjdG9ycy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgYXJpdHkgKz0gdGhpcy5mYWN0b3JzW2lkeF0uZ2V0QXJpdHkoKTtcbiAgfVxuICByZXR1cm4gYXJpdHk7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZXhwci5nZXRBcml0eSgpO1xufTtcblxucGV4cHJzLk5vdC5wcm90b3R5cGUuZ2V0QXJpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5nZXRBcml0eSA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5nZXRBcml0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5leHByLmdldEFyaXR5KCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBDYWxsZWQgYXQgZ3JhbW1hciBjcmVhdGlvbiB0aW1lIHRvIHJld3JpdGUgYSBydWxlIGJvZHksIHJlcGxhY2luZyBlYWNoIHJlZmVyZW5jZSB0byBhIGZvcm1hbFxuICBwYXJhbWV0ZXIgd2l0aCBhIGBQYXJhbWAgbm9kZS4gUmV0dXJucyBhIFBFeHByIC0tIGVpdGhlciBhIG5ldyBvbmUsIG9yIHRoZSBvcmlnaW5hbCBvbmUgaWZcbiAgaXQgd2FzIG1vZGlmaWVkIGluIHBsYWNlLlxuKi9cbnBleHBycy5QRXhwci5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID0gY29tbW9uLmFic3RyYWN0KCdpbnRyb2R1Y2VQYXJhbXMnKTtcblxucGV4cHJzLmFueS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLmVuZC5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPSBmdW5jdGlvbihmb3JtYWxzKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID0gZnVuY3Rpb24oZm9ybWFscykge1xuICB0aGlzLnRlcm1zLmZvckVhY2goKHRlcm0sIGlkeCwgdGVybXMpID0+IHtcbiAgICB0ZXJtc1tpZHhdID0gdGVybS5pbnRyb2R1Y2VQYXJhbXMoZm9ybWFscyk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGZ1bmN0aW9uKGZvcm1hbHMpIHtcbiAgdGhpcy5mYWN0b3JzLmZvckVhY2goKGZhY3RvciwgaWR4LCBmYWN0b3JzKSA9PiB7XG4gICAgZmFjdG9yc1tpZHhdID0gZmFjdG9yLmludHJvZHVjZVBhcmFtcyhmb3JtYWxzKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucGV4cHJzLkl0ZXIucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5pbnRyb2R1Y2VQYXJhbXMgPVxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUuaW50cm9kdWNlUGFyYW1zID1cbnBleHBycy5MZXgucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGZ1bmN0aW9uKGZvcm1hbHMpIHtcbiAgdGhpcy5leHByID0gdGhpcy5leHByLmludHJvZHVjZVBhcmFtcyhmb3JtYWxzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLmludHJvZHVjZVBhcmFtcyA9IGZ1bmN0aW9uKGZvcm1hbHMpIHtcbiAgY29uc3QgaW5kZXggPSBmb3JtYWxzLmluZGV4T2YodGhpcy5ydWxlTmFtZSk7XG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgaWYgKHRoaXMuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBiZSBzdXBwb3J0ZWQ/IFNlZSBpc3N1ZSAjNjQuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcml6ZWQgcnVsZXMgY2Fubm90IGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gYW5vdGhlciBydWxlLicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBleHBycy5QYXJhbShpbmRleCkud2l0aFNvdXJjZSh0aGlzLnNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hcmdzLmZvckVhY2goKGFyZywgaWR4LCBhcmdzKSA9PiB7XG4gICAgICBhcmdzW2lkeF0gPSBhcmcuaW50cm9kdWNlUGFyYW1zKGZvcm1hbHMpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHBhcnNpbmcgZXhwcmVzc2lvbiBtYXkgYWNjZXB0IHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dC5cbnBleHBycy5QRXhwci5wcm90b3R5cGUuaXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgcmV0dXJuIHRoaXMuX2lzTnVsbGFibGUoZ3JhbW1hciwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59O1xuXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLl9pc051bGxhYmxlID0gY29tbW9uLmFic3RyYWN0KCdfaXNOdWxsYWJsZScpO1xuXG5wZXhwcnMuYW55Ll9pc051bGxhYmxlID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuUGx1cy5wcm90b3R5cGUuX2lzTnVsbGFibGUgPVxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxucGV4cHJzLmVuZC5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLl9pc051bGxhYmxlID0gZnVuY3Rpb24oZ3JhbW1hciwgbWVtbykge1xuICBpZiAodHlwZW9mIHRoaXMub2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRoaXMgaXMgYW4gb3Zlci1zaW1wbGlmaWNhdGlvbjogaXQncyBvbmx5IGNvcnJlY3QgaWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLiBJZiBpdCdzIGFuIGFycmF5XG4gICAgLy8gb3IgYW4gb2JqZWN0LCB0aGVuIHRoZSBlbXB0eSBzdHJpbmcgcGFyc2luZyBleHByZXNzaW9uIGlzIG5vdCBudWxsYWJsZS5cbiAgICByZXR1cm4gdGhpcy5vYmogPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIHJldHVybiB0aGlzLnRlcm1zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgdGhpcy50ZXJtcy5zb21lKHRlcm0gPT4gdGVybS5faXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKSk7XG59O1xuXG5wZXhwcnMuU2VxLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgcmV0dXJuIHRoaXMuZmFjdG9ycy5ldmVyeShmYWN0b3IgPT4gZmFjdG9yLl9pc051bGxhYmxlKGdyYW1tYXIsIG1lbW8pKTtcbn07XG5cbnBleHBycy5TdGFyLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuT3B0LnByb3RvdHlwZS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5faXNOdWxsYWJsZSA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5wZXhwcnMuTGV4LnByb3RvdHlwZS5faXNOdWxsYWJsZSA9IGZ1bmN0aW9uKGdyYW1tYXIsIG1lbW8pIHtcbiAgcmV0dXJuIHRoaXMuZXhwci5faXNOdWxsYWJsZShncmFtbWFyLCBtZW1vKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuX2lzTnVsbGFibGUgPSBmdW5jdGlvbihncmFtbWFyLCBtZW1vKSB7XG4gIGNvbnN0IGtleSA9IHRoaXMudG9NZW1vS2V5KCk7XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lbW8sIGtleSkpIHtcbiAgICBjb25zdCBib2R5ID0gZ3JhbW1hci5ydWxlc1t0aGlzLnJ1bGVOYW1lXS5ib2R5O1xuICAgIGNvbnN0IGlubGluZWQgPSBib2R5LnN1YnN0aXR1dGVQYXJhbXModGhpcy5hcmdzKTtcbiAgICBtZW1vW2tleV0gPSBmYWxzZTsgLy8gUHJldmVudCBpbmZpbml0ZSByZWN1cnNpb24gZm9yIHJlY3Vyc2l2ZSBydWxlcy5cbiAgICBtZW1vW2tleV0gPSBpbmxpbmVkLl9pc051bGxhYmxlKGdyYW1tYXIsIG1lbW8pO1xuICB9XG4gIHJldHVybiBtZW1vW2tleV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBnZXRNZXRhSW5mbyhleHByLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgY29uc3QgbWV0YUluZm8gPSB7fTtcbiAgaWYgKGV4cHIuc291cmNlICYmIGdyYW1tYXJJbnRlcnZhbCkge1xuICAgIGNvbnN0IGFkanVzdGVkID0gZXhwci5zb3VyY2UucmVsYXRpdmVUbyhncmFtbWFySW50ZXJ2YWwpO1xuICAgIG1ldGFJbmZvLnNvdXJjZUludGVydmFsID0gW2FkanVzdGVkLnN0YXJ0SWR4LCBhZGp1c3RlZC5lbmRJZHhdO1xuICB9XG4gIHJldHVybiBtZXRhSW5mbztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wZXJhdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnBleHBycy5QRXhwci5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gY29tbW9uLmFic3RyYWN0KCdvdXRwdXRSZWNpcGUnKTtcblxucGV4cHJzLmFueS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFsnYW55JywgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKV07XG59O1xuXG5wZXhwcnMuZW5kLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gWydlbmQnLCBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpXTtcbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ3Rlcm1pbmFsJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMub2JqXG4gIF07XG59O1xuXG5wZXhwcnMuUmFuZ2UucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICByZXR1cm4gW1xuICAgICdyYW5nZScsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKSxcbiAgICB0aGlzLmZyb20sXG4gICAgdGhpcy50b1xuICBdO1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAncGFyYW0nLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgdGhpcy5pbmRleFxuICBdO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ2FsdCcsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKVxuICBdLmNvbmNhdCh0aGlzLnRlcm1zLm1hcCh0ZXJtID0+IHRlcm0ub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkpKTtcbn07XG5cbnBleHBycy5FeHRlbmQucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICBjb25zdCBleHRlbnNpb24gPSB0aGlzLnRlcm1zWzBdOyAvLyBbZXh0ZW5zaW9uLCBvcmlnaW5hbF1cbiAgcmV0dXJuIGV4dGVuc2lvbi5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKTtcbn07XG5cbnBleHBycy5TcGxpY2UucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9IGZ1bmN0aW9uKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkge1xuICBjb25zdCBiZWZvcmVUZXJtcyA9IHRoaXMudGVybXMuc2xpY2UoMCwgdGhpcy5leHBhbnNpb25Qb3MpO1xuICBjb25zdCBhZnRlclRlcm1zID0gdGhpcy50ZXJtcy5zbGljZSh0aGlzLmV4cGFuc2lvblBvcyArIDEpO1xuICByZXR1cm4gW1xuICAgICdzcGxpY2UnLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgYmVmb3JlVGVybXMubWFwKHRlcm0gPT4gdGVybS5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKSksXG4gICAgYWZ0ZXJUZXJtcy5tYXAodGVybSA9PiB0ZXJtLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpKVxuICBdO1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUub3V0cHV0UmVjaXBlID0gZnVuY3Rpb24oZm9ybWFscywgZ3JhbW1hckludGVydmFsKSB7XG4gIHJldHVybiBbXG4gICAgJ3NlcScsXG4gICAgZ2V0TWV0YUluZm8odGhpcywgZ3JhbW1hckludGVydmFsKVxuICBdLmNvbmNhdCh0aGlzLmZhY3RvcnMubWFwKGZhY3RvciA9PiBmYWN0b3Iub3V0cHV0UmVjaXBlKGZvcm1hbHMsIGdyYW1tYXJJbnRlcnZhbCkpKTtcbn07XG5cbnBleHBycy5TdGFyLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPVxucGV4cHJzLlBsdXMucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9XG5wZXhwcnMuT3B0LnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPVxucGV4cHJzLk5vdC5wcm90b3R5cGUub3V0cHV0UmVjaXBlID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLm91dHB1dFJlY2lwZSA9XG5wZXhwcnMuTGV4LnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLm5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMuZXhwci5vdXRwdXRSZWNpcGUoZm9ybWFscywgZ3JhbW1hckludGVydmFsKVxuICBdO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAnYXBwJyxcbiAgICBnZXRNZXRhSW5mbyh0aGlzLCBncmFtbWFySW50ZXJ2YWwpLFxuICAgIHRoaXMucnVsZU5hbWUsXG4gICAgdGhpcy5hcmdzLm1hcChhcmcgPT4gYXJnLm91dHB1dFJlY2lwZShmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpKVxuICBdO1xufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS5vdXRwdXRSZWNpcGUgPSBmdW5jdGlvbihmb3JtYWxzLCBncmFtbWFySW50ZXJ2YWwpIHtcbiAgcmV0dXJuIFtcbiAgICAndW5pY29kZUNoYXInLFxuICAgIGdldE1ldGFJbmZvKHRoaXMsIGdyYW1tYXJJbnRlcnZhbCksXG4gICAgdGhpcy5jYXRlZ29yeVxuICBdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAgUmV0dXJucyBhIFBFeHByIHRoYXQgcmVzdWx0cyBmcm9tIHJlY3Vyc2l2ZWx5IHJlcGxhY2luZyBldmVyeSBmb3JtYWwgcGFyYW1ldGVyIChpLmUuLCBpbnN0YW5jZVxuICBvZiBgUGFyYW1gKSBpbnNpZGUgdGhpcyBQRXhwciB3aXRoIGl0cyBhY3R1YWwgdmFsdWUgZnJvbSBgYWN0dWFsc2AgKGFuIEFycmF5KS5cblxuICBUaGUgcmVjZWl2ZXIgbXVzdCBub3QgYmUgbW9kaWZpZWQ7IGEgbmV3IFBFeHByIG11c3QgYmUgcmV0dXJuZWQgaWYgYW55IHJlcGxhY2VtZW50IGlzIG5lY2Vzc2FyeS5cbiovXG4vLyBmdW5jdGlvbihhY3R1YWxzKSB7IC4uLiB9XG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBjb21tb24uYWJzdHJhY3QoJ3N1YnN0aXR1dGVQYXJhbXMnKTtcblxucGV4cHJzLmFueS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5lbmQuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9IGZ1bmN0aW9uKGFjdHVhbHMpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wZXhwcnMuUGFyYW0ucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiBhY3R1YWxzW3RoaXMuaW5kZXhdO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9IGZ1bmN0aW9uKGFjdHVhbHMpIHtcbiAgcmV0dXJuIG5ldyBwZXhwcnMuQWx0KFxuICAgICAgdGhpcy50ZXJtcy5tYXAodGVybSA9PiB0ZXJtLnN1YnN0aXR1dGVQYXJhbXMoYWN0dWFscykpKTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPSBmdW5jdGlvbihhY3R1YWxzKSB7XG4gIHJldHVybiBuZXcgcGV4cHJzLlNlcShcbiAgICAgIHRoaXMuZmFjdG9ycy5tYXAoZmFjdG9yID0+IGZhY3Rvci5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpKSk7XG59O1xuXG5wZXhwcnMuSXRlci5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9XG5wZXhwcnMuTm90LnByb3RvdHlwZS5zdWJzdGl0dXRlUGFyYW1zID1cbnBleHBycy5Mb29rYWhlYWQucHJvdG90eXBlLnN1YnN0aXR1dGVQYXJhbXMgPVxucGV4cHJzLkxleC5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9IGZ1bmN0aW9uKGFjdHVhbHMpIHtcbiAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuZXhwci5zdWJzdGl0dXRlUGFyYW1zKGFjdHVhbHMpKTtcbn07XG5cbnBleHBycy5BcHBseS5wcm90b3R5cGUuc3Vic3RpdHV0ZVBhcmFtcyA9IGZ1bmN0aW9uKGFjdHVhbHMpIHtcbiAgaWYgKHRoaXMuYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBBdm9pZCBtYWtpbmcgYSBjb3B5IG9mIHRoaXMgYXBwbGljYXRpb24sIGFzIGFuIG9wdGltaXphdGlvblxuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3MubWFwKGFyZyA9PiBhcmcuc3Vic3RpdHV0ZVBhcmFtcyhhY3R1YWxzKSk7XG4gICAgcmV0dXJuIG5ldyBwZXhwcnMuQXBwbHkodGhpcy5ydWxlTmFtZSwgYXJncyk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbXBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgcGV4cHJzID0gcmVxdWlyZSgnLi9wZXhwcnMnKTtcblxuY29uc3Qge2NvcHlXaXRob3V0RHVwbGljYXRlc30gPSBjb21tb247XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpc1Jlc3RyaWN0ZWRKU0lkZW50aWZpZXIoc3RyKSB7XG4gIHJldHVybiAvXlthLXpBLVpfJF1bMC05YS16QS1aXyRdKiQvLnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUR1cGxpY2F0ZWROYW1lcyhhcmd1bWVudE5hbWVMaXN0KSB7XG4gIC8vIGBjb3VudGAgaXMgdXNlZCB0byByZWNvcmQgdGhlIG51bWJlciBvZiB0aW1lcyBlYWNoIGFyZ3VtZW50IG5hbWUgb2NjdXJzIGluIHRoZSBsaXN0LFxuICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgY2hlY2tpbmcgZHVwbGljYXRlZCBhcmd1bWVudCBuYW1lLiBJdCBtYXBzIGFyZ3VtZW50IG5hbWVzIHRvIGludHMuXG4gIGNvbnN0IGNvdW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgYXJndW1lbnROYW1lTGlzdC5mb3JFYWNoKGFyZ05hbWUgPT4ge1xuICAgIGNvdW50W2FyZ05hbWVdID0gKGNvdW50W2FyZ05hbWVdIHx8IDApICsgMTtcbiAgfSk7XG5cbiAgLy8gQXBwZW5kIHN1YnNjcmlwdHMgKCdfMScsICdfMicsIC4uLikgdG8gZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzLlxuICBPYmplY3Qua2V5cyhjb3VudCkuZm9yRWFjaChkdXBBcmdOYW1lID0+IHtcbiAgICBpZiAoY291bnRbZHVwQXJnTmFtZV0gPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgbmFtZSBzaG93cyB1cCBtb3JlIHRoYW4gb25jZSwgc28gYWRkIHN1YnNjcmlwdHMuXG4gICAgbGV0IHN1YnNjcmlwdCA9IDE7XG4gICAgYXJndW1lbnROYW1lTGlzdC5mb3JFYWNoKChhcmdOYW1lLCBpZHgpID0+IHtcbiAgICAgIGlmIChhcmdOYW1lID09PSBkdXBBcmdOYW1lKSB7XG4gICAgICAgIGFyZ3VtZW50TmFtZUxpc3RbaWR4XSA9IGFyZ05hbWUgKyAnXycgKyBzdWJzY3JpcHQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBSZXR1cm5zIGEgbGlzdCBvZiBzdHJpbmdzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBkZWZhdWx0IGFyZ3VtZW50IG5hbWVzIGZvciBpdHMgcmVjZWl2ZXJcbiAgKGEgcGV4cHIpIGluIGEgc2VtYW50aWMgYWN0aW9uLiBUaGlzIGlzIHVzZWQgZXhjbHVzaXZlbHkgYnkgdGhlIFNlbWFudGljcyBFZGl0b3IuXG5cbiAgYGZpcnN0QXJnSW5kZXhgIGlzIHRoZSAxLWJhc2VkIGluZGV4IG9mIHRoZSBmaXJzdCBhcmd1bWVudCBuYW1lIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWQgZm9yIHRoaXNcbiAgcGV4cHIuIEl0IGVuYWJsZXMgdXMgdG8gbmFtZSBhcmd1bWVudHMgcG9zaXRpb25hbGx5LCBlLmcuLCBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFcbiAgbm9uLWFscGhhbnVtZXJpYyB0ZXJtaW5hbCBsaWtlIFwiK1wiLCBpdCB3aWxsIGJlIG5hbWVkICckMicuXG5cbiAgYG5vRHVwQ2hlY2tgIGlzIHRydWUgaWYgdGhlIGNhbGxlciBvZiBgdG9Bcmd1bWVudE5hbWVMaXN0YCBpcyBub3QgYSB0b3AgbGV2ZWwgY2FsbGVyLiBJdCBlbmFibGVzXG4gIHVzIHRvIGF2b2lkIG5lc3RlZCBkdXBsaWNhdGlvbiBzdWJzY3JpcHRzIGFwcGVuZGluZywgZS5nLiwgJ18xXzEnLCAnXzFfMicsIGJ5IG9ubHkgY2hlY2tpbmdcbiAgZHVwbGljYXRlcyBhdCB0aGUgdG9wIGxldmVsLlxuXG4gIEhlcmUgaXMgYSBtb3JlIGVsYWJvcmF0ZSBleGFtcGxlIHRoYXQgaWxsdXN0cmF0ZXMgaG93IHRoaXMgbWV0aG9kIHdvcmtzOlxuICBgKGEgXCIrXCIgYikudG9Bcmd1bWVudE5hbWVMaXN0KDEpYCBldmFsdWF0ZXMgdG8gYFsnYScsICckMicsICdiJ11gIHdpdGggdGhlIGZvbGxvd2luZyByZWN1cnNpdmVcbiAgY2FsbHM6XG5cbiAgICAoYSkudG9Bcmd1bWVudE5hbWVMaXN0KDEpIC0+IFsnYSddLFxuICAgIChcIitcIikudG9Bcmd1bWVudE5hbWVMaXN0KDIpIC0+IFsnJDInXSxcbiAgICAoYikudG9Bcmd1bWVudE5hbWVMaXN0KDMpIC0+IFsnYiddXG5cbiAgTm90ZXM6XG4gICogVGhpcyBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCBvbiB3ZWxsLWZvcm1lZCBleHByZXNzaW9ucywgZS5nLiwgdGhlIHJlY2VpdmVyIG11c3RcbiAgICBub3QgaGF2ZSBhbnkgQWx0IHN1Yi1leHByZXNzaW9ucyB3aXRoIGluY29uc2lzdGVudCBhcml0aWVzLlxuICAqIGUuZ2V0QXJpdHkoKSA9PT0gZS50b0FyZ3VtZW50TmFtZUxpc3QoMSkubGVuZ3RoXG4qL1xuLy8gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykgeyAuLi4gfVxucGV4cHJzLlBFeHByLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBjb21tb24uYWJzdHJhY3QoJ3RvQXJndW1lbnROYW1lTGlzdCcpO1xuXG5wZXhwcnMuYW55LnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIFsnYW55J107XG59O1xuXG5wZXhwcnMuZW5kLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIFsnZW5kJ107XG59O1xuXG5wZXhwcnMuVGVybWluYWwucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgaWYgKHR5cGVvZiB0aGlzLm9iaiA9PT0gJ3N0cmluZycgJiYgL15bX2EtekEtWjAtOV0rJC8udGVzdCh0aGlzLm9iaikpIHtcbiAgICAvLyBJZiB0aGlzIHRlcm1pbmFsIGlzIGEgdmFsaWQgc3VmZml4IGZvciBhIEpTIGlkZW50aWZpZXIsIGp1c3QgcHJlcGVuZCBpdCB3aXRoICdfJ1xuICAgIHJldHVybiBbJ18nICsgdGhpcy5vYmpdO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgbmFtZSBpdCBwb3NpdGlvbmFsbHkuXG4gICAgcmV0dXJuIFsnJCcgKyBmaXJzdEFyZ0luZGV4XTtcbiAgfVxufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIGxldCBhcmdOYW1lID0gdGhpcy5mcm9tICsgJ190b18nICsgdGhpcy50bztcbiAgLy8gSWYgdGhlIGBhcmdOYW1lYCBpcyBub3QgdmFsaWQgdGhlbiB0cnkgdG8gcHJlcGVuZCBhIGBfYC5cbiAgaWYgKCFpc1Jlc3RyaWN0ZWRKU0lkZW50aWZpZXIoYXJnTmFtZSkpIHtcbiAgICBhcmdOYW1lID0gJ18nICsgYXJnTmFtZTtcbiAgfVxuICAvLyBJZiB0aGUgYGFyZ05hbWVgIHN0aWxsIG5vdCB2YWxpZCBhZnRlciBwcmVwZW5kaW5nIGEgYF9gLCB0aGVuIG5hbWUgaXQgcG9zaXRpb25hbGx5LlxuICBpZiAoIWlzUmVzdHJpY3RlZEpTSWRlbnRpZmllcihhcmdOYW1lKSkge1xuICAgIGFyZ05hbWUgPSAnJCcgKyBmaXJzdEFyZ0luZGV4O1xuICB9XG4gIHJldHVybiBbYXJnTmFtZV07XG59O1xuXG5wZXhwcnMuQWx0LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIC8vIGB0ZXJtQXJnTmFtZUxpc3RzYCBpcyBhbiBhcnJheSBvZiBhcnJheXMgd2hlcmUgZWFjaCByb3cgaXMgdGhlXG4gIC8vIGFyZ3VtZW50IG5hbWUgbGlzdCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgdGVybSBpbiB0aGlzIGFsdGVybmF0aW9uLlxuICBjb25zdCB0ZXJtQXJnTmFtZUxpc3RzID0gdGhpcy50ZXJtcy5tYXAodGVybSA9PiB0ZXJtLnRvQXJndW1lbnROYW1lTGlzdChmaXJzdEFyZ0luZGV4LCB0cnVlKSk7XG5cbiAgY29uc3QgYXJndW1lbnROYW1lTGlzdCA9IFtdO1xuICBjb25zdCBudW1BcmdzID0gdGVybUFyZ05hbWVMaXN0c1swXS5sZW5ndGg7XG4gIGZvciAobGV0IGNvbElkeCA9IDA7IGNvbElkeCA8IG51bUFyZ3M7IGNvbElkeCsrKSB7XG4gICAgY29uc3QgY29sID0gW107XG4gICAgZm9yIChsZXQgcm93SWR4ID0gMDsgcm93SWR4IDwgdGhpcy50ZXJtcy5sZW5ndGg7IHJvd0lkeCsrKSB7XG4gICAgICBjb2wucHVzaCh0ZXJtQXJnTmFtZUxpc3RzW3Jvd0lkeF1bY29sSWR4XSk7XG4gICAgfVxuICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gY29weVdpdGhvdXREdXBsaWNhdGVzKGNvbCk7XG4gICAgYXJndW1lbnROYW1lTGlzdC5wdXNoKHVuaXF1ZU5hbWVzLmpvaW4oJ19vcl8nKSk7XG4gIH1cblxuICBpZiAoIW5vRHVwQ2hlY2spIHtcbiAgICByZXNvbHZlRHVwbGljYXRlZE5hbWVzKGFyZ3VtZW50TmFtZUxpc3QpO1xuICB9XG4gIHJldHVybiBhcmd1bWVudE5hbWVMaXN0O1xufTtcblxucGV4cHJzLlNlcS5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICAvLyBHZW5lcmF0ZSB0aGUgYXJndW1lbnQgbmFtZSBsaXN0LCB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IGR1cGxpY2F0ZXMuXG4gIGxldCBhcmd1bWVudE5hbWVMaXN0ID0gW107XG4gIHRoaXMuZmFjdG9ycy5mb3JFYWNoKGZhY3RvciA9PiB7XG4gICAgY29uc3QgZmFjdG9yQXJndW1lbnROYW1lTGlzdCA9IGZhY3Rvci50b0FyZ3VtZW50TmFtZUxpc3QoZmlyc3RBcmdJbmRleCwgdHJ1ZSk7XG4gICAgYXJndW1lbnROYW1lTGlzdCA9IGFyZ3VtZW50TmFtZUxpc3QuY29uY2F0KGZhY3RvckFyZ3VtZW50TmFtZUxpc3QpO1xuXG4gICAgLy8gU2hpZnQgdGhlIGZpcnN0QXJnSW5kZXggdG8gdGFrZSB0aGlzIGZhY3RvcidzIGFyZ3VtZW50IG5hbWVzIGludG8gYWNjb3VudC5cbiAgICBmaXJzdEFyZ0luZGV4ICs9IGZhY3RvckFyZ3VtZW50TmFtZUxpc3QubGVuZ3RoO1xuICB9KTtcbiAgaWYgKCFub0R1cENoZWNrKSB7XG4gICAgcmVzb2x2ZUR1cGxpY2F0ZWROYW1lcyhhcmd1bWVudE5hbWVMaXN0KTtcbiAgfVxuICByZXR1cm4gYXJndW1lbnROYW1lTGlzdDtcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIGNvbnN0IGFyZ3VtZW50TmFtZUxpc3QgPSB0aGlzLmV4cHIudG9Bcmd1bWVudE5hbWVMaXN0KGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spXG4gICAgICAubWFwKGV4cHJBcmd1bWVudFN0cmluZyA9PiBleHByQXJndW1lbnRTdHJpbmdbZXhwckFyZ3VtZW50U3RyaW5nLmxlbmd0aCAtIDFdID09PSAncycgP1xuICAgICAgICAgIGV4cHJBcmd1bWVudFN0cmluZyArICdlcycgOlxuICAgICAgICAgIGV4cHJBcmd1bWVudFN0cmluZyArICdzJyk7XG4gIGlmICghbm9EdXBDaGVjaykge1xuICAgIHJlc29sdmVEdXBsaWNhdGVkTmFtZXMoYXJndW1lbnROYW1lTGlzdCk7XG4gIH1cbiAgcmV0dXJuIGFyZ3VtZW50TmFtZUxpc3Q7XG59O1xuXG5wZXhwcnMuT3B0LnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiB0aGlzLmV4cHIudG9Bcmd1bWVudE5hbWVMaXN0KGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spLm1hcChhcmdOYW1lID0+IHtcbiAgICByZXR1cm4gJ29wdCcgKyBhcmdOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBhcmdOYW1lLnNsaWNlKDEpO1xuICB9KTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIFtdO1xufTtcblxucGV4cHJzLkxvb2thaGVhZC5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID1cbnBleHBycy5MZXgucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIHRoaXMuZXhwci50b0FyZ3VtZW50TmFtZUxpc3QoZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjayk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLnRvQXJndW1lbnROYW1lTGlzdCA9IGZ1bmN0aW9uKGZpcnN0QXJnSW5kZXgsIG5vRHVwQ2hlY2spIHtcbiAgcmV0dXJuIFt0aGlzLnJ1bGVOYW1lXTtcbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUudG9Bcmd1bWVudE5hbWVMaXN0ID0gZnVuY3Rpb24oZmlyc3RBcmdJbmRleCwgbm9EdXBDaGVjaykge1xuICByZXR1cm4gWyckJyArIGZpcnN0QXJnSW5kZXhdO1xufTtcblxucGV4cHJzLlBhcmFtLnByb3RvdHlwZS50b0FyZ3VtZW50TmFtZUxpc3QgPSBmdW5jdGlvbihmaXJzdEFyZ0luZGV4LCBub0R1cENoZWNrKSB7XG4gIHJldHVybiBbJ3BhcmFtJyArIHRoaXMuaW5kZXhdO1xufTtcblxuLy8gXCJWYWx1ZSBwZXhwcnNcIiAoVmFsdWUsIFN0ciwgQXJyLCBPYmopIGFyZSBnb2luZyBhd2F5IHNvb24sIHNvIHdlIGRvbid0IHdvcnJ5IGFib3V0IHRoZW0gaGVyZS5cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIFBFeHByLCBmb3IgdXNlIGFzIGEgVUkgbGFiZWwsIGV0Yy5cbnBleHBycy5QRXhwci5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID0gY29tbW9uLmFic3RyYWN0KCd0b0Rpc3BsYXlTdHJpbmcnKTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5TZXEucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UudHJpbW1lZCgpLmNvbnRlbnRzO1xuICB9XG4gIHJldHVybiAnWycgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnXSc7XG59O1xuXG5wZXhwcnMuYW55LnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuZW5kLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuSXRlci5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5Ob3QucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9XG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS50b0Rpc3BsYXlTdHJpbmcgPVxucGV4cHJzLkxleC5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5SYW5nZS5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID1cbnBleHBycy5QYXJhbS5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG59O1xuXG5wZXhwcnMuQXBwbHkucHJvdG90eXBlLnRvRGlzcGxheVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwcyA9IHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy50b0Rpc3BsYXlTdHJpbmcoKSk7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWUgKyAnPCcgKyBwcy5qb2luKCcsJykgKyAnPic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWU7XG4gIH1cbn07XG5cbnBleHBycy5Vbmljb2RlQ2hhci5wcm90b3R5cGUudG9EaXNwbGF5U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnVW5pY29kZSBbJyArIHRoaXMuY2F0ZWdvcnkgKyAnXSBjaGFyYWN0ZXInO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEZhaWx1cmUgPSByZXF1aXJlKCcuL0ZhaWx1cmUnKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBwZXhwcnMgPSByZXF1aXJlKCcuL3BleHBycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucGV4cHJzLlBFeHByLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBjb21tb24uYWJzdHJhY3QoJ3RvRmFpbHVyZScpO1xuXG5wZXhwcnMuYW55LnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsICdhbnkgb2JqZWN0JywgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuZW5kLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsICdlbmQgb2YgaW5wdXQnLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5UZXJtaW5hbC5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgdGhpcy5vYmosICdzdHJpbmcnKTtcbn07XG5cbnBleHBycy5SYW5nZS5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICAvLyBUT0RPOiBjb21lIHVwIHdpdGggc29tZXRoaW5nIGJldHRlclxuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgSlNPTi5zdHJpbmdpZnkodGhpcy5mcm9tKSArICcuLicgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnRvKSwgJ2NvZGUnKTtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLmV4cHIgPT09IHBleHBycy5hbnkgP1xuICAgICAgJ25vdGhpbmcnIDpcbiAgICAgICdub3QgJyArIHRoaXMuZXhwci50b0ZhaWx1cmUoZ3JhbW1hcik7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBkZXNjcmlwdGlvbiwgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiB0aGlzLmV4cHIudG9GYWlsdXJlKGdyYW1tYXIpO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGxldCBkZXNjcmlwdGlvbiA9IGdyYW1tYXIucnVsZXNbdGhpcy5ydWxlTmFtZV0uZGVzY3JpcHRpb247XG4gIGlmICghZGVzY3JpcHRpb24pIHtcbiAgICBjb25zdCBhcnRpY2xlID0gKC9eW2FlaW91QUVJT1VdLy50ZXN0KHRoaXMucnVsZU5hbWUpID8gJ2FuJyA6ICdhJyk7XG4gICAgZGVzY3JpcHRpb24gPSBhcnRpY2xlICsgJyAnICsgdGhpcy5ydWxlTmFtZTtcbiAgfVxuICByZXR1cm4gbmV3IEZhaWx1cmUodGhpcywgZGVzY3JpcHRpb24sICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCAnYSBVbmljb2RlIFsnICsgdGhpcy5jYXRlZ29yeSArICddIGNoYXJhY3RlcicsICdkZXNjcmlwdGlvbicpO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUudG9GYWlsdXJlID0gZnVuY3Rpb24oZ3JhbW1hcikge1xuICBjb25zdCBmcyA9IHRoaXMudGVybXMubWFwKHQgPT4gdC50b0ZhaWx1cmUoZ3JhbW1hcikpO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9ICcoJyArIGZzLmpvaW4oJyBvciAnKSArICcpJztcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIGRlc2NyaXB0aW9uLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLnRvRmFpbHVyZSA9IGZ1bmN0aW9uKGdyYW1tYXIpIHtcbiAgY29uc3QgZnMgPSB0aGlzLmZhY3RvcnMubWFwKGYgPT4gZi50b0ZhaWx1cmUoZ3JhbW1hcikpO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9ICcoJyArIGZzLmpvaW4oJyAnKSArICcpJztcbiAgcmV0dXJuIG5ldyBGYWlsdXJlKHRoaXMsIGRlc2NyaXB0aW9uLCAnZGVzY3JpcHRpb24nKTtcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS50b0ZhaWx1cmUgPSBmdW5jdGlvbihncmFtbWFyKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gJygnICsgdGhpcy5leHByLnRvRmFpbHVyZShncmFtbWFyKSArIHRoaXMub3BlcmF0b3IgKyAnKSc7XG4gIHJldHVybiBuZXcgRmFpbHVyZSh0aGlzLCBkZXNjcmlwdGlvbiwgJ2Rlc2NyaXB0aW9uJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW1wb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IHBleHBycyA9IHJlcXVpcmUoJy4vcGV4cHJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICBlMS50b1N0cmluZygpID09PSBlMi50b1N0cmluZygpID09PiBlMSBhbmQgZTIgYXJlIHNlbWFudGljYWxseSBlcXVpdmFsZW50LlxuICBOb3RlIHRoYXQgdGhpcyBpcyBub3QgYW4gaWZmICg8PT0+KTogZS5nLixcbiAgKH5cImJcIiBcImFcIikudG9TdHJpbmcoKSAhPT0gKFwiYVwiKS50b1N0cmluZygpLCBldmVuIHRob3VnaFxuICB+XCJiXCIgXCJhXCIgYW5kIFwiYVwiIGFyZSBpbnRlcmNoYW5nZWFibGUgaW4gYW55IGdyYW1tYXIsXG4gIGJvdGggaW4gdGVybXMgb2YgdGhlIGxhbmd1YWdlcyB0aGV5IGFjY2VwdCBhbmQgdGhlaXIgYXJpdGllcy5cbiovXG5wZXhwcnMuUEV4cHIucHJvdG90eXBlLnRvU3RyaW5nID0gY29tbW9uLmFic3RyYWN0KCd0b1N0cmluZycpO1xuXG5wZXhwcnMuYW55LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnYW55Jztcbn07XG5cbnBleHBycy5lbmQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdlbmQnO1xufTtcblxucGV4cHJzLlRlcm1pbmFsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5vYmopO1xufTtcblxucGV4cHJzLlJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5mcm9tKSArICcuLicgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnRvKTtcbn07XG5cbnBleHBycy5QYXJhbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICckJyArIHRoaXMuaW5kZXg7XG59O1xuXG5wZXhwcnMuTGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJyMoJyArIHRoaXMuZXhwci50b1N0cmluZygpICsgJyknO1xufTtcblxucGV4cHJzLkFsdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGVybXMubGVuZ3RoID09PSAxID9cbiAgICB0aGlzLnRlcm1zWzBdLnRvU3RyaW5nKCkgOlxuICAgICcoJyArIHRoaXMudGVybXMubWFwKHRlcm0gPT4gdGVybS50b1N0cmluZygpKS5qb2luKCcgfCAnKSArICcpJztcbn07XG5cbnBleHBycy5TZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZhY3RvcnMubGVuZ3RoID09PSAxID9cbiAgICB0aGlzLmZhY3RvcnNbMF0udG9TdHJpbmcoKSA6XG4gICAgJygnICsgdGhpcy5mYWN0b3JzLm1hcChmYWN0b3IgPT4gZmFjdG9yLnRvU3RyaW5nKCkpLmpvaW4oJyAnKSArICcpJztcbn07XG5cbnBleHBycy5JdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5leHByICsgdGhpcy5vcGVyYXRvcjtcbn07XG5cbnBleHBycy5Ob3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnficgKyB0aGlzLmV4cHI7XG59O1xuXG5wZXhwcnMuTG9va2FoZWFkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJyYnICsgdGhpcy5leHByO1xufTtcblxucGV4cHJzLkFwcGx5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwcyA9IHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy50b1N0cmluZygpKTtcbiAgICByZXR1cm4gdGhpcy5ydWxlTmFtZSArICc8JyArIHBzLmpvaW4oJywnKSArICc+JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlTmFtZTtcbiAgfVxufTtcblxucGV4cHJzLlVuaWNvZGVDaGFyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ1xcXFxweycgKyB0aGlzLmNhdGVnb3J5ICsgJ30nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFVuaWNvZGVDYXRlZ29yaWVzID0gcmVxdWlyZSgnLi4vdGhpcmRfcGFydHkvVW5pY29kZUNhdGVnb3JpZXMnKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBHZW5lcmFsIHN0dWZmXG5cbmNsYXNzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IFBFeHByKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQRXhwciBjYW5ub3QgYmUgaW5zdGFudGlhdGVkIC0tIGl0J3MgYWJzdHJhY3RcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byB0aGUgaW50ZXJ2YWwgY29udGFpbmluZyB0aGUgc291cmNlIGZvciB0aGlzIGV4cHJlc3Npb24uXG4gIHdpdGhTb3VyY2UoaW50ZXJ2YWwpIHtcbiAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuc291cmNlID0gaW50ZXJ2YWwudHJpbW1lZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vLyBBbnlcblxuY29uc3QgYW55ID0gT2JqZWN0LmNyZWF0ZShQRXhwci5wcm90b3R5cGUpO1xuXG4vLyBFbmRcblxuY29uc3QgZW5kID0gT2JqZWN0LmNyZWF0ZShQRXhwci5wcm90b3R5cGUpO1xuXG4vLyBUZXJtaW5hbHNcblxuY2xhc3MgVGVybWluYWwgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKG9iaikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYmogPSBvYmo7XG4gIH1cbn1cblxuLy8gUmFuZ2VzXG5cbmNsYXNzIFJhbmdlIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB0aGlzLnRvID0gdG87XG4gIH1cbn1cblxuLy8gUGFyYW1ldGVyc1xuXG5jbGFzcyBQYXJhbSBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoaW5kZXgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgfVxufVxuXG4vLyBBbHRlcm5hdGlvblxuXG5jbGFzcyBBbHQgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKHRlcm1zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRlcm1zID0gdGVybXM7XG4gIH1cbn1cblxuLy8gRXh0ZW5kIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBydWxlIGV4dGVuc2lvblxuXG5jbGFzcyBFeHRlbmQgZXh0ZW5kcyBBbHQge1xuICBjb25zdHJ1Y3RvcihzdXBlckdyYW1tYXIsIG5hbWUsIGJvZHkpIHtcbiAgICBjb25zdCBvcmlnQm9keSA9IHN1cGVyR3JhbW1hci5ydWxlc1tuYW1lXS5ib2R5O1xuICAgIHN1cGVyKFtib2R5LCBvcmlnQm9keV0pO1xuXG4gICAgdGhpcy5zdXBlckdyYW1tYXIgPSBzdXBlckdyYW1tYXI7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICB9XG59XG5cbi8vIFNwbGljZSBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgcnVsZSBvdmVycmlkaW5nIHdpdGggdGhlIGAuLi5gIG9wZXJhdG9yLlxuY2xhc3MgU3BsaWNlIGV4dGVuZHMgQWx0IHtcbiAgY29uc3RydWN0b3Ioc3VwZXJHcmFtbWFyLCBydWxlTmFtZSwgYmVmb3JlVGVybXMsIGFmdGVyVGVybXMpIHtcbiAgICBjb25zdCBvcmlnQm9keSA9IHN1cGVyR3JhbW1hci5ydWxlc1tydWxlTmFtZV0uYm9keTtcbiAgICBzdXBlcihbLi4uYmVmb3JlVGVybXMsIG9yaWdCb2R5LCAuLi5hZnRlclRlcm1zXSk7XG5cbiAgICB0aGlzLnN1cGVyR3JhbW1hciA9IHN1cGVyR3JhbW1hcjtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgdGhpcy5leHBhbnNpb25Qb3MgPSBiZWZvcmVUZXJtcy5sZW5ndGg7XG4gIH1cbn1cblxuLy8gU2VxdWVuY2VzXG5cbmNsYXNzIFNlcSBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoZmFjdG9ycykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mYWN0b3JzID0gZmFjdG9ycztcbiAgfVxufVxuXG4vLyBJdGVyYXRvcnMgYW5kIG9wdGlvbmFsc1xuXG5jbGFzcyBJdGVyIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihleHByKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICB9XG59XG5cbmNsYXNzIFN0YXIgZXh0ZW5kcyBJdGVyIHt9XG5jbGFzcyBQbHVzIGV4dGVuZHMgSXRlciB7fVxuY2xhc3MgT3B0IGV4dGVuZHMgSXRlciB7fVxuXG5TdGFyLnByb3RvdHlwZS5vcGVyYXRvciA9ICcqJztcblBsdXMucHJvdG90eXBlLm9wZXJhdG9yID0gJysnO1xuT3B0LnByb3RvdHlwZS5vcGVyYXRvciA9ICc/JztcblxuU3Rhci5wcm90b3R5cGUubWluTnVtTWF0Y2hlcyA9IDA7XG5QbHVzLnByb3RvdHlwZS5taW5OdW1NYXRjaGVzID0gMTtcbk9wdC5wcm90b3R5cGUubWluTnVtTWF0Y2hlcyA9IDA7XG5cblN0YXIucHJvdG90eXBlLm1heE51bU1hdGNoZXMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5QbHVzLnByb3RvdHlwZS5tYXhOdW1NYXRjaGVzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuT3B0LnByb3RvdHlwZS5tYXhOdW1NYXRjaGVzID0gMTtcblxuLy8gUHJlZGljYXRlc1xuXG5jbGFzcyBOb3QgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKGV4cHIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gIH1cbn1cblxuY2xhc3MgTG9va2FoZWFkIGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihleHByKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICB9XG59XG5cbi8vIFwiTGV4aWZpY2F0aW9uXCJcblxuY2xhc3MgTGV4IGV4dGVuZHMgUEV4cHIge1xuICBjb25zdHJ1Y3RvcihleHByKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICB9XG59XG5cbi8vIFJ1bGUgYXBwbGljYXRpb25cblxuY2xhc3MgQXBwbHkgZXh0ZW5kcyBQRXhwciB7XG4gIGNvbnN0cnVjdG9yKHJ1bGVOYW1lLCBhcmdzPVtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuXG4gIGlzU3ludGFjdGljKCkge1xuICAgIHJldHVybiBjb21tb24uaXNTeW50YWN0aWModGhpcy5ydWxlTmFtZSk7XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBqdXN0IGNhY2hlcyB0aGUgcmVzdWx0IG9mIGB0aGlzLnRvU3RyaW5nKClgIGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gIHRvTWVtb0tleSgpIHtcbiAgICBpZiAoIXRoaXMuX21lbW9LZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX21lbW9LZXknLCB7dmFsdWU6IHRoaXMudG9TdHJpbmcoKX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWVtb0tleTtcbiAgfVxufVxuXG4vLyBVbmljb2RlIGNoYXJhY3RlclxuXG5jbGFzcyBVbmljb2RlQ2hhciBleHRlbmRzIFBFeHByIHtcbiAgY29uc3RydWN0b3IoY2F0ZWdvcnkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgICB0aGlzLnBhdHRlcm4gPSBVbmljb2RlQ2F0ZWdvcmllc1tjYXRlZ29yeV07XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMuUEV4cHIgPSBQRXhwcjtcbmV4cG9ydHMuYW55ID0gYW55O1xuZXhwb3J0cy5lbmQgPSBlbmQ7XG5leHBvcnRzLlRlcm1pbmFsID0gVGVybWluYWw7XG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5leHBvcnRzLlBhcmFtID0gUGFyYW07XG5leHBvcnRzLkFsdCA9IEFsdDtcbmV4cG9ydHMuRXh0ZW5kID0gRXh0ZW5kO1xuZXhwb3J0cy5TcGxpY2UgPSBTcGxpY2U7XG5leHBvcnRzLlNlcSA9IFNlcTtcbmV4cG9ydHMuSXRlciA9IEl0ZXI7XG5leHBvcnRzLlN0YXIgPSBTdGFyO1xuZXhwb3J0cy5QbHVzID0gUGx1cztcbmV4cG9ydHMuT3B0ID0gT3B0O1xuZXhwb3J0cy5Ob3QgPSBOb3Q7XG5leHBvcnRzLkxvb2thaGVhZCA9IExvb2thaGVhZDtcbmV4cG9ydHMuTGV4ID0gTGV4O1xuZXhwb3J0cy5BcHBseSA9IEFwcGx5O1xuZXhwb3J0cy5Vbmljb2RlQ2hhciA9IFVuaWNvZGVDaGFyO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXh0ZW5zaW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucmVxdWlyZSgnLi9wZXhwcnMtYWxsb3dzU2tpcHBpbmdQcmVjZWRpbmdTcGFjZScpO1xucmVxdWlyZSgnLi9wZXhwcnMtYXNzZXJ0QWxsQXBwbGljYXRpb25zQXJlVmFsaWQnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWFzc2VydENob2ljZXNIYXZlVW5pZm9ybUFyaXR5Jyk7XG5yZXF1aXJlKCcuL3BleHBycy1hc3NlcnRJdGVyYXRlZEV4cHJzQXJlTm90TnVsbGFibGUnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWNoZWNrJyk7XG5yZXF1aXJlKCcuL3BleHBycy1ldmFsJyk7XG5yZXF1aXJlKCcuL3BleHBycy1nZXRBcml0eScpO1xucmVxdWlyZSgnLi9wZXhwcnMtZ2VuZXJhdGVFeGFtcGxlJyk7XG5yZXF1aXJlKCcuL3BleHBycy1vdXRwdXRSZWNpcGUnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLWludHJvZHVjZVBhcmFtcycpO1xucmVxdWlyZSgnLi9wZXhwcnMtaXNOdWxsYWJsZScpO1xucmVxdWlyZSgnLi9wZXhwcnMtc3Vic3RpdHV0ZVBhcmFtcycpO1xucmVxdWlyZSgnLi9wZXhwcnMtdG9EaXNwbGF5U3RyaW5nJyk7XG5yZXF1aXJlKCcuL3BleHBycy10b0FyZ3VtZW50TmFtZUxpc3QnKTtcbnJlcXVpcmUoJy4vcGV4cHJzLXRvRmFpbHVyZScpO1xucmVxdWlyZSgnLi9wZXhwcnMtdG9TdHJpbmcnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltcG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIHN0dWZmXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBHaXZlbiBhbiBhcnJheSBvZiBudW1iZXJzIGBhcnJgLCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIG51bWJlcnMgYXMgc3RyaW5ncyxcbi8vIHJpZ2h0LWp1c3RpZmllZCBhbmQgcGFkZGVkIHRvIHRoZSBzYW1lIGxlbmd0aC5cbmZ1bmN0aW9uIHBhZE51bWJlcnNUb0VxdWFsTGVuZ3RoKGFycikge1xuICBsZXQgbWF4TGVuID0gMDtcbiAgY29uc3Qgc3RyaW5ncyA9IGFyci5tYXAobiA9PiB7XG4gICAgY29uc3Qgc3RyID0gbi50b1N0cmluZygpO1xuICAgIG1heExlbiA9IE1hdGgubWF4KG1heExlbiwgc3RyLmxlbmd0aCk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfSk7XG4gIHJldHVybiBzdHJpbmdzLm1hcChzID0+IGNvbW1vbi5wYWRMZWZ0KHMsIG1heExlbikpO1xufVxuXG4vLyBQcm9kdWNlIGEgbmV3IHN0cmluZyB0aGF0IHdvdWxkIGJlIHRoZSByZXN1bHQgb2YgY29weWluZyB0aGUgY29udGVudHNcbi8vIG9mIHRoZSBzdHJpbmcgYHNyY2Agb250byBgZGVzdGAgYXQgb2Zmc2V0IGBvZmZlc3RgLlxuZnVuY3Rpb24gc3RyY3B5KGRlc3QsIHNyYywgb2Zmc2V0KSB7XG4gIGNvbnN0IG9yaWdEZXN0TGVuID0gZGVzdC5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gZGVzdC5zbGljZSgwLCBvZmZzZXQpO1xuICBjb25zdCBlbmQgPSBkZXN0LnNsaWNlKG9mZnNldCArIHNyYy5sZW5ndGgpO1xuICByZXR1cm4gKHN0YXJ0ICsgc3JjICsgZW5kKS5zdWJzdHIoMCwgb3JpZ0Rlc3RMZW4pO1xufVxuXG4vLyBDYXN0cyB0aGUgdW5kZXJseWluZyBsaW5lQW5kQ29sIG9iamVjdCB0byBhIGZvcm1hdHRlZCBtZXNzYWdlIHN0cmluZyxcbi8vIGhpZ2hsaWdodGluZyBgcmFuZ2VzYC5cbmZ1bmN0aW9uIGxpbmVBbmRDb2x1bW5Ub01lc3NhZ2UoLi4ucmFuZ2VzKSB7XG4gIGNvbnN0IGxpbmVBbmRDb2wgPSB0aGlzO1xuICBjb25zdCBvZmZzZXQgPSBsaW5lQW5kQ29sLm9mZnNldDtcbiAgY29uc3QgcmVwZWF0U3RyID0gY29tbW9uLnJlcGVhdFN0cjtcblxuICBjb25zdCBzYiA9IG5ldyBjb21tb24uU3RyaW5nQnVmZmVyKCk7XG4gIHNiLmFwcGVuZCgnTGluZSAnICsgbGluZUFuZENvbC5saW5lTnVtICsgJywgY29sICcgKyBsaW5lQW5kQ29sLmNvbE51bSArICc6XFxuJyk7XG5cbiAgLy8gQW4gYXJyYXkgb2YgdGhlIHByZXZpb3VzLCBjdXJyZW50LCBhbmQgbmV4dCBsaW5lIG51bWJlcnMgYXMgc3RyaW5ncyBvZiBlcXVhbCBsZW5ndGguXG4gIGNvbnN0IGxpbmVOdW1iZXJzID0gcGFkTnVtYmVyc1RvRXF1YWxMZW5ndGgoW1xuICAgIGxpbmVBbmRDb2wucHJldkxpbmUgPT0gbnVsbCA/IDAgOiBsaW5lQW5kQ29sLmxpbmVOdW0gLSAxLFxuICAgIGxpbmVBbmRDb2wubGluZU51bSxcbiAgICBsaW5lQW5kQ29sLm5leHRMaW5lID09IG51bGwgPyAwIDogbGluZUFuZENvbC5saW5lTnVtICsgMVxuICBdKTtcblxuICAvLyBIZWxwZXIgZm9yIGFwcGVuZGluZyBmb3JtYXR0aW5nIGlucHV0IGxpbmVzIHRvIHRoZSBidWZmZXIuXG4gIGNvbnN0IGFwcGVuZExpbmUgPSAobnVtLCBjb250ZW50LCBwcmVmaXgpID0+IHtcbiAgICBzYi5hcHBlbmQocHJlZml4ICsgbGluZU51bWJlcnNbbnVtXSArICcgfCAnICsgY29udGVudCArICdcXG4nKTtcbiAgfTtcblxuICAvLyBJbmNsdWRlIHRoZSBwcmV2aW91cyBsaW5lIGZvciBjb250ZXh0IGlmIHBvc3NpYmxlLlxuICBpZiAobGluZUFuZENvbC5wcmV2TGluZSAhPSBudWxsKSB7XG4gICAgYXBwZW5kTGluZSgwLCBsaW5lQW5kQ29sLnByZXZMaW5lLCAnICAnKTtcbiAgfVxuICAvLyBMaW5lIHRoYXQgdGhlIGVycm9yIG9jY3VycmVkIG9uLlxuICBhcHBlbmRMaW5lKDEsIGxpbmVBbmRDb2wubGluZSwgJz4gJyk7XG5cbiAgLy8gQnVpbGQgdXAgdGhlIGxpbmUgdGhhdCBwb2ludHMgdG8gdGhlIG9mZnNldCBhbmQgcG9zc2libGUgaW5kaWNhdGVzIG9uZSBvciBtb3JlIHJhbmdlcy5cbiAgLy8gU3RhcnQgd2l0aCBhIGJsYW5rIGxpbmUsIGFuZCBpbmRpY2F0ZSBlYWNoIHJhbmdlIGJ5IG92ZXJsYXlpbmcgYSBzdHJpbmcgb2YgYH5gIGNoYXJzLlxuICBjb25zdCBsaW5lTGVuID0gbGluZUFuZENvbC5saW5lLmxlbmd0aDtcbiAgbGV0IGluZGljYXRpb25MaW5lID0gcmVwZWF0U3RyKCcgJywgbGluZUxlbiArIDEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7ICsraSkge1xuICAgIGxldCBzdGFydElkeCA9IHJhbmdlc1tpXVswXTtcbiAgICBsZXQgZW5kSWR4ID0gcmFuZ2VzW2ldWzFdO1xuICAgIGNvbW1vbi5hc3NlcnQoc3RhcnRJZHggPj0gMCAmJiBzdGFydElkeCA8PSBlbmRJZHgsICdyYW5nZSBzdGFydCBtdXN0IGJlID49IDAgYW5kIDw9IGVuZCcpO1xuXG4gICAgY29uc3QgbGluZVN0YXJ0T2Zmc2V0ID0gb2Zmc2V0IC0gbGluZUFuZENvbC5jb2xOdW0gKyAxO1xuICAgIHN0YXJ0SWR4ID0gTWF0aC5tYXgoMCwgc3RhcnRJZHggLSBsaW5lU3RhcnRPZmZzZXQpO1xuICAgIGVuZElkeCA9IE1hdGgubWluKGVuZElkeCAtIGxpbmVTdGFydE9mZnNldCwgbGluZUxlbik7XG5cbiAgICBpbmRpY2F0aW9uTGluZSA9IHN0cmNweShpbmRpY2F0aW9uTGluZSwgcmVwZWF0U3RyKCd+JywgZW5kSWR4IC0gc3RhcnRJZHgpLCBzdGFydElkeCk7XG4gIH1cbiAgY29uc3QgZ3V0dGVyV2lkdGggPSAyICsgbGluZU51bWJlcnNbMV0ubGVuZ3RoICsgMztcbiAgc2IuYXBwZW5kKHJlcGVhdFN0cignICcsIGd1dHRlcldpZHRoKSk7XG4gIGluZGljYXRpb25MaW5lID0gc3RyY3B5KGluZGljYXRpb25MaW5lLCAnXicsIGxpbmVBbmRDb2wuY29sTnVtIC0gMSk7XG4gIHNiLmFwcGVuZChpbmRpY2F0aW9uTGluZS5yZXBsYWNlKC8gKyQvLCAnJykgKyAnXFxuJyk7XG5cbiAgLy8gSW5jbHVkZSB0aGUgbmV4dCBsaW5lIGZvciBjb250ZXh0IGlmIHBvc3NpYmxlLlxuICBpZiAobGluZUFuZENvbC5uZXh0TGluZSAhPSBudWxsKSB7XG4gICAgYXBwZW5kTGluZSgyLCBsaW5lQW5kQ29sLm5leHRMaW5lLCAnICAnKTtcbiAgfVxuICByZXR1cm4gc2IuY29udGVudHMoKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgYnVpbHRJblJ1bGVzQ2FsbGJhY2tzID0gW107XG5cbi8vIFNpbmNlIEdyYW1tYXIuQnVpbHRJblJ1bGVzIGlzIGJvb3RzdHJhcHBlZCwgbW9zdCBvZiBPaG0gY2FuJ3QgZGlyZWN0bHkgZGVwZW5kIGl0LlxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgbW9kdWxlcyB0aGF0IGRvIGRlcGVuZCBvbiB0aGUgYnVpbHQtaW4gcnVsZXMgdG8gcmVnaXN0ZXIgYSBjYWxsYmFja1xuLy8gdGhhdCB3aWxsIGJlIGNhbGxlZCBsYXRlciBpbiB0aGUgaW5pdGlhbGl6YXRpb24gcHJvY2Vzcy5cbmV4cG9ydHMuYXdhaXRCdWlsdEluUnVsZXMgPSBjYiA9PiB7XG4gIGJ1aWx0SW5SdWxlc0NhbGxiYWNrcy5wdXNoKGNiKTtcbn07XG5cbmV4cG9ydHMuYW5ub3VuY2VCdWlsdEluUnVsZXMgPSBncmFtbWFyID0+IHtcbiAgYnVpbHRJblJ1bGVzQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgIGNiKGdyYW1tYXIpO1xuICB9KTtcbiAgYnVpbHRJblJ1bGVzQ2FsbGJhY2tzID0gbnVsbDtcbn07XG5cbi8vIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW5cbi8vIG9mZnNldCBpbiBgc3RyYC5cbmV4cG9ydHMuZ2V0TGluZUFuZENvbHVtbiA9IChzdHIsIG9mZnNldCkgPT4ge1xuICBsZXQgbGluZU51bSA9IDE7XG4gIGxldCBjb2xOdW0gPSAxO1xuXG4gIGxldCBjdXJyT2Zmc2V0ID0gMDtcbiAgbGV0IGxpbmVTdGFydE9mZnNldCA9IDA7XG5cbiAgbGV0IG5leHRMaW5lID0gbnVsbDtcbiAgbGV0IHByZXZMaW5lID0gbnVsbDtcbiAgbGV0IHByZXZMaW5lU3RhcnRPZmZzZXQgPSAtMTtcblxuICB3aGlsZSAoY3Vyck9mZnNldCA8IG9mZnNldCkge1xuICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGN1cnJPZmZzZXQrKyk7XG4gICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICBsaW5lTnVtKys7XG4gICAgICBjb2xOdW0gPSAxO1xuICAgICAgcHJldkxpbmVTdGFydE9mZnNldCA9IGxpbmVTdGFydE9mZnNldDtcbiAgICAgIGxpbmVTdGFydE9mZnNldCA9IGN1cnJPZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChjICE9PSAnXFxyJykge1xuICAgICAgY29sTnVtKys7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgZW5kIG9mIHRoZSB0YXJnZXQgbGluZS5cbiAgbGV0IGxpbmVFbmRPZmZzZXQgPSBzdHIuaW5kZXhPZignXFxuJywgbGluZVN0YXJ0T2Zmc2V0KTtcbiAgaWYgKGxpbmVFbmRPZmZzZXQgPT09IC0xKSB7XG4gICAgbGluZUVuZE9mZnNldCA9IHN0ci5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGxpbmUuXG4gICAgY29uc3QgbmV4dExpbmVFbmRPZmZzZXQgPSBzdHIuaW5kZXhPZignXFxuJywgbGluZUVuZE9mZnNldCArIDEpO1xuICAgIG5leHRMaW5lID0gbmV4dExpbmVFbmRPZmZzZXQgPT09IC0xID8gc3RyLnNsaWNlKGxpbmVFbmRPZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdHIuc2xpY2UobGluZUVuZE9mZnNldCwgbmV4dExpbmVFbmRPZmZzZXQpO1xuICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIEVPTCBjaGFyKHMpLlxuICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXlxccj9cXG4vLCAnJykucmVwbGFjZSgvXFxyJC8sICcnKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgcHJldmlvdXMgbGluZS5cbiAgaWYgKHByZXZMaW5lU3RhcnRPZmZzZXQgPj0gMCkge1xuICAgIHByZXZMaW5lID0gc3RyLnNsaWNlKHByZXZMaW5lU3RhcnRPZmZzZXQsIGxpbmVTdGFydE9mZnNldClcbiAgICAgICAgLnJlcGxhY2UoL1xccj9cXG4kLywgJycpOyAvLyBTdHJpcCB0cmFpbGluZyBFT0wgY2hhcihzKS5cbiAgfVxuXG4gIC8vIEdldCB0aGUgdGFyZ2V0IGxpbmUsIHN0cmlwcGluZyBhIHRyYWlsaW5nIGNhcnJpYWdlIHJldHVybiBpZiBuZWNlc3NhcnkuXG4gIGNvbnN0IGxpbmUgPSBzdHIuc2xpY2UobGluZVN0YXJ0T2Zmc2V0LCBsaW5lRW5kT2Zmc2V0KS5yZXBsYWNlKC9cXHIkLywgJycpO1xuXG4gIHJldHVybiB7XG4gICAgb2Zmc2V0LFxuICAgIGxpbmVOdW0sXG4gICAgY29sTnVtLFxuICAgIGxpbmUsXG4gICAgcHJldkxpbmUsXG4gICAgbmV4dExpbmUsXG4gICAgdG9TdHJpbmc6IGxpbmVBbmRDb2x1bW5Ub01lc3NhZ2VcbiAgfTtcbn07XG5cbi8vIFJldHVybiBhIG5pY2VseS1mb3JtYXR0ZWQgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhlXG4vLyBnaXZlbiBvZmZzZXQgaW4gYHN0cmAgaGlnaGxpZ2h0aW5nIGByYW5nZXNgLlxuZXhwb3J0cy5nZXRMaW5lQW5kQ29sdW1uTWVzc2FnZSA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0LCAuLi5yYW5nZXMpIHtcbiAgcmV0dXJuIGV4cG9ydHMuZ2V0TGluZUFuZENvbHVtbihzdHIsIG9mZnNldCkudG9TdHJpbmcoLi4ucmFuZ2VzKTtcbn07XG5cbmV4cG9ydHMudW5pcXVlSWQgPSAoKCkgPT4ge1xuICBsZXQgaWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIHByZWZpeCA9PiAnJyArIHByZWZpeCArIGlkQ291bnRlcisrO1xufSkoKTtcbiIsIi8qIGdsb2JhbCBfX0dMT0JBTF9PSE1fVkVSU0lPTl9fICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gV2hlbiBydW5uaW5nIHVuZGVyIE5vZGUsIHJlYWQgdGhlIHZlcnNpb24gZnJvbSBwYWNrYWdlLmpzb24uIEZvciB0aGUgYnJvd3Nlcixcbi8vIHVzZSBhIHNwZWNpYWwgZ2xvYmFsIHZhcmlhYmxlIGRlZmluZWQgaW4gdGhlIGJ1aWxkIHByb2Nlc3MgKHNlZSB3ZWJwYWNrLmNvbmZpZy5qcykuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBfX0dMT0JBTF9PSE1fVkVSU0lPTl9fID09PSAnc3RyaW5nJ1xuICAgID8gX19HTE9CQUxfT0hNX1ZFUlNJT05fX1xuICAgIDogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiIsIi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtOS4wLjAuXG4vLyBUaGVzZSBhcmUganVzdCBjYXRlZ29yaWVzIHRoYXQgYXJlIHVzZWQgaW4gRVM1L0VTMjAxNS5cbi8vIFRoZSBmdWxsIGxpc3Qgb2YgVW5pY29kZSBjYXRlZ29yaWVzIGlzIGhlcmU6IGh0dHA6Ly93d3cuZmlsZWZvcm1hdC5pbmZvL2luZm8vdW5pY29kZS9jYXRlZ29yeS9pbmRleC5odG0uXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gTGV0dGVyc1xuICBMdTogL1tBLVpcXHhDMC1cXHhENlxceEQ4LVxceERFXFx1MDEwMFxcdTAxMDJcXHUwMTA0XFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAxMEVcXHUwMTEwXFx1MDExMlxcdTAxMTRcXHUwMTE2XFx1MDExOFxcdTAxMUFcXHUwMTFDXFx1MDExRVxcdTAxMjBcXHUwMTIyXFx1MDEyNFxcdTAxMjZcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTJFXFx1MDEzMFxcdTAxMzJcXHUwMTM0XFx1MDEzNlxcdTAxMzlcXHUwMTNCXFx1MDEzRFxcdTAxM0ZcXHUwMTQxXFx1MDE0M1xcdTAxNDVcXHUwMTQ3XFx1MDE0QVxcdTAxNENcXHUwMTRFXFx1MDE1MFxcdTAxNTJcXHUwMTU0XFx1MDE1NlxcdTAxNThcXHUwMTVBXFx1MDE1Q1xcdTAxNUVcXHUwMTYwXFx1MDE2MlxcdTAxNjRcXHUwMTY2XFx1MDE2OFxcdTAxNkFcXHUwMTZDXFx1MDE2RVxcdTAxNzBcXHUwMTcyXFx1MDE3NFxcdTAxNzZcXHUwMTc4XFx1MDE3OVxcdTAxN0JcXHUwMTdEXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDN1xcdTAxQ0FcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjFcXHUwMUY0XFx1MDFGNi1cXHUwMUY4XFx1MDFGQVxcdTAxRkNcXHUwMUZFXFx1MDIwMFxcdTAyMDJcXHUwMjA0XFx1MDIwNlxcdTAyMDhcXHUwMjBBXFx1MDIwQ1xcdTAyMEVcXHUwMjEwXFx1MDIxMlxcdTAyMTRcXHUwMjE2XFx1MDIxOFxcdTAyMUFcXHUwMjFDXFx1MDIxRVxcdTAyMjBcXHUwMjIyXFx1MDIyNFxcdTAyMjZcXHUwMjI4XFx1MDIyQVxcdTAyMkNcXHUwMjJFXFx1MDIzMFxcdTAyMzJcXHUwMjNBXFx1MDIzQlxcdTAyM0RcXHUwMjNFXFx1MDI0MVxcdTAyNDMtXFx1MDI0NlxcdTAyNDhcXHUwMjRBXFx1MDI0Q1xcdTAyNEVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFXFx1MDM4RlxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBQlxcdTAzQ0ZcXHUwM0QyLVxcdTAzRDRcXHUwM0Q4XFx1MDNEQVxcdTAzRENcXHUwM0RFXFx1MDNFMFxcdTAzRTJcXHUwM0U0XFx1MDNFNlxcdTAzRThcXHUwM0VBXFx1MDNFQ1xcdTAzRUVcXHUwM0Y0XFx1MDNGN1xcdTAzRjlcXHUwM0ZBXFx1MDNGRC1cXHUwNDJGXFx1MDQ2MFxcdTA0NjJcXHUwNDY0XFx1MDQ2NlxcdTA0NjhcXHUwNDZBXFx1MDQ2Q1xcdTA0NkVcXHUwNDcwXFx1MDQ3MlxcdTA0NzRcXHUwNDc2XFx1MDQ3OFxcdTA0N0FcXHUwNDdDXFx1MDQ3RVxcdTA0ODBcXHUwNDhBXFx1MDQ4Q1xcdTA0OEVcXHUwNDkwXFx1MDQ5MlxcdTA0OTRcXHUwNDk2XFx1MDQ5OFxcdTA0OUFcXHUwNDlDXFx1MDQ5RVxcdTA0QTBcXHUwNEEyXFx1MDRBNFxcdTA0QTZcXHUwNEE4XFx1MDRBQVxcdTA0QUNcXHUwNEFFXFx1MDRCMFxcdTA0QjJcXHUwNEI0XFx1MDRCNlxcdTA0QjhcXHUwNEJBXFx1MDRCQ1xcdTA0QkVcXHUwNEMwXFx1MDRDMVxcdTA0QzNcXHUwNEM1XFx1MDRDN1xcdTA0QzlcXHUwNENCXFx1MDRDRFxcdTA0RDBcXHUwNEQyXFx1MDRENFxcdTA0RDZcXHUwNEQ4XFx1MDREQVxcdTA0RENcXHUwNERFXFx1MDRFMFxcdTA0RTJcXHUwNEU0XFx1MDRFNlxcdTA0RThcXHUwNEVBXFx1MDRFQ1xcdTA0RUVcXHUwNEYwXFx1MDRGMlxcdTA0RjRcXHUwNEY2XFx1MDRGOFxcdTA0RkFcXHUwNEZDXFx1MDRGRVxcdTA1MDBcXHUwNTAyXFx1MDUwNFxcdTA1MDZcXHUwNTA4XFx1MDUwQVxcdTA1MENcXHUwNTBFXFx1MDUxMFxcdTA1MTJcXHUwNTE0XFx1MDUxNlxcdTA1MThcXHUwNTFBXFx1MDUxQ1xcdTA1MUVcXHUwNTIwXFx1MDUyMlxcdTA1MjRcXHUwNTI2XFx1MDUyOFxcdTA1MkFcXHUwNTJDXFx1MDUyRVxcdTA1MzEtXFx1MDU1NlxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTNBMC1cXHUxM0Y1XFx1MUUwMFxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTFFMDhcXHUxRTBBXFx1MUUwQ1xcdTFFMEVcXHUxRTEwXFx1MUUxMlxcdTFFMTRcXHUxRTE2XFx1MUUxOFxcdTFFMUFcXHUxRTFDXFx1MUUxRVxcdTFFMjBcXHUxRTIyXFx1MUUyNFxcdTFFMjZcXHUxRTI4XFx1MUUyQVxcdTFFMkNcXHUxRTJFXFx1MUUzMFxcdTFFMzJcXHUxRTM0XFx1MUUzNlxcdTFFMzhcXHUxRTNBXFx1MUUzQ1xcdTFFM0VcXHUxRTQwXFx1MUU0MlxcdTFFNDRcXHUxRTQ2XFx1MUU0OFxcdTFFNEFcXHUxRTRDXFx1MUU0RVxcdTFFNTBcXHUxRTUyXFx1MUU1NFxcdTFFNTZcXHUxRTU4XFx1MUU1QVxcdTFFNUNcXHUxRTVFXFx1MUU2MFxcdTFFNjJcXHUxRTY0XFx1MUU2NlxcdTFFNjhcXHUxRTZBXFx1MUU2Q1xcdTFFNkVcXHUxRTcwXFx1MUU3MlxcdTFFNzRcXHUxRTc2XFx1MUU3OFxcdTFFN0FcXHUxRTdDXFx1MUU3RVxcdTFFODBcXHUxRTgyXFx1MUU4NFxcdTFFODZcXHUxRTg4XFx1MUU4QVxcdTFFOENcXHUxRThFXFx1MUU5MFxcdTFFOTJcXHUxRTk0XFx1MUU5RVxcdTFFQTBcXHUxRUEyXFx1MUVBNFxcdTFFQTZcXHUxRUE4XFx1MUVBQVxcdTFFQUNcXHUxRUFFXFx1MUVCMFxcdTFFQjJcXHUxRUI0XFx1MUVCNlxcdTFFQjhcXHUxRUJBXFx1MUVCQ1xcdTFFQkVcXHUxRUMwXFx1MUVDMlxcdTFFQzRcXHUxRUM2XFx1MUVDOFxcdTFFQ0FcXHUxRUNDXFx1MUVDRVxcdTFFRDBcXHUxRUQyXFx1MUVENFxcdTFFRDZcXHUxRUQ4XFx1MUVEQVxcdTFFRENcXHUxRURFXFx1MUVFMFxcdTFFRTJcXHUxRUU0XFx1MUVFNlxcdTFFRThcXHUxRUVBXFx1MUVFQ1xcdTFFRUVcXHUxRUYwXFx1MUVGMlxcdTFFRjRcXHUxRUY2XFx1MUVGOFxcdTFFRkFcXHUxRUZDXFx1MUVGRVxcdTFGMDgtXFx1MUYwRlxcdTFGMTgtXFx1MUYxRFxcdTFGMjgtXFx1MUYyRlxcdTFGMzgtXFx1MUYzRlxcdTFGNDgtXFx1MUY0RFxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRkI4LVxcdTFGQkJcXHUxRkM4LVxcdTFGQ0JcXHUxRkQ4LVxcdTFGREJcXHUxRkU4LVxcdTFGRUNcXHUxRkY4LVxcdTFGRkJcXHUyMTAyXFx1MjEwN1xcdTIxMEItXFx1MjEwRFxcdTIxMTAtXFx1MjExMlxcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTMwLVxcdTIxMzNcXHUyMTNFXFx1MjEzRlxcdTIxNDVcXHUyMTgzXFx1MkMwMC1cXHUyQzJFXFx1MkM2MFxcdTJDNjItXFx1MkM2NFxcdTJDNjdcXHUyQzY5XFx1MkM2QlxcdTJDNkQtXFx1MkM3MFxcdTJDNzJcXHUyQzc1XFx1MkM3RS1cXHUyQzgwXFx1MkM4MlxcdTJDODRcXHUyQzg2XFx1MkM4OFxcdTJDOEFcXHUyQzhDXFx1MkM4RVxcdTJDOTBcXHUyQzkyXFx1MkM5NFxcdTJDOTZcXHUyQzk4XFx1MkM5QVxcdTJDOUNcXHUyQzlFXFx1MkNBMFxcdTJDQTJcXHUyQ0E0XFx1MkNBNlxcdTJDQThcXHUyQ0FBXFx1MkNBQ1xcdTJDQUVcXHUyQ0IwXFx1MkNCMlxcdTJDQjRcXHUyQ0I2XFx1MkNCOFxcdTJDQkFcXHUyQ0JDXFx1MkNCRVxcdTJDQzBcXHUyQ0MyXFx1MkNDNFxcdTJDQzZcXHUyQ0M4XFx1MkNDQVxcdTJDQ0NcXHUyQ0NFXFx1MkNEMFxcdTJDRDJcXHUyQ0Q0XFx1MkNENlxcdTJDRDhcXHUyQ0RBXFx1MkNEQ1xcdTJDREVcXHUyQ0UwXFx1MkNFMlxcdTJDRUJcXHUyQ0VEXFx1MkNGMlxcdUE2NDBcXHVBNjQyXFx1QTY0NFxcdUE2NDZcXHVBNjQ4XFx1QTY0QVxcdUE2NENcXHVBNjRFXFx1QTY1MFxcdUE2NTJcXHVBNjU0XFx1QTY1NlxcdUE2NThcXHVBNjVBXFx1QTY1Q1xcdUE2NUVcXHVBNjYwXFx1QTY2MlxcdUE2NjRcXHVBNjY2XFx1QTY2OFxcdUE2NkFcXHVBNjZDXFx1QTY4MFxcdUE2ODJcXHVBNjg0XFx1QTY4NlxcdUE2ODhcXHVBNjhBXFx1QTY4Q1xcdUE2OEVcXHVBNjkwXFx1QTY5MlxcdUE2OTRcXHVBNjk2XFx1QTY5OFxcdUE2OUFcXHVBNzIyXFx1QTcyNFxcdUE3MjZcXHVBNzI4XFx1QTcyQVxcdUE3MkNcXHVBNzJFXFx1QTczMlxcdUE3MzRcXHVBNzM2XFx1QTczOFxcdUE3M0FcXHVBNzNDXFx1QTczRVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3NDZcXHVBNzQ4XFx1QTc0QVxcdUE3NENcXHVBNzRFXFx1QTc1MFxcdUE3NTJcXHVBNzU0XFx1QTc1NlxcdUE3NThcXHVBNzVBXFx1QTc1Q1xcdUE3NUVcXHVBNzYwXFx1QTc2MlxcdUE3NjRcXHVBNzY2XFx1QTc2OFxcdUE3NkFcXHVBNzZDXFx1QTc2RVxcdUE3NzlcXHVBNzdCXFx1QTc3RFxcdUE3N0VcXHVBNzgwXFx1QTc4MlxcdUE3ODRcXHVBNzg2XFx1QTc4QlxcdUE3OERcXHVBNzkwXFx1QTc5MlxcdUE3OTZcXHVBNzk4XFx1QTc5QVxcdUE3OUNcXHVBNzlFXFx1QTdBMFxcdUE3QTJcXHVBN0E0XFx1QTdBNlxcdUE3QThcXHVBN0FBLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjRcXHVBN0I2XFx1RkYyMS1cXHVGRjNBXXxcXHVEODAxW1xcdURDMDAtXFx1REMyN1xcdURDQjAtXFx1RENEM118XFx1RDgwM1tcXHVEQzgwLVxcdURDQjJdfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0JGXXxcXHVEODM1W1xcdURDMDAtXFx1REMxOVxcdURDMzQtXFx1REM0RFxcdURDNjgtXFx1REM4MVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCNVxcdURDRDAtXFx1RENFOVxcdUREMDRcXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQzOFxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ2Qy1cXHVERDg1XFx1RERBMC1cXHVEREI5XFx1RERENC1cXHVEREVEXFx1REUwOC1cXHVERTIxXFx1REUzQy1cXHVERTU1XFx1REU3MC1cXHVERTg5XFx1REVBOC1cXHVERUMwXFx1REVFMi1cXHVERUZBXFx1REYxQy1cXHVERjM0XFx1REY1Ni1cXHVERjZFXFx1REY5MC1cXHVERkE4XFx1REZDQV18XFx1RDgzQVtcXHVERDAwLVxcdUREMjFdLyxcbiAgTGw6IC9bYS16XFx4QjVcXHhERi1cXHhGNlxceEY4LVxceEZGXFx1MDEwMVxcdTAxMDNcXHUwMTA1XFx1MDEwN1xcdTAxMDlcXHUwMTBCXFx1MDEwRFxcdTAxMEZcXHUwMTExXFx1MDExM1xcdTAxMTVcXHUwMTE3XFx1MDExOVxcdTAxMUJcXHUwMTFEXFx1MDExRlxcdTAxMjFcXHUwMTIzXFx1MDEyNVxcdTAxMjdcXHUwMTI5XFx1MDEyQlxcdTAxMkRcXHUwMTJGXFx1MDEzMVxcdTAxMzNcXHUwMTM1XFx1MDEzN1xcdTAxMzhcXHUwMTNBXFx1MDEzQ1xcdTAxM0VcXHUwMTQwXFx1MDE0MlxcdTAxNDRcXHUwMTQ2XFx1MDE0OFxcdTAxNDlcXHUwMTRCXFx1MDE0RFxcdTAxNEZcXHUwMTUxXFx1MDE1M1xcdTAxNTVcXHUwMTU3XFx1MDE1OVxcdTAxNUJcXHUwMTVEXFx1MDE1RlxcdTAxNjFcXHUwMTYzXFx1MDE2NVxcdTAxNjdcXHUwMTY5XFx1MDE2QlxcdTAxNkRcXHUwMTZGXFx1MDE3MVxcdTAxNzNcXHUwMTc1XFx1MDE3N1xcdTAxN0FcXHUwMTdDXFx1MDE3RS1cXHUwMTgwXFx1MDE4M1xcdTAxODVcXHUwMTg4XFx1MDE4Q1xcdTAxOERcXHUwMTkyXFx1MDE5NVxcdTAxOTktXFx1MDE5QlxcdTAxOUVcXHUwMUExXFx1MDFBM1xcdTAxQTVcXHUwMUE4XFx1MDFBQVxcdTAxQUJcXHUwMUFEXFx1MDFCMFxcdTAxQjRcXHUwMUI2XFx1MDFCOVxcdTAxQkFcXHUwMUJELVxcdTAxQkZcXHUwMUM2XFx1MDFDOVxcdTAxQ0NcXHUwMUNFXFx1MDFEMFxcdTAxRDJcXHUwMUQ0XFx1MDFENlxcdTAxRDhcXHUwMURBXFx1MDFEQ1xcdTAxRERcXHUwMURGXFx1MDFFMVxcdTAxRTNcXHUwMUU1XFx1MDFFN1xcdTAxRTlcXHUwMUVCXFx1MDFFRFxcdTAxRUZcXHUwMUYwXFx1MDFGM1xcdTAxRjVcXHUwMUY5XFx1MDFGQlxcdTAxRkRcXHUwMUZGXFx1MDIwMVxcdTAyMDNcXHUwMjA1XFx1MDIwN1xcdTAyMDlcXHUwMjBCXFx1MDIwRFxcdTAyMEZcXHUwMjExXFx1MDIxM1xcdTAyMTVcXHUwMjE3XFx1MDIxOVxcdTAyMUJcXHUwMjFEXFx1MDIxRlxcdTAyMjFcXHUwMjIzXFx1MDIyNVxcdTAyMjdcXHUwMjI5XFx1MDIyQlxcdTAyMkRcXHUwMjJGXFx1MDIzMVxcdTAyMzMtXFx1MDIzOVxcdTAyM0NcXHUwMjNGXFx1MDI0MFxcdTAyNDJcXHUwMjQ3XFx1MDI0OVxcdTAyNEJcXHUwMjREXFx1MDI0Ri1cXHUwMjkzXFx1MDI5NS1cXHUwMkFGXFx1MDM3MVxcdTAzNzNcXHUwMzc3XFx1MDM3Qi1cXHUwMzdEXFx1MDM5MFxcdTAzQUMtXFx1MDNDRVxcdTAzRDBcXHUwM0QxXFx1MDNENS1cXHUwM0Q3XFx1MDNEOVxcdTAzREJcXHUwM0REXFx1MDNERlxcdTAzRTFcXHUwM0UzXFx1MDNFNVxcdTAzRTdcXHUwM0U5XFx1MDNFQlxcdTAzRURcXHUwM0VGLVxcdTAzRjNcXHUwM0Y1XFx1MDNGOFxcdTAzRkJcXHUwM0ZDXFx1MDQzMC1cXHUwNDVGXFx1MDQ2MVxcdTA0NjNcXHUwNDY1XFx1MDQ2N1xcdTA0NjlcXHUwNDZCXFx1MDQ2RFxcdTA0NkZcXHUwNDcxXFx1MDQ3M1xcdTA0NzVcXHUwNDc3XFx1MDQ3OVxcdTA0N0JcXHUwNDdEXFx1MDQ3RlxcdTA0ODFcXHUwNDhCXFx1MDQ4RFxcdTA0OEZcXHUwNDkxXFx1MDQ5M1xcdTA0OTVcXHUwNDk3XFx1MDQ5OVxcdTA0OUJcXHUwNDlEXFx1MDQ5RlxcdTA0QTFcXHUwNEEzXFx1MDRBNVxcdTA0QTdcXHUwNEE5XFx1MDRBQlxcdTA0QURcXHUwNEFGXFx1MDRCMVxcdTA0QjNcXHUwNEI1XFx1MDRCN1xcdTA0QjlcXHUwNEJCXFx1MDRCRFxcdTA0QkZcXHUwNEMyXFx1MDRDNFxcdTA0QzZcXHUwNEM4XFx1MDRDQVxcdTA0Q0NcXHUwNENFXFx1MDRDRlxcdTA0RDFcXHUwNEQzXFx1MDRENVxcdTA0RDdcXHUwNEQ5XFx1MDREQlxcdTA0RERcXHUwNERGXFx1MDRFMVxcdTA0RTNcXHUwNEU1XFx1MDRFN1xcdTA0RTlcXHUwNEVCXFx1MDRFRFxcdTA0RUZcXHUwNEYxXFx1MDRGM1xcdTA0RjVcXHUwNEY3XFx1MDRGOVxcdTA0RkJcXHUwNEZEXFx1MDRGRlxcdTA1MDFcXHUwNTAzXFx1MDUwNVxcdTA1MDdcXHUwNTA5XFx1MDUwQlxcdTA1MERcXHUwNTBGXFx1MDUxMVxcdTA1MTNcXHUwNTE1XFx1MDUxN1xcdTA1MTlcXHUwNTFCXFx1MDUxRFxcdTA1MUZcXHUwNTIxXFx1MDUyM1xcdTA1MjVcXHUwNTI3XFx1MDUyOVxcdTA1MkJcXHUwNTJEXFx1MDUyRlxcdTA1NjEtXFx1MDU4N1xcdTEzRjgtXFx1MTNGRFxcdTFDODAtXFx1MUM4OFxcdTFEMDAtXFx1MUQyQlxcdTFENkItXFx1MUQ3N1xcdTFENzktXFx1MUQ5QVxcdTFFMDFcXHUxRTAzXFx1MUUwNVxcdTFFMDdcXHUxRTA5XFx1MUUwQlxcdTFFMERcXHUxRTBGXFx1MUUxMVxcdTFFMTNcXHUxRTE1XFx1MUUxN1xcdTFFMTlcXHUxRTFCXFx1MUUxRFxcdTFFMUZcXHUxRTIxXFx1MUUyM1xcdTFFMjVcXHUxRTI3XFx1MUUyOVxcdTFFMkJcXHUxRTJEXFx1MUUyRlxcdTFFMzFcXHUxRTMzXFx1MUUzNVxcdTFFMzdcXHUxRTM5XFx1MUUzQlxcdTFFM0RcXHUxRTNGXFx1MUU0MVxcdTFFNDNcXHUxRTQ1XFx1MUU0N1xcdTFFNDlcXHUxRTRCXFx1MUU0RFxcdTFFNEZcXHUxRTUxXFx1MUU1M1xcdTFFNTVcXHUxRTU3XFx1MUU1OVxcdTFFNUJcXHUxRTVEXFx1MUU1RlxcdTFFNjFcXHUxRTYzXFx1MUU2NVxcdTFFNjdcXHUxRTY5XFx1MUU2QlxcdTFFNkRcXHUxRTZGXFx1MUU3MVxcdTFFNzNcXHUxRTc1XFx1MUU3N1xcdTFFNzlcXHUxRTdCXFx1MUU3RFxcdTFFN0ZcXHUxRTgxXFx1MUU4M1xcdTFFODVcXHUxRTg3XFx1MUU4OVxcdTFFOEJcXHUxRThEXFx1MUU4RlxcdTFFOTFcXHUxRTkzXFx1MUU5NS1cXHUxRTlEXFx1MUU5RlxcdTFFQTFcXHUxRUEzXFx1MUVBNVxcdTFFQTdcXHUxRUE5XFx1MUVBQlxcdTFFQURcXHUxRUFGXFx1MUVCMVxcdTFFQjNcXHUxRUI1XFx1MUVCN1xcdTFFQjlcXHUxRUJCXFx1MUVCRFxcdTFFQkZcXHUxRUMxXFx1MUVDM1xcdTFFQzVcXHUxRUM3XFx1MUVDOVxcdTFFQ0JcXHUxRUNEXFx1MUVDRlxcdTFFRDFcXHUxRUQzXFx1MUVENVxcdTFFRDdcXHUxRUQ5XFx1MUVEQlxcdTFFRERcXHUxRURGXFx1MUVFMVxcdTFFRTNcXHUxRUU1XFx1MUVFN1xcdTFFRTlcXHUxRUVCXFx1MUVFRFxcdTFFRUZcXHUxRUYxXFx1MUVGM1xcdTFFRjVcXHUxRUY3XFx1MUVGOVxcdTFFRkJcXHUxRUZEXFx1MUVGRi1cXHUxRjA3XFx1MUYxMC1cXHUxRjE1XFx1MUYyMC1cXHUxRjI3XFx1MUYzMC1cXHUxRjM3XFx1MUY0MC1cXHUxRjQ1XFx1MUY1MC1cXHUxRjU3XFx1MUY2MC1cXHUxRjY3XFx1MUY3MC1cXHUxRjdEXFx1MUY4MC1cXHUxRjg3XFx1MUY5MC1cXHUxRjk3XFx1MUZBMC1cXHUxRkE3XFx1MUZCMC1cXHUxRkI0XFx1MUZCNlxcdTFGQjdcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNlxcdTFGQzdcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2XFx1MUZEN1xcdTFGRTAtXFx1MUZFN1xcdTFGRjItXFx1MUZGNFxcdTFGRjZcXHUxRkY3XFx1MjEwQVxcdTIxMEVcXHUyMTBGXFx1MjExM1xcdTIxMkZcXHUyMTM0XFx1MjEzOVxcdTIxM0NcXHUyMTNEXFx1MjE0Ni1cXHUyMTQ5XFx1MjE0RVxcdTIxODRcXHUyQzMwLVxcdTJDNUVcXHUyQzYxXFx1MkM2NVxcdTJDNjZcXHUyQzY4XFx1MkM2QVxcdTJDNkNcXHUyQzcxXFx1MkM3M1xcdTJDNzRcXHUyQzc2LVxcdTJDN0JcXHUyQzgxXFx1MkM4M1xcdTJDODVcXHUyQzg3XFx1MkM4OVxcdTJDOEJcXHUyQzhEXFx1MkM4RlxcdTJDOTFcXHUyQzkzXFx1MkM5NVxcdTJDOTdcXHUyQzk5XFx1MkM5QlxcdTJDOURcXHUyQzlGXFx1MkNBMVxcdTJDQTNcXHUyQ0E1XFx1MkNBN1xcdTJDQTlcXHUyQ0FCXFx1MkNBRFxcdTJDQUZcXHUyQ0IxXFx1MkNCM1xcdTJDQjVcXHUyQ0I3XFx1MkNCOVxcdTJDQkJcXHUyQ0JEXFx1MkNCRlxcdTJDQzFcXHUyQ0MzXFx1MkNDNVxcdTJDQzdcXHUyQ0M5XFx1MkNDQlxcdTJDQ0RcXHUyQ0NGXFx1MkNEMVxcdTJDRDNcXHUyQ0Q1XFx1MkNEN1xcdTJDRDlcXHUyQ0RCXFx1MkNERFxcdTJDREZcXHUyQ0UxXFx1MkNFM1xcdTJDRTRcXHUyQ0VDXFx1MkNFRVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdUE2NDFcXHVBNjQzXFx1QTY0NVxcdUE2NDdcXHVBNjQ5XFx1QTY0QlxcdUE2NERcXHVBNjRGXFx1QTY1MVxcdUE2NTNcXHVBNjU1XFx1QTY1N1xcdUE2NTlcXHVBNjVCXFx1QTY1RFxcdUE2NUZcXHVBNjYxXFx1QTY2M1xcdUE2NjVcXHVBNjY3XFx1QTY2OVxcdUE2NkJcXHVBNjZEXFx1QTY4MVxcdUE2ODNcXHVBNjg1XFx1QTY4N1xcdUE2ODlcXHVBNjhCXFx1QTY4RFxcdUE2OEZcXHVBNjkxXFx1QTY5M1xcdUE2OTVcXHVBNjk3XFx1QTY5OVxcdUE2OUJcXHVBNzIzXFx1QTcyNVxcdUE3MjdcXHVBNzI5XFx1QTcyQlxcdUE3MkRcXHVBNzJGLVxcdUE3MzFcXHVBNzMzXFx1QTczNVxcdUE3MzdcXHVBNzM5XFx1QTczQlxcdUE3M0RcXHVBNzNGXFx1QTc0MVxcdUE3NDNcXHVBNzQ1XFx1QTc0N1xcdUE3NDlcXHVBNzRCXFx1QTc0RFxcdUE3NEZcXHVBNzUxXFx1QTc1M1xcdUE3NTVcXHVBNzU3XFx1QTc1OVxcdUE3NUJcXHVBNzVEXFx1QTc1RlxcdUE3NjFcXHVBNzYzXFx1QTc2NVxcdUE3NjdcXHVBNzY5XFx1QTc2QlxcdUE3NkRcXHVBNzZGXFx1QTc3MS1cXHVBNzc4XFx1QTc3QVxcdUE3N0NcXHVBNzdGXFx1QTc4MVxcdUE3ODNcXHVBNzg1XFx1QTc4N1xcdUE3OENcXHVBNzhFXFx1QTc5MVxcdUE3OTMtXFx1QTc5NVxcdUE3OTdcXHVBNzk5XFx1QTc5QlxcdUE3OURcXHVBNzlGXFx1QTdBMVxcdUE3QTNcXHVBN0E1XFx1QTdBN1xcdUE3QTlcXHVBN0I1XFx1QTdCN1xcdUE3RkFcXHVBQjMwLVxcdUFCNUFcXHVBQjYwLVxcdUFCNjVcXHVBQjcwLVxcdUFCQkZcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGRjQxLVxcdUZGNUFdfFxcdUQ4MDFbXFx1REMyOC1cXHVEQzRGXFx1RENEOC1cXHVEQ0ZCXXxcXHVEODAzW1xcdURDQzAtXFx1RENGMl18XFx1RDgwNltcXHVEQ0MwLVxcdURDREZdfFxcdUQ4MzVbXFx1REMxQS1cXHVEQzMzXFx1REM0RS1cXHVEQzU0XFx1REM1Ni1cXHVEQzY3XFx1REM4Mi1cXHVEQzlCXFx1RENCNi1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1RENDRlxcdURDRUEtXFx1REQwM1xcdUREMUUtXFx1REQzN1xcdURENTItXFx1REQ2QlxcdUREODYtXFx1REQ5RlxcdUREQkEtXFx1REREM1xcdURERUUtXFx1REUwN1xcdURFMjItXFx1REUzQlxcdURFNTYtXFx1REU2RlxcdURFOEEtXFx1REVBNVxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVFMVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYxQlxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY1NVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REY4RlxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDOVxcdURGQ0JdfFxcdUQ4M0FbXFx1REQyMi1cXHVERDQzXS8sXG4gIEx0OiAvW1xcdTAxQzVcXHUwMUM4XFx1MDFDQlxcdTAxRjJcXHUxRjg4LVxcdTFGOEZcXHUxRjk4LVxcdTFGOUZcXHUxRkE4LVxcdTFGQUZcXHUxRkJDXFx1MUZDQ1xcdTFGRkNdLyxcbiAgTG06IC9bXFx1MDJCMC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzc0XFx1MDM3QVxcdTA1NTlcXHUwNjQwXFx1MDZFNVxcdTA2RTZcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwOTcxXFx1MEU0NlxcdTBFQzZcXHUxMEZDXFx1MTdEN1xcdTE4NDNcXHUxQUE3XFx1MUM3OC1cXHUxQzdEXFx1MUQyQy1cXHUxRDZBXFx1MUQ3OFxcdTFEOUItXFx1MURCRlxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MkM3Q1xcdTJDN0RcXHUyRDZGXFx1MkUyRlxcdTMwMDVcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzA5RFxcdTMwOUVcXHUzMEZDLVxcdTMwRkVcXHVBMDE1XFx1QTRGOC1cXHVBNEZEXFx1QTYwQ1xcdUE2N0ZcXHVBNjlDXFx1QTY5RFxcdUE3MTctXFx1QTcxRlxcdUE3NzBcXHVBNzg4XFx1QTdGOFxcdUE3RjlcXHVBOUNGXFx1QTlFNlxcdUFBNzBcXHVBQUREXFx1QUFGM1xcdUFBRjRcXHVBQjVDLVxcdUFCNUZcXHVGRjcwXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MUFbXFx1REY0MC1cXHVERjQzXXxcXHVEODFCW1xcdURGOTMtXFx1REY5RlxcdURGRTBdLyxcbiAgTG86IC9bXFx4QUFcXHhCQVxcdTAxQkJcXHUwMUMwLVxcdTAxQzNcXHUwMjk0XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjNGXFx1MDY0MS1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwODAwLVxcdTA4MTVcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzItXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBEMC1cXHUxMEZBXFx1MTBGRC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0RDXFx1MTgyMC1cXHUxODQyXFx1MTg0NC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzc3XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUyMTM1LVxcdTIxMzhcXHUyRDMwLVxcdTJENjdcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA2XFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBMDE0XFx1QTAxNi1cXHVBNDhDXFx1QTREMC1cXHVBNEY3XFx1QTUwMC1cXHVBNjBCXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjZFXFx1QTZBMC1cXHVBNkU1XFx1QTc4RlxcdUE3RjdcXHVBN0ZCLVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5RTAtXFx1QTlFNFxcdUE5RTctXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE2RlxcdUFBNzEtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREJcXHVBQURDXFx1QUFFMC1cXHVBQUVBXFx1QUFGMlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGNjYtXFx1RkY2RlxcdUZGNzEtXFx1RkY5RFxcdUZGQTAtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwMVtcXHVEQzUwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OF18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXG5cbiAgLy8gTnVtYmVyc1xuICBObDogL1tcXHUxNkVFLVxcdTE2RjBcXHUyMTYwLVxcdTIxODJcXHUyMTg1LVxcdTIxODhcXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzOC1cXHUzMDNBXFx1QTZFNi1cXHVBNkVGXXxcXHVEODAwW1xcdURENDAtXFx1REQ3NFxcdURGNDFcXHVERjRBXFx1REZEMS1cXHVERkQ1XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RV0vLFxuICBOZDogL1swLTlcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcXHUwN0MwLVxcdTA3QzlcXHUwOTY2LVxcdTA5NkZcXHUwOUU2LVxcdTA5RUZcXHUwQTY2LVxcdTBBNkZcXHUwQUU2LVxcdTBBRUZcXHUwQjY2LVxcdTBCNkZcXHUwQkU2LVxcdTBCRUZcXHUwQzY2LVxcdTBDNkZcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENkZcXHUwREU2LVxcdTBERUZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDkwLVxcdTEwOTlcXHUxN0UwLVxcdTE3RTlcXHUxODEwLVxcdTE4MTlcXHUxOTQ2LVxcdTE5NEZcXHUxOUQwLVxcdTE5RDlcXHUxQTgwLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQjUwLVxcdTFCNTlcXHUxQkIwLVxcdTFCQjlcXHUxQzQwLVxcdTFDNDlcXHUxQzUwLVxcdTFDNTlcXHVBNjIwLVxcdUE2MjlcXHVBOEQwLVxcdUE4RDlcXHVBOTAwLVxcdUE5MDlcXHVBOUQwLVxcdUE5RDlcXHVBOUYwLVxcdUE5RjlcXHVBQTUwLVxcdUFBNTlcXHVBQkYwLVxcdUFCRjlcXHVGRjEwLVxcdUZGMTldfFxcdUQ4MDFbXFx1RENBMC1cXHVEQ0E5XXxcXHVEODA0W1xcdURDNjYtXFx1REM2RlxcdURDRjAtXFx1RENGOVxcdUREMzYtXFx1REQzRlxcdURERDAtXFx1REREOVxcdURFRjAtXFx1REVGOV18W1xcdUQ4MDVcXHVEODA3XVtcXHVEQzUwLVxcdURDNTlcXHVEQ0QwLVxcdURDRDlcXHVERTUwLVxcdURFNTlcXHVERUMwLVxcdURFQzlcXHVERjMwLVxcdURGMzldfFxcdUQ4MDZbXFx1RENFMC1cXHVEQ0U5XXxcXHVEODFBW1xcdURFNjAtXFx1REU2OVxcdURGNTAtXFx1REY1OV18XFx1RDgzNVtcXHVERkNFLVxcdURGRkZdfFxcdUQ4M0FbXFx1REQ1MC1cXHVERDU5XS8sXG5cbiAgLy8gTWFya3NcbiAgTW46IC9bXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDQtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlFMlxcdTA5RTNcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEIwMVxcdTBCM0NcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTZcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkMwXFx1MEJDRFxcdTBDMDBcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENFMlxcdTBDRTNcXHUwRDAxXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENjJcXHUwRDYzXFx1MERDQVxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCOVxcdTBFQkJcXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUIwM1xcdTFCMzRcXHUxQjM2LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY1XFx1MURGQi1cXHUxREZGXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkRcXHUzMDk5XFx1MzA5QVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQ0EtXFx1RERDQ1xcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNDXFx1REY0MFxcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGOEYtXFx1REY5Ml18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY3LVxcdURENjlcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0vLFxuICBNYzogL1tcXHUwOTAzLVxcdTA5MDNdfFtcXHUwOTNFLVxcdTA5NDBdfFtcXHUwOTQ5LVxcdTA5NENdfFtcXHUwOTgyLVxcdTA5ODNdfFtcXHUwOUJFLVxcdTA5QzBdfFtcXHUwOUM3LVxcdTA5QzhdfFtcXHUwOUNCLVxcdTA5Q0NdfFtcXHUwOUQ3LVxcdTA5RDddfFtcXHUwQTNFLVxcdTBBNDBdfFtcXHUwQTgzLVxcdTBBODNdfFtcXHUwQUJFLVxcdTBBQzBdfFtcXHUwQUM5LVxcdTBBQzldfFtcXHUwQUNCLVxcdTBBQ0NdfFtcXHUwQjAyLVxcdTBCMDNdfFtcXHUwQjNFLVxcdTBCM0VdfFtcXHUwQjQwLVxcdTBCNDBdfFtcXHUwQjQ3LVxcdTBCNDhdfFtcXHUwQjRCLVxcdTBCNENdfFtcXHUwQjU3LVxcdTBCNTddfFtcXHUwQjgzLVxcdTBCODNdfFtcXHUwQkJFLVxcdTBCQkZdfFtcXHUwQkMxLVxcdTBCQzJdfFtcXHUwQkM2LVxcdTBCQzhdfFtcXHUwQkNBLVxcdTBCQ0NdfFtcXHUwQkQ3LVxcdTBCRDddfFtcXHUwQzAxLVxcdTBDMDNdfFtcXHUwQzQxLVxcdTBDNDRdfFtcXHUwQzgyLVxcdTBDODNdfFtcXHUwQ0JFLVxcdTBDQkVdfFtcXHUwQ0MwLVxcdTBDQzRdfFtcXHUwQ0M3LVxcdTBDQzhdfFtcXHUwQ0NBLVxcdTBDQ0JdfFtcXHUwQ0Q1LVxcdTBDRDZdfFtcXHUwRDAyLVxcdTBEMDNdfFtcXHUwRDNFLVxcdTBENDBdfFtcXHUwRDQ2LVxcdTBENDhdfFtcXHUwRDRBLVxcdTBENENdfFtcXHUwRDU3LVxcdTBENTddfFtcXHUwRjNFLVxcdTBGM0ZdfFtcXHUwRjdGLVxcdTBGN0ZdLyxcblxuICAvLyBQdW5jdHVhdGlvbiwgQ29ubmVjdG9yXG4gIFBjOiAvW19cXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZGM0ZdLyxcblxuICAvLyBTZXBhcmF0b3IsIFNwYWNlXG4gIFpzOiAvWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLyxcblxuICAvLyBUaGVzZSB0d28gYXJlIG5vdCByZWFsIFVuaWNvZGUgY2F0ZWdvcmllcywgYnV0IG91ciB1c2VmdWwgZm9yIE9obS5cbiAgLy8gTCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFsbCB0aGUgbGV0dGVyIGNhdGVnb3JpZXMuXG4gIC8vIEx0bW8gaXMgYSBjb21iaW5hdGlvbiBvZiBMdCwgTG0sIGFuZCBMby5cbiAgTDogL1tBLVphLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjQwXFx1REY0Mi1cXHVERjQ5XFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdUREMDAtXFx1REQ0M118XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcbiAgTHRtbzogL1tcXHUwMUM1XFx1MDFDOFxcdTAxQ0JcXHUwMUYyXFx1MUY4OC1cXHUxRjhGXFx1MUY5OC1cXHUxRjlGXFx1MUZBOC1cXHUxRkFGXFx1MUZCQ1xcdTFGQ0NcXHUxRkZDXXxbXFx1MDJCMC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzc0XFx1MDM3QVxcdTA1NTlcXHUwNjQwXFx1MDZFNVxcdTA2RTZcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwOTcxXFx1MEU0NlxcdTBFQzZcXHUxMEZDXFx1MTdEN1xcdTE4NDNcXHUxQUE3XFx1MUM3OC1cXHUxQzdEXFx1MUQyQy1cXHUxRDZBXFx1MUQ3OFxcdTFEOUItXFx1MURCRlxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MkM3Q1xcdTJDN0RcXHUyRDZGXFx1MkUyRlxcdTMwMDVcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzA5RFxcdTMwOUVcXHUzMEZDLVxcdTMwRkVcXHVBMDE1XFx1QTRGOC1cXHVBNEZEXFx1QTYwQ1xcdUE2N0ZcXHVBNjlDXFx1QTY5RFxcdUE3MTctXFx1QTcxRlxcdUE3NzBcXHVBNzg4XFx1QTdGOFxcdUE3RjlcXHVBOUNGXFx1QTlFNlxcdUFBNzBcXHVBQUREXFx1QUFGM1xcdUFBRjRcXHVBQjVDLVxcdUFCNUZcXHVGRjcwXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MUFbXFx1REY0MC1cXHVERjQzXXxcXHVEODFCW1xcdURGOTMtXFx1REY5RlxcdURGRTBdfFtcXHhBQVxceEJBXFx1MDFCQlxcdTAxQzAtXFx1MDFDM1xcdTAyOTRcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2M0ZcXHUwNjQxLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA4MDAtXFx1MDgxNVxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3Mi1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ1XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEQwLVxcdTEwRkFcXHUxMEZELVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RENcXHUxODIwLVxcdTE4NDJcXHUxODQ0LVxcdTE4NzdcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDNzdcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTIxMzUtXFx1MjEzOFxcdTJEMzAtXFx1MkQ2N1xcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDZcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUEwMTRcXHVBMDE2LVxcdUE0OENcXHVBNEQwLVxcdUE0RjdcXHVBNTAwLVxcdUE2MEJcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NkVcXHVBNkEwLVxcdUE2RTVcXHVBNzhGXFx1QTdGN1xcdUE3RkItXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlFMC1cXHVBOUU0XFx1QTlFNy1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTZGXFx1QUE3MS1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQlxcdUFBRENcXHVBQUUwLVxcdUFBRUFcXHVBQUYyXFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkY2Ni1cXHVGRjZGXFx1RkY3MS1cXHVGRjlEXFx1RkZBMC1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjQwXFx1REY0Mi1cXHVERjQ5XFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXXxcXHVEODAxW1xcdURDNTAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXXxcXHVEODIxW1xcdURDMDAtXFx1REZFQ118XFx1RDgyMltcXHVEQzAwLVxcdURFRjJdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdL1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDtcbmZ1bmN0aW9uIGV4dGVuZChvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8IHR5cGVvZiBhZGQgIT09ICdvYmplY3QnKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufVxuIiwidmFyIHYxID0gcmVxdWlyZSgnLi92MScpO1xudmFyIHY0ID0gcmVxdWlyZSgnLi92NCcpO1xuXG52YXIgdXVpZCA9IHY0O1xudXVpZC52MSA9IHYxO1xudXVpZC52NCA9IHY0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1cbiAgXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsImNvbnN0IG1lcnJpYW0gPSB7XG4gICAgbmFtZTogXCJNZXJyaWFtQVBJXCIsXG4gICAgbG9hZDogZnVuY3Rpb24odXJsKXtcbiAgICAgICAgdGhpcy5zcmMgPSB1cmw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcmVzcG9uc2U6IG51bGwsXG4gICAgY2FjaGU6IG51bGwsXG4gICAgY2FjaGVOZXh0SXRlbTogbnVsbCxcbiAgICBjdXJyZW50UmVzcG9uc2VJdGVtSW5kZXg6IC0xLFxuICAgIHNyYzogbnVsbCxcbiAgICBnZXQ6IGFzeW5jIGZ1bmN0aW9uKHByZXJlcXVpc2l0ZSwgYXJnKXtcbiAgICAgICAgaWYoYXJnKXtcbiAgICAgICAgICAgIGlmKCF0aGlzLmNhY2hlKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vIHJlc3VsdCBoYXMgYmVlbiBmZXRjaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYXJnID09IFwibmV4dFwiKXtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0cyA9IHRoaXMuY2FjaGUucmVzdWx0cztcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZUl0ZW1JbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudFJlc3BvbnNlSXRlbUluZGV4ID49IHJlc3VsdHMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzcG9uc2VJdGVtSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5jYWNoZS5yZXN1bHRzW3RoaXMuY3VycmVudFJlc3BvbnNlSXRlbUluZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIHJlc3VsdCBpbiB0aGUgbmV4dCBpdGVtIGNhY2hlXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZU5leHRJdGVtID0gdGhpcy5jYWNoZS5yZXN1bHRzW3RoaXMuY3VycmVudFJlc3BvbnNlSXRlbUluZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5yZXNwb25zZSwgbnVsbCwgJ1xcdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGVyZSB3ZSBhc3N1bWUgdGhhdCB0aGUgYXJnIGlzIGEga2V5IGluIHRoZSBuZXh0IGl0ZW0gY2FjaGVcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLmNhY2hlTmV4dEl0ZW1bYXJnXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBwYXJzZVByZXJlcXVpc2l0ZShwcmVyZXF1aXNpdGUpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgICAgIFwiaGVhZGVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJvZHlcIjogSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5zcmMsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykgeyAvLyBpZiBIVFRQLXN0YXR1cyBpcyAyMDAtMjk5XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHJlc3BvbnNlIGJvZHkgKHRoZSBtZXRob2QgZXhwbGFpbmVkIGJlbG93KVxuICAgICAgICAgICAgbGV0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0ganNvbjtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucmVzcG9uc2UsIG51bGwsICdcXHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJIVFRQLUVycm9yOiBcIiArIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbmxldCBwYXJzZVByZXJlcXVpc2l0ZSA9IChwKSA9PiB7XG4gICAgbGV0IHBMaXN0ID0gcC5zcGxpdChcIjtcIik7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBwTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCBrZXkgPSBpdGVtLnNwbGl0KFwiOlwiKVswXTtcbiAgICAgICAgbGV0IHZhbHVlID0gaXRlbS5yZXBsYWNlKGAke2tleX06YCwgXCJcIik7XG4gICAgICAgIHN3aXRjaChrZXkpe1xuICAgICAgICBjYXNlIFwiZmllbGRzXCI6XG4gICAgICAgICAgICBwYXlsb2FkW1wiZmllbGRzXCJdID0gdmFsdWUuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2VpZ2h0c1wiOlxuICAgICAgICAgICAgbGV0IHdlaWdodHMgPSB7fTtcbiAgICAgICAgICAgIHZhbHVlLnNwbGl0KFwiLFwiKS5mb3JFYWNoKCh3KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IFt3X25hbWUsIHdfdmFsdWVdID0gdy5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgd2VpZ2h0c1t3X25hbWVdID0gTnVtYmVyKHdfdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXlsb2FkW1wid2VpZ2h0c1wiXSA9IHdlaWdodHM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRvY19pZHNcIjpcbiAgICAgICAgICAgIHBheWxvYWRbXCJkb2NfaWRzXCJdID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaW1pdFwiOlxuICAgICAgICAgICAgcGF5bG9hZFtcImxpbWl0XCJdID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5cblxuZXhwb3J0IHtcbiAgICBtZXJyaWFtLFxuICAgIG1lcnJpYW0gYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCBUZXN0IGZyb20gJy4vdGVzdEFQSS5qcyc7XG5pbXBvcnQgTWVycmlhbSBmcm9tICcuL21lcnJpYW0uanMnO1xuXG5jb25zdCBwbHVnaW5zID0ge1xuICAgIFwiTWVycmlhbUFQSVwiOiBNZXJyaWFtLFxuICAgIFwiVGVzdEFQSVwiOiBUZXN0XG59XG5cbmV4cG9ydCB7XG4gICAgcGx1Z2lucyxcbiAgICBwbHVnaW5zIGFzIGRlZmF1bHRcbn1cbiIsImNvbnN0IHRlc3QgPSB7XG4gICAgbmFtZTogXCJUZXN0QVBJXCIsXG4gICAgbG9hZDogZnVuY3Rpb24odXJsKXtcbiAgICAgICAgdGhpcy5zcmMgPSB1cmw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcmVzcG9uc2U6IG51bGwsXG4gICAgc3JjOiBudWxsLFxuICAgIGdldDogYXN5bmMgZnVuY3Rpb24ocHJlcmVxdWlzaXRlLCBrZXkpe1xuICAgICAgICBpZihrZXkpe1xuICAgICAgICAgICAgaWYoIXRoaXMucmVzcG9uc2Upe1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm8gcmVzdWx0IGhhcyBiZWVuIGZldGNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcmMgPSB0aGlzLnNyYztcbiAgICAgICAgaWYocHJlcmVxdWlzaXRlKXtcbiAgICAgICAgICAgIHNyYyA9IHNyYyArIFwiL1wiICsgcHJlcmVxdWlzaXRlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNyYyk7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykgeyAvLyBpZiBIVFRQLXN0YXR1cyBpcyAyMDAtMjk5XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHJlc3BvbnNlIGJvZHkgKHRoZSBtZXRob2QgZXhwbGFpbmVkIGJlbG93KVxuICAgICAgICAgICAgbGV0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0ganNvbjtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJIVFRQLUVycm9yOiBcIiArIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7XG4gICAgdGVzdCxcbiAgICB0ZXN0IGFzIGRlZmF1bHRcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9